---
title: Methods and systems for performing dynamic power management via frequency and voltage scaling
abstract: Methods and systems are provided for dynamically managing the power consumption of a digital system. These methods and systems broadly provide for varying the frequency and voltage of one or more clocks of a digital system upon request by an entity of the digital system. An entity may request that the frequency of a clock of the processor of the digital system be changed. After the frequency is changed, the voltage point of the voltage regulator of the digital system is automatically changed to the lowest voltage point required for the new frequency if there is a single clock on the processor. If the processor is comprised of multiple processing cores with associated clocks, the frequency is changed to the lowest voltage point required by all frequencies of all clocks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07155617&OS=07155617&RS=07155617
owner: Texas Instruments Incorporated
number: 07155617
owner_city: Dallas
owner_country: US
publication_date: 20030613
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority to provisional application Ser. No. 60\/400,426 filed Aug. 1, 2002 (TI-34977PS). This application is related to copending applications Ser. No. 10\/461,289 entitled Methodology for Coordinating and Tuning Application Power (TI-35526) and Ser. No. 10\/461,025 entitled Methodology for Managing Power Consumption in an Application (TI-35525).","This invention generally relates to software development systems, and more specifically to improvements in software support for power management in systems and applications.","Power efficiency is a key requirement across a broad range of systems, ranging from small portable devices, to rack-mounted processor farms. Even in systems where high performance is key, power efficiency is still a care-about. Power efficiency is determined both by hardware design and component choice, and software-based runtime power management techniques.","In wired systems power efficiency will typically enable a reduction in power supply capacity, as well as a reduction in cooling requirements and fan noise, and ultimately product cost. Power efficiency can allow an increase in component density as well. For example, a designer may be limited by the number of processors that can be placed on a board simply because the cumulative power consumption would exceed compliance limits for the bus specification. Increased component density can result either in increased capacity, a reduction in product size, or both.","In mobile devices, power efficiency means increased battery life, and a longer time between recharge. It also enables selection of smaller batteries, possibly a different battery technology, and a corresponding reduction in product size.","Power efficiency is a key product differentiator. A simple example is a buyer shopping for an MP3 player at an electronics store. In a side-by-side comparison of two players with the same features, the decision will likely go to the player with the longest time between recharge. In many scenarios, the success or failure of a product in its marketplace will be determined by its power efficiency.","The total power consumption of a CMOS circuit is the sum of both active and static power consumption: P=P+P. Active power consumption occurs when the circuit is active, switching from one logic state to another. Active power consumption is caused both by switching current (that needed to charge internal nodes), and through current (that which flows when both P and N-channel transistors are both momentarily on). Active power consumption can be approximated by the equation: P=C\u00d7F\u00d7V\u00d7N, where Cis the dynamic capacitance, F is the switching frequency, V, is the supply voltage, and N, is the number of bits switching. An additional relationship is that voltage (V) determines the maximum switching frequency (F) for stable operation. The important concepts here are: 1) the active power consumption is linearly related to switching frequency, and quadratically related to the supply voltage, and 2) the maximum switching frequency is determined by the supply voltage.","If an application can reduce the CPU clock rate and still meet its processing requirements, it can have a proportional savings in power dissipation. Due to the quadratic relationship, if the frequency can be reduced safely, and this frequency is compatible with a lower operating voltage available on the platform, then in addition to the savings due to the reduced clock frequency, a potentially significant additional savings can occur by reducing the voltage. However, it is important to recognize that for a given task set, reducing the CPU clock rate also proportionally extends the execution time of the same task set, requiring careful analysis of the application ensure that it still meets its real-time requirements. The potential savings provided by dynamic voltage and frequency scaling (DVFS) has been extensively studied in academic literature, with emphasis on ways to reduce the scaling latencies, improve the voltage scaling range, and schedule tasks so that real-time deadlines can still be met. For example, see ---, IEEE ISBN 0-7803-5974-7, Seongsoo Lee, Takayasu Sakurai, 2000---, IEEE Design & Test of Computers, Dongkun Shin, Jihong Kim, Seongsoo Lee, 2001; and ---, DAC2000, ACM 1-58113-188-7, Seongsoo Lee, Takayasu Sakurai 2000.","Static power consumption is one component of the total power consumption equation. Static power consumption occurs even when the circuit is not switching, due to reverse-bias leakage. Traditionally, the static power consumption of a CMOS circuit has been very small in comparison to the active power consumption. Embedded applications will typically idle the CPU clock during inactivity to eliminate active power, which dramatically reduces total power consumption. However, new higher-performance transistors are bringing significant boosts in leakage currents, which requires new attention to the static power consumption component of the total power equation.","There are many known techniques utilized both in hardware design and at run-time to help reduce power dissipation. Table 1 lists some up-front hardware design decisions for reducing power dissipation. Table 2 lists common techniques employed at run-time to reduce power dissipation. Table 3 lists some fundamental challenges to utilizing these power management techniques in real-time systems.",{"@attributes":{"id":"p-0012","num":"0011"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"252pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Decision","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Choose a low-power","Choosing a power-efficient process (e.g., CMOS) is perhaps the most important up-"]},{"entry":["technology base","front decision, and directly drives power efficiency."]},{"entry":["Partition separate voltage","By partitioning separate domains, different components can be wired to the"]},{"entry":["and clock domains","appropriate power rail and clock line, eliminating the need for all circuitry to operate"]},{"entry":[{},"at the maximum required by any specific module."]},{"entry":["Enable scaling of voltage","Designing in programmable clock generators allows application code a linear savings"]},{"entry":["and frequency","in power when it can scale down the clock frequency. A programmable voltage"]},{"entry":[{},"source allows the potential for an additional quadratic power savings when the voltage"]},{"entry":[{},"can be reduced as well, because of reduced frequency. Also, designing the hardware"]},{"entry":[{},"to minimize scaling latencies will enable broader usage of the scaling technique."]},{"entry":["Enable gating of different","Some static RAMs require less voltage in retention mode vs. normal operation mode."]},{"entry":["voltages to modules","By designing in voltage gating circuitry, power consumption can be reduced during"]},{"entry":[{},"inactivity while still retaining state."]},{"entry":["Utilize interrupts to alleviate","Often software is required to poll an interface periodically to detect events. For"]},{"entry":["polling by software","example, a keypad interface routine might need to spin or periodically wake to detect"]},{"entry":[{},"and resolve a keypad input. Designing the interface to generate an interrupt on"]},{"entry":[{},"keypad input will not only simplify the software, but it will also enable event-driven"]},{"entry":[{},"processing and activation of processor idle and sleep modes while waiting for"]},{"entry":[{},"interrupts."]},{"entry":["Reduce loading of outputs","Decreasing capacitive and DC loading on output pins will reduce total power"]},{"entry":[{},"consumption."]},{"entry":["Use hierarchical memory","Depending on the application, utilizing cache and instruction buffers can drastically"]},{"entry":["model","reduce off-chip memory accesses and subsequent power draw."]},{"entry":["Boot with resources un-","Many systems boot in a fully active state, meaning full power consumption. If certain"]},{"entry":["powered","sub-systems can be left un-powered on boot, and later turned on when really needed,"]},{"entry":[{},"it eliminates unnecessary wasted power."]},{"entry":["Minimize number of active","Using shared clocks can reduce the number of active clock generators, and their"]},{"entry":["phase lock loops (PLL)","corresponding power draw. For example, a processor's on-board PLL can be"]},{"entry":[{},"bypassed in favor of an external clock signal."]},{"entry":["Use clock dividers for fast","A common barrier to highly dynamic frequency scaling is the latency of re-locking a"]},{"entry":["selection of an alternate","PLL on a frequency change. Adding a clock divider circuit at the output of the PLL"]},{"entry":["frequency","will allow instantaneous selection of a different clock frequency."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0013","num":"0012"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"252pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Technique","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Gate clocks off when not","As described above, active power dissipation in a CMOS circuit occurs only when the"]},{"entry":["needed","circuit is clocked. By turning off clocks that are not needed, unnecessary active"]},{"entry":[{},"power consumption is eliminated. Most processors incorporate a mechanism to"]},{"entry":[{},"temporarily suspend active power consumption in the CPU while waiting for an"]},{"entry":[{},"external event. This idling of the CPU clock is typically triggered via a \u2018halt\u2019 or \u2018idle\u2019"]},{"entry":[{},"instruction, called during application or OS idle time. Some processors partition"]},{"entry":[{},"multiple clock domains, which can be individually idled to suspend active power"]},{"entry":[{},"consumption in unused modules. For example, in the Texas Instruments"]},{"entry":[{},"TMS320C5510 DSP, six separate clock domains, CPU, cache, DMA, peripheral"]},{"entry":[{},"clocks, clock generator, and external memory interface, can be selectively idled."]},{"entry":["Activate peripheral low-","Some peripherals have built-in low power modes that can be activated when the"]},{"entry":["power modes","peripheral is not immediately needed. For example, a device driver managing a codec"]},{"entry":[{},"over a serial port can command the codec to a low power mode when there is no"]},{"entry":[{},"audio to be played, or if the whole system is being transitioned to a low-power mode."]},{"entry":["Leverage peripheral","Some peripherals have built-in activity detectors that can be programmed to power"]},{"entry":["activity detectors","down the peripheral after a period of inactivity. For example, a disk drive can be"]},{"entry":[{},"automatically spun down when the drive is not being accessed, and spun back up"]},{"entry":[{},"when needed again."]},{"entry":["Utilize auto-refresh modes","Dynamic memories and displays will typically have a self or auto-refresh mode where"]},{"entry":[{},"the device will efficiently manage the refresh operation on its own."]},{"entry":["On boot actively turn off","Processors typically boot up fully powered, at a maximum clock rate, ready to do"]},{"entry":["un-necessary power","work. There will inevitably be resources powered that are not needed yet, or that may"]},{"entry":["consumers","never be used in the course of the application. At boot time, the application or OS"]},{"entry":[{},"may traverse the system, turning off\/idling unnecessary power consumers."]},{"entry":["Gate power to subsystems","A system may include a power-hungry module that need not be powered at all times."]},{"entry":["only as needed","For example, a mobile device may have a radio subsystem that only needs to be ON"]},{"entry":[{},"when in range of the device with which it communicates. By gating power OFF\/ON"]},{"entry":[{},"on demand, unnecessary power dissipation can be avoided."]},{"entry":["Benchmark application to","Typically, systems are designed with excess processing capacity built in, either for"]},{"entry":["find minimum required","safety purposes, or for future extensibility and upgrades. For the latter case, a"]},{"entry":["frequency and voltages","common development technique is to fully exercise and benchmark the application"]},{"entry":[{},"to determine excess capacity, and then \u2018dial-down\u2019 the operating frequency and"]},{"entry":[{},"voltage to that which enables the application to fully meet its requirements, but"]},{"entry":[{},"minimizes excess capacity. Frequency and voltage are usually not changed at"]},{"entry":[{},"runtime, but are set at boot time, based upon the benchmarking activity."]},{"entry":["Adjust CPU frequency and","Another technique for addressing excess processing capacity is to periodically"]},{"entry":["voltage based upon gross","sample CPU utilization at runtime, and then dynamically adjust the frequency and"]},{"entry":["activity","voltage based upon the empirical utilization of the processor. This \u201cinterval-based"]},{"entry":[{},"scheduling\u201d technique improves on the power-savings of the previous static"]},{"entry":[{},"benchmarking technique because it takes advantage of the dynamic variability of"]},{"entry":[{},"the application's processing needs."]},{"entry":["Dynamically schedule CPU","The \u201cinterval-based scheduling\u201d technique enables dynamic adjustments to"]},{"entry":["frequency and voltage to","processing capacity based upon history data, but typically does not do well at"]},{"entry":["match predicted work load","anticipating the future needs of the application, and is therefore not acceptable for"]},{"entry":[{},"systems with hard real-time deadlines. An alternate technique is to dynamically"]},{"entry":[{},"vary the CPU frequency and voltage based upon predicted workload. Using"]},{"entry":[{},"dynamic, fine-grained comparison of work completed vs. the worst-case execution"]},{"entry":[{},"time (WCET) and deadline of the next task, the CPU frequency and voltage can be"]},{"entry":[{},"dynamically tuned to the minimum required. This technique is most applicable to"]},{"entry":[{},"specialized systems with data-dependent processing requirements that can be"]},{"entry":[{},"accurately characterized. Inability to fully characterize an application usually limits"]},{"entry":[{},"the general applicability of this technique. Study of efficient and stable scheduling"]},{"entry":[{},"algorithms in the presence of dynamic frequency and voltage scaling is a topic of"]},{"entry":[{},"much on-going research."]},{"entry":["Optimize execution speed of","Developers often optimize their code for execution speed. However, in many"]},{"entry":["code","situations the speed may be good enough, and further optimizations are not"]},{"entry":[{},"considered. When considering power consumption, faster code will typically mean"]},{"entry":[{},"more time for leveraging idle or sleep modes, or a greater reduction in the CPU"]},{"entry":[{},"frequency requirements. In some situations, speed optimizations may actually"]},{"entry":[{},"increase power consumption (e.g., more parallelism and subsequent circuit activity),"]},{"entry":[{},"but in others, there may be power savings."]},{"entry":["Use low-power code","Different processor instructions exercise different functional units and data paths,"]},{"entry":["sequences and data patterns","resulting in different power requirements. Additionally, because of data bus line"]},{"entry":[{},"capacitances and the inter-signal capacitances between bus lines, the amount of"]},{"entry":[{},"power required is affected by the data patterns that are transferred over the data"]},{"entry":[{},"buses. And, the power requirements are affected by the signaling patterns chosen"]},{"entry":[{},"(1s vs. 0s) for external interfaces (e.g., serial ports). Analyzing the affects of"]},{"entry":[{},"individual instructions and data patterns is an extreme technique that is sometimes"]},{"entry":[{},"used to maximize power efficiency."]},{"entry":["Scale application and OS","Architecting application and OS code bases to be scalable can reduce memory"]},{"entry":["footprint based upon","requirements and, therefore, the subsequent runtime power requirements. For"]},{"entry":["minimal requirements","example, by simply placing individual functions or APIs into individual linkable"]},{"entry":[{},"objects, the linker can link in only the code\/data needed and avoid linking dead"]},{"entry":[{},"code\/data."]},{"entry":["Use code overlays to reduce","For some applications, dynamically overlaying code from non-volatile to fast"]},{"entry":["fast memory requirements","memory will reduce both the cost and power consumption of additional fast"]},{"entry":[{},"memory."]},{"entry":["Tradeoff accuracy vs. power","Accepting less accuracy in some calculations can drastically reduce processing"]},{"entry":["consumption","requirements. For example, certain signal processing applications can tolerate more"]},{"entry":[{},"noise in the results, which enables reduced processing and reduced power"]},{"entry":[{},"consumption."]},{"entry":["Enter a reduced capability","When there is a change in the capabilities of the power source, e.g., when going"]},{"entry":["mode on a power change","from AC to battery power, a common technique is to enter a reduced capability"]},{"entry":[{},"mode with more aggressive runtime power management. A typical example is a"]},{"entry":[{},"laptop computer, where the OS is notified on a switch to battery power, and"]},{"entry":[{},"activates a different power management policy, with a lower CPU clock rate, a"]},{"entry":[{},"shorter timeout before the screen blanks or the disk spins down, etc. The OS power"]},{"entry":[{},"policy implements a tradeoff between responsiveness and extending battery life. A"]},{"entry":[{},"similar technique can be employed in battery-only systems, where a battery monitor"]},{"entry":[{},"detects reduced capacity, and activates more aggressive power management, such"]},{"entry":[{},"as slowing down the CPU, not enabling image viewing on the digital camera's LCD"]},{"entry":[{},"display, etc."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0014","num":"0013"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Challenge","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Scaling CPU frequency with","For many processors the same clock that feeds the CPU also feeds on-chip"]},{"entry":["workload often affects","peripherals, so scaling the clock based upon CPU workload can have side-affects"]},{"entry":["peripherals","on peripheral operation. The peripherals may need to be reprogrammed before"]},{"entry":[{},"and\/or after the scaling operation, and this may be difficult if a pre-existing (non"]},{"entry":[{},"power-aware) device driver is being used to manage the peripheral. Additionally,"]},{"entry":[{},"if the scaling operation affects the timer generating the OS system tick, this timer"]},{"entry":[{},"will need to be adapted to follow the scaling operation, which will affect the"]},{"entry":[{},"absolute accuracy of the time base."]},{"entry":["V\/F scaling latencies can be","The latency for voltage and frequency scaling operations will vary widely across"]},{"entry":["large, and platform-","platforms. An application that runs fine on one platform may not be portable to"]},{"entry":["dependent","another platform, and may not run on a revision to the same platform if the"]},{"entry":[{},"latencies change much. For example, the time for a down-voltage scaling"]},{"entry":[{},"operation is typically load-dependent, and if the load changes significantly on the"]},{"entry":[{},"revised platform the application may not run correctly."]},{"entry":["Might not have stable","Some processor vendors specify a non-operation sequence during voltage or"]},{"entry":["operation during V\/F scaling","clock frequency changes to avoid instabilities during the transition. In these"]},{"entry":[{},"situations, the scaling code will need to wait for the transition to occur before"]},{"entry":[{},"returning, increasing the scaling latency."]},{"entry":["V\/F scaling directly affects","Changing CPU frequency (and voltage when possible) will alter the execution"]},{"entry":["ability to meet deadlines","time of a given task, potentially causing the task to miss a real-time deadline."]},{"entry":[{},"Even if the new frequency is compatible with the deadline, there may still be a"]},{"entry":[{},"problem if the latency to switch between V\/F setpoints is too big."]},{"entry":["Scaling the CPU clock can","If the clock that feeds the CPU also feeds the OS timer, the OS timer will be"]},{"entry":["affect ability to measure CPU","scaled along with the CPU, which compromises measurement of CPU utilization."]},{"entry":"utilization"},{"entry":["Watchdogs still need to be","Watchdog timers are used to detect abnormal program behavior and either"]},{"entry":["kept happy","shutdown or reboot a system. Typically the watchdog needs to be serviced within"]},{"entry":[{},"a pre-defined time interval to keep it from triggering. Power management"]},{"entry":[{},"techniques that slow down or suspend processing can therefore inadvertently"]},{"entry":[{},"trigger application failure."]},{"entry":["Idle and sleep modes","Depending upon the processor and the debug tools, invoking idle and sleep modes"]},{"entry":["typically collide with","can disrupt the transport of real-time instrumentation and debugging information"]},{"entry":["emulation, debug, and","from the target. In the worst case it may perturb and even crash the debug"]},{"entry":["instrumentation","environment. Similar concerns arise with V\/F scaling, which may cause difficulty"]},{"entry":[{},"for the emulation and debug circuitry. It may be the case that power management is"]},{"entry":[{},"enabled when the system is deployed, but only minimally used during development."]},{"entry":["Context save\/restore can","In a non-power managed environment the OS or application framework will"]},{"entry":["become non-trivial","typically save and restore register values during a context switch. As register"]},{"entry":[{},"banks, memories, and other modules are powered OFF and back ON, the context to"]},{"entry":[{},"be saved and restored can grow dramatically. Also, if a module is powered down it"]},{"entry":[{},"may be difficult (and sometimes not possible) to fully restore the internal state of"]},{"entry":[{},"the module."]},{"entry":["Most advanced power","Many of the research papers that demonstrate significant power savings use highly"]},{"entry":["management techniques are","specialized application examples, and do not map well to general application cases."]},{"entry":["still in the research stage","Or, they make assumptions regarding the ability to fully characterize an application"]},{"entry":[{},"such that it can be guaranteed to be schedulable. These techniques often do not"]},{"entry":[{},"map to \u2018real world\u2019, multi-function programmable systems, and more research is"]},{"entry":[{},"needed for broader applicability."]},{"entry":["Different types of","Different hardware platforms have varying levels of support for the above listed"]},{"entry":["applications call for","techniques. Also, different applications running on the same platform may have"]},{"entry":["different techniques","different processing requirements. For some applications, only the low-latency"]},{"entry":[{},"techniques (e.g., clock idling) are applicable, but for others the higher-latency"]},{"entry":[{},"techniques can be used to provide significant power savings when the application"]},{"entry":[{},"switches between modes with significantly different processing requirements. For"]},{"entry":[{},"example, one mode can be run at low V\/F, and another mode, with higher"]},{"entry":[{},"processing requirements, can be run at a higher V\/F. If the V\/F latency is"]},{"entry":[{},"compatible with the mode switch time, the application can use the technique."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The present invention provides methods and systems for dynamically managing power consumption in a digital system. Embodiments of the invention permit entities of the digital system to vary the frequency and voltage used to power a processor of the digital system. The processor of the digital system may be comprised of a single processing core with a single clock or a multiple of processing cores, each with its own clock. An entity may request that the current frequency of a clock be changed to a new frequency and the change will be made. The voltage point of the voltage regulator in the digital system is then automatically changed to the minimum voltage required by that frequency if there is a single clock. If there are multiple clocks in the processor, the voltage point is automatically changed to the minimum voltage required by all frequencies of all clocks. An entity may request a frequency change for one clock or a multiple of clocks in a single request.","Digital systems are provided operable to dynamically manage power consumption by providing for scaling of frequency and voltage during operation of the digital systems. Embodiments of such digital systems comprise a processor, a voltage regulator, and a memory storing a power scaling library executable to enable any entity of the digital system change the frequency and voltage of the digital system. The power scaling library is operable to cause the voltage to be automatically changed to the minimum voltage required by a frequency when an entity requests a frequency change. The power scaling library may be further executable to enable an entity to obtain a current frequency of the clock, to obtain a current voltage of the voltage regulator, to obtain all valid frequencies of the clock, to obtain a minimum required voltage for each of the valid frequencies of the clock, and to obtain a maximum latency for a change from a first frequency and voltage to a second frequency and voltage.","In other embodiments, the processor of the digital system comprises multiple processing cores, each with an associated clock. In such embodiments, the power scaling library is executable to permit an entity to cause the frequencies of two or more clocks to be changed. And, the power scaling library is executable to automatically changes the voltage to the minimum voltage required by all frequencies of all clocks when the frequencies of the two or more clocks are changed.","Corresponding numerals and symbols in the different figures and tables refer to corresponding parts unless otherwise indicated.","The present invention provides systems and methods to permit application developers to select and utilize power management techniques that are compatible with specific application requirements. Although these systems and methods are described below in relation to a real-time operating system (RTOS), they may be easily adapted by one skilled in the art to other operating systems or application environments without an operating system.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["1000","1002","1004","1006","1000","1002","1000","1002","1000"]},"The capabilities of real-time operating systems are well known to those skilled in the art. One representative example of an RTOS is DSP\/BIOS from Texas Instruments Incorporated. DSP\/BIOS is a scalable, instrumented real-time kernel for digital signal processors. The kernel is optimized for resource-constrained, real-time embedded applications. It supports three pre-emptive thread types: tasks (blockable), software interrupts (light-weight run-to-completion threads), and hardware interrupts. Priority based scheduling is used at each thread level. The kernel includes standard synchronization primitives (e.g., semaphores, mailboxes, etc.), and includes a memory manager with support for multiple heaps for managing multiple regions and types of memories. A device model is defined for implementing streaming, device-independent I\/O. The kernel also provide clock-based services: high and low-resolution time APIs, functions that run on each system tick, periodic functions that run on multiples of clock ticks, and timeouts for blocking API calls. More detailed information is available in TMS320 DSP\/BIOS User's Guide, SPRU423, available on the Texas Instruments website at http:\/\/www-s.ti.com\/sc\/psheets\/spru423b\/spru423b.pdf, incorporated herein by reference.","In this embodiment, PWRM  interfaces directly to processor  by writing and reading a clock idle configuration register, and through Power Scaling Library (PSL) . Processor  may comprise a single CPU with a single clock or multi-core device with multiple clocks. PSL  controls the CPU clock rate and voltage-regulation circuitry of processor . PSL  logically isolates PWRM  and the rest of the application from the low-level implementation details of the frequency and voltage control hardware. In other embodiments where frequency and voltage scaling is not required or supported, PWRM  may be present without PSL . And, in other embodiments, PSL  may be present without PWRM .","PWRM  manages all things power-related in the application, as statically configured by the application developer, and as dynamically called at runtime. In an embodiment, features of PWRM  include:\n\n",{"@attributes":{"id":"p-0030","num":"0034"},"figref":["FIG. 2","FIG. 2"],"b":"1000","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["1. Application  registers to be notified on V\/F setpoint changes. For example, processor  may require different external memory interface (EMIF) settings for different setpoints, so application  registers control code with PWRM  so that EMIF settings can be changed to follow the change in setpoint. As part of the registration, application  tells PWRM  the specific notification function to call when the event occurs; a client-specific argument to be passed as part of the notification; and the V\/F setpoints at which the control code is capable of operating (so that PWRM  will not try to initiate a change to an unsupported setpoint).","2. Driver  that uses direct memory access (DMA) to transfer data to\/from external memory registers to be notified of a V\/F setpoint change. For example, prior to a setpoint change, the driver may need to temporarily stop DMA operations to external memory.","3. Packaged target content  similarly registers with PWRM  for notification on setpoint changes.","4. Application  comes to a decision to change the V\/F setpoint (e.g., a change in the device's mode, or maybe a task boundary), and calls the API of PWRM  to initiate the setpoint change.","5. PWRM  verifies the new setpoint is allowed for all registered clients, and then notifies registered clients of the impending setpoint change.","6. PWRM  calls into PSL  to change the voltage and frequency setpoint. PSL  writes to the clock generation and voltage regulation hardware as appropriate to safely change the V\/F setpoint.","7. Following the setpoint change, PWRM  notifies registered clients that the setpoint has been changed."]}}}},"PWRM  has a number of configuration parameters, many of which may be configured statically using a graphical configuration tool. The statically configurable parameters include enabling power management, specifying a specific user function to be called at boot time to reduce power consumption, reprogramming the BIOS clock in response to a frequency scaling event, causing clock domains to be automatically idled when the CPU is idle, enabling scaling, setting the initial CPU frequency at boot, setting the initial CPU voltage at boot, enabling scaling of voltage along with frequency, waiting while voltage is scaling down, specifying the clock domains to be idled when the CPU is put into deep sleep mode, and specifying that interrupts are allowed to wake the CPU from deep sleep mode.",{"@attributes":{"id":"p-0032","num":"0043"},"figref":["FIGS. 3A\u20133D","FIG. 3A"],"b":["3000","3001","3004","3001","3005","1000","3005","1000","1000","3006","1000","3007","3007"]},"The screen display of idle tab  is presented in . Here, check box  is used to indicate if PWRM  should take action in the RTOS idle loop. If check box  is checked, other check boxes become write-able to allow the user to select specific clock domains to be idled. In this example, PWRM  will insert a function in the RTOS idle loop to idle the cache and CPU domains. Only valid combinations of domains are permitted, e.g., CLKGEN can only be idled if the CPU, DMA, and CACHE domains are also idled.","The screen display of V\/F scaling tab  is presented in . Scaling check box  is used to indicate if voltage and frequency scaling is to be enabled. If the box is checked, an appropriate version of PSL  will be included with the RTOS when it is linked. When the box is not checked and PWRM  is enabled, a null version of PSL  is linked to resolve any references to PSL  in PWRM . When V\/F scaling is enabled, four additional data entry boxes become active: two boxes permitting user specification of the initial frequency and voltage, a box to indicated if voltage should be scaled along with frequency, and a box to indicate whether PWRM  should wait for a down-voltage transition to complete before returning control to user code after a scaling operation.","The screen display of sleep tab  is presented in . Sleep check box  is used to indicate whether deep sleep is to be enabled. If this box is checked, the clock domain check boxes become write-able along with two entry boxes for specifying whether interrupts may awake the processor from deep sleep. In this example, the EMIF, CLKGEN, PERIPHS, CACHE, DMA, and CPU domains are selected to be idled during deep sleep, and a single wakeup interrupt is allowed, as specified by the IER0 and IER1 masks. Snooze check box  is used to indicate if snooze mode is to be enabled. If this box is checked, a drop down list is presented to allow selection of a timer to be used for timing the snooze interval.","Certain of the PWRM  parameters are also re-configurable at runtime, via the PWRM  API. These dynamically configurable parameters include specifying the clock domains to be automatically idled when the CPU is idle, enabling scaling of voltage along with frequency, and waiting while the voltage is scaling down.","To further clarify the capabilities of PWRM , a more detailed description of an API of an embodiment is presented below. Table 4 summarizes the available API functions and the tables referenced in the table column present a more detailed description of each associated interface function, along with pseudocode describing its operation. Table 17 contains data structure definitions for the embodiment.",{"@attributes":{"id":"p-0038","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Function","Purpose","Table"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PWRM_changeSetpoint","Initiate a change to the V\/F setpoint","5"]},{"entry":["PWRM_configure","Set new configuration parameters","6"]},{"entry":["PWRM_getCapabilities","Get information on capabilities on the current platform","7"]},{"entry":["PWRM_getCurrentSetpoint","Get the current setpoint in effect","8"]},{"entry":["PWRM_getNumSetpoints","Get the number of setpoints supported for the","9"]},{"entry":[{},"current platform"]},{"entry":["PWRM_getSetpointInfo","Get the corresponding frequency and CPU","10"]},{"entry":[{},"core voltage for a setpoint"]},{"entry":["PWRM_getTransitionLatency","Get the latency to scale from one specific","11"]},{"entry":[{},"setpoint to another specific setpoint"]},{"entry":["PWRM_idleClocks","Immediately idle clock domains","12"]},{"entry":["PWRM_registerNotify","Register a function to be called on a specific","13"]},{"entry":[{},"power event"]},{"entry":["PWRM_sleepDSP","Transition the DSP to a new sleep state","14"]},{"entry":["PWRM_snoozeDSP","Put the DSP in a deep sleep for a specified","15"]},{"entry":[{},"number of seconds"]},{"entry":["PWRM_unregisterNotify","Unregister for an event notification","16"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0039","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_changeSetpoint"},{"entry":"\u2003\u2003Initiates a change to the V\/F setpoint."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_changeSetpoint(IN newSetpoint, IN notifyTimeout);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns newSetpoint"},{"entry":"\u2003\u2003\u2003\u2003New V\/F setpoint to scale to (from 1 to the maximum supported for the"},{"entry":"\u2003\u2003\u2003\u2003configuration)."},{"entry":"\u2003\u2003Uns notifyTimeout"},{"entry":"\u2003\u2003\u2003\u2003The maximum amount of time (in system clock ticks) for the power manager to wait for"},{"entry":"\u2003\u2003\u2003\u2003notification clients to respond to a delayed completion, before declaring failure and returning"},{"entry":"\u2003\u2003\u2003\u2003PWRM_ETIMEOUT. For example, if notifyTimeout is set to 200, while the power manager"},{"entry":"\u2003\u2003\u2003\u2003is notifying clients it will wait 200 ticks (typically 200 msec) before declaring that a client has"},{"entry":"\u2003\u2003\u2003\u2003failed to respond. Note that the power manager tracks the notifyTimeout for each"},{"entry":"\u2003\u2003\u2003\u2003notification sequence; for example, if clients are registered to be notified both before and"},{"entry":"\u2003\u2003\u2003\u2003after setpoint changes, the power manager will wait up to notifyTimeout on both types of"},{"entry":"\u2003\u2003\u2003\u2003notification, (before and after changing the setpoint), within the single call to"},{"entry":"\u2003\u2003\u2003\u2003PWRM_changeSetpoint."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK on success; the new setpoint is now in effect."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure; the requested setpoint transition did not occur."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EOUTOFRANGE if newSetpoint is out of the range of valid setpoints for the"},{"entry":"\u2003\u2003\u2003\u2003platform; the requested setpoint transition did not occur."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTSUPPORTED if newSetpoint indicates a setpoint that a registered client"},{"entry":"\u2003\u2003\u2003\u2003does not support; the requested setpoint transition did not occur."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if V\/F scaling is not supported."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EBUSY if PWRM is currently busy processing a previous request."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINITFAILURE if a failure occurred while initializing V\/F scaling support."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ETIMEOUT if a notification client did not complete a delayed completion"},{"entry":"\u2003\u2003\u2003\u2003within the specified notifyTimeout."},{"entry":"\u2003\u2003When PWRM_changeSetpoint returns PWRM_ETIMEOUT or PWRM_EFAIL this should be"},{"entry":"\u2003\u2003considered a critical system failure, as a client is deemed unresponsive, and the system is now in an"},{"entry":"\u2003\u2003unknown state."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check if V\/F scaling supported, if not return PWRM_ENOTIMPLEMENTED;"},{"entry":"\u2003\u2003check if requested setpoint is allowed, if not return PWRM_ENOTSUPPORTED;"},{"entry":"\u2003\u2003stop TSK and SWI scheduling, retain HWIs for completion detection;"},{"entry":"\u2003\u2003notify clients registered for PWRM_PENDINGSETPOINTCHANGE;"},{"entry":"\u2003\u2003if timeout return PWRM_ETIMEOUT;"},{"entry":"\u2003\u2003call PSL to do the scaling op;"},{"entry":"\u2003\u2003notify clients registered for PWRM_DONESETPOINTCHANGE;"},{"entry":"\u2003\u2003if timeout return PWRM_ETIMEOUT;"},{"entry":"\u2003\u2003resume TSK and SWI scheduling;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0040","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_configure"},{"entry":"\u2003\u2003Specifies new configuration parameters for the power manager, overriding those specified via"},{"entry":"\u2003\u2003static configuration settings."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_configure(IN attrs);"},{"entry":"Parameters"},{"entry":"\u2003\u2003PWRM_Attrs attrs"},{"entry":"\u2003\u2003\u2003\u2003Configuration attributes for the power manager module."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003scaleVoltage"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Flag indicating if the power manager should scale voltages during setpoint changes."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003For example, if scaleVoltage is TRUE, the voltage will be scaled down, when"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003possible, when going to a lower frequency. If scaleVoltage is FALSE,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003the voltage will not be scaled lower to follow the lower frequency of the new"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003setpoint. The voltage will always be scaled up when the destination setpoint"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003frequency is higher than that supported at the current voltage."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003waitForVoltageScale"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Flag indicating if the power manager should wait for a down-voltage transition to complete"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003before returning. [Note: for up-voltage transitions the power manager must wait for the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003transition to complete before up-scaling frequency.]"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003idleMask"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Bitmask specifying the domains to be idled in the BIOS idle loop (i.e., the value"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003to be written to the ICR register before idling the processor)."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK on success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if attrs is NULL."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDVALUE if scaleVoltage, waitForVoltageScale, or idleMask are"},{"entry":"\u2003\u2003\u2003\u2003invalid."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003validate parameters;"},{"entry":"\u2003\u2003simply copy elements from attrs structure to PWRM_Config object;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0041","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_getCapabilities"},{"entry":"\u2003\u2003Returns information on the power manager's capabilities on the current platform."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_getCapabilities(OUT capsMask);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns *capsMask"},{"entry":"\u2003\u2003\u2003\u2003Pointer to location to store bitmask defining the power managers capabilities. The following"},{"entry":"\u2003\u2003\u2003\u2003pre-defined bitmasks can be used to check if the power manager implements the capability on"},{"entry":"\u2003\u2003\u2003\u2003the current platform."},{"entry":"\u2003\u2003PWRM_CDEEPSLEEP"},{"entry":"\u2003\u2003\u2003\u2003PWRM_sleepDSP implements PWRM_DEEPSLEEP."},{"entry":"\u2003\u2003PWRM_CSLEEPUNTILRESTART"},{"entry":"\u2003\u2003\u2003\u2003PWRM_sleepDSP implements PWRM_SLEEPUNTILRESTART."},{"entry":"\u2003\u2003PWRM_CSNOOZE"},{"entry":"\u2003\u2003\u2003\u2003PWRM_snoozeDSP is implemented."},{"entry":"\u2003\u2003PWRM_CVFSCALING"},{"entry":"\u2003\u2003\u2003\u2003PWRM supports voltage and frequency scaling."},{"entry":"\u2003\u2003[For example, if (*capsMask & PWRM_CVFSCALING) != 0, then V\/F scaling"},{"entry":"\u2003\u2003is supported.]"},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK on success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if capsMask is NULL."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003read generated configuration info, fill in and return capabilities mask;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0042","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_getCurrentSetpoint"},{"entry":"\u2003\u2003Returns the current setpoint in effect."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_getCurrentSetpoint(OUT setpoint);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns * setpoint"},{"entry":"\u2003\u2003\u2003\u2003Pointer to location to store the current V\/F setpoint in effect."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK on success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if setpoint is NULL."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINITFAILURE if a failure occurred while initializing V\/F scaling support."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if V\/F scaling is not supported."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check if V\/F scaling supported, if not return PWRM_ENOTIMPLEMENTED;"},{"entry":"\u2003\u2003call PSL_getSetpoints to determine the current setpoint;"},{"entry":"\u2003\u2003if get PSL_OK return code then return the indicated setpoint;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003else return PWRM_EFAIL to indicate failure;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0043","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_getNumSetpoints"},{"entry":"\u2003\u2003Returns the number of setpoints supported for the current configuration."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_getNumSetpoints(OUT numberSetpoints);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns * numberSetpoints"},{"entry":"\u2003\u2003\u2003\u2003Pointer to the location to store the number of V\/F setpoints supported in this"},{"entry":"\u2003\u2003\u2003\u2003configuration. If V\/F scaling is supported a value of at least 1 will be returned."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK on success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if numberSetpoints is NULL."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINITFAILURE if a failure occurred while initializing V\/F scaling support."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if V\/F scaling is not supported."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check if V\/F scaling supported, if not return PWRM_ENOTIMPLEMENTED;"},{"entry":"\u2003\u2003call PSL_getNumSetpoints to determine the current setpoint;"},{"entry":"\u2003\u2003if get PSL_OK return code then return the indicated number;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003else return PWRM_EFAIL"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0044","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_getSetpointInfo"},{"entry":"\u2003\u2003Returns the frequency and CPU core voltage for a setpoint."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_getSetpointInfo(IN setpoint, OUT frequency, OUT voltage);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns setpoint"},{"entry":"\u2003\u2003\u2003\u2003The setpoint to query."},{"entry":"\u2003\u2003float * frequency"},{"entry":"\u2003\u2003\u2003\u2003Pointer to location to store the DSP core frequency for setpoint."},{"entry":"\u2003\u2003float * voltage"},{"entry":"\u2003\u2003\u2003\u2003Pointer to location to store the voltage for setpoint."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK on success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDVALUE if setpoint is invalid."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if frequency or voltage are NULL."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINITFAILURE if a failure occurred while initializing V\/F scaling support."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if V\/F scaling is not supported."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check if V\/F scaling supported, if not return PWRM_ENOTIMPLEMENTED;"},{"entry":"\u2003\u2003check if setpoint is valid, if not return PWRM_EINVALIDVALUE;"},{"entry":"\u2003\u2003call PSL_querySetpoints to get the CPU frequency and voltage for the specified setpoint;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0045","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_getTransitionLatency"},{"entry":"\u2003\u2003Returns the latency to scale from one specific setpoint to another specific setpoint."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_getTransitionLatency(IN initialSetpoint, IN finalSetpoint, OUT latency);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns initialSetpoint"},{"entry":"\u2003\u2003\u2003\u2003The setpoint to be scaled from."},{"entry":"\u2003\u2003Uns finalSetpoint"},{"entry":"\u2003\u2003\u2003\u2003The setpoint to be scaled to."},{"entry":"\u2003\u2003Uns * latency"},{"entry":"\u2003\u2003\u2003\u2003The location to store the transition latency. This latency is in microseconds, and indicates"},{"entry":"\u2003\u2003\u2003\u2003the time to scale frequency and voltage from the initialSetpoint to the finalSetpoint."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK for success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDVALUE if initialSetpoint or finalSetpoint are invalid."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if latency is NULL."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINITFAILURE if a failure occurred while initializing V\/F scaling support."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if V\/F scaling is not supported."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check if V\/F scaling supported, if not return PWRM_ENOTIMPLEMENTED;"},{"entry":"\u2003\u2003check if setpoints are valid, if not return PWRM_EINVALIDVALUE;"},{"entry":"\u2003\u2003call PSL_getSetpointTransitions to get frequency and voltage scaling latency for specified setpoints;"},{"entry":"\u2003\u2003if voltage scaling is enabled then check if voltage latency is biggest;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003else, simply return frequency latency;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0046","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_idleClocks"},{"entry":"\u2003\u2003Immediately idle (i.e., turn off) clock domains. [The purpose of this function is to allow the"},{"entry":"\u2003\u2003application to idle non-CPU domains from anywhere in the application. The function will"},{"entry":"\u2003\u2003immediately return and indicate error if an attempt is made to idle the CPU or CLKGEN"},{"entry":"\u2003\u2003domains; these domains should only be idled in the idle loop (see PWRM_configure).]"},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_idleClocks(IN domainMask);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns domainMask"},{"entry":"\u2003\u2003\u2003\u2003The bitmask of clock domains to be idled."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK for success."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDVALUE if a domain specified in domainMask cannot be idled by"},{"entry":"\u2003\u2003\u2003\u2003this function (e.g., CPU, CLKGEN)."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if this function is not implemented."},{"entry":"Pseudocode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0047","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_registerNotify"},{"entry":"\u2003\u2003Registers a function to be called on a specific power event. [Registrations and the corresponding"},{"entry":"\u2003\u2003notifications are processed in FIFO order.]"},{"entry":"Syntax"},{"entry":"\u2003\u2003PWRM_registerNotify(IN eventType, IN eventMask, IN notifyFxn, IN clientArg,"},{"entry":"\u2003\u2003\u2003OUT notifyHandle, OUT delayedCompletionFxn);"},{"entry":"Parameters"},{"entry":"\u2003\u2003PWRM_Event eventType"},{"entry":"\u2003\u2003\u2003The type of power event for which the notify function is to be called:"},{"entry":"\u2003\u2003\u2003\u2003PWRM_PENDINGSETPOINTCHANGE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003The V\/F setpoint is about to change."},{"entry":"\u2003\u2003\u2003\u2003PWRM_DONESETPOINTCHANGE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003The V\/F setpoint that was pending has now been changed."},{"entry":"\u2003\u2003\u2003\u2003PWRM_GOINGTODEEPSLEEP"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003The DSP is going to deep sleep."},{"entry":"\u2003\u2003\u2003\u2003PWRM_AWAKEFROMDEEPSLEEP"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003The DSP has awoken from deep sleep."},{"entry":"\u2003\u2003\u2003\u2003PWRM_GOINGTOSLEEPUNTILRESTART"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003The DSP is going to deep sleep and must be restarted to resume."},{"entry":"\u2003\u2003LgUns eventMask"},{"entry":"\u2003\u2003\u2003\u2003An event-specific mask. For V\/F setpoint registrations this mask will define the"},{"entry":"\u2003\u2003\u2003\u2003setpoints the client supports. For example, if only one of the setpoints exported by"},{"entry":"\u2003\u2003\u2003\u2003the power manager is supported by the client, only the single corresponding bit in"},{"entry":"\u2003\u2003\u2003\u2003eventMask will be set. V\/F event clients specify eventMask at registration time so the"},{"entry":"\u2003\u2003\u2003\u2003power manager will be able to determine before it starts a setpoint transition if one of the"},{"entry":"\u2003\u2003\u2003\u2003registered clients cannot support it; in this case PWRM_changeSetpoint will not start the"},{"entry":"\u2003\u2003\u2003\u2003notification process, but will immediately return PWRM_ENOTSUPPORTED."},{"entry":"\u2003\u2003Fxn notifyFxn"},{"entry":"\u2003\u2003\u2003\u2003This is the client's function that should be called by the power manager when the specified"},{"entry":"\u2003\u2003\u2003\u2003power event has occurred. When the client's function is called, the clientArg will be"},{"entry":"\u2003\u2003\u2003\u2003passed back to the client. The purpose here is to allow a notify function to be used by"},{"entry":"\u2003\u2003\u2003\u2003multiple instances of a driver (e.g., the clientArg can be used to identify the instance of the"},{"entry":"\u2003\u2003\u2003\u2003driver that is being notified)."},{"entry":"\u2003\u2003Arg clientArg"},{"entry":"\u2003\u2003\u2003\u2003An arbitrary argument to be passed to the client on notification."},{"entry":"\u2003\u2003PWRM_notifyHandle * notifyHandle"},{"entry":"\u2003\u2003\u2003\u2003This is a notification handle that is returned to the client. When it is time to"},{"entry":"\u2003\u2003\u2003\u2003unregister the function the client should pass this handle to the PWRM_unregisterNotify"},{"entry":"\u2003\u2003\u2003\u2003function. [A handle is used so that the same notify function can be registered by"},{"entry":"\u2003\u2003\u2003\u2003multiple clients (e.g., multiple instances of a driver.)]"},{"entry":"\u2003\u2003Fxn * delayedCompletionFxn"},{"entry":"\u2003\u2003\u2003\u2003This is the function the client should call if it cannot act immediately upon the"},{"entry":"\u2003\u2003\u2003\u2003notification. For example, if a DMA driver is to prepare for a setpoint change it may"},{"entry":"\u2003\u2003\u2003\u2003need to wait for the current DMA transfer to complete. If so, its notify function will"},{"entry":"\u2003\u2003\u2003\u2003return PWRM_NOTIFYNOTDONE, and when the action is complete, the driver will call"},{"entry":"\u2003\u2003\u2003\u2003the delayedCompletionFxn to signal the power manager that it has finished. If the client"},{"entry":"\u2003\u2003\u2003\u2003can and does act immediately on the notification it will return PWRM_NOTIFYDONE in"},{"entry":"\u2003\u2003\u2003\u2003response to the notification."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK for successful registration."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDEVENT if eventType is invalid."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDPOINTER if notifyFxn, notifyHandle or delayedCompletionFxn are"},{"entry":"\u2003\u2003\u2003\u2003NULL."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check to make sure event type is valid, if not return PWRM_EINVALIDEVENT;"},{"entry":"\u2003\u2003validate pointers (notifyFxn, notifyHandle, delayedCompletionFxn);"},{"entry":"\u2003\u2003for V\/F scaling update the setpoint mask (_PWRM_allowedSPmask) to reflect client's limitations"},{"entry":"\u2003\u2003allocate a notification object; if fail return FALSE;"},{"entry":"\u2003\u2003fill in the notification object elements;"},{"entry":"\u2003\u2003enqueue the notification object on the appropriate event queue;"},{"entry":"\u2003\u2003set the notifyHandle and delayedCompletionFxn out params;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0048","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_sleepDSP"},{"entry":"\u2003\u2003Transitions the DSP to a new sleep state."},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_sleepDSP(IN sleepCode, IN notifyTimeout);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns sleepCode"},{"entry":"\u2003\u2003\u2003\u2003A command code indicating the new sleep state for the DSP:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003PWRM_DEEPSLEEP"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Put the DSP in deep sleep."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003PWRM_SLEEPUNTILRESTART"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Idle all DSP clock domains; only way to wakeup is a DSP reset."},{"entry":"\u2003\u2003Uns notifyTimeout"},{"entry":"\u2003\u2003\u2003\u2003The maximum amount of time (in system clock ticks) for the power manager to wait for"},{"entry":"\u2003\u2003\u2003\u2003notification clients to respond for a delayed completion, before declaring failure and"},{"entry":"\u2003\u2003\u2003\u2003returning PWRM_ETIMEOUT. For example, if notifyTimeout is set to 200, while"},{"entry":"\u2003\u2003\u2003\u2003the power manager is notifying clients it will wait 200 ticks (typically 200 msec) before"},{"entry":"\u2003\u2003\u2003\u2003declaring that a client has failed to respond. Note that the power manager tracks the"},{"entry":"\u2003\u2003\u2003\u2003notifyTimeout for each notification sequence; for example, if clients are registered to be"},{"entry":"\u2003\u2003\u2003\u2003notified both before and after deep sleep state changes, PWRM will wait up to notifyTimeout"},{"entry":"\u2003\u2003\u2003\u2003on both types of notification, (before and after changing the sleep state), within the single"},{"entry":"\u2003\u2003\u2003\u2003call to PWRM_sleepDSP."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK for successful sleep and wake."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL if unable to sleep the DSP."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if the requested sleep state is not implemented."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EBUSY if PWRM is currently busy processing a previous request."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ETIMEOUT if a notification client did not complete a delayed completion"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003within the specified notifyTimeout."},{"entry":"\u2003\u2003\u2003\u2003Note that because of the critical \u201csystem\u201d nature of sleep commands, clients that"},{"entry":"\u2003\u2003\u2003\u2003register for sleep notifications cannot say \u2018no\u2019 when notified of a sleep event. They must"},{"entry":"\u2003\u2003\u2003\u2003do their best to immediately act on the sleep command. For PWRM_DEEPSLEEP this"},{"entry":"\u2003\u2003\u2003\u2003function will return once the DSP is awoken from deep sleep. For"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SLEEPUNTILRESTART this function will not return. When PWRM_sleepDSP"},{"entry":"\u2003\u2003\u2003\u2003returns PWRM_ETIMEOUT or PWRM_EFAIL this should be considered a critical system"},{"entry":"\u2003\u2003\u2003\u2003failure, as a client is deemed unresponsive, and the system is now in an unknown state."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003\u2003\u2003check if sleep mode is supported, if not return PWRM_ENOTIMPLEMENTED;"},{"entry":"\u2003\u2003\u2003\u2003if sleep code is PWRM_SLEEPUNTILRESTART:"},{"entry":"\u2003\u2003\u2003\u2003\u2003notify all registered PWRM_GOINGTOSLEEPUNTILRESTART clients;"},{"entry":"\u2003\u2003\u2003\u2003\u2003if timeout return PWRM_ETIMEOUT;"},{"entry":"\u2003\u2003\u2003\u2003\u2003set IER registers to zero to disable all interrupts;"},{"entry":"\u2003\u2003\u2003\u2003\u2003set ICR to 0x3F to get ready to idle all domains;"},{"entry":"\u2003\u2003\u2003\u2003\u2003call IDLE instruction;"},{"entry":"\u2003\u2003\u2003\u2003else if sleep code is PWRM_DEEPSLEEP;"},{"entry":"\u2003\u2003\u2003\u2003\u2003notify all registered PWRM_GOINGTODEEPSLEEP clients;"},{"entry":"\u2003\u2003\u2003\u2003\u2003if timeout return PWRM_ETIMEOUT;"},{"entry":"\u2003\u2003\u2003\u2003\u2003save current IER masks;"},{"entry":"\u2003\u2003\u2003\u2003\u2003set IER registers to configured masks for deep sleep wake interrupts;"},{"entry":"\u2003\u2003\u2003\u2003\u2003set ICR to that configured via config tool, to get ready to idle domains;"},{"entry":"\u2003\u2003\u2003\u2003\u2003save current ISTR mask (domains currently idled);"},{"entry":"\u2003\u2003\u2003\u2003\u2003call IDLE instruction;"},{"entry":"\u2003\u2003\u2003\u2003\u2003on wake write to ICR to restore idled domains on entry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003call IDLE instruction;"},{"entry":"\u2003\u2003\u2003\u2003\u2003restore IER masks on entry;"},{"entry":"\u2003\u2003\u2003\u2003\u2003notify all registered PWRM_AWAKEFROMDEEPSLEEP clients;"},{"entry":"\u2003\u2003\u2003\u2003\u2003if timeout return PWRM_ETIMEOUT;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0049","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_snoozeDSP"},{"entry":"\u2003\u2003Puts the DSP in deep sleep for a specified number of seconds."},{"entry":"Syntax"},{"entry":"\u2003\u2003Status = PWRM_snoozeDSP(IN seconds);"},{"entry":"Parameters"},{"entry":"\u2003\u2003Uns seconds"},{"entry":"\u2003\u2003\u2003\u2003The number of seconds that the DSP should sleep."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK if the DSP slept for the specified number of seconds and is now awake."},{"entry":"\u2003\u2003\u2003\u2003PWRM_ENOTIMPLEMENTED if snooze is not implemented."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EBUSY if the power manager is currently busy processing a previous request."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EOUTOFRANGE if unable to sleep because the seconds value is out of range"},{"entry":"\u2003\u2003\u2003\u2003of the capabilities of the power manager."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003check can program PLL & timer to achieve the specified snooze interval,"},{"entry":"\u2003\u2003\u2003with reasonable periodic wakeups;"},{"entry":"\u2003\u2003notify all registered PWRM_GOINGTODEEPSLEEP clients;"},{"entry":"\u2003\u2003if timeout return PWRM_ETIMEOUT;"},{"entry":"\u2003\u2003program timer for the snooze and unmask its interrupt as sole wakeup source;"},{"entry":"\u2003\u2003while specified snooze interval hasn't been reached {"},{"entry":"\u2003\u2003\u2002go to deep sleep (except for clock and timer domains);"},{"entry":"\u2003\u2003\u2002when wake, if need multiple wakeups to achieve overall time,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003decrement count and go back to snooze;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003notify all registered PWRM_AWAKEFROMDEEPSLEEP clients"},{"entry":"\u2003\u2003\u2002if timeout return PWRM_ETIMEOUT;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0050","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PWRM_unregisterNotify"},{"entry":"\u2003\u2003Unregister for an event notification from the PWRM module. [For example, an audio codec"},{"entry":"\u2003\u2003device is closed, and the notification is no longer needed.]"},{"entry":"Syntax"},{"entry":"\u2003\u2003status = PWRM_unregisterNotify(IN notifyHandle);"},{"entry":"Parameters"},{"entry":"\u2003\u2003PWRM_notifyHandle notifyHandle"},{"entry":"\u2003\u2003\u2003\u2003This is the handle returned by PWRM_registerNotify when the function was registered"},{"entry":"\u2003\u2003\u2003\u2003for notification."},{"entry":"Return Value"},{"entry":"\u2003\u2003PWRM_Status status"},{"entry":"\u2003\u2003\u2003\u2003PWRM_SOK for successful unregistration."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EINVALIDHANDLE if notifyHandle is invalid."},{"entry":"\u2003\u2003\u2003\u2003PWRM_EFAIL for a general failure."},{"entry":"Pseudocode"},{"entry":"\u2003\u2003if notifyHandle is NULL return PWRM_EINVALIDHANDLE;"},{"entry":"\u2003\u2003atomically remove the notification object from its event queue;"},{"entry":"\u2003\u2003free the notification object memory;"},{"entry":"\u2003\u2003for V\/F scaling un-registration update the valid setpoint mask"},{"entry":"\u2003\u2003\u2003(_PWRM_allowedSPmask) to remove client's limitations"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0051","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct PWRM_Config {"]},{"entry":[{},"\u2003Bool scaleVoltage;"]},{"entry":[{},"\u2003Bool waitForVoltageScale;"]},{"entry":[{},"\u2003Uns idleMask;"]},{"entry":[{},"} PWRM_Config;"]},{"entry":[{},"typedef struct PWRM_Attrs {"]},{"entry":[{},"\u2003Bool scaleVoltage;"]},{"entry":[{},"\u2003Bool waitForVoltageScale;"]},{"entry":[{},"\u2003Uns idleMask;"]},{"entry":[{},"} PWRM_Attrs;"]},{"entry":[{},"PWRM_Attrs PWRM_ATTRS = {"]},{"entry":[{},"\u2003FALSE,\u2003\u2003\/* scaleVoltage *\/"]},{"entry":[{},"\u2003FALSE,\u2003\u2003\/* waitForVoltageScale *\/"]},{"entry":[{},"\u20030,\u2003\u2003\u2003\u2003\u2002\/* idleMask *\/"]},{"entry":[{},"};"]},{"entry":[{},"typedef struct {"]},{"entry":[{},"\u2003QUE_Elem link;"]},{"entry":[{},"\u2003PWRM_Event eventType;"]},{"entry":[{},"\u2003Fxn notifyFxn;"]},{"entry":[{},"\u2003Arg clientArg;"]},{"entry":[{},"\u2003LgUns eventMask;"]},{"entry":[{},"} PWRM_notifyObj;"]},{"entry":[{},"QUE_Obj PWRM_notifyQueues[PWRM_NUMQUEUES] ="]},{"entry":[{},"{"]},{"entry":[{},"\u2003{&PWRM_notifyQueues[0], &PWRM_notifyQueues[0]},"]},{"entry":[{},"\u2003{&PWRM_notifyQueues[1], &PWRM_notifyQueues[1]},"]},{"entry":[{},"\u2003{&PWRM_notifyQueues[2], &PWRM_notifyQueues[2]},"]},{"entry":[{},"\u2003{&PWRM_notifyQueues[3], &PWRM_notifyQueues[3]},"]},{"entry":[{},"\u2003{&PWRM_notifyQueues[4], &PWRM_notifyQueues[4]},"]},{"entry":[{},"};"]},{"entry":[{},"Void * PWRM_delayCompletionFxns[PWRM_NUMQUEUES] ="]},{"entry":[{},"{"]},{"entry":[{},"\u2003_PWRM_delayCompletion0,"]},{"entry":[{},"\u2003_PWRM_delayCompletion1,"]},{"entry":[{},"\u2003_PWRM_delayCompletion2,"]},{"entry":[{},"\u2003_PWRM_delayCompletion3,"]},{"entry":[{},"\u2003_PWRM_delayCompletion4,"]},{"entry":[{},"};"]},{"entry":[{},"Void_PWRM_delayCompletion0(Void)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003ATM_deci(&PWRM_notifyWaitcount[0]);"]},{"entry":[{},"}"]},{"entry":[{},"..."]},{"entry":[{},"volatile Int PWRM_notifyWaitCount[PWRM_NUMQUEUES] ="]},{"entry":[{},"{"]},{"entry":[{},"\u20030,"]},{"entry":[{},"\u20030,"]},{"entry":[{},"\u20030,"]},{"entry":[{},"\u20030,"]},{"entry":[{},"\u20030,"]},{"entry":[{},"\u20030"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A complete power management strategy includes runtime power management support as described herein, plus the ability to measure power consumption as an application executes to gauge the effectiveness of different runtime power management techniques. By varying techniques and comparing the resulting power consumption, an application developer can choose the appropriate techniques for the application and\/or tune operating parameters for optimal performance. Coupling runtime power management support with a measurement tool enables a new application development flow, whereby power consumption is measured and tuned as part of the regular application development process rather than waiting until development is complete.",{"@attributes":{"id":"p-0053","num":"0064"},"figref":"FIG. 4","b":["4000","4002","4004","4006","4006","4002","4008","4012","4010","1000","1008","4014","4000"]},{"@attributes":{"id":"p-0054","num":"0065"},"figref":["FIG. 5","FIG. 4"],"b":["5000","5002","5004","5000","5002","5004","5004","5002","5006","5008","1000"]},"An embedded application with a logical architecture as illustrated in  is built on host computer  and downloaded to target system . Target system  is comprised of at least one digital signal processor (DSP) . DSP  comprises emulation circuitry providing a standard JTAG debug interface with two additional terminals or pins (interchangeably referred to as nET and nET or EMU and EMU) supporting various extended debugging capabilities. Such emulation circuitry is well known in the art and is described in detail in U.S. Pat. No. 5,828,824 issued to Gary Swoboda. These terminals may be used to export trigger signals from DSP  without interfering with any other functionality of the standard JTAG debug interface. These terminals may be made available for triggering a power measurement device. Other pins of DSP  may also be used to export trigger signals, such as an XF pin, any general purpose I\/O (GPIO) pin or any user configurable pin that can be controlled through software.","Various types of power measurement devices, e.g. oscilloscopes, multimeters, special purpose boards, etc., and means for connecting the devices to the system may be employed. In this embodiment, the power measurement device is oscilloscope . Oscilloscope  is connected by a current probe to a power measurement point on target system . It receives signals to start and stop power measurements via a trigger connected to target system . Oscilloscope  is also connected to host computer  via Interface Board  to permit collection of power measurement data.","The system of  is able to measure power consumption in real-time of an application executing on target system . Power analysis software  can collect power measurement data in real-time at a function or task level and correlate that data to show the power consumption of the application by function or task so that power \u201chot spots\u201d may be identified. Power analysis software  can also collect power measurement data for a user-specified execution range. Power measurements may include total energy, maximum and average power consumption, and peripheral activity. These measurements may be displayed in either textual or graphical form. Pending U.S. patent application Ser. No. 10\/325,024 entitled Power Profiling System and Method for Correlating Runtime Information (TI 34464) describes the capabilities of such power analysis systems in more detail and is incorporated herein by reference.","PSL  of  comprises a software library providing functionality to allow applications developers to incorporate functionality in an application to manage both frequency and voltage scaling. PSL  provides hardware abstraction, portability, and a standard API that enables its use on differing processors. Entities of the application (e.g., application code, peripheral drivers, packaged content, the operating system clock module, etc.) may utilize this API to manage frequency and voltage scaling. Included in the API are routines that initiate scaling operations, and various query routines that provide information on current settings and available frequency\/voltage settings. Frequency changes are initiated directly by entity request. Voltage changes are performed indirectly by PSL  when a frequency changes is requested. PSL  will automatically scale the voltage to the minimum level required by the requested frequency. In this way, PSL  ensures a valid frequency\/voltage setting at all times.","In an embodiment, PSL  is delivered as two code libraries: a scaling library and a configuration library. The scaling library contains a target specific implementation of scaling functionality. A distinct scaling library is provided for each processor\/voltage regulator control scheme combination as different processors may have different clock generators, and different regulators may have different methods of control. The configuration library provides system and target board specific data to the scaling library. This configuration library contains user configurable data permitting a scaling library implementation to be adapted to custom target boards.","An embodiment of PSL  is presented below. In this embodiment, the target processor is the TMS320C5510 (\u201cC5510\u201d) from Texas Instruments Incorporated. The C programming language is used for the examples. In this embodiment, the scaling library is PSL.lib and the configuration library is PSL_cfg.lib.","PSL_cfg.lib comprises two configuration data files PSLclk_cfg.c and PLSvolt_cfg.c. The file PSLclk_cfg.c contains configuration data relating to the clock(s) that will be controlled by the scaling library. The data in this file is device-specific, but typically, it will include items such as input frequency, maximum operating frequency, the table of operating frequencies that will be supported by the scaling library, and perhaps some latency information relating to frequency scaling operations. The variable declarations for this data, as well as the type definitions that define the structure of this data, are provided in a separate file, PSLclk_cfg.h.","The file PSLvolt_cfg.c contains configuration data relating to the operating voltages that are supported by the device, and data relating to the voltage regulator controller. This file will typically include a table of voltages and their corresponding maximum frequencies, data that specifies how the voltage regulator is controlled, and latency information relating to voltage scaling operations. The variable declarations for this data, as well as the type definitions that define the structure of this data, are provided in a separate file, PSLvolt_cfg.h.","The scaling library does not require a specific voltage regulator control scheme. Instead, the scaling library provides built-in support for a default control scheme, and a mechanism that allows application developers to override the built-in support for custom target boards.","For the C5510, which has only one clock, the clock configuration data contained in PSLclkcfg.c and its associated declarations file PSLclk_cfg.h is presented in Tables 18\u201321. The clock configuration variables are described in Table 18.",{"@attributes":{"id":"p-0065","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Variable","Description","Code"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PSL_clkmdRegAddr","specifies the address of the clock","const unsigned PSL_clkmdRegAddr = 0x1C00;"]},{"entry":[{},"mode register in I\/O space"]},{"entry":["PSL_cpuMaxFreq","specifies the maximum frequency, in","const float PSL_cpuMaxFreq = 200.0 f;"]},{"entry":[{},"MHz units, at which it is safe to"]},{"entry":[{},"operate the CPU. The maximum"]},{"entry":[{},"frequency of the CPU on the C5510"]},{"entry":[{},"DSK is 200 MHz. This maximum"]},{"entry":[{},"frequency should he obtained from"]},{"entry":[{},"the device's data sheet."]},{"entry":["PSL_cpuInputFreq","specifies, the input frequency","const float PSL_cpuInputFreq = 24.0 f;"]},{"entry":[{},"(CLKIN) in MHz units. The input"]},{"entry":[{},"frequency on the C5510 is 24 MHz."]},{"entry":["PSL_cpuFreqCnt","specifies the number of frequencies","const unsigned PSL_cpuFreqCnt = 16;"]},{"entry":[{},"that will be supported by the PSL. It"]},{"entry":[{},"also specifies the number of entries in"]},{"entry":[{},"the frequency table of Table 19."]},{"entry":[{},"Here, acceptable values are those in"]},{"entry":[{},"the range 1 ...16."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table 19 presents a definition of the frequency table, PSL_cpuFreqTable. PSL_cpuFreqTable contains the frequencies that are supported by the scaling library. In this example, the table may contain from 1 to 16 frequencies. Internally, the scaling library creates a setpoint for each frequency. The ordering of the setpoints matches the ordering of the frequencies in the frequency table. Each entry in the frequency table is of type PSL_CPUFreq, which is defined in the file PSLclk_cfg.h. The definition of PSL_CPUFreq is contained in Table 6. In this definition, PLL_mult is a value in the range 2 . . . 31. This value, in conjunction with the input frequency and PLL_div, determines the CPU clock frequency when operating in lock mode. PLL_div is a value in the range 0 . . . 3. This value, in conjunction with the input frequency and PLL_mult, determines the CPU clock frequency when operating in lock mode. bypass_div is a value in the range 0 . . . 3. It specifies the input frequency divider when operating in bypass mode.","The clock generator on the C5510 device has two operating modes: bypass and lock mode. The type PSL_ClkMode, which is defined in PSLclk_cfg.h, represents these modes. The definition of PSL_ClkMode is presented in Table 19. In PSL_BYPASS mode, the PLL is bypassed and the frequency of the output clock signal is equal to the frequency of the input clock signal divided by 1, 2, or 4. Because the PLL is disabled in this case, this mode consumes less power. In PSL_LOCK mode, the input frequency can be both multiplied and divided to produce the desired output frequency. In bypass mode, the clock frequency can be calculated using the following equation:\n\nClock frequency=input frequency\/(bypass_div+1)\n\nIn lock mode, the clock frequency can be calculated using the following equation:\n\nClock frequency=(PLL_mult\/(PLL_div+1))*input frequency\n",{"@attributes":{"id":"p-0068","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 19"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PSL_CPUFreq PSL_cpuFreqTable[] = {"},{"entry":"{0, 0, 3, PSL_BYPASS}, \/\/ 6 MHz (input freq \/ 4), bypass mode"},{"entry":"{0, 0, 1, PSL_BYPASS}, \/\/ 12 MHz (input freq \/ 2), bypass mode"},{"entry":"{0, 0, 0, PSL_BYPASS}, \/\/ 24 MHz (input freq \/ 1), bypass mode"},{"entry":"{ 2, 0, 0, PSL_LOCK}, \/\/ 48 MHz (input freq * (2 \/ 1)), lock mode"},{"entry":"{ 5, 1, 0, PSL_LOCK}, \/\/ 60 MHz (input freq * (5 \/ 2)), lock mode"},{"entry":"{ 3, 0, 0, PSL_LOCK}, \/\/ 72 MHz (input freq * (3 \/ 1)), lock mode"},{"entry":"{ 7, 1, 0, PSL_LOCK}, \/\/ 84 MHz (input freq * (7 \/ 2)), lock mode"},{"entry":"{ 4, 0, 0, PSL_LOCK}, \/\/ 96 MHz (input freq * (4 \/ 1)), lock mode"},{"entry":"{ 9, 1, 0, PSL_LOCK}, \/\/ 108 MHz (input freq * (9 \/ 2)), lock mode"},{"entry":"{ 5, 0, 0, PSL_LOCK}, \/\/ 120 MHz (input freq * (5 \/ 1)), lock mode"},{"entry":"{11, 1, 0, PSL_LOCK}, \/\/ 132 MHz (input freq * (11 \/ 2)), lock mode"},{"entry":"{ 6, 0, 0, PSL_LOCK}, \/\/ 144 MHz (input freq * ( 6 \/ 1)), lock mode"},{"entry":"{13, 1, 0, PSL_LOCK}, \/\/ 156 MHz (input freq * (13 \/ 2)), lock mode"},{"entry":"{ 7, 0, 0, PSL_LOCK}, \/\/ 168 MHz (input freq * ( 7 \/ 1)), lock mode"},{"entry":"{15, 1, 0, PSL_LOCK}, \/\/ 180 MHz (input freq * (15 \/ 2)), lock mode"},{"entry":"{25, 2, 0, PSL_LOCK}, \/\/ 200 MHz (input freq * (25 \/ 3)), lock mode"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0069","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 20"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct {"]},{"entry":[{},"\u2003unsigned PLL_mult;"]},{"entry":[{},"\u2003unsigned PLL_div;"]},{"entry":[{},"\u2003unsigned bypass_div;"]},{"entry":[{},"\u2003PSL_ClkMode mode;"]},{"entry":[{},"} PSL_CPUFreq;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0070","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 21"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum { \/\/ clock's operating mode"]},{"entry":[{},"\u2003PSL_BYPASS,"]},{"entry":[{},"\u2003PSL_LOCK"]},{"entry":[{},"} PSL_ClkMode;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The file PSLvolt_cfg.c contains voltage configuration data relating to the operating voltages that are supported by processor, and data relating to the voltage regulator controller. The variable declarations for this data, as well as the type definitions that define the structure of this data, are provided in PSLvolt_cfg.h. The voltage configuration data for the C5510 device is presented below.","PSL_voltCnt, defined as const unsigned PSL_voltCnt=2;, specifies the number of voltage points that are supported by the voltage regulator. The C5510 can operate at two different voltages so the value PSL_voltCnt is set to 2. The voltage table, PSL_voltTable, lists the supported voltage points and their associated maximum frequencies. These values are generally obtained from the device's data sheet. The voltages are listed in increasing order starting with the smallest. Each entry in the voltage table is of type PSL_VoltTable, which is defined in the file PSLvolt_cfg.h. The definition of the type PSL_VoltTable is shown in Table 22 where volt specifies a voltage point, and freq specifies the maximum operating frequency for this voltage. The maximum operating frequency for a given voltage should be obtained from the device's data sheet.",{"@attributes":{"id":"p-0073","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 22"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct {"]},{"entry":[{},"float volt; \/\/ voltage"]},{"entry":[{},"float freq; \/\/ frequency for PSL_CPU_CLK"]},{"entry":[{},"}"]},{"entry":[{},"PSL_VoltTable;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0074","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 23"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_VoltTable PSL_voltTable[] = {"]},{"entry":[{},"{1.1f, 72.0f}, \/\/ 0 MHz up to, and including 72 MHz, require a"]},{"entry":[{},"\/\/ minimum voltage of 1.1V."]},{"entry":[{},"{1.6f, 200.0f}, \/\/ frequencies > 72 MHz up to the max frequency"]},{"entry":[{},"\/\/ require a minimum voltage of 1.6V."]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Table 24 describes other data comprising the voltage configuration file. Any data that is related to GPIO pins is only present if one or more GPIO pins are to be used to control the voltage regulator.",{"@attributes":{"id":"p-0076","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 24"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Variable","Description","Code"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PSL_voltDecreaseLatency","specify the maximum latencies","const unsigned PSL_voltDecreaseLatency = 3300; \/\/"]},{"entry":["PSL_voltIncreaseLatency","incurred during voltage scaling","3.3 milliseconds"]},{"entry":[{},"operations. The latency is","const unsigned PSL_voltIncreaseLatency = 300; \/\/"]},{"entry":[{},"given in microseconds.","300 microseconds"]},{"entry":[{},"Following the initiation of a"]},{"entry":[{},"voltage scaling operation, the"]},{"entry":[{},"latency is the time required"]},{"entry":[{},"before the new voltage has"]},{"entry":[{},"been reached. These latencies"]},{"entry":[{},"are system specific and are"]},{"entry":[{},"measured for each different"]},{"entry":[{},"target board."]},{"entry":["PSL_voltRegInitFunc","specifies the function that","PSL_VoltRegInitFunc PSL_voltRegInitFunc = PSL"]},{"entry":[{},"performs any one-time","gpioVoltRegInit_DSK5510;"]},{"entry":[{},"initialization that may be"]},{"entry":[{},"required before the voltage"]},{"entry":[{},"regulator can perform scaling"]},{"entry":[{},"operations. For the C5510, this"]},{"entry":[{},"variable is initialized to the"]},{"entry":[{},"default initialization routine."]},{"entry":["PSL_voltRegScaleFunc","specifies the function that","PSL_VoltRegScaleFunc"]},{"entry":[{},"performs voltage scaling. For","PSL_voltRegScaleFunc = PSL"]},{"entry":[{},"the C5510, this variable is","gpioVoltRegScale_DSK5510;"]},{"entry":[{},"initialized to the default scaling"]},{"entry":[{},"routine."]},{"entry":["PSL_gpioIodirAddr","specify the addresses of GPIO","const unsigned PSL_gpioIodirAddr = 0x3400;"]},{"entry":["PSL_gpioIodataAddr","IODIR and IODATA registers","const unsigned PSL_gpioIodataAddr = 0x3401;"]},{"entry":[{},"in I\/O space."]},{"entry":["PSL_gpioPinsMask","a mask that specifies which","const unsigned PSL_gpioPinsMask = 0x1; \/\/"]},{"entry":[{},"GPIO pin(s) is\/are used to","GPIO bit 0"]},{"entry":[{},"control the voltage regulator."]},{"entry":["PSL_GpioVoltRegTable","contains the GPIO bit settings","PSL_GpioVoltRegTable"]},{"entry":[{},"for each voltage","PSL_gpioVoltRegTable[] = {"]},{"entry":[{},"supported by the regulator.","{1.1 f, 0x0}, \/\/ set GPIO bit 0 to a 0"]},{"entry":[{},{},"{1.6 f, 0x1}, \/\/ set GPIO bit 0 to a 1"]},{"entry":[{},{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"PSL  does not require a specific voltage regulator control scheme. Instead, built-in support for a de fault control scheme is provided along with a mechanism that allows application developers to override the built-in support with their own implementations. For the C5510, the default support provides for controlling the voltage regulator via the GPIO pins. The presence or absence of the macro USING_DEFAULT_VOLT_REG_CONTROL, defined in PSLvolt_cfg.h, determines whether the default support is used.","If the voltage regulator on the target board is controlled via GPIO pins, the configuration data in PSLvolt_cfg.c permits the application developer to specify the GPIO pin(s) used to control the regulator and the pin values for each voltage. For example, the default values for PSL_gpioPinsMask and PSL_gpioVoltRegTable provided in PSLvolt_cfg.c for the C5510, where the voltage regulator is controlled by GPIO pin  and supports two voltage points are shown in Table 25.",{"@attributes":{"id":"p-0079","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 25"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const unsigned PSL_gpioPinsMask = 0x1; \/\/ GPIO pin 0"]},{"entry":[{},"PSL_GpioVoltRegTable PSL_gpioVoltRegTable[] = {"]},{"entry":[{},"{1.1f, 0x0}, \/\/ set GPIO pin 0 to a 0 for 1.1v"]},{"entry":[{},"{1.6f, 0x1}, \/\/ set GPIO pin 0 to a 1 for 1.6v"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"0"},"As another example, consider a case where the voltage regulator is controlled by GPIO pins  and , and there are four voltage points 0.9 v, 1.1 v, 1.3 v, and 1.6 v. The values for PSL_gpioPinsMask and PSL_gpioVoltRegTable in this instance are shown in Table 26.",{"@attributes":{"id":"p-0081","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 26"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"const unsigned PSL_gpioPinsMask = 0x3; \/\/ GPIO pins 0 and 1"},{"entry":"PSL_GpioVoltRegTable PSL_gpioVoltRegTable = {"},{"entry":"{0.9f, 0x0}, \/\/ set both GPIO pin 0 and 1 to a 0 for 0.9v"},{"entry":"{1.1f, 0x1}, \/\/ set GPIO pin 0 to a 1 and GPIO pin 1 to a 0 for 1.1v"},{"entry":"{1.3f, 0x2}, \/\/ set GPIO pin 0 to a 0 and GPIO pin 1 to a 1 for 1.3v"},{"entry":"{1.6f, 0x3}, \/\/ set both GPIO pin 0 and 1 to a 1 for 1.6v"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"An application developer may override the default voltage regulator support with custom support. The configuration data provides function pointers that enable application developers to supply their own voltage regulator control functions. For the C5510, the function pointers refer to the functions that use GPIO pins to control the regulator. The default implementation can be overridden by changing the function pointers to refer to developer-supplied functions. Two functions are required: an initialization function and a scaling function. The initialization function is of type PSL_VoltRegInitFunc, the definition of which is shown in Table 27. The scaling function is of type PSL_VoltRegScaleFunc, the definition of which is shown in Table 28.",{"@attributes":{"id":"p-0083","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function","typedef void (* PSL_VoltRegInitFunc)(void);"]},{"entry":["Description","Function that performs any one-time initialization that"]},{"entry":[{},"may be required before the voltage"]},{"entry":[{},"regulator can perform scaling operations."]},{"entry":["Parameters","none"]},{"entry":["Return Value","none"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0084","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Function typedef void (* PSL_VoltRegScaleFunc)(float currVoltage,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"float newVoltage,"]},{"entry":[{},"float currFrequency,"]},{"entry":[{},"\u2003int\u2003wait);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","Function that scales the voltage to the specified voltage. If wait is TRUE, wait until the"]},{"entry":[{},"new voltage has been reached."]},{"entry":["Parameters","currVoltage [in]\u2003the current voltage."]},{"entry":[{},"newVoltage [in]\u2003the new voltage."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"currFrequency [in]","the current clock frequency of the device that is"]},{"entry":[{},{},"executing this routine. The frequency may be needed to"]},{"entry":[{},{},"implement a delay loop in cases where wait is TRUE and"]},{"entry":[{},{},"the voltage regulator provides no notification as to when"]},{"entry":[{},{},"the new voltage has been reached."]},{"entry":[{},"wait [in]","TRUE if this routine should wait for the new voltage to"]},{"entry":[{},{},"reach the regulation point. FALSE otherwise."]},{"entry":[{},"Return Value ","none"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"As mentioned previously, PSL  comprises a standard API for power scaling functionality. The implementation of this fimctionality may vary based on processor and voltage regulator capabilities but the API remains the same. Table 29 presents a summary of the functions in this API. See the table listed in the table column of Table 29 for a more detailed description of each function. Several types are used in these API functions: PSL_ClkID, PSL_Setpoint, PSL_Status, PSL_PrologueFunc, PSL_EpilogueFunc, and PSL_ClkMode. These types are defined below to aid in understanding the API functions.",{"@attributes":{"id":"p-0086","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Function","Description","Table"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PSL_initialize","Initializes the power scaling library","35"]},{"entry":["PSL_getNumSetpoints","Returns the number of valid setpoints for the specified clocks.","36"]},{"entry":["PSL_getSetpoints","Returns the current setpoint for each of the specified clocks.","37"]},{"entry":["PSL_changeSetpoints","For each of the specified clocks, initiates a scaling operation to","38"]},{"entry":[{},"the new setpoint. This includes setting the CPU clock frequency"]},{"entry":[{},"and clock mode, and possibly the voltage to those specified by"]},{"entry":[{},"the clock's new setpoint."]},{"entry":["PSL_querySetpoints","Returns the clock frequency, clock mode, and voltage that are","39"]},{"entry":[{},"associated with each of the specified setpoints."]},{"entry":["PSL_querySetpointFrequencies","Returns the clock frequency that is associated with each of the","40"]},{"entry":[{},"specified set points."]},{"entry":["PSL_querySetpointVoltages","Returns the voltage that is associated with each of the specified","41"]},{"entry":[{},"setpoints."]},{"entry":["PSL_querySetpointModes","Returns the clock mode that is associated with each of the","42"]},{"entry":[{},"specified setpoints."]},{"entry":["PSL_querySetpointTransitions","Returns the maximum scaling latencies that are associated with","43"]},{"entry":[{},"each of the specified setpoint changes."]},{"entry":["PSL_getFrequencies","Returns the current clock frequency for each of the specified","44"]},{"entry":[{},"clocks."]},{"entry":["PSL_getModes","Returns the current clock mode (e.g. PSL_BYPASS or","45"]},{"entry":[{},"PSL_LOCK) for each of the specified clocks."]},{"entry":["PSL_getVoltage","Return the current voltage.","46"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"PSL_ClkID, illustrated in Table 30, defines the different clocks that are supported by the power scaling library. For the C5510, there is only one clock. Multi-core devices that have more than one clock will define multiple clocks.",{"@attributes":{"id":"p-0088","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 30"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"\u2003PSL_CPU_CLK = 0"]},{"entry":[{},"} PSL_ClkID;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"PSL_Setpoint, defined as typedef unsigned PSL_Setpoint;, is an unsigned integer type used to refer to a discrete frequency and voltage operating point, i.e. a setpoint, that is supported by the PSL. The voltage of a setpoint is the minimum operating voltage that is required to support the frequency of the setpoint. All scaling operations are performed on setpoints. Each clock supported by the scaling library has a separate set of setpoints. The number of setpoints associated with a specific clock corresponds directly to the number of entries in the clock's frequency table. The ordering of the setpoints also corresponds directly to the ordering specified by the frequency table. For the C5510 device, the scaling library supports one clock, which is referred to as PSL_CPU_CLK. Thus, the C5510 device has only one set of setpoints.","PSL_Status, illustrated in Table 31, specifies the return status of several scaling functions. If the return status is PSL_OK, the function executed without error. A return value other than PSL_OK indicates that the function encountered an error during execution.",{"@attributes":{"id":"p-0091","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 31"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"PSL_OK,"]},{"entry":[{},"PSL_INVALID_CLK,"]},{"entry":[{},"PSL_INVALID_FREQ,"]},{"entry":[{},"PSL_INVALID_INITIAL_FREQ,"]},{"entry":[{},"PSL_INVALID_INITIAL_VOLTAGE,"]},{"entry":[{},"PSL_INVALID_SETPOINT,"]},{"entry":[{},"PSL_MAX_FREQ_EXCEEDED,"]},{"entry":[{},"PSL_MAX_VOLTAGE_EXCEEDED,"]},{"entry":[{},"PSL_INCOMPATIBLE_VOLTAGE,"]},{"entry":[{},"PSL_INCOMPLETE_INITIALIZATION,"]},{"entry":[{},"PSL_CANNOT_CHANGE_SETPOINT"]},{"entry":[{},"} PSL_Status;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"PSL_PrologueFunc, illustrated in Table 32, is a pointer to a function that is called immediately before a scaling operation (i.e., immediately before a setpoint change). This callback allows applications to perform any peripheral modifications required prior to the upcoming scaling operation. For example, the application may need to stop a timer prior to changing the clock frequency.",{"@attributes":{"id":"p-0093","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 32"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef void (* PSL_PrologueFunc)(unsigned\u2003\u2003\u2002count,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID\u2003\u2002*clks,"]},{"entry":[{},"PSL_Setpoint *currentSetpoints"]},{"entry":[{},"PSL_Setpoint *newSetpoints);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"PSL_EpilogueFunc, illustrated in Table 33, is a pointer to a function that is called immediately after a scaling operation, i.e., immediately after a setpoint change. This callback allows an application to perform any peripheral modifications required as a result of the just completed scaling operation. For example, the application may need to reprogram and restart a timer after changing the clock frequency.",{"@attributes":{"id":"p-0095","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 33"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef void (* PSL_EpilogueFunc)(unsigned\u2003\u2003\u2002count,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID\u2003\u2002*clks,"]},{"entry":[{},"PSL_Setpoint *oldSetpoints,"]},{"entry":[{},"PSL_Setpoint *currentsetpoints);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"PSL_ClkMode, illustrated in Table 34, specified the different operating modes of the CPU clock. The clock on C5510 devices can operate in either bypass or lock mode.",{"@attributes":{"id":"p-0097","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 34"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum { \/\/ clock's operating mode"]},{"entry":[{},"\u2003PSL_BYPASS,"]},{"entry":[{},"\u2003PSL_LOCK"]},{"entry":[{},"} PSL_ClkMode;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0098","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 35"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_initialize(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002PSL_ClkID","*clks,"]},{"entry":[{},"\u2002unsigned","*initFrequencies,"]},{"entry":[{},"\u2002float","\u2002initVoltage)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","Perform any initialization required by the power scaling library."]},{"entry":[{},"The initial clock frequency and operating mode for each clock are determined"]},{"entry":[{},"according to the values specified in the initFrequencies array. The values in"]},{"entry":[{},"this array are indices into a clock's associated frequency table. This routine does not"]},{"entry":[{},"actually change the frequency of any clock. Instead, it assumes that a clock's initial"]},{"entry":[{},"frequency is also the clock's current frequency. An initial frequency must be supplied for"]},{"entry":[{},"every clock that is defined by the enum type PSL_ClkID. The initial voltage is specified"]},{"entry":[{},"by initVoltage. This routine does not actually change the voltage. Instead, it assumes that"]},{"entry":[{},"the initial voltage is also the current voltage. The initial voltage must match one of the"]},{"entry":[{},"voltages specified in the voltage table. The initial setpoint for each clock will specify the"]},{"entry":[{},"clock's initial frequency and the minimum voltage required for that frequency."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},{},"The count must specify the number of clocks"]},{"entry":[{},{},"defined by the enum type PSL_ClkID."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count. Every"]},{"entry":[{},{},"clock that is defined by the enum type PSL_ClkID must be"]},{"entry":[{},{},"present in the array."]},{"entry":[{},"*initFrequencies [in]","Pointer to locations that specify the initial frequency of each"]},{"entry":[{},{},"clock. The values in this array are indexes into a clock's"]},{"entry":[{},{},"associated frequency table. The initial frequency for clks[0] is"]},{"entry":[{},{},"specified by initFrequencies[0], the initial frequency for clks[1]"]},{"entry":[{},{},"is specified by initFrequencies[1], etc."]},{"entry":[{},"initVoltage [in]","The initial voltage."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Return Value"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_OK","If all initialization required for the correct"]},{"entry":[{},{},"operation of the scaling library succeeds. If"]},{"entry":[{},{},"initialization does not succeed, all setpoints for"]},{"entry":[{},{},"all clocks are considered invalid"]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_FREQ","If any of the clock frequencies tables are empty,"]},{"entry":[{},{},"there are more than 16 entries in any of the"]},{"entry":[{},{},"frequencies tables, or any of the values (mult,"]},{"entry":[{},{},"div, mode) for a specific clock are invalid."]},{"entry":[{},"PSL_INVALID_INITIAL_FREQ","If any of the values specified in the"]},{"entry":[{},{},"initFrequencies array are invalid indexes into the"]},{"entry":[{},{},"corresponding clock's frequency table."]},{"entry":[{},"PSL_MAX_FREQ_EXCEEDED","If any of the frequencies specified in a"]},{"entry":[{},{},"clock's frequency table exceed the maximum"]},{"entry":[{},{},"operating frequency of the device that the clock"]},{"entry":[{},{},"is controlling."]},{"entry":[{},"PSL_INCOMPATIBLE_VOLTAGE","If the initial voltage as specified by initVoltage"]},{"entry":[{},{},"is less than the voltage required by any of the"]},{"entry":[{},{},"initial setpoints."]},{"entry":[{},"PSL_INVALID_INITIAL_VOLTAGE","If the intial voltage as specified by initVoltage is"]},{"entry":[{},{},"not one of the voltages specified in the voltage"]},{"entry":[{},{},"table."]},{"entry":[{},"PSL_MAX_VOLTAGE_EXCEEDED","If any of the values in the user configurable data"]},{"entry":[{},{},"are beyond the maximum supported voltage."]},{"entry":[{},"PSL_INCOMPLETE_INITIALIZATION","If an initial frequency is not supplied for every"]},{"entry":[{},{},"clock defined by the enum type PSL_ClkID."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0099","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 36"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_getNumSetpoints(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"unsigned","*numSetpoints)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the number of valid setpoints for the specified clocks."]},{"entry":[{},"If a clock has n valid setpoints, the valid setpoints for that clock are those in"]},{"entry":[{},"the range (0...\u25a1n\u22121). No setpoint for any clock is considered valid until the"]},{"entry":[{},"power scaling library has been successfully initialized."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number"]},{"entry":[{},{},"of clocks referred to by the pointer should match the"]},{"entry":[{},{},"count."]},{"entry":[{},"*numSetpoints [out]","Pointer to locations to store the setpoint count for each"]},{"entry":[{},{},"of the clocks referred to by the clks pointer. The"]},{"entry":[{},{},"number of valid setpoints for clks[0] will be returned"]},{"entry":[{},{},"in numSetpoints[0], the valid number of setpoints for"]},{"entry":[{},{},"clks[1] will be returned in numSetpoints[1], etc."]},{"entry":"Return Value"},{"entry":[{},"PSL_OK","If all of the specified clocks are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0100","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 37"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_getSetpoints(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PSL_ClkID","*clks,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PSL_Setpoint *setpoints)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Description","This function returns the current setpoint for each of the specified clocks."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*setpoints [out]","Pointer to locations to store the current setpoint for each of the"]},{"entry":[{},{},"clocks referred to by the clks pointer. The current setpoint for"]},{"entry":[{},{},"clks[0] will be returned in setpoints[0], the current setpoint for"]},{"entry":[{},{},"clks[1] will be returned in setpoints[1], etc."]},{"entry":"Return Value"},{"entry":[{},"PSL_OK","If all of the specified clocks are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0101","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 38"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_changeSetpoints(unsigned count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*newSetpoints,"]},{"entry":[{},"int","scaleVoltage,"]},{"entry":[{},"int","waitForVoltScale,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_PrologueFunc prologueFunc,"]},{"entry":[{},"PSL_EpilogueFunc epilogueFunc)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","For each of the specified clocks, this function initiates a scaling operation to"]},{"entry":[{},"the new setpoint. This includes setting the CPU clock frequency and clock"]},{"entry":[{},"mode to those specified by the clock's new setpoint."]},{"entry":[{},"If scaleVoltage is TRUE and the current voltage is not sufficient for any of the new"]},{"entry":[{},"setpoints, then the voltage will be increased to the lowest level that will support all the new"]},{"entry":[{},"setpoints. In this case, the new voltage will also be sufficient for any current setpoint that is"]},{"entry":[{},"not being changed. If a lower voltage is sufficient for all new setpoints as well as all current"]},{"entry":[{},"setpoints that are not being changed, the voltage will be decreased to the lowest level that"]},{"entry":[{},"will support all of these setpoints."]},{"entry":[{},"This routine will not return until the clocks are generating the new frequencies specified by"]},{"entry":[{},"the setpoints. If waitForVoltScale is TRUE and the voltage was actually scaled, then this"]},{"entry":[{},"routine will also wait until the new voltage is reached. In addition, if a voltage increase"]},{"entry":[{},"was required as part of the setpoint changes, or if the device is in an unstable state until the"]},{"entry":[{},"new voltage is reached, then this routine will also wait for the voltage scaling to complete,"]},{"entry":[{},"regardless of waitForVoltScale."]},{"entry":[{},"Prior to initiating any scaling operations, this routine will call the function referenced by"]},{"entry":[{},"prologueFunc. If prologueFunc is NULL, no function is called. Similarly, following the"]},{"entry":[{},"scaling operations, this routine will call the function referred to by epilogueFunc. The call"]},{"entry":[{},"to epilogueFunc will not occur until the clocks are generating the new frequencies. If this"]},{"entry":[{},"routine must wait for the new voltage to be reached, then the call to epilogueFunc will not"]},{"entry":[{},"occur until the voltage has been reached. If epilogueFunc is NULL, no function is called."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*newSetpoints [in]","Pointer to locations that specify the new setpoint for"]},{"entry":[{},{},"each of the clocks referred to by the clks pointer. The"]},{"entry":[{},{},"new setpoint for clks[0] is specified by newSetpoints[0], the"]},{"entry":[{},{},"new setpoint for clks[1] is specified by newSetpoints[1], etc."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scaleVoltage [in] TRUE if the voltage should be scaled when necessary."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"FALSE if the voltage should not be scaled."]},{"entry":[{},"WaitForVoltScale [in]","TRUE if this routine should wait for the new voltage to"]},{"entry":[{},{},"be reached after initiating the voltage scaling."]},{"entry":[{},{},"FALSE if waiting is not required. Note that this"]},{"entry":[{},{},"parameter is ignored if a voltage increase is required"]},{"entry":[{},{},"or if the device is in an unstable state until the new"]},{"entry":[{},{},"voltage is reached. In these cases, this routine will"]},{"entry":[{},{},"always wait for the voltage scaling to complete."]},{"entry":[{},"prologueFunc [in]","Function called prior to scaling operations. NULL if no"]},{"entry":[{},{},"function is to be called."]},{"entry":[{},"epilogueFunc [in]","Function called after the scaling operations have"]},{"entry":[{},{},"completed. NULL if no function is to be called."]},{"entry":"Return Value"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_OK","If the setpoint changes were successful."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_SETPOINT","If any of the new setpoints are invalid. A"]},{"entry":[{},{},"clock's valid setpoints are those in the range"]},{"entry":[{},{},"(0...n\u22121), where n is the number of valid"]},{"entry":[{},{},"setpoints returned by"]},{"entry":[{},{},"PSL_getNumSetpoints( ). No scaling"]},{"entry":[{},{},"operations are performed if any of the"]},{"entry":[{},{},"setpoints are invalid."]},{"entry":[{},"PSL_INCOMPATIBLE_VOLTAGE","If scaleVoltage is FALSE and the current"]},{"entry":[{},{},"voltage is less than the voltage required by"]},{"entry":[{},{},"any of the new setpoints. No scaling"]},{"entry":[{},{},"operations are performed in this case."]},{"entry":[{},"PSL_CANNOT_CHANGE_SETPOINT","\u2003If the setpoint could not be changed."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0102","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 39"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_querySetpoints(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*setpoints,"]},{"entry":[{},"float","*frequencies,"]},{"entry":[{},"float","*voltages,"]},{"entry":[{},"PSL_ClkMode","*modes)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the clock frequency, clock mode, and voltage that are"]},{"entry":[{},"associated with each of the specified setpoints."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*setpoints [in]","Pointer to locations that specify the setpoints that are"]},{"entry":[{},{},"being queried. The setpoint for clks[0] is specified by"]},{"entry":[{},{},"setpoints[0], the setpoint for clks[1] is specified by"]},{"entry":[{},{},"setpoints[1], etc."]},{"entry":[{},"*frequencies [out]","Pointer to locations to store the frequency associated with each"]},{"entry":[{},{},"setpoint. The frequency for setpoints[0] will be returned in"]},{"entry":[{},{},"frequencies[0], the frequency for setpoints[1] will be returned in"]},{"entry":[{},{},"frequencies[1], etc."]},{"entry":[{},"*voltages [out]","Pointer to locations to store the voltages associated with each"]},{"entry":[{},{},"setpoint. A setpoint's voltage is the minimum voltage required"]},{"entry":[{},{},"for the setpoint's frequency. Note that this voltage may not be"]},{"entry":[{},{},"equal to the current voltage if voltage scaling was not performed"]},{"entry":[{},{},"during PSL_changeSetpoint, or if the"]},{"entry":[{},{},"current setpoint for another clock required a higher"]},{"entry":[{},{},"voltage. The voltage for setpoints[0] will be returned in"]},{"entry":[{},{},"voltages[0], the voltage for setpoints[1] will be returned in"]},{"entry":[{},{},"voltages[1], etc."]},{"entry":[{},"*modes [out]","Pointer to locations to store the clock mode associated"]},{"entry":[{},{},"with each setpoint (e.g. PSL_BYPASS or PSL_LOCK)."]},{"entry":[{},{},"The clock mode for setpoints[0] will be returned in"]},{"entry":[{},{},"modes[0], the clock mode for setpoints[1] will be returned"]},{"entry":[{},{},"in modes[1], etc."]},{"entry":"Return Value"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_OK","If the specified clocks and setpoints are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_SETPOINT","If any of the setpoints are invalid. A clock's valid"]},{"entry":[{},{},"setpoints are those in the range 0\u2013n\u22121, where n is the"]},{"entry":[{},{},"number of valid setpoints returned by"]},{"entry":[{},{},"PSL_getNumSetpoints( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0103","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 40"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_querySetpointFrequencies(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*setpoints,"]},{"entry":[{},"float","*frequencies)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the clock frequency that is associated with each of the"]},{"entry":[{},"specified setpoints."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*setpoints [in]","Pointer to locations that specify the setpoints that are"]},{"entry":[{},{},"being queried. The setpoint for clks[0] is specified by"]},{"entry":[{},{},"setpoints[0], the setpoint for clks[1] is specified by"]},{"entry":[{},{},"setpoints[1], etc."]},{"entry":[{},"*frequencies [out]","Pointer to locations to store the frequency associated with each"]},{"entry":[{},{},"setpoint. The frequency for setpoints[0] will be returned in"]},{"entry":[{},{},"frequencies[0], the frequency for setpoints[1] will be returned in"]},{"entry":[{},{},"frequencies[1], etc."]},{"entry":"Return Value"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_OK","If the specified clocks and setpoints are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_SETPOINT","If any of the setpoints are invalid. A clock's"]},{"entry":[{},{},"valid setpoints are those in the range 0...n\u22121, where n"]},{"entry":[{},{},"is the number of valid setpoints returned by"]},{"entry":[{},{},"PSL_getNumSetpoints( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0104","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 41"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_querySetpointVoltages(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*setpoints,"]},{"entry":[{},"float","*voltages)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the voltage that is associated with each of the specified"]},{"entry":[{},"setpoints."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*setpoints [in]","Pointer to locations that specify the setpoints that are"]},{"entry":[{},{},"being queried. The setpoint for clks[0] is specified by"]},{"entry":[{},{},"setpoints[0], the setpoint for clks[1] is specified by"]},{"entry":[{},{},"setpoints[1], etc."]},{"entry":[{},"*voltages [out]","Pointer to locations to store the voltages associated with each"]},{"entry":[{},{},"setpoint. A setpoint's voltage is the minimum voltage required"]},{"entry":[{},{},"for the setpoint's frequency. Note that this voltage may not be"]},{"entry":[{},{},"equal to the current voltage if voltage scaling was not performed"]},{"entry":[{},{},"during PSL_changeSetpoint, or if the"]},{"entry":[{},{},"current setpoint for another clock required a higher"]},{"entry":[{},{},"voltage. The voltage for setpoints[0] will be returned in"]},{"entry":[{},{},"voltages[0], the voltage for setpoints[1] will be returned in"]},{"entry":[{},{},"voltages[1], etc."]},{"entry":"Return Value"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_OK","If the specified clocks and setpoints are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_SETPOINT","If any of the setpoints are invalid. A clock's"]},{"entry":[{},{},"valid setpoints are those in the range 0 \u25a1"]},{"entry":[{},{},"n\u22121, where n is the number of valid"]},{"entry":[{},{},"setpoints returned by PSL_getNumSetpoints( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0105","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 42"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_querySetpointModes(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*setpoints,"]},{"entry":[{},"PSL_ClkMode","*modes)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Description","This function returns the clock mode that is associated with each of the specified setpoints."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*setpoints [in]","Pointer to locations that specify the setpoints that are"]},{"entry":[{},{},"being queried. The setpoint for clks[0] is specified by"]},{"entry":[{},{},"setpoints[0], the setpoint for clks[1] is specified by"]},{"entry":[{},{},"setpoints[1], etc."]},{"entry":[{},"*modes [out]","Pointer to locations to store the clock mode associated"]},{"entry":[{},{},"with each setpoint (e.g. PSL_BYPASS or PSL_LOCK). The"]},{"entry":[{},{},"clock mode for setpoints[0] will be returned in modes[0], the"]},{"entry":[{},{},"clock mode for setpoints[1] will be returned in modes[1], etc."]},{"entry":"Return Value"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_OK","If the specified clocks and setpoints are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_SETPOINT","If any of the setpoints are invalid. A clock's valid setpoints are"]},{"entry":[{},{},"those in the range 0...n\u22121, where n is the number of valid"]},{"entry":[{},{},"setpoints returned by PSL_getNumSetpoints( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0106","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 43"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_querySetpointTransitions(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*fromSetpoints,"]},{"entry":[{},"PSL_Setpoint","*toSetpoints,"]},{"entry":[{},"unsigned","*freqScalingLatencies,"]},{"entry":[{},"unsigned","*voltageScalingLatency)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the maximum scaling latencies that are associated with each of the"]},{"entry":[{},"specified setpoints changes."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The"]},{"entry":[{},{},"number of clocks referred to by the pointer"]},{"entry":[{},{},"should match the count."]},{"entry":[{},"*fromSetpoints [in]","Pointer to locations that specify the source"]},{"entry":[{},{},"setpoints. The source setpoint for clks[0] is"]},{"entry":[{},{},"specified by fromSetpoints[0], the source"]},{"entry":[{},{},"setpoint for clks[1] is specified by"]},{"entry":[{},{},"fromSetpoints[1], etc."]},{"entry":[{},"*toSetpoints [in]","Pointer to locations that specify the destination"]},{"entry":[{},{},"Setpoints. The destination setpoint for clks[0] is"]},{"entry":[{},{},"specified by toSetpoints[0], the destination"]},{"entry":[{},{},"setpoint for clks[1] is specified by toSetpoints[1], etc."]},{"entry":[{},"*freqScalingLatencies [out]","Pointer to locations to store the maximum"]},{"entry":[{},{},"latencies associated with each of the frequency scaling"]},{"entry":[{},{},"operations that will occur during the specified setpoint"]},{"entry":[{},{},"changes. The latencies are specified in microseconds."]},{"entry":[{},{},"Following the initiation of a frequency scaling"]},{"entry":[{},{},"operation, the latency is the time required before the"]},{"entry":[{},{},"clock starts generating the new frequency. The latency"]},{"entry":[{},{},"for the setpoint change associated with clks[0] is"]},{"entry":[{},{},"specified by freqScalingLatencies[0], the latency for"]},{"entry":[{},{},"the setpoint change associated with clks[1] is specified"]},{"entry":[{},{},"by freqScalingLatencies[1], etc."]},{"entry":[{},"*voltageScalingLatency [out]","Location to store the maximum latency"]},{"entry":[{},{},"associated with the voltage scaling that may"]},{"entry":[{},{},"occur during the specified setpoint changes."]},{"entry":[{},{},"The latency is given in microseconds."]},{"entry":[{},{},"Following the initiation of the voltage scaling"]},{"entry":[{},{},"operation, the latency is the time required"]},{"entry":[{},{},"before the new voltage has been reached."]},{"entry":"Return Value"},{"entry":[{},"PSL_OK","If the specified clocks and setpoints are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":[{},"PSL_INVALID_SETPOINT","If any of the setpoints are invalid. A clock's"]},{"entry":[{},{},"valid setpoints are those in the range (0..."]},{"entry":[{},{},"n\u22121), where n is the number of valid setpoints"]},{"entry":[{},{},"returned by PSL_getNumSetpoints( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0107","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 44"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_getFrequencies(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"float","*frequencies)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the current clock frequency for each of the specified"]},{"entry":[{},"clocks."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*frequencies [out]","Pointer to locations to store the current frequency of each of the"]},{"entry":[{},{},"specified clocks. The current frequency of a clock is the same as"]},{"entry":[{},{},"the frequency returned by"]},{"entry":[{},{},"PSL_querySetpointFrequencies for that clock when that"]},{"entry":[{},{},"function is called with the clock's current setpoint (i.e., the"]},{"entry":[{},{},"current frequency of a clock is always the same as the frequency"]},{"entry":[{},{},"of the clock's current setpoint). The current frequency for"]},{"entry":[{},{},"clks[0] will be returned in frequencies[0], the current frequency"]},{"entry":[{},{},"for clks[1] will be returned in frequencies[1], etc."]},{"entry":"Return Value"},{"entry":[{},"PSL_OK","If all of the specified clocks are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0108","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 45"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Function","PSL_Status PSL_getModes(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_ClkMode","*modes)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Description","This function returns the current clock mode (e.g., PSL_BYPASS or"]},{"entry":[{},"PSL_LOCK) for each of the specified clocks."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameters",{},{}]},{"entry":[{},"count [in]","Specifies the number of clocks pointed to by clks."]},{"entry":[{},"*clks [in]","Pointer to locations that specify the clocks. The number of"]},{"entry":[{},{},"clocks referred to by the pointer should match the count."]},{"entry":[{},"*modes [out]","Pointer to locations to store the current mode of each of the"]},{"entry":[{},{},"specified clocks. The current operating mode of a clock is the"]},{"entry":[{},{},"same as the mode returned by"]},{"entry":[{},{},"PSL_querySetpointModes when that function is called with the"]},{"entry":[{},{},"clock's current setpoint (i.e., the current mode of a clock is"]},{"entry":[{},{},"always the same as the mode of the clock's current setpoint)."]},{"entry":[{},{},"The current mode for clks[0] will be returned in modes[0], the"]},{"entry":[{},{},"current mode for clks[1] will be returned in modes[1], etc."]},{"entry":"Return Value"},{"entry":[{},"PSL_OK","If all of the specified clocks are valid."]},{"entry":[{},"PSL_INVALID_CLK","If any of the specified clocks are invalid."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0109","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 46"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function","float PSL_getVoltage( )"]},{"entry":["Description","This function returns the current voltage."]},{"entry":["Return Value","This function returns the current voltage. If voltage scaling"]},{"entry":[{},"was not performed in any of the calls to"]},{"entry":[{},"PSL_changeSetpoint, the current voltage is assumed to be"]},{"entry":[{},"the initial voltage as specified in the user configurable data."]},{"entry":[{},"If voltage scaling is being done, the current voltage will be"]},{"entry":[{},"the lowest voltage that is sufficient for all of the current"]},{"entry":[{},"setpoints."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"By default, PSL  performs many error checks that prevent the device from running at unsupported frequencies and voltages and unsupported frequency\/voltage combinations. These checks guard against situations such as overclocking and other situations that could cause damage to the device. However, these error checks do increase the code size. For this reason, separate libraries that do not contain these error checks are provided for the application developer to use in the delivered application to decrease the code size. These libraries do not check for the following errors: PSL_INVALID_CLK, PSL_INVALID_FREQ, PSL_INVALID_INITIAL_FREQ, PSL_INVALID_INITIAL_VOLTAGE, PSL_INVALID_SETPOINT, PSL_MAX_FREQ EXCEEDED, PSL_MAX_VOLTAGE_EXCEEDED, PSL_INCOMPATIBLE_VOLTAGE, and PSL_INCOMPLETE_INITIALIZATION. Generally, initial development is done using the default libraries that contain the error checks and a switch is made to the library implementation that perform no error checking after the developer has ensured these errors will not occur.","Tables 48, 51, and 53 contain examples of the use of this embodiment of the scaling functionality. These examples assume that the configuration library is built using the configuration data shown in Table 47. All examples assume that the initial frequency and voltage at system startup are 200 MHz and 1.6 v respectively. The call to scaling library API initialization routine specifies these initial settings. The initial frequency is specified by supplying an index to an entry in PSL_cpuFreqTable[ ]. In the configuration data shown in Table 47, 200 MHz is entry 15 in the table.",{"@attributes":{"id":"p-0112","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 47"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"const float PSL_cpuInputFreq = 24.0f;"},{"entry":"\/\/ 24 MHz input clock (CLKIN) frequency"},{"entry":"const float PSL_cpuMaxFreq = 200.0f;"},{"entry":"\/\/ 200 MHz max operating frequency"},{"entry":"PSL_CPUFreq PSL_cpuFreqTable = {"},{"entry":"\u2003\u2003{0, 0, 3, PSL_BYPASS}, \/\/ 6 MHz (input freq \/ 4), bypass mode"},{"entry":"\u2003\u2003{0, 0, 1, PSL_BYPASS}, \/\/ 12 MHz (input freq \/ 2), bypass mode"},{"entry":"\u2003\u2003{0, 0, 0, PSL_BYPASS}, \/\/ 24 MHz (input freq \/ 1), bypass mode"},{"entry":"\u2003\u2003{2, 0, 0, PSL_LOCK}, \/\/ 48 MHz (input freq * (2 \/ 1)), lock mode"},{"entry":"\u2003\u2003{5, 1, 0, PSL_LOCK}, \/\/ 60 MHz (input freq * ( 5 \/ 2)), lock mode"},{"entry":"\u2003\u2003{3, 0, 0, PSL_LOCK}, \/\/ 72 MHz (input freq * (3 \/ 1)), lock mode"},{"entry":"\u2003\u2003{7, 1, 0, PSL_LOCK}, \/\/ 84 MHz (input freq * (7 \/ 2)), lock mode"},{"entry":"\u2003\u2003{4, 0, 0, PSL_LOCK}, \/\/ 96 MHz (input freq * (4 \/ 1)), lock mode"},{"entry":"\u2003\u2003{9, 1, 0, PSL_LOCK}, \/\/108 MHz (input freq * (9 \/ 2)), lock mode"},{"entry":"\u2003\u2003{5, 0, 0, PSL_LOCK}, \/\/120 MHz (input freq * (5 \/ 1)), lock mode"},{"entry":"\u2003\u2003{11, 1, 0, PSL_LOCK}, \/\/132 MHz (input freq * (11 \/ 2)),"},{"entry":"\u2003\u2003lock mode"},{"entry":"\u2003\u2003{6, 0, 0, PSL_LOCK}, \/\/144 MHz (input_freq * (6 \/ 1)), lock mode"},{"entry":"\u2003\u2003{13, 1, 0, PSL_LOCK}, \/\/156 MHz (input freq * (13 \/ 2)),"},{"entry":"\u2003\u2003lock mode"},{"entry":"\u2003\u2003{7, 0, 0, PSL_LOCK}, \/\/168 MHz (input_freq * ( 7 \/ 1)), lock mode"},{"entry":"\u2003\u2003{15, 1, 0, PSL_LOCK}, \/\/180 MHz (input freq * (15 \/ 2)),"},{"entry":"\u2003\u2003lock mode"},{"entry":"\u2003\u2003{25, 2, 0, PSL_LOCK}, \/\/200 MHz (input_freq * (25 \/ 3)),"},{"entry":"\u2003\u2003lock mode"},{"entry":"};"},{"entry":"PSL_VoltTable PSL_voltTable[] = {"},{"entry":"\u2003\u2003{1.1f, 100.0f}, \/\/ 0 MHz up to, and including 100 MHz, can use the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ lowest supported voltage of 1.1V."},{"entry":"\u2003\u2003{1.6f, 200.0f}, \/\/ frequencies > 100 MHz up to the max frequency"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ require a minimum voltage of 1.6V."},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The example in Table 48 highlights some of the basic scaling library operations. It shows how the scaling functionality is initialized, and how frequency and voltage changes are initiated by the changing of a setpoint. This example calls three functions: func, func, and func and executes func and func at 200 MHz and 1.6 v. It executes func at 72 MHz and 1.1 v.",{"@attributes":{"id":"p-0114","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 48"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u201cPSL.h\u201d"},{"entry":"extern void func1( );"},{"entry":"extern void func2( );"},{"entry":"extern void func3( );"},{"entry":"void main (void)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_Status status;"]},{"entry":[{},"\/\/ Variable specifying PSL_ClkID that will be used in all calls."]},{"entry":[{},"PSL_ClkID clk = PSL_CPU_CLK;"]},{"entry":[{},"\/\/ Index into PSL_cpuFreqTable[] that specifies"]},{"entry":[{},"initial freq of 200 MHz."]},{"entry":[{},"unsigned initFreqIndex = 15;"]},{"entry":[{},"\/\/ PSL_cpuFreqTable[5] represents 72 MHz"]},{"entry":[{},"\/\/ PSL_cpuFreqTable[15] represent 200 MHz"]},{"entry":[{},"PSL_Setpoint_72 MHzSetpoint = 5;"]},{"entry":[{},"PSL_Setpoint_200 MHzSetpoint = 15;"]},{"entry":[{},"\/\/ Initialize the scaling library. The frequency following reset is"]},{"entry":[{},"\/\/ specified by PSL_cpuFreqTable[15]. The voltage"]},{"entry":[{},"following reset is 1.6 v."]},{"entry":[{},"status = PSL_initialize(1, &clk, &initFreqIndex, 1.6f);"]},{"entry":[{},"if (status != PSL_OK)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/ handle error;"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003return;"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ Execute func1 at 200 MHz (i.e., the initial frequency)"]},{"entry":[{},"func1( );"]},{"entry":[{},"\/\/Change frequency to 72 MHz"]},{"entry":[{},"status = PSL_changeSetpoints(1,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"&clk,"]},{"entry":[{},{},"&_72MHzSetpoint,"]},{"entry":[{},{},"TRUE, \/\/ change voltage also"]},{"entry":[{},{},"FALSE,"]},{"entry":[{},{},"NULL, NULL);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (status != PSL_OK) {"]},{"entry":[{},"\u2003\/\/ handle error"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003return;"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ Execute func2 at 72 MHz"]},{"entry":[{},"func2( );"]},{"entry":[{},"\/\/ Change frequency back to 200 MHz"]},{"entry":[{},"status = PSL_changeSetpoints(1,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"&clk,"]},{"entry":[{},{},"&_200MHzSetpoint,"]},{"entry":[{},{},"TRUE, \/\/ change voltage also"]},{"entry":[{},{},"FALSE,"]},{"entry":[{},{},"NULL, NULL);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (status != PSL_OK) {"]},{"entry":[{},"\u2003\/\/ handle error"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003return;"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ Execute func3 at 200 MHz"]},{"entry":[{},"func3( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"When the required frequencies are statically known, as is the case in the example of Table 48, the setpoints can be assigned values that correspond to indexes into PSL_cpuFreqTable[ ]. This is possible because the ordering of the setpoints directly matches the ordering of the frequencies in PSL_cpuFreqTable[ ]. Therefore, locating the setpoint that corresponds to a particular frequency does not require calls to the query routines in this case. For example, the setpoint72 MhzSetpoint is assigned the value 5 since PSL_cpuFreqTable[5] corresponds to 72 MHz. Similarly, the setpoint200 MhzSetpoint is assigned the value 15, which corresponds to the frequency specified by PSL_cpuFreqTable[15].","Separate calls are not required to change both the frequency and the voltage. Instead, applications initiate a frequency, and possibly a voltage change, through a single call to PSL_changeSetpoints. If an application instructs PSL_changeSetpoints to change the voltage, the voltage will be changed automatically to the voltage specified by the setpoint. This voltage will be the lowest voltage that is required to support the new frequency. In the example of Table 48, the initial frequency is 200 MHz and 1.6 v. When the frequency is changed to 72 MHz, the voltage is automatically changed to 1.1 v by the scaling library. Similarly, when the frequency is changed back to 200 MHz, the scaling library will automatically increase the voltage to 1.6 v.","The scaling library can operate in a mode that changes frequency only. This mode is useful if the target board does not have a voltage regulation capability. The fourth parameter of PSL_changeSetpoints specifies whether voltage scaling should be done. So for the example of Table 48, if the call of Table 49 is used to change the frequency to 72 MHz, the frequency is changed to 72 MHz, but the voltage remains at 1.6 v.",{"@attributes":{"id":"p-0118","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 49"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"status = PSL_changeSetpoints(1,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"&clk,"]},{"entry":[{},{},"&_72MHzSetpoint,"]},{"entry":[{},{},"FALSE, \/\/ do not change voltage"]},{"entry":[{},{},"FALSE,"]},{"entry":[{},{},"NULL, NULL);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"A very important feature of PSL  is that it will always maintain a valid frequency\/voltage setting. In the example of Table 48, the scaling library would not allow the application to enter a state where the frequency is 200 MHz and the voltage is 1.1 v. For example, if the second call to PSL_changeSetpoints is that shown in Table 50, the return status will be PSL_INCOMPATIBLE_VOLTAGE and no scaling operations are performed. This is because the frequency\/voltage setting at the point of the call is 72 MHz and 1.1 v. The call of Table 50 instructs the scaling library to increase the frequency to 200 MHz and leave the current voltage of 1.1 v unchanged. However, since 200 MHz requires 1.6 v, the scaling library will not perform the frequency change and will return an error.",{"@attributes":{"id":"p-0120","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 50"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"status = PSL_changeSetpoints(1,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"&clk,"]},{"entry":[{},{},"&_200MHzSetpoint,"]},{"entry":[{},{},"FALSE, \/\/ do not change voltage"]},{"entry":[{},{},"FALSE,"]},{"entry":[{},{},"NULL, NULL);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"When changing the frequency, the effects that the frequency change will have on the rest of the system must be considered. Obviously, frequency changes may affect the amount of time it takes to complete a certain operation. Therefore, frequency changes can only occur if the application's timing requirements continue to be satisfied. Frequency changes can also effect the operation of peripherals. For example, the timer period or the EMIF may need to be reprogrammed as a result of a frequency change.","The example of Table 51 illustrates how to use the callback hooks of PSL  to perform peripheral modifications required as a result of an upcoming or just completed scaling operation. In this example, a function of type PSL_PrologueFunc is used to stop Timer immediately before the scaling operation. A function of type PSL_EpilogueFunc is used to reprogram and restart Timer when the scaling operation completes.",{"@attributes":{"id":"p-0123","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 51"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u201cPSL.h\u201d"},{"entry":"TIMER_Handle timer0Handle;"},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"},{"entry":"\/\/ Function to stop the timer. Called immediately before a"},{"entry":"\/\/ scaling operation is initiated."},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["void StopTimer0(unsigneqd","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*currentSetpoints,"]},{"entry":[{},"PSL_Setpoint","*newSetpoints) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003TIMER_stop(timer0Handle);"},{"entry":"}"},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"},{"entry":"\/\/ Function to reprogram and restart the timer. Called immediately"},{"entry":"\/\/ after a scaling operation completes."},{"entry":"\/\/ Assumes that Timer0 is alreadly stopped"},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["void RestartTimer0(unsigned","count,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*oldSetpoints,"]},{"entry":[{},"PSL_Setpoint","*currentSetpoints) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003float currFreq;"},{"entry":"\u2003unsigned long cycles;"},{"entry":"\u2003Uint16 timer0TCR;"},{"entry":"\u2003\/\/ Set timer loading (TLB) bit prior to initializing the period"},{"entry":"\u2003\/\/ and prescale registers."},{"entry":"\u2003timer0TCR = TIMER_RGETH(timer0Handle, TCR);"},{"entry":"\u2003timer0TCR |= TIMER_FMK(TCR, TLB, 1); \/\/ TLB = 1;"},{"entry":"\u2003TIMER_RSETH(timer0Handle, TCR, timer0TCR);"},{"entry":"\u2003\/\/ Reprogram the period and prescale register such that the"},{"entry":"\u2003\/\/ interrupt period is 10 microseconds. The actual number of"},{"entry":"\u2003\/\/ CPU cycles is determined based on the current CPU frequency."},{"entry":"\u2003PSL_querySetpointFrequencies(1, clks, currentSetpoints, &currFreq);"},{"entry":"\u2003cycles = (unsigned long)(10.0f * currFreq);"},{"entry":"\u2003\/\/ Write PRD register"},{"entry":"\u2003TIMER_FSETH(timer0Handle, PRD, PRD, cycles & 0xFFFF);"},{"entry":"\u2003\/\/ Write TDDR field of PRSC register"},{"entry":"\u2003TIMER_FSETH(timer0Handle, PRSC, TDDR, (cycles >> 16) & 0xF);"},{"entry":"\u2003\/\/ Restart the timer"},{"entry":"\u2003TIMER_start(timer0Handle);"},{"entry":"}"},{"entry":"#include \u201cPSL.h\u201d"},{"entry":"extern void func1( );"},{"entry":"extern void func2( );"},{"entry":"extern void func3( );"},{"entry":"void main (void)"},{"entry":"{"},{"entry":"\u2003PSL_Status status;"},{"entry":"\u2003\/\/ Variable specifying PSL_ClkID that will be used in all PSL calls."},{"entry":"\u2003PSL_ClkID clk = PSL_CPU_CLK;"},{"entry":"\u2003\/\/ Index into PSL_cpuFreqTable[] that specifies"},{"entry":"\u2003initial freq of 200 MHz."},{"entry":"\u2003unsigned initFreqIndex = 15;"},{"entry":"\u2003\/\/ PSL_cpuFreqTable[5] represents 72 MHz"},{"entry":"\u2003\/\/ PSL_cpuFreqTable[15] represent 200 MHz"},{"entry":"\u2003PSL_Setpoint_72 MHzSetpoint = 5;"},{"entry":"\u2003PSL_Setpoint_200 MHzSetpoint = 15;"},{"entry":"\u2003\/\/ Initialize the PSL. The frequency following reset is"},{"entry":"\u2003\/\/ specified by PSL_cpuFreqTable[15]. The voltage"},{"entry":"\u2003following reset is 1.6 v."},{"entry":"\u2003status = PSL_initialize(1, &clk, &initFreqIndex, 1.6f);"},{"entry":"\u2003if (status != PSL_OK)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/ handle error;"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003return;"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ Execute func1 at 200 MHz (i.e., the initial frequency)"},{"entry":"\u2003func1( );"},{"entry":"\u2003\/\/Change frequency to 72 MHz. Stop\/Restart the Timer before\/after the"},{"entry":"\u2003\/\/ scaling operation."},{"entry":"\u2003status = PSL_changeSetpoints(1,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&clk,"]},{"entry":[{},"&_72MHzSetpoint,"]},{"entry":[{},"TRUE, \/\/ change voltage also"]},{"entry":[{},"FALSE,"]},{"entry":[{},"StopTimer0, \/\/ Stop timer"]},{"entry":[{},"before scaling operation"]},{"entry":[{},"RestartTimer0); \/\/ Reprogram"]},{"entry":[{},"and start timer"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\/\/ after scaling"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003if (status != PSL_OK) {"},{"entry":"\u2003\u2003\/\/ handle error"},{"entry":"\u2003\u2003.."},{"entry":"\u2003\u2003return;"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ Execute func2 at 72 MHz"},{"entry":"\u2003func2( );"},{"entry":"\u2003\/\/ Change frequency to 200 MHz. Stop\/Restart the"},{"entry":"\u2003Timer before\/after the"},{"entry":"\u2003\/\/ scaling operation."},{"entry":"\u2003status = PSL_changeSetpoints(1,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&clk,"]},{"entry":[{},"&_200MHzSetpoint,"]},{"entry":[{},"TRUE, \/\/ change voltage also"]},{"entry":[{},"FALSE,"]},{"entry":[{},"StopTimer0, \/\/ Stop timer before"]},{"entry":[{},"scaling operation"]},{"entry":[{},"RestartTimer0); \/\/ Reprogram and"]},{"entry":[{},"start timer"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\/\/ after scaling"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003if (status != PSL_OK) {"},{"entry":"\u2003\u2003\/\/ handle error"},{"entry":"\u2003\u2003.."},{"entry":"\u2003\u2003return;"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ Execute func3 at 200 MHz;"},{"entry":"\u2003func3( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The prologue and epilogue functions are passed to the scaling library as the last two parameters of PSL_changeSetpoints. In the example of Table 51, StopTimer, the prologue function, is called immediately before the scaling operation is initiated. RestartTimer, the epilogue function, is called immediately after the scaling has completed. The prologue function is passed the current and new setpoints, and the epilogue function is passed the old and current setpoints. Since the StopTimer function simply stops the timer, it does not use these parameters. However, the RestartTimer function determines the frequency of the current setpoint so that the period register of the timer can be reprogrammed correctly.","The example of Table 51 handles only one peripheral. Multiple peripherals can be handled by supplying a wrapper function that calls other routines to adjust the peripherals as necessary. For example, an epilogue function that restarts Timer and reprograms the EMIF might resemble the code in Table 52.",{"@attributes":{"id":"p-0126","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 52"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"void EpilogueFunc (unsigned count,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PSL_ClkID","*clks,"]},{"entry":[{},"PSL_Setpoint","*oldSetpoints,"]},{"entry":[{},"PSL_Setpoint","*currentSetpoints) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ Determine frequency of current setpoint"},{"entry":"\u2003\u2003float freq;"},{"entry":"\u2003\u2003PSL_getSetPointFrequencies(1, clks, currSetpoints, &freq);"},{"entry":"\u2003\u2003\/\/ Reprogram and restart Timer1 based on the current frequency"},{"entry":"\u2003\u2003RestartTimer0(freq);"},{"entry":"\u2003\u2003\/\/ Reprogram EMIF based on current frequency"},{"entry":"\u2003\u2003ReprogramEMIF(freq);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the examples of Table 48 and Table 51, the desired frequencies are statically known. In both instances, the application switches between 200 MHz and 72 MHz. Since the frequencies are known up front, the setpoints may be directly assigned values that corresponded to indices into the frequency table PSL_cpuFreqTable[ ]. However, there may be cases where the frequency is to be dynamically determined. Consider an application that dynamically determines the lowest possible frequency based on information relating to the system's timing requirements and the timing information of each task or operation. In this case, after calculating the lowest possible frequency, the application must determine the setpoint that corresponds to the closest frequency that is greater than or equal to the calculated frequency. For example, assuming the configuration data of Table 47, if the calculated frequency is 70 MHz, the setpoint that corresponds to 72 MHz must be used since there is no setpoint that corresponds to 70 MHz. In the example of Table 53, the function FindSetpoint illustrates how to find the correct setpoint by using the query routines of the scaling library API. The function ChangeToLowestFreq further illustrates how query functions can be used.",{"@attributes":{"id":"p-0128","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 53"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"},{"entry":"\/\/ Function to find a setpoint that corresponds to the closest frequency"},{"entry":"\/\/ that is greater than or equal to the specified frequency."},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"},{"entry":"PSL_Setpoint FindSetpoint (float desiredFreq)"},{"entry":"{"},{"entry":"\u2003unsigned i, numSetpoints;"},{"entry":"\u2003float freq,"},{"entry":"\u2003float closetFreq = PSL_cpuMaxFreq;"},{"entry":"\u2003PSL_Setpoint closestSetPoint;"},{"entry":"\u2003\/\/ Determine number of setpoints"},{"entry":"\u2003PSL_getNumSetpoints(1, &clk, &numSetpoints);"},{"entry":"\u2003for (i = 0; i < numSetpoints; i++) {"},{"entry":"\u2003\u2003\/\/ Determine frequency of setpoint i"},{"entry":"\u2003\u2003PSL_querySetpointFrequencies(1, &clk, &i, &freq);"},{"entry":"\u2003\u2003if((freq >= disiredFreq) && (freq < closestFreq ) {"},{"entry":"\u2003\u2003\u2003closestSetPoint = i;"},{"entry":"\u2003\u2003\u2003closestFreq = freq;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003return closestSetPoint;"},{"entry":"}"},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"},{"entry":"\/\/ Function that changes setpoint to lowest frequency that"},{"entry":"\/\/ still meets real-time requirements."},{"entry":"\/\/\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014"},{"entry":"void ChangeToLowestFreq ( ) {"},{"entry":"\u2003float currFreq, desiredFreq;"},{"entry":"\u2003unsigned freqScalingLatency, voltScalingLatency;"},{"entry":"\u2003PSL_Setpoint currSetpoint, desiredSetpoint,"},{"entry":"\u2003\/\/ Determine lowest frequency that meets timing requirements"},{"entry":"\u2003desiredFreq = CalcLowFreq( );"},{"entry":"\u2003\/\/ Find nearest setpoint whose freqeuncy is greater than or"},{"entry":"\u2003\/\/ equal to the desired frequey"},{"entry":"\u2003desiredSetpoint = FindSetpoint(desiredFreq);"},{"entry":"\u2003\/\/ Is the desired setpoint equal to the current setpoint?"},{"entry":"\u2003PSL_getSetpoints(1, &clk, &currSetpoint);"},{"entry":"\u2003if ( currSetpoint == desiredSetpoint) {"},{"entry":"\u2003\u2003\/\/ nothing to change"},{"entry":"\u2003\u2003return;"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ Determine the latencies involved when scaling from the current"},{"entry":"\u2003\/\/ setpoint to the new setpoint"},{"entry":"\u2003PSL_querySetpointTransitions(1,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&clk,"]},{"entry":[{},"&currSetpoint,"]},{"entry":[{},"&desiredSetpoint,"]},{"entry":[{},"&freqScalingLatency,"]},{"entry":[{},"&voltScalingLatency);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\/\/ Determine if real-time requirements are still met"},{"entry":"\u2003\/\/ when latencies are considered"},{"entry":"\u2003if(!CanScale(freqScalingLatency + voltScalingLatency) ) {"},{"entry":"\u2003\u2003return;"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ Change setpoint"},{"entry":"\u2003status = PSL_changeSetpoints(1,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&clk,"]},{"entry":[{},"&desiredSetpoint,"]},{"entry":[{},"TRUE, \/\/ change voltage also"]},{"entry":[{},"FALSE,"]},{"entry":[{},"NULL, NULL);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003if (status != PSL_OK) {"},{"entry":"\u2003\u2003\/\/ handle error"},{"entry":"\u2003\u2003.."},{"entry":"\u2003\u2003return;"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"While the invention has been described with reference to illustrative embodiments, this description should not be construed in a limiting sense. Various other embodiments of the invention will be apparent to persons skilled in the art upon reference to this description. For example, other power events may be included in embodiments. Such power events could include notification of power supply changes such as AC\/DC transition when the source of the system power is changed, battery power is below a given threshold or is critically low, or power failure, notification of operating system power state changes when there are transitions in the OS power state and responsiveness, or application-defined power events, e.g., an application signaling that a particular subsystem is powered up or down. This later type of power event would require that a power management system permit an application developer to configure, register, process, and optionally unregister application specific power events. Also, in the method for developing a power management strategy, additional data regarding system activities that influence power consumption may be provided to contribute to the analysis and tuning. For example, using internal memory rather than external memory can save power. Similarly, fetching instructions or data from a cache is more power efficient than using external memory. Data regarding the number of external memory accesses and the number of cache hits\/misses during execution may be provided, at the level of granularity of the power measurements (task, function, or single range of execution). This data could then be used to derive changes to the application to further reduce power consumption. It is therefore contemplated that the appended claims will cover any such modifications of the embodiments as fall within the true scope and spirit of the invention."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Particular embodiments in accordance with the invention will now be described, by way of example only, and with reference to the accompanying drawings:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 3A\u20133D"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5","FIG. 4"]}]},"DETDESC":[{},{}]}
