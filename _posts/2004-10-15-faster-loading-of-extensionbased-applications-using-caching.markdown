---
title: Faster loading of extension-based applications using caching
abstract: Disclosed herein are methods for efficient loading of extensions or “plug ins” into a host software program. In a preferred embodiment, extensions registered with the host software program are loaded when the host program is first initialized. During their loading, changes that the various extensions make to the host program are recorded in a cache file, including graphical changes to the user interface and non-graphical changes. Later, when the host program is again initialized, the cache file is read in lieu of loading the extensions, with the affect that it appears to the user that the extensions' functionality are fully present in the host application, although in reality the extensions are not yet loaded. Instead, the extensions are loaded when and if they are called, either by the user or automatically by the computer. This saves time upon host program initialization as the extensions, once cached, need not be loaded until they are called.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735076&OS=07735076&RS=07735076
owner: Adobe Systems Incorporated
number: 07735076
owner_city: San Jose
owner_country: US
publication_date: 20041015
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates in general to computer software, and specifically to methods for efficient loading of extensions or \u201cplug ins\u201d into a host software program.","Application programs such as Adobe Acrobat\u2122, Adobe Photoshop\u2122, Microsoft Internet Explorer\u2122, Microsoft Word\u2122, etc., can be supplemented by third party software producers through the inclusion of application \u201cextensions.\u201d Such application extensions \u201cextend\u201d the functionality of the host program by adding third party software functionality to the host program, or optionally may override certain functionality in the host program. Sometimes, such extensions are referred to in the art as \u201cplug ins.\u201d","For example, as shown in , a screen shot of the graphical user interface  of Microsoft Word is shown. In this example, Microsoft Word, the hosting program, has been extended to include functionality from a third party software product called \u201cGarret.\u201d Accordingly, certain functional aspects of the Garret program have been made available within Word as the hosting program, which can occur in any number of ways. For example, the Garret application extension can cause a \u201cGarret\u201d drop-down menu  to be displayed as a modification to Word's standard menu bar . Although not shown, this drop-down menu  would allow the user to access the loaded functionality from the Garret extension (or extensions). Alternatively, menu options specific to the loaded Garret extension may appear as selections within the standard menu options already present on the standard menu bar  without the need for a separate Garret drop-down menu , although this is not shown.","Additionally, the loaded extension may cause a \u201cGarret\u201d tool bar  to appear in the user interface , providing buttons or drop-down windows to again allow the user to access the loaded functionality provided by the extension(s). Such extension buttons may be separate from or integrated with the standard tool bar  otherwise provided by Word as the hosting program. Of course, these manners of modifying the user interface of the hosting program by the extensions are merely exemplary. Alternatively, some of the aspects of the loaded extensions may not be visible to the user and\/or may not cause modification of the graphical user interface .","For extensions to operate in this fashion, the hosting program must include an Application Programming Interface (API) to allow the extensions to register with the host program. After being registered, the registered extensions are loaded when the host program is initialized, e.g., when the user runs the host program or when the host program is otherwise made to run automatically. In short, when the host program is initialized, the extensions too are loaded and initialized. But the additional computer resources required to load the registered extensions can make initializing the host program slow. For example, in the example shown in , when Word is initialized, the registered extensions may require queries to certain files or code fragments within the Garret program, and these files or code fragments may be scattered elsewhere on the computer's hard drive, i.e., wherever the Garret program is ultimately stored. Of course, the additional time taken to initialize the Word program is further lengthened if there are several registered extensions for a given program (such as \u201cGarret\u201d), and\/or if extensions from many different third party software programs are used. At some point, this additional time becomes unsatisfactory to the user, who generally will not wish to wait more than a few seconds for the host program to initialize.","Further compounding this problem is the fact that all registered extensions are typically loaded regardless of whether they will be used. For example, suppose a Garret extension  (in this case, a button) provides certain additional functionality to the Word program, e.g., by providing an additional spell checking feature. It may be the case that the user never wishes to access this additional spell checking feature (perhaps because the user is comfortable using the spell checking feature already provided by Word), or that the user will use this feature only occasionally (e.g., one time out of every twenty times the user runs the Word program). In such cases, using processing resources (and time) to load the Garret extension for the spell checking feature is generally wasteful. Again, the overall problem is compounded when one realizes that a particular hosting program might potentially have hundreds of extensions that are registered to it, of which some will never (or only occasionally) be selected by the user or automatically by the host program.","One solution to this problem is to simply not allow the extensions to load, or to load them at a time when the functionality that the extension provides is selected or called. For example, in Microsoft's Internet Explorer (IE) program, and as shown in , a registry directory  is provided by which extensions can register themselves with IE as the host program. Specifically, the extensions ,  are preferably (from IE's point of view) accompanied by registry keys ,  in the registry directory . The registry keys ,  can constitute pointers to where the extensions, and certain specific information concerning the extensions, are stored. Thus, when IE initializes, it reviews the registry keys , , and gathers (for example) bit maps from the extensions relating to changes in the graphical user interface that the extensions would have IE make. For example, if extension  would have IE place a button (such as ) on a tool bar, the bit map for that button would be fetched as specified by the key . Thus, when IE initializes, it in theory is able to merely consult the keys , , gather the appropriate minimal information from the extensions, and make necessary changes to the user interface so that it appears to the user that the extensions ,  have been fully loaded. However, the extension is not in fact loaded at this time, but instead is fully loaded when and if the functionality pertaining to that extension is called (such as by selecting button ). Accordingly, this scheme potentially allows the extensions to be loaded only when and if they are engaged, saving time during the initialization of the host program.","But there are drawbacks to this approach. First, as just mentioned, the host program (i.e., IE) would potentially need to load or read a number of pieces of data (e.g., the bit maps) from the extensions programs upon initialization as specified by the keys , . As these pieces of data would reside with the extension programs, they would be randomly scattered throughout the computer's hard drive, thus requiring at least some processing and time to retrieve them upon the host program's initialization. Second, by virtue of this approach, the host program shifts responsibility to the extension programmers to write their extensions ,  (or at least their keys , ) in a manner specified by the host program to allow for efficient processing of the type set forth above. This requires the extension programmers to have knowledge of the host program's desired formats for registration, which they may not have even if such optional formatting schemes are made public as part of the API. Moreover, extension program writers may lack incentive to code their extensions in this way, which results in yet a third drawback: despite IE's permitted acceptance of register keys ,  to help facilitate loading of the extension, the fact remains that IE does not require the use of register keys, i.e., does not require the registering extension to partake of time-saving extension-loading key-based scheme discussed above. Thus, as illustrated by extension  in , an extension can fail to provide a key to IE's registry domain , and instead can merely provide the extension to the registry domain, thereby causing the extension to fully load when the host program is initialized. Should all extensions decide not to use the host program's registration format, all benefits of the scheme are lost. Fourth, once a registry key format has been set by the host program to allow for efficient extension loading, that format must thereafter continue to be supported by the host program, or extension programs relying on that format will not be recognized. Fifth, this scheme provides a solution for only the simplest user interface additions. It does not address non-user interface additions, deletions, or modifications, nor user interface modifications or additions. Thus many extensions may not use such a scheme.","Accordingly, the software art would be benefited by a better solution to the problem of efficient initialization of a host program to which extensions have been registered.","Disclosed herein are methods for efficient loading of extensions or \u201cplug ins\u201d into a host software program. In a preferred embodiment, extensions registered with the host software program are loaded when the host program is first initialized. During their loading, changes that the various extensions make to the host program are recorded in a cache file, including changes to the graphical user interface and non-graphical changes. Later, when the host program is again initialized, the cache file is read in lieu of loading the extensions, with the effect that it appears to the user that the extensions' functionality are fully present in the host application, although in reality the extensions are not yet loaded. Instead, the extensions are loaded when and if they are called, either by the user or automatically by the host program. This saves time upon host program initialization as the extensions, once cached, need not be loaded until they are called. Use of the disclosed technique does not require the extensions to be coded or registered in any particular format.","The disclosed cache file preferably comprises earlier recorded data, which the host program reads upon subsequent initializations of the host program. The data preferably comprises all that is necessary to make the host program appear to the user as if all extensions have been fully loaded, and provides sufficient information to generate \u201cproxy code\u201d for each extension which can be run when and if the cached extension is called for loading. Thus, for extensions that modify graphics, the data in the cache file preferably contains a bit map of the required information as well as the information needed to find and load the associated extension. For non-graphical changes, the cache file data may comprise a pointer to the extension code or to that extension's registration in the registry directory, i.e., what is necessary to find and load the extensions.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 3","FIG. 2"],"b":["50","36","38"]},"Next, the host program initializes (i.e., is run) (), and the extensions are allowed, at least initially, to fully load (). As one skilled in the art will recognize, such loading of extensions generally occurs rather early in the initialization of the host program, for example, before the display of graphics on the user interface. This is logical, as it allows the extensions to load and perhaps modify the graphics of host program before they are displayed in substantial detail to the user. Moreover, as one skilled in the art will appreciate, the loading of the extensions occurs during a set period in the host application's launch sequence.","During loading of the extensions during this period (), the loading process is monitored by the host application, and those aspects working a change to the host program (whether graphical or not) are recorded and stored in a cache file . While this cache file  will be explained in more detail later, the cache file  essentially represents the changes that the extensions work to the host program. For example, if a particular extension will add a button (such as , ) to the user interface of the host program, the cache file  will record the textual\/graphical\/location information for that button being displayed. In another example not constituting a graphic-based change, if a particular extension will add a new or different random number generator to the host program, the location of the new random number generator extension (i.e., where it is located on the user's hard disk) is cached, as is explained further below. Thus, during the recording and cache generation process (), the extensions themselves are not cached; rather only the changes the extensions render to the user interface and\/or any other information relevant to how the host program will be changed are cached.","When the host program is subsequently initialized again (), the cache file  is first checked to see if any new extensions not previously cached have been registered with the host program, or whether any extensions previously cached have been deregistered with the host program. (More on this later). Assuming no newly added or deleted extensions, the extensions this time are not loaded, and instead the cache file  is read, \u201cproxy code\u201d  is constructed (explained further below), and the host program is modified accordingly (). As the cache file  contains all information relevant to changes in the host program (whether graphical or non-graphical) as previously recorded, the host program presents to the user what appears to be the host program as modified by the extensions, even though the extensions are not fully loaded nor ready for execution at this stage. Thus for example, the user would see the cached toolbar button (, ) displayed, and non-graphical changes would have the necessary pointers in place (although not apparent to the user).","Thereafter, should the functionality of a particular extension be called by the user (e.g., by selecting button ), or automatically by the host program itself, that extension is then loaded using the proxy code for the extension, which in turn executes the extension's functionality (). The proxy code may be able to completely remove itself so that subsequent invocations of functionality directly call the now-loaded extension, as explained below.","While the user must therefore wait for the registered extensions to fully load the first time the host program is initialized, thereafter only the cache file  needs to be read to make the application appear fully functional. Because the cache file  is preferably a single file (although perhaps a file in subparts as explained later) and located at a single region on the user's hard drive, it will load relatively quickly, and substantially more quickly than the loading of each extension. Then, when and if a particular extension is called, it can be fully loaded, thereby pushing the wait for such a load from the host program's initialization to the more reasonable time when the extension is first used. Moreover, and as noted earlier, the extensions require no special coding or formatting to render them compatible with this caching scheme.","With the above serving as an overview of the disclosed technique, further implementation details for the disclosed method are discussed, starting with , which illustrates a representation of an exemplary cache file . While the cache file  is preferably formatted as a single file, it can also be considered for illustrative purposes as a table having rows for each extension, and columns (A-C) comprising data pertinent to that extension.","Central to the cache file  is the recorded data (column C) for each extension. As noted earlier, the data in the cache file will vary depending on the type of extension at issue, and preferably varies if the extension works a graphical change or a non-graphical change to the user interface for the application. For a graphical change, the data would contain in significant part the graphical data for the change to be made to the user interface, which may constitute the text for the button, a bit map for the button, and its location on the graphical user interface or on some other structure such as a toolbar (see, e.g., Extensions #, ). Of course, these cached attributes are merely exemplary, and other information can be cached depending on the circumstances. For example, the extension might desire a button to be displayed only when a document is opened in the host program or only when text is selected; such information is also stored in the cache file  so that the button looks and behaves correctly even when the extension hasn't been loaded. In other embodiments, a pointer to the graphical data (i.e., in the original extension program) can be included with or used in lieu of the captured graphical data in column C, but this is less preferred as this would involve an intermediate step for displaying the graphical data and hence slow loading of the cache file. For a non-graphical change, the data in the cache file would preferably constitute a pointer to where the code for the extension can be found (e.g., Extension #, , and ), as is explained further below. In any event, the cache file  provides the host program what it needs to make it appear as if all extensions have been fully loaded. Additionally, the cache file  data's is preferably also sufficient to generate \u201cproxy code\u201d  for each extension, as will be explained in more detail later.","Also shown in  is the association between the data in the cache file  and the extension to which it relates (column A), as it is registered in the registry. This entry essentially constitutes a pointer to the extension. Thus, entry \u201c1\u201d for Extension # points to the first extension in the registry directory. For ease of illustration, the extensions are numbered in the order in which they would normally be expected to load, although this is not strictly required (e.g., Extension # might actually load as the third extension, i.e., Extension # would be listed in the third row of the cache file ). Because this registry entry in turn points to the actual extension (i.e., where it exists on the hard drive), the entry \u201c1\u201d in effect constitutes a cached pointer and ultimately points to where the extension resides through the registry directory as an intermediary. For non-graphical user interface changes (such as the random number generator example discussed above), such caching of the pointer may be all the \u201cdata\u201d that is required. Of course, in alternative embodiments, a specific pointer directly to the extension on the hard disk (as opposed to the registry directory) could also be cached as data in Column C, which might serve to eliminate the need to point to the registry directory as an intermediary step. However, directly caching the pointer as data is less preferred because the registry information for the extension already contains a pointer to the extension, and hence caching that as data would be somewhat redundant. Although the data in column C may be blank (N\/A) for such non-graphical user interface changes, for simplicity, data (i.e., the pointer) is still said to be cached by virtue of the extension number in column A. In any event, the association between the cached data and the extension as reflected in column A is important in preferred aspects of the disclosed technique, because eventually the extension only pseudo-loaded via the cache file  may need to be loaded in earnest when and if the extension is called.","Column B, reflecting the basic operation of a given extension, reflects the routine in the host program that is to be changed, modified, or added, which again can be recorded upon the first initialization of the host program. Knowing this is also important in practice of the disclosed technique, for example, to ensure that the extensions will not conflict, as described in further detail below. Of course, the data formats of the cache file  in  are merely exemplary and are described in functional terms to aid in their understanding. As one skilled in the art will understand, the actual coding and data structures in the cache file  could be represented in any number of ways.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["11","32","5"]},"Different extensions may seek to modify the same routines within the host program. Thus, extensions #, , and  for example all provide a new random number generator routine to the host program. Ways in which the disclosed technique addresses these special considerations is addressed later.","Once the cache file  has been generated, it is queried and loaded in lieu of loading of the extensions when the host program is subsequently initialized as noted earlier, thus allowing the host program to initialize more quickly (, ). The cache file  still remains important however even after loading because in preferred embodiment it can continue to operate as \u201cmap\u201d or \u201ckey\u201d for associating the entries in the cache file to their extensions and to the routines in the host program that the extensions seek to modify.","When a particular extension is called for loading (e.g., when a pseudo-loaded button is selected), \u201cproxy code\u201d  is preferably used as a means for loading the extension, and in a sense such code operates as an intermediary between the extensions as they are pseudo-loaded (using the cache file) and the actual extensions themselves. Such proxy code  for each extension is constructed using the data in the cache file , including the various associations between the actual extension itself (column A) and the affected host program routine (column B). The proxy code is preferably generated when the cache file  is read.","A functional description  of the proxy code  for a given extension, and how such code handles an eventual call for loading of the extension, is shown in the flow chart of . (Again, the proxy code  is preferably generated during loading of the cache file). As a first step, after a called extension (e.g., extension #X) is called for loading (), it is determined whether that extension had been previously loaded (). If so, there is no need to re-load the extension, and instead the code provided by extension #X is merely executed ().","However, if this is the first time Extension #X is being loaded during a session of the host program, all modifications which the cache file  performed subsequent to Extension #X are undone in reverse order () (i.e., \u201crolled back\u201d). Then, the modifications the cache file performed for Extension #X are removed (), and then Extension #X is fully loaded (). Then, the cache file is again read, and extensions subsequent to Extension #X are redone (i.e. \u201crolled forward\u201d) to once again pseudo-load them (). Thereafter, the newly loaded Extension #X's code can be executed (). While the specific coding for the proxy code  can and will vary between platforms and operating systems, one skilled in the art will appreciate that all of the information needed to generate the proxy code is determinable from the cache file  itself, as the cache file contains the ordering of the extensions (as reflected by their rows) and the necessary associations with the actual extensions themselves and the routines in the host program that the extensions affect.","Steps  and  can be thought of as a roll-back\/roll-forward procedure, and is designed to preserve the ordering that the extensions would exhibit were they allowed to load as normal. Essentially, these steps seek to keep the extensions from conflicting with one another. For example, as noted in , three extensions seek to modify the host program's random number generator routine (Extension #, , and ). Suppose Extension # is called for loading, perhaps because the export service feature has been called. Absent any further consideration, such loading of Extension # would potentially \u201ctrump\u201d (i.e., overwrite) the random number generator routine for Extension #, which otherwise would have taken precedence over Extension # had the extensions been allowed to load in their normal order.","Accordingly, the roll-back\/roll-forward procedure, in a simple embodiment, would start with the last extension (say Extension #), and undo the cache file modifications. Thus, if Extension # had for example caused a button to be displayed, that button would be removed. This un-doing procedure is then rolled back to the second-to-last extension (#), then #, #, etc. () until the selected extension (#) itself is undone (). Extension # is then loaded as it was called (), and its proxy code is updated or removed (more on this later). Then, the cache file  is re-read and rolled forward () to re-execute the extensions from that point forward. Thus, the cache file  for Extension # is again performed, then Extension #, and so on until the cache file is read through to its end (#). Using this technique, it is assured that loading of a particular extension will not affect other extensions that have been loaded, and that the extensions will react predictably and in order as desired.","However, it may not be strictly necessary to undo\/redo certain extensions and\/or all aspects of those extensions. For example, the cache file, through its association to the routines in the host program to be effected (, column B) can identify potential conflicts to further streamline the roll-back\/roll-forward procedure. For example, assume again that Extension # called for loading. Prior to the roll back (), the host program can assess the routines that are affected in the host computer (column B), which reveals that only Extension # also seeks to affect the random number generator routine of the host program. In this case, only Extension # need be rolled back (), followed by a roll back of Extension # (), then Extension # can be fully loaded (), and Extension # rolled forward (). In a still further improvement, potentially affected extensions need not rolled back and forward in their entirety. For example, Extension # also affects the spell checker, but this has no relationship to Extension #. Thus, only the random number generator function of Extension # need be rolled back (), then Extension # is rolled back and loaded (, ), and then the random number generator portion of Extension # is rolled forward ().","It is generally preferred that such undoing and redoing of the cache file  be generally transparent to the user. Accordingly, it is preferred to \u201cfreeze\u201d the graphical user interface while the roll-back\/roll-forward is accomplished, so that the user will not see (for example) buttons popping off and on the graphical user interface. One skilled in the art well knows how to freeze the screen in a typical computer, which will vary between operating systems.","Through the use of the preferred embodiment of the proxy code , as shown in , roll back () and roll forward () may not be required for all extensions that are called for loading. For example, suppose the host program is initialized, and the user selects the newly-added button on the toolbar for the equation editor as provided by Extension #. Because no other extension bears any relation to the functionality of this extension (as noted via a review of column B), roll back () and roll forward () can be skipped in its entirety when that extension is loaded.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","b":["200","300","305","305","400","350","305","300","405","350","310","315","320","305","150","360","300","410","300","415","360","300","420","360","305","425"]},"An issue to contend with using the disclosed technique is the scenario in which a particular extension is loaded, but later another extension affecting that loaded extension's functionality is selected for loading. For example, and referring again to , suppose Extension # has been loaded by virtue of an earlier selection of the random number generator functionality that extension provides. As a result, the proxy code for extension # may have been removed (see, e.g., , ). Assume later that Extension # is called for loading, which also modifies the host program's random number generator routine. During roll back, an absent other considerations, the proxy code for Extension # would be undone, as would the proxy code for Extension #, then Extension # is loaded. However, in this case, it might not be possible or advisable to remove the proxy code for Extension #, because it would be preferable to keep the proxy code  in tact for roll-back\/roll-forward. Accordingly, in this case, the proxy code for Extension # would preferably not be removed upon loading the extension, but instead would change to become a call to the extension's code. This way the proxy code is still available for roll-back\/roll-forward. Then, during roll forward, the proxy code for Extension # can be restored, in essence hiding the existence of Extension # from Extension # to keep the host program from being confused.","Yet another issue to consider is the circumstance in which an extension is called for loading, which in turn requires another extension to be loaded. For example, suppose the user selects the equation button of Extension #, but Extension # requires the \u201csupport service\u201d of Extension # to provide the functionality. Thus, loading Extension # may also load Extension #. The recursive loading of Extension # during the load of Extension # behaves in a similar manner to non-recursive loading of Extension #. Such recursive loading of the extensions obviates the need to cache dependencies between the extensions.","When a session of the host program terminates (e.g., is exited), the cache file  is preferably stored without modification and reloaded the next time the host program is initialized. However, the cache table  could be modified in other embodiments. For example, by reviewing and tracking the history or frequency with which various extensions were loaded, the host application might infer that certain extensions are desirable to the user, and may modify the cache file  to automatically load those extensions upon subsequent initializations of the host program. Alternatively, the user might be provided an option to \u201cturn on\u201d such frequently desired extensions to ensure that they load upon each initialization of the host program. Either way, host initialization would be lengthened as those previously selected extensions are loaded, but this may be preferable to a user who might prefer such frequently-used extensions to not have to load during the middle of a given session.","Newly registered extensions and deleted unregistered extensions are easily addressed with the disclosed technique. When the host program is initialized, the computer first checks the contents of the registry directory and the cache file  (i.e., column A, ) to see which extensions are present in both. If a new extension is determined to be present in the registry directory, it is determined in which order that extension would load without the use of the disclosed technique. (One skilled in the art will recognize that many different ways exist to allow the host program to order the loading of the extensions). After this, the cache file  is executed up to the point in the cache where the new extension would intervene. The new extension is then loaded and recorded as explained above, and such information is stored as a new \u201crow\u201d in the cache file . Thereafter, the cache file  continues its execution where it left off. It can be recognized that the first initialization of the host program involves a special case for the adding of new extensions, in the sense that all extensions will be recognized as new and cached accordingly. By contrast, should it be determined that an extension has deregistered itself from the host program (i.e., because it is no longer present in the registry directory), that \u201crow\u201d in the cache file  can be deleted and\/or skipped during its execution.","Certain extensions may logically need to be fully loaded instead of being cached. For example, an extension providing a stock ticker displaying stock prices would naturally need to be fully loaded and executed so it could start displaying accurate stock price data. In this and similar circumstances, the caching aspects disclosed herein could be subverted by allowing the extension to request the host program to load it each and every time the host program is initialized without caching. Such a request can come in the form of a key, command, or other specified format. However, while it may be useful to allow some extensions to exempt themselves from being cached, most extensions would not need such treatment, or would find caching non-problematic.","In other useful embodiments, the cache file\/proxy code need not be generated by the host program, and need not be recorded upon loading of the extensions. Instead, the cache file\/proxy code could be created independently by a program other than the host program, and by means other than recording. In short, in one embodiment, the technique merely envisions that the cache file with the necessary data and\/or the proxy code be provided to the host program in some manner.","It should be clear from this disclosure that \u201cchanges\u201d to the host program denotes not merely changes visible to the user (such as graphical user interface changes provided by a bit map), but also redirection of the host program (e.g., by using a pointer to either the registry directory or the extensions as they exist on the hard disk).","The cache file  need not in all useful embodiments be generated by or recorded by the host program. For example, the cache file could be manually generated even prior to the initialization of the host program, and independently of the host program. Such an alternatively-generated cache file would be particularly useful in embodiments in which it would not be desirable to read the cache file even upon the first initialization of the host program and without the need to first record loading of the extensions. The cache file need not be a single unitary file (although this is preferable), but could comprise files or other data structures related or linked to provide the desired functionality of the host program to pseudo-load all extensions registered to it. For example, several registries of extensions could be stored as several cache files and each cache file used in turn to pseudo-load each registry of extensions . The \u201ccache file\u201d or \u201cfile\u201d as used herein should be so understood, and should be understood as potentially comprising multiple files or data structures, even if referred to in the singular.","While it is contemplated that the extensions of interest are \u201cregistered\u201d with the host program, it should be understood that such registration does not require use of any formal mechanism, such as inclusion of the extensions in a registry directory as disclosed earlier. Thus, extensions can be \u201cregistered\u201d with the host program in any number of ways that otherwise associate the extensions with the host program.","The foregoing methods and other functional aspects are easily programmable, and such programming would be a routine matter to a computer programmer of skill using any of a variety of different programming languages in the context of many different operating systems. Of course, the methods would be ultimately coded and stored on a computer-readable media, such as a compact disk, a tape, stored in a volatile or non-volatile memory, etc. While disclosed in the context of a traditional computer, it should be understood that the disclosed methods are not so limited. For example, the disclosed methods can have applicability with respect to other devices such as handheld devices (Personal Data Assistants, cell phones, etc.) and other multimedia devices (such as televisions, etc.).","The cache file  need not necessarily reside at the same location as the host program. For example, the cache file  could reside on a server coupled to a user's or users' computer(s) running the host program, and made available to each user when they initialize the local version(s) of the host program. Additionally, portions of the cache file  could reside on different computers or servers, i.e., the cache file  need not be a contiguous data file. Of course, each user could have their own cache files  for a given host program, with certain portions potentially sharable with other users also having access to the host program at different computers. Thus, the cache file used by one user can be generated in whole or in part by another user.","It should be understood that the inventive concepts disclosed herein are capable of many modifications. To the extent such modifications fall within the scope of the appended claims and their equivalents, they are intended to be covered by this patent."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the inventive aspects of this disclosure will be best understood with reference to the following detailed description, when read in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
