---
title: Generating libraries for reflection without project compilation
abstract: A stripped-down version of a library is generated from server source code extracted from a server project under development. Information extracted from the server source code may include only that information which is exposed to a client project under development. The stripped-down library generated from the extracted server source code is received by a reflection-based component that uses reflection to generate documentation and disclosure information helpful in the development of the client source code. Because the server project does not have to be compiled or ready to be compiled before the software development information for the client project can be provided, development of the server side source code and the client side source code can proceed in tandem or incrementally.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08239823&OS=08239823&RS=08239823
owner: Microsoft Corporation
number: 08239823
owner_city: Redmond
owner_country: US
publication_date: 20090320
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Overview"],"p":["A programming or software development tool is a program or application used by software developers to create, debug, maintain, or otherwise support other programs and applications. Programming tools can be integrated into an IDE (integrated development environment) that consolidates functionality into one place or can be used by external software as exemplified by the use of Unix shell tools with text editors like Vim and Emacs. Programming tools can be interactive or can be static. Interactive programming tools provide information to a program developer as the developer is writing the program while static programming tools run offline and provide information to the developer after the fact. One popular type of interactive programming tool provides dynamic documentation and disambiguation information such as: a list of members for a class, a list of parameters for a function, a list of defined classes, a list of types for type declarations and so on. Dynamic documentation and disambiguation information is displayed in response to information received from the developer. An example of such a dynamic display is, in response to a developer typing in the name of a method, a list of valid parameters for the method is displayed.","Relevant source code can be extracted from server source code and converted into a library of program code that can be used by reflection-based development tools to provide dynamic documentation and disambiguation information without having to first successfully perform a build on the server source code. The library generated from the extracted server source code can be a metadata assembly or other assembly, a DLL (dynamic link library) a package or other software library entity. The generated library can be used by reflection-based programming tools without prior compilation of the source code from which the library is generated. The relevant source code extracted from the server-side source code can be metadata associated with types and type definitions referenced in the server-side source code. The extracted source code can be converted into a library. The library can be provided to a reflection-based code generator, which can generate documentation and disambiguation information to a client-side source code editor, the client-side source code editor providing the documentation and disambiguation information to the developer as the developer is writing the client-side source code. Hence, incremental development of the server-side and client-side software can proceed in the absence of a server project compile.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Many programming tools work by compiling source code to generate a binary program code file (sometimes in the form of Common Intermediate Language (CIL) or Java bytecode) and then reverse engineering the binary program code file to produce documentation and disambiguation information that is helpful when developing software. For example, in the realm of network communication, a programmer may want to expose an API (application programming interface) on a server over a network to a client. In this context, an API can be a set of methods or can be a set of classes where each class in the set of classes is associated with a set of methods, properties and fields. It may be helpful to have an automated way to create a proxy that can access the server API programmatically, while listing a corresponding proxy API for the developer to use on the client side.","Today one automated way in which source code to expose a server API or set of server APIs is generated is by compiling the server code, and performing reflection on the built output. During reflection, the API or set of APIs that are exposed to the client are found and proxy APIs are programmatically generated for the APIs exposed to the client. In some programming languages, source code including proxy classes that expose an API of interest to the client are generated from the information gleaned from reflection performed on the binary program code file. This approach relies on having the binary program code file available. This in turn depends on being able to successfully compile the server source code to produce the binary program code file. Compilation, especially when invoked while a developer is using an interactive programming tool such as a source code editor, can result in an unacceptable time delay. Moreover, the server software obviously has to be in a compile-able state to be compiled: that is, the server software has to be complete enough and free enough of errors to be successfully compiled.","Often, because client-side software and server-side software is developed in tandem or incrementally, (that is, development of the client-side software begins before development of the server-side software is complete so that perhaps the developer writes some server source code, then writes some client source code, then writes some more server source code and so on), the server-side software is not in a compile-able state when the client-side software is being developed because the server-side software is also in development. Finally, although the server-side source code may be able to be compiled successfully, it may be advisable not to compile the server-side source code because the server-side source code is changing, is expected to change or for other reasons such as but not limited to performance.","To address these and other aspects of programming tools, in accordance with aspects of the subject matter discussed herein, relevant information (such as but not restricted to metadata associated with program entities (e.g., functions, methods, types, classes, fields, properties, variables etc.) that will be exposed to a client by a server), can be extracted from source code in a server project. Information that is extracted from the source code can be found in various ways, depending on the problem domain, but in general, language constructs are evaluated to find the relevant information. A stripped-down version of a library such as but not limited to a metadata assembly can be generated from the extracted information without compiling the project from which the information is extracted. In accordance with some aspects of the subject matter the stripped down library can include metadata and can exclude portions of the executable part of a compilation product. For example, libraries can be executables with empty method bodies. Moreover, excluded information can include private code (i.e., extracted information is information that is public code). Information that is filtered out of the extracted information or that is excluded from the information that is extracted can include everything except the information that is exposed to a client by a server so that a stripped-down library that excludes information that will not be exposed to the client, can be sent to a code generator or other reflection-based component. Because only a subset of information in the server project is used to create the library, the server source code can be in a much less complete state when this process is performed. The subset of information extracted from the server source code is less likely to contain errors than is the entire server project.","Source code can be generated by the code generator or other reflection-based component from the extracted and\/or extracted and filtered information. Information associated with the code-generated source code or with the original server source code can be provided to the developer during development of the client project before the server project is complete or in a state in which it will successfully compile. For example, if the application being developed is a network application involving a server and a client, information concerning APIs exposed to the client can be extracted from the server source code as soon as an API that will be exposed to the client is added to the server source code.","A library such as but not limited to a metadata assembly can be generated therefrom, and API proxy source code can be generated by the code generator from the stripped down library. In accordance with some aspects of the subject matter disclosed herein, the API proxy source code can be based on types defined in the library generated from extracted server source code containing proxy classes that expose the API to the client. Information generated in this way can be displayed to the developer to assist the client-side software development process. For example, if a set of APIs that will be exposed to the client are extracted from the server source code, the code generator can generate the source code that represents the set of proxy APIs, enabling the set of APIs that will be exposed to the client to be displayed to the developer, while he or she is coding the client source code for the application, even if the server side project is not complete or contains errors that prevent successful compilation of the server side project.","Generating Libraries for Reflection without Project Compilation",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","i":"a ","b":["100","146","104","106","108","110","112","104","114","116","112","118","120","122","116","114","120","118","114","118","146"]},"Source code editor  may receive documentation and disambiguation information generated from the built server project  to assist the developer in his or her development tasks, as described above. The built server project  can comprise binary program code such as but not limited to assemblies comprising metadata and executables in CIL. The code generator  can receive or access the binary program code generated by the compiler  and generate from it information such as documentation and disambiguation information that when displayed to the developer helps the developer in his development tasks.","Today, when a software developer writes or adds to software that will run on a network, he or she typically creates both server source code and client source code in a source code editor such as source code editor . For example, suppose the developer is writing part of an application for online shopping. Suppose the developer is adding a new way to search for merchandise or a new way to search for a particular type of merchandise to the online shopping application. Code added to the server source code might include the mechanism for executing the new search and can indicate that the new search method is to be exposed to the client. Code added to the client source code might include a new textbox in which a string to be searched for is entered and that calls the new search method.","Today, in order to provide information such as auto-completion information, programmatically generated proxy source code and other documentation and disambiguation information useful to the software developer when writing the client source code, the server source code has to be complete enough to compile successfully because the code generator  uses the binary program code from the built server project  generated by the compiler  from the server source code  to create the information that is presented to the software developer during development of the client software. For example, before the development software can list the new search method as one of the methods exposed by the server to the client, the server source code for the new search method has to be complete enough and debugged enough to compile. Typically, however, a software developer would like to be able to develop the server source code and the client source code in tandem. (That is, the developer may want to write a little server source code and then write a little client source code, and then go back to writing a little more server source code and so on.) In order to receive dynamic documentation and disambiguation information in the client-side source code development, the server-side software has to have been compiled.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIG. 3","FIG. 4","FIG. 4"],"i":"b ","b":["101","101","101","102","101","140","101"]},"System  may include one or more processors (such as processor ), a memory , a source code editor , a server project , a compiler , a built server project , a code generator  or other reflection-based component and a client project . An application can include a number of projects, including both server projects and client projects. Server-side software can be generated from server project(s) by compilation and client-side software can be generated from the client project(s) by compilation. A project can include compilation settings, source code, other project artifacts and assembly references. The server project  can include server source code  and references . The client project  can include client source code  and references . References  can include pre-built binary references used or referenced by the server source code . References  can include pre-built binary references used or referenced by the client source code .","Source code such as server source code  and client source code  is generally entered via a source code editor such as source code editor . Source code editor  may dynamically receive documentation and disambiguation information generated from the built server project  to assist the developer in his or her development tasks, as described above. The built server project  can comprise binary program code such as but not limited to CIL that includes metadata and executables. The code generator  can receive or access the binary program code of the built server project  generated by the compiler  and generate from it code-generated source code  for the client project  and information that when displayed to the developer helps the developer in his development tasks. This information may include documentation and disambiguation information as described above.","A compiler  may compile source code written in Visual Basic, Visual J#, C++, C#, J#, Java Script, APL, COBOL, Pascal, Eiffel, Haskell, ML, Oberon, Perl, Python, Scheme, Smalltalk or another programming language. A compiler such as compiler  can receive source code input and can produce executable code output. In accordance with aspects of the subject matter disclosed herein, the executable code output can be one or more assemblies, where each assembly comprises an executable portion and a metadata portion. The metadata portion of the assembly can be used by the code generator  to provide information to the developer that is helpful while developing software.","In addition, system  can include one or more of: a metadata extractor  (also referred to as a metadata extracting module) and a library generator  (also referred to as a library generating module). Metadata extractor  can extract metadata  from server source code , and provide the metadata  extracted from the server source code  to library generator . Library generator  can generate one or more libraries (e.g., library ) from the extracted metadata  and provide the generated library  to the code generator . The library generated from the extracted server source code can be a metadata assembly or other assembly, a DLL (dynamic link library), a package or other software library entity. The generated library can be a stripped down version of the library that includes metadata and can exclude portions of the executable part of a compilation product. For example, a library can be an executable with one or more empty method bodies. Moreover, a library can exclude private code and include portions of public code.","In turn the code generator  can dynamically provide information that is useful in the development of the client software from the generated library  to the developer of the client software during software development in the absence of compilation of the server project. The code generator  can provide information that is useful in the development of the client software from the generated library  to the developer of the client software during software development in the absence of compilation of the server source code  from which the metadata  is extracted. Metadata extractor  and\/or library generator  can be loaded into memory  and may cause one or more processors such as processor  to provide library  generated from server source code  without compilation to code generator  to provide information useful to the developer when developing client source code .","Metadata extractor  can generate a simplified form of the server source code  by for example, stripping out private code and\/or by stripping out method bodies. Stripping out private code and\/or method bodies can increase performance (i.e., decrease the wait time of the software developer for documentation and disambiguation information to be displayed as he or she is writing the client source code in a client source code editor). That is, the time the developer would have to wait for information useful in client software development can decrease from:","the time it takes to compile the source code+the time it takes for the code generator to process the compiled binary program code","to:","the time it takes the metadata extractor to extract the metadata from the source code+the time it takes the library generator to generate the library from the extracted metadata+the time it takes for the code generator to process the library to provide the documentation and disambiguation information in the client source code editor.","The time it takes the metadata extractor to extract the metadata from the source code+the time it takes the library generator to generate the metadata containing library from the extracted metadata+the time it takes for the code generator to process the metadata containing library is likely to be much less than the time it takes to compile the source code+the time it takes for the code generator to process the compiled binary program code. Moreover, the need for compilation before code generation is eliminated so that the server source code can be in a non-compile-able state. By extracting metadata from server side source code, client proxy classes can be generated through reflection, thus providing code completion (such as but not limited to IntelliSense-type information) on server objects for client side source code development.","In accordance with aspects of the subject matter disclosed herein the server component of the application developed can expose data to a client component such as but not limited to a Silverlight client by defining one or more business objects that expose data entities. The business objects and entities defined in the server project can essentially immediately be available for the developer to write code against on the client. Accurate source reference information including IntelliSense or other code completion information can be provided essentially immediately for projects under development because compilation does not provide this information. In accordance with aspects of the subject matter disclosed herein, the mechanism by which the above is accomplished may use source code understanding techniques including custom parsers, CodeModel and other techniques to find the relevant source code (e.g., relevant types for proxy code generation).",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2","i":"a ","b":["200","202","204","206","208","206","210","212","214"]},"Because information from the binary program code produced by the compilation process is available to the code generator or other reflection-based component, when the developer is writing the client source code, documentation and disambiguation information is able to be displayed to the developer. For example, statement completion information and information concerning APIs that will be exposed to the client by the server software will be available to the developer as he or she is writing the client source code. However, in order for this information to be displayed to the developer as he or she is writing the client source code in a program editor, the server project or at least the portion of the source code from which the documentation and disambiguation information was derived, has to have been successfully compiled.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 1"],"i":["b ","b"],"b":["201","203","205","207","209","211","203"]},"Example of a Suitable Computing Environment","In order to provide context for various aspects of the subject matter disclosed herein,  and the following discussion are intended to provide a brief general description of a suitable computing environment  in which various embodiments may be implemented. While the subject matter disclosed herein is described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other computing devices, those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and\/or a combination of hardware and software. Generally, program modules include routines, programs, objects, physical artifacts, data structures, etc. that perform particular tasks or implement particular data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment  is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.","With reference to , a computing device for generating libraries for reflection without project compilation in the form of a computer  is described. Computer  may include a processing unit , a system memory , and a system bus . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The system memory  may include volatile memory  and nonvolatile memory . Nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM) or flash memory. Volatile memory  may include random access memory (RAM) which may act as external cache memory. The system bus  couples system physical artifacts including the system memory  to the processing unit . The system bus  can be any of several types including a memory bus, memory controller, peripheral bus, external bus, or local bus and may use any variety of available bus architectures.","Computer  typically includes a variety of computer readable media such as volatile and nonvolatile media, removable and non-removable media. Computer storage media may be implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer .","It will be appreciated that  describes software that can act as an intermediary between users and computer resources. This software may include an operating system  which can be stored on disk storage , and which can control and allocate resources of the computer system . Disk storage  may be a hard disk drive connected to the system bus  through a non-removable memory interface such as interface . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.","A user can enter commands or information into the computer  through an input device(s) . Input devices  include but are not limited to a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . An interface port(s)  may represent a serial port, parallel port, universal serial bus (USB) and the like. Output devices(s)  may use the same type of ports as do the input devices. Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers and printers that require particular adapters. Output adapters  include but are not limited to video and sound cards that provide a connection between the output device  and the system bus . Other devices and\/or systems or devices such as remote computer(s)  may provide both input and output capabilities.","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computer(s) . The remote computer  can be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . Remote computer(s)  can be logically connected via communication connection . Network interface  encompasses communication networks such as local area networks (LANs) and wide area networks (WANs) but may also include other networks. Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . Connection  may be internal to or external to computer  and include internal and external technologies such as modems (telephone, cable, DSL and wireless) and ISDN adapters, Ethernet cards and so on.","It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the subject matter disclosed herein man pertain to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4","b":["600","602","600","610","600","600","650","610","611","620","611","650","660"]},"A user can create and\/or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface  and a source code editor  in the IDE . Thereafter, the source code component  can be compiled via a source compiler , whereby an intermediate language representation of the program may be created, such as assembly . The assembly  may comprise the intermediate language component  and metadata . Application designs may be able to be validated before deployment.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus described herein, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects, e.g., through the use of a data processing API or the like, may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the subject matter disclosed herein has been described in connection with the figures, it is to be understood that modifications may be made to perform the same functions in different ways."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
