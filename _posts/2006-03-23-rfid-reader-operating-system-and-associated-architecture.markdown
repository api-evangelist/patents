---
title: RFID reader operating system and associated architecture
abstract: A framework structure for controlling an RFID device including a platform comprising an RFID radio. The structure comprises a layered framework including a first layer, with at least one functional module comprising a device driver, communicatively coupled with the platform; and a second layer, with at least one functional module comprising an API, communicatively coupled with the first layer and with an application for controlling the RFID device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07659819&OS=07659819&RS=07659819
owner: SkyeTek, Inc.
number: 07659819
owner_city: Westminster
owner_country: US
publication_date: 20060323
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","Solution to the Problem","DETAILED DESCRIPTION"],"p":["This application claims benefit of priority to U.S. Provisional Application No. 60\/673,692, filed Apr. 21, 2005, which is incorporated herein by reference. This application also claims benefit of priority to U.S. Provisional Application No. 60\/712,957, filed 31 Aug. 2005.","RFID stands for Radio-Frequency IDentification. An RFID transponder, or \u2018tag\u2019, serves a similar purpose as a bar code or a magnetic strip on the back of a credit card; it provides an identifier for a particular object, although, unlike a barcode or magnetic strip, some tags support being written to. An RFID system carries data in these tags, and retrieves data from the tags wirelessly. Data within a tag may provide identification for an item in manufacture, goods in transit, a location, the identity of a vehicle, an animal, or an individual. By including additional data, the ability is provided for supporting applications through item-specific information or instructions available on reading the tag.","A basic RFID system includes a reader or \u2018interrogator\u2019 and a transponder (RF tag) electronically programmed with unique identifying information. Both the transceiver and transponder have antennas, which respectively emit and receive radio signals to activate the tag, read data from the tag, and write data to it. An antenna is a feature that is present in both readers and tags, and is essential for the communication between the two. An RFID system requires, in addition to tags, a mechanism for reading or interrogating the tags and usually requires some means of communicating RFID data to a host device, e.g., a computer or information management system. Often the antenna is packaged with the transceiver and decoder to become a reader (an \u2018interrogator\u2019), which can be configured either as a handheld or a fixed-mount device. The reader emits radio waves in ranges of anywhere from one inch to 100 feet or more, depending upon its power output and the radio frequency used. When an RFID tag passes through the electromagnetic zone (its \u2018field\u2019) created by the reader, it detects the reader's activation signal. The reader decodes the data encoded in the tag's integrated circuit and the data is often passed to a device (e.g., a computer) for processing.","Two methods distinguish and categorize RFID systems, one based upon close proximity electromagnetic or inductive coupling, and one based upon propagating electromagnetic waves. Coupling is via \u2018antenna\u2019 structures forming an integral feature in both tags and readers. While the term \u2018antenna\u2019 is generally considered more appropriate for propagating systems it is also loosely applied to inductive systems.","Transponders\/Tags","The word transponder, derived from TRANSmitter\/resPONDER, reveals the function of a tag. A tag responds to a transmitted or communicated request for the data it carries, the communication between the reader and the tag being wireless across the space between the two. The essential components that form an RFID system are one or more tags and a reader or interrogator. The basic components of a transponder are, generally speaking, fabricated as low power integrated circuit suitable for interfacing to an external coil, or utilizing \u2018coil-on-chip\u2019 technology, for data transfer and power generation, where the coil acts as an antenna matched to the frequency supported.","The Reader\/Interrogator","Reader\/interrogators can differ quite considerably in complexity, depending upon the type of tags being supported and the functions to be fulfilled. However, their overall function is to provide a mechanism for communicating with the tags, providing power to passive tags, and facilitating data transfer. Functions performed by the reader may include signal conditioning, parity error checking and correction. Once the signal from a transponder has been correctly received and decoded, algorithms may be applied to decide whether the signal is a repeat transmission, and may then instruct the transponder to cease transmitting. This is known as a \u2018Command Response Protocol\u2019 and is used to circumvent the problem of reading multiple tags in a short space of time. Using interrogators in this way is sometimes referred to as \u2018Hands Down Polling\u2019. An alternative, more secure, but slower tag polling technique is called \u2018Hands Up Polling\u2019, which involves the interrogator looking for tags with specific identities, and interrogating them in turn. This technique requires contention management, and a variety of techniques have been developed to improve the process of batch reading, including anti-collision techniques.","Current RFID systems require that a tag be in the field of the reader (interrogator), and powered on, in order for a user to interact with it. Furthermore, current tags are limited to the capabilities inherent in the tag. In multiple tag type environments, an RFID system is typically forced to use the common subset of tag capabilities, and has limited ability to support new or enhanced tags.","Previous embedded software systems have had limitations including the utilization of static software architectures whose specific software implementations are integral with their application-specific program or functionality. These monolithic implementations are often found in microcontroller-based designs wherein the embedded software or firmware has system resources and performance that are limited by the hardware.","Problem to be Solved","Traditional RFID applications have been closed loop and proprietary. Preexisting RFID readers are controlled by dedicated, closed-architecture, monolithic, embedded software (firmware). In previous RFID readers, features and functionality in the readers are set at compile time, and the readers are typically application specific. These readers do not allow a user or programmer to modify or upgrade only those specific aspects of a reader's functionality (i.e., code sections or modules) which the user\/programmer would like to change. Rather, in order to modify segments of code in the reader with any reasonable degree of granularity, the entire reader firmware module must typically be re-programmed (e.g., \u2018re-flashed\u2019, in the typical case where the reader employs flash memory), or, in the case of multiple-processor readers, a relatively large part of the existing reader firmware must still be extensively re-programmed. Nor do preexisting RFID readers allow modularity or granularity with respect to the security level of specific modules (drivers\/applications, etc.), so that, for example, the code in pre-selected proprietary modules may be kept secure (i.e., remain undecipherable to an unauthorized user\/programmer), while the code in other specific modules may be readily re-programmed.","As markets such as contactless payment and supply chain management emerge, wide-scale adoption of RFID remains inhibited as the industry continues to deliver reader technology as monolithic hardwired devices with inaccessible RFID radio control software. Thus the benefits of RFID have been difficult to implement across a wider set of applications. For example, access control readers and animal scanners cannot be integrated into cell phones, DVD players or medical devices. Furthermore, because RFID readers have been delivered as vertically-integrated \u2018black-box\u2019 technology, software developers have not had access to the inner workings of the readers.","Even within retail supply chain, RFID reader requirements vary widely from stationary label printers to handheld devices and from forklifts to dock doors. Indeed there remains a problem in the industry that no standard technology can support the spectrum of reader requirements\u2014from power and frequency control, to host interfaces, to tag protocols and standards, as well as the wide variety of price\/performance tradeoffs related to read range and rate, physical size, power consumption and cost.","A framework structure is disclosed for controlling an RFID device including a platform comprising an RFID radio. The structure comprises a layered framework including a first layer, with at least one functional module comprising a device driver, communicatively coupled with the platform; and a second layer, with at least one functional module comprising an API, communicatively coupled with the first layer and with an application for controlling the RFID device.","In one embodiment, the framework structure includes a firmware stratum comprising a tiered plurality of the functional modules, with the stratum being integrated with the layered framework such that each tier of the stratum is layered to functionally correspond to one of the layers in the framework.","The present RFID operating system (\u2018RFID OS\u2019) comprises an open-architecture software architecture for RFID readers. The system provides interoperability between generic RFID readers, system services, and applications. The present architecture allows RFID reader functionality to be independent of RFID reader hardware architecture.","In the present system, RFID services are layered on top of the RFID OS. For example, a service handler may facilitate a contactless payment transaction by invoking a particular application functionality via a tag protocol API (application programming interface), which in turn, calls on or more APIs to perform RF communication with RFID tags.","The present RFID operating system framework includes a layered architecture that can be used with a multiplicity of different RFID reader platforms. The RFID OS framework interfaces with peripheral hardware, and may perform a number of different application functions such as task scheduling, protocol handling, and storage allocation. The framework provides a default software interface between a host processor and an RFID reader when no application program is running on a particular reader.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1A","FIG. 1B","FIGS. 1A and 1B"],"b":["101","102"]},"Reader  is connected to an external host computer , and reader  has an embedded processor  which functions as a dedicated, fixed-capability host. In both readers \/, a host-specific API  is typically integral to the readers, and the reader functionality is pre-established and not modifiable by a user, since the functionality is \u2018buried\u2019 inside user-inaccessible firmware in a \u2018black box\u2019 . In the systems of , the reader control features and functionality are set at compile time, thus making the readers \/ application-specific. Value-added software & middleware cannot be integrated into these existing readers by a typical user, thereby limiting the readers' performance.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 2"],"b":["200","201","220","212","210","210","209","214","230","210","214","230","202"]},"Reader platform  comprises on-board control software for an RFID reader that can be customized and built upon by third-party developers. This platform enables OEMs to easily RFID-enable new or existing devices.","Reader platform  may also include an embedded operating system , such as Linux or Windows CE. Platform  may be coupled to framework  via an operating system  running on the platform (through interface ), or via RF communication with RFID radio , using an RF link . In the latter instance, the platform typically does not include operating system .","As explained below, the present RFID OS vertical framework  is integrated with a horizontal firmware stratum (shown in ) to support a range of options for use with an RFID reader platform . These options include firmware components that can be used independently or in combination, a set of API extensions to embedded operating systems, and a stand-alone operating system for dedicated RFID reader architectures.","As shown in , the vertical framework  for the present system comprises three layers, which are effectively situated \u2018on top of\u2019 platform :\n\n","Specific examples of functional modules included in the above layers are described with respect to , below.",{"@attributes":{"id":"p-0040","num":"0042"},"figref":"FIG. 3A"},"As shown in , framework  vertically tiered with respect to RFID reader application software interface layer  and hardware abstraction layer , both of which are also tiered or layered in a \u2018vertical\u2019 direction between reader platform  and application layer .","More specifically, the application software interface layer  is tiered or divided into two functional sub-layers, a layer  including library functions (or modules), and a layer  including APIs for interfacing between the library functions and the application layer , as indicated by arrow  in . As used herein, the term \u201clibrary function\u201d refers to any software or firmware program code, which, although typically stored with other functions in a \u2018library\u2019, may exist in a context (or layer, in the present system) wherein no library is extant. In the present document, the terms \u201clibrary function\u201d and \u201clibrary module\u201d are intended to refer to the same type of entity, as a result of the modular nature of the present system architecture.","The hardware abstraction layer  is also tiered or divided into two functional sub-layers, a layer  including hardware and communication device drivers (modules), and a layer  including driver APIs for interfacing between the drivers and corresponding library functions in API library function layer , as indicated by arrow .","It should be noted that, in certain cases, where an application in layer  has a priori knowledge of the protocol or other mechanism for communicating with a particular driver in layer , the application may bypass the application software interface layer  and directly call the driver, as indicated by arrow .","As indicated in , the RFID OS vertical framework  includes an operating system kernel  which is always present, and various system programs  which use facilities provided by the kernel to perform higher-level \u2018housekeeping\u2019 tasks. Each of the vertical layers in the present system is described in greater detail immediately below.","Platform Layer","The RFID operating system vertical framework  may be viewed as resting on top of the reader platform layer . In an exemplary embodiment, platform  includes hardware, plus an optional operating system  and developer tools . The terms \u201chardware platform\u201d or \u201chardware layer\u201d are often used interchangeably when referring to a platform. A simple platform  might use 8-bit microcontroller hardware with no operating system; in this case, modules in RFID OS framework  serve as the device operating system. On platforms with more powerful processors, the present system integrates with both the target operating system  and the platform hardware ; in this case, portable RFID OS framework components reside in the different processors, logic blocks and ASICs that comprise a particular platform . The open software architecture of the RFID OS framework , together with the horizontal layering of the firmware stratum (described below) facilitates integration of RFID radio hardware with most types of processors and OS platforms.",{"@attributes":{"id":"p-0047","num":"0049"},"figref":["FIG. 4A","FIG. 4A"],"b":["209","402","404","406","408","410","214"]},"Hardware Abstraction Layer\/Drivers","As shown in , driver APIs (in sub-layer  of hardware abstraction layer ) function as the software interface for the low-level software drivers that directly control reader hardware . In an exemplary embodiment, the driver APIs (in sub-layer  of layer ) are platform-independent. The code that implements each driver is, however, platform-specific. Typically, only a small amount of code in each low-level driver requires modification when porting to a new platform. The hardware abstraction layer  in RFID OS framework  provides portability for \u2018on-reader\u2019 applications, and platform-independence across RFID-enabled devices.",{"@attributes":{"id":"p-0049","num":"0051"},"figref":["FIG. 4B","FIG. 4B"],"b":["303","414","416","424"]},"Application Software Interface Layer\/Libraries\/APIs","As shown in , sub-layer  of application software interface layer  includes a library of functions or modules, and sub-layer  includes one or more libraries of APIs defining the software interface used by an application to access internal RFID reader functionality, via the functions in sub-layer . In an exemplary embodiment, the library APIs  are platform-independent, as are the code implementations of the library functions in sub-layer . Unless otherwise indicated, the term \u201ccode\u201d is used herein to refer to \u2018object code\u2019, which is code produced by a compiler from \u2018source code\u2019, usually in the form of machine language that a computer (e.g., a microprocessor) can execute directly. The present system allows the use of multiple APIs for \u2018on-device\u2019 applications to control device hardware and low-level functionality in a standard manner, regardless of the device-embedded computing platform . Such platforms  range from DSP architectures to microprocessor cores with an operating system to microcontroller-based devices, sensors and objects, with or without an operating system.","Application Layer","Applications in application layer , as well as in host \/, may indirectly access any of the lower layers (, , ) in the system architecture via a set of APIs \/. By accessing the RFID reader hardware and platform  via the abstraction layers provided by the libraries and drivers, \u2018on-reader\u2019 applications become portable across devices employing the present architecture. This abstraction layering makes third-party-generated RFID reader software and tag protocol libraries independent of the underlying hardware, thus facilitating the integration of embedded computing intelligence into sensors, devices and ordinary objects.","In an alternative embodiment of the present system, hardware abstraction layer  may include one or more drivers and no API(s). In this same embodiment, application software interface layer  may include only (one or more) APIs and no library functional modules. In this embodiment, an API in layer \/ directly calls a corresponding driver in layer \/ to control reader hardware .",{"@attributes":{"id":"p-0053","num":"0055"},"figref":["FIG. 4C","FIG. 4C"],"b":["305","426","436"]},{"@attributes":{"id":"p-0054","num":"0056"},"figref":["FIG. 4D","FIG. 4D"],"b":["306","205","305"]},"Application Code Layer","In an exemplary embodiment, as indicated above, on-reader applications make function calls to library functions, which, in turn, call driver functions which control the reader hardware. As shown in , application layer  of the present system includes one or more of these applications.",{"@attributes":{"id":"p-0056","num":"0058"},"figref":["FIG. 3B","FIG. 3C","FIGS. 3B and 3C","FIG. 2","FIG. 3A","FIG. 3B","FIG. 3C"],"b":["350","350","201","350","201","33","331","338","201","331","338","201","1","201"]},"The orthogonal relationship between firmware stratum  and the layering of composite structure (*) is indicated in  by the relationship between arrow , which shows the \u2018horizontal\u2019 layering of the firmware stratum, and arrow , which shows the \u2018vertical\u2019 layering of each of the components or \u2018levels\u2019 of the firmware stratum. Each level X of firmware stratum  includes one, two, or three modules, the aggregate of which may include an API, a library function (or other functional component), and a driver. Thus, each stratum level X is itself layered in the three-tiered scheme of framework structure .","Table 1, below, lists specific modules or other functional components that may be included in the firmware stratum  in an exemplary embodiment of the present system. In Table 1, each level X may be further subdivided into sub-levels, each of which is designated in the Table as being a member of a respective higher level, as indicated in .",{"@attributes":{"id":"p-0059","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"FIRMWARE STRATUM"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIG. 3",{},{}]},{"entry":["LEVEL","SUBLEVEL","FUNCTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["338",{},"Application Module Interface"]},{"entry":[{},"44","AM-Host Interface"]},{"entry":[{},"43","AM-Host Protocol Security"]},{"entry":[{},"42","AM-Host Discovery"]},{"entry":[{},"41","AM-Host Plug-and-Play"]},{"entry":[{},"39","AM-Host APIs, Protocols and Adapters"]},{"entry":[{},"38","AM-Host Protocol Transport"]},{"entry":[{},"37","AM-Host Physical Connection"]},{"entry":["337",{},"Application Module Manaqement"]},{"entry":[{},"36","AM Self Test"]},{"entry":[{},"35","AM Code Update"]},{"entry":[{},"34","AM Management"]},{"entry":[{},"33","AM Configuration"]},{"entry":["336",{},"Application Module Development Environment"]},{"entry":[{},"32","AM Connected Devices"]},{"entry":[{},"31","Interpreter Support"]},{"entry":[{},"30","AM Operating System"]},{"entry":[{},"29","AM Processor"]},{"entry":[{},"28","Application Environment"]},{"entry":[{},"27","Workflow\/Scripting Engine"]},{"entry":["335",{},"Radio Communication and Control"]},{"entry":[{},"26","Reader to reader Protocol"]},{"entry":[{},"25","Tag Command Set Types"]},{"entry":[{},"24","Tag Command Language Support"]},{"entry":[{},"23","Read Tag"]},{"entry":["334",{},"Radio to Application Module Interface"]},{"entry":[{},"22","RM (Radio Module)-AM Protocol Security"]},{"entry":[{},"21","RM-AM Discovery"]},{"entry":[{},"20","RM-AM Plug-and-Play"]},{"entry":[{},"19","RM-AM APIs"]},{"entry":[{},"18","RM-AM Protocol(s)"]},{"entry":[{},"17","RM-AM Protocol Transport"]},{"entry":[{},"16","RM-AM Physical Connection"]},{"entry":["333",{},"Radio Module Management"]},{"entry":[{},"15","RM Self Test"]},{"entry":[{},"14","RM Code Update"]},{"entry":[{},"13","RM Management"]},{"entry":[{},"12","RM Configuration"]},{"entry":["332",{},"Radio Module Development Environment"]},{"entry":[{},"11","RM Task Automation\/Scripting"]},{"entry":[{},"10","RM Connected Devices"]},{"entry":[{},"9","RM Operating System"]},{"entry":[{},"8","RM Processor"]},{"entry":["331",{},"Tag Interface"]},{"entry":[{},"7","Anti-Collision\/Tag Singulation"]},{"entry":[{},"6","Tag Command Primitives"]},{"entry":[{},"5","Air Protocol Security"]},{"entry":[{},"4","Air Protocols"]},{"entry":[{},"3","Modulation and Encoding Schemes"]},{"entry":[{},"2","Antenna Tuning, Control and Diversity"]},{"entry":[{},"1","Analog Front End (AFE) Abstraction Layer"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0060","num":"0062"},"figref":["FIG. 5","FIG. 5","FIGS. 2-4"],"b":["500","506","504","502","514","504","518","516","506","516","518","506","514","512","504","305","306","303","304"]},"In the system shown in , the RFID radio hardware comprises separate digital and analog hardware , , which is respectively split between signal processor  and discrete (analog) radio device . Accordingly, platform  may be considered to overlap with hardware abstraction layer , as indicated by respective braces  and .",{"@attributes":{"id":"p-0062","num":"0064"},"figref":["FIG. 6","FIG. 6","FIGS. 2-4"],"b":["600","604","602","605","607","609","604","602","610","612","610","605","607","609","604","614","512","504","305","306","303","304"]},"In the system shown in , the RFID radio hardware comprises separate digital and analog hardware which may be split between signal processor  and discrete (analog) radio device , as in the system of . Accordingly, platform  may be considered to overlap with part of framework , as indicated by respective braces  and .",{"@attributes":{"id":"p-0064","num":"0066"},"figref":"FIG. 7","b":["700","203","205","207","201"]},"The software\/firmware in reader  includes proprietary source code (and other information) security capability, as well as secure delivery capability, so that a user can encapsulate code into a software module that may be distributed in a secure manner (i.e., without being copied). Using a suitable form of encryption as the security mechanism, selected code (in software or firmware form) can reside and operate within the platform or framework without being extracted or copied.","The present system architecture allows any specific software\/firmware module to have its API known\/published, but any module containing API-related code (the code accessed by the API), for example, may remain protected and secure. Other parties can make function calls to the protected functions by making calls to the functions' published APIs. Each of the components within framework  is selectively securable at three levels, i.e., at the driver, libraries, API and\/or application level. Some components may be open source, and other components may be locked and proprietary so that third parties can use this open architecture framework as a secure delivery vehicle for their code into the market.","As shown in the example of , module  in application layer , modules  and  in hardware abstraction layer , and modules  and  in application software interface layer  are encrypted so that they remain inaccessible to unauthorized users and other third parties.",{"@attributes":{"id":"p-0068","num":"0070"},"figref":["FIG. 8","FIG. 8","FIG. 3A"],"b":["805","305","205","306","205","810","815","820","825"]},{"@attributes":{"id":"p-0069","num":"0071"},"figref":["FIG. 9","FIG. 9","FIG. 3B","FIG. 3B"],"b":["905","207","306","23","306","205","230","910","306","23","305","23","305","335","23","305","305","23","335","33","905","910","315"]},"At step , the \u2018Read Tag\u2019 library function () calls Read Tag driver API () in driver API library layer , in framework layer \/firmware stratum Level , sub-level . At step , Read Tag driver API () calls Read Tag driver () in driver layer , in framework layer \/firmware stratum Level , sub-level . Steps  and  of the present example are indicated by arrow  in .","At step , the Read Tag driver sends a Read Tag command to platform , as indicated by arrow . Finally, at step , the platform sends the Read Tag command to Tag , which reads information stored in the tag, and sends information back to the reader, as indicated by arrow  in . Note that steps  through  in the present example are each performed by a module in the same firmware stratum level (i.e., Level , sub-level ).","Certain changes may be made in the above methods and systems without departing from the scope of that which is described herein. It is to be noted that all matter contained in the above description or shown in the accompanying drawings is to be interpreted as illustrative and not in a limiting sense. For example, the methods shown in  may include steps other than those shown therein, and the systems shown in  may include different components than those shown in the drawings. The elements and steps shown in the present drawings may be modified in accordance with the methods described herein, and the steps shown therein may be sequenced in other configurations without departing from the spirit of the system thus described. The following claims are intended to cover all generic and specific features described herein, as well as all statements of the scope of the present method, system and structure, which, as a matter of language, might be said to fall there between."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3B","FIG. 3C"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4A","b":"209"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4B","b":"305"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4C","b":"207"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4D","b":"207"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
