---
title: Rendering mode selection in graphics processing units
abstract: This disclosure describes techniques for automatically selecting a rendering mode for use by a graphics processing unit (GPU) to render graphics data for display. More specifically, the techniques include evaluating at least two metrics associated with rendering graphics data of one or more rendering units, and automatically selecting either an immediate rendering mode or a deferred rendering mode for a current rendering unit based on the evaluated metrics. The selected rendering mode may be the one of the rendering modes predicted to use less power and/or system bandwidth to render the graphics data of the current rendering unit. A rendering unit may comprise a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08982136&OS=08982136&RS=08982136
owner: QUALCOMM Incorporated
number: 08982136
owner_city: San Diego
owner_country: US
publication_date: 20110516
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates to processing data and, more particularly, processing data using a graphics processing unit (GPU).","A graphics processing unit (GPU) is a dedicated graphics rendering device utilized to process and display computerized graphics on a display device. GPUs are built with a highly-parallel structure that provides more efficient processing than typical, general-purpose central processing units (CPUs) for a range of complex algorithms. For example, the complex algorithms may correspond to representations of two-dimensional (2D) or three-dimensional (3D) computerized graphics.","GPUs may be included within graphics devices such as mobile wireless telephones, personal digital assistants (PDAs), video gaming devices, video gaming consoles, video conferencing units, laptop computers, desktop computers, tablet computers, television set-top boxes, integrated television graphics devices, digital recording devices, digital media players, global positioning system (GPS) devices, digital cameras, automotive displays, and the like. Graphics applications executed on the graphics devices may describe or define contents of a graphics scene by invoking application programming interface (API) calls, or instructions, which in turn use the GPU to render an image for display.","Rendering engines of GPUs may operate according to either an immediate rendering mode or a deferred rendering mode. When operating according to the immediate rendering mode, a rendering engine of a GPU renders graphics data directly to a frame buffer. When operating according to the deferred rendering mode, a rendering engine of a GPU performs a tiling pass to divide graphics data into a plurality of tiles, renders each of the plurality of tiles to a local tile buffer, and reads each for the rendered tiles from the tile buffer to a frame buffer. At present, the immediate rendering mode is most commonly used in graphics devices where power and system bandwidth are less of a concern, and the deferred rendering mode is most commonly used in mobile devices where power and system bandwidth are at a premium.","This disclosure describes techniques for automatically selecting a rendering mode for use by a graphics processing unit (GPU) to render graphics data for display. More specifically, the techniques include evaluating at least two metrics associated with rendering graphics data of one or more rendering units, and automatically selecting either an immediate rendering mode or a deferred rendering mode for a current rendering unit based on the evaluated metrics. A rendering unit may comprise a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. A current rendering unit may comprise the rendering unit that is currently being rendered by the GPU. The techniques for automatically selecting a rendering mode may be performed at each rendering boundary in the graphics data, i.e., when the GPU finishes rendering a previous rendering unit and begins rendering a current rendering unit.","The most efficient rendering mode may vary based on the performance of the GPU when rendering certain graphics data. The selected rendering mode, therefore, may be the one of the rendering modes predicted to use less power and\/or less system bandwidth to render a current rendering unit of graphics data based on the evaluated metrics. The techniques of this disclosure include configuring a GPU to operate according to the selected rendering mode. In some cases, the techniques may also include receiving a manually selected rendering mode that overrides the automatically selected rendering mode. When a manually selected rendering mode is received, the GPU may be configured to operate according to the manually selected rendering mode.","In one example, this disclosure is directed to a method of processing graphics data comprising evaluating at least two metrics associated with rendering graphics data of one or more rendering units, automatically selecting a rendering mode for a current rendering unit as one of an immediate rendering mode and a deferred rendering mode based on the evaluated metrics, and configuring a graphics processing unit (GPU) to render graphics data of the current rendering unit according to the selected rendering mode.","In another example, this disclosure is directed to a graphics device for processing graphics data comprising a memory buffer that stores metrics associated with rendering graphics data of one or more rendering units, and one or more processors that evaluate at least two of the metrics, automatically select a rendering mode for a current rendering unit as one of an immediate rendering mode and a deferred rendering mode based on the evaluated metrics, and configures a graphics processing unit (GPU) to render graphics data of the current rendering unit according to the selected rendering mode.","In a further example, this disclosure is directed to a graphics device for processing graphics data comprising means for evaluating at least two metrics associated with rendering graphics data of one or more rendering units, means for automatically selecting a rendering mode for a current rendering unit as one of an immediate rendering mode and a deferred rendering mode based on the evaluated metrics, and means for configuring a graphics processing unit (GPU) to render graphics data of the current rendering unit according to the selected rendering mode.","In another example, this disclosure is directed to a computer-readable medium comprising instructions for processing graphics data that, when executed, cause one or more programmable processors to evaluate at least two metrics associated with rendering graphics data of one or more rendering units, automatically select a rendering mode for a current rendering unit as one of an immediate rendering mode and a deferred rendering mode based on the evaluated metrics, and configure a graphics processing unit (GPU) to render graphics data of the current rendering unit according to the selected rendering mode.","The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.","This disclosure describes techniques for automatically selecting a rendering mode for use by a graphics processing unit (GPU) to render graphics data for display. More specifically, the techniques include evaluating at least two metrics associated with rendering graphics data of one or more rendering units, and automatically selecting either an immediate rendering mode or a deferred rendering mode for a current rendering unit based on the evaluated metrics. The selected rendering mode may be one of the rendering modes predicted to use less power and\/or less system bandwidth to render the current rendering unit of the graphics data based on the evaluated metrics. A rendering unit may comprise a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. A current rendering unit may comprise the rendering unit currently being rendered by the GPU. The techniques for automatically selecting a rendering mode may be performed at each rendering boundary in the graphics data, i.e., when the GPU finishes rendering a previous rendering unit and begins rendering.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["2","10","6","10","6"]},"Graphics device  is capable of transmitting and receiving graphics data, supporting a variety of graphics data processing applications, and outputting processed graphics data for presentation to a user. Examples of graphics device  include, but are not limited to, mobile wireless telephones, personal digital assistants (PDAs), video gaming devices, video gaming consoles, video conferencing units, laptop computers, desktop computers, tablet computers, television set-top boxes, integrated television graphics devices, digital recording devices, digital media players, global positioning system (GPS) devices, digital cameras, automotive displays, and the like. Graphics data may comprise still image data, video data, or other multimedia data. In this disclosure, graphics data may often be described as video data that includes a plurality of sequential frames. It is not intended, however, to limit the types of graphics data that may be rendered according to the techniques of this disclosure.","In the example illustrated in , graphics device  includes a central processing unit (CPU)  with graphics driver , a GPU  with a rendering engine , a device memory , a transceiver module , a user input device , and a display . In other cases, for example, when graphics device  is a desktop computer, display  and\/or user input device  may be external to graphics device . CPU  and GPU  may comprise digital signal processors (DSPs), general purpose microprocessor, application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. CPU  may be capable of controlling GPU .","Graphics device  may execute one or more graphics applications on CPU . Examples of graphics applications include web browsers, e-mail applications, spreadsheets, video games, computer-aided design (CAD) applications, digital camera applications, video conferencing applications, simulation and visualization tools, video streaming applications, or other applications that generate visual output for presentation to a user via display .","CPU  executes a graphics application by invoking application instructions for the graphics application, which use CPU  and\/or GPU  to generate an image. In some cases, the application instructions may be generated from graphics application programming interface (API) calls. Graphics APIs for writing graphics applications may include Open Graphics Library (OpenGL\u00ae), OpenGL\u00ae for embedded systems (OpenGL\u00ae ES), or OpenVG (vector graphics) APIs. In the illustrated embodiment, graphics driver  runs on CPU . Graphics driver  may translate the application instructions or API calls into commands to be performed on CPU  and\/or GPU . In some cases, GPU  may separately execute one or more graphics applications. In this case, GPU  may also execute its own graphics driver. In other examples, graphics driver  may be stored in device memory  such that either CPU  or GPU  could load graphics driver  for execution by that processing unit.","GPU  may perform commands issued by graphics driver  on CPU  in accordance with the graphics application to render graphics data into an image for presentation to a user via display . For example, GPU  may perform one or more of vertex shading, triangle rasterization, fragment shading, and pixel blending. GPU  may then store the rendered graphics data in a frame buffer in device memory . The graphics data may be rendered by GPU  on a per rendering unit basis. As described above, a rendering unit may comprise a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. In some cases, a frame may include one or more render targets. Render targets may comprise frame buffers stored in device memory  that each holds a certain type of graphics data for a frame, such as texture data, color data, and depth data. GPU  may render graphics data within each of the render targets associated with the frame, and then combine the rendered graphics data for storage in device memory  and presentation on display  as the single frame.","In the illustrated example, GPU  includes a rendering engine  that may operate according to either an immediate rendering mode or a deferred rendering mode to render graphics data. When operating according to the immediate rendering mode, rendering engine  within GPU  renders graphics data of a rendering unit directly to a frame buffer in device memory . Rendering engine , therefore, makes all read and write calls for the graphics data being rendered to device memory  external to GPU . This mode may use a large amount of system bandwidth and power when performing certain graphics operations that require many read-modify-writes in device memory , such as pixel blending and depth testing, to render the graphics data.","When operating according to the deferred rendering mode, rendering engine  within GPU  may first perform a tiling pass to divide a current rendering unit into a plurality of tiles. For each of the plurality of tiles, rendering engine  then renders graphics data of the tile to a tile buffer located locally on GPU  and, when complete, reads the rendered graphics data from the tile buffer to a frame buffer in device memory . Rendering engine , therefore, makes a majority of read and write calls for the graphics data being rendered to the tile buffer on GPU . This mode, i.e., deferred rendering, uses a small amount of power and no system bandwidth to perform read-modify-writes in the tile buffer, but includes additional overhead costs of setting up the tiling pass and rendering each tile of the rendering unit.","Conventionally, a GPU within a laptop or desktop computer, or another type of wall-plugged graphics device in which power and bandwidth usage are not a concern, would likely be designed to operate according to the immediate rendering mode. On the contrary, a GPU within a mobile wireless telephone, or other mobile devices in which power and bandwidth are at a premium, would likely be designed to operate according to the deferred rendering mode. The most efficient rendering mode may vary, however, based on the performance of the GPU when rendering certain graphics data.","According to the techniques in this disclosure, graphics driver  may automatically select a rendering mode for use by GPU  to render graphics data for presentation to a user on display . More specifically, graphics driver  may evaluate at least two metrics associated with rendering graphics data, and automatically select either an immediate rendering mode or a deferred rendering mode for a current rendering unit based on the evaluated metrics. The metrics may include performance metrics, power metrics, or other metrics of CPU  and GPU  when rendering graphics data of a previous or current rendering unit. The selected rendering mode may be the one of the rendering modes predicted to use less system bandwidth and\/or less power to render the graphics data of the current rendering unit based on the evaluated metrics. In some cases, the selected rendering mode may also be the rendering mode predicted to allow higher vertex throughput in CPU  and\/or GPU , reduce overhead of graphics driver , or otherwise improve the performance and power consumption based on the evaluated metrics.","Graphics driver  may then configure GPU  to operate according to the selected rendering mode. In some cases, graphics driver  may also receive a manually selected rendering mode that overrides the automatically selected rendering mode. For example, graphics driver  may receive the manually selected rendering mode from a developer or other user via a graphics API executed on CPU . When a manually selected rendering mode is received, graphics driver  may configure GPU  to operate according to the manually selected rendering mode.","The techniques of this disclosure\u2014including collecting and evaluating metrics, automatically selecting a rendering mode, and configuring GPU \u2014may be performed at each rendering boundary. A rendering boundary may comprise a transition period between rendering units, e.g., when GPU  finishes rendering a previous rendering unit and begins rendering a current rendering unit. Once GPU  completes rendering of a previous rendering unit, GPU  switches from receiving data of the previous rendering unit to receiving data of a current rendering unit to be rendered. At that time, according to the techniques, graphics driver  may automatically select the rendering mode for the current rendering unit based on the evaluated metrics. If the rendering mode selected for the current rendering unit is different than the rendering unit used for the previous rendering unit, graphics driver  may also reconfigure GPU  to operate according to the newly selected rendering mode. CPU  may download one or more graphics applications via transceiver module . In addition, CPU  may download graphics data to be processed by CPU  and\/or GPU  in accordance with the graphics applications via transceiver module . Transceiver module  may include circuitry to allow wireless or wired communication between graphics device  and another device or a network. Transceiver module  may include modulators, demodulators, amplifiers and other such circuitry for wired or wireless communication.","CPU  may store application instructions for each of the graphics applications within device memory . In addition, device memory  may store the graphics data to be processed by CPU  and\/or GPU  in accordance with the graphics applications, and may also store processed graphics data received from CPU  and\/or GPU . For example, device memory  may store rendered graphics data of a current rendering unit in a frame buffer. As another example, device memory  may store one or more render targets associated with a frame that each holds a certain type of graphics data for the frame, such as texture data, color data, and depth data. In some cases, device memory  may also include a desktop or display dedicated frame buffer into which rendered graphics data of a frame may be copied for presentation on display .","Device memory  may comprise one or more computer-readable storage media. Examples of device memory  include, but are not limited to, a random access memory (RAM), a read only memory (ROM), an electrically erasable programmable read-only memory (EEPROM), CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor.","Display  comprises an output device for graphics device . As an example, display  may comprise a liquid crystal display (LCD), a cathode ray tube (CRT) display, a plasma display, or another type of display device. In some cases, graphics device  may include speakers or other types of video and audio output devices. GPU  may provide processed graphics data for presentation to display . For example, GPU  may copy the rendered graphics data of a frame from a frame buffer to a desktop or display dedicated frame buffer within device memory  to present the frame to a user via display .","User input device  comprises one or more user input devices for graphics device . For example, user input device  may include a trackball, a mouse, a keyboard, a microphone and\/or other types of input devices. In some examples, user input device  may comprise a touch screen and may be incorporated as a part of display . A user may select one or more graphics applications to be executed by CPU  via user input device . In the illustrated example, display  and user input device  are included in graphics device . In other examples, display  and\/or user input device  may be external to graphics device .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 2"],"b":["2","10","6","4","6","8","10"]},"In the illustrated example of , CPU  executes a graphics application , a graphics API  and graphics driver . Graphics application  may include, for example, web browsers, e-mail applications, spreadsheets, video games, computer-aided design (CAD) applications, digital camera applications, video conferencing applications, simulation and visualization tools, video streaming applications, or other applications that generate visual output.","CPU  may execute graphics application  by invoking application instructions, which use CPU  and\/or GPU  to generate an image. Application instructions may be stored in device memory . In some cases, the application instructions may be generated from graphics API calls made by graphics API , such as calls to draw primitives or triangles associated with the image. Graphics API  may comprise one of an Open Graphics Library (OpenGL\u00ae), OpenGL\u00ae for embedded systems (OpenGL\u00ae ES), or OpenVG (vector graphics) API. Graphics driver  may translate the application instructions or API calls from graphics API  into commands to be performed by CPU  and\/or GPU  in accordance with graphics application .","In the illustrated example of , GPU  includes rendering engine , a tile buffer , and GPU performance counters . Rendering engine  may include one or more processing units used to process graphics data for display. For example, rendering engine  may comprise a vertex shader, a triangle rasterizer, a fragment shader, and\/or a pixel blender. GPU performance counters  may comprise hardware counters that record processing information associated with GPU , including an amount of system bandwidth used by GPU  during rendering.","GPU  may perform commands issued by graphics driver  on CPU  in accordance with the graphics application to render graphics data into an image for presentation on display. For example, rendering engine  of GPU  may receive graphics data from device memory  and perform one or more of vertex shading, triangle rasterization, fragment shading, and pixel blending. GPU  may then eventually store the rendered graphics data in frame buffer  in device memory . The graphics data may be rendered by rendering engine  on a per rendering unit basis. A rendering unit may include, for example, a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target.","In some cases, one or more render targets  may be defined for a frame. Render targets  comprise frame buffers stored in device memory  that each holds a certain type of graphics data for a frame, such as texture data, color data, and depth data. Graphics data within each of render targets  associated with a given frame may be rendered separately by rendering engine  and then combined in frame buffer  in device memory . In some cases, render targets  may include multiple render targets that hold the same type of data, e.g., color data, for a frame. Rendering engine  may render the graphics data in the multiple render targets simultaneously. A different number of render targets  may be defined for each frame of the graphics data.","Rendering engine  of GPU  may operate according to either an immediate rendering mode or a deferred rendering mode to render graphics data. When operating according to the immediate rendering mode, rendering engine  within GPU  renders graphics data of a rendering unit directly to frame buffer  in device memory . Rendering engine , therefore, makes all read and write calls for the graphics data being rendered to device memory  located external to GPU .","When operating according to the deferred rendering mode, rendering engine  within GPU  first performs a tiling pass to divide a rendering unit into a plurality of tiles. For each of the plurality of tiles, rendering engine  then renders graphics data of the tile to tile buffer  located locally on GPU  and, when complete, reads the rendered graphics data from tile buffer  to frame buffer  in device memory . Rendering engine , therefore, makes a majority of read and write calls for the graphics data being rendered to tile buffer  on GPU . In the case where one or more render targets  are defined for a frame, rendering engine  must perform a tiling pass for each of render targets  and then render each tile for each of render targets  associated with the frame.","Tile buffer  is a small amount of very high bandwidth memory located on-chip with GPU . The size of tile buffer , however, is too small to hold graphics data for an entire rendering unit, so rendering engine  must perform multiple rendering passes to render the entire rendering unit. For example, rendering engine  may perform one rendering pass for each tile of a frame, or may perform one rendering pass for each tile for each of render targets  associated with a frame. In some cases, rendering engine  may also perform binning to determine which primitives of the rendering unit are visible within each of the tiles. If binning is not performed, rendering engine  of GPU  may use raster scissors to draw all the primitives or triangles included in the rendering unit for each tile being rendered. By performing binning, rendering engine  may only draw those primitives in the rendering unit that are visible within a given tile being rendered.","The deferred rendering mode may use less power and system bandwidth to render graphics data when the graphics data represents a complex graphics scene with pixel blending and depth testing that requires many read-modify-write functions. The deferred rendering mode, however, does include additional overhead costs of setting up the tiling pass and rendering graphics data for each tile of the rendering unit. The deferred rendering mode may be the most efficient rendering mode when the overhead cost of setting up a tiling pass and rendering a plurality of tiles for each rendering unit does not override the bandwidth reduction of the deferred rendering mode.","On the contrary, the immediate rendering mode may use less power and system bandwidth to render graphics data when the graphics data represents a simple graphics scene where the deferred rendering mode provides no bandwidth reduction but acts as a drain on processing resources. The immediate rendering mode may be the most efficient mode when the overhead cost of setting up a tiling pass and rendering a plurality of tiles for each rendering unit overrides any bandwidth reduction of the deferred rendering mode.","According to the techniques of this disclosure, graphics driver  may automatically select either the immediate rendering mode or the deferred rendering mode for use by GPU  based on which is predicted to use the least amount of system bandwidth and\/or power to render graphics data of the current rendering unit. In general, graphics driver  may evaluate at least two metrics associated with rendering graphics data, select either the immediate rendering mode or the deferred rendering mode based on the evaluated metrics, and configure GPU  to operate according to the selected rendering mode. The automatic rendering mode selection process is described in more detail below.","Graphics driver  may select a rendering mode for a current rendering unit at a rendering boundary in the graphics data when GPU  is switching from a previous rendering unit to the current rendering unit. As described above, a rendering unit may include a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. A rendering boundary may comprise a transition period between rendering units, e.g., when GPU  finishes rendering a previous rendering unit and begins rendering a current rendering unit. Once GPU  completes rendering of a previous rendering unit, GPU  switches from receiving data of the previous rendering unit to receiving data of a current rendering unit to be rendered. At that time, graphics driver  may automatically select the rendering mode for the current rendering unit.","In this way, as the graphics data changes and as the performance of CPU  and\/or GPU  when rendering the graphics data changes, graphics driver  may switch the rendering mode used by GPU  for the current situation. For example, if the rendering mode selected for the current rendering unit is different than the rendering unit used for the previous rendering unit, graphics driver  may reconfigure GPU  to operate according to the newly selected rendering mode. According to the techniques, graphics driver  may switch the rendering mode for each of single or multiple render targets  associated with a frame, for each frame of the graphics data, or for each predefined set of frames of the graphics data.","At a given rendering boundary, graphics driver  may collect metrics associated with rendering graphics data of one or more rendering units. The metrics may be associated with the performance of CPU  and\/or GPU  when rendering graphics data of a previous rendering unit and a current rendering unit. During processing of the graphics data, GPU  may be several frames behind CPU . Graphics driver , therefore, may collect metrics associated with rendering graphics data of a previous rendering unit from GPU  and collect metrics associated with rendering graphics data of a current rendering unit from CPU .","The metrics may include a number of vertices in a rendering unit, a number of fragments in a rendering unit, locations of fragments in the rendering unit, an amount of GPU bandwidth used during rendering, a load amount on registers of GPU  during rendering, a load amount on registers of CPU  during rendering, a number of render targets  defined for a frame, a number of multiple render targets (MRTs) defined for a frame, dimensions (e.g., height, width, bits per pixel) of render targets , whether depth testing is enabled for the rendering unit, whether blending is enabled for the rendering unit, whether stencil testing is enabled for the unit, a type of application executed on GPU , a number of graphics API calls to draw primitives for a rendering unit, and additional information from GPU performance counters . In addition, the metrics may also include whether scene overdraw occurs for the rendering unit, whether mid-render updates occur in render targets  during rendering, whether transform feedback is used, whether fragments in the rendering unit are read from frame buffer , a number of state updates for the rendering unit, and other metrics that may indicate a mid-frame resolve.","In general, it is relatively inexpensive for graphics driver  to collect the metrics, even on a per frame or per render target basis. Information from GPU performance counters , however, may be collected less frequently because, on some hardware, a performance stall of GPU  may be required to read GPU performance counters . Graphics driver  may then store the collected metrics in metric buffer . The process of collecting metrics is described in more detail with respect to .","Graphics driver  next evaluates the metrics to predict which of the immediate rendering mode and the deferred rendering mode will use less power and\/or system bandwidth to render the graphics data of the current rendering unit. Graphics driver  evaluates at least two of the metrics. By evaluating more than one metric, graphics driver  may gain a thorough understanding of the performance and power constrains associated with rendering the current rendering unit in order to make an efficient rendering mode selection.","For example, graphics driver  may evaluate at least the metrics of GPU bandwidth and a number of render targets defined for a frame. If graphics driver  only evaluated GPU bandwidth, it would fail to take into account the processing resources required to set up the tiling pass and render each tile of the rendering unit in the deferred rendering mode. By evaluating both GPU bandwidth and a number of render targets, graphics driver  may compare the bandwidth costs with the overhead costs to render graphics data of the current rendering unit to predict the most efficient rendering mode for use by GPU .","Graphics driver  may apply a weighting scheme to the at least two metrics. For example, graphics driver  may execute an algorithm that assigns certain amounts of weight to two or more of the metrics. The weighting scheme may apply an equal amount of weight to two or more of the metrics, or may apply a different amount of weight to each of the metrics. In some cases, the weighting scheme algorithm may be pre-programmed into graphics driver . In other cases, the weighting scheme algorithm may be set by a developer via graphics API . In this way, the weighting scheme algorithm may be varied over time based on a type of graphics data to be rendered, system requirements and performance of CPU  and GPU , or other considerations. The process of evaluating two or more metrics is described in more detail with respect to .","Graphics driver  then automatically selects the immediate rendering mode or the deferred rendering mode based on the evaluated metrics. More specifically, graphics driver  may select the rendering mode predicted to use less power and\/or system bandwidth to render the graphics data of the current rendering unit. In some cases, graphics driver  may select the rendering mode also predicted to allow higher vertex throughput in CPU  and\/or GPU , reduce overhead of graphics driver , or otherwise improve the performance and power consumption based on the evaluated metrics.","In some cases, graphics driver  may also receive a manually selected rendering mode from a developer or other user. For example, graphics driver  may receive the manually selected rendering mode via graphics API  executed on CPU . In some cases, the manual selection may comprise an indication or a hint regarding a preferred one of the rendering modes to graphics driver . The manually selected rendering mode received by graphics driver  may override the automatically selected rendering mode. In this way, a developer may be able to control the rendering mode used by GPU  regardless of which rendering mode is predicted to use less power and\/or system bandwidth during rendering.","Regardless of whether the rendering mode is automatically selected based on evaluated metrics or manually selected by a user, graphics driver  configures GPU  to operate according to the selected rendering mode to render graphics data of the current rendering unit. Configuring GPU  may comprise programming registers of GPU  to send the rendered graphics data output from rendering engine  directly to frame buffer , in the case of the immediate rendering mode, or to tile buffer , in the case of deferred rendering mode. For example, when the immediate rendering mode is selected, graphics driver  may configure rendering engine  of GPU  to render graphics data of the current rendering unit directly to frame buffer  in device memory . On the contrary, when the deferred rendering mode is selected, graphics driver  may configure rendering engine  of GPU  to perform a tiling pass that divides the current rendering unit into a plurality of tiles, render graphics data of each of the plurality of tiles to tile buffer , and read each for the rendered tiles from the tile buffer to frame buffer .","Graphics driver  may then provide graphics data of the current rendering unit to rendering engine  of GPU  to be rendered according to the selected rendering mode. When GPU  reaches a rendering boundary in the graphics data, GPU  will switch to the next rendering unit. As described above, a rendering boundary may comprise a transition period between rendering units, such as a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. When GPU  switches to the next rendering unit, graphics driver  again performs the process described above to automatically select a rendering mode for the now current rendering unit. Hence, different rendering modes may be used for consecutive rendering units.  is a block diagram illustrating exemplary functional blocks of graphics driver  configured to automatically select a rendering mode for use by GPU . As described above, graphics driver  may translate application instructions or API calls for a graphics application into commands to be performed by CPU  and\/or GPU . For example, GPU  may render graphics data to prepare images for display in response to commands from the graphics application. In order to preserve power and system bandwidth during the rendering processes, graphics driver  may automatically select either the immediate rendering mode or the deferred rendering mode for use by GPU  based on evaluated metrics. Graphics driver  may first collect and store the metrics in metric buffer , and then evaluate the metrics in order to select the rendering mode predicted to use less power and\/or system bandwidth to render the graphics data.","In the illustrated example of , when executed by CPU , graphics driver  includes metric collection unit , metric evaluation unit , and rendering mode selection unit . As described above, metric buffer  may comprise a local memory buffer within CPU . In other examples, metric buffer  may comprise a memory buffer within device memory  located external to CPU .","In the illustrated example, metric buffer  includes GPU bandwidth , number of render targets , dimensions of render targets , GPU load , CPU load , number of vertices\/fragments , locations of fragments , depth test\/blending enablement , type of application , and number of API calls . In some cases, metric buffer  may include more or fewer metrics associated with rendering graphics data. For example, metric buffer  may include additional information collected from GPU performance counters  of GPU  in . In addition, metric buffer  may also include metrics regarding whether scene overdraw occurs for the in rendering unit, whether mid-render updates occur in render targets  during rendering, whether transform feedback is used, whether fragments in the rendering unit are read from frame buffer , a number of state updates for the rendering unit, and other metrics that may indicate a mid-frame resolve. Metric buffer  should include at least two metrics, such as GPU bandwidth  and number of render targets .","Graphics driver  may collect and evaluate the metrics to automatically select a rendering mode for use by GPU  at each rendering boundary within the graphics data. As described above, a rendering boundary may comprise a transition period between rendering units, e.g., when GPU  finishes rendering a previous rendering unit and begins rendering a current rendering unit. The rendering unit may include a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. At a given rendering boundary, graphics driver , running on CPU , executes metric collection unit  to collect metrics associated with rendering graphics data of one or more rendering units. For example, metric collection unit  may collect metrics associated with rendering the graphics data of a previous rendering unit and\/or a current rendering unit. During processing of the graphics data, GPU  may be several frames behind CPU . Metric collection unit  may, therefore, collect metrics from CPU  associated with rendering graphics data of the current rendering unit. At the same time, metric collection unit  may also collect metrics from GPU  associated with rendering graphics data of a previous rendering unit.","As an example, metric collection unit  may collect an amount of GPU bandwidth  used during rendering graphics data of a previous rendering unit from GPU performance counters  of GPU . In some cases, collecting information from GPU performance counter  may require a performance stall of GPU . Frequently stalling the performance of GPU  may cause an undesirable increase in the performance cost of rendering graphics data. Metric collection unit , therefore, may not collect information from GPU performance counters  at every rendering boundary, especially where the rendering boundaries occur between each frame or between each render target associated with a frame. In other cases, an amount of GPU bandwidth may be determined based on a number of vertices\/fragments  for the previous or current rendering unit collected from graphics application  executed on CPU . A large amount of system bandwidth used by GPU  to render graphics data may indicate that GPU  is making a large number of read and\/or write requests to device memory  in the immediate rendering mode.","Metric collection unit  may also collect a number of render targets  defined for a frame from graphics application  executed on CPU . As described above, render targets  comprise frame buffers stored in device memory  that each holds a certain type of graphics data for the associated frame, such as texture data, color data, and depth data. In order to render the frame, GPU  renders the graphics data within each of render targets  associated with the frame separately and then combines the rendered graphics data in frame buffer . The greater the number of render targets defined for a given frame, the greater the number of rendering passes is required to fully render the frame for display. In some cases, number of render targets  may include a number of multiple render targets included in render targets . As described above, multiple render targets comprise frame buffers that hold the same type of data, e.g., color data, for a frame, and may be rendered simultaneously.","In addition, metric collection unit  may collect dimensions of render targets  defined for a frame from graphics application  executed on CPU . The dimensions may comprise a height and width for each of render targets  stored in device memory  for a given frame. The dimensions may also include a depth or bits per pixel value for each of render targets . Large render targets defined for a given frame may indicate that the frame includes a complex graphics scene for rendering that may require many read-modify-write operations.","As another example, metric collection unit  may collect an amount of GPU load  on registers of GPU  during rendering of graphics data of a previous rendering unit. Metric collection unit  may also collect an amount of CPU load  on registers of CPU  during rendering of graphics data of a previous or current rendering unit. The load amounts of GPU  and CPU  may indicate where any performance bottlenecks may be occurring during rendering of the graphics data.","Metric collection unit  may also collect a number of vertices\/fragments  for a previous or current rendering unit from graphics application  executed on CPU . As stated above, the number of vertices and\/or fragments included in a given frame may be used to determine an amount of GPU bandwidth that will be required to render the graphics data of the frame. In addition, metric collection unit  may collect locations of fragments  in a previous or current rendering unit from graphics application  executed on CPU . The locations of the fragments  may indicate whether a large number of fragments is spread across the rendering unit in a simple graphics scene, or clustered in one area of the rendering unit as a complex graphics scene.","In a further example, metric collection unit  collects whether a previous or current rendering unit is depth test\/blending enabled  from graphics application  executed on CPU . When enabled and performed for a given rendering unit, the graphics operations of depth testing and pixel blending require many read-modify-write operations. In some cases, depth test\/blending enabled  may also indicate whether stencil testing is enabled.","Metric collection  also collects a type of application  executed on CPU  and\/or GPU  for a previous or current rendering unit. The type of application , i.e., graphics application , executed on CPU  and\/or GPU  may indicate a general level of complexity for the graphics scenes generated for rendering. In addition, metric collection unit  may collect a number of API calls , e.g., calls to draw primitives or triangles with the graphics data, for a previous or current rendering unit from graphics API  executed on CPU . When a given rendering unit includes a large number of API calls, it may be more likely that a large number of primitives will be re-drawn for multiple tiles in the deferred rendering mode.","Once the metrics are collected and stored in metric buffer , graphics driver  executes metric evaluation unit  to evaluate at least two of the metrics to predict which of the immediate rendering mode and the deferred rendering mode will use less power and\/or system bandwidth to render the graphics data of the current rendering unit. Metric evaluation unit  may apply a weighting scheme to the collected metrics stored in metric buffer . For example, metric evaluation unit  may execute an algorithm that assigns certain amounts of weight to two or more of the metrics. The weighting scheme may apply an equal amount of weight to two or more of the metrics, or may apply a different amount of weight to each of the metrics. In some cases, the weighting scheme algorithm may be pre-programmed into graphics driver . In other cases, the weighting scheme algorithm may be set by a developer via graphics API . In this way, the weighting scheme algorithm may be varied over time based on a type of graphics data to be rendered, system requirements and performance of CPU  and GPU , or other considerations.","As one specific example, metric evaluation unit  may apply the greatest weight to the metrics of GPU bandwidth  and number of render targets . In some cases, metric evaluation unit  may apply an equal amount of weight to GPU bandwidth  and number of render targets . In other cases, metric evaluation unit  may apply slightly more weight to one of GPU bandwidth  and number of render targets .","When GPU bandwidth  is high during rendering, it may indicate that rendering engine  of GPU  is performing a large number of read and\/or write requests to device memory , which is external to GPU . This may occur when rendering engine  is performing color blending or depth testing operations that require a large number of read-modify-write operations with device memory  in the immediate rendering mode. When the amount of GPU bandwidth  is high, therefore, it may be more efficient to switch to the deferred rendering mode to reduce the system bandwidth usage. In the deferred rendering mode, GPU  may perform the read and\/or write requests to tile buffer , located locally on GPU , using little power and no system bandwidth. In this way, the deferred rendering mode will likely reduce the amount of system bandwidth used by GPU  during rendering of graphics data for the current rendering unit.","The metric evaluation should not, however, rely solely on one metric. For example, merely relying on GPU bandwidth  fails to take into account the processing resources required to set up the tiling pass to divide the rendering unit into tiles and then separately render each tile. Instead, metric evaluation unit  may compare the bandwidth costs with the overhead costs for rendering graphics data in the current rendering unit to predict the most efficient rendering mode for use by GPU .","In order to determine the overhead costs, performance evaluation unit  may evaluate the number of render targets  defined for a current rendering unit. As described above, in order to render the frame, GPU  renders the graphics data within each of the render targets associated with the frame separately and then combines the rendered graphics data in frame buffer . When the number of render targets  defined for a given frame is high, a greater number of rendering passes is required to fully render the frame for display. When the number of render targets  is high, therefore, it may be more efficient to switch to the immediate rendering mode to reduce the overhead cost by eliminating the need to set up tiling passes for each render target and render each tile of each render target associated with the frame.","In the immediate rendering mode, GPU  may directly render graphics data in each render target associated with the frame to frame buffer  without performing a separate tiling pass and tile rendering for each render target. In this way, using the immediate rendering mode will likely reduce the amount of processing resources used by CPU  and\/or GPU  during rendering of graphics data for the current rendering unit.","When GPU bandwidth  is high and the number of render targets  is low, therefore, metric evaluation unit  may predict that the deferred rendering mode is the most efficient for the current rendering unit. As described above, the deferred rendering mode may use less power and system bandwidth to render graphics data of a rendering unit when the graphics data represents a complex graphics scene with pixel blending and depth testing that requires many read-modify-write functions. When GPU bandwidth  is high but the number of render targets  is low, the overhead cost of setting up a tiling pass and rendering a plurality of tiles for each render target does not override the bandwidth reduction of the deferred rendering mode.","On the other hand, when GPU bandwidth  is low and the number of render targets  is high, metric evaluation unit  may predict that the immediate rendering mode is the most efficient for the current rendering unit. As described above, the immediate rendering mode may use less power and system bandwidth to render graphics data of a rendering unit when the graphics data represents a simple graphics scene where the deferred rendering mode provides no bandwidth reduction but acts as a drain on processing resources. When GPU bandwidth  is low but the number of render targets  is high, the overhead cost of setting up a tiling pass and rendering a plurality of tiles for each render target overrides any bandwidth reduction of the deferred rendering mode.","In some cases it may not be immediately evident, based on GPU bandwidth  and the number of render targets , which rendering mode will use less power and\/or system bandwidth during rendering. For example, when GPU bandwidth  and the number of render targets  are both low or both high, it may be unclear whether the overhead cost of setting up the tiling passes and tile rendering for the deferred rendering mode will override the bandwidth reduction of the deferred rendering mode. In those cases, metric evaluation unit  may look to the next weighted metric to predict the most efficient rendering mode for the current rendering unit.","Metric evaluation unit  may then evaluate, for example, GPU load  and CPU load  to determine where any bottlenecks may be occurring during rendering. When CPU load  is high, it may indicate a bottleneck in CPU  due to additional overhead costs in graphics driver  with the deferred rendering mode. In this case, it may be more efficient to use the immediate rendering mode and shift more processing burden onto GPU . In other examples, performance evaluation unit  may evaluate the number of API calls  to determine a number of primitive or triangle draws for a rendering unit. When the number of API calls  is high, e.g., more than 2,000 calls per rendering unit, it may be more efficient to use the immediate rendering mode because the overhead cost of having to re-draw a large number of primitives for each tile of the rendering unit may override the bandwidth reduction of the deferred rendering mode.","Once the metrics are evaluated, graphics driver  executes rendering mode selection unit  to select the immediate rendering mode or the deferred rendering mode based on the evaluated metrics. More specifically, rendering mode selection unit  may select the rendering mode predicted by metric evaluation unit  to use less power and\/or system bandwidth to render the graphics data of the current rendering unit. Rendering mode selection unit  may then configure GPU  to operate according to the selected rendering mode to render graphics data of the current rendering unit. Configuring GPU  may comprise programming registers of GPU  to send the rendered graphics data output from rendering engine  directly to frame buffer , in the case of the immediate rendering mode, or to tile buffer , in the case of deferred rendering mode.","In some cases, rendering mode selection unit of graphics driver  may also receive a manually selected or indicated rendering mode from a developer or other user via graphics API . The manually selected rendering mode may override the automatically selected rendering mode. When a manually selected rendering mode is received, rendering mode selection unit  may configure GPU  to operate according to the manually selected rendering mode. In this way, a developer may be able to control the rendering mode used by GPU  regardless of which rendering mode is predicted to use less power and\/or system bandwidth during rendering.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 4","FIG. 2"],"b":["10","6","2","20","4","10","6","10","6"]},"The graphics data may comprise a plurality of rendering units. A rendering unit of the graphics data may include a set of frames, a frame, a portion of a frame, multiple render targets associated with a frame, a single render target associated with a frame, or a portion of a single render target. Graphics driver  may select a rendering mode for a current rendering unit at a rendering boundary when GPU  is switching from a previous rendering unit to the current rendering unit.","At a given rendering boundary, graphics driver  running on CPU  collects metrics associated with rendering graphics data of one or more rendering units (). Typically, graphics driver  collects metrics associated with rendering graphics data of a previous rendering unit from GPU  and collects metrics associated with rendering graphics data of the current rendering unit from CPU . Graphics driver  may then store the collected metrics in metric buffer . An exemplary operation of collecting metrics is described in more detail in .","Graphics driver  next evaluates at least two of the metrics using a weighting scheme (). In this way, graphics driver  may predict which of the immediate rendering mode and the deferred rendering mode will use less power and\/or system bandwidth to render the graphics data of the current rendering unit. For example, graphics driver  may apply a weighting scheme to at least the metrics of GPU bandwidth and a number of render targets defined for a frame. Graphics driver  may then evaluate whether the overhead costs associated with setting up the deferred rendering mode override the bandwidth reduction of the deferred rendering mode for the graphics data of the current rendering unit. An exemplary operation of evaluating metrics is described in more detail in .","Once the metrics are evaluated, graphics driver  automatically selects the immediate rendering mode or the deferred rendering mode based on the evaluation (). More specifically, rendering mode selection unit  may select the rendering mode predicted to use less power and\/or system bandwidth to render the graphics data of the current rendering unit.","In some cases, graphics driver  may also receive a manually selected rendering mode from a developer or other user via graphics API  (YES branch of ). The manually selected rendering mode received by graphics driver  may override the automatically selected rendering mode (). In this way, a developer may be able to control the rendering mode used by GPU  regardless of which rendering mode is predicted to use less power and\/or system bandwidth during rendering.","Regardless of whether the rendering mode is automatically selected based on evaluated metrics (NO branch of ) or manually selected by a user (YES branch of , ), graphics driver  configures GPU  to operate according to the selected rendering mode to render graphics data of the current rendering unit (). Configuring GPU  may comprise programming registers of GPU  to send the rendered graphics data output from rendering engine  directly to frame buffer , in the case of the immediate rendering mode, or to tile buffer , in the case of deferred rendering mode.","Graphics driver  may then provide graphics data of the current rendering unit to rendering engine  of GPU  configured to operate according to the selected rendering mode (). Until GPU  reaches a rendering boundary in the graphics data (NO branch of ), graphics driver  will continue to provide graphics data of the current rendering unit to rendering engine  of GPU  (). Once GPU  reaches a rendering boundary and switches from the current rendering unit to a subsequent rendering unit (YES branch of ), graphics driver  also switches to the subsequent rendering unit (). Graphics driver  then performs the automatic rendering mode selection process described above for the subsequent rendering unit.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIG. 5","FIG. 4","FIG. 3"],"b":["10","60","40","10","10","40","40","4","6"]},"Metric collection unit  may collect an amount of GPU bandwidth  used during rendering of a previous rendering unit from GPU performance counters  of GPU  (). In some cases, metric collection unit  may not collect information from GPU performance counters  at every rendering boundary. An amount of GPU bandwidth may then be determined based on a number of vertices\/fragments  for the previous or current rendering unit collected from graphics application  executed on CPU  (step  below). A large amount of bandwidth used by GPU  to render graphics data may indicate that GPU  is making a large number of read and\/or write requests to device memory .","Metric collection unit  may also collect a number of render targets  defined for a frame associated with a current rendering unit from graphics application  executed on CPU  (). The greater the number of render targets defined for a given frame, the greater the number of rendering passes required to fully render the frame for display. Metric collection unit  may collect dimensions of render targets  defined for a frame associated with a current rendering unit from graphics application  executed on CPU  (). The dimensions may comprise a height, width, and bits per pixel for each of render targets  stored in device memory  for a given frame. Large render targets defined for a given frame may indicate that the frame includes a complex graphics scene for rendering that may require many read-modify-write operations.","Metric collection unit  may collect an amount of GPU load  on registers of GPU  during rendering of a previous rendering unit (). Metric collection unit  may also collect an amount of CPU load  on registers of CPU  during rendering of a previous rendering unit (). The load amounts of GPU  and CPU  may indicate where any performance bottlenecks may be occurring during rendering of the graphics data.","Metric collection unit  may collect a number of vertices\/fragments  for a current rendering unit from graphics application  executed on CPU  (). As stated above, the number of vertices and\/or fragments included in the graphics data of a given rendering unit may be used to determine an amount of GPU bandwidth that will be required to render the graphics data of the rendering unit. Metric collection unit  may also collect locations of fragments  in a current rendering unit from graphics application  executed on CPU  (). The locations of the fragments may indicate whether a large number of fragments is spread across the rendering unit in a simple graphics scene, or clustered in one area of the rendering unit as a complex graphics scene.","Metric collection unit  may collect whether a current rendering unit is depth test\/blending enabled  from graphics application  executed on CPU  (). When enabled and performed for a given rendering unit, the graphics operations of depth testing and pixel blending require many read-modify-write operations. Metric collection  may also collect a type of application  executed on CPU  and\/or GPU  for a current rendering unit (). The type of application, i.e., graphics application , executed on CPU  and\/or GPU  may indicate a general level of complexity for the graphics scenes generated for rendering.","In addition, metric collection unit  may collect a number of API calls , e.g., calls to draw primitives or triangles with the graphics data, for a previous or current rendering unit from graphics API  executed on CPU  (). When a given rendering unit includes a large number of API calls, it may be more likely that a large number of primitives will need to be re-drawn for multiple tiles in the deferred rendering mode. Metric collection unit  of graphics driver  may then store the collected metrics in metric buffer .",{"@attributes":{"id":"p-0097","num":"0096"},"figref":["FIG. 6","FIG. 4","FIG. 3"],"b":["10","62","42","10","24","10","42"]},"Metric evaluation unit  applies a weighting scheme to the collected metrics stored in metric buffer  (). For example, metric evaluation unit  may execute an algorithm that assigns certain amounts of weight to two or more of the metrics. In the illustrated example operation, metric evaluation  applies the greatest weight to the metrics of GPU bandwidth  and number of render targets  ().","When GPU bandwidth  is high and the number of render targets  is low (YES branch of ), metric evaluation unit  may predict that the deferred rendering mode is the most efficient for the current rendering unit (). As described above, the deferred rendering mode may use less system bandwidth and power to render graphics data of a rendering unit when the graphics data represents a complex graphics scene with pixel blending and depth testing that requires many read-modify-write functions. When GPU bandwidth  is high but the number of render targets  is low, the overhead cost of setting up a tiling pass and rendering a plurality of tiles for each render target does not override the bandwidth reduction of the deferred rendering mode.","When GPU bandwidth  is low and the number of render targets  is high (NO branch of  & YES branch of ), metric evaluation unit  may predict that the immediate rendering mode is the most efficient for the current rendering unit (). As described above, the immediate rendering mode may use less system bandwidth and power to render graphics data of a rendering unit when the graphics data represents a simple graphics scene where the deferred rendering mode provides no bandwidth reduction but acts as a drain on processing resources. When GPU bandwidth  is low but the number of render targets  is high, the overhead cost of setting up a tiling pass and rendering a plurality of tiles for each render target overrides any bandwidth reduction of the deferred rendering mode.","When GPU bandwidth  is low and the number of render targets  is also low, or when GPU bandwidth  is high and the number of render targets  is also high (NO branch of  & NO branch of ), metric evaluation unit  may look to the next weighted metric to predict the most efficient rendering mode for the current rendering unit (). For example, when GPU bandwidth  and the number of render targets  are both low or both high, it may be unclear whether the overhead cost of setting up the tiling passes and tile rendering for the deferred rendering mode will override the bandwidth reduction of the deferred rendering mode. In this case, any additional weighted metrics may be used when it is not immediately evident, based on GPU bandwidth  and the number of render targets , which rendering mode will use less system bandwidth and\/or power during rendering.","The illustrated flowchart of  is merely one example of evaluating metrics using a weighting scheme. In other examples, different amounts of weight may be applied to different metrics. For example, two or more other metrics may be given the greatest weight for predicting the most efficient rendering mode, or all the metrics may be given equal weight. In still other examples, a different evaluation scheme may be used for predicting the most efficient rendering mode.","In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions or operations may be stored as one or more instructions or code on a non-transitory computer-readable medium and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and\/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.","By way of example, and not limitation, such computer-readable media can comprise non-transitory media such as RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transient media, but are instead directed to non-transient, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.","Instructions may be executed by one or more processors, such as one or more DSPs, general purpose microprocessors, ASICs, FPGAs, or other equivalent integrated or discrete logic circuitry. Accordingly, the term \u201cprocessor,\u201d as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and\/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.","The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and\/or firmware.","Various examples have been described. These and other examples are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
