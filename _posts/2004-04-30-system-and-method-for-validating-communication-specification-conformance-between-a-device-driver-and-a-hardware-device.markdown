---
title: System and method for validating communication specification conformance between a device driver and a hardware device
abstract: A system and method for validating whether communications between a device driver and a hardware device conform to a communication specification is presented. A validation module obtains a communication specification identifying rules for validating whether communications between a device driver and a hardware device conform to the specification. A redirection module redirects communications between the device driver and the hardware device to the validation module. Based on an individual communication, as well as the context in which an individual communication is made, the validation module validates whether the communication conforms to the communication specification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07810103&OS=07810103&RS=07810103
owner: Microsoft Corporation
number: 07810103
owner_city: Redmond
owner_country: US
publication_date: 20040430
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to computer hardware and software, and more particularly, to a system and method for validating communication specification conformance between a device driver and a hardware device.","After connecting or installing a hardware device to a computer, there is a user expectation that the hardware device will work, i.e., that the computer will properly recognize, communicate and operate with the hardware device, and that through the computer, a user will be able to utilize that hardware device. Unfortunately, quite frequently, after a user has apparently connected or installed the hardware device to the computer, the computer and hardware device fail to communicate and\/or inter-operate. In such circumstances, it is very difficult to determine the exact nature or source of the failure. For example, the failure may lie in an operating system problem, in faulty software for communicating with the hardware device, or in improper installation. In any event, the user is left to try to isolate the problem and rectify the situation.","Even after a hardware device is apparently installed and operating on a computer, it is not uncommon that the hardware device operates at less than its advertised or optimal performance, or that some features or aspects associated with the hardware device fail to operate entirely. Again, the user must determine whether the software that interfaces with the hardware device is faulty, whether the hardware device itself is faulty, whether the user incorrectly installed the device, or whether the operating system is at fault.","When faced with these problems, a user may refer to operator manuals for the hardware device and\/or for the operating system, call a support service, check on the provider's Internet site, consult with user groups, and the like. However, a user is often unable to secure proper assistance because the user is unable to identify the exact source of the problem. As such, the user will frequently turn to the most visible and\/or accessible information source, either an operating system provider or a hardware provider.","Operating system providers are a frequent, yet incorrect, target of dissatisfied users for various reasons, including the widespread use of the operating system, the fact that the operating system is a common denominator to the problem, and also, that the operating system provider often bundles device drivers for various hardware devices with its operating system, primarily for user convenience. For purposes of the present discussion, and as those skilled in the art will recognize, a device driver is a body of computer code that, when installed on a computer, acts as the interface for a specific hardware device for the operating system. In other words, device drivers represent the hardware\/software interface between the operating system and the hardware device.","As one example of how operating system providers often bundle device drivers on deliverable media with their operating system, the distributable media for the most recent version of Microsoft Corporation's Windows\u00ae operating system includes bundled device drivers for approximately 10,000 different hardware devices! However, while an operating system provider, such as Microsoft Corporation, distributes or bundles numerous device drivers for user convenience, most device drivers are not actually written by the operating system provider. In fact, most device drivers are actually written by the corresponding hardware device provider, and submitted to the operating system provider for distribution purposes. This distribution mechanism also explains why hardware device providers offer updated device drivers: to correct \u201cissues\u201d with an earlier version of the device driver that was distributed by the operating system provider.","In spite of the fact that the operating system provider does not actually write the device drivers, because they distribute the device drivers, to a user it appears that the device drivers are \u201cfrom\u201d the operating system provider, and the dissatisfied user calls the operating system provider when a problem arises. Thus, it behooves an operating system provider to determine that a hardware device operates at a minimum level of compatibility with a computer running its operating system prior to bundling a device driver on its distribution media.","One area where the operating system provider looks to determine whether a hardware device (with its corresponding device driver) is compatible with a computer system is the communication between the hardware device and the device driver. Those skilled in the art will readily appreciate that in order for a hardware device to properly function on a computer system, the hardware device must communicate with the computing system, particularly with the operating system, according to some predetermined communication protocol. The device drivers, as the interface between the operating system and the hardware device, encapsulate this communication protocol. The communication protocol is almost always memorialized in a so-called communication specification.","The communication protocol may conform to a public communication specification, or alternatively, be implemented as a private communication specification. Examples of public communication specifications include the Universal Serial Bus (USB) specification and the IEEE 1394 specification (also referred to as Firewire). Private communication specifications are simply non-public communication protocols that are encapsulated in corresponding device drivers. Hybrid communication specifications, i.e., a combination of both public and private communication specifications, are also sometimes used. However, irrespective of whether a specification is a public or private communication specification, the communication protocol represented by the specification represents a set of rules by which a device driver and a hardware device should abide in order to properly communicate. Failure to follow those rules can result in computer system\/hardware incompatibilities, reduced or failed hardware performance, irreparable damage to the hardware device's firmware, operating system failures, and the like.","Testing whether the communications between a device driver and a hardware device conform to an established specification is currently a difficult process. In addition to the sheer number of hardware devices available, according to current practices, in order to evaluate the communication between a device driver and a hardware device, one must locate and\/or identify the communication stream as it flows between the device driver and the hardware device. Frequently, these communications may take place over system interrupts, register reads and writes, system port reads and writes, through shared memory blocks, and the like. One trying to locate the communications between a device driver and a hardware device must be well versed in monitoring a myriad of \u201cevents\u201d occurring on a computer system, and filter out events and the like that are not related to the monitored communications. In addition to \u201cmerely\u201d identifying the communications, in order to validate whether a device driver and hardware device communicate according to a communication specification, one must also evaluate the communications with respect to the rules established by communication specification. Clearly, determining, or validating, whether communications between a device driver and a hardware device conform to a specification is a complex task, often overlooked by operating system providers.","In an effort to address a more general task of determining whether a hardware device is compatible with a computer system, a system and method has been proposed to simulate or emulate an actual hardware device with software, and to provide an automated testing environment to determine the device's compatibility with the operating system. This system and method, set forth in commonly assigned and U.S. Pat. No. 7,181,382, entitled System and Method for Testing, Simulating, and Controlling Computer Software and Hardware, is incorporated herein by reference. According to this novel approach for determining whether a hardware device is compatible with a computer system, a particular hardware device is emulated in software. Communications from a device driver written for the hardware device are intercepted and may be redirected to the emulated hardware device. Similarly, the emulated hardware device responds with information as would an actual hardware device, and those communications are routed to the device driver.","While the above-incorporated reference includes a system that intercepts and redirects the communications between a device driver and a hardware device, it is not adapted to evaluate the communications themselves, and in particular, to determine whether the communications conform to a predetermined communication specification.","In light of the above-described issues relating to hardware compatibility with computing devices, and more particularly relating to validating whether a device driver and hardware device communicate according to an established specification, a need exists for a system and method for validating whether communications between a hardware device and a device driver conform to a specification. The present invention addresses these and other issues relating to the prior art.","In accordance with aspects of the present invention, a computer system for validating whether communications between a device driver and a hardware device conform to a predetermined communication specification is presented. The computer system includes a validation module that validates whether communications that occur between a device driver and a hardware device conform to the communication specification. The computer system also includes a redirection module. The redirection module intercepts communications that occur between the device driver and the hardware device and forwards them to the validation module for validating whether they conform to the communication specification.","In accordance with additional aspects of the present invention, a method, implemented on a computer system, for validating whether communications between a device driver and a hardware device conform to a communication specification is presented. A validation module obtains rules for validating whether communications between a device driver and a hardware device conform to a communication specification. The communications between the device driver and a hardware device are intercepted and redirected to the validation module. As communications occur between the device driver and the hardware device, each communication is examined with respect to the obtained rules to validate whether the communication conforms to the communication specification.","In accordance with yet further additional aspects of the present invention, a computer-readable medium bearing computer-executable instructions is presented. When the computer-executable instructions are executed, they carry out a method for validating whether communications between a device driver and a hardware device conform to a communication specification comprising the following steps. A validation module obtains rules for validating whether communications between a device driver and a hardware device conform to a communication specification. The communications between the device driver and a hardware device are intercepted and redirected to the validation module. As communications occur between the device driver and the hardware device, each communication is examined with respect to the obtained rules to validate whether the communication conforms to the communication specification.","While the present invention is described in terms of operating on a personal computer running an operating system, such as Microsoft Corporation's Windows\u00ae operating system, it should be appreciated that this is for illustration purposes only, and should not be construed as limiting upon the present invention. For example, the present invention may be suitably implemented on any number of computing devices, including personal computers, tablet computers, mini and mainframe computers, personal digital assistants (PDAs), and the like. Furthermore, while individual operating systems have specific implementation details for defining the software\/hardware communication paradigm, the general principles described below, specifically a device driver communicating with a hardware device, are generally found in most operating systems, including UNIX, Linux and Apple\u00ae operating systems. As such, the present invention may be advantageously implemented on numerous operating systems.","As mentioned above,  is a block diagram illustrating exemplary components, including operating system components, installed on a computer system for illustrating how an application, operating in user mode, communicates with a hardware device via a device driver operating in kernel mode, as found in the prior art. Those skilled in the art will appreciate that an operating system  has many modes in which software applications and\/or program modules may execute. As shown in , the illustrated operating system  comprises two modes in which software applications may execute: a user mode , and a kernel mode . While the present discussion uses the term \u201capplication\u201d to describe a collection of computer-executable instructions, it should be understood that \u201capplication\u201d is a generic term to describe a collection of executable instructions, and is not directed to any particular collection of instructions. For example, an \u201capplication\u201d may refer to an executable program installed on the computer, to an interpretable script, services, library modules, and the like.","Software applications operating in user mode, often referred to as user mode applications, operate in a less privileged area of the operating system. Examples of user mode applications include word processing programs, spreadsheets, games, e-mail readers, and the like. Most user mode applications gain access to operating system functions via a well defined, secure set of functions and programs, commonly referred to as operating system application programming interfaces (APIs). Alternatively, software applications that operate in the kernel mode , often referred to as kernel mode applications, have access to and operate in a more privileged area of the operating system. Device drivers, such as device driver , are one example of kernel mode applications.","Due to the distinct operating modes in an operating system, there are limits to the type of interaction that may occur between two components operating in the different modes. More particularly, in order for application , operating in user mode , to communicate with a hardware device  through a device driver  operating in the kernel address space , a special communication channel  is provided. This communication channel comprises a user mode portion and a kernel mode portion. As shown in , the user mode portion includes the operating system APIs . The operating system APIs  are specially designed to communicate with their kernel mode counterpart, operating system services . The operating system services , operating in kernel mode, are able to directly communicate with various kernel mode components, including device driver .","While the device driver  represents the software\/hardware interface between the operating system and the hardware device, according to various operating system implementations, the device driver uses a generic, hardware abstraction layer (HAL)  for communicating with hardware devices, such as hardware device . The HAL  provides a standardized tool for device drivers to read and write information to and from the hardware device, but the device drivers, such as device driver , encapsulate the knowledge, such as the communication protocol, of how to use the HAL to carry out desired communications with a hardware device .","As an example of how the components of  operate together, assuming that hardware device  is a particular type of storage device, and further assuming that application  wishes to write data to the hardware device , the flow of information is as follows. Application  makes a call to one of the operating system APIs  to write some date to the hardware device . The called operating system APIs  communicate with the corresponding operating system services , operating in the kernel mode , for writing data to the hardware device . The operating system services  identify the appropriate device driver  associated with the hardware device  and forward the write request to the device driver. The device driver , according to its encapsulated communication protocol, issues commands to the hardware device  via the HAL . Status information, indicating the success or failure of the write, is likely returned to the application  through the components described above in their reverse order. Similarly, if the application  requests to read information from the hardware device , the application calls corresponding operating system APIs , which in turn issue read commands to the operating system services . The operating system services  forward the read request to the device driver , which reads the information from the hardware device  via the HAL . The read information is then returned from the device driver  to the operating system services , and returned to the application  as a response to the read request to the operating system APIs .","As previously mentioned, in the environment described above in regard to , it is very difficult to determine whether communications between the device driver  and the hardware device  conform to their predetermined specification, due, at least in part, to the difficulty in identifying the actual communications between the device driver and hardware device. The above mentioned reference, U.S. Pat. No. 7,181,382, entitled System and Method for Testing, Simulating, and Controlling Computer Software and Hardware, which is incorporated herein by reference, discloses, among other things, a novel approach for identifying and redirecting the communications between the device driver  and the hardware device . By utilizing the concept of intercepting and redirecting communications between a device driver  and a hardware device , irrespective of whether a HAL  is also present, the present invention is able to validate whether these communications conform to a predetermined communication specification.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","116","120","200","104","106","112","114","118"]},"Unlike the components of , communications between a device driver  and the hardware device , irrespective of whether a HAL  is used, are redirected to\/by a redirection module . More particularly, according to the present invention, the redirection module  intercepts communications between a device driver  and a corresponding hardware device . Upon intercepting a communication between the device driver  and hardware device , the redirection module  forwards the intercepted communication to a validation module . In addition to forwarding the intercepted\/redirected communication to the validation module , the redirection module  completes the communication by forwarding the communication to its intended destination, i.e., either the device driver  or hardware device  via the HAL .","While the present discussion with regard to redirecting a communication between a device driver  and hardware device  would indicate that after the communication is intercepted it is first forwarded to the validation module , and subsequently, after the validation module  has completed its analysis of the communication, the communication is then forwarded to its intended destination (i.e., either the device driver or hardware device), it is to be viewed as illustrative only, and should not be construed as limiting upon the present invention. As one alternative to that described above, the redirection module  may first forward the communication to the intended destination and then forward a copy to the validation module . As another alternative, the redirection module  may simultaneously forward the intercepted communication to its intended destination and to the validation module . As yet another alternative, the redirection module  forwards the intercepted communication to the validation module  and only forwards the communication to the intended destination at the request of the validation module, thus giving control over the communications to the validation module. Accordingly, it should be appreciated that redirecting communications to the validation module  and forwarding the communications to their intended destination is not limited to any particular sequence of events or routes.","While  illustrates that only one redirection module  is used to intercept and redirect communications between a device driver  and a corresponding hardware device , according to an actual embodiment of the invention, a plurality of redirection modules  may be used in order to intercept and redirect the communications between the device driver and corresponding hardware device. As described above, communication between a device driver  and hardware device  may be effectuated in a variety of manners. Accordingly, a plurality of redirection modules may be used where each redirection module corresponds to a particular communication means available to the device driver  and hardware device . For example, one redirection module may intercept communications between the device driver  and hardware device  via reads and writes on the host computer system's ports, while another redirection module may intercept communications using reads and writes on the computer system's registers. Other redirection modules may correspond to communications delivered via computer system interrupts, shared memory access, direct memory access, and the like. Thus, while the present discussion of  is made in terms of a single redirection module , it should be viewed as illustrative, and not construed as limiting upon the present invention.","The validation module  evaluates the intercepted communications, received from the redirection module , to validate whether they conform to a predetermined communication specification. According to aspects of the present invention, the validation module  evaluates\/validates individual communications as well as the context of the communications. For example, in regard to individual communications, the validation module  examines the format and\/or content of the communication to determine whether it is formed according to the predetermined communication specification. In regard to the context of the communications, individual communications, especially response communications, are often constrained by communications that previously occurred. As an example to illustrate context\/constraints, a communication specification may require that if a properly formed communication A is sent from the device driver  to the hardware device , then the hardware device must respond with a communication B, via the computer system's port C, having the third bit of the value at port C set to one, all within twenty milliseconds of receiving communication A. The validation module  is programmed to evaluate all of the rules, formats, and constraints associated with a particular communication specification.","The validation module  is preferably a generic validation tool. As a generic validation tool, the validation module  validates communications between any device driver and hardware device pair according to a supplied communication specification associated with the device driver\/hardware device pair. In one embodiment, the validation module  receives the communication specification associated with the device driver\/hardware device pair from a compliance validation application . According to aspects of the present invention, using the compliance validation application , a user is able to identify the targeted device driver\/hardware device pair whose communications are to be evaluated, supply a communication specification to the validation module , as well as initiate and terminate the validation process. Upon termination of the validation process, the validation module  may generate a report reflecting the compliance level of the communications between the device driver  and the hardware device .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 2"],"b":["204","104","204","104","204","206","206","208","210","204","208","104","208","210","202","206","112","202"]},"In order for the validation module  to be a general purpose validation module, i.e., one that validates communications between a device driver  and a corresponding hardware device  according to a supplied communication specification, the requirements of a communication specification must be distilled into rules that can be validated by the validation module, and encoded in a specific format such that the validation module can parse the rules of the communication specification and interpret those rules in terms of the device driver\/hardware device communications. The following table, Table A, represents a subset of rules that may correspond to a particular communication specification. For interpretation purposes, italicized letters in the following table, such as \u201cn\u201d and \u201cm\u201d, represent numeric values, and value or words separated by a \u201c\/\u201d, such as \u201c0\/1\u201d or \u201cregister\/port\u201d, indicate a selection of one of the two tokens listed.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE A"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["1","Rules for Register or Port Writes"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1.1","Data may have bit = 1\/0"]},{"entry":[{},"1.2","Data cannot have bit = 1\/0"]},{"entry":[{},"1.3","If bit = 1\/0, the = 1\/0"]},{"entry":[{},"1.4","If bit = 1\/0, then bit = 1\/0 in register\/port "]},{"entry":[{},"1.5","If bit = 1\/0, then bit in register\/port must be set to"]},{"entry":[{},{},"1\/0 within milliseconds"]},{"entry":[{},"1.6","Register\/port must be read only"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["2","Rules for Shared Memory Writes"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2.1","Data at offset may have bit = 1\/0"]},{"entry":[{},"2.2","Data at offset cannot have bit = 1\/0"]},{"entry":[{},"2.3","If bit = 1\/0 of data at offset , then = 1\/0"]},{"entry":[{},"2.4","If bit = 1\/0 of data at offset , then bit = 1\/0 in register\/port "]},{"entry":[{},"2.5","If bit = 1\/0, then bit in register\/port must be set to"]},{"entry":[{},{},"1\/0 within milliseconds"]},{"entry":[{},"2.6","Data at offset must be read only"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["3","Rules for Resource Usage"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.1","Device cannot use interrupts"]},{"entry":[{},"3.2","Device uses interrupt "]},{"entry":[{},"3.3","Device cannot use ports"]},{"entry":[{},"3.4","Device uses port "]},{"entry":[{},"3.5","Device cannot use registers"]},{"entry":[{},"3.6","Device uses register "]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"According to one embodiment of the present invention, the rules of a communication specification are encoded in an extensible markup language (XML) file according to an XML schema understood by the validation module  for delivery to the validation module. Tables B and C below illustrate segments of an XML file showing specific encoded rules. In particular, Table B illustrates a specific encoding of rule 1.2, and Table C illustrates a specific encoding of rule 2.5.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<RULE Name = \u201cRule00\u201d>"]},{"entry":[{},"<!-- Register at offset 0x1234ABCD cannot have bit 3 set to 0 -->"]},{"entry":[{},"\u2003\u2003<TYPE>register<\/TYPE>"]},{"entry":[{},"\u2003\u2003<DATA>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<OFFSET>1234ABCD<\/OFFSET>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<DEPENDENCY>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<TYPE>data<\/TYPE>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<DEPDATA>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<VALUE16>xxxxxxxxxxxx0xxx<\/VALUE16>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<RELATION>false<\/RELATION>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<\/DEPDATA>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/DEPENDENCY>"]},{"entry":[{},"\u2003\u2003<\/DATA>"]},{"entry":[{},"<\/RULE>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE C"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<RULE Name = \u201cRule04\u201d>"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<!--","If register at offset 0x1234ABCD has bit 5 set to 1, then bit 3 of"]},{"entry":[{},"port at offset 0xABCD1234 must be set to 0 within 100"]},{"entry":[{},"milliseconds"]},{"entry":"-->"},{"entry":[{},"<TYPE>register<\/TYPE>"]},{"entry":[{},"<DATA>"]},{"entry":[{},"\u2003\u2003<DIRECTION>write<\/DIRECTION>"]},{"entry":[{},"\u2003\u2003<OFFSET>1234ABCD<\/OFFSET>"]},{"entry":[{},"\u2003\u2003<VALUE16>xxxxxxxxxx1xxxxx<\/VALUE16>"]},{"entry":[{},"\u2003\u2003<DEPENDENCY>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<TYPE>timing<\/TYPE>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<DEPTIMING>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<TYPE>port<\/TYPE>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<OFFSET>ABCD1234<\/OFFSET>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<VALUE16>xxxxxxxxxxxx0xxx<\/VALUE16>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<TIME>100<TIME>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<RELATION>true<\/RELATION>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/DEPTIME>"]},{"entry":[{},"\u2003\u2003<\/DEPENDENCY>"]},{"entry":[{},"<\/DATA>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/RULE>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"While the compliance validation application  typically delivers the communication specification to the validation module  and initiates the validation process, the compliance validation application does not necessarily drive the communications between the device driver  and the hardware device . The compliance validation application  could drive the communications between the device driver  and hardware device , either by making calls on the operating system APIs  that would cause communications between the device driver and hardware device to occur, or by initiating the communications via directive delivered through the validation module  to the device driver via the redirection module . Preferably, however, a separate application for driving the communications is used. For example, application  could be a test application used to initiate communications between the device driver  and the hardware device .","It should be noted that while the present invention has been discussed in regard to validating communications between a device driver  and a hardware device , according to an alternative embodiment, the present invention may alternatively be used to validate communications between a device driver and an emulated hardware device, such as emulated hardware device , rather than an actual hardware device. Additionally, while  illustrates that the exemplary device driver  resides in kernel mode , it is illustrative only and should not be construed as limiting upon the present invention. Still further, the present invention may be used to validate communications between a device driver and a non-emulated device, i.e., a \u201cdevice\u201d that is implemented simply as a software device. For example, a voice over IP (VoIP) connection is frequently treated as a \u201cdevice\u201d by a computer system, yet is implemented on the computer system entirely in software and is not an emulation of an actual hardware device.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3","FIG. 2"],"b":["300","200","116","120","302","120","116","304","116","120","202","306","212","116","120","202"]},"At delay block , after having initialized the redirection module , the routine  monitors for communications between the device driver  and hardware device . Additionally at delay block , the routine  monitors for an indication that the exemplary validation routine is to terminate. Thus, after detecting either a communication or an indication to terminate, at decision block , a determination is made as to whether the routine  is to terminate validating the communications between the device driver  and hardware device . If there was not an indication that the routine  is to terminate, at decision block , another determination is made as to whether the detected communication conforms to the communication specification previously downloaded to the validation module .","If the communication does not conform to the communication specification, at block  a record of the non-conformance is made. Thereafter, or if the communication conforms to the communication specification, at block , the communication is forwarded to its intended destination, i.e., either the device driver  or the hardware device . After forwarding the communication to its intended destination, the routine  returns again to delay block  awaiting subsequent communications or an indication to terminate.","The routine  continues to validate the communications between the device driver and hardware device  until, at decision block , it is determined that an indication to terminate was received. Thereafter, at block , the exemplary routine  reports the non-conformance log and then terminates.","While various embodiments of the present invention have been illustrated and described, including the preferred embodiment, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 2"]}]},"DETDESC":[{},{}]}
