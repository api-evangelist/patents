---
title: Method and system for managing tables that are used by network processors to control traffic through a network
abstract: A method for managing tables that are used by network processors to control network traffic through a network. The method comprises including a first table management software application in a first network processor, in which the first table management software is dedicated to managing only tables associated with the first network processor; including a second table management software application in a second network processor, in which the second table management software application is dedicated to managing only tables associated with the second network processor; and including a table management control application in a host processor, in which the table management control application is configured to respectively manage the tables associated with the first network processor and the tables associated with the second network processor through the first table management software application and the second table management software application through a plurality of generic application programming interfaces (APIs).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865912&OS=07865912&RS=07865912
owner: International Business Machines Corporation
number: 07865912
owner_city: Armonk
owner_country: US
publication_date: 20071119
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of application Ser. No. 10\/706,232, filed Nov. 12, 2003, now U.S. Pat. No. 7,325,239, the entire contents of which are incorporated by reference herein.","The present invention relates to computer systems, and more particularly to a method and system for providing a mechanism for allowing a host to manage tables, such as lookup tables, in a scalable, flexible manner.","Driven by increasing usage of a variety of network applications, such as those involving the Internet, computer networks are of increasing interest. In order to couple portions of a network together or to couple networks together, network processors residing in switches, routers, and\/or other components are typically used. In order to adequately control the traffic through the network, the network processor must classify packets and perform other functions that use tables, such as lookup tables. In order to use these tables, the properties of the tables are managed. For example, size, the data structure and corresponding speed, the location (memory selected), the insertion of entries in the tables, and certain relationships between tables are controlled. Thus, a network administrator typically desires to manage the properties of the tables being used by the network processors.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1","b":["10","10","12","30","40","50","10","22","10","22","30","40","50","10"]},"The conventional network processors , , and  are typically purchased by the owner of the conventional system . The conventional network processors , , and  each includes conventional software and\/or firmware , , and , respectively, that are used in managing the tables (not explicitly shown). In addition, the conventional software and\/or firmware , , and  may be different. For example, the conventional network processors , , and  may include different versions of a particular model of network processor from a particular vendor and\/or other model(s) of network processor that may be from other vendors. Thus, the conventional network processors  and  are depicted as having software and\/or firmware  and  that are different versions of a Model X network processor, while the software and\/or firmware  of the conventional network processor  is a Model Y network processor. Because the conventional network processors , , and  are designed to communicate with different control applications, each conventional network processor , , and  utilizes conventional application program interfaces (APIs) , , and , respectively, that are specific to the particular software and\/or firmware , , and , respectively.","The conventional table management application  is used to manage the tables used by the conventional network processors , , and , respectively. The conventional table management application  thus includes a corresponding set of conventional behaviors , , and  for each set of the conventional APIs , , and , respectively. The conventional APIs , , and  are designed to communicate with the conventional behaviors , , and , respectively. The conventional APIs , , and  are also used to control the corresponding software and\/or firmware , , and , respectively. Thus, using the conventional behaviors , , and  corresponding to the conventional APIs , , and , respectively, the conventional table management application  can control the tables for the conventional network processors , , and , respectively.","Although the conventional system  functions, one of ordinary skill in the art will readily recognize that the conventional system is difficult to scale and may have high maintenance costs. The conventional network processors , , and  are typically heterogeneous in nature. Because the conventional network processors , , and  are heterogeneous, the conventional network processors may include different versions of a particular model of network processor and\/or different models of network processor. In addition, the way in which particular tables are used in each conventional network processor , , and  may differ widely. Thus, the software and\/or firmware , , and  of different network processors typically differ. The APIs , , and  thus also differ. Consequently, the corresponding behaviors , , and  of the conventional table management application  are distinct. One of ordinary skill in the art will also readily recognize that the conventional system  may actually include a large number of network processors. Consequently, the number of conventional APIs , , and  with which the conventional table management application  must be compatible may be large. As a result, the number of distinct conventional behaviors used by the conventional host processor  and developed by the owner of the conventional system , such as the conventional behaviors , , and , may be large. As a result, the conventional table management application  may be complex and include an amalgamation of a variety of behaviors, one for each model and\/or version of conventional network processor. It may thus be difficult to incorporate new network processors, which may have software and\/or firmware and thus APIs not previously supported. The conventional system  is, therefore, difficult to scale. Because of difficulties in incorporating new software and\/or firmware and their corresponding APIs, evolving the conventional table management application  and, therefore, the conventional system  to utilize improved network processors may be problematic. Furthermore, because supporting a variety of conventional behaviors , , and  makes the conventional table management application  more complex, the conventional system  may be subject to higher maintenance costs.","Accordingly, what is needed is a system and method for allowing a host to manage tables used by a network processor in a scalable, flexible manner. The present invention addresses such a need.","The present invention provides a method and system for managing a plurality of tables for a plurality of heterogeneous network processors in a network. The network also includes at least one host processor that utilizes at least one table management application. The method and system comprise providing a plurality of generic application program interfaces (APIs). The generic APIs communicate with the control application(s) and the heterogeneous network processors. The generic APIs communicate with the table management application(s) in a network processor independent manner, but manage the tables for the heterogeneous network processors in a network processor specific manner. Thus, the generic APIs allow the control application(s) to be network processor independent and to manage the tables for the heterogeneous network processors in the network processor specific manner.","According to the system and method disclosed herein, the present invention provides a generic mechanism for managing the tables for network processors. As a result, a customer need not maintain a table management application having different sets of API for different types (e.g. models and\/or versions) of network processors.","The details of one or more implementations are set forth in the accompanying drawings and the description below. Features and advantages will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","The present invention relates to an improvement in computer system. The following description is presented to enable one of ordinary skill in the art to make and use the invention and is provided in the context of a patent application and its requirements. The present invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features described herein.","The present invention provides a method and system for managing a plurality of tables for a plurality of heterogeneous network processors in a network. The network also includes at least one host processor that utilizes at least one table management application. The method and system comprise providing a plurality of generic application program interfaces (APIs). The generic APIs communicate with the control application(s) and the heterogeneous network processors. The generic APIs communicate with the table management application(s) in a network processor independent manner, but manage the tables for the heterogeneous network processors in a network processor specific manner. Thus, the generic APIs allow the control application(s) to be network processor independent and to manage the tables for the heterogeneous network processors in the network processor specific manner.","The present invention will be described in terms of a particular computer system, a particular network processor, and certain APIs. However, one of ordinary skill in the art will readily recognize that this method and system will operate effectively for other computer system and network processors, as well as additional and\/or other APIs. The present invention is also described in the context of a network including specific components and a particular number of components. However, one of ordinary skill in the art will readily recognize that the present invention is consistent with other networks containing other and\/or additional components as well as another number of components. The present invention is also described in the context of particular types of tables. One of ordinary skill in the art will readily recognize that the method and system are consistent with other types of tables.","To more particularly illustrate the method and system in accordance with the present invention, refer now to , depicting one embodiment of a system  in accordance with the present invention for managing tables (not shown) for network processors. The system  is depicted as including a host processor  and network processors , , and . The host processor  includes a table management application . The network processors , , and  include table management software and\/or firmware , , and , respectively. However, one of ordinary skill in the art will readily recognize that the generic APIs  are of particular utility. In addition, the generic APIs  are depicted as a separate entity. However, one of ordinary skill in the art will readily recognize that the host processor  and network processors , , and  utilize the generic APIs  for communication and control.","The network processors , , and  are capable of being heterogeneous. Thus, the network processors , , and  may have hardware, software, and\/or firmware for managing tables that differ significantly. For example, as depicted in , the software and\/or firmware  for the network processor  is Model X, Version 1.0. In contrast, the network processor  includes software and\/or firmware  that is Model X, Version 2.0. The network processor  is a completely different model, having software and\/or firmware  that is Model Y, Version 1.0. Other network processors (not shown) having different models and\/or versions may also be included. Because they are heterogeneous, in the absence of the present invention, the network processors , , and  would each require a separate network processor specific set of APIs in order to be controlled by a conventional table management application, such as the conventional table management application  depicted in .","Referring back to , the generic APIs  include APIs are used by the table management application  and the network processors , , and . In particular, the generic APIs communicate with and are used by the table management application  in a network processor independent manner. In other words, the table management application  is network processor independent. In the context of the present application, a network processor independent manner means that the table management application  need not contain knowledge of the specific hardware, software, and\/or firmware , , and  of any of the network processors , , and , respectively, for which tables are being managed. At the same time, the table management application  can control the tables for the network processors , , and  by managing the software and\/or firmware , , and , respectively. Because the table management application  is network processor independent, the table management application  can control, such as configuring and updating, the tables for the network processors , , and  without requiring specific knowledge of the hardware or software and\/or firmware , , and , respectively of the individual network processors , , and , respectively.","The generic APIs  also communicate with and control the network processors , , and  in a network processor specific manner. In the context of the present application, network processor specific includes a knowledge of the specifics of a particular network processor, such as the hardware, software and\/or firmware , , and , and possibly other components used by the particular network processor , , and , respectively. Thus, the APIs  allow the table management application  to be network processor independent while allowing each of the network processors , , and  to be control in a network processor specific manner.","Using the system , and more particularly the generic APIs , the table management application  can be network processor independent. Because of the use of the generic APIs, the table management application  can still control the tables for the potentially heterogeneous network processors , , and  in a network processor specific manner. As a result, the table management application  need not include a separate set of APIs for each type of network processor , , and  used. The table management application  is, therefore, simpler. As a result, it is significantly simpler to scale the system , including adding new types of network processors. It is thus also easier to improve the performance of the system  by adding improved network processors. In addition, the maintenance costs of the system  may be reduced due to the use of a simpler table management application .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 3","FIG. 2","FIGS. 2 and 3"],"b":["200","200","100","200","150","112","150","120","130","140","122","132","142","150","120","130","140","150"]},"The properties of the tables (not shown in .) used by the network processors, such as the network processors , , and , are abstracted, via step . Each network processor , , and  has specific tables used in a certain manner. Step  abstracts the tables to a more general level.","For example, the tables used by network processors, such as the network processors , , and , are complex data structure that exhibits certain properties. Each table acts as a container for one or more user data records and maintains various states. Each table also typically has a maximum size, or number of records of fixed size that can be stored.","In a preferred embodiment, step  abstracts the tables as either fast or standard tables. The tables are placed in various memories either internal or external to the corresponding network processor , , and\/or . Tables may, for example, be placed in Dynamic Random Access Memories (DRAMs) and Static Random Access Memories (SRAMs). The speed with which data can be accessed from a table depends upon factors, such as the size, the placement in memory and the type of search algorithm used by the table. In step , the table size and the memory in which the records are placed (i.e. the memory in which the tables are placed), are abstracted to fast tables and standard tables. Fast tables are small in size in comparison to standard tables and are placed in memories internal to the corresponding network processor , , or  or in SRAMs. Standard tables may be very large in size and are placed in slower memories such as DRAMs. Thus, step  abstracts the type of table to fast or standard. However, the exact interpretation of this abstract concept can depend on the software and\/or firmware , , and  implemented by a specific network processor.","For example,  depict abstractions of a fast table  and a standard table , respectively. The tables  and  also represent abstractions of other features of tables. The fast table  is depicted as including records , , , and , as well as bookmarks  and . The records , , , and  have corresponding keys A through A. Also shown are pointers A, B, A, B, A, and B. As discussed below, the keys A through A are generally used for exact matches. In other words, an exact match for one of the keys A through A is typically searched for in the fast table . The standard table  also include records , , , and , corresponding keys A through A, and pointers A, B, A, B, A, and B. However, the algorithm typically used for a standard table, as discussed below, is generally a longest prefix match.","In addition to abstracting the table type, the step  preferably abstracts the search algorithm used by the tables. For example, tables may generally be accessed in a random manner or in a sequential manner. When accessed in a random manner, a search key is provided. The type of search key that is provided depends on the search algorithm that the table uses to access a particular record. A table generally incorporates one algorithm for accessing records randomly. In one embodiment, the abstracting step  defines two types of search keys corresponding to two types of search algorithms. The keys are exact match keys, such as the keys through Aa and longest prefix match keys, such as the keys through A, as depicted in . The maximum length of these keys need not be specified but is preferably large enough to support the largest key that could be specified in a heterogeneous system of network processors.","If sequential access is supported by a table, then records in a table may also be accessed sequentially from the beginning of the table or from some marked location within the table. Thus, the tables  and  are depicted as including pointers A, B, A, B, A, and B and A, B, A, B, A, and B. The sequential access to records may occur in a forward direction (where the term forward indicates access to the n+1record following the nrecord) or in a backward direction (where the term backward indicates access to the n\u22121record following the nrecord) or both. If sequential access is supported, then all of the records in the table are circularly linked. Therefore, there is no concept of the beginning (or end) of a table since there is no reference point to support this concept. However, tables may support bookmarks, such as the bookmarks , , , and , that may temporarily indicate a reference point for sequential access of records. A bookmark, such as the bookmarks , , , and , indicates the starting point of a sequential access. The complete table is said to have been sequentially traversed if the N+1(or N\u22121for a backward access) sequential access returns a bookmarked record.","A table, such as the table  or , is multi-user in nature, which enables multiple entities to access the table  or , respectively. The table management application  entity on the host processor , (and its proxy on each network processor , , or  if so implemented) is also considered to be an Administrative entity. All entities may access the table simultaneously to either perform random\/sequential searches or to insert\/delete\/update a Record in the Lookup Table. Each entity that wishes to perform a sequential search on the table registers with the table and obtains a sequential access user identifier. This identifier enables a table  or  to manage the bookmarks  and  or  and , respectively, associated with each registered entity independently. Thus, all registered entities are able to sequentially access the entries , , , and  and , , , and  in the table  and , respectively, simultaneously without adversely affecting one another.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4C","b":["182","184","186","188","180","182","184","186","180","182","186","184","182","184","186","180"]},"The records are an integral part of the table. Thus, the abstraction step  also abstracts the operations relating to records. The records of a table are of a fixed length. The length is specified as part of the table definition process. The record contains the user specific data and may contain other implementation-specific control information required to implement certain behaviors, such as sequential access. In addition, any record in a lookup table can be added to, modified or deleted by the table (if the record not being accessed at that time by another entity). The table incorporates behavior to ensure that sharing violations are avoided.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4D","FIG. 4D"],"b":["190","191","192","193","194","190","191","192","193","194"]},"In the network processors , , and , the information in the records of a table have a finite time period during which it is valid. On the expiration of this time period, the entries are automatically deleted from the table. The process of deleting a record after a finite time period is referred to as aging. Thus, step  preferably also abstracts the aging process for tables. The abstraction of tables performed in step  supports the aging function. In a preferred embodiment, the abstraction will require users to specify if aging is required to be supported on the table and if so, the identifier of an aging procedure that needs to be invoked, the elapsed time interval between aging cycles, the number of records that must be visited in a single cycle, and\/or any other information used in aging. Other aspects of the tables are preferably also abstracted in step .","The generic APIs  are defined using the abstraction provided, via step . Thus, step  provides the generic APIs  that can preferably manage tables, such as the tables  and , for the network processors , , and . Furthermore, where a particular operation is not supported by tables for a particular network processor , , and , the generic APIs  account for this by providing a null behavior to the table management application .","Step  also provides the generic APIs  such that the APIs can be used with a network processor independent table management application . Thus, using the method , the generic APIs  can be provided. The network processor independent table management application , as well as the network processors , , and  can be developed to utilize the generic APIs .","In a preferred embodiment, the generic APIs  include at least APIs for configuring and updating the tables for each of the network processors , , and  in a network processor specific manner. The generic APIs thus include APIs that govern the tables in general as well as the entries (or records). The generic APIs  preferably include APIs for setting the type of the table and setting the states of the table: defining, enabling, disabling, and locking tables. The generic APIs also include APIs for linking (cascading), tables, updating entries, adding entries, deleting entries, purging entries, and aging entries. In addition to controlling the tables for the network processors , , and  in a network processor specific manner, the APIs  preferably also return a null behavior for a particular function that is not implemented by a particular network processor.","In a preferred embodiment, the generic APIs  include twenty-five APIs. The APIs preferably include: Table Define, Table Delete, Table Add Entry, Table Update Entry, Table Read Entry, Table Delete Entry, Table Purge, Table Set Link, Table Switch Version, Table Enable, Table Disable, Table Lock, Table Unlock, Table View Config, Table List, Table Register SA, Table Deregister SA, Table Get Current Entry, Table Get Next Entry, Table Get Previous Entry, Table Process Entry, Table Set Bookmark, Table Go to Bookmark, Table Start Aging, and Table Stop Aging. In a preferred implementation of the generic APIs, including the configure, update, enable, disable, and list APIs, parameters and fields are specified. Table 1 describes a preferred embodiment of the fields used.",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field Name","Field Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Aging Entries","Number of entries to scan per aging cycle."]},{"entry":["Aging Function","Selection of aging algorithms. A value of zero"]},{"entry":[{},"indicates No Aging."]},{"entry":["Aging Interval","Number of seconds in aging cycle."]},{"entry":["AutoEnabled","Enable table immediately upon creation."]},{"entry":["Bookmark ID","The User's Bookmark ID to use."]},{"entry":["Cache Enabled","Enable cache"]},{"entry":["Data","Entry data"]},{"entry":["Data Offset","Number of bytes in the entry to skip before"]},{"entry":[{},"writing the Data field."]},{"entry":["Data size","the size in bytes of the data that will be added"]},{"entry":["Direction","Direction of travel in the Sequential Access table"]},{"entry":["Entry Data Size","Size of entry in bytes"]},{"entry":["EntryProcedure ID","Identifier of the procedure to call for processing"]},{"entry":[{},"an entry"]},{"entry":["Entry size","Fixed entry size in bytes or, if entry type is"]},{"entry":[{},"variable this is the maximum size."]},{"entry":["Error Area Size","Size of error message in Words starting from"]},{"entry":[{},"Word 2"]},{"entry":["Error Code","Component specific error code"]},{"entry":["Hash Algorithm","Hash algorithm selection. A value of zero"]},{"entry":[{},"indicates that no hashing is performed on the key."]},{"entry":["Invoke ID","A field used by the Service Requestor to correlate"]},{"entry":[{},"invocations with responses."]},{"entry":["Key","Key bits"]},{"entry":["Key length","Length of LPM key (in bits) to use for this"]},{"entry":[{},"operation. This field is ignored on tables that have"]},{"entry":[{},"been defined as exact-match."]},{"entry":["Key length fields","These 8 bit fields define the lengths of each key"]},{"entry":[{},"part. The number of these fields is indicated in"]},{"entry":[{},"Number Key Fields above."]},{"entry":[{},"For West multi-field keys are not implemented so"]},{"entry":[{},"only Key Field 0 is used."]},{"entry":["Mask Size","Indicates the size of the Mask for Invert mode"]},{"entry":[{},"only."]},{"entry":["Max Key size","Maximum number of bits in a key for this table."]},{"entry":["Max Table size","Maximum number of entries"]},{"entry":["New Version","New Table ID"]},{"entry":["NextTable ID","Identifies the next table that will be referenced"]},{"entry":[{},"in the case of an unsuccessful search. A value of"]},{"entry":[{},"255 indicates that no other tables will be"]},{"entry":[{},"searched. This feature should not be used if"]},{"entry":[{},"Cache Enabled is selected."]},{"entry":["Number key fields","Number of key fields to use during searches of"]},{"entry":[{},"this table. The lengths of these fields are defined"]},{"entry":[{},"in the variable sized key_length_fields. For"]},{"entry":[{},"West, this number is 1."]},{"entry":["Operation Class","Indicates the conditions under which a response is"]},{"entry":[{},"to be sent to the Service Requestor."]},{"entry":["Operation Code","Indicates the operation whose invocation is being"]},{"entry":[{},"requested."]},{"entry":["Operation Version","Indicates the version level of the operation."]},{"entry":["Output Mode","Select amount of information in response. If this"]},{"entry":[{},"feature is active, configuration data for each table"]},{"entry":[{},"is returned. If this feature is off, only the"]},{"entry":[{},"Table IDs are returned."]},{"entry":["Parameter Area Size","Indicates the size (in words) of the parameter"]},{"entry":[{},"area associated with this operation."]},{"entry":["Placement Data","These fields are defined at design time to contain"]},{"entry":[{},"any hardware dependent table resource"]},{"entry":[{},"information."]},{"entry":[{},"Note: For West, there are no Placement Data for"]},{"entry":[{},"this field."]},{"entry":["Placement Data","The number of words in the variable length"]},{"entry":["Length","Placement Data field. Not use in West"]},{"entry":[{},"implementation."]},{"entry":["Resource Allocation","Table Resources can be allocated manually or"]},{"entry":[{},"automatically."]},{"entry":["Method","Manual allocation requires resource data to be"]},{"entry":[{},"supplied in the Placement Data field and the"]},{"entry":[{},"corresponding size in Placement Data Length."]},{"entry":["Result Area Size","Size of result message in Words starting from"]},{"entry":[{},"Word 2"]},{"entry":["SA_User ID","The SA_User ID that should be freed."]},{"entry":["Search type","Type of search supported under the table. Can be"]},{"entry":[{},"Exact Match, Longest-Prefix Match or"]},{"entry":[{},"Range Match."]},{"entry":["Sequential access","Type of sequential access allowed under this"]},{"entry":[{},"table. Entries can be scanned forward,"]},{"entry":[{},"forward\/backward or none."]},{"entry":["Service Element Type","Indicates the nature of service. The possible"]},{"entry":[{},"values are: API-INVOKE, API-RESULT or"]},{"entry":[{},"API-ERROR"]},{"entry":["Table ID","Table Identifier"]},{"entry":["Table speed","For automatic table resource allocation, select"]},{"entry":[{},"one of two types of tables: normal and expedited."]},{"entry":[{},"If the Resource Allocation method is selected as"]},{"entry":[{},"manual, this field is not used."]},{"entry":["Threshold","Send notification if number of entries"]},{"entry":[{},"exceeds this threshold. Do not send notification"]},{"entry":[{},"if this value is zero."]},{"entry":["Update mode","Select mode of update: Standard, Select, Invert."]},{"entry":[{},"Select and Invert modes require the Mask field to"]},{"entry":[{},"indicate bit positions to be modified."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Some portion of the above fields are preferably used by the generic APIs  for performing different operations, such as configuring and invoking different types of congestion control at various points in the network processor. Note, however, that an alternate embodiment might use additional and\/or other fields having other uses.","Preferred embodiments of the Table Define API, Table Delete API, Table Add Entry API, Table Update Entry API, Table Read Entry API, Table Delete Entry API, Table Purge API, Table Set Link API, Table Switch Version API, Table Enable API, Table Disable API, Table Lock API, Table Unlock API, Table View Config API, Table List API, Table Register SA API, Table Deregister SA API, Table Get Current Entry API, Table Get Next Entry API, Table Get Previous Entry API, Table Process Entry API, Table Set Bookmark API, Table Go to Bookmark API, Table Start Aging API, and Table Stop Aging API are described below. However, nothing prevents the use of additional and\/or different APIs.","The table define API allows the table management application  to define the characteristics of a table. A TableID is supplied by the user to identify the table to the system and is bound to those defined characteristics. Once a TableID is defined, it uniquely identifies the table until the table is deleted. The parameters associated with this API are as shown in Table 2. If the operation is successful and sequential access is specified, a Sequential Access ID is returned.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table ID","0 . . . 255","Defines one of 256 tables in a"]},{"entry":[{},{},"NP."]},{"entry":["Search Key","0 . . . 255","Length is defined in bits."]},{"entry":"Length"},{"entry":["Search Type","Exact Match"]},{"entry":[{},"Longest Prefix Match"]},{"entry":["Sequential Access","No Sequential Access"]},{"entry":["Method","Forward Only"]},{"entry":[{},"Forward and"]},{"entry":[{},"Backward"]},{"entry":["AutoEnable","True","True means the Table is"]},{"entry":[{},"False","automatically transitioned to"]},{"entry":[{},{},"Enabled State (else it is left"]},{"entry":[{},{},"in the Disabled State)."]},{"entry":["Table Speed","Normal","These correspond to Standard"]},{"entry":[{},"Expedited","and Fast Tables mentioned in"]},{"entry":[{},{},"the abstract model."]},{"entry":["Record Size","1 . . . 1024","Size defined in bytes."]},{"entry":["Aging Identifier","0 . . . 255","A value of zero indicates no"]},{"entry":[{},{},"aging."]},{"entry":["Cascaded Table","True","\u2018True\u2019 indicates that this"]},{"entry":[{},"False","table is cascaded and the"]},{"entry":[{},{},"\u2018Next Table ID\u2019 field"]},{"entry":[{},{},"indicates the next table in the"]},{"entry":[{},{},"cascade. \u2018False\u2019 implies that"]},{"entry":[{},{},"the \u2018Next Table ID\u2019 field is"]},{"entry":[{},{},"not interpreted."]},{"entry":["Next Table ID","0 . . . 255","Indicates the next table in the"]},{"entry":[{},{},"cascade."]},{"entry":["Max Table Size","1 . . . 16777216","Indicates the maximum"]},{"entry":[{},{},"number of records in the"]},{"entry":[{},{},"table."]},{"entry":["Max Key Size","1 . . . 255","Max number of bits in a LPM"]},{"entry":[{},{},"key."]},{"entry":["Threshold","1 . . . 16777216","If number of records reaches"]},{"entry":[{},{},"this number, a warning is"]},{"entry":[{},{},"generated."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Delete API allows a table to be deleted. The table is preferably in the disabled state prior to invoking this API. When a table is deleted, all entries and the table configuration is removed. The TableID is then ready for re-use. Preferably, the only parameter for the Table Delete API is the TableID.","The Table Add Entry API allows an entry to be added to into an existing table. The table is in the Enabled or Locked state for this operation. The parameters associated with this API are depicted in Table 3.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter Name","Value","Remarks"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Table ID","0.255","Uniquely identifies the table"]},{"entry":[{},{},{},"on which the operation is to"]},{"entry":[{},{},{},"be performed."]},{"entry":[{},"Search Key Length","0.255","Length is defined in bits."]},{"entry":[{},"Search Key",{},"The key to be used for"]},{"entry":[{},{},{},"inserting the record."]},{"entry":[{},"override Entry","True","If set to True, any existing"]},{"entry":[{},{},"False","record corresponding to the"]},{"entry":[{},{},{},"specified key will be"]},{"entry":[{},{},{},"overwritten, else the"]},{"entry":[{},{},{},"operation will not succeed (if"]},{"entry":[{},{},{},"the record pre-exists)."]},{"entry":[{},"User Data Size","1.1024","The size of the user info (in"]},{"entry":[{},{},{},"bytes) that needs to go into"]},{"entry":[{},{},{},"the record."]},{"entry":[{},"User Data","1.1024","The actual user data."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The Table Update Entry API allows an entry in a table to be updated. Three modes of operation are preferably available: Standard update, Select and Invert. All modes specify the size and position of the entry data to be modified. In the Standard Mode, the user data is overwritten starting at the specified data offset within the record. In the Select Mode a mask is specified for indicating only the bit positions which are to be modified. In Select Mode, the mask size is the same as the data size. The Invert Mode uses the mask to indicate which bit positions to invert. The table is in the Enabled or Locked state prior to invoking this API. The parameters associated with the Table Update Entry API are shown in Table 4.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table ID","0.255","Uniquely identifies the table"]},{"entry":[{},{},"on which the operation is to"]},{"entry":[{},{},"be performed."]},{"entry":["Search Key Length","0.255","Length is defined in bits."]},{"entry":["Search Key",{},"The key to be used for"]},{"entry":[{},{},"updating the record."]},{"entry":["Update Mode","Standard"]},{"entry":[{},"Select"]},{"entry":[{},"Invert"]},{"entry":["User Data Size","1.1024","The size of the user info (in"]},{"entry":[{},{},"bytes) that needs to go into"]},{"entry":[{},{},"the record."]},{"entry":["User Data Offset","1.1024","The offset in the record"]},{"entry":[{},{},"where the data should be"]},{"entry":[{},{},"written."]},{"entry":["User Data","1.1024","The actual user data."]},{"entry":["Select Mask","1 . . . 1024","The size equals that specified"]},{"entry":[{},{},"in the User Data Size field."]},{"entry":[{},{},"This parameter is interpreted"]},{"entry":[{},{},"only if the Update Mode is"]},{"entry":[{},{},"\u2018Select\u2019 or \u2018Invert\u2019."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Read Entry API is used to read an entry in a table. The table is in the enabled or locked state for the Table Read Entry API to utilize the table. The requested amount data is read from the record associated with the specified key and returned. The parameters associated with the Table Read Entry API are depicted in Table 5.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table ID","0 . . . 255","Uniquely identifies the table"]},{"entry":[{},{},"on which the operation is to"]},{"entry":[{},{},"be performed."]},{"entry":["Search Key Length","0 . . . 255","Length is defined in bits."]},{"entry":["Search Key",{},"The key to be used for"]},{"entry":[{},{},"reading the record."]},{"entry":["User Data Size","1 . . . 1024","The size of the user info (in"]},{"entry":[{},{},"bytes) that needs to be read."]},{"entry":["User Data Offset","1 . . . 1024","The offset in the record from"]},{"entry":[{},{},"where the data should be"]},{"entry":[{},{},"read."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Delete Entry API allows an entry to be deleted from a table. The table is in the enabled or locked state for this API. The parameters associated with the Table Delete Entry API are shown in Table 6.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter Name","Value","Remarks"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Table ID","0 . . . 255","Uniquely identifies the table"]},{"entry":[{},{},{},"on which the operation is to"]},{"entry":[{},{},{},"be performed."]},{"entry":[{},"Search Key Length","0 . . . 255","Length is defined in bits."]},{"entry":[{},"Search Key",{},"The key to be used for"]},{"entry":[{},{},{},"inserting the record."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The Table Purge API is used to purge all the entries in a table. Resources that were consumed by these entries are then returned to the system for reuse. The table can be in either the enabled or disabled state prior to utilizing this API. If the table is in the enabled state, the Table Purge API preferably locks the table, purges the entries and then unlocks the table. In a preferred embodiment, the only parameter associated with the Table Purge API is the Table ID.","The Table Set Link API allows the NextTableID field to be set in the table configuration. Although the NextTableID is set when a table is defined, subsequent actions on the table chain, such as the_Table_Delete API update links from the original definition. If the Cascaded Table parameter is set to \u2018False\u2019, then the table identified by the Table ID parameter is the last table in the cascade. The table is preferably in the enabled state for to the Table Set Link API. In a preferred embodiment, this API automatically transitions the table to the locked state, set the new link value and then transition back to the enabled state. The parameters associated with this API are shown in Table 7.",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter Name","Value","Remarks"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Table ID","0 . . . 255","Uniquely identifies the table"]},{"entry":[{},{},{},"on which the operation is to"]},{"entry":[{},{},{},"be performed."]},{"entry":[{},"Cascaded Table","True","\u2018True\u2019 indicates that this"]},{"entry":[{},{},"False","table is cascaded and the"]},{"entry":[{},{},{},"\u2018Next Table ID\u2019 field"]},{"entry":[{},{},{},"indicates the next table in the"]},{"entry":[{},{},{},"cascade. \u2018False\u2019 implies that"]},{"entry":[{},{},{},"the \u2018Next Table ID\u2019 field is"]},{"entry":[{},{},{},"not interpreted."]},{"entry":[{},"Next Table ID","0 . . . 255","Indicates the next table in the"]},{"entry":[{},{},{},"cascade if the \u2018Cascaded"]},{"entry":[{},{},{},"Table\u2019 parameter is set to"]},{"entry":[{},{},{},"\u2018True\u2019."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The Table Switch Version API is used to swap two versions of a table, preferably even if the 100 system is running. After the operation is completed, registered sequential users of the old table are transferred to the newer version of the table. The sequential access pointers and bookmarks associated with each user are reset. If Aging had been initiated on the old table and if aging is enabled on the newer version of the table, then the aging parameters are transferred to the new table and the aging operation commences. The Sequential Access ID, Aging Interval and Aging Entries parameters are all preferably inherited from the old table. The table is preferably in the enabled state prior to the Table Switch Version API operating. In a preferred embodiment, both tables are transitioned to the Locked state before performing the switch operation and automatically transitioned back to enabled state when the switch operation is concluded. The parameters associated with the Table Switch Version API are shown in Table 8.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter Name","Value","Remarks"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Table ID","0 . . . 255","Uniquely identifies the table"]},{"entry":[{},{},{},"on which the operation is to"]},{"entry":[{},{},{},"be performed."]},{"entry":[{},"New Table ID","0 . . . 255","Indicates the table with"]},{"entry":[{},{},{},"which the original table will"]},{"entry":[{},{},{},"be swapped."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The Table Enable API is used to transition a table from disabled to the enabled state. Transitions from other table states may result in an error. If the table is already in the enabled state, this operation is preferably treated as a essentially null operation. In a preferred embodiment, the only parameter associated with this operation is the Table ID.","The Table Disable API allows a table to be transitioned from enabled to the disabled state. If the table is already in the enabled state, this operation is essentially treated as a null operation. In a preferred embodiment, the only parameter associated with the Table Disable API is the Table ID.","The Table Lock API use used to move a table from the enabled to the locked state. After the transition to the locked state, the table is deemed to be temporarily out of service for non-administrative entities. Operations on the table from such entities are blocked until the table is unlocked or they time out. In a preferred embodiment, all generic APIs may be performed using the table control application  except the Table_Define API, the Table_Delete API, the Table_Enable API and the Table_Disable API. In a preferred embodiment, the only parameter associated with this operation is the Table ID.","The Table Unlock API is used to moves a table from locked to enabled state. In a preferred embodiment, the only parameter associated with this operation is the Table ID.","The Table View Config API returns the configuration information associated with a table. The configuration information is the preferably same as specified during use of the Table_Define API. In a preferred embodiment, the only parameter associated with this operation is the Table ID.","The Table List API allows the currently defined tables in the system  to be listed. In a preferred embodiment, in a standard mode, the output from the use of the Table List API contains a list of TableID's, the number of entries in each table, the search type, and the table state. In a preferred embodiment of a verbose mode, the output of the operation of the Table List API contains all of the parameters found in the_operations for the Table_Define API in addition to the state. Tables in the undefined state are preferably ignored by this API. A search filter enables specification of search criteria. The parameters associated with this operation are shown in Table 9.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Starting Table ID","0 . . . 255","The id of the Table from"]},{"entry":[{},{},"where the list operation"]},{"entry":[{},{},"should commence."]},{"entry":["Max Tables","0 . . . 255","Indicates the maximum"]},{"entry":[{},{},"number of tables to be"]},{"entry":[{},{},"included in the list operation."]},{"entry":["Output Mode","Standard"]},{"entry":[{},"Verbose"]},{"entry":["Search Filter","All Tables"]},{"entry":[{},"Exact Match only"]},{"entry":[{},"LPM only"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Register SA API can also be utilized. A table can be set up to execute a forward sequential access or both forward and backward sequential accesses. This access can be performed by multiple users simultaneously without any detriment to one another. However, prior to performing sequential access, a user (e.g. an entity) must register to receive Sequential Access services on a particular table. The response to this service request is an SA_User Id which is used to differentiate SA users on a particular table. A table us in the enabled or locked state for this API. In a preferred embodiment, the only parameter to this operation is the Table ID. If the operation is successful, a Sequential Access ID, which is used in performing sequential access on the table, is preferably returned.","The Table Deregister SA API is used to free the Sequential Access ID and its associated resources. This API is preferably invoked after a registered entity has finished traversing a table sequentially and has no further use of the ID. A table is in the enabled or locked state prior to utilizing the Table Deregister SA API. The only parameters associated with this API are preferably the Table ID and the Sequential Access ID.","The Table Get Current Entry API is used to fetch the current record pointed to by a sequential access pointer of a particular entity. The table is in the enabled or locked state and the entity previously registered in the table for sequential access in order for the Table Get Current Entry API to function as desired. The only parameters associated with this API are preferably the Table ID and the Sequential Access ID. The Table Get Current Entry API preferably returns the User Data Size and User Data.","The Table Get Next Entry API operation is used to fetch the entity's sequential access pointer to point to the next record and then fetch the contents of the next record. The table is preferably in the enabled or locked state and the entity has previously registered for sequential access for the Table Get Next Entry API to function as desired. The sequential access pointers are also updated accordingly. In a preferred embodiment, the only parameters associated with this operation is the Table ID and the Sequential Access ID. The operation returns the User Data Size and User Data (refer to Lookup_Table_AddEntry for the specification of these fields).","The Table Get Previous Entry is used to fetch the entity's sequential access pointer to point to the previous record and then fetch the latter's contents. The sequential access pointers are also preferably updated accordingly. The table is in the enabled or locked state and the entity must have previously registered for sequential access for the Table Get Previous Entry. In a preferred embodiment, the properties of the table indicate that it is capable of both forward and backward traversal. In a preferred embodiment, the parameters associated with this operation are the Table ID and the Sequential Access ID. The operation returns the User Data Size and User Data.","The Table Process Entry API allows the entire table or a segment of the entire table to be sequentially \u2018walked\u2019 (either forward or backward). In addition, for every access, calls a specified procedure in order to enable the latter to process the entry. The Table Process Entry API is typically used by aging routines. The specified procedure address must have previously been bound to an ordinal number that represents that address. The enabled or locked state and the entity must have previously registered for sequential access. The parameters associated with this operation are depicted in Table 10.",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table ID","0 . . . 255","The id of the Table on which"]},{"entry":[{},{},"the operation is to be"]},{"entry":[{},{},"performed."]},{"entry":["Sequential Access ID","0 . . . 15","Indicates the id of the"]},{"entry":[{},{},"registered user."]},{"entry":["Walk Direction","Forward","Indicates the direction in"]},{"entry":[{},"Backward","which the iterative traversal"]},{"entry":[{},{},"should be performed."]},{"entry":["Procedure ID","0 . . . 255","Procedure to call in order to"]},{"entry":[{},{},"process each entry"]},{"entry":["Number Of Entries","0 . . . Max Entries","Indicates the number of"]},{"entry":[{},{},"entries to process. Zero"]},{"entry":[{},{},"indicates all entries in the"]},{"entry":[{},{},"table. This value cannot be"]},{"entry":[{},{},"greater than the specified"]},{"entry":[{},{},"Max Entries (refer to"]},{"entry":[{},{},"Lookup_Table_Define) for"]},{"entry":[{},{},"the table."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Set Bookmark API is used with bookmarks. Bookmarks are associated with sequential table access and are used for \u201cmarking\u201d a particular location, or record, in a table so that it is possible to directly go to the bookmark later and begin a sequential \u201cwalk\u201d from the bookmarked record. If a bookmarked record is deleted, the bookmark is simply moved to the next record in the chain. Bookmarks are associated with registered users. Therefore each user may maintain independent bookmarks at different record locations within the same file. The Table Set Bookmark API allows a bookmark to be set at the current sequential access point within a table. The table is in the Enabled or Locked state for use of this API. Other preconditions include configured support for sequential access and user registration. The parameters associated with the Table Set Bookmark API are shown in Table 11.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table ID","0 . . . 255","The id of the Table on which"]},{"entry":[{},{},"the operation is to be"]},{"entry":[{},{},"performed."]},{"entry":["Sequential Access ID","0 . . . 15","Indicates the id of the"]},{"entry":[{},{},"registered user."]},{"entry":["Bookmark ID","0 . . . 3","Upto four Bookmarks may be"]},{"entry":[{},{},"set per registered user per"]},{"entry":[{},{},"table."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Go To Bookmark API is used to initialize the sequential access pointers associated with a registered user to point to the desired bookmark of the user. If a subsequent_Table_Get Current Entry API is utilized, then the contents of the record associated with the bookmark are returned. Similarly if a subsequent Table Get Next Entry API is utilized, then the contents of the record next to the bookmarked record are returned. The table is in the enabled or locked state for this API to be successfully used. In addition, support for sequential access and user registered for sequential access are already preconfigured. The parameters associated with this operation are the same as that for the Table Set Bookmark API.","The Table Start Aging API allows aging of a table to commence. When a table is defined, it is possible to indicate whether aging is supported on the table and if so, the Aging Procedure ID is provided (refer to the Lookup Table Define API for details of the parameter). If aging is supported, the Lookup Table Define API allows the user to be automatically registered for sequential access and returns a Sequential Access ID. However, the aging procedure does not actually start until Table Start Aging API is used. Because the aging procedure involves sequential access, the Sequential Access ID returned as part of the Table Define API operations and is provided as a parameter for this operation. The table for which the Table Start Aging API is utilized is in the enabled or locked state. The parameters associated with the Table Start Aging API are depicted in Table 12.",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter Name","Value","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table ID","0 . . . 255","The id of the Table on which"]},{"entry":[{},{},"the operation is to be"]},{"entry":[{},{},"performed."]},{"entry":["Sequential Access ID","0 . . . 15","Indicates the id of the"]},{"entry":[{},{},"registered user."]},{"entry":["Aging Interval","1 . . . 2\u2212 1","The elapsed time in seconds"]},{"entry":[{},{},"between aging cycles."]},{"entry":["Aging Entries","0 . . . Max Entries","Indicates the number of"]},{"entry":[{},{},"entries to process. Zero"]},{"entry":[{},{},"indicates all entries in the"]},{"entry":[{},{},"table. This value cannot be"]},{"entry":[{},{},"greater than the specified"]},{"entry":[{},{},"Max Entries (refer to"]},{"entry":[{},{},"Lookup_Table_Define) for"]},{"entry":[{},{},"the table."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Table Stop Aging API is operation is used to stop the aging function. This presupposes that aging had previously been started using the Table Start Aging API. The conditions for the table are similar to that for the Table Start Aging API. The parameters associated with this API are preferably limited to the Table ID and the Sequential Access ID used by the Table Start Aging API.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 5","FIG. 2","FIGS. 2 and 5"],"b":["210","210","100","210","120","130","140","112","112","112","112"]},"A user, such as a network administrator, is allowed to input information to manage the tables for the network processors , , and  using the generic APIs  in a network independent manner, via step . In step , therefore, a user might provide the identification of the network processor desired to be controlled, values of the appropriate parameters and flags, as well as other information used by the API(s) of the generic APIs being used. The generic APIs  are then used to control tables for the possibly heterogeneous network processors , , and  in a network processor specific manner, via step .","Using the system , the methods  and , and more particularly the generic APIs , the table management application  can be network processor independent. Because of the use of the generic APIs, the table management application  can still control tables for the potentially heterogeneous network processors , , and  in a network processor specific manner. As a result, the table management application  need not include a separate set of APIs for each type of network processor , , and  used. The table management application  is, therefore, simpler. As a result, it is significantly simpler to scale the system , including adding new types of network processors. It is thus also easier to improve the performance of the system  by adding improved network processors. In addition, the maintenance costs of the system  may be reduced due to the use of a simpler table management application .","A method and system has been disclosed for managing tables for heterogeneous network processors using a network processor independent control application. Software written according to the present invention is to be stored in some form of computer-readable medium, such as memory, CD-ROM or transmitted over a network, and executed by a processor. Consequently, a computer-readable medium is intended to include a computer readable signal which, for example, may be transmitted over a network. Although the present invention has been described in accordance with the embodiments shown, one of ordinary skill in the art will readily recognize that there could be variations to the embodiments and those variations would be within the spirit and scope of the present invention. Accordingly, many modifications may be made by one of ordinary skill in the art without departing from the spirit and scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 4A-4D"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
