---
title: Log message anomaly detection
abstract: One or more techniques and/or systems are disclosed for detecting anomalies in a message log. A log message is parsed from an unstructured text string to a structured form, comprising messages signature and parameter values. Structured log messages that contain a same parameter value of a same program variable are grouped together. One or more invariants for are identified from respective types of log message groups. Invariants are applied to log sequences of respective log types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495429&OS=08495429&RS=08495429
owner: Microsoft Corporation
number: 08495429
owner_city: Redmond
owner_country: US
publication_date: 20100525
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A software system, such as a program executed on a computer, can generate a console log message that may be used to troubleshoot the program. For example, console log messages are typically unstructured free-form text strings, which can record events or states of interest and capture a system developers' intent. These logs can be read by a developer or user to detect the events, states and other interesting occurrences, for example. Usually, when a program execution fails (e.g., does not perform according to expectations), system operators can examine recorded log files to gain insight about the failure, and find out the potential root causes. These logs can be utilized for debugging distributed systems, where checking the console logs to locate system problems, which is usually most applicable, as an instrumentation or dump based approach may make a system to behavior differently from its daily execution and introduce overhead.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Large-scale data centers may consist of thousands of distributed components including servers, network devices, distributed computing software components, and operating systems, for example. Due to an increasing scale and complexity of distributed systems, it may be very time consuming for a human operator to diagnose system problems by manually examining a great amount of log messages. Therefore, in this example, automated tools for problem diagnosis through log analysis are desirable for use in diagnosis of distributed systems.","Current and previous automatic detection systems and techniques check logs with a set of rules that describe normal system behaviors. These rules are typically manually predefined by experts according to their knowledge about system design and implementation. However, it can be very expensive to manually define such rules because a great amount of system experts' efforts are often used. Further, modern systems often comprise multiple components developed by different groups or even different companies, and a single expert may not have the complete knowledge of the system, necessitating close cooperation of multiple experts. Additionally, after a system upgrade, the experts may need extra efforts to check or modify the predefined rules again.","Some current statistic learning based automatic tools have been developed that can analyze console logs, profiles and measurements for system monitoring and trouble shooting. These approaches typically extract features from logs, traces or profiles, then use statistical techniques, such as subspace analysis, clustering and classification algorithms to automatically build models, then identify failures or problems according to the learned models. However, most of the learned models are black box models that cannot be easily understood by human operators. That is, for example, they may detect anomalies in a high dimensional feature space, but do not provide intuitive and meaningful explanations for the detected anomalies.","Accordingly, one or more techniques and\/or systems are disclosed that can be used to mine system invariants from console logs based on a statistical learning technique. For example, program invariants have clear physical meanings that can be easily understood by a human operator. Therefore, these techniques can detect system problems and give a meaningful interpretation for respective detected anomaly, for example. In one embodiment, an interpretation can associate the anomaly with program execution logic, which can significantly help system operators to diagnose system problems.","In one embodiment for detecting anomalies in a message log, a log message is parsed from an unstructured text string to a structured form, such as by breaking it into a message signature and parameters. Structured log messages that contain a same value of a same program variable are grouped together and one or more invariants are identified from respective types of log message groups. In order to detect anomalies, invariants are applied to log sequences of respective log types.","To the accomplishment of the foregoing and related ends, the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects, advantages, and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.","The claimed subject matter is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.","A method may be devised that provides for mining system invariants from console logs, such as from a program execution, for example, based on a statistical learning technique. Unlike current and previous approaches, a program invariant can have a clear physical meaning that may be easily understood by a human operator, for example. An exemplary method may detect system problems and provide a meaningful interpretation for detected anomalies. Such an interpretation, for example, can associate the anomaly with execution logic, which can significantly help system operators to diagnose system problems.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","100","102","104"]},"At , structured log messages that contain a same value of a same program variable are grouped. In one embodiment, after parsing, it may be determined whether a set of parameters correspond to a same program variable (e.g., from an executed program from which the log messages are created). In this embodiment, log messages that comprise a same value of a same program variable can be grouped together. For example, log messages containing a same request ID value can be grouped together. Further, by dividing log messages into some close inner-related groups, for example, computational costs can largely be reduced.","At , one or more invariants are identified for respective types of log message groups. In one embodiment, after grouping log messages, a compact sparse integer invariant set can be determined, for example, for respective types of the log message groups. In one embodiment, message groups that are extracted according to the same program variable may be considered as the same type of group. For example, the group of log messages with a request ID # # and the group of log messages with a request ID ## can be the same type of message groups. In one embodiment, a brute force searching algorithm can be combined with a greedy searching algorithm to make the invariant searching process more tractable.","At , invariants are applied to log sequences of respective log types to detect anomalies. In one embodiment, after obtaining one or more sets of invariants, the obtained sets can be applied to detect anomalies. For example, a log sequence that violates an invariant can be labeled as an anomaly. In this example, by detecting the anomalies in the message logs from an executed program, problems in the execution may be identified automatically, that is, mitigating human involvement in manually searching through the logs to look for errors.","Having applied the invariants to log sequences to detect anomalies, the exemplary method  ends at .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":"200"},"A simple example of program execution flow is illustrated in , comprising stages of the program execution: A , B , C , D , and E , where an example condition  may be present to direct the flow accordingly. In this embodiment , a system executing the program can print a corresponding log message A-E at the respective stages -. Typically, there can be multiple running instances that follow the execution flow - shown in the exemplary embodiment . Further, in some embodiments, different instances may execute different branches and their produced logs may interleave together.","In one embodiment, in the exemplary embodiment of a program execution flow , the following equations are to be satisfied:\n\n()=()=()\n\n()=()+()\n\nwhere c(A), c(B), c(C), c(D), c(E) denote a number of log messages A-E in the logs respectively. The respective equations can correspond to a specific invariant of the program execution flow, for example, and validity of such invariants may not be affected by dynamics of the workloads (e.g., varying workloads of the program executed multiple time), a difference of system inputs (e.g., into the program) or an interleaving of multiple instances (e.g., of the program execution).\n","In one embodiment, these invariants may be identified as execution flow invariants. As an example, a violation of these equations (invariants) may identify a program execution error. Because log sequences can record an underlying execution flow of system components in a program, there may be many such linear equations (e.g., invariants) among the log sequences. In one embodiment, automatically discovering respective invariants from collected historical log data for the program execution may facilitate error detection, for example, and further system management tasks.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":["300","300","302","304","304","306","306","308","308","306","310","300"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4A","b":["400","402"]},"Generally, as an illustrative example, log messages printed by a same log-print statement in a source code are a same type of message, as they may correspond to a same execution point and record a same kind of program event having a same semantic meaning. Alternatively, for example, different types of log messages can be used to record different program events having different semantic meanings, and printed by different log-printed statements. In one embodiment, a free-form text string in the log-print statement can be used as a signature to represent the log message type. As an example, a message signature can correspond to a constant content of respective log messages printed by the same log-print statement. Further, in this embodiment, parameter values can be recorded variable values in the log-print statement, which may vary in different executions.","As an illustrative example,  illustrates an example log message . In this example, , the log message can be parsed into message signatures  and parameter values . Parsing the log messages may be performed more easily if the corresponding source code is available, for example, but this is typically not the case. Therefore, in one embodiment, empirical rules can be applied to extract parameter values  leaving raw message signatures  (e.g., message types) to be extracted.","As an example, empirical rules and a few general heuristics may be applied to extract some content that meets typical parameter patterns (e.g., ), such as numbers, uniform resource identifiers (URIs), Internet protocol (IP) addresses, and globally unique identifiers (GUIDs). Further, in this example, after extracting typical parameter values from the log messages by the empirical rules, the remained parts of log messages may be categorized as a set of raw message signatures. Because all of the parameter values may not be extracted by the heuristics empirical rules approach, raw message signatures may still contain some parameter values.","At  of the exemplary embodiment , of , a clustering algorithm can be applied to the raw message signatures to obtain a set of clusters (e.g., comprising similar elements). In one embodiment, a weighted string edit distance (e.g., a weighted Levenshtein distance) may be used to evaluate similarity between two raw message signatures. After clustering, a splitting procedure can be applied on the obtained clusters, for example, according to a diversity of content difference in the cluster. In this embodiment, after the splitting processing, final clusters can be obtained.","At , for respective final clusters, a common string in the cluster is may be considered as a message signature, and remaining parts can be recognized as parameter values. In this way, in this embodiment, the signatures can be extracted, and the remaining parameter values can be extracted.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4C","b":["450","452","456","452","456","2","3","4","450"]},{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Message type index","Message signature"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","[ ] Start TCP Job ID"]},{"entry":["2","Image file of job loaded in seconds, size."]},{"entry":["3","Image file of job saved in seconds, size."]},{"entry":["4","Edits file of size edits # loaded in seconds."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["458","452","452","460","454"]},"As an example, for a log message in, we can denote an extracted message signature as K(m), a number of parameters as PN(m), and an iparameter's value as PV (m, i). In this example, after message signature and parameter value extraction, respective log messages in with a time stamp T(m) can be represented by a multi-tuple:\n\n[(),(),(1),(2), . . . ,(())],\n\nwhich may be designated as a tuple-form representation of the log messages (e.g., A-F).\n",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 5A","FIG. 4C"],"b":["500","452","458"]},"Developers of programs often print out the same important program variable in multiple log-print statements. In one embodiment, multiple parameters may correspond to a same program variable, which may be considered as cogenetic parameters (e.g., created at a same time and\/or in a same place). For example, a program variable (e.g., request ID) can appear as parameters in different log message types, which may be related to execution flow of a request processing.","As another example, as illustrated in , the first three log messages A-C and the fourth log message D, the parameter at the position two B of the message signature \u201c[ ] Start TCP Job ID,\u201d and the parameter at the position one A of the message signature \u201cImage file of job loaded in seconds, size\u201d may be cogenetic parameters because they represent a same program variable (e.g., JobID). In this exemplary embodiment, for example, these cogenetic parameters can be grouped.","At  in the exemplary embodiment  of , a value range of a log parameter for a log message is enumerated. For example, log messages can be collected several times as a target program runs under different workloads. In this example, for respective times of collection, the collected log messages can comprise a log bunch, which may contain several log files from distributed machines. Further, in one embodiment, a value range for a particular parameter can be determined for the log bunch, comprising the plurality of values from the respective times of collection, for example. In this embodiment, the value range for a particular parameter (e.g., defined by its signature and index) can comprise respective distinct values within respective log bunches. Therefore, for example, a value range for log parameters comprises values from a plurality of execution of a program resulting in a plurality of log messages.","At , it can be determined whether a first log parameter and a second log parameter are cogenetic. In one embodiment, this can comprise determining whether the value range of the first log parameter and the value range of the second log parameter are equivalent, or whether the value range of the first log parameter is a sub-set of the value range of the second log parameter, at .","In one aspect, determining whether two parameters are cogenetic. can be based on the following observations:\n\n","In this aspect, for respective log parameters, for two parameters, if a size of an overlapped (e.g., union) value range is larger than a desired threshold, and a desired minimal length of the parameter value is larger than a desired number of characters (e.g., 3 characters using the text string form of the parameter values in the log messages for analysis), the parameters may be cogenetic. At , if the parameters are not cogenetic, they are not grouped.","In this embodiment, at , those log messages having cogenetic log parameters are grouped. In one embodiment, a set of parameter groups can be obtained in which parameters in respective groups are cogenetic, where the parameter group corresponds to a program variable. Further, log messages with the same program variable values can be grouped together.",{"@attributes":{"id":"p-0054","num":"0056"},"figref":["FIG. 5B","FIG. 4B"],"b":["550","550","552","552","552","554","556","556","556"]},"In one embodiment the following algorithm may be used to identify cogenetic parameters:\n\n",{"@attributes":{"id":"p-0056","num":"0065"},"figref":["FIG. 6A","FIG. 6B"],"b":["600","650","602","600","656","654","652"],"br":[{},{}],"in-line-formulae":[{},{}],"i":["a","+a","x","+a","x","+ . . . +a","x"],"sub":["0","1","1","2","2","m","m","j ","0","1","2","m"]},"Therefore, in one embodiment, an invariant can be represented by the vector \u03b8. For example, an invariant can be represented by the vector \u03b8=[0, 0, 1, \u22121, \u22121, 0]. In this example, the message type indexes of A to E are 1 to 5 respectively. Further, given a group of log sequences L, i=1, . . . , n, that are produced by a series of program executions, for example, the number of respective type of log messages can be counted in respective log sequences, x, j=1, . . . , m. In this example, xis the number of log messages of the jlog message type in the ilog sequence, which can yield the following linear equation:\n\n=01, . . . ,n\n","We can denote a count matrix:",{"@attributes":{"id":"p-0059","num":"0068"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"X","mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"1"},{"msub":{"mi":"x","mn":"11"}},{"msub":{"mi":"x","mn":"12"}},{"mi":"\u2026"},{"msub":{"mi":"x","mrow":{"mn":"1","mo":"\u2062","mi":"m"}}}]},{"mtd":[{"mn":"1"},{"msub":{"mi":"x","mn":"21"}},{"msub":{"mi":"x","mn":"22"}},{"mi":"\u22f1"},{"msub":{"mi":"x","mrow":{"mn":"2","mo":"\u2062","mi":"m"}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mn":"1"},{"msub":{"mi":"x","mrow":{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"msub":{"mi":"x","mrow":{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}},{"mi":"\u2026"},{"msub":{"mi":["x","nm"]}}]}]}}}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":"X\u03b8="},"At  in the example embodiment , an invariant space of the count matrix is identified, and one or more invariant candidates in the invariant space can be identified, at . Further, At  of the exemplary embodiment , invariants from the invariant candidates are validated using collected historical log data.","In this embodiment, for example, two sub-spaces can be derived according to the matrix X: a row space of matrix X, which spans row vectors of X, and null space of matrix X, which is orthogonal complement space to the row space. The above equation yields an invariant \u03b8, which can be a vector in the null space of matrix X. In this embodiment, the null space of matrix X can be the invariant space of the executed program, for example. In this example, respective vectors in the invariant space can represent an execution flow invariant, where the vector in the invariant space is the invariant vector.","In one embodiment, the invariant space can be estimated from the matrix X by singular value decomposition (SVD) operation. As an example, a dimension of the invariant space can be equal to a number of zero singular values of the matrix X, and the invariant space can be a span of corresponding singular vectors. However, in this embodiment, historical logs may contain some log messages caused by program failures, which may influence the singular values, which may result in no zero singular value of the matrix X, for example. In one embodiment, traditional sub-space analysis algorithms can be used to determine the row space according to the energy spectrum.","In one embodiment, the following algorithm may be used to estimate invariant space:\n\n","In one embodiment, the invariant searching algorithm can find a compact set of program sparse invariants, for example, based on the set of message counter vectors. Combinations of non-zero coefficients can be used in different dimensions to construct a potential sparse invariant, for example, and it can be validated by determining if it fits with historical log data. For example, an invariant may fit with the collected historical log data if it is satisfied by more than \u03b3% log message groups. In one embodiment, \u03b3 can be a user defined threshold. Further, in this embodiment, the hypothesis of invariants can be constructed with k non-zero coefficients, and the validity of these hypotheses can be sequentially tested.",{"@attributes":{"id":"p-0065","num":"0078"},"figref":"FIG. 7","b":["700","656","752","754","656","752","656","758"]},"In one embodiment, the mined invariants may reflect elementary execution flows in a program. For example, these program invariants often provide intuitive and meaningful information to human operators, and can help them to locate problems on fine granularity. Therefore, in this embodiment, the respective detected anomalies can be related with the invariants (e.g., ) that it breaks to provide insight cues for problem diagnosis, for example. In one example, operators can check which invariants are broken by an anomaly, and how many anomalies are raised by the violation of a specific invariant.","A system may be devised that provides for mining system invariants from console logs, such as from a program execution.  is a component diagram of an exemplary system  for detecting anomalies in a message log. A memory component  is used to store data, such as log messages, and a processor  is used to process data. In one embodiment, the memory component  and processor  may be comprised in a computing device together, or alternately, in separate computing devices operably coupled to perform anomaly detection, for example.","A log message parsing component  is operably coupled with the memory component  and processor  for parsing a log message from an unstructured text string to a structured form. For example, the log message parsing component  can convert a log message from an unstructured text string to a tuple-form representation that comprises a timestamp, a message signature (e.g., a constant free form text string representing a log message type), and a list of message parameter values.","A grouping component  is also operably coupled with the memory component  and processor , and groups structured log messages that contain a same value of a same program variable. For example, log messages that comprise a same value of a same program variable can be grouped together for the grouping component . Further, in this example, log messages that contain a same request ID value can be grouped together by the grouping component .","An invariant identification component  is operably coupled with the memory component and processor, and identifies one or more invariants for respective types of log message groups. For example, message groups associated with a same program variable may be considered as the same type of group. In one embodiment, the invariant identification component  can use a brute force searching algorithm can be combined with a greedy searching algorithm to search for invariants, and extract them.","An anomaly detection component  is operably coupled with the memory component and processor, and it applies invariants to log sequences to detect anomalies. For example, an obtained set of invariants can be applied to detect anomalies, and a log sequence that violates an invariant can be labeled as an anomaly. In this example, by detecting the anomalies in the message logs from an executed program, problems in the execution may be identified automatically.",{"@attributes":{"id":"p-0072","num":"0085"},"figref":"FIG. 9","b":["900","806","920","806","922"]},"The grouping component  comprises a parameter value determination component  that enumerates a value range of a log parameter for a log message, such as from a log bunch (e.g., from a plurality of program executions). Further, the grouping component  comprises a parameter comparison component  compares log value ranges of parameters to determine if the parameters can be grouped based on value ranges, such as by grouping log messages that contain the same value of the same program variable together.","The invariant identification component  comprises a vector extraction component , which extracts a set of message count vectors for respective log message groups that are related to a same target program variable, where the count vectors form a count matrix. An invariant space determination component  then identifies an invariant space of the count matrix. Further, an invariant candidate identification component  can identify one or more invariant candidates in the invariant space using combinations of non-zero coefficients in different dimensions to construct the invariant candidate. Additionally, an invariant validation component  can validate invariants from the invariant candidates using collected historical log data. In this way, for example, the validated invariants can be applied to detect anomalies, using the anomaly detection component .","Still another embodiment involves a computer-readable medium comprising processor-executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer-readable medium that may be devised in these ways is illustrated in , wherein the implementation  comprises a computer-readable medium  (e.g., a CD-R, DVD-R, or a platter of a hard disk drive), on which is encoded computer-readable data . This computer-readable data  in turn comprises a set of computer instructions  configured to operate according to one or more of the principles set forth herein. In one such embodiment , the processor-executable instructions  may be configured to perform a method, such as the exemplary method  of , for example. In another such embodiment, the processor-executable instructions  may be configured to implement a system, such as the exemplary system  of , for example. Many such computer-readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem\u201d, \u201cinterface\u201d, and the like are generally intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a controller and the controller can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.",{"@attributes":{"id":"p-0079","num":"0092"},"figref":["FIG. 11","FIG. 11"]},"Although not required, embodiments are described in the general context of \u201ccomputer readable instructions\u201d being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media (discussed below). Computer readable instructions may be implemented as program modules, such as functions, objects, Application Programming Interfaces (APIs), data structures, and the like, that perform particular tasks or implement particular abstract data types. Typically, the functionality of the computer readable instructions may be combined or distributed as desired in various environments.",{"@attributes":{"id":"p-0081","num":"0094"},"figref":["FIG. 11","FIG. 11"],"b":["1110","1112","1112","1116","1118","1118","1114"]},"In other embodiments, device  may include additional features and\/or functionality. For example, device  may also include additional storage (e.g., removable and\/or non-removable) including, but not limited to, magnetic storage, optical storage, and the like. Such additional storage is illustrated in  by storage . In one embodiment, computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage  may also store other computer readable instructions to implement an operating system, an application program, and the like. Computer readable instructions may be loaded in memory  for execution by processing unit , for example.","The term \u201ccomputer readable media\u201d as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory  and storage  are examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also include communication connection(s)  that allows device  to communicate with other devices. Communication connection(s)  may include, but is not limited to, a modem, a Network Interface Card (NIC), an integrated network interface, a radio frequency transmitter\/receiver, an infrared port, a USB connection, or other interfaces for connecting computing device  to other computing devices. Communication connection(s)  may include a wired connection or a wireless connection. Communication connection(s)  may transmit and\/or receive communication media.","The term \u201ccomputer readable media\u201d may include communication media. Communication media typically embodies computer readable instructions or other data in a \u201cmodulated data signal\u201d such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.","Device  may include input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, infrared cameras, video input devices, and\/or any other input device. Output device(s)  such as one or more displays, speakers, printers, and\/or any other output device may also be included in device . Input device(s)  and output device(s)  may be connected to device  via a wired connection, wireless connection, or any combination thereof. In one embodiment, an input device or an output device from another computing device may be used as input device(s)  or output device(s)  for computing device .","Components of computing device  may be connected by various interconnects, such as a bus. Such interconnects may include a Peripheral Component Interconnect (PCI), such as PCI Express, a Universal Serial Bus (USB), firewire (IEEE 1394), an optical bus structure, and the like. In another embodiment, components of computing device  may be interconnected by a network. For example, memory  may be comprised of multiple physical memory units located in different physical locations interconnected by a network.","Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example, a computing device  accessible via network  may store computer readable instructions to implement one or more embodiments provided herein. Computing device  may access computing device  and download a part or all of the computer readable instructions for execution. Alternatively, computing device  may download pieces of the computer readable instructions, as needed, or some instructions may be executed at computing device  and some at computing device .","Various operations of embodiments are provided herein. In one embodiment, one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media, which if executed by a computing device, will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further, it will be understood that not all operations are necessarily present in each embodiment provided herein.","Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as advantageous over other aspects or designs. Rather, use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application, the term \u201cor\u201d is intended to mean an inclusive \u201cor\u201d rather than an exclusive \u201cor\u201d. That is, unless specified otherwise, or clear from context, \u201cX employs A or B\u201d is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then \u201cX employs A or B\u201d is satisfied under any of the foregoing instances. In addition, the articles \u201ca\u201d and \u201can\u201d as used in this application and the appended claims may generally be construed to mean \u201cone or more\u201d unless specified otherwise or clear from context to be directed to a singular form.","Also, although the disclosure has been shown and described with respect to one or more implementations, equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components (e.g., elements, resources, etc.), the terms used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., that is functionally equivalent), even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition, while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes\u201d, \u201chaving\u201d, \u201chas\u201d, \u201cwith\u201d, or variants thereof are used in either the detailed description or the claims, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
