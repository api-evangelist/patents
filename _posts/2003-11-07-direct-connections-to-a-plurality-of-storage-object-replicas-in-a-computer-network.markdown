---
title: Direct connections to a plurality of storage object replicas in a computer network
abstract: A system and method for efficiently accessing replicas of a storage object. A first node may perform a find operation to determine a plurality of nodes that each store a replica of a first storage object. For each node in the plurality of nodes, the first node may establish a direct connection to the node. The first node may then access the replicas of the first storage object using the respective direct connections to the plurality of nodes. In one embodiment, the nodes may be nodes in a peer-to-peer network. Establishing a direct connection to each storage object replica may enable the first node to communicate with each node in a single hop without having to pass messages via intermediate nodes in the peer-to-peer network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08060619&OS=08060619&RS=08060619
owner: Symantec Operating Corporation
number: 08060619
owner_city: Mountain View
owner_country: US
publication_date: 20031107
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","This invention relates to computer networks and, more particularly, to a system and method for establishing direct network connections to a plurality of storage object replicas in a computer network.","2. Description of the Related Art","Computer networks are important for many different applications. One important type of networking is referred to as peer-to-peer or P2P networking. As used herein, a peer-to-peer network is generally used to describe a decentralized network of peer nodes where each node may have similar capabilities and\/or responsibilities. Participating peer nodes in a P2P network may communicate directly with each other. Work may be done and information may be shared through interaction among the peers. In addition, in a P2P network, a given peer node may be equally capable of serving as either a client or a server for another peer node.","A peer-to-peer network may be created to fulfill some specific need, or it may be created as a general-purpose network. Some P2P networks are created to deliver one type of service and thus typically run one application. For example, Napster was created to enable users to share music files. Other P2P networks are intended as general purpose networks which may support a large variety of applications. Any of various kinds of distributed applications may execute on a P2P network. Exemplary peer-to-peer applications include file sharing, messaging applications, distributed data storage, distributed processing, etc.","In some peer-to-peer networks, various objects may be replicated across multiple computer systems in the network. It is often necessary to access all the replicas of a storage object together. In order for the peer-to-peer network to be able to scale efficiently, it may be important to provide a method for accessing all the replicas of an object efficiently without having to communicate with each one in a hop-by-hop manner.","Various embodiments of a system and method related to efficiently accessing replicas of a storage object are disclosed. A plurality of nodes may be coupled to each other to form a network. Coupling the plurality of nodes to each other may comprise creating a plurality of links. Each link may comprise a virtual communication channel between two nodes.","According to one embodiment of the method, a first node may perform a find operation to determine a plurality of nodes, where each node in the plurality of nodes stores a replica of a first storage object. For each node in the plurality of nodes, the first node may establish a direct connection to the node. The first node may then access the replicas of the first storage object using the respective direct connections to the plurality of nodes. For example, the first node may access each replica of the first storage object by sending one or more messages directly to each node in the plurality of nodes using the respective direct connection. The one or more messages may be sent from the first node to each node in the plurality of nodes without passing through intermediate nodes in the network.","In one embodiment, a first location-independent address, e.g., a role, may be associated with each node that stores a replica of the first storage object. In this embodiment, the first node may determine the plurality of nodes by sending a first message addressed to the first location-independent address and receiving one or more responses to the first message. For example, the response(s) may include information useable to establish direct connections to the plurality of nodes. In one embodiment, the first node may receive a single aggregated response that aggregates individual responses from the various nodes in the plurality of nodes.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 1","b":["100","100","110","110","110","110","110"]},"As shown, nodes A-E may be coupled through a network . In various embodiments, the network  may include any type of network or combination of networks. For example, the network  may include any type or combination of local area network (LAN), a wide area network (WAN), an Intranet, the Internet, etc. Exemplary local area networks include Ethernet networks, Fiber Distributed Data Interface (FDDI) networks, and token ring networks. Also, each node  may be coupled to the network  using any type of wired or wireless connection medium. For example, wired mediums may include a modem connected to plain old telephone service (POTS), Ethernet, fiber channel, etc. Wireless connection mediums may include a satellite link, a modem link through a cellular service, a wireless link such as Wi-Fi\u2122, a wireless connection using a wireless communication protocol such as IEEE 802.11 (wireless Ethernet), Bluetooth, etc.","In one embodiment, the nodes  may form a peer-to-peer network. For example, the system  may comprise a decentralized network of nodes  where each node  may have similar capabilities and\/or responsibilities. As described below, each node  may communicate directly with at least a subset of the other nodes . In one embodiment, messages may be propagated through the system  in a decentralized manner. For example, in one embodiment each node  in the system  may effectively act as a message router.","In another embodiment, the nodes  in the system  may be organized or may communicate using a centralized networking methodology, or the system  may utilize a combination of centralized and decentralized networking methodologies. For example, some functions of the system  may be performed by using various nodes  as centralized servers, whereas other functions of the system  may be performed in a peer-to-peer manner.","In one embodiment, each node  may have an identifier (ID). The ID of a node  may comprise any kind of information usable to identify the node , such as numeric or textual information. In one embodiment, a node ID may comprise a 128-bit Universally Unique ID (UUID). Universally Unique IDs or UUIDs may be allocated based on known art that ensures that the UUIDs are unique.","Referring now to , a diagram of one embodiment of a node  in the system  is illustrated. Generally speaking, a node  may include any of various hardware and software components. In the illustrated embodiment, the node  includes a processor  coupled to a memory , which is in turn coupled to a storage . The node  may also include a network connection  through which the node  couples to the network . The network connection  may include any type of hardware for coupling the node  to the network , e.g., depending on the type of node  and type of network .","The processor  may be configured to execute instructions and to operate on data stored within the memory . In one embodiment, the processor  may operate in conjunction with the memory  in a paged mode, such that frequently used pages of memory may be paged in and out of the memory  from the storage  according to conventional techniques. It is noted that the processor  is representative of any type of processor. For example, in one embodiment, the processor  may be compatible with the x86 architecture, while in another embodiment the processor  may be compatible with the SPARC\u2122 family of processors. Also, in one embodiment the node  may include multiple processors .","The memory  may be configured to store instructions and\/or data. In one embodiment, the memory  may include one or more forms of random access memory (RAM) such as dynamic RAM (DRAM) or synchronous DRAM (SDRAM). However, in other embodiments, the memory  may include any other type of memory instead or in addition.","The storage  may be configured to store instructions and\/or data, e.g., may be configured to store instructions and\/or data in a persistent or non-volatile manner. In one embodiment, the storage  may include non-volatile memory, such as magnetic media, e.g., one or more hard drives, or optical storage. In one embodiment, the storage  may include a mass storage device or system. For example, in one embodiment, the storage  may be implemented as one or more hard disks configured independently or as a disk storage system. In one embodiment, the disk storage system may be an example of a redundant array of inexpensive disks (RAID) system. In an alternative embodiment, the disk storage system may be a disk array, or Just a Bunch Of Disks (JBOD), (used to refer to disks that are not configured according to RAID). In yet other embodiments, the storage  may include tape drives, optical storage devices or RANI disks, for example.","As shown in , in one embodiment the storage  may store one or more storage objects . As used herein, the term \u201cstorage object\u201d may comprise any kind of data structure or entity used to store or represent data or information. In one embodiment, each storage object  may comprise a file. The storage objects  may include data or information of any kind, where the data is organized or structured in any way. In various embodiments, the storage objects  may be utilized within the system  in any application or to perform any function. Any number of storage objects  may be stored in the storage  of a given node .","In another embodiment, one or more of the storage objects  associated with the node  may be stored in the memory  instead of or in addition to the storage . For example, various storage objects  or portions of storage objects  may be transferred in and out of memory  from storage  as necessary, e.g., as required by other software executing on the node .","In one embodiment, each storage object  may have an identifier (ID). The ID of a storage object  may comprise any kind of information usable to identify the storage object , such as numeric or textual information. In one embodiment, a storage object ID may comprise a 128-bit Universally Unique ID (UUID).","In , another embodiment of a node  in the system  is illustrated. In this embodiment, the memory  may store lower level network software . The lower level network software  (also referred to as link layer software) may be executable by the processor  to interact with or control the network connection , e.g., to send and receive data via the network connection . The lower level network software  may also be responsible for discovering or setting up communication links from the node  to other nodes . The memory  may also store topology and routing (T&R) layer software  which utilizes the lower level network software . Memory  may also store client application software  which utilizes the T&R layer software .","The T&R layer software  may be executable by the processor  to create and manage data structures allowing client application software  to communicate with other nodes  on the system , e.g., to communicate with other client application software  executing on other nodes . In one embodiment, the client application software  may utilize the T&R layer software  to send messages to other nodes . Similarly, the T&R layer software  may pass messages received from other nodes  to the client application software , e.g., messages which originate from client application software  executing on other nodes . The T&R layer software  may also be involved in forwarding messages routed through the local node , where the messages originate from another node  and are addressed to another node  in the system .","In one embodiment the functionality of the T&R layer software  may be modularized into builder functionality and router functionality. For example, a builder component or engine  may be responsible for creating and managing data structures or routing information  representing topology of the system . A router component or message routing engine  may utilize the data structures or routing information  to send or forward messages to other nodes  in the system . The builder  and router  may interface with each other as necessary. For example, in the event of a network failure that invalidates existing routing information, the router  may request the builder  to recover or rebuild routing information  so that the router  can send or forward a message using a different route.","In one embodiment, various storage objects  may be replicated on different nodes . The T&R layer software  may be operable to link together multiple replicas of a storage object  in an efficient manner. Exemplary methods for linking together storage object replicas are described below.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 4","b":["140","100","110","100","110","142","110","100","142","110","131","110","110","110","100","110","110","131","142","110"]},"The resulting set of connected nodes  is referred to herein as a link mesh . In , each hexagon represents a node , and each line represents a link  between two nodes . It is noted that  is exemplary only, and in various embodiments, any number of nodes  may be connected by the link mesh , and each node  may establish links  to any number of neighbor nodes .","In one embodiment, nodes  in the system  may be organized or divided into multiple realms. As used herein, a realm refers to a group of nodes  that communicate with each other in a low-latency, reliable manner and\/or physically reside in the same geographic region. In one embodiment, each realm may comprise a local area network (LAN). As used herein, a LAN may include a network that connects nodes within a geographically limited area. For example, one embodiment of a LAN may connect nodes within a 1 km radius. LANs are often used to connect nodes within a building or within adjacent buildings. Because of the limited geographic area of a LAN, network signal protocols that permit fast data transfer rates may be utilized. Thus, communication among nodes  within a LAN (or within a realm) may be relatively efficient. An exemplary LAN may include an Ethernet network, Fiber Distributed Data Interface (FDDI) network, token ring network, etc. A LAN may also connect one or more nodes via wireless connections, such as wireless Ethernet or other types of wireless connections.","In one embodiment, each realm or LAN may have an identifier (ID). The ID of a realm may comprise any kind of information usable to identify the realm, such as numeric or textual information. In one embodiment, a realm ID may comprise a 128-bit Universally Unique ID (UUID).","For any given node  in a given realm, links may be built from the node  to other nodes  in the same realm and\/or to nodes  in other realms (remote realms). The term \u201cnear neighbors\u201d may be used to refer to nodes  to which the given node  is connected in the same realm. The term \u201cremote neighbors\u201d may be used to refer to nodes  to which the given node  is connected in remote realms. As described below, as various messages are sent from a given node  in a given realm to other nodes , the messages may be sent to near neighbors and\/or remote neighbors. In one embodiment, send operations may be restricted to the local realm where possible. This may be useful, for example, to avoid the overhead of a wide area network (WAN) transfer. In one embodiment, an application programming interface (API) for sending a message may allow the client application software  executing on a node  to specify whether or how to restrict the send operation in this manner.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 5","b":["100","104","104","110","110","104","110","110","104","110","110","110","104","114"]},"As used herein, a \u201cwide area network (WAN) connection\u201d may comprise a network connection between two nodes in different realms or LANs . As shown in , WAN connections  may be utilized to interconnect the various realms, e.g., LANs , within the system . A WAN connection may allow two nodes  that are separated by a relatively long distance to communicate with each other. For example, in one embodiment a WAN connection  may connect two nodes  that are separated by 1 km or more. (WAN connections  may also be used to interconnect two nodes  in different realms or LANs, where the two nodes  are separated by a distance of less than 1 km.) In one embodiment, the data transfer rate via a WAN connection  may be relatively slower than the data transfer rate via a LAN connection . In various embodiments, a WAN connection  may be implemented in various ways. A typical WAN connection may be implemented using bridges, routers, telephony equipment, or other devices.","It is noted that  illustrates a simple exemplary system . In various embodiments, the system  may include any number of realms or LANs , and each realm or LAN  may include any number of nodes . Also, although  illustrates an example in which a single node from each realm is connected to a single node of each of the other realms, in various embodiments, various numbers of WAN connections  may be utilized to interconnect two realms or LANs. For example, a first node in a first realm may be connected to both a second node and a third node in a second realm. As another example, a first node in a first realm may be connected to a second node in a second realm, as well as a third node in the first realm being connected to a fourth node in the second realm.","As described above with reference to , in one embodiment various nodes  in the system  may store storage objects .  illustrates a system  similar to the system illustrated in , in which various storage objects  are stored by nodes . For example, node A stores the storage objects , Obj A, Obj B, and Obj C; node B stores the storage objects , Obj D and Obj E; etc.","In many applications, it may be necessary for nodes  to determine the location of various storage objects  located or stored on other nodes. For example, a first node  may need to determine the location of a first storage object , i.e., may need to determine which node  in the system  stores the first storage object . This may be necessary, for example, if the first node  (or client application software  executing on the first node ) needs to access the first storage object , e.g., to read data from and\/or write data to the first storage object .","In one embodiment, location information may be stored on one or more nodes  in the system . In the example of , each node  stores location information . The location information on each node  may include information that maps IDs of one or more storage objects  to the respective nodes  on which the storage objects  are stored. Thus, when a first node  needs to locate a first storage object , the first node  may access the location information  stored on one or more nodes  to determine the location of the first storage object . The location information  on each node  may be stored in the memory  and\/or the storage  of the respective node . Exemplary methods for storing and using location information to search for storage objects are described in detail below.","It is noted that  illustrate simple systems for exemplary purposes. In various embodiments, any number of realms or LANs may be present in the system , and each realm may include any number of nodes. Also, nodes within a realm may be networked together in any of various ways, and realms may be interconnected in any of various ways. With respect to , in various embodiments, each node  may store any number of storage objects . In one embodiment, some nodes  may not store any storage objects . For example, in , node G does not store any storage objects . A node  that does not store any storage objects  may still access or utilize storage objects  stored on other nodes  and may also store location information  regarding locations of storage objects  stored on other nodes . In one embodiment, one or more nodes may act as lookup servers operable to store lookup information  but may not themselves store and\/or may not access storage objects .","Also, in one embodiment some nodes  may not store location information . For example, in one embodiment, only a subset of the nodes  in the system  may be responsible for storing location information  that can be accessed to lookup locations of storage objects  in response to lookup queries received from other nodes. A node  that does not store location information  may still store one or more storage objects .","As noted above, in one embodiment various storage objects  may be replicated on different nodes . Each replica of a storage object  may store the same data. For example, where a storage object  comprises a file, the file may be replicated on multiple nodes . The system may be operable to link together all the replicas of a storage object . For example, linking the storage object replicas together may enable the data in all the replicas to be updated together so that the data is kept consistent across all the replicas.  is a flowchart illustrating one embodiment of a method for linking together two replicas of a storage object .","In , a first replica of a storage object Obj X may be stored or created on a node A.  illustrates an example in which a first replica of Obj X is stored or created on node A.","In , node A may cause location information for the first replica of Obj X to be stored on a node B. The location information may specify that the first replica of Obj X is located on node A. In the example of , node A causes location information for the first replica of Obj X to be stored on node B. As shown, the location information specifies that the first replica of Obj X is located on node A.","In various embodiments, node A may use any of various methods to select a node to store the location information for the first replica of Obj X. One embodiment of an efficient method for storing the location information for the first replica of Obj X is described below.","In , a second replica of the storage object Obj X may be stored or created on a node C. For example, in , the second replica of Obj X has been stored on node C.","In , node C may query node B to determine the location of the first replica of Obj X. Node B may respond to the query by returning to node C the location information specifying that the first replica of Obj X is located on node A. Thus, in the current example, node C may query node B and may receive location information specifying that the first replica of Obj X is located on node A. In various embodiments, node C may use any of various techniques to determine that node B is the appropriate node to query for the location information for the first replica of Obj X. One exemplary technique for efficiently determining which node to query for the location information is described below.","In , node C may build a route for sending messages to the first replica of Obj X on node A. In the example of , the arrows illustrate a route from node C to node A. As shown, the route goes from node C to node D and from node D to node A.","In various embodiments, any of various techniques may be utilized to build the route from node C to the first replica of Obj X on node A. In one embodiment, node C may initiate a route building process by sending a message that is propagated through one or more intermediate nodes in the system until reaching node A. A reply to the message may be propagated back from node A until reaching node C. As the reply is propagated back, each node that receives a reply may create routing information pointing in the direction of node A. Thus, the route from node C to node A is effectively built backwards from node A to node C. For example, in , node D may first create routing information indicating that messages sent to the first replica of Obj X should be sent along a link to node A. Node C may then create routing information indicating that messages sent to the first replica of Obj X should be sent along a link to node D. An exemplary technique for building a route in this manner is described below.","As shown in , creating the route from node C to the first replica of Obj X on node A effectively links the first replica of Obj X to the second replica of Obj X in one direction. To link the replicas in the other direction, node C may send a publish message for the second replica of Obj X along the route to the first replica of Obj X on node A, as indicated in . Sending the publish message may cause a route for sending messages from node A to the second replica of Obj X on node C to be built. The route from node A to node C may be built in a backward manner, similarly as described above for the route from node C to node A.","For example,  illustrates the publish message being sent from node C along the route to the first replica of Obj X on node A, thus reaching node D. When node D receives the publish message, node D may create routing information for sending messages from node D to the second instance of Obj X. The routing information may specify that messages to the second instance of Obj X should be sent along the link over which the publish message was received. Thus, the route from node D to the second instance of Obj X created on node C may point toward node C, as shown in .","As shown in , node D may forward the publish message along the route to the first replica of Obj X on node A, thus reaching node A. When node A receives the publish message, node A may create routing information for sending messages from node A to the second instance of Obj X. The routing information may specify that messages to the second instance of Obj X should be sent along the link over which the publish message was received. Thus, the route from node A to the second instance of Obj X created on node C may point toward node D, as shown in . Thus, the first and second replicas of Obj X are now linked in a bi-directional manner.","Additional replicas may be linked to the existing replicas in a similar manner. For example,  illustrates a third replica of Obj X stored or created on node G. As described above, node G may build a route to the first replica of Obj X on node A, e.g., by initiating a route-building process by sending a message. However, in this example, node C may receive the message and may not propagate it further. Since node C already has a route to the first replica of Obj X on node A, node C may simply send a reply to node G indicating that the link to node C is an appropriate link over which to send messages to the first replica of Obj X on node A. Node G may then create routing information pointing toward node C, as shown in . Thus, in one embodiment, an optimization may be made so that existing routing information already stored on various nodes is leveraged. This may reduce the propagation of messages through the system.","As described above, node G may then send a publish message for the third replica of Obj X along its route to the first replica of Obj X on node A, as illustrated in . In response to the publish message, node C may create routing information specifying that messages to the third instance of Obj X should be sent along the link to node G, as described above. In one embodiment, node C may not propagate the publish message further along the route to the first replica of Obj X. Instead, a similar optimization as described above may be made with respect to the publish message. Since the second replica of Obj X on node C is already linked to the first replica of Obj X on node A, and the third replica of Obj X on node G is linked to the second replica of Obj X on node C, the third replica of Obj X on node G is also effectively linked to the first replica of Obj X on node A, as shown in . Thus, as new replicas are created on new nodes, the new replicas may be linked to the existing replicas in an efficient manner by leveraging existing routing information.","Methods for recovering from node or network failures may also be provided. It is possible that various nodes or network links may fail, thus invalidating existing routing information. For example,  illustrates the system of , in which node D is no longer reachable, e.g., due to a hardware failure on node D. Thus, the first replica of Obj X on node A is now effectively unlinked from the other two replicas of Obj X. The existing routing information for sending messages from node A to the other replicas of Obj X is no longer valid, and vice versa. In one embodiment, a recovery process may be performed to find new routes to reconnect the replicas. For example,  illustrates new routes passing through nodes H and I.","In one embodiment, the recovery process may not be initiated until necessary. For example, existing routing information may be marked as no longer valid when the network or node failure is discovered, and new routing information may not be built until needed to actually send a message to a replica that is unlinked from another. Exemplary techniques for performing route recovery operations are described in more detail below.","In various embodiments, a node may need to access all the replicas of a storage object for various reasons. For example, it may be necessary to update the data in each replica to maintain consistent data across the replicas. In one embodiment, a node E may access the multiple replicas in a similar manner as described above. For example, node E may first build a route to the first replica of the storage object Obj X and may then send write messages (or other types of messages) along the route to the first replica of Obj X. Since the replicas are linked, the write messages may be forwarded to all the replicas.","However, in a system in which nodes frequently access all the replicas of various storage objects, it may be desirable to send messages to all the replicas in a more efficient manner rather than in this hop-to-hop manner.  is a flowchart diagram illustrating one embodiment of a method for communicating with all the replicas of a storage object in a more efficient manner.","In , a node E that needs to communicate with all the replicas of Obj X may query node B to determine the location of the first replica of Obj X, similarly as described above. Node B may respond to the query by returning to node [[C]] E the location information specifying that the first replica of Obj X is located on node A.","In , node E may build a route for sending messages to the first replica of Obj X on node A, similarly as described above.  illustrates the example of , in which node E has built a route for sending messages to the first replica of Obj X on node A. As illustrated by the arrows, the route passes from node E to node F and from node F to node A. (It is possible that node E already has a route to the first replica of Obj X on node A. For example, node E may have previously been involved in a route-building process to find a route from one of the replicas of Obj X to the first replica of Obj X on node A. If so, it may not be necessary to perform  and .)","In , node E may send a find message along the route to the first instance of Obj X on node A. The find message may comprise a message requesting the locations of all the replicas of Obj X. Each node that receives the find message may forward the find message over all the routes it has to the various replicas of Obj X. Thus, the find message may eventually reach all the nodes that have replicas of Obj X. Each of these nodes may return a reply that specifies the address of the respective node, e.g., specifies a node ID, network address, or other information useable to address the respective node. In the current example,  illustrates the find message being sent from node E to node F and forwarded from node F to node A.  illustrates the find message being forwarded from node A to node D and from node D to node C.","In one embodiment, replies from all of the nodes having a replica of Obj X may be aggregated so that node E receives a single aggregated reply. For example,  illustrates a reply being returned from node C to node D. This reply may specify the location of the second replica of Obj X. As shown, the reply may be forwarded from node D to node A. At node A, the reply may be aggregated with another reply specifying the location of the first replica of Obj X. As shown in , the aggregated reply may be sent from node A to node F and forwarded from node F to node E. Exemplary techniques for aggregating reply messages in this manner are described in more detail below. In another embodiment, replies may not be aggregated. For example, node E may receive a separate reply from each node that has a replica of Obj X.","In , node E may establish direct connections to each replica of Obj X, using the location or address information received in the reply to the find message in . The direct connections may enable node E to send messages directly to each node that has a replica of Obj X. In the current example, node E may establish a first direct connection with node C and a second direct connection with node A, as shown in .","Thus, in one embodiment of the system , a first node  may send a find message and receive a reply to locate a plurality of storage object replicas and may then establish a direct connection to each node  on which one of the storage object replicas is located. The find message may be propagated in a hop-by-hop fashion via one or more intermediate nodes  before reaching the nodes  on which the storage object replicas are located. Similarly, the reply (or replies) to the find message may be propagated back to the first node  in a hop-by-hop fashion. However, once the direct connections are established, the first node  may communicate in a point-to-point fashion with each node  on which a storage object replica is located.","As described above, each node  in the system  may establish links  with at least a subset of other nodes  in the system . Each link  may comprise a virtual communication channel or connection between two nodes . Thus, the links  are also referred to herein as virtual links . The nodes  interconnected by links  effectively comprise an overlay network in which nodes communicate by passing messages to each other over the established links . As used herein, the term \u201cdirect connection\u201d may refer to a direct connection with respect to this overlay network. In other words, a direct connection may refer to a connection implemented using a virtual link  between two nodes .","In various embodiments, a virtual link  or direct connection may be implemented using any of various networking methodologies or protocols. For example, in one embodiment, each link  or direct connection may be implemented using a network protocol such as TCP or UDP. Although a virtual link  or direct connection may directly connect two nodes  with respect to the overlay network, the virtual link  or direct connection may be implemented as a network connection that passes through one or more intermediate devices or computer systems. For example, the network connection that implements a virtual link  or direct connection may pass through one or more devices such as routers, hubs, etc. However, when a first node  establishes a virtual link  or direct connection to a second node  on which a storage object replica is located, the first node  may pass messages to the second node  (and vice versa) via the direct connection without the message being seen as a message on the overlay network by any intermediate nodes . One embodiment of a method for establishing direct connections with a plurality of storage object replicas is described in further detail below.","As described above, one embodiment of the methods for linking storage object replicas and establishing direct connections to the replicas may involve storing location information for a first replica of a storage object and subsequently looking up the location information. The process of determining the location of a storage object by looking up its location information is also referred to herein as a \u201csearch\u201d. An exemplary search facility is described in more detail below.","Referring again to , for a system that utilizes a large number of storage objects  and\/or includes a large number of nodes , it may be inefficient to store location information on every node such that the location information on every node maps every storage object  to its respective location. Thus, the location information  on each node  may map only a subset of the storage objects  to their locations. When a first node  needs to determine the location of a first storage object , the first node  may determine a second node  whose location information  specifies the location of the first storage object , e.g., specifies a third node  on which the first storage object  is located or stored. The first node  may then communicate with the second node  to determine the location of the first storage object . For example, the first node  may send a message to the second node  requesting the second node  to look up and return the location of the first storage object .","In various embodiments, any of various techniques may be utilized to determine which nodes  store location information  for which storage objects . Exemplary techniques for making this determination are described below.","In one embodiment, a hierarchical technique may be utilized such that a first node  first determines a second node  within its own realm or LAN  to check for the location of a storage object . If the location information  on the second node  does not specify the location of the particular storage object , then the first node  may determine a third node  within a remote realm or LAN  to check for the location of the storage object .","In one embodiment, this hierarchical lookup technique may be implemented in such a way that for storage objects within a given realm, nodes within that realm do not have to communicate with nodes outside the realm to determine the locations of those storage objects, but rather can communicate with one or more nodes within the realm to determine the locations of those storage objects. As discussed above, in one embodiment communication within a realm or LAN may be faster than communication between different realms or LANs, e.g., because communication over a LAN connection  may be faster than communication over a WAN connection . Thus, efficiency of the system may be increased by enabling lookup operations for storage objects within a realm to be performed within that realm.","Suppose that a first storage object  is newly created or stored on a first node  in a first realm (e.g., a first LAN). The first node may need to store location information for the first storage object in such a way as to enable the hierarchical lookup technique described above.  is a flowchart diagram illustrating one embodiment of a method for storing location information for the first storage object. It is noted that  illustrates one exemplary embodiment, and various alternative embodiments are contemplated.","In , the first node  in the first realm may select a second node  in the first realm to store location information for the first storage object  located on the first node . In various embodiments, any technique may be used to select which node in the first realm should store the location information for the first storage object. In one embodiment, the second node may be selected based on information regarding the first storage object. For example, in one embodiment the first storage object may have an ID, e.g., a UUID such as described above, and the second node may be selected based on a relation between this ID and IDs of nodes in the first realm, as described in more detail below.","In , the first node  may send the location information for the first storage object  to the second node . For example, the first node  may send a message to the second node  requesting the second node  to store the location information for the first storage object  in the second node 's location information . The location information for the first storage object  may comprise information indicating that the first storage object  is located or stored on the first node . For example, in one embodiment the location information for the first storage object  may associate an ID of the first storage object  with an ID of the first node .","In , the second node may store the location information for the first storage object that was received from the first node. For example, the second node may add information to its location information  to indicate that the first storage object is located on the first node. After storing the location information for the first storage object, the second node may be operable to lookup or retrieve the location information for the first storage object from the second node's location information . For example, the second node may lookup the location information for the first storage object in response to a query from another node, as described below.","In , the first node may select a second realm (e.g., a second LAN) to store location information for the first storage object. In various embodiments, any technique may be used to determine which remote realm to choose as the second realm. In one embodiment, the second realm may be selected based on information regarding the first storage object. For example, in one embodiment the second realm may be selected based on a relation between an ID of the first storage object and IDs of realms in the system , as described in more detail below.","In , the first node may send the location information for the first storage object to the second realm, i.e., to a node within the second realm. In , a third node within the second realm may store the location information for the first storage object. For example, the third node may add information to its location information  to indicate that the first storage object is located on the first node. After storing the location information for the first storage object, the third node may be operable to lookup or retrieve the location information for the first storage object from the third node's location information . For example, the third node may lookup the location information for the first storage object in response to a query from another node, as described below.","In various embodiments, the first node may send the location information for the first storage object to any node within the second realm. In one embodiment the first node may be operable to determine which third node within the second realm should store the location information for the first storage object and may send the location information directly to the third node (or may send a message addressed to the third node to another node in the second realm, which then forwards the message to the third node).","In another embodiment, the first node may not determine which third node within the second realm should store the location information for the first storage object. Instead, the first node may send the location information to a node within the second realm that is designated as a realm representative. The realm representative node may then determine which third node within the second realm should store the location information for the first storage object and may forward the location information to the third node. In various embodiments, any technique may be used to select which node in the second realm should store the location information for the first storage object. In one embodiment, the third node may be selected based on information regarding the first storage object. For example, in one embodiment the third node may be selected based on based on a relation between an ID of the first storage object and IDs of nodes in the second realm, as described in more detail below. The embodiment in which the first node sends the location information to a realm representative node and the realm representative node determines the third node may be advantageous in that the first node is not required to have knowledge of node IDs for nodes within the second realm.",{"@attributes":{"id":"p-0122","num":"0121"},"figref":["FIG. 27","FIG. 6","FIG. 26","FIG. 27"],"b":["100","110","110","6","104","110","110","104","109","110","110","107","110"]},"Node A also selected the LAN B as the second realm to store the location information for Obj A. As shown, node D was selected as the third node within LAN B to store the location information for Obj A in its location information D. The location information for Obj A indicates that Obj A is stored on node A. In one embodiment, the location information may also indicate the node A is in the LAN A, e.g., the location information may include an ID of the first realm (an ID of the LAN A).","Referring now to the flowchart of , suppose that a fourth node in the first realm needs to determine the location of the first storage object, e.g., because the fourth node needs to access the first storage object. As shown in , the fourth node may determine the second node to query for location information for the first storage object. In various embodiments, any technique may be used to determine that the second node is the appropriate node to query. In one embodiment, the technique used by the fourth node to determine the second node may be the same as the technique used by the first node to select the second node. For example, in one embodiment the second node may be selected in each case based on a relation between the ID of the first storage object and IDs of nodes in the first realm, as described in more detail below.","In , the fourth node may query the second node for location information for the first storage object. For example, the fourth node may send a message to the second node identifying the first storage object (e.g., by including the ID of the first storage object in the message) and requesting the second node to lookup and return the location information for the first storage object.","In response, the second node may access its location information  to lookup the location information for the first storage object. In , the second node may return the location information for the first storage object to the fourth node. As described above, the location information for the first storage object may specify that the first storage object is located on the first node. For example, the second node may return a message to the fourth node indicating the ID of the first node. The fourth node may then utilize the location information to access the first storage object on the first node.","Referring again to , in this example any of nodes A-C may act as the fourth node within the first realm (LAN A). For example, if node A or node B is the fourth node, then a message may be sent to node C, and node C may return the location information for the first storage object , Obj A, as described above. If node C is the fourth node then it may not be necessary to send a message to itself. For example, when needing to determine the location of the first storage object  Obj A, node C may determine that it itself has the location information for Obj A and may simply access the location information C. Also, in one embodiment, if node A is the fourth node, node A may first determine whether Obj A is stored locally on node A and find that that is the case, making it unnecessary to send a message to node C to determine the location of Obj A.","Referring now to the flowchart of , suppose that the fourth node is in a third realm different than the first realm or the second realm, and again the fourth node needs to determine the location of the first storage object. As described above, the fourth node may thus first attempt to query a node within its local realm to find the location information for the first storage object. Thus, in , the fourth node may determine a fifth node in the third realm to query for location information for the first storage object, similarly as described above with respect to  of . For example, in one embodiment the fifth node may be selected based on a relation between the ID of the first storage object and IDs of nodes in the third realm.","In , the fourth node may query the fifth node for location information for the first storage object, similarly as described above with respect to  of . In response, the fifth node may access its location information  to lookup the location information for the first storage object. However, in this case the fifth node may find that it does not have location information for the first storage object. The fifth node may thus send a reply to the fourth node indicating that this is the case. In , the fourth node may receive the reply from the fifth node indicating that the fifth node does not have location information for the first storage object.","Since the fourth node could not find the location information for the first storage object in its local realm, the fourth node may next attempt to find the location information in a remote realm. In , the fourth node may determine the second realm as a remote realm to query for location information for the first storage object. In various embodiments, any technique may be used to determine that the second realm is the appropriate realm to query. In one embodiment, the technique used by the fourth node to determine the second realm may be the same as the technique used by the first node to select the second realm in  of . For example, in one embodiment the second realm may be selected in each case based on a relation between the ID of the first storage object and IDs of IDs of realms in the system , as described in more detail below.","In , the fourth node may send a query for location information for the first storage object to the second realm. In various embodiments, the fourth node may send the query for the location information to any node within the second realm. The query may be received either directly or indirectly by the third node in the second realm. For example, in one embodiment the fourth node may be operable to determine which third node within the second realm stores the location information for the first storage object and may send the location information directly to the third node (or may send a message addressed to the third node to another node in the second realm, which then forwards the message to the third node).","In another embodiment, the fourth node may not determine which third node within the second realm stores the location information for the first storage object. Instead, the fourth node may send the query for the location information to a node within the second realm that is designated as a realm representative. The realm representative node may then determine which third node within the second realm stores the location information for the first storage object and may forward the query for the location information to the third node.","In various embodiments, any technique may be used to determine which node in the second realm stores the location information for the first storage object. In one embodiment, the technique used may be the same as the technique used when selecting the third node as the node to store the location information received from the first node. For example, in one embodiment the third node may be selected in each case based on a relation between the ID of the first storage object and IDs of nodes in the second realm, as described in more detail below. The embodiment in which the fourth node sends the query for the location information to a realm representative node in the second realm and the realm representative node determines the third node may be advantageous in that the fourth node is not required to have knowledge of node IDs for nodes within the second realm.","In response to the query for the location information, the third node may access its location information  to lookup the location information for the first storage object. In , the third node may return the location information for the first storage object to the fourth node. As described above, the location information for the first storage object may specify that the first storage object is located on the first node. For example, the third node may return a message to the fourth node indicating the ID of the first realm and the ID of the first node. The fourth node may then utilize the location information to access the first storage object on the first node.","Referring again to , in this example the third realm may be the LAN C, and any of nodes H-J may act as the fourth node within the third realm. For example, suppose that node I acts as the fourth node. Node  may determine any of nodes H-J as the fifth node within the third realm. For example, suppose that node  determines node J as the fifth node. Thus, node I may query node J for location information for the first storage object (Obj A). Node J may attempt to find the location information in its location information J and may return a reply to node I indicating that the location information was not found. Node I may then determine that LAN B is the appropriate remote realm to query for the location information for Obj A and may send the query to a node within LAN B. Node D may receive the query (either directly or indirectly as described above) and may return the location information for Obj A, as described above.","In various embodiments, the location information  discussed above may be structured or stored in any desired way. Any of various data structures or algorithms may be used to store the location information . In one embodiment, the location information  on a given node  may be implemented as a table comprising a plurality of table entries, where each table entry specifies location information for a particular storage object . For example, in , the location information C and D on nodes C and D may each comprise a table entry specifying that the storage object  Obj A is stored on node A. In one embodiment, the location information table on each node  may be implemented as a hash table. For example, hash table entries for each storage object  may be keyed on the ID of the storage object . In other embodiments, location information  may be stored or structured in any other desired way.","As described above, the location information  stored by a given node may include location information specifying locations of storage objects located within the node's own realm (referred to as local location information), as well as location information specifying locations of storage objects located within remote realms (referred to as remote location information). In one embodiment, the local location information and the remote location information may be stored separately. For example, the location information  on a given node may include both a first hash table (referred to as a local hash table) comprising entries specifying locations of storage objects located within the node's own realm and a second hash table (referred to as a global hash table) specifying locations of storage objects located within any realm in the system .","The first hash table stored on a given node may effectively comprise a portion of a larger distributed hash table that is distributed over all the nodes in the node's realm (or distributed over all the nodes in the realm that store location information). Thus, for each realm, nodes in the realm may be configured to collectively store a distributed hash table specifying location information for storage objects stored on nodes within that realm.","The second hash table stored on a given node may effectively comprise a portion of a larger distributed hash table that is distributed over all the nodes in the system (or distributed over all the nodes in the system that store location information). Thus, nodes throughout the system may be configured to collectively store a global distributed hash table specifying location information for storage objects stored on nodes throughout the system.","In another embodiment, the local location information and the remote location information maintained by a given node may be stored together. For example, the local location information and the remote location information may be stored in a single table. Each table entry may simply indicate a mapping of a storage object ID to location information for the respective storage object, regardless of whether the storage object is located in the local realm or a remote realm.","Referring again to  of , any technique may be used to select which node in the local realm (i.e., the second node) should store the location information for the first storage object, as noted. In one embodiment, the first storage object may have an ID implemented as a Universally Unique ID (UUID). Each node in the local realm may also have an ID implemented as a UUID. In one embodiment, the second node may be selected based on a relation between the first storage object's UUID and UUIDs of nodes in the local realm. As one example, the node whose UUID is the highest UUID less than the UUID of the first storage object may be selected as the second node. If the first storage object's UUID is less than the UUID of all nodes in the realm, the node with the highest UUID may be selected as the second node. As another example, the node whose UUID is the lowest UUID greater than the UUID of the first storage object may be selected as the second node, where the node with the lowest UUID is selected as the second node if the first storage object's UUID is greater than the UUID of all nodes in the realm.","With respect to  of  in which the fourth node determines which node in the local realm is the second node to query for location information of the first storage object, in one embodiment this determination may be performed in the same way, e.g., by selecting the node whose UUID is the highest UUID less than the UUID of the first storage object.","With respect to the selection of which third node to select in the second realm to store the location information for the first storage object, this selection may be performed in a similar manner. For example, the node in the second realm whose UUID is the highest UUID less than the UUID of the first storage object may be selected as the second node. Similarly, with respect to  when the third node is again determined during the query process, the third node may be determined using the same technique.","In one embodiment, new nodes may be added to or come online in various realms as the system is active. In one embodiment, location information may be transferred from other nodes to a new node when the new node joins a realm. For example, suppose that a new node is added to the first realm described above with reference to . The second node to store location information for the first storage object may have been selected as described above as the node having the highest UUID less than the UUID of the first storage object. If the UUID of the new node is higher than the UUID of the second node and less than the UUID of the first storage object, then the second node may communicate with the new node to transfer location information for the first storage object from the second node to the new node. Nodes that need to lookup the location of the first storage object may query the new node for the location information.","Similarly, nodes may be removed from the system or may fail as the system is active. In this case, location information previously stored by these nodes may be re-located to other nodes. For example, each node which previously stored location information on a node that is subsequently removed from the system may store the location information on a new node, e.g., by selecting the new node based on its UUID, as described above.","With respect to  of  in which the first node selects a second realm to store location information for the first storage object, in one embodiment this selection may be made based on a relation between the UUID of the first storage object and UUIDs of realms in the system. In one embodiment, the UUID of the first storage object may first be transformed, for example by changing its endianness, e.g., by swapping the most significant and least significant longs in the UUID. The transformed UUID may then be compared to the realm UUIDs. The realm having the highest UUID less than the transformed UUID may be selected as the second realm. If the first storage object's transformed UUID is less than the UUID of all realms in the system, the realm with the highest UUID may be selected as the second realm.","With respect to  in which the fourth node determines which realm is the second realm to query for location information of the first storage object, in one embodiment this determination may be performed in the same way, e.g., by selecting the realm whose UUID is the highest UUID less than the transformed UUID of the first storage object.","In one embodiment, new realms may also be added to or come online in the system as the system is active. When a new realm is added, the UUID of the new realm may affect the determination of which remote realms store location information for various objects, in a manner similar to that described above. Thus, when the new realm is added, one or more nodes in one or more other realms may transfer remote location information to the new realm accordingly.","It is noted that the selection techniques described above are exemplary only. In other embodiments any other desired selection technique may be utilized to select nodes or realms. Also, as described above, in one embodiment some nodes may not store location information. UUIDs for nodes that do not store location information may be excluded from consideration in the node selection technique. In one embodiment, one or more realms in the system may also be excluded from storing location information for remote storage objects. In this embodiment, the UUIDs of these realms may be excluded from consideration in the realm selection technique.","In one embodiment, storage objects may have a limited lifetime, and various storage objects may be deleted or destroyed at times. In one embodiment, when a storage object is deleted, the node that stored the storage object may communicate with the nodes that store location information for the storage object to cause them to discard the location information.","It is noted that the method described above represents exemplary embodiments only, and numerous alternative embodiments are contemplated. As one example, in one embodiment when a first storage object is created on a first node, the first node may select multiple remote realms to which to send the first storage object's location information. In each remote realm, a node may be selected to store the location information. Thus, when another node needs to lookup the location of the first storage object, the node may determine the closest of these multiple realms and may send the lookup query to the closest realm, which may increase efficiency of the lookup operation in some cases. Having the lookup information for the first storage object stored in multiple remote realms may also benefit the system by increasing the availability of the location information. For example, if one remote realm becomes inaccessible, location information for the first storage object may still be obtained from another realm.","In other embodiments, it may be desirable to avoid the overhead of storing location information for each storage object in multiple remote realms. In one embodiment, in the event that a search for location information fails, a broadcast operation to find the storage object may be performed. The system may be designed so that the broadcasting does not affect scaling and performance of the system. First it is noted that in one embodiment, it is not necessary to search for or locate a storage object every time the storage object is accessed. For example, once a node determines the location of a storage object the first time, it may not be necessary to perform subsequent lookup operations for subsequent accesses. Also, it is only necessary to do the broadcast search when a failure causes the location information for the given storage object to be lost or when the node having the location information cannot be accessed. Also, in one embodiment nodes in the system may maintain routing information in such a way that a full broadcast over nodes in the system is not required. Routes toward the storage object may be remembered so that nodes that have not experienced failures do not need to broadcast, but instead just send a search request on the route towards the storage object.","In various embodiments, the methods described above may be employed in systems that utilize any of various kinds of messaging or addressing schemes. In one embodiment, the methods may be utilized in a system that utilizes \u201crole-based addressing\u201d based on a tree-based view of the network. In one embodiment, a role may be associated with each storage object. Thus, to send a message to a desired storage object (e.g., to access the storage object), a message may be sent to the corresponding role. As described below, each role may have multiple instances located on multiple nodes. Each replica of a storage object may have a corresponding role instance on the respective node on which the storage object is located. Thus, a message may be sent to all the replicas of a storage object by sending the message to all the instances of the corresponding role. One embodiment of a system that utilizes role-based addressing is described in detail below.","According to one embodiment, the T&R layer software  may provide client application software  with a tree-based view of the underlying link mesh as a means of exchanging messages between nodes . For example, trees referred to below as \u201cnode trees\u201d and \u201crealm trees\u201d may be utilized to perform such operations as storing and looking up the location information for a first replica of a storage object. As used herein, a tree may comprise an undirected, acyclic, and connected sub-graph of the underlying link mesh . Each vertex in a tree may be a node . Each connection between nodes  in a tree is referred to herein as an edge. Thus, each tree effectively comprises a subset of the link mesh.","As described below, a portion of the T&R layer software, e.g., builder , executing on the nodes  may be operable to create tree data structures based on the link mesh . Multiple trees may be created based on the link mesh . Client application software  may utilize the trees to send messages to other nodes . For example, client application software  executing on a node A may invoke router  on node A through an application programming interface (API). Router  may send the client's message to another node B. Router  executing on node B may forward the message to another node C, and so on, until the message arrives at its destination node X. At each node, the message may be forwarded according to routes based on a tree created by builder  on the respective node. For example, a route may specify a tree edge over which to send the message. Thus, at each node the message may be sent over one of the tree edges, which may be mapped to one of the node's links, i.e., the virtual communication channel used to actually send the message.","Router  executing on destination node X may notify client application software  executing on node X of the received message, and client application software  may process the message accordingly. As described below, the T&R layer software may also handle one or more responses returned by the client application software  at node X to the client application software  at sender node A. These responses may include a variable amount of application data.","Using trees as a basis for sending messages between nodes may be advantageous in several ways. As described below, each tree may have one or more nodes that may be addressed by a \u201crole\u201d. Each message may be addressed to a particular role on a particular tree. Thus, when the message is sent to the role associated with the tree, only nodes attached to the specified tree (or a subset of nodes attached to the specified tree) see the message, e.g., as opposed to all nodes on the link mesh seeing the message. The T&R layer may also be able to detect and discard duplicate messages automatically. Also, an ordered delivery of messages may be enforced based on the position of the sender node and receiver node(s) on the tree.","In one embodiment, the concept of a message response may be directly supported by the T&R layer. The concept of a response including data is not directly supported by protocols such as UDP or TCP, but instead must be provided by the application layer. Thus, application programmers for a client application that utilizes the T&R layer may be relieved from the burden of implementing a separate response protocol. In other words, the concept of a message response including data may be integrated in a \u201csender to receiver back to sender\u201d protocol provided by the T&R layer. As described below, in one embodiment each message sent may have a variable number of responses.","To send a message, client application software  may create a data structure that contains an application header  and application data . The client application software may then request the T&R layer software  to send the message (including the application header  and application data ) to client application software executing on another node . It is noted that both instances of the client application software may utilize a common tree.","Before invoking the lower level network software  to send the message to the destination node , the T&R layer software  at the sender node  may create its own data structure including a T&R layer header  and the message received from the client application. Similarly, a link layer and transport layer may build their own data structure including their own respective headers, as shown in . On the receiving end of the message transfer, each protocol layer (e.g., transport, link, and T&R) may un-wrap its own message from its header, until finally the client application software at the destination node receives its message.","Role-Based Addressing","Most message-based protocols require some addressing scheme to name a destination endpoint as the target of a message. IP-based protocols for example, use an IP address to name a node on a network.","According to one embodiment of the T&R layer, message addressing is based on the concept of a \u201crole\u201d. As used herein, a role may refer to a location-independent address for a computer network. A location-independent address may comprise information usable to address a message without specifying where the message recipient is located in the network, e.g., without specifying a particular node in the network.","The T&R layer may include an interface allowing client application software to create a role on one or more nodes on a tree (more specifically, the client application software may create an instance of the role on each of the one or more nodes). Each node on which an instance of the role is created is said to have the role or host the role (or host an instance of the role). In one embodiment, each role may be identified using a string, e.g., the name of the role. In other embodiments, roles may be identified in other ways, e.g., using integers.","Thus, a complete network address for sending a message may comprise information identifying a tree and a role on the tree. For example, in one embodiment the tree may be identified using a tree ID, such as a 128-bit Universally Unique ID (UUID), and a role may be identified using a variable length string. (Universally Unique IDs or UUIDs may be allocated based on known art which ensures that the UUIDs are unique. Any node may allocate a UUID without having to communicate with another node, which may be advantageous in terms of efficiency.)","In another embodiment, a network address for sending a message may also include information identifying a portion of client application software to receive the message. For example, the network address may also include information identifying a protocol ID associated with a client application that utilizes the T&R layer. Multiple protocols may utilize the same tree. Thus, each message may be sent on a particular tree and, more particularly, to a particular set of nodes on the tree, i.e., the nodes having the specified role. As the message arrives to each node on the specified tree and having the specified role, the protocol ID may be used to determine which protocol on the node or which portion of client application software receives the message. In another embodiment there may not be multiple protocols, or a message may be sent without specifying a particular protocol ID. If no protocol ID is specified, the message may be delivered to all protocols bound to the tree.","Any semantic meaning associated with a role may be done so by the client application and not by the T&R layer. For example, roles such as \u201cowner\u201d or \u201cinstrumentation-manager\u201d may appear to the T&R layer as just two different strings that each designate a separate target on a tree for message transfers. The T&R layer may treat client application messages simply as a set of bytes.","Sending messages to roles instead of directly to nodes may have a number of advantages. For example, a given role may be assigned to any tree vertex (node), and the role may move from node to node dynamically. Also, a single role may be assigned to multiple tree nodes. Thus, a message addressed to the role may reach each of the nodes which have the role.","Role-based addressing may also allow distributed software to run in a peer-to-peer manner. Nodes do not need to keep track of global state, such as knowing which other nodes are present on the network or which roles are bound to which nodes. A node may simply accomplish an operation by routing a message to a particular role, without needing to know which particular node or nodes have the role.","A role which is restricted to a single node is referred to herein as an exclusive role. A role which is associated with multiple nodes is referred to herein as a non-exclusive or shared role. (It is noted that a non-exclusive role may be associated with a single node.) Each instance of a shared role may have an associated role instance ID, such as a 128-bit UUID.","Each node may maintain a list of role instances which are associated with that node for each tree, i.e., a list of local role instances hosted by that node. The node may also maintain routing information that allows messages to be routed from the node to remote instances of the role, i.e., role instances associated with or hosted by other nodes. For example, the routing information may define one or more edges for the node. Each edge may be mapped to one of the node's links and may be used to route a message to one or more remote instances of a role. Each link may support many mapped tree edges. Thus, at each node along the message path from a sender node to the target node(s), the node may deliver the message to a local instance of the role (if there is one) and may forward the message to other role instances using the respective edge or edges.","In one embodiment, at each node, the routing information for a given role may include information directly specifying how to route a message to every instance of the role. For example, for each node, the node may have an edge associated with each instance of the role, where each edge points to another node to which or via which the message can be sent to the respective role instance. The role name and the instance ID for the respective instance of the role may be associated with each edge, allowing the edges to be disambiguated for shared roles.","In another embodiment, the routing information at one or more nodes may include information directly specifying how to route a message to only a subset of the role instances. Thus, if there are N instances of the role, a given node may have knowledge of less than N instances of the role. As one example, a first node may have knowledge of only a single instance of the role. For example, the first node may have an edge associated with a particular instance of the role, such that messages addressed to the role are routed to a second node to which the edge points. The second node may in turn have two or more edges, each associated with different role instances, such that messages addressed to the role and received from the first node are forwarded by the second node to multiple nodes, and continuing in this manner until each instance of the role receives the message.","The embodiment in which nodes can have routing information regarding only a subset of the role instances may allow nodes to leverage each other's knowledge. Thus, routing data may be localized, i.e., the routing data does not have to be published to every node on the tree. This may increase efficiency of the system. Allowing nodes to leverage each other's routing information may also enable recovery operations to operate more efficiently to rebuild routing information after a link failure.","One example of a technique for allowing a given node to maintain routing information for less than all N instances of a role is to utilize scoped roles. In a system employing scoped roles, each node that does not host an instance of the role must know how to reach only one node that has the role (if there is one). Each node that does host an instance of the role must be able to eventually reach all other nodes that host an instance of the role.","Client applications may utilize an API to manage roles in various ways. For example, in one embodiment client applications may be able to perform the following tasks related to roles:\n\n","Publishing a Role","Client application software may create or publish a role (by requesting the T&R layer to publish the role) in order to establish an address on a tree. The client application software may also remove or un-publish the role to remove the address. In one embodiment, creation (publication) and removal (un-publication) of roles may also be initiated by the T&R layer. The process of publishing a role instance may cause a series of edges to be created from a set of potential sender nodes to the target node on which the role instance is published.","In one embodiment, publishing a role instance is accomplished by broadcasting publish messages from the publishing node to other nodes. In one embodiment, the publish message may be broadcast using a particular broadcast scope as described below. At each node that receives the publish message, an edge may be created that maps upon the link over which the publish message was received (or an existing edge may be updated with information to indicate that the edge is also usable to route messages toward the new role instance). The result is a series of edges distributed over a set of nodes, each edge pointing toward the role instance that was published. Un-publishing a role may cause existing edges to the role to be removed.","Each node that receives the publish message may forward the publish message to one or more other nodes, e.g., according to the broadcasting scope used. In one embodiment, a node which receives the publish message and already hosts another instance of the role may not continue forwarding the received publish message for the new instance. This may allow the type of routing data localization described above.","The publish message may include a message ID (e.g., a UUID) that uniquely identifies the respective publish operation. This enables the publish message to be distinguished from any other message being sent. Each node that receives the publish message may stop forwarding the publish message if the node has already received the publish message (as identified by its message ID).","As noted above, in one embodiment the publish message (as well as other types of messages) may be broadcast using a particular broadcast scope. For example, a \u201cbroadcast on all links\u201d, a \u201cbroadcast on tree\u201d, or a \u201cbroadcast on role routes\u201d type of broadcast may be performed. The type of broadcast may determine what links are chosen at any given node to continue forwarding the message. For the broadcast on all links type, the message may be sent on all links from each node that receives the message. For the broadcast on tree type, the message may be sent on all links that correspond to existing edges of the tree (i.e., edges that were created by previous publish operations). For the broadcast on role routes type, the message may be sent on all links that correspond to edges pointing to previously published instances of the role.","In the case of a broadcast on tree operation, if the tree is not \u201cfully built\u201d (described below) at the local node, the message is forwarded over all links from that node. (This does not affect how further nodes forward the message.) Similarly, in the case of a broadcast on role routes operation, if the role is not fully built (described below), and if the tree is fully built, then the broadcast reverts temporarily to broadcast on tree. If the role is not fully built, and the tree is also not fully built, the broadcast reverts temporarily to broadcast on all links.","In one embodiment, the information that is broadcast for a Publish operation (or an Un-publish operation) may include:\n\n",{"@attributes":{"id":"p-0185","num":"0195"},"figref":["FIGS. 31-36","FIGS. 37-45"]},{"@attributes":{"id":"p-0186","num":"0196"},"figref":"FIGS. 46-52"},"As noted above, a role instance may be designated as exclusive when it is the only instance of the role. Publishing a role instance as an exclusive instance of the role may cause any existing edges to other instances of the same role to be removed or overwritten. In the event that a simultaneous publish of role instances is attempted where each instance is intended to be exclusive, the instance IDs of the role instances may be used to ensure that only one role instance is actually recognized. For example, the role with the largest (or smallest) instance ID value may win.","An un-publish operation for an exclusive role instance may cause all edges to the role to be removed on all nodes. An un-publish exclusive operation may be performed even when there is no local role instance to remove.","It is possible that one or more nodes in a network may fail.  illustrate the process of publishing a role on a network in which a node has failed.","When nodes or links fail, affected tree edges (i.e., those edges mapped to the broken link or links) become broken and need to be repaired. In one embodiment, trees may be allowed to remain with broken edges in an incomplete state such that not all routes to all roles have been determined at every node. Each tree may be repaired or recovered independently at the time the tree is next needed by a send operation. The recovery operation may result in not finding some roles if a node with a role no longer exists. Therefore, the T&R layer may employ a timeout mechanism to terminate the recovery operation if necessary. Tree recovery is described in detail below.","In one embodiment, it may also be the case that temporary cycles exist in a tree. The T&R layer may be operable to detect cycles and fix them with no loss of messages or message ordering. Detecting and breaking cycles is described in detail below.","As described above, a message addressed to a role or virtual network address may be sent to a set of physical nodes attached to a single tree by utilizing a series of edges. The physical location of the role or virtual network address may advantageously be re-mapped. As noted above, roles may dynamically move from one node to another node. The T&R layer may move or re-assign a role from one node to another node when instructed to do so by the client application software. For example, in one embodiment, the message response mechanism provided by the T&R layer may include an option allowing a message receiver node (the current role owner) to give up the role to a node which sends a request role message. Thus, the role may move from the message receiver to the message sender. The message receiver node may also grant the role to the message sender node without giving up the role, so that the two nodes each have an instance of the role.","When the role is granted without give-up, the sender node may publish a new instance of the role. In one embodiment, moving the role from the message receiver node to the message sender node (i.e., when the receiver node gives up the role) may be accomplished by first un-publishing the role from the receiver node and then publishing the role at the sender node. In a more efficient embodiment however, edges on affected nodes may simply be re-pointed toward the sender node, eliminating the need to un-publish the role and re-publish the role at the new location. In this re-pointing operation, edge updates may be localized to just those nodes along the message path from the sender node (new role holder) to the receiver node (previous role holder). Also, the messages that would be sent to perform a complete unpublish\/re-publish sequence may be avoided, thus increasing efficiency of the system. , referenced below, illustrate an example of re-pointing edges along a message path to point toward the sender of a message.","Routing","As described above, client applications and the T&R layer may view the system  as a set of trees, each with a set of assigned roles. Routing may occur from a sender to a role within the context of a single tree. Each node  in the system  may act as a message router.","As described above, messages may be routed by associating a series of edges with a role. At each node along the message path, an edge (or multiple edges) at that node serves to point towards the target node (or nodes) that has the desired role. Some nodes that route messages may also be a message destination. Other nodes may act solely as a router, never assuming a role. Messages may continue to be routed until all role instances have been reached.","Trees and Tree IDs","As noted above, each tree may have an associated ID which identifies the tree. For example, in one embodiment, a tree ID may comprise a unique 128-bit UUID. The tree ID may be valid for all network nodes. In one embodiment, the T&R layer may accept the tree IDs from client application software as a means for naming the trees. In another embodiment, the T&R layer may be responsible for creating the tree IDs.","The T&R layer software may associate edges with each tree ID. As described above, each edge may be mapped onto an underlying link. This mapping may give each edge a direction away from the local node and towards another node. For each edge, one or more roles that are found in the direction of the edge may be associated with the edge.","Routing Table Management","The T&R layer software on each node may maintain routing information. For example, for each particular tree for which the node has routing data, the node may have information specifying roles on the tree to which the node has routes. For each of these roles, instances of the role may be mapped to edges, as described above.","In one embodiment, the routing information may include routing entries stored in one or more routing tables. In various embodiments, the routing entries may be structured in any of various ways and may comprise information of varying levels of granularity. For example, in one embodiment each routing entry may be associated with a particular role and a particular tree and may specify one or more edges that point toward instances of the role.","According to one embodiment, two routing tables may be used to hold routing entries. The first routing table is referred to herein as the primary routing table. The primary routing table may be stored in the memory  of the node. The second routing table is referred to herein as the secondary routing table. The secondary routing table may be stored in the storage  of the node. In one embodiment, the routing entries in both the primary routing table and the secondary routing table may be the same. In another embodiment, the primary routing table may be used to store the most recently used routing entries, and the secondary routing table may be used to store other routing entries. Routing entries may be swapped in and out of the primary routing table from the secondary routing table as necessary, similar to the manner in which data is swapped in and out of a memory cache. In another embodiment, there may be only one routing table.","In one embodiment, information regarding local role instances for the node may not be maintained in the routing table(s). The information regarding local role instances may be maintained as long as a node is up. If a node fails, routing information for remote roles may be rebuilt when the node comes back up.","As the number of nodes  in the system  increases, one or more of the nodes  may run out of memory  and may also possibly run out of storage  so that all edges to all roles throughout the network cannot be maintained on the local node. In one embodiment, this problem may be solved by enabling the T&R layer to remove least recently used routing entries from the routing table as necessary. For example, for a routing table stored in the memory , if an out-of-memory situation occurs or is near for the memory , or if a routing table reaches a maximum size, then the routing entry that was least recently used may be removed from the routing table, e.g., so that a new routing entry can be added in its place. Similarly, for a routing table stored in the storage , if an out-of-storage situation occurs or is near for the storage , or if the routing table reaches a maximum size, then the routing entry that was least recently used may be removed from the routing table. This may allow new routing entries to be added to the routing tables as necessary.","If at a later time the node ever needs a routing entry that was replaced in the table, the routing entry may be re-created. For example, if the routing entry corresponded to a first tree and the node needs to forward a message addressed to a role on the first tree, then the first tree may be rebuilt, or information regarding the first tree may be re-acquired.","Fully-Built Roles and Trees","As used herein, a role is said to be fully built on any given node when edges leading to all instances of the role on all other nodes have been created for that node or when the node has sufficient edges so that a message addressed to the role eventually reaches all instances of the role when sent in the manner described above. For example, a role on a given node may be fully built when the node has sufficient edges to neighbor nodes such that a message sent to the role using those edges is ensured to reach all instances of the role, provided that the neighbor nodes each ensure that they are fully built before forwarding the message.","In one embodiment roles may be \u201cscoped\u201d, meaning that a node that does not have a role must know how to get to only one node that has the role (if there is one). Nodes that do have the role must be able to eventually reach all other nodes with that role.","In one embodiment a role is considered fully built once one of the following conditions has been met:\n\n","A tree is said to be fully built on any given node if all of the tree's roles are fully built on that node. It is noted that in some situations a tree may be marked fully built, while a role associated with the tree is marked not fully built. This may occur when a new role is published. The role may be initialized to not fully built, while the tree is initialized to fully built. A tree may be marked as not fully built only if one of its roles has gone from fully built to not fully built. Once each of a tree's not fully built roles has been rebuilt (and marked fully built) the tree may be again marked as fully built.","In one embodiment, when a new node joins the link mesh, the node may need to gain access to trees. This may be accomplished by using a simple request\/response protocol that yields the set of known tree IDs. The new node may then create its own edges to point towards existing roles on the tree. Once this process is accomplished, each tree and each of its roles may be marked as fully-built for the new node.","When a link fails at a node, all roles that have edges over the failed link may be marked as not fully built for the node. As noted above, a recovery operation may be performed when necessary to send or forward a message to one of the roles that previously was pointed to by an edge over the failed link.","Sessions","Because each role may be shared by different nodes, a message sent to a single role may be delivered to many nodes that in turn send one or more responses or replies back to the sending node. In one embodiment, the T&R layer may utilize a session mechanism to support this one-to-many reply model. The session mechanism may facilitate the automatic routing of responses back to the original sending node.","According to one embodiment of the session mechanism, a long-lived state information element referred to herein as a \u201cbreadcrumb\u201d may be stored at each node along the message path. The breadcrumb (state information) may point back via a link towards the original message sender. An initial breadcrumb may be created in response to each send operation. The initial breadcrumb may indicate that the original sender is on the current node, e.g., may indicate this via a null link. As the message is forwarded on to other nodes, a new breadcrumb may be created on each receiving node, where the breadcrumb points back over the link by which the message was just received.","As a result, a trail of breadcrumbs may compose a route from the target receiver node back to the original sender node and passing through all the intermediary forwarding nodes. When the receiver node responds to the message, the incoming link specified in the breadcrumb may be used to route the response back to the sender. Similarly, each of the forwarding nodes may use the links specified in their respective breadcrumbs to route the response back to the sender node.","In one embodiment, breadcrumb elements may remain active until a response is marked as \u201clast reply.\u201d When all last replies from all receivers of the message have been received over a link, the breadcrumb element at the local node may be deleted, thus preventing any more replies. Thus, the session may be created when the send operation is initiated and ended when all \u201clast reply\u201d responses have been processed. Each response, whether it as a \u201clast reply\u201d response or not, may be propagated to the sender as it is generated and may not be held by nodes along the message delivery chain.","In one embodiment, an alternative means of ending the session using aggregated replies may also or may alternatively be provided. According to the aggregated reply model, all responses may be held at a given node until all \u201clast reply\u201d responses have arrived at the node from target destinations to which the node forwarded the original message. Aggregated replies work by consolidating each individual response into a single response that is matched with the send that was previously issued. As the send operation fans out to more nodes, responses are returned (using the breadcrumb elements). The responses may be consolidated at each forwarding node. Not until the consolidated response is completely built (with all individual responses included) is the single consolidated reply passed back towards the original sender.","If a send has been issued, and then a link fails at a node along the message delivery chain, the T&R layer software at the node where the link failed may automatically generate a response, referred to as a null reply, that indicates the failed link. This null reply may be treated like all other responses, working in both aggregated and non-aggregated sessions. If the sender receives no null replies, the sender knows that it has received all the responses from the various receivers once the last reply comes back. However, if a null reply comes back, the sender knows it has not received all replies, and thus may re-send the message.","Also, if no role instance can be reached then the T&R layer software may return a role not found message to the sender. Thus, the sender may receive either a role not found response or one or more responses with the last one indicated, which in the absence of a null reply indicates that all responses have been received. These features may enable the sender to send messages without utilizing or depending on a timeout mechanism.","In various embodiments, the T&R layer software may determine that no role could be reached using any of various techniques. For example, the router on a given node may experience the role not found condition when it can no longer reach any role instances. When this occurs, a role not found message may be returned to the node that forwarded the message. However, the role not found message may not be forwarded back any further unless that node receives a role not found message from all links over which the node forwarded the message. For example, if node A forwards a message to nodes B and C, and node B returns a role not found message to node A, and node C returns a response other than a role not found message, then the role not found message sent from node B to node A may be ignored. Thus, for a role not found message to get all the way back to the sender, all nodes that received the message must have been unsuccessful in attempting to reach the role.","In one embodiment, the T&R layer software may also or may alternatively support a one-way send model in which replies to a message are not allowed, and thus sessions are not utilized. For example, one-way send operations may be useful for broadcasting information that does not warrant a reply. Breadcrumb elements may not be created when a one-way send operation is performed.","Listeners","In one embodiment, the T&R layer may support listener ports through which client application software at a given node can listen for messages. A listener port may connect one or more listening clients with one or more trees that are bound to the listener port. Client application software can listen to all messages sent on a tree, even those not addressed to the local node. Client application software that listens to all messages (regardless of role) is referred to herein as a snooper.  illustrates the snooper concept.","Client applications may utilize application listener ports to receive information from the T&R layer. For example, through application listener ports, client applications may be notified of messages received from senders, responses to messages (replies from receivers), and events fired. A listener port is somewhat similar to the concept of a socket. Client software listeners may be added to and removed from a listener port. Also, the listener port may be opened and closed as desired. Each listener port may implement an interface to accept events generated by the T&R layer, messages, and responses to messages.","Each listening client may supply the T&R layer software with a set of callback methods or functions. These callback methods or functions may be invoked by the T&R layer software when a message or response is delivered over the local node or when a message delivery cannot be accomplished. A listener method may also be called to announce the routing of a tree through a node. At each invocation, the listening method may be passed a parameter specifying either a message being sent or a response being returned. As described below, a listening client may perform any of various actions in response to a message or response.","Message and Response Structure","In various embodiments, a message and a response may be structured or implemented in any of various ways and may include any of various kinds of information. In one embodiment, each message includes the following information:\n\n","Tree Building","As described above, the T&R layer may perform a tree building process. There are many situations in which a tree building process may be performed. For example, tree building may be performed when:\n\n","In various embodiments, any of various techniques may be utilized to build trees. In one embodiment, trees may be built using local state and messages received from neighboring nodes. In one embodiment, instead of using a tree building algorithm that avoids cycles, cycles may instead be detected and broken. This may be more efficient than avoiding cycles. In one embodiment, trees may not be immediately repaired when a link fails. If there are a large number of trees, it may be too inefficient to repair all the trees. Instead, each tree may be repaired as needed, e.g., when a message send operation requires it.","A tree cache mechanism may be utilized to support more trees than can fit into memory at one time. Each node may maintain its own tree cache, e.g., a primary or secondary routing table such as described above. The tree cache may include a list of known trees. The tree cache may be managed using a \u201cleast recently used\u201d replacement policy as described above. In one embodiment, the tree cache may be configured to utilize a \u201cno replacement\u201d policy if desired, so that the size of the tree cache is unbounded. A \u201ctree built\u201d event may be fired to all listeners when a tree is added to a tree cache.","As shown in , each node may maintain information  related to the T&R layer. The information  may include information  pertaining to local roles for all trees, i.e., all roles which exist on that particular node. The information  may also include tree cache information or routing information , as described above. Each of the smaller rectangles illustrated within the tree cache  in  may represent a tree.","In various embodiments, trees may be represented using any of various types of data structures.  illustrates tree representation according to one embodiment. This tree representation makes it easy to get all links towards all instances of a role. It is also easy to get all links to perform a broadcast operation on a tree. It is also easy to update the tree representation in the event of a link failure (described below). According to the tree representation shown in , local roles may be maintained at all times while the local node is up. Routes to remote role instances, however, can be rebuilt.","As described above, the T&R layer may utilize the concept of \u201cfully built\u201d roles and \u201cfully built\u201d trees.  illustrates a state machine showing state changes for the fully built status. As shown, when a new node joins the network and gets on all trees (all fully built trees), each of the trees and all its roles may be marked as fully built. Also, once a recovery operation completes for building routes to a particular role, the role is marked as fully built.  also illustrates that when a link fails, all roles that have routes over the failed link (and the trees with which the roles are associated) are marked as not fully built. Also, in some situations when breaking routes or reversing routes, roles may be marked as not fully built. Changes in the fully built status of roles and trees are discussed in more detail below.","Broadcast Operations","In one embodiment, broadcast operations may be performed at various times during the tree building process. Several types of broadcast operations may be performed, including a broadcast on all links, a broadcast on a given tree, or a broadcast on all role routes.","For the broadcast on all links operation, an initial node may send a message on each of its links, identifying the message with a unique message ID. Each receiving node may then recursively send the message on each of its links. In one embodiment, each receiving node may be allowed to modify the message. Receiving nodes may maintain a hashmap keyed by message ID so that messages can be dropped to eliminate cycles. The message is thus effectively sent to all nodes in a tree fashion. One exemplary use of the broadcast on all links operation is to send a \u201cGot trees?\u201d message, i.e., a message sent during the process of a node getting on all trees at node startup time.","The broadcast on tree operation may be performed similarly to the broadcast on all links operation, except a specific tree is specified. Each time a node forwards the message, the specified tree is used, provided that the tree is fully built for that node. If the tree is not fully built for that node, then the message may be sent on all of the node's links. Cycles may be eliminated similarly as for the broadcast on all links operation.","The broadcast on role routes operation may be performed similarly to the broadcast on all links operation, except a specific role on a specific tree is specified. Each receiving node may forward the message on all the links that correspond to routes to the specified role, provided that the role is fully built for that node. If the role is not fully built for that node, then the message may be sent on all of the node's links. Cycles may be eliminated similarly as for the broadcast on all links operation. One exemplary use of the broadcast on role routes operation is to recover routes to the role. Another exemplary use is to publish an instance of a role.","Getting on All Trees","When a node joins a network, the network may already have trees unless the network is new. In one embodiment, the following process may be performed for a node to get on all trees. First, the node may broadcast a \u201cGot trees?\u201d message using the broadcast on all links operation described above. If no response is received within a given timeout interval, then the process may be done (since there are no trees).  illustrate an exemplary tree building process when a group of nodes joins a network, and a tree spanning the nodes is built. If it is determined that there are trees and the node is not on all trees, then the node may request all trees from each neighbor. If not on all trees, each neighbor may in turn request all trees from its neighbors in a recursive manner. Cycles may occur, but only one request to each neighbor is performed. Once a node is on all trees, the node may supply all the trees to each requesting neighbor. A receiver of trees may receive some trees from each neighbor to avoid getting all trees over one link.","Routing","As described above, in one embodiment of the T&R layer, a message routing engine  may manage the routing of messages. The message routing engine on a particular node may be invoked by a client application using an application programming interface (API) or may be invoked in response to receiving a message via a link.","Client applications which receive a message from a sender may reply to the message with one or more responses. The response(s) may be routed back to the sender over the same route that was used to send the message. The API for sending a response may include parameters specifying the ID of the message being responded to, the response (e.g., an array of bytes and size of the array), as well as parameters specifying various options.","In one embodiment, the concept of a session may be utilized to allow a message sender to receive multiple responses to a message. A \u201clast reply\u201d Boolean value (e.g., a value included in the response header or a parameter passed when sending a response) may be set to True when the last response to the message is sent.  illustrates an exemplary session. As shown, a sender sends a message to a receiver. The receiver sends four response messages back to the sender. In the fourth response message, \u201clast reply\u201d is indicated.","The message routing API may also allow a sender to send a message to only one role instance. The send process may be complete once a first role instance receives the message. (The session may continue until the last reply from that instance.)","In one embodiment, the T&R layer may support aggregate responses such that the sender receives a single response message which includes all responses from all receivers. The client application listener on the sender may not be invoked until all responses have been received. Thus, the client application may synchronize with multiple responses.","In another embodiment, the sender may receive each response as a separate response message. In one embodiment, the T&R layer may support one-way messaging so that responses by receivers of a message are not allowed. In one embodiment, each message may be handled using the messaging technique desired by the sender, e.g., aggregated responses, separate responses, or no responses.","In one embodiment, responses may flow back to the message sender over the original path by which the message was received.  illustrates an exemplary network in which a message is sent from a sender node  to a receiver node . For example, the message may be addressed to a role on the receiver node . The path of the message is illustrated. As shown in , a reply sent by the receiver node  is sent over the same path.",{"@attributes":{"id":"p-0252","num":"0282"},"figref":["FIG. 78","FIG. 79","FIGS. 80-86"],"b":["320","321","321","321","321","321","321"]},"As noted above, the API for sending a response may include parameters specifying various options or other information related to the response. For example, the receiver of the message may send the response with a parameter to give up a role and\/or grant a role to the sender, e.g., in response to a request for the role sent by the sender. Valid combinations may include:\n\n","As another example, the response may be sent with a \u201clast reply\u201d parameter indicating that the response is the last reply to the message, as described above. Any given recipient of the original message may set the \u201clast reply\u201d parameter to True only once.","In one embodiment the T&R layer may change the \u201clast reply\u201d parameter in some situations. For example, if \u201clast reply\u201d is set to True, a node forwarding the response along the route may change \u201clast reply\u201d to False if the node has an outstanding link on which it has not yet received a response with \u201clast reply\u201d set to True or if the node has not yet received a response from a local client (a client application on that node which received the original message from the sender) with \u201clast reply\u201d set to True. This ensures that the sender receives only one response with the \u201clast reply\u201d parameter set to True, even though multiple responses may originally be sent from receivers of the message with the \u201clast reply\u201d parameter set to True. In another embodiment, the sender may always receive response messages having the original \u201clast reply\u201d parameter values set by the respective recipients, and the sender may keep track of which recipients it has received a last reply from and which it has not.","As noted above, when a recipient node with a role instance issues a reply with a \u201cgive up role\u201d parameter set to True, the role instance may move to the sender node. In one embodiment, this may be accomplished by performing an un-publish operation to remove the role instance from the recipient node, followed by a publish operation to add the role instance to the sender node. However, in another embodiment a more efficient technique of moving the role instance to the sender node may be utilized. The more efficient technique is based on the observation that only routes maintained by nodes along the path of reply (which is the same as the path over which the original message was sent) need to change. Thus, each time after the reply with the \u201cgive up role\u201d=True parameter is forwarded by a node, the route on that node may be re-pointed to point in the direction in which the reply was forwarded, i.e., to point in the direction from which the original message sent by the sender node was received. Thus, the next time that node receives a message addressed to the role, the message may be routed in the direction of the node which now has the exclusive instance of the role (i.e., in the direction of the original sender node which requested the role).",{"@attributes":{"id":"p-0257","num":"0290"},"figref":["FIG. 87","FIG. 88","FIG. 89"],"b":["330","331","330","331","330","331"]},"As illustrated in this example, the original message is propagated from node  to node  via a plurality of intermediate nodes. As described below, a message record for the original message may be created on each intermediate node. The message record may specify information regarding the original message, including information specifying the link by which the intermediate node received the original message.","The response message is propagated from node  to node  via the same plurality of intermediate nodes. As each intermediate node receives the response message, the intermediate node may retrieve the message record for the original message and examine the message record to determine the link by which the intermediate node received the original message. The intermediate node may then change its routing information for the role so that subsequent messages addressed to the role are forwarded over the link by which the intermediate node received the original message. Thus, subsequent messages may be forwarded in the direction of node  which now holds the role.","In one embodiment, each intermediate node may store the message record for the original message in a hash map. For example, the hash map may map the message ID of the original message to the message record for the original message (i.e., the hash map may be keyed by message ID). The response message may include information specifying the message ID of the original message. Thus, each intermediate node may obtain the message ID of the original message from the response message and look up the message record using the message ID of the first message. In one embodiment, the ID of the response message may be identical to the ID of the original message. Thus, the intermediate node may simply use the ID of the response message to look up the message record for the original message.","Events","In various embodiments, any of various kinds events may be generated by the T&R layer in response to certain situations. Client applications may be notified of particular events through application listener ports. The following describes some exemplary events which the T&R layer may utilize.","Tree Built event\u2014indicates that a tree has been constructed or a tree object has been instantiated. The Tree Built event may include information identifying the protocol (e.g., client of the T&R layer) that caused the tree to be created. Thus, applications may learn about new trees by receiving Tree Built events. As described below, in one embodiment an application may create a snooper in response to a Tree Built event.","Role Not Found event\u2014indicates that a message was not delivered to any instance of the role to which it was addressed.","Snooping","As shown in , in one embodiment the T&R layer may allow client software to act as a snooper. A snooper may intercept messages sent from a sender to a receiver and may intercept any responses sent from the receiver to the sender. The snooper client may be located on any node between (and including) the sender node and receiver node. In various embodiments, the snooper may be able to take any of various actions in response to intercepting a message or response message. For example, the snooper may simply allow the message or response to continue on its way unaffected. The snooper may also alter the contents of the message or response if desired, or may replace the message or response with a completely different message or response. Response messages may be appended or replaced. The snooper may also consume or suspend the message or response if desired. The snooper may resume suspended messages or responses at a later time. The snooper may also store the message or response data before allowing the message or response to continue or may perform any of various other actions on the message or response data. The snooper may also be able to get information regarding the message or response message. For example, in one embodiment the message or response message may have an associated message information object having methods such as:\n\n","Each receiver of a message, e.g., the intended client recipient or a snooper, may receive information regarding where the message currently is in the message path. For example, in one embodiment each receiver may receive an Endpoint Boolean and a HasRole Boolean. An Endpoint value of True indicates that the local node is an endpoint for the message (no more roles to reach). An Endpoint value of False indicates that the local node is somewhere in the middle of the delivery chain. In this case, the receiver may be a snooper. The HasRole Boolean indicates to the receiver whether the local node has an instance of the role to which the message is addressed.","It is noted that an Endpoint Boolean may also be used during the routing of replies back to the original sender of a message. The Endpoint Boolean for a reply is False until the reply reaches the sender.","Tracking Message Status","The T&R layer may track or record various types of information related to sending messages. For example, the message routing engine may track or record information indicating:\n\n","A message record may be created when a message is sent or when a message is received. The message record may be used to track the incoming link for the message and\/or the outgoing links for the message. The message record may also be used to track outstanding replies for the message. In one embodiment, the T&R layer may be operable to perform a sweeping operation to clean up or discard old message records. The time period at which sweeping operations are performed may be configurable.","Failure and Recovery Operations","The T&R layer may be operable to perform recovery operations in response to a link failure, e.g., a condition in which messages cannot be sent over a link in the link mesh. For example, routes that use the failed link may be recovered so that messages can be sent to their destinations using different links. This section describes recovery operations which may be performed according to one embodiment.","In one embodiment, trees may not be immediately rebuilt at link failure time.","To process the link failure, the following may be performed:\n\n","For all send operations over the failed link, the T&R layer may return a null reply which indicates the link failure to the sender. This may be performed when the router has forwarded a send request over the failing link and the last reply over that link has not yet been received.","The actual recovery of a route which utilized the failed link may be performed later when required by a send operation. At any node along the message delivery chain, the role to which the message is addressed may not be fully built. If so, the message routing engine may call a method, e.g., recoverRoute( ) to rebuild routes to the role. The ID of the message being sent may be passed to the recoverRoute( )method. After the routes have been recovered (rebuilt) a method, e.g., routeReady( ) may be called to to notify the message routing engine. The ID of the message may be passed to the routeReady( )method to indicate that the message routing engine may resume routing the message using the recovered routes. This process is illustrated in .","Recovery Algorithm","In various embodiments, any desired algorithm may be employed to recover or rebuild routes to role instances. This algorithm may be performed in response to the message routing engine requesting the routes to be recovered, e.g., by calling a recoverRoute( )method as described above.","According to one embodiment of the route recovery algorithm, the following may be performed. The node at which the recovery process is begun may begin by broadcasting a recovery request using the broadcast on role routes type of broadcast, as described above. As described above, since the role may not be fully built on this node, the recovery request may initially be sent over all links corresponding to the tree. Each node which receives the recovery request may forward the recovery request on all the links used in routes to instances of the role, provided that the role is fully built for that node. If the role is not fully built for that node, then the recovery request may be forwarded as in broadcast on tree or broadcast on all links (if the tree is not fully built) operation.","Thus, the recovery requests may be forwarded through the node network until they arrive at nodes that have instances of the role. When a recovery request arrives at a node that has an instance of the role, the node may return a recovery response. The recovery response may be returned in the direction from which the recovery request came, i.e., using the link by which the recovery request arrived. If a node that receives a recovery response does not already have a route to the role instance that generated the recovery response, the node may update its routing table to indicate a route to the role instance that points in the direction from which the recovery response came.","The node may also propagate the recovery response back via a link by which the node received a recovery request, so that each recovery response from each role instance continues to be propagated back until reaching the original node that initiated the recovery request broadcast.","Thus, for each role instance, routes may effectively be built backwards from the node that has the role instance to the original node that initiated the recovery request broadcast. Once the routes have been built, this original node may forward the message being sent over the routes, as described above.","In one embodiment, a recovery request may not be forwarded further after reaching a node that has an instance of the role being recovered. As described above, in one embodiment it is not necessary that each node have routing information for all instances of a role.",{"@attributes":{"id":"p-0285","num":"0336"},"figref":["FIG. 91","FIG. 92"],"b":["462","482","462","482","468","468"]},"Suppose that node  attempts to send a message to each instance of the role. Thus, the message may be routed to node , as indicated by the route arrows from node . However, the role is not fully built at node . As described above, the role may have been marked as not fully built in response to the failed links. Thus, the route recovery algorithm may be initiated. As shown in  and described above, node  may broadcast a recovery request on all links. The broadcast on each link is denoted by the wide arrows.","As shown in , nodes that receive the recovery requests from node  may forward the recovery requests. (To simplify the diagram, not all forwarded recovery requests are illustrated.) As shown, node  may forward the recovery request over all of its links (except the link from which it received the recovery request) because the role is not fully built at node . However, the role is fully built at node  and . Thus, nodes  and  may forward the recovery request only over links used in routes to instances of the role.","When node  (which has an instance of the role) receives the recovery request from node , node  may respond by returning a recovery response to node , as described above. The recovery response is indicated in  by the curved arrow from node  to node . Similarly, node  (which also has an instance of the role) may return a recovery response to node , indicated by the curved arrow from node  to node . As shown in , nodes  and  may forward the recovery responses originating from the respective role instances to node , since nodes  and  received their recovery requests from node .","As described above, node  may update its routing table to indicate a route to the role instance at node  which points to node . Similarly, node  may update its routing table to indicate a route to the role instance at node  which points to node .  illustrates the resulting recovered routes to the respective role instances. Once the routes have been recovered, node  may forward the message received from node  using the recovered routes.","In one embodiment, a recovery request such as described above may include the following information:\n\n","Routes to role instances in the exclude list do not need to be recovered. Thus, if a node having an instance of the role is on the exclude list, then the node may not return a recovery response when the node receives a recovery request.","In one embodiment, a recovery response such as described above may include the following information:\n\n","It is possible that a link may fail while the recovery algorithm described above is being performed. A node having an instance of the role receives the recovery request via a path over which the recovery response will be sent back. If any link on this path fails, then the recovery response may not be received. Thus, when a link fails on a node, the node may return a link failure response for any pending recovery request. When the node that initiated the recovery request receives the link failure response, the node may re-issue the recovery request.","Detecting and Breaking Cycles","As noted above, in one embodiment routes created according to the methods described above may result in a cycle when a message is propagated. In one embodiment, cycles may be detected, and routes may be changed to avoid or break the cycles. It may be more efficient to detect and break cycles than to avoid the creation of routes with cycles.",{"@attributes":{"id":"p-0296","num":"0355"},"figref":["FIGS. 98-101","FIG. 98","FIG. 99","FIG. 100","FIG. 101"],"b":["475","462","482","475","469","476","469","462","476","470","482","463","463","470"]},"Routes for each role instance on the edge to be broken may be reversed. Routes for other roles may be invalidated or marked not fully built but not reversed. The routes may be reversed by pointing them in the direction of the incoming link by which the message was received. The reversal process may be continued in a backward manner toward the node which sent the message via the incoming link. Once arriving at a node that has other routes on other edges for instances of the same role, the role may be invalidated (marked not fully built) at that node, and the algorithm may be terminated. Also, if the incoming link is null at a node (e.g., the original sender of the message) then the role may be invalidated at the node, and the algorithm may be terminated.","Exemplary APIs","This section describes exemplary application programming interfaces (APIs) which client application software may utilize to interface with the T&R layer software. It is noted that these APIs are exemplary only and the method details given relate to one particular embodiment. Although the APIs and associated data types are presented as implemented in the Java programming language, various other language bindings are contemplated.","Messaging:\n\n","Message Listening Functions:\n\n","Message Listening Callbacks:\n\n","Role Management Functions:\n\n","Message Snooping Functions:\n\n","Reply (Response) Snooping Functions:\n\n","Instrumentation Functions:\n\n","Messaging","Send\u2014This function passes an array of bytes from sender to all nodes holding the specified role. Inputs to this function include:\n\n","Reply\u2014This function sends a response back to the original sender. Inputs to this function include:\n\n","The following combinations of grant role and give up role flags are valid: T\/T, T\/F, F\/x. The T\/T combination grants the role to the sender and also gives up its own local role. This combination is used to move an exclusive role. The T\/F combination grants the role, but does not give the role up. This combination is used to distribute shared roles. The F\/x combination is used to indicate that a request role was denied. In this case, the give up Boolean is ignored.","Message Listening","Listener ports serve as a callback registration point for those applications wishing to receive messages and replies to sent messages. Each port is associated with a protocol ID and can be bound to one or more trees and includes a list of listeners that are invoked in response to messages and replies arriving at a node. Ports are created with no listeners and without a binding to any tree. Note that it is only important to bind a port to a tree if a send is done which does not specify a protocol ID, since such a send is delivered to the ports explicitly bound to the tree. Port listeners can augment the routing process by giving the following routing direction to the tree layer (on a per message or reply response basis):\n\n","A port is \u201cnamed\u201d with a protocol ID. A single port can listen to multiple trees (and all trees for sends that specify the protocol ID). A typical sequence of operations is:\n\n","CreateListenerPort\u2014This function creates a new port in the closed state. Each listening port is associated with a protocol ID that names the type of port. Inputs to this function include:\n\n","GetListenerPort\u2014This function returns the listening port that is associated with a specific protocol ID. Inputs to this function include:\n\n","GetListenerPort\u2014This function returns the listening port that is bound to a specific tree ID. Note that there may not be any listening ports bound to a tree, as binding a protocol to a tree is only done when a protocol does a send without specifying the protocol ID. Inputs to this function include:\n\n","RemoveListenerPort\u2014This function closes and deactivates the listening port associated with a specific protocol ID. Inputs to this function include:\n\n","OpenPort\u2014This function activates the listening port associated with a specific protocol ID.","ClosePort\u2014This function deactivates the listening port associated with a specific protocol ID.","AddTree\u2014This function binds the listening port to the specified tree. This is only used by protocols that do a send without specifying a protocol ID. Inputs to this function include:\n\n","RemoveTree\u2014This function unbinds the listening port from the specified tree. Inputs to this function include:\n\n","AddListener\u2014This function registers the message callback interface. Inputs to this function include:\n\n","RemoveListener\u2014This function unregisters the message callback interface with the T&R layer. Inputs to this function include:\n\n","Message Listening Callbacks","The following callback functions are registered with the listening port.","MessageReceived\u2014This function is invoked by the T&R layer when a message arrives at the listening port. Inputs to this function include:\n\n","MessageReplied\u2014This function is invoked by the T&R layer when a response to a sent message arrives at the listening port. Inputs to this function include:\n\n","RoleNotFound\u2014This function is invoked by the T&R layer when a message could not be delivered to any role instance. Inputs to this function include:\n\n","TreeBuilt\u2014This function is invoked by the T&R layer when a tree is routed through the local node. Tree built events are used for:\n\n","Role Management","The following functions operate on roles assigned to the local node. Functions to operate on a single role and bulk (many trees\/many roles) versions are supported. The bulk functions may be useful when a node is booting, and needs to re-publish many roles (even on possibly different trees).","AddRole\u2014This function publishes a role. Inputs to this function include:\n\n","RemoveRole\u2014This function unpublishes a role, thus destroying all edges (routes) to the local node. Inputs to this function include:\n\n","AddRoles\u2014This function allows multiple roles on varied trees to be published in an efficient manner. The AddRoles function is passed only an array of role records. Each role record contains the arguments for an AddRole function invocation. Note that these are independent AddRole invocations, and do not have to be for the same tree.","RemoveRoles\u2014This function is a bulk version of the RemoveRole function. The RemoveRoles function is passed only an array of role records. Each role record contains the arguments for a RemoveRole function invocation. Note that these are independent RemoveRole invocations, and do not have to be for the same tree.","Instrumentation","The instrumentation functions return information about trees and the local node.","ContainsTree\u2014This function gets whether the local node contains a routing tree.","GetLocalRoles\u2014This function gets all the roles that the local node has for the specified tree.","GetNeighborNodes\u2014This function gets all the neighbors of the local node on the specified tree.","GetRemoteNodes\u2014This function gets all neighbor and remote (non-neighbor) nodes on the specified tree.","GetTreeNodes\u2014This function gets all the nodes on the specified tree. Each node specifies its neighbors. Each returned item contains a node ID and its neighbor IDs.","GetTrees\u2014This function gets the IDs of all trees that the local node knows about.","Router ","The following sections describe internal mechanisms and data structures used to route messages according to one embodiment. It is noted that the particular internal mechanisms and data structures are intended to be exemplary only. In various embodiments, message routing such as described above may be implemented in any of various ways.","Incoming and Outgoing Interfaces","In one embodiment the router  may export and implement a public T&R layer application programming interface (API), as well as an internal API. The router  may be invoked using this collection of APIs whenever:\n\n","In response to being invoked through these public and internal APIs, the router  either satisfies the request locally or uses the link layer and\/or builder  to invoke other nodes that may in turn satisfy the request locally or use another remote node instead.","In one embodiment, the router relies upon the following components (using their APIs) to satisfy requests and maintain its internal state:\n\n","Data Structures","The router  may utilize data structures to contain temporary state accumulated during the processing of messages or responses. For example, this state may be held to support replies.","Records","The router  may use a data structure called a record to hold state associated with some in-progress activity. Each record is identified, e.g., with a unique 128-bit number that is generated by the router.","A message record may be used to hold all local knowledge regarding an in-progress send including:\n\n","A link record may be used to track a single instance of a message being sent over exactly one link. The record includes the link on which the message was sent and a reference to the message record.","Maps","The router  may use a data structure called a map to store keyed data. The key may be associated with the data when the data is inserted in the map. The key may then be used to lookup that same data. In one embodiment the router  uses a number of maps to perform functions such as:\n\n","A sent messages map may be used to track each instance of a message sent over a link. For example, if the message is to be sent on two links, a link record may be created (that references the message record) and inserted twice into this map. As replies return to the sending node, the link records may be removed until all are removed.","A seen messages map may be used to hold a message record of each message seen (processed) by the router. A message record may be created and inserted in this map whenever a new message is to be sent from the local node.","An in progress route map may be used to hold message records, each denoting a message that requires a route to be recovered. The message record may be inserted in the map just before the router calls the builder, requesting that a route be re-built. The message record may be removed from the map by the router when the builder completes the recovery process.","A pending reply map may be used to hold message records inserted whenever a message is created or one is received off a link. The message record may be deleted when the last remaining reply arrives.","A suspended messages map may be used to hold message records that track listeners processing received messages. Just before the listener is invoked, the message record may be inserted. The record may be removed from the map as the result of a resume send API function invocation or when instructed to do so (via a special return value) by the listener's callback routine.","A suspended replies map may be used to hold message records that track listeners processing received replies. Just before the listener is invoked, the message record may be inserted. The record may be removed from the map as the result of a resume reply API function invocation or when instructed to do so (via a special return value) by the listener's callback routine.","A protocol map may hold listener ports. Each port may be associated (keyed) with a protocol ID. The router  may use this map to find the appropriate listener port to handle messages and responses.","Send Parameter Object","This object may be used to hold the set of send parameters associated with a particular message record. This object may encapsulate the router's message header and the sender's parameters (including sender's data). In a Java implementation, this object may be serialized into an array of bytes before being sent over a link. On the remote side of the link, the object may be rebuilt from the serialized array of bytes. As another example, in one embodiment the object may be sent as a SOAP message.","Similarly, a Reply Parameter object may be used to hold the set of reply parameters associated with a particular message record. This object may encapsulate the router's reply header and the reply parameters (including response data). In a Java implementation, this object may be serialized into an array of bytes before being sent over a link. On the remote side of the link, the object may be rebuilt from the serialized array of bytes.","Sending a Message","The process of sending a message may begin by validating the sender's invocation parameters. The tree ID and role name are verified to be non-null. If the \u2018oneInstance\u2019 option is true, the \u2018oneResponse\u2019 option is set to false. If the \u2018one-way\u2019 option is set to true while at least one of the \u2018oneInstance\u2019 or \u2018oneResponse\u2019 options are true, an error condition may be raised and the message may not be sent.","If the parameters are validated, the set of send parameters may be packaged together in a common send parameter object, which is then stored in a new message record.","If the \u2018one-way\u2019 option is false, the message record may be stored into the pending replies map. The message record may then be stored in the seen messages map. The router may then forward the message. If the forward logic returns without raising an error condition (e.g., an exception in a Java implementation), the message record ID may be returned to the calling software.","Forwarding a Message","The forward logic in the router  is the logic that moves existing messages (not reply responses) to listeners on the local node and to remote nodes.  illustrates the forward logic state machine. The forward logic may be leveraged by other router logic that:\n\n","The forward logic may begin by requesting the builder  to lookup local information about the tree and role in use. If this is a new tree on the local node, a new entry in the tree cache may be allocated. The information returned regarding the role may specify whether or not the role on the specified tree has been added on the local node and whether or not the role is exclusive.","If the local node has published the role and the \u2018oneInstance\u2019 option is true, the forward logic does not need any additional remote routes. If this is not the case, routes from the local node to remote nodes that have published the role on the tree may be looked up. If the send parameter \u2018roleID\u2019 is non-null, information about just a specific role instance may be looked up.","If a set of candidate links is found, the set may be stored in the candidate links field of the message record. Otherwise, a tree recovery operation may be required. A tree recovery operation may be required if the role is not fully built.","Next, the link layer's link interface may be queried as to all the link destinations. If any of the original sends were invoked with the local realm option, these links leading to nodes outside of the local realm may be removed from the candidate list.","If the role on the specified tree is already fully built, the router may need to raise a role not found error condition. The error condition is raised if the message has never been delivered (specified by delivery status field in the send parameter object) to any nodes and the local node also does not have the role.","If the role is not fully built and a recovery operation has not already been started, the router  may request the builder  to recover routes to the role. The message record may then be stored in the in-progress routes map until the builder's recovery operation completes. At that time, the forward logic is re-activated and the process repeats itself. In one embodiment the process may be repeated for at most one more time.","If the role is fully built and a recovery operation has already completed, the message has never been delivered, and the local node does not have the role, a role not found error condition may be raised.","If error conditions have been raised, the forward logic may be terminated, and control may be passed back to the invoking logic (e.g., send message logic).","Otherwise, if the local node has the role, the message may be given to the local listener's receive interface. If the listener's receive callback does not suspend or consume the message, the forward logic may then begin sending the message to remote nodes using the candidate links stored in the message record. If the remote send operation was successful, the forward logic exits. Otherwise, one of two situations has arisen:\n\n","Sending to Remote Nodes","For each candidate link over which to send the message to a remote node (excluding the link the message was received over) the following may be performed:\n\n","This logic may then return either an error indication or the actual number of messages sent over the links. This number matches the complete set of links in the message record sent links list. Error conditions caught here may cause the link record to be removed from the sent messages map.","If the one instance option is used, this process may be performed only once. The choice of which link to choose can either be:\n\n","New Routes Built Behind Path of Routing","It is possible that after a node A has routed a message to another node B, building initiated on node B can cause new routes to be added on node A. In one embodiment, a technique may be employed to allow node A to forward the message on the new route.","In this situation, since node A will be waiting for replies from node B (perhaps not directly), this situation is isolated to the time while node A is waiting for replies. Two internal interfaces in the builder allow the router to mark this time interval:\n\n","Whenever the builder adds a new route for a role, the builder may call the following internal interface in the router:\n\n","If the router is doing a multi-instance send, the router may then simply send the same message that is pending replies (indicated by message ID) on the newly added route (indicated by link), and may update data structures to indicate that a reply is now pending on that link also. However, if the router is doing a single-instance send, the new link may simply be added to the list of candidate links.","Role Not Found Error","A role not found condition can be detected on any node along the sending message path (e.g., when the tree is marked fully built yet no edges exist for the desired role). When this condition is detected, a special role not found reply may be generated and routed back to the original sender. When the role not found reply reaches the original sending node only, a role not found event may pushed to the sending application.","Invoking the Receiver","The router may use the protocol map to find the proper listener associated with the specified tree. If no listener is found, the invocation procedure may be terminated. Otherwise, before invoking the listener's receive interface, the router may check to see if the local node is an endpoint along the message route. This information may be passed to the receiver. The delivery status in the send parameter object may be set to true, indicating that the message has been delivered to at least one listening node. The message record may then be stored in the suspended messages map, until it is resumed. The listener's receive interface may then be invoked. After the listener returns control to the router, the return value may be checked for one of three values:\n\n","Continuing the message causes the router to resume the message along the route. Suspending the message leaves the message in the suspended message map, awaiting a future resume or consumption operation. Consuming a message removes the message on the local node so that it can no longer be forwarded or have replies issued to it.","Replying To a Message","The process of replying to a message may begin by validating input parameters, in particular, the message ID that names the message for which a response should be generated. The message ID may be used to lookup the message record in the pending replies map. A failure to find the message record can occur for the following reasons:\n\n","If the message record is not located, an error condition may be raised and control may be returned back to the caller. Otherwise, information about the role used in the message for which the reply is being issued may be looked up. If the role is exclusive, a possible error condition may be checked. That is, if the exclusive role is being granted, the giveUp Boolean must also be set to true. The last reply Boolean may also be checked. If true, some additional processing is required. If this is a last reply, the number of outstanding replies is decremented. If this is a local last reply, the message record Boolean indicating such is set to true. Otherwise, a remote link is removed from the sent links list in the message record. Finally, if no more outstanding replies are expected (local or remote), the message record may be removed from the pending replies map. Otherwise, the last reply Boolean may be flipped to false to indicate that some other replies are still expected from either the local node or from remote nodes.","If this reply is actually the specially generated role not found reply, some additional processing is necessary. A role not found reply for this message may or may not have been seen already. When a role not found is first detected (no previous instances seen), the router may check to see if it has already processed a good reply (a reply other than role not found). If so, the role not found reply may be discarded. Otherwise, the router may check to see if more replies are expected, which may in fact be good replies. If so, the reply parameter object for the role not found reply may be stored away in the message record for future role not found processing. A future good reply may cause this previously received role not found reply to be discarded. Finally, if no more replies are expected, the role not found reply is valid and may be returned to the original sender.","The reply logic may locate which role (original or one named in \u2018grantedRoleName\u2019 parameter) is to be controlled by the role manipulation booleans. The role manipulation parameters may be false and false, which conveys to the router that the role should not be granted or given up. For all other values of the role manipulation Booleans, the specific role's instance ID is required. The router may use the builder to get the role's instance ID. If the role is not being given up, a new instance may be created (shared role). If the giveUp Boolean is true, the router may instruct the builder to remove the role from the node on the specified tree.","A reply parameter object may then be created by utilizing the send parameter object in the message record and adding in the reply parameters. The reply parameters may be clustered together into a response data structure that includes the response data. The reply parameter object may be used to accumulate multiple responses at a node. The \u2018oneResponse\u2019 aggregated reply option may be checked and processed. If this is not the absolute last reply expected at this node, the set of responses may be appended to a message record list of responses.","If this is a role not found to a \u2018oneInstance\u2019 message, some special post processing may be invoked. See discussion below on single instance role not found reply processing.","If waiting for more replies to arrive, or the \u2018oneInstance\u2019 post processing has re-sent the message, the reply logic may exit. Otherwise, if the local node is the original sending node, the proper listener's reply interface may be invoked. If not, the router may find the incoming link (used to receive the original message) and use this link to send the reply parameter object back towards the original sender.","Single Instance Role Not Found Reply Processing","As noted above, when a reply to a single instance send arrives at a node, some additional processing may be performed. If there are more candidates to try, the message may be re-sent by invoking the forward logic again. As the forward logic sends messages, links are moved from the candidate list to the sent list. If the candidate list is empty when this role not found reply was processed, the role not found reply is passed on towards the original sender. Since the previously used link was removed from the candidate list by the forward logic, the next forward of the same message will pick another link to use for the re-try send.","Thus, all possible instances may be tried until one can be reached.","Receiving Messages Over a Link","When a routed message arrives at another node, the link layer on that node may invoke the T&R layer's receive handling logic. This logic may include logic common to both sent message processing and reply processing.","Common Message Processing","The received message may first be decoded from an array of bytes back into a send or reply parameter object. In one embodiment a Java implementation may be arranged so that both send and reply objects sub-class a common message object. This common message object may include a reply Boolean that is true if the message is a reply and false if it is a sent message. This object may also include the message and tree IDs common to both sends and replies.","Before dispatching to more specific processing, the common logic may check to see if this node has received a sent message already. Replies do not require the same checking because multiple replies to the same message can and do arrive at nodes. If a sent message arrives at a node twice however, the tree has a circular route. The check for circularity is accomplished by searching the seen messages map, looking for a message with the same ID. If the node has not already received the sent message, the message is added to the seen message map. If a duplicate message has arrived, the router may call the builder's break route interface to remove the edge mapped to the link on which this message just arrived. If the message is not a duplicate, the router may request the builder to find the tree with the tree ID in the sent message or reply. Once the tree is located the router may dispatch logic specific to sent messages or replies to messages, passing the tree as a parameter.","Sent Message Processing","If the reply Boolean is false (indicating that the message is a sent message), the send-specific logic is invoked. A new message record may be created to track this new message. If the message is not a one-way message, the message record may be inserted into the pending replies map. The common forward logic may then be invoked, after which control returns back to the link layer.","Reply Processing","If the reply Boolean is true (indicating that the message is a reply message), the reply-specific logic is invoked. The reply logic may use the message ID to lookup the message record that should be in the pending replies map. If the message record is not found, the reply may be discarded. This can happen if a reply took longer than a periodic sweep time assigned to a background sweeper task. Once the message record is located, the last reply Boolean may be checked in the reply parameter object. If it is true, additional last reply processing may be invoked. This processing may be the same regardless of whether the reply was issued locally (this node) or whether the reply was received over a link.","The router may next determine whether this reply has arrived at the original sending node. The original sending node will have a null value in the incoming link field of the message record. A Boolean in the reply parameter object may be set to true to indicate the arrival back where the send was issued. If the reply has arrived at its endpoint, some additional role processing may be required.","At reply endpoint nodes only, any roles that have been granted to the sender by the replying node must be assumed. At all nodes along the reply path (middle(s) and the endpoint), any role routes that point towards a removed role on the replying node may be removed or re-pointed.","The router may also perform a check for aggregation. If this is a \u2018oneResponse\u2019 send, the common (to local replies) aggregated reply processing may be executed. Also, common to local reply processing is the check for a role not found reply to a single instance send. These two checks may cause the reply to stall at this node until all outstanding replies have arrived or a single instance send does not result in a role not found reply. Finally, the reply listener may be invoked.","Invoking the Reply Listener","When invoking the reply listener, the router may use the protocol map to find the proper listener associated with the specified tree. If no listener is found, the invocation procedure may be terminated. If this is a role not found reply, the router may ensure it is delivered to the original sending node only. If this is a null reply due to a break route procedure, the router may skip delivery. A break route procedure may be used to eliminate circularity in a tree. This procedure may be performed transparently so that applications do not received null replies when generated by a break route procedure.","The message record may then stored in the suspended replies map until it is resumed. The listener's reply interface may then be invoked. After the listener returns control to the router, the return value may be checked for one of three values:\n\n","Continuing a reply causes the router to resume the reply's journey along the route back towards the original sender. Suspending the message leaves it in the suspended message map, awaiting a future resume or consumption operation. Consuming a reply removes it on the local node so that it can no longer be resumed.","Breaking a Stale or Circular Route","When the router  detects a stale or circular route, the builder  may be invoked on the node that first detected the problem (Builder B). Builder B eventually sends a special message back over the link in question. When Builder A (the builder  on the remote end of the link from builder B) receives the special message, Builder A may invoke a special router interface that generates a null reply.","Null Replies","Null replies may be generated when a link goes down or when a circular or stale route has been broken. The null reply may be generated to account for all of the outstanding replies expected by a sending node. A reply may be marked null by setting a Boolean in the reply parameter object to true.","Original senders only receive null replies that were generated because of a link down. The original sender may then re-issue the send on the repaired tree. Stale routes and circular routes, on the other hand, may be hidden from the sender and treated as operations internal to the router\/builder. These null replies do not reflect the nature of ensuring that all replies have been received.","When the application performs a resend, the application may take appropriate standard safeguards to ensure idempotency\u2014e.g., identify the request with a unique ID, keep a map indexed by that ID of replies recently sent. When a request comes for a retry, it has the same ID, and the response may simply be looked up rather than re-performing the operation.","Link Down Processing","The link layer may alert the T&R layer of inactive (down) links by pushing an event to the link's listener callback. The T&R layer's link down handler may subsequently be invoked. The T&R layer may first remove its listener from the link. Next, the T&R layer may look up the set of outstanding replies over that link. The set of affected replies may be added to during the send process and subtracted from after a reply is received. For each outstanding reply, a null reply may be issued. Finally, the link may be removed from the set of active links used by the T&R layer and placed on a special transitional list of links to indicate that this link has gone down.","Stopping a Node","When a node is taken down voluntarily, the link layer may close down all active links to other nodes. The T&R layer's link down processing logic may then be invoked to send any needed null replies to other nodes.","Snooping Functions","Snooping messages is the process of examining in-route sends or replies. A snooping listener can consume (stop), suspend, or continue the routing of the send or reply towards its ultimate destination. Messages or replies currently being examined by a snooping listener have already been placed in the suspended state. The suspended send or reply may be resumed by either continuing the routing (triggered by special return value from listener), or by using the resume APIs.","When a snooping listener consumes a message, the T&R layer looks up that message in the suspended message map, and if found, removes it. No other processing is required. Similarly, when a snooping listener consumes a reply, the T&R layer looks up that message in the suspended replies map, and if found, removes it. No other processing is required.","When a snooping listener resumes a message, the T&R layer looks up that message in the suspended message map, and if found, removes it. Then, the common forward logic is used to continue the message routing. Similarly, when a snooping listener resumes a reply, the T&R layer looks up that message in the suspended replies map, and if found, removes it. Then, the common reply logic is used to continue the reply routing.","Builder ","The following sections describe internal mechanisms and data structures used to build and manage trees according to one embodiment. It is noted that the particular internal mechanisms and data structures are intended to be exemplary only. In various embodiments, routing data may be built and managed in any of various ways.","The builder  may be invoked in various circumstances, such as when performing the following:\n\n","Data Structures","The builder  builds and maintains routes for the router . According to one embodiment, these routes may be represented and managed using data structures referred to herein as tree layer objects. On each node, the local instance of the builder may perform a distributed protocol which manipulates its local tree layer objects to manage these routes.","Tree Object","According to one embodiment, for every tree that the local node maintains routing information, there is a Tree object.","List of Local Edges of the Tree","Each Tree object may maintain a list of Edge objects, each of which correspond to an edge of that tree on the local node.","Routes to Remote Roles on the Tree","Each Tree object may also have a hash map (hashed by role name) containing each Role Route object, which has local routing information for a role on the tree.","Local Roles on the Tree","Each Tree object may also have a hash map (hashed by role name) containing each Local Role object, which contains information about each role that the local node has on the tree.","Role Route Object","For every role that the local node has a route to on a particular tree, there is a Role Route object.","Role Route Instances","Each Role Route object may have a hash map (hashed by unique ID of role instance) holding each Role Route Instance object.","Role Route Instance Object","Each Role Route Instance object has the route for a specific instance of a role.","Route Specified by an Edge","That route is specified by a reference to the particular Edge object whose corresponding edge on the tree is in the direction towards that particular instance of the role.","Edge Object","For each edge on a tree, there is an Edge object.","Shadow link Object for that Edge Object","Each Edge object has a reference to a Shadow Link object.","Tree that Contains this Edge","Each Edge object has a reference to the particular tree on which it represents an edge.","Role Route Instances going over this Edge","Each Edge object also has a list containing all the Role Route Instance objects for all the role instances (for one or more roles) that are over this edge.","Shadow Link Object","For every neighbor node in the link mesh, there is a Link object, managed by the Link\/Discovery layer, which the T&R layer uses to send and receive messages to\/from that neighbor node. Corresponding to every Link object, the T&R layer maintains a Shadow Link object. The T&R layer may use Shadow Link objects to keep from polluting the Link Layer with T&R-specific code.","Going From Link Object to Corresponding Shadow Link Object","A hash map (hashed by Link object) may be used to look up the Shadow Link object that corresponds to a particular Link object.","Going From Shadow Link Object to Corresponding Link Object","Each Shadow Link object has a reference to its corresponding Link object.","List of all Edges over Corresponding Link","Each Shadow Link object has a list of all the Edge objects for each tree that has an edge over the Link corresponding to that Shadow Link.","Local Role Object","Each local role is specified by a role record including the following parameters specified when a role was added using the addRole API function:\n\n","Tree Cache Object","In one embodiment, each local node has a Tree Cache object that acts as a routing table such as described above. The Tree Cache object may maintain a cache of Tree objects. The size of the cache may be specified at start-up time and may be controlled by a local policy. Every time the T&R layer (both router and builder) modifies or accesses the routing information for a particular tree, the corresponding Tree object may first looked up in the Tree Cache, by specifying the unique ID of the tree.","Tree Cache Management","The Tree Cache may consider a look up of a Tree object to be an access of that Tree object. In one embodiment, the Tree Cache may keep track of the temporal order of accesses to the various Tree objects, so that the cache can be managed with a least recently used (LRU) policy such as described above. If a unique ID for a tree not currently in the cache is specified and the size of the cache is below its limit, a new Tree object may simply be allocated and added to the Tree Cache. However, if the Tree Cache is already at its limit, the least recently accessed Tree object may first removed from the cache before adding the new Tree object.","Cached State Can Be Recomputed","If a Tree object is removed from the Tree Cache and later accessed, the T&R layer may re-compute the routing information, rebuilding the tree using the same algorithms that would rebuild a tree after a link fails. The rebuilt Tree object may be re-added to the Tree Cache.","Tree Cache Also Maintains Local Roles","In one embodiment, in addition to maintaining the cache of Tree objects, the Tree Cache may also maintain all the local roles on each of the trees. Unlike the cache of Tree objects, the local roles may be maintained for as long as the local node is up. Therefore, when a Tree object is replaced from the cache, its hash map of Local Role objects may first be stored in the Tree Cache. The Tree Cache may maintain each hash map in another hash map, which is indexed by tree ID. Thus a double hash map, indexed by tree ID and role name, effectively manages all local roles on a node. When a Tree object is added back to the Tree Cache, its hash map of local Role objects is initialized using the one stored in the Tree Cache.","Fully-Built","Both Tree and Role Route objects may have a Boolean indicating whether the object (on the local node) is fully built. This indicates whether or not the object has been built sufficiently to be used for routing, or whether it needs for the builder first to perform recovery.","Maintaining Fully Built for a Role Route Object\n\n","When a node sends a message to a particular role, then provided the network is not partitioned, that message will eventually reach all nodes that have an instance of that role, provided the router does not use the routes maintained by the Role Route object until the builder has made it fully-built. The reason is as follows. If a node does not have the role, then it will not route the message until it either has a route to at least one node that has the role, or until the recovery operation has timed out due to no node having the role (role not found condition). Once the message reaches a node with the role, the rules for maintaining fully built on nodes with the role ensure that all nodes with the role and fully built set can reach all other nodes with the role.","Fully-built for a Role Route ensures that all nodes with the role can be reached in the whole cloud. For a cloud located throughout a WAN, the timeout may be relatively large. Since it is also possible to do a send that is restricted to the local Realm, recovery for that operation may have a much smaller timeout. For that reason, a fully built realm Boolean may also be maintained for each Role Route object.","Maintaining Fully Built for a Tree Object","The Tree object also has a fully-built Boolean which is:\n\n","The router does not use the Tree object for routing message, since messages are routed for a particular role on a tree (not all roles on a tree). The fully built boolean for the tree is only used by the builder to determine whether it can use the current edges of the trees to publish a new role on the tree. The only time a Tree object can have fully built set to true when one of its Role Route objects has fully built set to false is when that Role Route object has just been allocated. This special case allows the newly allocated role to publish on an existing tree that has not been broken from any link failures.","Obtaining Routes to All Instances of a Role","The router needs a list of links over which to send a message in order to reach all instances of a role. The builder looks up the Tree object in the cache, and then looks up the Role Route object in the Tree object. Once the builder has performed any needed recovery (if fully built is set to false for the Role Route object), then the list of links that the router should send the message on is simply determined by following the reference from each Role Route Instance object to its Edge object, and then to its Shadow Link object, and finally to its Link object. Once this list of links is computed, it can be kept in the Role Route object and only recomputed if the Role Route object has fully built reset to false, or if a new Role Route Instance is added.","Handling Link Failures","When a link fails, the trees that go over that link need to be rebuilt. In one embodiment the builder does not rebuild a tree until the tree needs to be used for a send. Otherwise, the system could become overwhelmed repairing many trees at once. Furthermore, many trees may not be needed until much later. Repairing them immediately would divert system resources from operations that currently need to be performed.","Although recovery may not be performed immediately when a link fails, all the Role objects that have a route over the failing link need to have fully built set to false, so that they will be marked for recovery the next time they are used. The following process may be performed:\n\n","In one embodiment, basic tree building algorithms may be employed which do not use a search algorithm to locate a node with an instance of a role. In another embodiment these basic tree-building algorithms may also be enhanced with a search algorithm to further improve performance and scaling. The basic tree-building algorithms are described.","The basic builder algorithms build the tree by two mechanisms:\n\n","Basic Publish Algorithm","This section describes one embodiment of a basic publish algorithm. It is noted that in various embodiments, any desired algorithm may be used to publish a role.","When a new instance of a role is added to a tree on the local node, the local node initiates the forwarding of a publish message. Among other information, the publish message specifies:\n\n","Forwarding a Publish Message","In one embodiment, the initial sending node and each node that receives the publish message may send the publish message using the following rules. When applying these rules, the incoming link is excluded.","Rule 1: If the node has already received the same publish message (a simple hash map is maintained for this purpose) the publish message is discarded, with no processing. This rule eliminates many cycles and thus helps to form a tree, not a graph in general. However, not all cycles may be prevented. Cycles may be eliminated when detected by the router.","Rule 2: If the node has another instance of the same role, the publish message is not forwarded any further provided that Spew Hops is 0, but it is processed. This rule prevents the publish from being forwarded unnecessarily. If the publish message were to be forwarded further, it would reach nodes that already have a route along the same edge to this node just reached with the role. In other words, a node only needs a route to one of the nodes with the role down a particular edge; it does not need a route to roles behind that node.","Rule 3: If the local Role Route is not fully built and the local Tree is also not fully built, reset Spew Hops to 3. (In other embodiments, other values may be used.) Otherwise, if the local Role Route is fully built and Spew Hops is non-zero, decrement Spew Hops by 1. This essentially computes the number of hops where rule 6 will apply.","Rule 4: If the local Role Route is fully built and Spew Hops is 0, the publish message is only forwarded on links that are the routes to existing instances of the role. This tends to publish towards other instances.","Rule 5: If the local Role Route is not fully built but the local Tree is fully built and Spew Hops is 0, the publish message is forwarded along edges of the tree. This tends to publish a new role on a tree already formed by a role previously published that built out the tree.","Rule 6: Otherwise, the publish message is forwarded on all links. This tends to search for local repairs to the tree for a few hops.","If only Rules 1 and 6 were used, the publish request would eventually reach all instances of the role. Using Rules 2, 3, 4, and 5 reduces the number of nodes that must receive and process the publish request.","Except in the case of Rule 1, the publish message is processed by adding a Role Route Instance, with an Edge over the Link that the publish message is received.","Basic Recovery Algorithm","When the router is sending or forwarding a message to a role for which the local Role Route object has fully built set to false, the builder must first perform recovery.","This section describes one embodiment of a basic recovery algorithm. It is noted that in various embodiments, any desired algorithm may be used to perform recovery.","To perform recovery, the local node may initiate the forwarding of a recovery request message. Among other information, the recovery request message specifies:\n\n","Forwarding a Recovery Request Message","In one embodiment, the initial sending node and each node that receives the recovery request message may forward the recovery request message using the following rules. When applying these rules, the incoming link is excluded.","Rule 1: If the node has already received the same recovery request message (a simple hash map is maintained for this purpose) the recovery request message is discarded, with no processing. This rule helps eliminate cycles, thus forming a tree and not a graph in general.","Rule 2: If the node has another instance of the same role, the recovery message is not forwarded any further provided that Spew Hops is 0, but it is processed. This rule prevents the recovery from reaching instances that need not be reached. If the recovery message were to be forwarded further, it would cause routes to be recovered for nodes to which the current node (i.e., the node that the recovery message just reached) already has routes. In other words, a node only needs a route to one of the nodes with the role down a particular edge; it does not need a route to roles behind that node.","Rule 3: If the local Role Route is not fully built, reset Spew Hops to 3. Otherwise, if the local Role Route is fully built and Spew Hops is non-zero, decrement Spew Hops by 1. This essentially computes the number of hops where rule 6 will apply. (Due to this rule, Spew Hops may immediately get set to 3 when the algorithm is started since the role is not fully built at the node where the recovery algorithm is started.)","Rule 4: If Spew Hops is 0 and the Role Route is fully built, the recovery message is only forwarded on links that are the routes to existing instances of the role. This tends to send the recovery request towards instances of the role.","Rule 5: If Spew Hops is 0 and the local Role Route is not fully built but the local Tree is fully built, the recovery message is forwarded along edges of the tree. This tends to recover the role routes on a tree already formed by a role previously published that built out the tree.","Rule 6: Otherwise, the recovery message is forwarded on all Links. This tends to search for local repairs to the tree for a few hops.","If only Rules 1 and 6 were used, the recovery request would eventually reach all instances of the role. Using Rules 2, 3, 4, and 5 reduces the number of nodes that must receive and process the recovery request.","The initial sending node, and each node that receives and processes the recovery request message (all cases except the one in Rule 1) keep track of the recovery request and the Link over which it was received, using a Recovery Record object. The initial sending node and each node that receives the recovery request and finds fully built to be set to false for the role considers a recovery operation to be in progress and starts a timer which goes off when the recovery operation is finished locally.","When a node with an instance of the role receives the recovery message, the node sends a recover response message, which specifies:\n\n","The recover response message is forwarded back along the path that the recovery request message came. For the purpose of routing back the response, the Link over which the recovery request was received (recorded in the Recovery Record) is used (Recovery Record is looked up in a hash map indexed by the Message ID of the recovery response, which is the same as the Message ID of the recovery request). Except in the case of Rule 1, each node that receives the recovery response adds a Role Route Instance with an Edge over the Link that the recover response message is received.","For the initial sending node and any other node that received the recovery request and found fully built to be false, any one of the following conditions causes it to terminate the recovery algorithm and mark its Role Route object with fully built set to true:\n\n","Other Mechanisms of the Basic Publish and Recovery Algorithms","Having discussed above the core of the basic publish and recovery algorithms according to one embodiment, the following sections cover other mechanisms which may be utilized in performing these algorithms.","Exclusive Roles","When two nodes attempt simultaneously to publish an exclusive role, all nodes must reach a distributed agreement regarding which node has the exclusive role. In one embodiment this is handled simply by comparing instance IDs for the (prospective) role instances and letting the highest instance ID win. Thus, the publish from the node with the highest role instance ID will eventually reach all nodes and replace any routes to lower-numbered instances. It will also result in the exclusive role being removed from the node that has the lower-numbered exclusive role instance. The algorithm works also when there are more than two nodes attempting to publish simultaneous exclusive roles on the same tree. It is also noted that publishing an exclusive role wipes out any shared role by the same name that had been published on the tree.","In one embodiment a handshake utility can be used to add exclusive roles, instead of directly calling addRole( ) This utility provides a callback to the user when the exclusive role has been successfully added, or when the exclusive role was removed. Before attempting to add the exclusive role, it first does a ping to the exclusive role, so that an existing holder of the exclusive role (one that has already been notified of success via callback on its node) does not get the exclusive role taken away from it when the new node attempts to get the role using the handshake utility. Thus, in this case, if there is already a node with the exclusive role, the node attempting to get it will get a callback indicating it cannot get the exclusive role.","Unpublish","An unpublish operation may be handled by the same code that does publish. A Boolean in the Publish request message may indicate whether the request is a publish or an unpublish, and the message may be propagated using the same rules as the publish. Instead of adding a Role Route Instance when the Unpublish request message is processed on each node, the specified Role Route Instance is removed.","Unpublish does have one other additional capability. In most cases, the node that adds an instance of a local role (or removes the local instance of a role) does the publish (or unpublish). However, for exclusive roles, the unpublish can originate from any node, due to the way the publish algorithm comes to a distributed agreement (on all nodes) regarding which instance wins when there is an attempt to publish exclusive roles simultaneously from two different nodes. A node could fail holding an exclusive role, and its instance may win over an attempt to publish an exclusive role on another node, when some higher-level software performs recovery. Thus, instead an unpublish can be done first from the node that performs recovery to clean up any routes to the old exclusive role on the failing node.","In some cases nodes may fail without first unpublishing their roles. This results in nodes having stale routes to those roles. This may be handled by an algorithm that removes stale routes.","Creating and Destroying Tree Edges","Many builder operations involve creating and destroying tree edges. For example, when a Role Route Instance object is added for a route over a link, if there is not already an Edge object created over that link, one is created. Since the tree needs to be bi-directional, whenever an Edge object is created, the local node sends an edge create request message over the link (the link the edge is over). This message specifies simply the tree's unique ID. When the node on the other end of the link receives the edge create request, it simply creates the edge if it does not already have one.","Since an edge may be created to ensure the tree is bi-directional, some edges will not have any routes to roles over them. However, if node A and node B have bi-directional edges to each other, at least one of those nodes will have a route to the other node. Otherwise, the edge may be removed. The edges mutually between two nodes may be removed once neither of the nodes has a route to the other node. The removing of the edges may be accomplished by a simple protocol where the two nodes both agree to remove their edges after checking with each other to make sure there are no routes. In another situation, an edge may be removed to break a cycle. In that case, the breaking of the edge may be forced even if there are routes over the edge.","According to one embodiment, both the unforced and forced cases for edge removal may be handled as follows:\n\n","Bulk Publish","An addRoles API function may allow multiple roles to be added and published at the same time. The bulk publish facility may allow roles to be added on different trees in the same bulk request. A bulk message including multiple builder messages may be utilized to perform a bulk publish operation. A bulk request message for bulk publish includes multiple independent publish messages. The code that processes bulk requests may unroll the bulk request and call the routine that processes publish requests for each of the publish requests in the bulk request message.","The following changes to the publish algorithm described above may allow a bulk publish operation to be performed:\n\n","Once the bulk processing code has called the process publish request for each publish message, it may simply send each bulk request message in the bulk request record on the Link that corresponds to it. In a recursive manner, each node that receives a bulk request message over a link may perform a bulk publish operation for each publish message in the bulk request message, similarly as described above. Thus, each publish message in the received bulk message may be processed and added to a bulk request message for the particular link the individual publish message would have been forwarded on from that node, and the bulk request messages may be sent over the corresponding links.","Link\/Node Failure During Recovery","Sometimes the recovery process is not complete until the recovery timeout has occurred. In such cases, the node performing recovery does not know it has all the routes it needs to ensure its routing table is fully built until the recovery timeout. However, if the node forwarding a recovery request experiences a link failure on one of the links it forwarded the recovery request, the node might not have received all the recovery responses. This problem may be handled by having any node that experienced such a link failure send back a recovery response indicating link failure. This response is sent back all the way to the node that originated the recovery. Each node along the way marks the role as not-fully built if it has not received a response that allows it to declare otherwise that recovery is complete. Then, if the node that originated recovery gets any recovery failure responses during the recovery, it simply re-initiates the recovery.","Ensuring Efficient Routing to All Roles in a Local Realm","In one embodiment the router's send API may support restricting the send to just the roles in the local realm. This send is supposed to reach all instances of the role in the local realm. If the publish and recovery algorithms allowed a tree to be built with the nodes in any realm not all on the same fragment of the tree, a send that is restricted to a local realm might have to be routed outside of that local realm to another realm, and then back to the original realm in order to reach all instances of a role in the local realm. This would defeat the purpose of having realms. A send within the local realm should be considerably more efficient, because nodes within the local realm should be reachable with much lower latency, and without wasting WAN bandwidth. Therefore, the builder may ensure that, for every tree built, nodes within the same realm are all on the same fragment of the tree, so that any node in a realm can send a message to any other node in the same realm without leaving that realm.","Such fragments could be formed in the following unlikely but possible situation: A publish or recovery request message goes from a node A in realm R to nodes outside of realm R, and then returns to realm R reaching a node B in realm R before the same message goes from node A to node B without leaving realm R. This situation is not likely because the path that goes outside of realm R to go from node A to node B should have a significantly higher latency than the path that stays inside realm R. However, this situation could occur for example if one or more nodes on the path that stays inside the realm are overloaded and not able to forward the messages fast enough.","This problem may be addressed with the following solution:\n\n","With this mechanism in place, the router can easily send to only the instances of a role in a local realm by excluding a send on any link that goes to a node in a remote realm. Thus, the router may simply request the list of links that are routes to a role and may then exclude any of the links that goes to a remote realm.","Recovery for Sends Restricted To Local Realm","When the router is performing a send restricted to the local realm, it is not necessary to be able to reach all instances of the role, just the ones in the local realm. When doing recovery for just the local realm, the recovery algorithm may employ an additional restriction that recovery request messages are only forwarded over links that go to other nodes in the local realm. Also, since nodes in the local realm can be reached more quickly than nodes throughout the cloud, the recovery timeout for local realm recovery should be significantly smaller.","Recovery for Single Instance Sends","When doing a single instance send, the recovery algorithm may terminate as soon as the node initiating recovery has one route to an instance of that role, whether or not that instance is marked fully built.","Determining Recovery Timeout","In some cases recovery is not done until the recovery timeout has happened. The recovery timeout may be based upon a maximum reasonable time for a recovery request message to reach each instance of the role being recovered and come back in the form of a recovery response along the same path.","According to one embodiment, in order to compute such a timeout the following computations may be performed:\n\n","For local Realm recovery, the recovery timeout may be computed as the maximum value in List A multiplied by a multiplication factor (e.g., 3). For full recovery (to reach instances throughout the cloud), the recovery timeout may be computed as the maximum value in List B multiplied by a multiplication factor (e.g., 3).","Motivations for this algorithm for computing recovery times include the following:\n\n","In other embodiments, any of various other algorithms may be used to compute timeouts. In one embodiment, a local hop time may be computed as a running weighted average of local ping times. In one embodiment, each ping affects 10% of the next computed local hop time and the previous local hop time affects 90% of the next computed local hop time. The ping rate may be configurable. In one embodiment, pings may be performed once per minute. The local hop time may be piggybacked on every builder message.","A global hop time may be computed based on the local hop times. In one embodiment, the piggybacked local hop time affects 10% of the next computed global hop time, and the previous global hop time affects 90% of the next computed global hop time.","Timeouts may be computed as a function of the maximum number of expected total remaining hops and the global hop time.","Loss of Link Connecting to Another Realm","In one embodiment the link layer software may use the node IDs of nodes in a realm to establish an ordering. For a certain target valency number, N, each node may form links with the N nodes that have the smallest node IDs larger then their node ID. Within a realm, 2 hops should be sufficient to perform local repair around a failure. Thus, the Spew Hops setting of 3 in the basic publish\/recovery algorithms should be more than sufficient.","However, the link layer may form links that connect realms differently, and only a few nodes within a realm may connect two realms together. To address this problem, when a role route becomes not fully built due to loss of a link connecting to another realm, the role route is marked so that the publish\/recovery algorithms keep Spew Hops set to infinite until the message leaves the realm.","Restricted Publish","In one embodiment the addRole( ) API function may allow the user to restrict the extent that a role is published according to:\n\n","Other Builder Operations","As noted above, trees are built primarily via the Publish and Recovery algorithms. The following sections discuss other builder operations.","Repointing a Route When a Role Moves","When a node grants and gives up a role in a reply to a routed message, the router may initiate the re-pointing of the role back to the node that will ultimately receive the reply granting the role given up. Re-pointing is considerably more efficient than having the node that gives up the role initiate an unpublish operation, followed by having the node that gets the role initiate a publish operation. With re-pointing, only the nodes on the way from the replying node to the receiving node need to change their routes.","On every node that forwards the reply, the router may simply call an internal API function, repointRole( ) in the builder, supplying:\n\n","The builder may simply remove any Role Route Instance that the local node had to the specified role instance and create a new Role Route Instance as specified pointing along the Link supplied.","When nodes fail along the path of the re-pointed role, the node that sent the request will not receive the reply granting the role. However, the node will receive a null reply that it can use as an indication of the need to recover the role that was granted and lost.","Handling Cycles","The tree building algorithms described above do not guarantee that the routes have no cycles. The presence of cycles in the routing tables has no effect on the routing of messages because the router detects cycles of individual messages sent and discards extraneous messages. The prevention of cycles would require a very complex distributed building algorithm that would likely impact performance. Moreover, typical use of the T&R layer algorithms should not often result in cycles.","When the router detects that a message has cycled, the router may call an internal breakRoute( ) API function of the builder, specifying:\n\n",{"@attributes":{"id":"p-0581","num":"0856"},"figref":"FIG. 103","ul":{"@attributes":{"id":"ul0141","list-style":"none"},"li":{"@attributes":{"id":"ul0141-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0142","list-style":"none"},"li":["Step 1: Node A's router sends a message to node B, causing the cycle.","Step 2: Node B's router receives the message and detects that receipt of that message causes a cycle.","Step 3: Node B's router calls node B's builder's breakRoute( ) method.","Step 4: Node B's builder sends a break route request protocol message to node A's builder (sent over the link specified by node B's router), and this break route request message specifies the information supplied by node B's router (Tree ID, Role Name, Message ID).","Step 5: Node A's builder calls node A's router's routeBrokenReply( ) method so that node A's router can process this case as though the last reply to the request that came over the link to node A has been received. (This is done since node A's router is waiting for replies from node B's router for the message it sent).","Step 6: Node A's builder determines a list of roles that have routes over the edge of the tree from node A to node B.","Step 7: Node A's builder generates reverse routes for each of the roles determined in step 6. (Step 7 is described in detail below.)","Step 8: Node A's builder removes all the role route instances that go over the edge from node A to node B. All roles besides the one that the router was sending the message that caused the cycle are marked as not fully built.","Step 9: Node A's builder removes the edge from node A to node B. The removal of the edge is forced so that node B is forced to remove its corresponding edge. This causes node B to remove any role route instances that go over the edge from node B to node A, marking the corresponding roles routes as not fully built.","Step 7 above creates reversed routes opposite to the direction that the message that cycled ran. This step tends to prevent a cycle from being re-formed over the edge just broken. In one embodiment the creation of reverse routes (step 7) may be performed as follows:","Step 7a: Node A's builder creates a reverse route protocol message specifying: Tree ID, List of Role Names (from Step 6), Message ID of the router message that cycled.","Step 7b: Node A's builder calls node A's router specifying the Message ID of the router message that cycled to get the incoming link over which the router message was received.","Step 7c: If the incoming link determined in Step 7b is non null, dummy role route instances are created (a new instance ID is used) over this incoming link for each role in the list of roles to create a reverse route, and the reverse route message is sent over the incoming link.","Step 7d: The node that receives the reverse route message loops to Step 7b to process it."]}}}},"Reverse routes are created back to the node that sent the cycling message, allowing the role that was involved in the cycle to remain fully built on all the nodes that were in the cycle. Some of these routes may not be necessary. If so, they may be removed as stale routes (see below).","A mechanism that prevents nodes in a realm R from being on different fragments of a given tree is discussed above. The mechanism creates a cycle that will eventually need to be broken. It is important not to break that cycle in such a way that realm R becomes fragmented on the tree. In order to ensure this, the router may perform the following:\n\n","Although avoiding breaking the cycle causes the cycle to persist, eventually the right node in the cycle will receive the message and break the route. Also, due to the fact that latency within a realm is significantly lower than outside a realm, the cycle is more likely to occur so that it is favorable to break the route.","Removing Stale Routes","When nodes fail while holding roles, other nodes may have stale routes to those roles. The router detects a stale route when it receives a message being routed to a role, and it does not have any route (even after invoking the builder if necessary) to the role, except over the link that the router received the message. When the router detects a stale route, the router calls an internal breakRoute( ) API function of the builder, specifying:\n\n",{"@attributes":{"id":"p-0587","num":"0884"},"figref":"FIG. 104","ul":{"@attributes":{"id":"ul0147","list-style":"none"},"li":{"@attributes":{"id":"ul0147-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0148","list-style":"none"},"li":["Step 1: Node A's router sends a message to node B over a stale route to node B.","Step 2: Node B's router detects the stale route.","Step 3: Node B's router calls node B's builder's breakRoute( )method.","Step 4: Node B's router sends a break route request protocol message to node A's router (sent over the link specified by node B's router), and this break route request message specifies the information supplied by node B's router (Tree ID, Role Name, Message ID) and indicates the break route request message is for stale route removal (not handling cycles).","Step 5: Node A's builder calls node A's router's routeBrokenReply( ) method, so that node A's router can process this case as though the last reply to the request that came over the link to node A has been received. (This is done since node A's router is waiting for replies from node B's router for the message it sent).","Step 6: For the role specified in the break route request, node B's builder removes all role route instances for that role over the edge of the tree from node A to node B (fully built is not changed for the role). The edge is only removed if it has no more routes. The removal is not forced."]}}}},"Handling Network Partitioning","In some cases the network of nodes may become partitioned. As used herein, a network is partitioned if there are at least two nodes in the network, node A and node B, such that there is no sequence of links starting from node A and connecting eventually to node B. In this situation the network has essentially become separated into two (or more) groups of nodes where nodes in one group cannot communicate with nodes in another group. Partition boundaries do not necessarily coincide with realm boundaries. However, two different realms may be more likely to become partitioned than two sections within a single realm.","After becoming partitioned the network may later become un-partitioned, i.e., the partitioning problem may become corrected. The network may become un-partitioned when a network link is added or repaired. In one embodiment the system may employ a method for determining when the network has become un-partitioned, i.e., for determining that partitioning of the network has been repaired. It is a necessary, but not sufficient, condition for a link to have been added or repaired for a network to become un-partitioned. Thus, logic for determining whether the network has become un-partitioned may execute in response to a link being added.","If the system determines that the network has become un-partitioned, the system may cause at least a subset of nodes in the network to perform recovery operations to reflect the repair of the partitioning. Before the network is un-partitioned, a role route of a particular tree may be marked fully built on a node in one of the partitions, meaning that no recovery is needed at that local node in order to eventually route to all instances of that particular role (at least the instances that are reachable in the current partition). However, after the network is un-partitioned, there may be new role instances that are now reachable on nodes that were previously inaccessible. Thus, when the network becomes un-partitioned (or partially unpartitioned), trees may need to be rebuilt on various nodes so that routes are built to the new role instances that are now reachable.","Suppose a node X (with node ID Dx) in realm Rx detects an un-partition caused by adding a link L and that this link L connects node X to node Y (with node ID Dy) on the opposite end of Link L. When such an un-partition occurs, node X may issue an un-partition event, specified by <Dx, Rx, Dy> to all nodes that node X can reach. The node X may send a message specifying the event <Dx, Rx, Dy> to all nodes except for nodes now reachable over the newly added link.","Each node that receives an un-partition event message may maintain a list of such un-partition events. The order of each node's list is not particularly important. However, maintaining an order may allow each node to keep track of which un-partition events have been handled for any particular role. Thus, each node may maintain a numbered list of the un-partition events in the order they are received. For each role of a tree, the local node may also keep track of the highest numbered un-partition event (in the list) for which recovery has been performed.","If a send operation is to be performed to send a message to a particular role, then even if the role is currently marked fully built, the T&R layer may check to determine whether there are new un-partition events added to the list since the last time a recovery operation was performed for the role. If so, a recovery operation may be performed for each such un-partition event.",{"@attributes":{"id":"p-0595","num":"0898"},"figref":"FIG. 105"},"As shown in step 3, to perform recovery that is made possible by the un-partition identified by <Dx, Rx, Dy>, a directed recovery variation of the tree recovery algorithm may be utilized in which Node A sends a tree recovery message directly to node X. As shown in step 4, the directed recovery request may be sent from Node X to Node Y. The normal recovery algorithm as described above may then take over from Node Y. Thus, in one embodiment the routing of the directed recovery request may be performed as follows:\n\n","When node X receives the directed recovery request, node X forwards the request message across the link that caused the un-partition (the link that goes to node Y). Once the directed recovery request reaches node Y, the normal recovery algorithm may resume so that the recovery request message is routed to instances of the role on the opposite side of the (old) partition. The tree may then be rebuilt when nodes process the reply (or replies) to the directed recovery request message as the reply is forwarded back, in the same manner as described above with reference to the recovery algorithm.","The above description refers to a realm tree and a node tree. These are referred to herein as utility trees, i.e., trees which allow the T&R layer to perform various functions (such as handling network un-partitioning).","A node tree is a tree that allows any node to send a message to all nodes that can be currently reached. The tree may be identified by a well-known ID, D, which all nodes in the entire network know about. The tree may have a shared role named \u201cN\u201d, where each node in the network adds a local instance of the shared role \u201cN\u201d.","In some cases a per-node tree may also be useful. A per-node tree for a given node in a given realm may enable messages to be optimally routed to the node within the realm. The per-node tree may have the following characteristics:\n\n","A realm tree is a tree that allows any node to route a message to a node in any particular realm. This allows local realm routing (perhaps using the per-node trees) once the message has been routed to the realm. The realm tree may have a well-known Tree ID.","Detecting Un-Partitioning","In various embodiments the system may use any technique or algorithm to determine that the network has become un-partitioned. This section describes one exemplary algorithm that may be used for this purpose.","A partition-coloring algorithm may operate to ensure that when partitions occur, the nodes in each partition get a different value referred to herein as a color. Thus, when a link is added, it can easily be determined if a possible un-partitioning has occurred, by comparing colors on both sides of the link.","The \u201ccolor\u201d may be a logical color or value, represented by a unique ID that is created on a node when it has a failure of a link. The use of unique IDs ensures that partitions are uniquely colored. Along with the color ID C, the node may also reads its Lamport Logical Clock, obtaining some value, L. Then, the pair <C, L> may be sent to all nodes in the local partition.","When each node is booted the node may have an undefined partition color. A node with an undefined color may simply accept any proposed new color <C, L>. However, a node that already has some color, <C0, L0> may only accept the proposed new color if L0<L, or if L0=L, and C0<C. Even if a set of nodes is being partitioned from the rest of the network in multiple places (i.e., multiple nodes are losing links at about the same time), this partition-coloring algorithm causes the nodes in the partition to converge on the same color eventually.","Assuming the above-described partition-coloring algorithm is utilized, an un-partition caused when a link is added can be detected as follows. If either of the nodes on the ends of a link has an undefined color or if both nodes have the same color, there has not been an un-partition. (For example, a node may have simply booted or re-booted). Otherwise, if the two nodes have different colors, an un-partition has been detected.","Once an un-partition has been discovered, the winning color (based upon partition coloring) may be propagated so that all nodes in the new partition converge to the same color.","Since a network may have been partitioned into more pieces than two, this partition may later join with another partition when another un-partition occurs.","Node failures may be manifested as link failures on their neighbor nodes. Thus, the basic partition-coloring algorithm described above may run on each neighbor node when a node fails. In one embodiment an assumption may be made that nodes in a local subnet remain fully connected and do not become partitioned. If this assumption is made, then the partition-coloring algorithm only needs to be run when links spanning subnets are lost. Also, detection and handling of un-partitioning only needs to run when a link spanning subnets is added. This assumption may decrease the overhead of partition\/un-partition handling.","Support for Layers above the T&R Layer","Layers above the T&R layer may need to be able to detect when a partition has occurred, e.g., to restrict access to a data object. For example, a strongly coherent distributed file system may not allow a node on the side of a losing partition (a side with less than a majority quorum of persistent replicas of the object) to do writes, and may not even allow reads (depending upon how strict the coherency). Even with a loose coherency distributed file system, it may be useful to detect when a partition or an un-partition occurs, in order to perform conflict resolution.","To support such higher layers, it may be useful to have an interface which allows listeners to receive events for partitions and un-partitions:\n\n","Tree Building Using a Search Facility","As described above with reference to , in one embodiment a search technique may be utilized for tree building so that the first replica of a storage object (e.g., the first instance of a role) is not published with a publish operation. Instead, a search mechanism may be utilized to simply store location information for the first replica (first role instance).","When the first instance of a role is created, the resulting publish operation may be expensive since the publish operation results in many nodes receiving and processing the publish message. Nodes that process a publish message for the first instance of a role do not yet have any routes built for other instances of the role, and hence forward the publish message over all the node's links.","However, publish operations for subsequent instances of the role are typically significantly more efficient than the publish operation for the first instance, since nodes that receive the publish message only forward the publish message over routes that point toward other instances of the role. Also, the publish message may not be forwarded further when it encounters a node that already has another instance of the role.","Thus, for greater efficiency, in one embodiment the first instance of a role may not be published. Instead, the location of the first instance of the role may simply be stored as described above with reference to . In one embodiment, this may be facilitated through use of a search facility with the following characteristics:\n\n","Thus, instead of publishing the first instance of a role, the <Node ID, Realm ID> pair identifying the local node may be specified to the search facility. The search facility may then store this location as described above. Subsequent instances of the role may be published normally. However, before doing the normal publish, if the role is not fully built, an implicit recovery, using the search facility, may first be performed as described below. Then, when the normal publish is done, it is done efficiently with the publish message sent only along the routes towards existing instances of the role.","Recovery using the search facility may be performed when:\n\n","When recovery using the search facility is performed, the local node may specify the <Tree ID, Role Name> pair to the search facility, and the search facility may return the location of the first instance of that role, specified by <Node ID, Realm ID>. If the search facility is not able to find such a first instance, then the normal recovery operation described above may be performed instead.","When recovery using the search facility is performed, the recovery message may be routed as follows:","Step 1: If the first role instance located by the search facility is in a remote realm, the recovery request message is first routed towards the exclusive role on the per-realm tree whose tree ID is the Realm ID portion of the location returned by the search facility. Each time the recovery request message is received, if the receiving node is already in the destination realm, Step 2 of the routing is started.","Step 2: Once in the destination realm, the recovery request message is routed to the \u201cN\u201d role on the node tree whose tree ID is the node ID of the node where the role instance is located (the one the search facility located).","As is also done with the normal recovery operation, so that the recovery response message can be routed back to the node that initiated recovery, each node that receives the recovery request message may maintain a recovery record that indicates the incoming link by which the recovery request message was received.","If any node along the route of the recovery is not able to continue routing, a recovery failure response may be sent back to the node that initiated recovery, and the normal recovery operation may be performed instead. Otherwise, the recovery response message is sent back, and the original sending node marks the role route as fully built.","In some situations, location information previously sent to the search facility may be removed. For example, when an unpublish operation is performed on the first instance of the role, the location information of that first instance may be specified to the search facility in a remove operation so that the search facility no longer returns that location information. Also, if any node attempts to perform recovery using information obtained from the search facility, and the specified node could not be reached, the node that attempted the recovery may cause the search facility to remove the location information.","If the search facility fails to find a first instance or if the node indicated by the search has failed, the node then performs normal recovery. An internal single instance send operation may then be sent to one of the role instances (if there is one) so that the role instance that receives the message is instructed to add itself as the \u201cfirst\u201d instance, once it has performed normal recovery (if needed). The search facility may subsequently return the location of this instance of the role when queried.","It is possible that two nodes may attempt recovering the first instance at the same time. To avoid this situation, a reserved exclusive role may be used for synchronization. The exclusive role may first be obtained before recovering the first instance.","As described above, in one embodiment the first instance of the role may move to another node. In this case, in addition to the repointing done, the original location of the first instance of the role may be removed by the search facility, and a new entry may be added for the instance's new node location.","As described above, in one embodiment a hierarchical technique may be utilized in which both a local realm search facility and a system-wide search facility are told to add or remove location information. During recovery, first the local realm search facility may be used to locate the first role instance. Only when the location of the first role instance cannot be found using the local realm search facility may the system-wide search facility be utilized.","Direct Connection Trees","As described above with reference to , in one embodiment a node may establish direct connections to one or more storage object replicas located on other nodes. In one embodiment, this may be accomplished by creating a direct connection tree for sending messages in a point-to-point manner to one or more role instances corresponding to the respective storage object replicas. (Direct connection trees may also be used for sending messages in a point-to-point manner from a source node to one or more target role instances that represent other things besides storage object replicas.)","In one embodiment, a direct connection tree may be created by first performing a find step to determine the nodes on which the role instances to be included on the direct connection tree are located. In one embodiment, performing the find step may comprise sending a message (e.g., the find message described above with reference to ) to a specified role on an existing tree. Each instance of the role that receives the message may reply, where the reply indicates whether the instance of the role desires to join the direct connection tree, and if so, specifies the address of the node on which the role instance is located. For example, each reply from a role instance that desires to join the direct connection tree may include a node descriptor specifying the node's address or other information usable to establish a direct connection to the node on which the role instance is located.","In one embodiment, the replies from the various role instances may be aggregated so that the source node receives a single aggregated reply including all the replies from the individual role instances. The source node, e.g., client application software executing on the source node, may then call a \u201cconnect\u201d API method to create the direct connection tree based on the node descriptors or address information received in the aggregated reply.","When invoked, the connect method may establish any necessary virtual links between the source node and the target nodes. If virtual links from the source node to all the target nodes already exist (e.g., from previous connect operations), it may not be necessary to send any messages to other nodes to create the direct connection tree. Edges pointing to each target node may simply be added to the direct connection tree data structure on the source node and mapped to the existing links. If one or more target nodes are not already connected to the source node by a link, links to these target nodes may first be created before mapping edges over these links to the respective target nodes.","The connect method may return an ID of the direct connection tree to the caller, e.g, client application software, of the connect method on the source node. The client application software may then utilize the direct connection tree to send messages to the one or more target role instances on the tree. For example, the application may utilize the message-sending API described above and may simply pass the ID of the direct connection tree to identify the tree on which to send the messages. The message may be sent to each of the target role instances in a single hop, i.e., no intermediate nodes may receive the message before the message arrives at each target node.","Utilizing a tree in this manner to implement direct connections may simplify the task of creating client applications. Applications may utilize a single programming interface to send messages on either single-hop (direct connection) or multiple-hop trees. Similarly, the client application software that receives the messages at the target nodes may process messages received via single-hop (direct connection) and multiple-hop trees in the same manner.","A direct connection tree essentially represents a \u201csnapshot\u201d in time of nodes attached to the original multi-hop tree on which the direct connection tree is based. As discussed above, the original multi-hop tree may change over time, e.g., as role instances are added or removed or move from node to node. Any number of direct connection trees can be created to represent different snapshots in time of the multi-hop tree. These snapshot trees may be used for any purpose of the application's choosing.","When an application publishes new role instances on the original multi-hop tree, the application may also publish the new role instances on the direct connection tree(s) if desired. Thus, a direct connection tree may also change over time. Snapshots to represent the state of a direct connection tree at a given point in time may also be taken, e.g., by creating another direct connection tree based on the original direct connection tree.","In one embodiment, a direct connection tree may be based on more than one tree. For example, as described above, client application software on the source node may send a message on a first tree and receive an aggregated reply indicating node locations of one or more role instances on the first tree. In one embodiment, the client application software on the source node may also send a message on one or more other trees and receive a reply (or replies) indicating node locations of one or more instances of other roles on these other trees. When calling the connect method to create the direct connection tree, the client application software may pass the node locations received in the replies to all the messages sent on all the different trees. Thus, the direct connection tree may include single-hop connections to role instances included on multiple original trees. Thus, in one embodiment a direct connection tree may represent the \u2018OR\u2019 of any number of existing trees as a snapshot in time.","Direct connection trees may be built on multiple original trees for any of various purposes. As one example, a first original multi-hop tree may include all the replicas of a storage object. A second original multi-hop tree may include all the replicas that represent the current parent directory of the storage object. A third original multi-hop tree may include all the replicas that represent a new parent directory for the storage object. A direct connection tree based on all these trees may be created, for example, to perform a \u201crename\u201d operation for a distributed filesystem.","Also, in one embodiment, results from one or more find operations performed by a source node may be sent to another node. The other node may then create a direct connection tree to directly access the role instances that responded to the find operation(s) by indicating a desire to join the direct connection tree.","Also, in one embodiment, find operations may be scoped to either the local realm or to the entire system. If scoped to the local realm, then only role instances in the same realm as the source node may receive and reply to the message sent in the find operation. Thus, only nodes in the same realm as the source node may be included in the direct connection tree. If scoped to the entire system, then role instances in multiple realms may receive and reply to the message sent in the find operation. Thus, nodes throughout the system may be included in the direct connection tree.","In one embodiment, the system  may support multiple direct connection \u201cneighborhoods\u201d (DCNs). Each direct connection neighborhood may be identified by an ID (e.g., an integer, string, or other information that identifies the DCN), also referred to as its DCN_ID. In one embodiment, each direct connection neighborhood may have an associated link cache. The link cache may close existing links when the maximum number of links for that neighborhood (neighborhood valency) is exceeded, on the basis of a Least Recently Used (LRU) policy or another cache replacement policy. Link caches may be maintained independently for each neighborhood. In one embodiment, the total number of links across link caches of the different neighborhoods may also be limited to a maximum number.","Different direct connection neighborhoods may need to communicate over the same two nodes. To handle this case, the traffic of the different direct connection neighborhoods may be mapped to the same underlying link, e.g., TCP\/IP link, between the two nodes. As a result, a second DCN may re-use the TCP\/IP link created by a first DCN. Thus, the second DCN may not incur the overhead of creating a new TCP\/IP connection for communicating between the same two nodes. The TCP\/IP link may remain open as long as at least one direct connection neighborhood is active on it.","As described above, the system may utilize both LAN and WAN communication to perform communication for regular (i.e., multi-hop or non-direct connection) trees. In one embodiment, the overlay link meshes for performing the LAN and WAN communication may also be treated as direct connection neighborhoods. In one embodiment, the LAN mesh has DCN_ID=0, and the WAN mesh has DCN_ID=1. Other direct connection neighborhoods may re-use an existing link of the LAN or WAN link meshes without needing to create new links. For example, if a first DCN needs a link between two nodes, and a link in the WAN link mesh already exists between the two nodes, this link may be re-used by the first DCN. Thus, multiple direct connection neighborhoods may effectively be dynamically mapped onto the same link. The respective DCN_ID's may be used to multiplex and de-multiplex traffic on the link.","In one embodiment, each direct connection neighborhood may be able to support multiple direct connection trees. Each direct connection tree may be identified by an ID, e.g., a DUID. Different direct connection trees in the same neighborhood may need to communicate between the same two nodes. To handle this case, the traffic for the different direct connection trees may be mapped to the same underlying link between the two nodes, similarly as described above. The respective ID's of the direct connection trees may be used to multiplex and de-multiplex traffic for different trees on the link. Thus, different direct connection trees that need to communicate between the same two nodes may re-use the link and not incur the overhead of creating new links, e.g., not incur the overhead of creating new TCP\/IP links.","It is noted that various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking, a carrier medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","Athough the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the invention can be obtained when the following detailed description is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 8-18"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 20-25"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 27","FIG. 7"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 31-36"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 37-45"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 46-52"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 53-62"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 63"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 64"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 65"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 66"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 67-74"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 75"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 76"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 77"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 78"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 79"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIGS. 80-86"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 87"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 88","b":["331","330","331","330"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 89"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 90"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 91"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 92"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 93-97"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIGS. 98-101"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 102"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 103"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 104"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 105"}]},"DETDESC":[{},{}]}
