---
title: Updating software while it is running
abstract: To avoid extensive time during which servicing of clients' requests is stopped for updating a piece of software or a data structure, various embodiments of the invention update an instance of the piece of software or an instance of the data structure instead of updating the original piece of software or the data structure. This allows the original piece of software or the data structure to service clients' requests without interruption. The updated instance begins to service clients' requests without losing context while the original piece of software or the data structure is terminated from further operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08146073&OS=08146073&RS=08146073
owner: Microsoft Corporation
number: 08146073
owner_city: Redmond
owner_country: US
publication_date: 20040930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention relates generally to software releases, and more particularly, to dynamically updating software so as to add new features or correct errors in software while it is running.","In a large enterprise, such as a corporation, computing resources are interconnected by a network of computer systems owned by the enterprise, which fulfill the enterprise's various computing needs. This network can span diverse geographical locations. Internal users (employees) as well as external clients (customers) of the enterprise need the enterprise's computing resources to be highly available and yet also highly secure. In reality, sometimes these two requirements work against each other. For example, to make the computing resources secure, the computing resources have to be brought down often to install security patches. On the other hand, to make the computing resources readily available with continuous frequency, only rarely should the computing resources be brought down.  illustrates these and other problems in greater detail.","An enterprise network  includes a client , which is a computer through which a user accesses shared computing resources interconnected via the network . These computing resources of the enterprise network  are provided by one or more servers, such as a server A , on which an on-line service is running. To make the on-line service executing on the server A  more secure, the enterprise often sets, as a matter of policy, for an administrator  to patch the on-line service with security fixes for reported or discovered vulnerabilities. Such patches are carried out by installing and applying the patch to a copy of the on-line service (updated service) running on a server B , which acts as a test machine. The administrator  verifies and validates the updated service in accordance with the computing policies of the enterprise to make sure that upon deployment, the updated service would be unlikely to cause problems. The server B  on which the updated service is tested is physically a different machine from the server A  on which the on-line service is providing services to the client . After the updated service has passed the testing on the server B , the administrator  deploys the patch by bringing down the server A  for some period of time during which the on-line service is no longer available to the client . The patch is then applied to the on-line service after which the server A  is brought back up to provide services to the client  again.","The problem with bringing down the server A  so as to install the patch is that the service context is lost at the time the server A  is brought down, and remains inactive. The service context is a state in which the client  has provided requests or some information to the on-line service running on the server A . There is an expectation by the client  that the on-line service will service the request or provide some computation in connection with the provided information. When the on-line service is brought down, such service context is destroyed. When the server A  is brought back up again with the patched on-line service, it is unlikely that the server A  can remember what the client  has previously provided because many services either do not persistently store the service context or the delays caused by the reboot of the server A  is too long to be acceptable to the client . For example, the client  may have sent a search query to the on-line service just prior to the server A  to be brought down. When the on-line service is active again with the patch, no response to the prior query will be provided by the on-line service, hence confusing the client . Another solution, albeit an expensive one, is to run the on-line service on a cluster-based server platform with redundancy built into the server by adding additional processing capacity to mirror the server , but this raises not only the costs of procuring equipment but also the costs of operating the equipment.","Without a resolution to the problem of satisfying the growing requirements of highly secured software while making the highly secured software highly available to users, users may eventually no longer trust the enterprise network  to provide a desired computing experience, causing demand for the enterprise network  to diminish in the marketplace. Thus, there is a need for a system, method, and computer-readable medium for dynamically updating software while avoiding or reducing the foregoing and other problems associated with existing systems.","In accordance with this invention, a system, method, and computer-readable medium for dynamically updating software is provided. The system form of the invention includes a computer system acting as a server for serving clients' requests. The computer system comprises a piece of software executing on the computer system for servicing a request of a client, the piece of software being capable of receiving a context provided by the client. The computer system further comprises an instance of the piece of software that has been updated with a new release of the piece of software. The instance of the piece of software is executed contemporaneously with the piece of software on the computer system so as to allow tests to be performed after which the instance of the piece of software executes and the piece of software terminates without losing the context provided by the client.","In accordance with further aspects of this invention, another system form of the invention includes pieces of software (executing in a computer system) for controlling the transition of one service mode to another service mode. The pieces of software include a service for servicing requests of clients. The service includes a mode among multiple modes that allows the service to obtain a handoff lock and export the state of the service. The pieces of software include a service control manager for causing the service to enter into a particular mode by invoking an assigned callback routine associated with the particular mode. One particular mode includes a customizable mode that allows the service to obtain the handoff lock and export the state of the service.","In accordance with further aspects of this invention, a computer-readable medium form of the invention includes a computer-readable medium having a data structure stored thereon for use by a computing system to export state of a service. The data structure comprises a service internal context tag that is indicative of information pertaining to the internal context generated by the service in servicing a client. The data structure further comprises a client external context tag that is indicative of information pertaining to the external context provided by the client in its request to perform a service.","In accordance with further aspects of this invention, a method implemented on a computer system includes receiving updates to a first service running on a first guest operating system that runs on the computer system, the first service performing requests of clients. The method further includes performing a state handoff by the first service to produce a file containing the state of the first service. The file is exported to an instance of the first service running on a second guest operating system that runs on the computer system. The method yet further includes executing by the instance of the first service, which is updated by the received updates, to service requests of clients and terminating the first service without losing the context provided by the clients to the first service.","To avoid having extensive time during which servicing of clients' requests is stopped for updating a piece of software or a data structure, various embodiments of the invention update an instance of the piece of software or an instance of the data structure instead of updating the original piece of software or the data structure. This allows the original piece of software or the data structure to service clients' requests without interruption. When the updated instance of the piece of software or the instance of the data structure has satisfactorily passed verification and validation, various embodiments of the present invention allow the original piece of software or the data structure to momentarily pause to export its state to the updated instance. The updated instance begins to service clients' requests without losing context while the original piece of software or the data structure is terminated from further operation. The term \u201ca piece of software\u201d means the inclusion of a service running in application mode; a service running in privileged mode; or a portion of the service running in application mode or in privileged mode (e.g., a code fragment).","A system  in which services can be dynamically updated while they are running is illustrated at . The system  includes a client  communicating over a network  to a server . Together, the client  and the server  form a type of computer network architecture called a client\/server architecture. Client\/server architecture composed from the client  and the server  is an arrangement that makes use of disputed intelligence, treating both the server  and the individual client  as intelligent, programmable devices, thus exploiting the full computing power of each. This is done by splitting the processing of a computing task, such as a search process, between two distinct components: \u201cFront-end\u201d client  and \u201cback-end\u201d server . The client , itself a complete, stand-alone personal computer (versus the \u201cdumb\u201d terminal found in older architecture), offers its users a full range of power and features for initiating the computing task. The server , which can be another personal computer, mini-computer, or mainframe, enhances the client  by providing the traditional strengths offered by minicomputers and mainframes in a time-sharing environment, such as data storage, data management, information sharing among clients, sophisticated network administration, security features, and servicing various computing tasks requested by clients, such as the client .","The network  is a group of computers and associated devices that are connected by communication facilities. The network  can involve permanent connections, such as coaxial or other cables, or temporary connections made through telephone or other communication links. The network  can be as small as a LAN (local area network) consisting of a few computers, printers, and other devices, or it can consist of many small and large computers distributed over a vast geographical area (WAN or wide area network). One exemplary implementation of a WAN is the Internet, which is a worldwide collection of networks and gateways that use the TCP\/IP suite of protocols to communicate with one another. The heart of the Internet is the backbone of high-speed data communication lines between major nodes or host computers, including thousands of commercial, government, educational, and other computer systems that route data and messages. One or more Internet nodes can go off-line without endangering the Internet or causing communications on the Internet to stop, because no single computer or network controls the entire Internet.","Using various embodiments of the present invention, the on-line service can be virtually updated to create an updated service without bringing the server  down, hence allowing the on-line service to continue to provide services to the client  without interruption. An administrator  can test the updated service while the on-line service continues to perform computing tasks as requested by the client . When the administrator  is satisfied that the updated service, if deployed, would be unlikely to cause problems to the system , the administrator  can cause the updated service to begin servicing the requests of the client  while the on-line service is uninstalled without the client  realizing that there has been a change. Various embodiments of the present invention allow the state stored by the on-line service to be seamlessly transferred to the updated service without losing the context relied upon by the client .","Using the virtual update capability of various embodiments of the present invention, the administrator  creates a new instance of the on-line service running in an instance of an operating system, which itself runs in parallel to the on-line service and the operating system on which the on-line service is running. The administrator  installs and applies the updates to the instance of the on-line service (updated service). The administrator  then tests and if the testing is successful, the administrator  determines that the updated service can be deployed in the system . The administrator  then causes the on-line service to perform a context handoff to the instance of the on-line service. After the context handoff is completed, the updated service begins to execute at a point where the on-line service left off just prior to the context handoff.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3A","b":["206","206","302","206","302","304","304","304","306","310","310"]},"Virtual machines A, B include sets of virtualized devices that act as virtual hardware for each virtual machine A, B. First and second guest operating systems run in virtual machines A, B without fully recognizing that various instructions and communications are simulated by the virtual server  that eventually will be translated into proper hardware instructions carried out by the hardware . The virtual server , is in essence, a multi-threaded service running, preferably, in the privileged mode of the host operating system , with each virtual machine A, B executing in its own thread of execution. Whereas the host operating system  provides scheduling of central processing unit resources and time and device drivers, as well as provides access to the hardware , the virtual server  maintains a software infrastructure that creates the illusion of different machines (virtual machines A, B) on which guest operating systems can execute.","The on-line service A executes on the first guest operating system, which, in turn, executes on the virtual machine A. The instance of the on-line service that has been updated is the updated service B, which runs on the second guest operating system, and in turn the second guest operating system executes on the virtual machine B. Using virtualization technology, the administrator  can test the updated service B on the same hardware  that the on-line service A depends on to communicate with a client . Various embodiments of the present invention allow the state, which includes the internal context and the external context, of the on-line service A to be captured by the first guest operating system and transfer such state to the second guest operating system via a suitable interprocess communication facility (e.g., pipes or queues) between the virtual machines A, B. The state of the updated service B is then set to the state of the on-line service so that no context is lost when the on-line service A terminates execution and execution of the updated service B is started.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3B","b":["316","318","316","318","316","316","314","318","318","318","318","316","318","318","202","318"]},"In one embodiment, if the service control manager  can invoke a custom command in which any arbitrary callback routine can be associated with the custom command, the ONHANDOFF( ) routine B can be associated with the custom command so as to expand the various modes of the service  to include a handoff mode. When the service  has entered the handoff mode, instructions connected with the ONHANDOFF( ) routine B can be executed to export the state of the first service A for importation into the updated service B. In another embodiment, instead of using a custom command, if a new handoff state can be made part of a service, such as the service , the ONHANDOFF( ) routine B can be associated with that mode. Preferably, in that particular example, one of the instructions in the ONHANDOFF( ) routine B cause the service to pause so as to avoid the receipt of additional requests from the client  while the preparation to switch the servicing from the on-line service A to the updated service B occurs.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3C","FIG. 3C"],"b":["312","312","312","202","5452","202","312","312","5452","312","202","202","312"]},"Both the internal context of the on-line service A as well as the external context of the client can be exported into the file illustrated at . The file includes a beginning tag <SERVICE_INTERNAL_CONTEXT> A and its companion ending tag, <\/SERVICE_INTERNAL_CONTEXT> B. Contained within tags A, B are tag <WORKER_THREAD_SLEEP_TIME> A and its companion ending tag <\/WORKER_THREAD_SLEEP_TIME> B. A numerical value \u201c35\u201d is expressed on line  to indicate the sleep time of the worker thread. The file also includes a beginning tag <CLIENT_EXTERNAL_CONTEXT> A and its companion ending tag <\/CLIENT_EXTERNAL_CONTEXT> B. Nested between tags A, B is another beginning tag <CONTEXT> A and its companion ending tag <\/CONTEXT> B. Contained between tags A, B is a tag <IP> and its companion ending tag <\/IP> at line . An IP address of 16.12.10.10 is enclosed between tag <IP> and its ending tag <\/IP>. Line  expresses the port number 5452 between tag <PORT> and its companion ending tag <\/PORT>. The time \u201c12:53\u201d is captured between tag <TIMESTAMP> and its companion ending tag <\/TIMESTAMP> at line . Line  contains the string provided by the client  \u201chello world\u201d contained between a tag <STRING> and its companion ending tag <\/STRING>. The details associated with the file discussed above should be understood in that the file is presented to illustrate the concept of capturing both the internal and external context of a service and is not meant to limit or restrict the capturing of the service's state to the particular types of information shown in .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIGS. 4A-4H","FIG. 2","FIG. 3A","FIG. 3C"],"b":["400","400","200","202","206","302","304","306","310","310","312","312","400","402","402","312"]},"In the following few steps, the initiation of the virtualization technology is discussed so as to allow various embodiments of the present invention to execute. From terminal A (), the method  initiates the host operating system . See block . At block , the method initiates the virtual server  running in the host operating system . The method  proceeds to block  where the method initiates a first virtual machine, such as the virtual machine A, and a first set of virtualized devices particular to the first virtual machine. The method  initiates a first guest operating system running in the first virtual machine. See block . At block , the method initiates a first service, such as the on-line service A, running on the first guest operating system to provide services to clients, such as the client . At block , the clients send external context (such as a request or information connected with a request) to the first service. The method  then continues at another continuation terminal (\u201cterminal A\u201d).","From terminal A (), the method  proceeds to block  where the first service, such as the on-line service A, stores external context for one client separated from the external context of another client. See the contents of tags A, B of . Next, the first service generates and stores internal context in connection with the servicing of the clients. See block . See also the contents of tags A, B. At block , notification of the availability of updates to the first service is received. The method  then proceeds to block  where it initiates a second virtual machine, such as the virtual machine B, and a second set of virtualized devices particular to the second virtual machine. The method initiates a second guest operating system running in the second virtual machine. See block . At block , the method installs the updates and runs an updated copy of the first service (a second service, such as the updated service B). (Preferably, the second service executes contemporaneously with the first service.) The method  then continues at another continuation terminal (\u201cterminal A\u201d).","From terminal A (), the method  proceeds to block  where the second service running on the second guest operating system is tested, such as by the administrator . A test is performed at decision block  to determine whether the second service is ready to be deployed. If the answer to the test at decision block  is NO, the method  loops back to block  where the above-described processing steps are repeated. If the answer to the test at decision block  is YES, the method  continues to the exit terminal B.","From terminal B (), the method  proceeds to a set of method steps  defined between a continuation terminal (\u201cterminal C\u201d) and an exit terminal (\u201cterminal D\u201d). The set of method steps  causes the first service to perform a state handoff to an instance of the first service (which is the second service or the updated service B). From terminal C (), the method  proceeds to block  where it causes the first service to enter into a handoff mode. The method causes the first service to pause from receiving any further client requests or external context. See block . (One exemplary method is to cause the service control manager  to invoke the ONPAUSE( ) routine A.) The method  then continues to another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the method obtains a handoff lock, which is a global lock, for the first service, so as to ensure that its mode does not change during the handoff. See block . At block , the method finds the external context of each client that is to be handed over to the second service. Preferably, the method should find any client external context that needs to be exported to the second service. The method  proceeds to block  where it finds the internal context of the first service that is to be handed over to the second service. In some cases, it may include internal details such as a number of worker threads, internal queues, and service management data structures. The method exports the external context and the internal context (collectively, the state) to a customizable, tag-based file. See block . (For illustrative purposes only, the file shown at  is an example.) Next, at block , the method changes the networking stack of the first service so as to map existing network connections on the first service to the second service. (Preferably, the virtualization facility, which includes the virtual server  and the virtual machines A, B, exposes application programming interfaces to remap the existing network connections.) The method  then continues at another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the method  proceeds to block  where the listening port of the first service is redirected to the listening port of the second service so as to enable the second service to receive requests from clients. Via interprocess communication such as pipes or queues, the first service requests a service control manager, such as the service control manager , running on the second guest operating system, to flush the state of the second service. See block . (Preferably, this can be accomplished by invoking the ONSTOP( ) routine C of the second service.) Next, at block , the first service requests the service control manager running on the second guest operating system to cause the second service to switch into a context receiving mode. The method  then proceeds to block  where the first service hands to the second service the customizable, tag-based file containing the state of the first service. The method  then proceeds to another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the second service receives the customizable, tag-based file and initializes itself into the state specified by the customizable, tag-based file. See block . (Preferably, the second service initializes various data structures at lower networking layers for effective initialization of a networking protocol that binds to the network interfaces.) A test is performed at decision block  to determine whether the second service has finished initialization. If the answer to the test at decision block  is NO, the method  loops back to block  where the above-described processing steps are repeated. Otherwise, the answer to the test at decision block  is YES, and the second service notifies this first service that the initialization was a success. See block . Next, at block , the first service sends a message to the second service to begin operation. The method  then proceeds to another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the method  proceeds to decision block  where a test is performed to determine whether the second service has acknowledged. If the answer is NO to the test at decision block , the method  loops until the answer is YES. If the answer is YES to the test at decision block , the first service indicates that the updating of the first service was a success. See block . At block , the first service releases the handoff lock. The method  then causes the first service to stop from further execution in preparation for being uninstalled. See block . (Preferably, the method causes the service control manager  to invoke the ONSTOP( ) routine C and another routine for the uninstallation of the first service.) The first service is then uninstalled. See block . The method  then continues to the exit terminal D.","From terminal D (), the method  proceeds to a set of method steps  defined between a continuation terminal (\u201cterminal E\u201d) and another continuation terminal (\u201cterminal F\u201d). The set of method steps  allows the instance of the first service (the second service or the updated service B), which has been modified with the updates, to execute and to service clients of the first service. The method  then terminates execution.","While the preferred embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 4A-4H"}]},"DETDESC":[{},{}]}
