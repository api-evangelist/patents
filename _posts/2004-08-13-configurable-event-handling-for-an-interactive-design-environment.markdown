---
title: Configurable event handling for an interactive design environment
abstract: An API and method for processing a user interface event is provided. The user interface event may take place in any environment of a software application, and may result from any type of user or software action. An embodiment also provides a framework for customizing the processing of a user interface event without the need to maintain accountability of computer states. In the method, an application process user interface event is processed using an operating system process. A user interface event is received by the application process by way of a user interface. A software component adapted to process the user interface event is pushed onto a memory stack by the operating system process. The operating system process processes the user interface event using the software component, and pops the software component from the memory stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07458081&OS=07458081&RS=07458081
owner: Microsoft Corporation
number: 07458081
owner_city: Redmond
owner_country: US
publication_date: 20040813
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","COPYRIGHT NOTICE AND PERMISSION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Exemplary Embodiments","APPENDIX"],"p":["This application is a continuation-in-part and claims priority under 35 U.S.C. \u00a7 120 to co-pending U.S. patent application Ser. No. 10\/400,366, filed Mar. 27, 2003, the disclosure of which is herein incorporated by reference in its entirety.","A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document: Copyright\u00a9 2004, Microsoft Corp.","The present invention relates to computer user interfaces. More particularly, the present invention relates to an Application programming interface (API) for handling user input events that take place in an interactive design environment. Even more particularly, the present invention relates to such APIs that use a memory stack to implement software components that handle user input events.","In computing environments, a user interface (UI) typically allows a user to interact with objects displayed on a display device by using an input device. For example, a user may use a mouse to direct selection indicia, such as a pointer, to an object on a monitor screen, and then may \u201cclick\u201d on the object to select the object or to perform a function on the object. Such a function is typically defined and controlled by the software that is generating the particular UI, or by software that is running transparently to generate the functionality while other software, such as the computer operating system, generates the UI. Sometimes a function that may be performed by the user is defined by the area that is selected, or by the area over which the pointer is placed prior to selection. In other instances, the functions that may be performed are contextual, where a function is made available to a user based on what task is being performed, or by the component of the software that is currently being used. In still other instances, a combination of context and user selection determines an available function.","Because of the context- and user-based nature of computing environments, a computer user may use the same pointer to perform a multitude of tasks. For example, a pointer may enable a default function, such as the ability to select objects on a display device, but when the pointer is placed on the edge of an object it may offer a different function, such as a resizing function. When the user moves the pointer off the edge, the pointer may then revert to its default function.","As a more detailed example, a user may direct a selection pointer to an object and then may select the object. In many computer systems, such a selection may be accomplished by moving a mouse to position the pointer over the desired object, and then by pressing a button on the mouse (\u201cmouse down\u201d) to select the object. Now that the object has been selected, the software may associate this UI event\u2014where the user has placed the pointer over an object and then pressed a button\u2014with a desire to move the object to another location. Such an association is typically referred to as a component\u2014where a UI event defines a function that the software will perform. Accordingly, the software may enable a relocation function, where the user may move the mouse while holding down the button to move the object to another location on the display device. Upon reaching the desired location, the user may release the button (\u201cmouse up\u201d) to fix the object to its new location. Upon completing the movement, the pointer may revert to being a selection pointer, or it may allow the user to perform another function.","As discussed above, the functions performed by the software are typically activated by events initiated by components, such as a component associated with the aforementioned combination of a mouse movement and button click. Correspondingly, for a given component, user actions typically have a fixed meaning. Therefore, a combination of a component and a UI event can be associated with a \u201chandler,\u201d which is a piece of software code activated by the event. The handler contains computer-readable instructions enabling the computer to carry out the necessary functionality.","As discussed briefly above, the context in which the UI event occurs may affect which software function is performed, and which handler is activated. For example, in a design environment, such as an editing mode for permitting user interaction with an electronic document, the meaning of a given UI event may vary greatly. The meaning may depend on a particular editing mode in which the software is currently operating, the editing operation currently being performed, the software tool that is currently active, and the like. For example, in a software application having a graphical image of a button on a display device, such as a \u201cprint\u201d button in a word processor, the UI event of a mouse click on the button could mean different things depending on the context in which the UI event takes place. For example, it could mean the selection of the button to cause a document to print, the start of a movement of the selected button to another location on the display device, or the activation of text editing in the button's label. In each case, the software may be operating in a different editing mode, such as a general document editing mode, a button relocation mode or a button editing mode, respectively.","Because of the variety of editing operations that may be performed for a given UI event, therefore, UI event processing in an editing environment cannot be tied to particular components or software applications. Instead, UI event processing should be handled by a special editing framework. In conventional systems, such a framework involves a systematic means for keeping track of the particular state in which a program is operating. Using the object relocation example given above, a state machine or the like typically performs such a function.","A state machine in such a conventional system keeps track of all the possible previous and next states in which the software may operate. For example, when in a general editing state, the state machine would permit a user to enter into a second state when the user positions the pointer over an object with which it can interact. Once in the second state, the state machine would permit the user to revert to the previous general editing state, which could occur if the user repositioned the pointer over empty space. Alternatively, the state machine could permit the user to enter a third state, which could occur if the user moused down on the object. There may be a plurality of states into which the user may enter at any point. For example, while in the second state, the user may be able to enter any one of several states\u2014such as a third, fourth, fifth or sixth state\u2014depending on the UI event initiated by the user.","As may be appreciated, any software having a rich set of functionality will have a large and complex arrangement of possible states. In addition, the states must be accounted for with perfect accuracy, otherwise inconsistent results or program failure may occur. For example, if the states are not kept perfectly consistent, the same UI event in the same editing mode may yield a different software operation for a given UI event, or may cause the program to crash by causing the state machine to enter into an inconsistent or unplanned-for state.","In many applications, a user such as a programmer or system administrator may wish to customize the software to add functionality to a program that was not originally part of such program. For example, a user with specific requirements may wish to provide an added or different function from the default function when a pointer is moved to an object. Accommodating such a customization adds a requirement to the software to enable UI event handling to be customizable, so that custom tools can be integrated into the software.","One shortcoming of conventional software is that incorporating added functionality into the software can be extremely difficult and complex. For example, in the software discussed above, a user wishing to modify the software would need perfect knowledge of each state used by the software, so a new function could be added to the UI event handling system without causing an illegal function or software crash. If the software has rich functionality, as discussed above, the complexity of the accounting for each of the existing states may cause such a modification to be unduly difficult. In fact, the task is so complicated in conventional software that in most situations, a programmer wishing to customize such conventional software will simply replace the entire UI event handling system rather than attempting to incorporate a new function. Such a replacement is an unnecessarily drastic procedure, particularly when the amount of desired customization is relatively small.","In addition, it is highly desirable that different software applications be able to use a common UI event handling system. A desirable UI event handling system should be able to communicate with a variety of software applications, determine the desired function and then communicate with various components and invoke function calls of the operating system to perform such functions.","What is needed, therefore, is an application programming interface (API) for providing extensible UI event handling in a software application. More particularly, what is needed is an API that enables an editing system to be customized with custom tools, custom types of editable objects, and the like. Even more particularly, what is needed is a software component that can process a user interface event according to the application context in which the event occurs.","In view of the foregoing, the present invention provides an API and method for processing a user interface event. The user interface event may take place in any environment of a software application, and may result from any type of user or software action. An embodiment also provides a framework for customizing the processing of a user interface event without the need to maintain accountability of computer states.","In the method, an application process user interface event is processed using an operating system process. A user interface event is received by the application process by way of a user interface. A software component adapted to process the user interface event is pushed onto a memory stack by the operating system process. The operating system process processes the user interface event using the software component, and pops the software component from the memory stack.","Overview","An embodiment of the present invention is directed to an extensible API that processes UI events. The API issues function calls to process UI events using software components that may be separated from the user actions that require their use. One or more of such components may be called and pushed onto a memory stack in any configuration desired. Additional components, such as a component to determine a function desired by a user based on a user action and application context, may be used to control the use of such components. One or more components may be active or suspended while on the memory stack, and may be terminated by being popped from the stack. An embodiment also enables customization of a UI event handling system by providing a means for maintaining accountability of components without the conventional need to monitor system states.","Exemplary Computing Environment",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules and other data may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and non-volatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and non-volatile, removable and non-removable media implemented in any. method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or non-volatile memory such as ROM  and RAM . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, non-volatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, non-volatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, non-volatile optical disk , such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/non-volatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Exemplary Distributed Computing Frameworks Or Architectures","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and web-enabled interface for applications and computing devices, making computing activities increasingly web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET platform includes servers, building-block services, such as web-based data storage, and downloadable device software. Generally speaking, the NET platform provides (1) the ability to make the entire range of computing devices work together and to have user information automatically updated and synchronized on all of them, (2) increased interactive capability for web sites, enabled by greater use of XML rather than HTML, (3) online services that feature customized access and delivery of products and services to the user from a central starting point for the management of various applications, such as e-mail, for example, or software, such as Office .NET, (4) centralized data storage, which will increase efficiency and ease of access to information, as well as synchronization of information among users and devices, (5) the ability to integrate various communications media, such as e-mail, faxes, and telephones, (6) for developers, the ability to create reusable modules, thereby increasing productivity and reducing the number of programming errors, and (7) many other cross-platform integration features as well.","While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of the invention may also be implemented via an operating system, API, or a \u201cmiddle man\u201d object between a coprocessor and requesting object, such that services may be performed by, supported in, or accessed via all of .NET's languages and services, and in other distributed computing frameworks as well.","An embodiment relates to an API that handles an input event in the context of a software application editing or design environment. As should be known to those of skill in the art, an API is used by an application program to communicate with a computer's operating system or some other control program. An example of an input event that can be handled by an API according to an embodiment is a \u201czoom\u201d tool. As the name implies, a zoom tool changes the scale of an object when viewed on a display device. Different ways of invoking a zoom tool while a user is operating in an application editing mode may exist in a software application. For example, a zoom tool may perform various tasks, such as: changing a zoom level for each click of a mouse wheel while a particular key is depressed, increasing a zoom level for each mouse click while ensuring that the point of the click stays within a visible frame, or decreasing a zoom level for each mouse click while a designated key (such as, for example, the \u201cAlt\u201d key) is held during a mouse down and drag, thereby allowing a user to select a rectangle to be enlarged to fit in the view.","In addition, different applications may have slightly varying programming conventions as to how a particular action, such as a zoom tool, may be activated. Nevertheless, the desired effect of the tool on the edited object is generally identical. Because of the various inputs that may invoke a tool, in one embodiment the component that enables the functionality of a tool is separate from any input event that may activate and control the tool. In such a manner, therefore, the API can recognize the functionality of a tool that should be invoked by any UI event using any programming convention. Accordingly, any editing tool may be implemented as an \u201cedit behavior.\u201d An edit behavior is a software component that responds to UI events to provide editing functionality and describes the set of events in which it is interested. In an embodiment, the API activates the software components by, for example, issuing a function call to the operating system. Details of programming function calls, suitable edit behaviors, and other such software components should be known to one skilled in the art and are therefore not discussed in detail herein for clarity.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 2A-C"},"Turning now to , a device or component of computer  that is operatively connected to system bus  may be in operative communications with event filter  of API . API  is illustrated as a functional box, in which the software components (i.e., edit router , event filter , etc.) are located. This arrangement illustrates the functional relationship between the API, which issues function calls as necessary to invoke the software components to operate in the configuration and manner desired. It will be appreciated in the discussion that follows that references to the software components performing tasks is actually a shorthand for the API  issuing one or more function calls that perform the function(s) of the software component. The API  may then receive results and\/or information relating to the function to issue one or more additional function calls. The memory stack , while located within API  in  and , may be in any location that is operatively accessible to API .","Event filter  may be a software component that performs preliminary processing of UI events, a stand-alone program designed to handle such events or the like. Event filter  may receive UI events directly from user input interface  (not shown), edit router , or may receive such events from an intermediate component of computer . Event filter  may modify such UI events and\/or route UI events to a proper software component for handling. For example, event filter  may make adjustments to the UI event to compensate for the aforementioned variances in program conventions, or the like. Event filter  may in turn be in operative communications with edit router , which in turn may be in operative communications with optional selection router . Furthermore, edit router  and\/or selection router  may be in operative communications with user input interface  (not shown), an intermediate component of computer  or the like.","Edit router , selection router  or both may be in operative communications with edit behaviors -. While  illustrates three edit behaviors -, it may be appreciated that any number of edit behaviors  may be present. Edit router  may be a software component of a software application design environment capable of receiving UI events, either directly from user input interface , system bus , event filter  or the like, and routing such events to one or more edit behaviors . In one embodiment, edit router  has a set number of associated edit behaviors -to which edit router  may route a UI event for handling. For example, one edit router  may have edit behaviors -for performing a zoom, resize and scroll function, while another edit router may have edit behaviors  for performing other functions. As will be discussed below in connection with , more complex arrangements of edit routers , edit behaviors -or the like are possible, thereby enabling the creation of enhanced editing functionality.","Selection router  may be a specialized edit router  that may be used in addition to or in place of edit router . Selection router  may be used to manage the editing selections available to a user based on the types of objects being edited or selected for editing. For example, different object types may require specialized code for editing, such as text, an image, a table or the like. In addition, the selection router  and event filter  may work in combination to determine an appropriate editing behavior based on the context of the UI event within the application. Thus, the event filter  determines the type of UI event that has occurred (e.g., mouse down, etc.), while the selection router  determines the type of environment in which the selection was made (e.g., editing mode, view mode, etc.). Combining the UI event type with the context (e.g., mouse down on a button while in an editing mode) enables the API  to determine the appropriate edit behavior(s)  to use to process the UI event.","One embodiment incorporating a selection router  will be discussed below in connection with . Similarly to edit router , the functionality of a tool is separate from any input event that may activate and control the tool. Accordingly, selection router  may enable flexible user selection of an object so, for example, a table cell when selected could be treated as text for commands such as Bold, or as a table for commands such as Column Width.","As discussed above, edit behavior  may receive an input event from edit router . Although edit router  is shown in , B and , edit router  is not necessary for edit behavior  to receive input events. Edit behavior , for example, could monitor UI events directly, without the intervention of edit router . However, in one embodiment edit router  may be adapted to provide additional functionality to edit behavior , such as for example providing a uniform process for tool activation, a framework for cooperation between multiple tools or a means for customization of tool behavior.","Edit router  and event filter , in one embodiment, may interact to provide an organized means for processing a UI event. For example, edit router  may receive a UI event directly from system bus , user input interface  (not shown) or the like and may route the event to event filter . Edit router  may perform a function based on the event in conjunction with routing the event to event filter , such as calling an edit behavior , or may simply pass the event directly to event filter  without any such processing. Event filter  may then process the event by determining the type of event. For example, the event may be a zoom tool request, a text edit request or the like. Once the type of event is determined, event filter  may instruct edit router  to perform a task related to the event. For example, if the event is a zoom tool request, event filter  may instruct edit router  to call an appropriate edit behavior , such as a zoom tool edit behavior , to process the event. Upon completion of such processing, edit router  may communicate with event filter  that such processing is complete. Event filter  may then instruct edit router  to perform another task, if necessary. Another task may be necessary, for example, if the event requires multi-stage processing, an intervening event requires processing or the like. Alternatively, event filter  may not require edit router  to perform any further tasks until another event is detected.","In an embodiment, only one edit behavior  may be \u201cactive\u201d at a given time. In other words, only one edit behavior  may be available to process a UI event. Alternatively, a plurality of edit behaviors  may be available simultaneously. A variety of factors may determine which edit behavior(s)  may be active, such as for example: which object is currently selected by a user, which editing mode is currently being used, default setting, a customized preference or the like. As will be discussed below in connection with , edit behaviors -may be active, suspended\u2014meaning that such edit behavior  is available for use but is not currently being used, or terminated\u2014where such edit behavior  is not available for use until it is invoked by a component, edit router , event filter  or the like.","Various additional components may also be added to, or may replace components in, the embodiment illustrated in . For example, a possible additional or replacement component is a \u201cselection,\u201d (not shown in  for clarity) which may be a component responsible for accounting for the objects selected by a user, as well as for providing visual feedback of an object's selection. Such feedback may be a sound, change in visual appearance of the object, or the like.","It will be appreciated that  illustrates the API  configuration of , with the edit behaviors -arranged in an array  rather than in the stack  of . Thus, it will be appreciated that the API  may interact with any type of memory that is configured in any fashion.","Referring now to , the API  configuration of  is shown with a nested arrangement of edit routers -. To permit additional flexibility in the configuration and operation of editing tools, such as for example such tools that may be customized by a user, one or more edit routers  may be invoked by an edit behavior , edit router  or the like, which may result in the exemplary nested arrangement illustrated. In , edit router is associated with edit behaviors -, while edit router is associated with edit behaviors -, and likewise edit router is associated with edit behaviors -. Optional selection router  may also be associated with one or more edit routers  and\/or edit behaviors -, or the like.","In one embodiment, and as illustrated, event filter  may be operatively connected to edit router -. Alternatively, a separate event filter  may be operatively connected to each edit router -, or to one or more of several edit routers . Event filter  may review, and in some embodiments change, UI events before such events are processed by an edit behavior , and may also affect which edit behavior  may receive and process the UI event if more than one edit behavior  is active simultaneously. As noted above in connection with , event filter  may perform the same functions for selection router . In an embodiment discussed above in connection with , event filter  may receive a UI event from edit router , and may then perform such review and processing. Event filter  may then instruct edit router to process the event using a particular edit behavior -, or may instruct edit router to call edit routers -, and corresponding edit behaviors -. Event filter  may also instruct edit router as to which edit routers -or edit behaviors -should process the event.","Nesting edit routers -implemented by the API  may enable a software application, user or the like to, for example, customize an existing edit behavior , such as by adding an event filter  that terminates an active edit behavior  upon a user pressing a particular keyboard key. Nesting may also enable the construction of a tool having complex functionality from multiple edit behaviors . For example, a complex tool could be a combination of a primary tool, such as a \u201cpen\u201d or \u201cbrush\u201d tool, with common help tools such as a scroll or zoom tool. In such a situation, a software application could create a user environment where, for example, a common tool is temporarily activated by pressing a designated key while a primary tool is still active, thereby obviating the need to suspend the primary tool. Nesting may further enable an application to arbitrate between multiple, similar edit behaviors  such as, for example, for managing selections of multiple types of objects.","Turning now to , and as noted above, memory stack  may be any location in system memory , non-volatile magnetic disk , non-volatile optical disk  or the like that is accessible to the API . One skilled in the art should be familiar with the operation of a memory stack , and so therefore a detailed explanation of the operation of such a stack  is omitted herein for clarity. As may be appreciated, therefore, the image of memory stack  in  is a functional illustration, and any implementation of such a stack  is consistent with an embodiment.","For ease of description, each position in stack  is labeled as follows: the first (top) row of entries is denoted by position , the second by , third by  and the last by the variable n. The variable n indicates that the number of rows of stack  may be of any size. The first (left) column of stack  is denoted by position A, the second by B and the last by the variable N. As is the case with the number of rows, stack  may contain any number of columns. As may be appreciated, therefore, the number of components, such as edit behaviors , edit routers  or the like, that may be pushed onto stack  may be unbounded. In addition, in an embodiment presented below, only components that are in row  may be active to receive or process UI events, while components in other rows are suspended. However, any row, column or location within stack  may be designated as an \u201cactive\u201d area while still remaining consistent with an embodiment.","Memory stack  may be in operative communications with edit router . Edit router may in turn be operatively connected to edit behaviors -located in column A of stack . In one embodiment, related components, such as edit behavior -, are pushed onto stack  in the same column, such as column A. However, and as discussed above, any convention of pushing related components onto stack  is consistent with an embodiment. Edit router may push edit behaviors -onto stack  when instructed to do so by event filter , in response to a UI event or the like. As in , event filter , and edit router  may be operatively connected to a component or device on system bus .","Edit behavior , for example, may be activated by edit router with a push operation, whereby edit behavior is placed into row  of stack . Alternatively, edit router may push several edit behaviors\u2014such as for example edit behaviors -\u2014onto stack , with one or more of edit behaviors -in row . As shown in , edit behavior is active in row , while edit behaviors -are suspended in rows -n.","Edit router , and its corresponding edit behaviors -, may be pushed onto stack , column B, by edit router , edit behaviors -, at the direction of event filter  or the like. Edit behaviors -are shown in column N, and may be pushed onto stack  by any of edit router -, edit behaviors -, an intermediate component such as a selection router  (not shown) or the like. Although not shown in , one or more event filters  may also be pushed onto stack . As may be appreciated, any combination and number of components may be pushed onto stack . As may also be appreciated, the use of stack  to maintain control of components such as edit behavior  enable one or more edit behaviors  or the like to be added, deleted or modified without interfering with the overall operation of UI event processing. For example, a programmer or specialized user desiring to add an edit behavior  between edit behaviors -would need only add such an edit behavior  and possibly modify event filter , edit router  and\/or the like to recognize that such edit behavior  may be called. Accordingly, the use or monitoring of states is not necessary to incorporate such edit behavior .","As an illustrative example of the use of stack , in one embodiment edit router may push edit behaviors -onto stack  in response to a UI event, a direction from event filter  as in an embodiment discussed above in connection with , or the like. Edit behavior , being in row , is active and may process a UI event. In the event that, for example, event filter  or the like determines that edit behavior is no longer needed to process a UI event, edit behavior may either be suspended or terminated. If suspended, edit behavior may be pushed \u201cdown\u201d a row to row , and another component, such as edit behavior , may be pushed into row , thereby becoming an active edit behavior . Edit behaviors -may be pushed down one or more rows along with edit behavior , pushed to another location on stack , popped from stack , or the like. If terminated, edit behavior may be popped from stack  and edit behaviors -may be shifted up, thereby making edit behavior an active edit behavior .","In one embodiment, a component in column A, or edit router , event filter  or the like, may push one or more components onto stack . For example, active edit behavior may be configured to require additional functionality that may be provided by edit router and its associated edit behaviors -. Accordingly, edit behavior pushes edit router and edit behaviors -onto stack . Edit router , being in row , is active along with edit behavior , and therefore may also process a UI event. Furthermore, in one embodiment, a component in column B, or edit router , event filter  or the like, may push one or more components onto stack . For example, edit router may require functionality that is not provided by its associated edit behaviors -. Accordingly, edit router may push edit behaviors -onto stack . Alternatively, and as in an embodiment discussed above in connection with , event filter  may instruct edit router to push any of edit router and\/or edit behaviors -onto stack  at any point during processing of a UI event. Likewise, event filter  may instruct edit router , or any component, to pop any of edit router and\/or edit behaviors -off stack . As may be appreciated, such a configuration permits multiple levels of processing for a UI input event.","A method by which a computer  or the like may handle a UI event is illustrated with reference to . It will be appreciated in the discussion of  that the UI event is received in an application process, such as for example a word processor or the like. The API  enables communication between the application process and an operating system process that carries out the UI event handling. As was discussed above, the API  implements the components by way of function calls or the like.","At step , edit router  is called. As discussed above, any component, such as event filter , may call edit router  to begin the method. Edit router  may also handle a UT event by sending such event to event filter  for instructions as part of step , before actually being called by event filter  to process the event. Step  may take place at the very beginning of editing, or may take place after previous UI events have been handled by components such as edit behavior  or the like. At step , at least one edit behavior  is pushed onto stack . Step  may take place in response to event filter  instructing edit router  to push such edit behavior  onto stack , solely in response to edit router , or as will be discussed below in connection with step , from another edit behavior . As was discussed above in connection with , at least one of the edit behaviors  that are pushed on stack  will be located in an active area, such as row . As may be appreciated, therefore, if any component, such as edit behavior , edit router  or the like, is already on the stack, such component may be popped from the stack, in which case the component has been terminated, or may be shifted down a row, in which case the component has been suspended.","At step , at least one edit behavior  becomes active and awaits a UI event to process according to the functionality it provides. Internal processes may occur to activate a component on stack  to enable such component to process a UT event. For example, if the component pushed onto stack  is actually several edit behaviors , then an internal method may be called on to perform an initialization of such edit behaviors .","At step , a UI event is received. As noted above, the UT event may be received by edit behavior  by way of event filter  and edit router , directly from user input interface , from event filter  or edit router  individually, or the like. At step , the UT event is processed according to the functionality of the edit behavior . As part of such functionality, and as will be discussed in connection with steps  and , event filter , edit router , edit behavior  or the like may call additional components. Edit behavior  may also, as part of processing the UI event, output a result or change to output peripheral interface , network interface , video interface  or the like. It will be appreciated that such outputting of a result or change, in one embodiment, is received from an operating system process by the API  and sent to an application process. At step , if one or more additional edit behaviors  are needed to process the UI event, then the method will proceed to step  for the called edit behaviors . The processing of the called edit behaviors  may take place concurrently with the processing of the calling edit behavior , consecutively or in any manner desired. As will be discussed below, the calling component may be terminated or suspended upon calling an additional edit behavior .","At step , if one or more additional edit routers  are called to process the UI event, then the method will proceed to step  for the called edit routers . As was the case with step , the processing of the called edit routers  may take place concurrently with the processing of the calling edit behavior , consecutively or in any manner desired. As may be appreciated, the one or more called edit routers  may each have one or more edit behaviors , which may be processed in the same manner as the calling edit behavior . At step , edit behavior  may be terminated if its functionality is no longer needed. If such is the case, the method proceeds to step . If edit behavior  is not to be terminated, then the method proceeds to step , where a suspend determination is made. If edit behavior is suspended, it enters a suspend state at step . A suspend or terminate determination may be made in response to a particular UI event, such as for example a mouse button up, depressing of a particular key or the like. Alternatively, an external operation such as, for example, a tool change or the like may initiate such a determination.","As discussed above in connection with , such a suspend state may occur when edit behavior  is shifted down one or more rows in stack . Edit behavior  may reside in a suspended state until such edit behavior  is re-activated\u2014such as for example by being pushed back to row  of stack  in FIG. \u2014or terminated at step . At step , edit behavior  is terminated by being popped from stack . Edit behavior  may initiate its own termination, or such termination may be initiated by edit router , selection router , event filter  or the like.","At step , the process may end, if no further edit operations are to take place, or a next edit behavior  may become active if the process is to continue. For example, if the currently running edit behavior  is to terminate, but another edit behavior is to become active, then the currently running edit behavior may be popped from stack  at step , and then at step  the process may, as indicated by line , return to steps  or . As may be appreciated, the design of event filters , edit routers  and edit behaviors  may change the exact timing, sequence, number of steps and the like of the method described herein in connection with . For example, edit behavior  may process a UI event and then may be terminated at step ,  without proceeding to steps , ,  or .","As discussed above in connection with , many types of components are available to the API  according to an embodiment. One such component is selection router . Turning now to , selection router  is activated at step . Step  may take place, for example, when event filter  instructs edit router  to push selection router  onto stack , or selection router  may be running concurrently or in place of event filter . If selection router is pushed onto stack , it may be placed in an active area of stack , such as row  of stack  as illustrated in . At step , selection router  monitors for UI events that may activate a selection process such as, for example, a mouse move, mouse down, keyboard focus change or the like. During step , selection router  may optionally have one or more edit routers  and\/or edit behaviors  active or suspended on stack . For example, an edit router  having edit behaviors  that are most applicable to the likely UI events that may be monitored by selection router  may be in place on stack  to enable a faster or more comprehensive response. In fact, one or more edit routers  and\/or edit behaviors  may even be pushed onto stack  before or at the same time selection router  is activated at step .","At step , selection router  processes one or more UI events. In doing so, selection router  may optionally work in conjunction with event filter . In fact, selection router  may incorporate the functionality of event filter , so that selection router  may perform the tasks normally associated with event filter , without having event filter  as a separate component. Assuming that the selection router  and event filter  are separate, the selection router  determines the type of environment in which the UI event occurred. For example, the UI event may have taken place in an editing environment, a viewing environment, or the like. The event filter  determines the type of UI event that took place, such as for example a mouse down, double-click, etc. The API  combines this information to determine one or more appropriate components that should process the UI event.","The selection router  may pass the UI event to an appropriate component for processing at step . If no appropriate components are active or present on stack , then selection router  may proceed to optional step  to push the desired components on to stack . As may be appreciated, a component may be chosen by selection router  to process a UI event according to any criteria, such as for example event kind, presenter type, potential element type, current state (such as in-place active) or the like. Also, selection router  may push a component onto stack  itself, or may instruct another component, such as edit router , to do so. In an embodiment, API  issues function calls or the like as needed to carry out such component-pushing activities.","At step , the appropriate component(s) such as edit router , edit behavior  or the like processes the UI event as discussed above in connection with , step . After processing the UI event, the process may end at step . However, and as may be appreciated, such process may be ongoing, in which case selection router  may continue to monitor UI events at step , as indicated by optional arrow . If the process is to be terminated or suspended, such termination or suspension may take place as discussed above in connection with .","As may be appreciated from the preceding discussion, having selection router  be responsible for UI selection bookkeeping and edit routers  and edit behaviors  for handling UI input events, enables one to extend each independently. Therefore, updating or customization of an individual feature such as, for example, a zoom tool as carried out by edit behavior , may be updated without interfering with the criteria for selecting such tool because the corresponding selection router  or edit router  will remain unaffected. Accordingly, and as discussed above in connection with , changes of any size, even as minor as a single change to an individual component, may be made without the necessity of maintaining perfect accountability of states.","As has been noted throughout the above discussion, UI event handling can be implemented using an API . An exemplary interface definition of such an API  is included in the Appendix. As was also noted above, the API  may issue function calls or the like to an operating system, subsystem or the like to carry out the functionality of the components described herein. Referring now to the Appendix, it can be seen that certain instructions are labeled \u201cpublic,\u201d while others are \u201cprotected.\u201d The public instructions may be called by either internal or external code. In contrast, the protected instructions may only be called by internal code, or by an implementation of the correct class. In addition, other controls may put in place by the API . For example, in one embodiment, an edit behavior  can only be called by an edit router . Such a control may be in place because allowing other components to call an edit behavior may cause stability issues.","An inspection of the exemplary interface definition as included in the Appendix shows sections pertaining to the implementation of edit routers , event filters , edit behaviors , selection routers  and so forth. As the interface definition of the Appendix is only exemplary, it will be appreciated that the syntax exhibited therein is not essential to an embodiment. Thus, any syntax used to create an interface definition of an API  is equally consistent with an embodiment.","While the present invention has been described in connection with the embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example, one skilled in the art will recognize that the present invention as described in the present application may apply to any configuration of components in any type of application environment. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims.","The interface definition that follows below provides an exemplary API according to one embodiment of the present invention.",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003[presentationframework]"},{"entry":"\u2003\u2003namespace MSAvalon.Windows.Design"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public class ActivationEventFilter: EventFilter"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public ActivationEventFilter( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnAttach(EditRouter router);"},{"entry":"\u2003\u2003\u2003\u2003protected override bool OnHandleGenericEvent(object sender, RoutedEventArgs"},{"entry":"args);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public abstract class EditBehavior: IService"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003protected EditBehavior( );"},{"entry":"\u2003\u2003\u2003\u2003public virtual Type AdornerSetType { get; }"},{"entry":"\u2003\u2003\u2003\u2003public DependencyObject BehaviorScope { get; }"},{"entry":"\u2003\u2003\u2003\u2003public bool IsSuspended { get; }"},{"entry":"\u2003\u2003\u2003\u2003public virtual Type ServiceType { get; }"},{"entry":"\u2003\u2003\u2003\u2003public virtual object GetAdornerSet( );"},{"entry":"\u2003\u2003\u2003\u2003protected ICollection GetFilteredSelectedComponents( );"},{"entry":"\u2003\u2003\u2003\u2003protected InputManager GetInputManager( );"},{"entry":"\u2003\u2003\u2003\u2003protected MouseDevice GetPointer( );"},{"entry":"\u2003\u2003\u2003\u2003protected ICollection GetSelectedComponents( );"},{"entry":"\u2003\u2003\u2003\u2003protected object GetService(Type serviceType);"},{"entry":"\u2003\u2003\u2003\u2003protected object GetService(Type serviceType, DependencyObject scope);"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnAttach(DependencyObject scope, EditRouter router);"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnCancel( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnDetach( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnResume( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnSuspend( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public abstract class Editor: EditBehavior, IService"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003protected Editor( );"},{"entry":"\u2003\u2003\u2003\u2003public abstract ISelection Selection { get; }"},{"entry":"\u2003\u2003\u2003\u2003public abstract Type SelectionType { get; }"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[AttributeUsageAttribute(..)]"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public sealed class EditorTypeAttribute: Attribute"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public EditorTypeAttribute(Type type);"},{"entry":"\u2003\u2003\u2003\u2003public Type EditorType { get; set; }"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public class EditRouter: EditBehavior, IService"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public EditRouter( );"},{"entry":"\u2003\u2003\u2003\u2003public EditRouter(DependencyObject scope);"},{"entry":"\u2003\u2003\u2003\u2003public EditRouter(DependencyObject scope, EventFilter eventFilter);"},{"entry":"\u2003\u2003\u2003\u2003public EditRouter(EventFilter eventFilter);"},{"entry":"\u2003\u2003\u2003\u2003public int ActiveBehaviorCount { get; }"},{"entry":"\u2003\u2003\u2003\u2003public EventFilter EventFilter { get; }"},{"entry":"\u2003\u2003\u2003\u2003public bool ForwardingEvents { get; }"},{"entry":"\u2003\u2003\u2003\u2003public int StackDepth { get; }"},{"entry":"\u2003\u2003\u2003\u2003public void Add(EditBehavior editBehavior);"},{"entry":"\u2003\u2003\u2003\u2003public void AddHandler(EditBehavior behavior, DependencyObject scope,"},{"entry":"RoutedEventID routedEvent, Delegate handler);"},{"entry":"\u2003\u2003\u2003\u2003public void ForwardEvents(EditRouter forwardTo);"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnAttach(DependencyObject scope, EditRouter router);"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnDetach( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnResume( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnSuspend( );"},{"entry":"\u2003\u2003\u2003\u2003public IList Peek( );"},{"entry":"\u2003\u2003\u2003\u2003public void Pop( );"},{"entry":"\u2003\u2003\u2003\u2003public void Push(DependencyObject scope);"},{"entry":"\u2003\u2003\u2003\u2003public void Push(DependencyObject scope, EditBehavior editBehavior);"},{"entry":"\u2003\u2003\u2003\u2003public void Push(DependencyObject scope, Type behaviorType);"},{"entry":"\u2003\u2003\u2003\u2003public void Remove(EditBehavior editBehavior);"},{"entry":"\u2003\u2003\u2003\u2003public void RemoveHandler(EditBehavior behavior, DependencyObject scope,"},{"entry":"RoutedEventID routedEvent, Delegate handler);"},{"entry":"\u2003\u2003\u2003\u2003public void Replace(DependencyObject scope, EditBehavior editBehavior);"},{"entry":"\u2003\u2003\u2003\u2003public void Replace(DependencyObject scope, Type behaviorType);"},{"entry":"\u2003\u2003\u2003\u2003public void Resume( );"},{"entry":"\u2003\u2003\u2003\u2003protected void SetEventFilter(EventFilter eventFilter);"},{"entry":"\u2003\u2003\u2003\u2003public void Suspend( );"},{"entry":"\u2003\u2003\u2003\u2003public event EventHandler Changed;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[SerializableAttribute(..)]"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public enum EditRouterChange"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Add,"},{"entry":"\u2003\u2003\u2003\u2003Pop,"},{"entry":"\u2003\u2003\u2003\u2003Push,"},{"entry":"\u2003\u2003\u2003\u2003Remove,"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public class EditRouterChangedEventArgs: EventArgs"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public EditRouterChange Action { get; }"},{"entry":"\u2003\u2003\u2003\u2003public EditBehavior Behavior { get; }"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public abstract class EventFilter"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003protected EventFilter( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnAttach(EditRouter router);"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnBehaviorPopped( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnBehaviorPushed( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual void OnDetach( );"},{"entry":"\u2003\u2003\u2003\u2003protected virtual ICollection OnGetBehaviorRoute(object sender, RoutedEventArgs"},{"entry":"args, IList behaviors);"},{"entry":"\u2003\u2003\u2003\u2003protected virtual bool OnHandleGenericEvent(object sender, RoutedEventArgs"},{"entry":"args);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public class RoutedEventAdapter"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public static Delegate CreateAdapter(Type handlerType, RoutedEventHandler"},{"entry":"genericHandler);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public class SelectionRouter: EditRouter, IService"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public SelectionRouter( );"},{"entry":"\u2003\u2003\u2003\u2003public static readonly DependencyProperty ServiceDependencyID;"},{"entry":"\u2003\u2003\u2003\u2003public Editor EnsureEditor(DependencyObject scope);"},{"entry":"\u2003\u2003\u2003\u2003public Editor EnsureEditor(Type selType);"},{"entry":"\u2003\u2003\u2003\u2003public Editor EnsureEditorRegistration(Type selType);"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnAttach(DependencyObject scope, EditRouter"},{"entry":"containingRouter);"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnDetach( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnResume( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnSuspend( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public class TextEditor: EditBehavior, IService"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public TextEditor(TextArray textArray, TextRangeMovable editRange);"},{"entry":"\u2003\u2003\u2003\u2003public bool AcceptsReturn { get; set; }"},{"entry":"\u2003\u2003\u2003\u2003public bool AcceptsTab { get; set; }"},{"entry":"\u2003\u2003\u2003\u2003public bool IsReadOnly { get; set; }"},{"entry":"\u2003\u2003\u2003\u2003public TextSelection Selection { get; }"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnAttach(DependencyObject scope, EditRouter router);"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnCancel( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnDetach( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnResume( );"},{"entry":"\u2003\u2003\u2003\u2003protected override void OnSuspend( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003[EditorTypeAttribute(..)]"},{"entry":"\u2003\u2003\u2003[XamlDesignerSerializerAttribute(..)]"},{"entry":"\u2003\u2003\u2003[StructLayoutAttribute(..)]"},{"entry":"\u2003\u2003\u2003public sealed class TextSelection: TextRange, IEnumerable, IFrameworkInputElement,"},{"entry":"ILoaded, ILogicalTreeNode"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003public static readonly DependencyProperty AtomicProperty;"},{"entry":"\u2003\u2003\u2003\u2003public TextPosition ActiveEnd { get; }"},{"entry":"\u2003\u2003\u2003\u2003public bool IsCaretVisible { get; }"},{"entry":"\u2003\u2003\u2003\u2003public override void Append(FrameworkContentElement element);"},{"entry":"\u2003\u2003\u2003\u2003public override void Append(string text);"},{"entry":"\u2003\u2003\u2003\u2003public override void Append(UIElement element);"},{"entry":"\u2003\u2003\u2003\u2003public void BeginMoveSequence( );"},{"entry":"\u2003\u2003\u2003\u2003public override bool CanChangeText(TextChangeOptions change);"},{"entry":"\u2003\u2003\u2003\u2003public override TextRange Copy(ObjectCloneDelegate clone);"},{"entry":"\u2003\u2003\u2003\u2003public override TextRange Cut( );"},{"entry":"\u2003\u2003\u2003\u2003public override void Delete( );"},{"entry":"\u2003\u2003\u2003\u2003public void EndMoveSequence( );"},{"entry":"\u2003\u2003\u2003\u2003public override IEnumerator GetContentEnumerator( );"},{"entry":"\u2003\u2003\u2003\u2003public override IEnumerator GetEnumerator( );"},{"entry":"\u2003\u2003\u2003\u2003public void HideCaret( );"},{"entry":"\u2003\u2003\u2003\u2003public void InputText(string text);"},{"entry":"\u2003\u2003\u2003\u2003protected override void MakeUnmovable( );"},{"entry":"\u2003\u2003\u2003\u2003public TextRangeMovable MovableCopy( );"},{"entry":"\u2003\u2003\u2003\u2003public override void Move(ObjectCloneDelegate clone, TextPosition destination);"},{"entry":"\u2003\u2003\u2003\u2003public int Move(TextUnit unit, int count);"},{"entry":"\u2003\u2003\u2003\u2003public int Move(TextUnit unit, int count, TextMoveOptions options, TextPosition"},{"entry":"limit);"},{"entry":"\u2003\u2003\u2003\u2003public int MoveActiveEnd(TextUnit unit, int count);"},{"entry":"\u2003\u2003\u2003\u2003public int MoveActiveEnd(TextUnit unit, int count, TextMoveOptions options,"},{"entry":"TextPosition limit);"},{"entry":"\u2003\u2003\u2003\u2003public int MoveEnd(TextUnit unit, int count);"},{"entry":"\u2003\u2003\u2003\u2003public int MoveEnd(TextUnit unit, int count, TextMoveOptions options,"},{"entry":"TextPosition limit);"},{"entry":"\u2003\u2003\u2003\u2003public int MoveStart(TextUnit unit, int count);"},{"entry":"\u2003\u2003\u2003\u2003public int MoveStart(TextUnit unit, int count, TextMoveOptions options,"},{"entry":"TextPosition limit);"},{"entry":"\u2003\u2003\u2003\u2003public void MoveTo(TextPosition position);"},{"entry":"\u2003\u2003\u2003\u2003public void MoveTo(TextRange range);"},{"entry":"\u2003\u2003\u2003\u2003public override void Paste(TextRange from);"},{"entry":"\u2003\u2003\u2003\u2003public void SetActiveEnd(TextPosition position);"},{"entry":"\u2003\u2003\u2003\u2003public void SetEnd(TextPosition position);"},{"entry":"\u2003\u2003\u2003\u2003public void SetStart(TextPosition position);"},{"entry":"\u2003\u2003\u2003\u2003public void ShowCaret( );"},{"entry":"\u2003\u2003\u2003\u2003public override TextRange UnmovableCopy( );"},{"entry":"\u2003\u2003\u2003\u2003public override void Unposition( );"},{"entry":"\u2003\u2003\u2003\u2003public event EventHandler Moved;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary embodiments of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2C","FIG. 2A"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIG. 2A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
