---
title: Generic service component for message formatting
abstract: An advanced intelligent network for use with a telecommunication service can include a service logic execution environment (SLEE), at least one service application executing in the SLEE, and at least one message formatting generic service component communicatively linked to the service application. The message formatting generic service component can include an interface to an application which is external to the SLEE.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06876733&OS=06876733&RS=06876733
owner: International Business Machines Corporation
number: 06876733
owner_city: Armonk
owner_country: US
publication_date: 20021203
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE INVENTION"],"p":["1. Technical Field","The present invention relates to the field of telecommunications, and more particularly, to generic service components for formatting messages in conjunction with a service logic execution environment.","2. Description of the Related Art","The development of the open network application programming interface (API) represents an important departure from traditional methods for opening the architecture of the public switched telephone network (PSTN). Presently, the Advanced Intelligent Network (AIN) architecture defines a call model which allows the creation of telecommunications service applications outside of the switch environment. Telecommunications service applications are a la carte telecommunications applications which can perform enhanced services for a telecommunications session established among two or more parties. Exemplary service applications can include Call Waiting, Caller ID, Call Forwarding, Message Activated Dialing, and Meet-me Conferencing.","When AIN first was introduced, in terms of the service application creation process, the AIN architecture represented an important advance. AIN separated service development from switching, allowing service logic components to be developed more quickly and placed in specialized network elements attached to databases. Switches, in turn, being free from all service logic, could be optimized for speed and efficiency. Still, typical service applications developed to the AIN specification are written in specialized languages by specially trained programmers using specialized service creation environments.","Importantly, future telecommunications networks will be characterized by new and evolving network architectures where packet-switched, circuit-switched, and wireless networks are integrated to offer subscribers an array of innovative multimedia, multiparty applications. Equally important, it is expected that the process by which telecommunications applications are developed will change, and will no longer solely be the domain of the telecommunications network or service application provider. In fact, in order to provide a broad portfolio of novel, compelling applications rapidly, service application providers will increasingly turn to third-party applications developers and software vendors. Thus, application development in the telecommunications domain will more closely resemble that of software and information technology in general, with customers reaping the benefits of increased competition, reduced time to market, and the rapid leveraging of new technology as it is developed.","To make this vision a reality, the principles of AIN have been discarded in favor of a new service application component paradigm. Specifically, it has been recognized that future integrated networks must offer application developers a set of standard, open APIs so that applications written for compatibility with one vendor's system can execute in the system of another vendor. In consequence, the cost of applications development can be amortized, reducing the final cost to the customer. Java APIs for Integrated Networks (JAIN\u00ae) fulfills the requirements of the new service application component development paradigm. Presently, JAIN includes standard, open published Java APIs for next-generation systems consisting of integrated Internet Protocol (IP) or asynchronous transport mode (ATM) networks, PSTN, and wireless networks. The JAIN APIs include interfaces at the protocol level, for different protocols such as Media Gateway Control Protocol (MGCP), Session Initiation Protocol (SIP), and Transactional Capabilities Application Part (TCAP), as well as protocols residing in the higher layers of the telecommunications protocol stack.","JAIN includes a set of integrated network APIs for the Java platform and an environment to build and integrate JAIN components into services or applications that work across PSTN, packet and wireless networks. The JAIN approach integrates wireline, wireless, and packet-based networks by separating service-based logic from network-based logic.  illustrates a conventional JAIN implementation. As shown in , a conventional JAIN implementation can include a protocol layer  which can include interfaces to IP, wireline and wireless signaling protocols. These protocols can include TCAP, ISUP, INAP, MAP, SIP, MGCP, and H.323. The JAIN implementation also can include a signaling layer  which can include interfaces to provide connectivity management and call control. The conventional JAIN implementation also can include an application layer  for handling secure network access and other external services. Finally, the conventional JAIN implementation can include a service layer  which can include a JAIN compliant service creation and carrier grade service logic execution environment (JSLEE) .","In JAIN, the protocol layer  and the signaling layer  are based upon a Java standardization of specific signaling protocols and provide standardized protocol interfaces in an object model. Additionally, applications and protocol stacks can be interchanged, all the while providing a high degree of portability to the applications in the application layer using protocol stacks from different sources. By comparison, the application layer  provides a single call model across all supported protocols in the protocol layer . Fundamentally, the application layer  provides a single state machine for multiparty, multimedia, and multi-protocol sessions for service components in the application layer . This state machine is accessible by trusted applications that execute in the application layer  through a call control API.","Notably, applications or services executing at the application layer  can communicate directly with protocol adapters in the JSLEE . Protocol adapters typically are class methods, callbacks, event or interfaces that encapsulate the underlying resources such as TCAP, MGCP, etc. The underlying resources can be implemented in many programming languages, but a JAIN-conformant protocol product must provide at least the relevant JAIN API. In contrast, an external application or service executing in the application layer  does not have to be aware of the underlying resources and can remain oblivious to the fact that some of its session or call legs may be using different protocols.","Service components  are the core JAIN components and can execute in the JSLEE . More particularly, service components  are constructed according to a standard component model, and instantiations of component assemblies can execute in coordination with the JSLEE . Using information regarding the protocol layer  which can be incorporated into the JSLEE , service components  can interact with the underlying protocol stacks without having specific knowledge of the protocol stack. The service components  can use the call model provided by the application layer  to implement telecommunication services. More importantly, the JSLEE  can relieve the service components  of conventional lifecycle responsibilities by providing portable support for transactions, persistence, load balancing, security, and object and connection instance pooling. In this way, the service components  can focus on providing telecommunication services.","Despite the apparent advantages of the JAIN specification, however, conventional implementations of the JAIN specification include some drawbacks, particularly in their application to real-time telephony. First, conventional JSLEE implementations include unnecessary system housekeeping chores, for example lifecycle responsibilities. Lifecycle responsibilities, however, are not as critical in the real-time telephony domain as they are in other communication domains. Thus the use of the JSLEE can introduce too many latencies to satisfy the demands for real time operations. More importantly, in order to relieve service components of the complexities of the protocol stacks, conventional SLEEs require specific knowledge of the underlying protocol layer.","Further, the complexities involved make it difficult to port systems, features, and applications across diverse hardware and\/or software environments. For example, because the protocol and logic necessary to access a particular service functionality are included within the service application being developed, any changes to an underlying protocol can necessitate reprogramming of the entire service application. To migrate a given telecommunication application to another hardware and\/or software environment, the telecommunication application must be redesigned and\/or recoded to work with the particular messaging protocol utilized by the application processing platform with which the telecommunication application is to be used.","The invention disclosed herein concerns a method and a system for providing a generic service component (GSC) for use with a service logic execution environment (SLEE). In particular, a GSC can provide a common application programming interface (API) for accessing a particular message formatting platform or application. A message formatting GSC also can include the necessary functionality and protocol information for interacting with those message formatting platforms. Using the common API, message formatting GSCs can be made available to developers in a manner which does not require the developer to have knowledge of any underlying protocols incorporated within the message formatting GSC. Rather, the service application developer need only be concerned with the functionality of each message formatting GSC which is to be called upon within the developer's service application.","Accordingly, the present invention provides a solution on the same platform wherein the service logic executes for generically accessing any of a variety of manufacturer specific or disparate applications which communicate to the SLEE through diverse message formats, such as extensible markup language (XML), hypertext markup language (HTML) and standard generalized markup language (SGML). By maintaining the message formatting platform interface on the service logic platform, service logic applications can be portable across diverse hardware and software platform environments when accompanied by a message formatting GSC. Additionally, message formatting functions need not be incorporated within other GSCs and SCs, but can instead utilize message format functions from the message formatting GSC.","One aspect of the invention can include an advanced intelligent network for use with a telecommunication service. The invention can include a SLEE, at least one service application executing in the SLEE, and at least one message formatting GSC communicatively linked to the service application. The message formatting GSC can include an interface to an application which is external to the SLEE.","A second aspect of the invention can include a message formatting GSC in a telephony environment having a SLEE. The message formatting GSC can be registered with the SLEE for interacting with a service application which may or may not execute within the SLEE. The message formatting GSC can include at least one client service instance. The client service instance can correspond to a message formatting application which can be external to the SLEE. Additionally, each client service instance can include a content interface for publishing an interface to the client service instance.","The message formatting GSC also can include a service wrapper. The service wrapper can provide a common interface to one or more client service instances for routing events between the SLEE and the various client service instances. The service wrapper can include a deployment descriptor for providing configuration information to the SLEE and a service interface for publishing an interface to the service wrapper. Also, the service wrapper can include a protocol stack for managing communications in the telephony environment. Notably, the message formatting GSC can interact with other GSCs, service components, protocol stacks, and external applications.","Another aspect of the invention can include a method of routing events between the SLEE and a message formatting GSC in a telephony environment. In that case, the method can include the message formatting GSC registering with the SLEE and the message formatting GSC receiving a first event routed by the SLEE. The first event can correspond to a service application which the message formatting GSC has been registered to receive from the SLEE. Further, the first event can be from a protocol stack, a service component, an external application, or another GSC. At least one client service instance can be instantiated for communicating with another application. The client service instance can interact with the other application. A second event can be posted to the SLEE responsive to the interaction between the client service instance and the other application. The second event can correspond to the interaction, and can be directed to the service application executing within the SLEE.","The invention disclosed herein concerns a method and a system for providing a generic service component (GSC) for use with a service logic execution environment (SLEE). In particular, a GSC can provide a common application programming interface (API) for accessing message formatting functions. Correspondingly, each GSC can include the necessary functionality and protocol information for interacting with a particular message formatting component. Accordingly, the message formatting component can convert exchanged messages to a platform independent format, such as XML, assuring application portability across diverse hardware and software platforms.","The incorporation of a SLEE configured in accordance with the inventive arrangements can help solve the deficiencies of the prior art by providing an event routing bus which can facilitate inter-service component event communications. By providing more direct event communications, the inherent latencies associated with a JSLEE implementation utilizing the JAIN specification can be reduced. Also, unlike conventional implementations of a SLEE in which service components only can receive and process events received from a client component such as a protocol stack via the SLEE, in the present invention, service components can also receive and process events from other service components. Thus, advanced combinations of service components can be created from macro service components. Accordingly, a series of service components can sequentially perform tasks via the event bus, resulting in a unitary, complex operation. Consequently, the message formatting component can be utilized by other components within the SLEE, thusly eliminating the necessity for redundant message formatting routines within each SLEE component.","The architecture of the present invention also can include a connector\/wrapper interface for communicatively linking the SLEE to client components in the protocol layer. The connector\/wrapper interface between the SLEE and client components in the protocol layer also can help to solve the deficiencies of the prior art by providing a configurable connection through a generic interface to a specific client component without inflexibly binding the client component to the SLEE. Unlike conventional implementations of a SLEE in which the SLEE is directly bound to client components with which the SLEE communicates, in the present invention, the SLEE and client component need not be positioned proximately to one another. Rather, the SLEE and client component can be positioned across a network, if need be. In this way, a more flexible association between client component and SLEE is possible which can facilitate the maintenance and enhancement of the SLEE during life-cycle maintenance. Moreover, the specific knowledge of a particular client component can be removed from the SLEE and included, instead, in the interface of the client component. As a result, the complexity of the SLEE can be reduced.","Finally, the architecture of the present invention can include generic service components for providing an abstracted interface to specific external services. More particularly, while each generic service component can maintain an awareness of a particular implementation of a specific external service, other service components, particularly telephony service components executing in the SLEE, can generally request external services of the generic service component without knowing the particular implementation of a corresponding specific external service. In this way the complexity of service components can be reduced and the service components can be de-coupled from specific implementations of external services.","Notably, implementing a message formatting GSC can allow a SLEE to expansively adjust as hardware\/software platforms change. For example, service applications need not be restricted to a particular message format, such as XML, in order to relay information to the SLEE. Instead, emerging formats, such as voice extensible markup language (VXML), can be utilized by service applications. The SLEE will merely require a new message formatting GSC for VXML messages. Other components within the SLEE need not be altered.",{"@attributes":{"id":"P-00031","num":"00031"},"figref":"FIG. 2","b":["205","210","215","220","215","225","230","230","225","225"]},"The service layer  can include a SLEE server . For example, according to one embodiment of the present invention, the SLEE server  can be a JAIN compliant SLEE server or JSLEE server. The protocol layer  can include one or more protocol stacks which can be configured to interact with the service components  and message formatting GSCs  executing in the SLEE Server  through a signaling layer . Notably, the invention is not limited in regard to the number or type of protocol stacks which can be included in the SLEE server . Rather, SLEE Server  can interact with any protocol stack, for example those protocol stacks configured in accordance with the JAIN specification.","The message formatting GSCs  can provide a common API for accessing message formatting services from one or more different message formatting applications . A message formatting GSC  can be built for each different message formatting application . Moreover, a message formatting GSC  can be built for each different protocol used by a message formatting application . Thus, as shown in , a plurality of message formatting GSCs  can be included, each corresponding to a particular messaging protocol or message formatting application. For example, a different message formatting GSC  can be built for each different manufacturer specific message formatting platform and\/or application. Notably, manufactures can even utilize propriety message formats for security or efficiency reasons to communicate with the SLEE, so long as an appropriate message formatting GSC  is provided.","The SLEE Server  also can include several lifecycle management functions enabling the message formatting GSCs  to be properly loaded within the SLEE Server  for execution. The SLEE Server  can identify configuration and loading parameters associated with each message formatting GSC  to be loaded. Subsequently, the SLEE Server  can execute the message formatting GSCs  using the identified configuration and loading parameters. Finally, the message formatting GSCs  can register with an internal event handling component in the SLEE Server  so that events can be transmitted to and from the message formatting GSCs  executing in the SLEE Server .","In operation, the SLEE Server  can support the transmission and receipt of events to and from the protocol stacks in the protocol layer . More particularly, the events can be transmitted and received in the event handling component included in the SLEE Server . Likewise, service components  and message formatting GSCs  which are registered with the SLEE Server  can receive protocol stack events directed towards particular ones of the service components  and the message formatting GSCs . More specifically, the event handling component can route received events to service components  which have registered with the SLEE Server  to receive such events. The service components  and message formatting GSCs  further can post protocol stack events to the SLEE Server .","The SLEE Server  also can receive and transmit messages among message formatting GSCs , service components , and between a message formatting GSC  and a service component . Specifically, message formatting GSCs  can be configured to post messages to the event handling component of the SLEE Server . The message formatting GSCs  further can be registered with the SLEE Server  to receive posted events from other GSCs, whether message formatting GSCs or not, as well as service components . In this way, inter-GSC and service component communications can be made possible. The message formatting GSCs  can be configured to receive events from external applications  through the SLEE Server  as well as send events to the external applications . For example, those events which are received from external applications  can be posted to the event handling component of the SLEE Server . The events then can be routed to message formatting GSCs  that have registered to receive such events.",{"@attributes":{"id":"P-00037","num":"00037"},"figref":["FIG. 3","FIG. 3"],"b":["235","2","235","305","310","305","200","305"]},"Notably, a given message formatting GSC, such as message formatting GSC C, can be linked to an external message formatting application A, wherein the external message formatting application A performs individual message formatting operations. Alternately, the message formatting operations can be performed by the message formatting GSCs, such as components A and B, without requiring the assistance of an external application. Once the message formatting GSC  performs necessary message formatting functions, the reformatted event can be routed to the particular external application  targeted by the SLEE to receive the event. Subsequently, the service wrapper  can instantiate a client service instance  for processing a particular transaction. The client service instance  also can be instantiated for communicating with a particular external application .","As shown in , and in accordance with the inventive arrangements disclosed herein, one or more message formatting GSCs A, B, and C can be provided, wherein each corresponds to a manufacturer specific message formatting application, external application, or to a particular messaging protocol used by one or more external applications. For example, the service wrapper , as part of the message formatting GSC A, can register with the SLEE Server  to receive message formatting events, such as events formatted using an internal messaging format which are to be converted to an XML format. Accordingly, the message formatting GSC A can be configured to utilize the same messaging protocol as the external application A, for example XML format.","As shown in , the service wrapper  has instantiated three client service instances , one for each received event or series of events comprising a transaction relating to a message formatting function. For example, each of the GSCs  can be associated with a particular external application such that each client service instance within a given GSC  interacts with a same external application to accomplish a different task. Alternatively, a single client service instance  can handle multiple transactions. In that case, each client service instance  of message formatting GSC A, for example, can interact with an associated one of the external applications, in this case external application A. Consequently, if three different external applications, such as a voice processing application, a directory services application, and data management application utilize message formatting GSC A, each external application can be associated with a particular one of the message formatting clients .","Similarly, the message formatting GSC B can include a service wrapper and one or more client service instances for interacting with external applications, such as external application B. For example, message formatting GSC A can receive events formatting using an internal message format and converting such messages to VoiceXML format, required by external application B. As noted, if external applications A and B each utilize the same messaging protocol, then a single message formatting GSC  can interact with both external applications. Still, it should be appreciated that a message formatting GSC can be built for the format required by any external application, including proprietary or private message formats, as may be necessary.","Furthermore, the message formatting GSC C can reference an external message formatting application, such as message formatting application A. The ability for a GSC to allow for message formatting to occur externally demonstrates the inherent flexibility of the GSC model. For example, message formatting application A can contain a library of seldom needed message conversions for legacy protocols. Such a library, accessed through message formatting GSC C, can nevertheless be invaluable on those rare occasions that such legacy protocols are demanded.",{"@attributes":{"id":"P-00043","num":"00043"},"figref":["FIG. 4","FIG. 4"],"b":["235","3","235","305","310","310","310","235","405","410","415","410","235","405","305","310","305","410","235"]},"The present invention can be realized in hardware, software, or a combination of hardware and software. The present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software can be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.","The present invention also can be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which when loaded in a computer system is able to carry out these methods. Computer program in the present context means any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: a) conversion to another language, code or notation; b) reproduction in a different material form.","This invention can be embodied in other forms without departing from the spirit or essential attributes thereof. Accordingly, reference should be made to the following claims, rather than to the foregoing specification, as indicating the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["There are shown in the drawings embodiments which are presently preferred, it being understood, however, that the invention is not limited to the precise arrangements and instrumentalities shown.",{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 3","b":"2"},{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
