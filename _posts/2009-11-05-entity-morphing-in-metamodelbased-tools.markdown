---
title: Entity morphing in metamodel-based tools
abstract: A system and method for morphing entities in metamodel-based business process model and notation (BPMN) tools is disclosed. A command is received for an entity to be morphed from a first non-abstract entity type to a second non-abstract entity type. A modeling infrastructure (MOIN) returns all non-abstract sub-types or siblings of the entity based on an inheritance hierarchy in a metamodel associated with the entity. The second non-abstract entity type is determined from the non-abstract sub-types or siblings of the entity, and the selected entity is morphed from the first non-abstract entity type to the second non-abstract entity type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839186&OS=08839186&RS=08839186
owner: SAP AG
number: 08839186
owner_city: Walldorf
owner_country: DE
publication_date: 20091105
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to model-driven process development, and more particularly to a system and method for refining model entities based on a metamodel definition.","Business Process Management (BPM) tools allow users to model, execute, and monitor your business processes based on a common process model. Business Process Model and Notation (BPMN) is an industry standard graphic notation for representing business process workflows. BPMN shows the end-to-end flow of a business process in a flowchart-type style, and is often used with a user-interface-oriented BPMN tool. One example of a BPMN tool is SAP's NetWeaver BPM component (NW BPM, also referred to as \u201cGalaxy\u201d), which is designed to help users improve the efficiency of business processes, reduce errors in complex repetitive tasks, and lower exception-handling costs. With SAP BPM, users can compose process steps, define business rules and exceptions, model process flows using BPMN, execute process models efficiently, and support interaction with running processes via personalized user interfaces or interactive forms.","In such model-driven development, a metamodel is a model that describes how models can be constructed. In the metamodel, classes can be specified which represent domain entities and define their relationships. These entities and their relationships also contain information for tools built on top of this metamodel, such as a BPMN tool, for example. However, this information currently does not provide any functionality in the modeling infrastructure that rapidly adjusts diagram elements based on a given metamodel definition.","In general, this document discusses a system and method for using an inheritance hierarchy in a metamodel as a manual for a tool on how to refine model entities based on the metamodel definition. This information provides a generic functionality in the modeling infrastructure that rapidly adjusts diagram elements (e.g. of a BPMN tool) based on a given metamodel definition.","In one aspect, a computer-implemented method for morphing entities in metamodel-based business process model and notation (BPMN) tools. The method is performed by execution of computer readable program code by at least one processor of at least one computer system. In another aspect, the method is implemented by a system that includes a storage device and a BPMN tool computer in communication with the storage device.","The method includes receiving a command for an entity to be morphed from a first non-abstract entity type to a second non-abstract entity type, and returning, from a modeling infrastructure (MOIN), all non-abstract sub-types or siblings of the entity based on an inheritance hierarchy in a metamodel associated with the entity. The method further includes determining the second non-abstract entity type from the non-abstract sub-types or siblings of the entity, and morphing the selected entity from the first non-abstract entity type to the second non-abstract entity type.","In yet another aspect, a computer program product for morphing entities in metamodel-based business process model and notation (BPMN) tools is presented. The product comprises a storage medium readable by at least one processor and storing instructions for execution by the at least one processor for receiving a command for an entity to be morphed from a first non-abstract entity type to a second non-abstract entity type, and returning all non-abstract sub-types or siblings of the entity based on an inheritance hierarchy in a metamodel associated with the entity. The instructions further include determining the second non-abstract entity type from the non-abstract sub-types or siblings of the entity, and morphing the selected entity from the first non-abstract entity type to the second non-abstract entity type.","The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","This document describes a system and method for entity morphing in metamodel-based tools. In particular, the system includes functionality in the modeling infrastructure that rapidly adjusts diagram elements based on a given metamodel definition. In accordance with some implementations, a functional module is configured to \u201cmorph\u201d entities of a model based on a given metamodel definition, and can be exposed as a generic command in a modeling infrastructure (MOIN) used by a BPMN tool. The MOIN enables model-driven development, meaning that things that are modeled by a user, such as BPMN artifacts for example, are stored in the form of models inside the MOIN based on given metamodels.","The term \u201cmorphing\u201d as used herein has several meanings, such as, for example, changing to a more concrete type, or changing to a sibling while keeping existing attribute values, relationships and identity wherever possible. Morphing can be done over one level in the inheritance hierarchy, or over multiple levels. In more sophisticated cases, morphing can also mean that a tool can morph on the same level of the hierarchy from sibling to sibling.","In exemplary implementations, morphing is associated with a migrate command, such as a \u201cMigrateToSubTypeCommand\u201d in the MOIN used in SAP's Netweaver BPM to migrate to a sub-type. Such a command gets two parameters: 1) the element that will be migrated; and 2) the class descriptor of the sub-type to which the element will be migrated. In some implementations, an application programming interface (API) provides a set of sub-types that are applicable for morphing of a given element based on an inheritance hierarchy in the metamodel. On execution, the migration command migrates the given model element to one of its non-abstract sub-types (or sibling), and takes over all attribute values and relationships wherever possible.","Once it is decided, either by the user or a program, to morph a model element to one of its non-abstract sub-types\u2014such as morphing a Sequence Connector to a Conditional Sequence Connector as shown in the example of FIG. \u2014the migration command can be executed by code. The following code in the bpem.ide (integrated development environment) plug-in of a developer studio is one example of a migration command that can be called. As an example, the plug-in contains the following code snippet which uses the \u201cMigrateToSubTypeCommand\u201d API:",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<...>"]},{"entry":[{},"Command comm = new MigrateToSubTypeCommand("]},{"entry":[{},"\u2003\u2003getConnection( ),"]},{"entry":[{},"\u2003\u2003GlxIdeMessages.ConvertAbstract2BPMNType_0,"]},{"entry":[{},"\u2003\u2003seqConn,"]},{"entry":[{},"\u2003\u2003ConditionalSequenceConnector.CLASS_DESCRIPTOR);"]},{"entry":[{},"comm.execute( );"]},{"entry":[{},"RefObject element ="]},{"entry":[{},"((MigrateToSubTypeCommand)comm).getMigratedElement( );"]},{"entry":[{},"if(element instanceof ConditionalSequenceConnector){"]},{"entry":[{},"\u2003\u2003csc = (ConditionalSequenceConnector)element;"]},{"entry":[{},"<...>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As illustrated in , which shows an entity morphing system , the plug-in  can be part of a process composer  of a BPMN tool  which generates a workspace  for a user. The process composer  is an application and computer program product, and can be run on a server computer and served to a client computer through a network, while the workspace  is run on one or more client computers.","Entity morphing is performed by an entity morphing engine  in the MOIN , and in some implementations the entity morphing engine is implemented as Java code. In such implementations, the Java code is configured to run inside an ECLIPSE platform. The MOIN  allows model driven development, meaning that the things (e.g. BPMN artifacts) that are modeled by a user are stored in form of entity models  inside the MOIN  according to given metamodels . One example of a metamodel is shown in .","The process composer  and workspace  may also provide a user interface that depicts a graphical notation of BPMN processes and entities, among other information.  shows an exemplary user interface  of a BPMN tool provided by a process composer. In addition to a set of function controls and menus, the user interface includes a folder tree  with a number of folders to indicate modeled processes and message triggers that can be used to trigger a process. The processes can be defined, modeled and generated in a graphical modeling window  of the user interface , using the graphic notation and flowcharting techniques of BPMN to represent domain entities and their relationships according to a metamodel. The user interface  can also include a properties definition area  in which users can define properties of processes, entities, and relationships.  represents a sub-menu for executing the entity morphing process.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5","b":["200","202","204","206"]},"In some entity morphing process implementations, first a new \u201cMigrateToSubTypeCommand\u201d is created via the constructor. A command is a wrapper for MOIN functionality that is used to operate on MOIN entity models. The constructor needs a connection to the MOIN that is used to execute the command, and which provides a human readable description of the command, the element that shall be migrated, and the ClassDescriptor of the sub-type. At , after the Command object has been created, the command is executed via calling the execute( )method. For example, as a result, the \u201cgetMigratedElement( )\u201d can be called on the command object, and at  the migrated element is received that can be cast to its new sub-type and used further.","In an alternative implementation, the MOIN can be configured to provide all non-abstract sub-types for a given model element based on the metamodel. This list can then be visualized, i.e. represented visually in a graphical display, to an end user who can then decide to which of the given sub-types the model element should be morphed. This code is executed before the \u201cMigrateToSubTypeCommand\u201d is constructed.","Some or all of the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of them. Embodiments of the invention can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium, e.g., a machine readable storage device, a machine readable storage medium, a memory device, or a machine-readable propagated signal, for execution by, or to control the operation of, data processing apparatus.","The term \u201cdata processing apparatus\u201d encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.","A computer program (also referred to as a program, software, an application, a software application, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to, a communication interface to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.","Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, embodiments of the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","Embodiments of the invention can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention, or any combination of such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","Certain features which, for clarity, are described in this specification in the context of separate embodiments, may also be provided in combination in a single embodiment. Conversely, various features which, for brevity, are described in the context of a single embodiment, may also be provided in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.","Particular embodiments of the invention have been described. Other embodiments are within the scope of the following claims. For example, the steps recited in the claims can be performed in a different order and still achieve desirable results. In addition, embodiments of the invention are not limited to database architectures that are relational; for example, the invention can be implemented to provide indexing and archiving methods and systems for databases built on models other than the relational model, e.g., navigational databases or object oriented databases, and for databases having records with complex attribute structures, e.g., object oriented programming objects or markup language documents. The processes described may be implemented by applications specifically performing archiving and retrieval functions or embedded within other applications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other aspects will now be described in detail with reference to the following drawings.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
