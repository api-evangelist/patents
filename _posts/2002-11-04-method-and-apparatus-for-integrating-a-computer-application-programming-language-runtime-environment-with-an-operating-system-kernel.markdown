---
title: Method and apparatus for integrating a computer application programming language runtime environment with an operating system kernel
abstract: An application programming language runtime environment is integrated with an operating system kernel. The resulting merged data structures, meta-data structures and access methods contain the consolidation of information needed by the application programming language runtime and the operating system, without duplication. Integrating resources of the application programming language runtime and the operating system reduces the overall memory needed to store the merges data structures and meta data structures. Additionally, overhead in maintaining multiple data structures in parallel is also reduced, thus reducing the processing required. The integrated application programming language runtime and operating system kernel environment can also sharing semantic behavior such that untrusted application program code is prevented from escaping the application programming language runtime environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07082600&OS=07082600&RS=07082600
owner: SavaJe Technologies, Inc.
number: 07082600
owner_city: Chelmsford
owner_country: US
publication_date: 20021104
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETALED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to process management in a computer system having an application programming language runtime and an operating system kernel, and more specifically to integrating the application programming language runtime and an operating system kernel in order to reduce memory and processing requirements and provide a secure process execution environment.","Several attempts have been made to integrate a programming language (and its runtime) with an operating system (OS). In typical systems application programming language and application programming language runtime are developed concurrently. The resulting systems enjoy the benefit of designing both the language and the OS together. Examples of these systems include: Cedar developed by Xerox Parc, Oberon developed at Zurich University and the Inferno OS developed by Lucent Technologies.","Cedar was spawned from an effort to create a combined hardware\/software environment from which applications can be executed. The system is comprised of a hardware architecture and an operating system with an integrated programming language runtime. Cedar hosts a variety of personal applications. After an initial focus on proprietary hardware, the software was ported to general purpose hardware. The system targeted high end workstation hardware for use by professionals (e.g., engineers and office workers). While Cedar attempted to be an application programming language runtime with an operating system, it did so by designing the application programming language runtime together with an operating system. The combination did not specifically focus on reducing processing or memory usage.","Oberon was developed at the Swiss Federal Institute of Technology by Niklaus Wirth. Oberon had similar attributes to the Cedar system, it also began as a proprietary hardware\/software platform. Again, the software was later ported to general purpose hardware. The system consisted of an OS and programming language designed together, with the intent of simplifying the language and software architecture. It was also designed for a high end workstation targeted for professionals. Oberon did not create a strong definition of application process separation, instead it encouraged the interaction of all applications to operate as one.","The Inferno OS was developed by Lucent Technologies and provides an operating system and programming language designed together to run on small networked devices intended to operate in a distributed computing environment. Inferno is yet another example of an OS and programming language being designed together and intended to operate only together. Inferno was designed as a distributed computing environment and was not object oriented.","The present invention provides a method and apparatus for combining an application programming language runtime environment with an operating system kernel. Typically, an application language runtime provides an application with a context that executes within a separate operating system (OS) process and the application simply calls into the functionality of the OS. In the present invention, the application language runtime environment is merged with the operating system kernel such that the typically distinct and separate OS process context is created on top of the combined runtime\/OS system. An examination of the programming language and runtime system along with the features of the target operating system is performed in order to determine which resources of the programming language runtime and operating system can be shared. Aspects of each of the programming language runtime and operating system that resemble each other, or can be made to resemble each other, are identified. The data structures (classes) of the identified resources are merged, and access and management algorithms (methods) for the data structures are modified to accommodate the new data structures and to account for the sharing of the data structures.","In a preferred embodiment of the present invention, one or more of the following programming language runtime and OS resources are integrated: threading data structures and algorithms, synchronization primitives, process resource ownership container data structures, graphical interface components, I\/O components and networking components.","In conventional systems, where there is a distinct separation of the programming language runtime data structures and the operating system data structures it is common to have multiple structures shadowing each other (i.e., one data structure is not fully useful without the other). Additionally, these systems often replicate information.","An exemplary programming language runtime (e.g., JVM) may have a concept of a thread which application programs makes use of. In conventional systems the programming language runtime will maintain a thread data structure that describes the thread features as needed by the programming language runtime. Further the programming language runtime will reference the underlying operating system thread resources (and indirectly the OS thread data structures).","The present invention provides merged data structures that contain the consolidation of information needed by the programming language runtime and the OS, with no duplication. Integrating resources of the programming language runtime and the operating system data structures and access methods can reduce the overall memory needed to store data structures associated with the resource. Additionally, overhead in maintaining two data structures in parallel is also reduced, thus reducing the processing required. Further, many of the core resources (e.g., threading operations) being consolidated, also reduce the processing required for common operations (e.g., thread suspend, resume, synchronizing, etc.). According to the principles of the present invention, the same techniques can be applied to other resource as well.","The present invention provides a method for integrating an application programming language runtime environment with an operating system kernel by providing distinct application processes for executing application programs. The application programming language runtime environment is shared with the distinct application processes. The application programming language runtime environment specification having been designed independent of the operating system kernel. Sharing comprising merging certain class data structures, meta-data structures and access methods of the application programming language runtime environment with class data structures, meta-data structures and access methods of the operating system kernel. The merging results in merged class data structures, merged meta-data structures and merged access methods. The distinct application processes are executed at Step  such that memory for storage of the merged class data structures, the merged class meta-data structures and the merged class access methods, and processing to execute the merged class access methods are reduced.","Various specific resources of the application programming language runtime environment can be integrated including, threading system resources, process synchronization resources, process resource ownership resources, graphical user interface resource, input-output system resources and networking resources.","The application programming language runtime environment can include a security system. Semantic behavior can be shared between the application programming language runtime environment and operating system kernel such that untrusted application program code is prevented from escaping the application programming language runtime environment.","The present invention provides a number of advantages for computer application programs in terms of how, when, and where resources needed by the computer application programs are managed and used. In addition it provides for processes implemented according to the principles of the present invention to leverage the features of the programming language runtime and OS for protection and security. The present invention reduces memory requirements and processing requirements while at the same time supporting multiple separate application processes.","The present invention provides the ability to easily share common resources and object definitions (e.g., class or language construct describing a data structure) between application contexts.","The present invention also improves security of running application processes by adding the ability to create a protected and separate application processes. The application process\/context leverages the protection capabilities of the OS, the protection rules of the application programming language and the protection capabilities of the application program language runtime. The present invention can additionally create a secure environment to protect computer systems from malicious external entities gaining access to local and unauthorized resources.","Support for an existing programming language runtime specification, designed separate from the underlying OS, and with the capability of executing on a completely independent OS is also provided by the present invention.","A description of preferred embodiments of the invention follows. A preferred embodiment of the present invention is implemented as the SavaJe OS developed by SavaJe Technologies, 100 Apollo Drive, Chelmsford, Mass., USA, the assignee of the present invention. While the present invention is particularly shown and described with references to the SavaJe OS preferred embodiment, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope and principles of the present invention.","Since the arrival several years ago of Sun Microsystems' Java\u2122 technology with its concept of \u201cwrite once, run anywhere\u201d applications, developers have struggled to adapt Java to information appliances that have limited resources in a small footprint. The core platform for Java functionality is Java 2 Standard Edition, J2SE\u2122, which is targeted at the desktop, operating interactively within an intranet or on the Internet. Information Appliances do not have the resources to run standard Sun Microsystems' J2SE with anything approaching acceptable performance. Java depends upon the structure of a Virtual Machine (VM) to deliver its concept of portability. Reference or optimized VMs, associated portability layers, classes and libraries normally run on top of a native operating system with its own portability layers, Application Programming Interfaces (APIs) and libraries. This creates performance and size issues on small footprint devices running Java.","To overcome this problem Sun Microsystems has promoted a range of subsets of Java under the overall name of the Java 2 Micro Edition, J2ME\u2122. These subsets overcome the performance issue by restricting functionality, but in doing so remove the core Java value proposition that any Java program written for one client machine will run on another. While this restriction has not to date been too onerous, the emerging generation of smart wireless devices, advanced mobile phones, wireless PDA's, interactive web tablets and internet-enabled gaming machines require the complete application support and client functionality that \u2018full\u2019 Java provides. Moreover the fragmentation of Java into a variety of subsets, and individual \u2018flavors\u2019 from third-party providers of VM technology, has introduced global incompatibilities such that an application provided by one provider may run correctly on a wireless device from one manufacturer but not on those provided by another. The present invention provides solution to overcome the issues that prevent \u201cfull\u201d Java from running on wireless handheld devices. By delivering a \u201cUniversal Java Client\u201d platform that runs all APIs from all subsets of J2ME as well as all APIs from J2SE, the SavaJe OS overcomes both the performance and compatibility problems. With SavaJe OS a handheld wireless device or information appliance is enabled as a full Java client in the Internet or intranet environment.","SavaJe OS is not a Virtual Machine. Designed from the ground up to run Java applications optimally, SavaJe OS is built around a 32-bit, multi-threaded, multi-tasking, pre-emptive, fitfor-purpose kernel. The SavaJe OS includes an embedded Java Virtual Machine (JVM) that is tightly coupled to the operating system kernel, and a complete set of Java libraries. The API for the SavaJe OS is the full range of J2ME and J2SE APIs. SavaJe is a Sun commercial J2SE licensee. The SavaJe OS is fully Sun compliant and is Java branded.","SavaJe OS provides are a small, efficient kernel. Information appliances have less CPU power, memory, and external storage than desktop or server-class systems. As a result efficiency in the use of memory and processing power are important commodities. Application portability is provided by supporting the full range of standard Java 2 APIs, SavaJe OS extends the full functionality of Java to the information appliance world. While there are some concerns that must still be considered when writing applications for information appliances (e.g. the user interface, memory and storage limitations, and network connectivity), application programmers now have the complete and familiar J2SE libraries available. Applications written using SavaJe OS can take full advantage of the abstractions in the Swing and Java 2D APIs to provide a rich graphical experience. SavaJe OS supports a wide variety of screen dimensions, and color depths up to 32-bit. SavaJe OS provides strong and flexible security and delivers application integrity by building directly on Java's inherent security. By default, each application runs in a secure environment that includes its own security manager controlled by a security policy. Full network support provides full support for networking and distributed computing. Connectivity to corporate LANs, local wireless, cellular services, and Personal Area Network (PAN) connections such as Bluetooth is built into the SavaJe OS. Robust applications can be developed with standard Java APIs including RMI, CORBA, and JINI services. SavaJe OS provides far better applications performance in a substantially smaller memory footprint than any other PersonalJava, Personal Profile or J2SE Java implementation on a given hardware platform.","An application programmer's view of SavaJe OS shows that it specifically supports Java applications. The developer's view of SavaJe OS is simple. Any SE or ME app will run on or can be developed for SavaJe. Applications that run on SavaJe OS can be written using any one of the full range of Java APIs\u2014from the Java 2 Micro Edition profiles, such as MIDP, MIDP 2.0 and Personal Profile, to the full rich environment of Java 2 Standard Edition. SavaJe has added optional applications services oriented extension Java APIs, making SavaJe OS the most complete Java client environment available. While SavaJe OS does not support end user applications written in other languages, there are provisions to allow 3rd party native modules written in C, C++ or assembler (drivers, media codecs, or arbitrary libraries) to be integrated into the SavaJe OS. These modules can then be exposed to applications via a suitable Java API.","An architectural view of SavaJe OS reveals that SavaJe OS provides J2SE Class Libraries, J2ME Class Libraries, a Java Virtual Machine, Native Methods, and an OS Kernel\/Graphics\/Networking\/Drivers, running Java applications. The kernel, the graphics system, the JVM, and the Java native methods are tightly bound, allowing performance optimizations not possible in other \u201cgeneral-purpose\u201d operating systems.","The kernel of SavaJe OS provides memory management services, resource locking, thread control and scheduling, and a device driver interface. In addition, the Java Virtual Machine is closely integrated with the kernel. Both the JVM and Java native methods can be considered as kernel-level resources. The kernel, JVM, and device drivers are statically bound. Device drivers, written to a standard interface, allow the kernel to communicate with peripherals, including keyboards, touch screens, and communication ports. Experience has shown that is a comparatively simple task to add existing native modules to the SavaJe OS. Developers may add native modules such as media codecs, or existing C libraries. To support this, SavaJe OS contains an extensive subset of ANSI C and POSIX APIs. Examples of 3rd party source modules include the Java VM itself, the FreeType font engine, the Beatnik Audio Engine, and the ZIP compression library. In some cases source code is not available when creating a SavaJe OS image. SavaJe OS is created with the industry standard GNU tool chain\u2014compiler, linker, assembler, etc. This allows for binary code modules to be added to the SavaJe OS without access to source code. A binary created with these or similar tools can easily be integrated. In addition, SavaJe OS can in some cases link in other arbitrary modules of Advances RISC Machine (ARM) binary code.","To manage physical memory, SavaJe OS uses virtual addresses in a 4 GB address space. Physical memory is divided into 4 KB pages, managed through a two-level hierarchy. At the kernel level, memory is allocated through an efficient malloc( ) for most general uses. Some system objects such as monitors, locks and semaphores are allocated using memory blocks of fixed size. There are no heap size settings since all memory that is not used by the system or by the DRAM file system is available to Java programs.","The SavaJe OS is not a hard real time system. There are no provisions in the SavaJe OS to enforce real time deadlines that are needed for hard real time systems. Rather, the SavaJe OS performs tasks that are time critical to the end user, but not catastrophic\u2014for example playing media can be time critical but missing a frame is not catastrophic to the system. The focus has been on developing a system that is capable of performing these end-user oriented time critical tasks. This may be classified as a soft real time system. One area of concern for key core modules is often that of interrupt dispatch. Measurements on commercially available hardware (206 MHz SA-1110) have shown the SavaJe OS system is capable of sustained processing of approximately 100,000 interrupts per second. This represents an approximate upper bound that will saturate the CPU. On the ARM architecture the use of Fast Interrupt reQuests (FIQs) would allow for more efficient interrupt dispatch. The SavaJe OS kernel is very flexible in allowing for developers to create system threads that can isolate themselves from the Java applications in order to perform sensitive operations. The results can then be passed up to a Java application.","The JVM in SavaJe OS is developed from Sun Microsystems' VM, but has been optimized for size, speed, and low-memory environments. The JVM runs a highly optimized byte code interpreter producing efficient code while conserving memory. The JVM garbage collector is a simple, efficient, mark and sweep garbage collector that uses handles for object references. The garbage collector is optimized for Java finalizers. There is a dynamically sized handle table and no object coalescing. The SavaJe OS JVM is interpretative and does not use JIT techniques. SavaJe OS creates less memory overhead than JIT-based systems. Applications that interact with the user or network typically run up to an order of magnitude faster and with a considerably smaller memory footprint than on other Java platforms. The corollary is that intensive computational tasks written in Java can benchmark slower than on a VM with a built in JIT compiler. The SavaJe OS thread model is implemented to directly support the Java threads API and semantics. A Java thread object is closely tied to a SavaJe OS thread. Non-Java threads are the exception in the SavaJe OS. The underlying thread scheduler implements a time-sliced pre-emptive, fixed-priority, round-robin scheduler. The highest priority ready thread always executes, and threads of equal priority execute in a round-robin fashion.","SavaJe OS can take advantage of any hardware acceleration available in the underlying platform. For example, SavaJe OS can utilize the ARM Jazelle core when available to execute relevant byte codes in hardware. However, experience has shown that most \u201creal-Java\u201d applications (as opposed to small midlets) benefit far more from the other architectural features of the SavaJe OS, than simply from VM acceleration. Sun Microsystems has recently announced the ongoing development of an optimized VM for J2ME CLDC, called the Project Monty VM. This is not a \u201cfull Java\u201d VM but rather a next generation version of the original KVM for MIDP. As such this VM will help accelerate MIDP implementations where midlet performance is restricted by the KVM, but will not be usable \u201cas is\u201d for Personal Profile or J2SE platforms. SavaJe OS will incorporate features from Monty where benefit can be gained.","Since the SavaJe OS operates on platforms that do not necessarily include a hardware floating-point processor, a highly optimized software floating-point emulation library is included. In addition an optimized library supporting the intrinsic math functions is also provided. The SavaJe OS platform also uses integer math wherever possible to minimize performance issues commonly encountered with floating point code.","Similar to most modern operating systems, SavaJe OS launches each application in a distinct process, referred to as a JProc (Java Process). There are a number of unique attributes in the SavaJe OS process model related to Java. By default, a new JProc has the following characteristics: its own class loader and security manager; a private view of class fields (i.e., statics); its own view of Java system properties; graphics context and system threads (for various system-level functions).","These attributes guarantee that one executing application will not interfere with another. SavaJe OS provides separation between processes while at the same time maintaining a single VM instance and sharing the standard system classes (both Java standard classes and SavaJe OS system classes). This is accomplished by treating the VM as an integrated kernel-provided resource to JProcs. In a traditional VM implementation, the VM executes within an OS process context. In contrast, on SavaJe OS, the VM is a service provided to the process by the kernel. This service model is beneficial to the system in general because the VM code and data is loaded and initialized only once, during system initialization. Because SavaJe OS is an always-on operating system, system initialization is a rare occurrence.","SavaJe OS shares system classes across multiple JProcs. All Jprocs follow the Java 2 Class loader delegation model. In this model, classes are loaded via a hierarchy of class loaders. Each class loader, when first asked to load a class, attempts to delegate the task to its parent class loader. The top of the class loader hierarchy is the system class loader (also known as the null, the bootstrap, or the internal class loader). The system class loader is responsible for loading the standard Java classes and all the vendor implementation classes (i.e., the SavaJe OS system classes). Since the individual application class loader does not have to load the system classes, the cost of loading them is shared by all executing SavaJe OS applications. The result is far less memory consumed across the system, and less processing resources required to execute applications.","SavaJe OS security is built upon the standard Java security architecture. The following components play a part in the SavaJe security architecture: the Java Language, Java byte-code verification, Java Security Managers, Java Runtime, Java Jar packaging, Java Security Architecture, SavaJe process model and SavaJe user identity. The Java language contributes to security by providing a type safe language that prevents accidental or intentional access to arbitrary memory locations. In addition, the Java VM enforces language via a process known as byte-code verification. The Java Security Manager infrastructure and its consistent use by the Java Runtime are key components. A policy file that is supplied when the program is executed drives the security manager. Under SavaJe OS the system will start each process with a security manager installed. This mandates that a program be given a policy file. This forced creation of a security manager is a unique feature of the SavaJe OS, providing a stricter security environment than that of a conventional desktop Java application environment. In general, applications should be run with the security manager and given the desired set of permissions. However, under special circumstances (following an explicit action by the programs installer) SavaJe OS makes it possible to start applications without creating a security manager. This allows applications that must load their own security manager in order to execute properly. When a SavaJe OS device is in operation it has a single user identity. A device can support multiple user profiles but only one logged-in user at a time. The method by which this user identity is established is specific to the device. Examples include a user-entered password or a user supplied smart card.","The Java Security Architecture provides a number of tools to allow for the secure delivery of code to a device over an insecure network (e.g. mobile phone networks). The Java application execution model allows for Java Archives (JAR) files, which contain application code and data resources, to be digitally signed. The Java execution platform then will verify the originator of each JAR prior to executing the code. In addition the Java Cryptography Architecture (JCA), Java Cryptography Extension (JCE), and Java Secure Socket Extension (JSSE) provide APIs for implementing additional security. These APIs can allow for secure network connections and data encryption. This lays the foundation for implementing a very secure application delivery mechanism. In a wireless network this can be easily integrated with the carrier and\/or service provider OTA delivery strategy.","The graphics subsystem is a key component of the SavaJe OS platform, playing a significant role in terms of performance and features. The target devices for the SavaJe OS platform are personal hand-held user-oriented devices with compelling graphical interfaces. The performance of a graphics subsystem is a function both of user perceptions and expectations. The interface must be reactive to the user's actions and provide good performance. Key goals of the SavaJe OS graphics subsystem include: immediate reaction to user input, optimized memory utilization, reduced CPU loading, close integration with Java 2 AWT\/Swing, minimal software layers and support for a variety of hardware types. The SavaJe OS platform supports the high-level APIs of Java 2 AWT, Swing and Java2D.","The graphics subsystem is tightly integrated to the AWT semantics and object structure. This integration allows for many optimizations in both memory usage and processing. For example, many of the internal levels of indirection that are found in an AWT implementation on other platforms are not required in the SavaJe OS system. Information stored in many AWT objects is directly manipulated by the core graphics subsystem, rather than copied and\/or translated between un-related software layers. This has the dual advantage of reducing the memory requirements of a high-level graphics component as well as cutting the processing time required to manipulate the component. The SavaJe OS platform is targeted at information appliances with varying screen sizes, levels of color support, types of graphics hardware, and distinct input methods. The graphics subsystem was designed to support a wide range of these hardware variations. By way of an example, while it contains low-level graphics drawing primitives executed in software, it can substitute any available hardware acceleration capabilities that are available. This has an additional advantage for developers\u2014enabling a prototype graphics output device to be developed quickly, followed by incremental addition of hardware acceleration, a key benefit where time to market is critical.","Applications are able to access various media types via standard Java APIs (e.g. MIDP Multimedia Extensions (JSR-135) or the Java Media Framework (JMF) for audio\/video). New media types may be added through protocol specific embedded Codecs. SavaJe OS supports: images (e.g., JPEG, GIF, PNG), audio (e.g., WAV, AU, MP3, MIDI) and video (e.g., MPEG4 with audio stream. The SavaJe OS allows media codecs implemented as native modules. Interaction with the controlling application is via the standard Java APIs, but the kernel can schedule codec threads in isolation from Java application threads. In addition the codec threads can interface directly to the graphics sub-system. This allows for efficient and timely processing of the media stream, even in the presence of Java application garbage collection cycles. The media support framework within the SavaJe OS provides the following: support for multiple media codecs, support for multiple media formats, buffering of media data (streaming or local access), buffering of decoded video frames, intelligent frame dropping and re-sync, interfaces to the graphics subsystem and interfaces to the SavaJe OS audio mixer.","A wide variety of file systems are supported. The file system architecture supports the following: all file systems are accessed via the standard Java APIs, dynamically-mountable file systems, file system implementation in Java or C, support for removable media and support for network file systems. The architecture consists of a core infrastructure implemented in Java as a high-level service. File systems can be dynamically mounted into a single namespace using a simple standard convention. File systems can be implemented as core kernel C modules within a simple Java wrapper, or entirely in Java. SavaJe OS contains five distinct types of file systems: a recoverable read-write RAM file system, a read-only flash based file system, a Microsoft-compliant FAT file system for removable compact-flash cards including disk drives and two network file systems\u2014SMB, and a simple Web server based file system. The mounting convention is that all file systems are mounted at a root (\u201c\/\u201d) with a file system type specific name. Once mounted, a file can be universally accessed via a single namespace\u2014for example: \u201c\/cf0\/foo\/bar.html\u201d. This namespace has the appearance of a UNIX-style file system, with properties similar to Microsoft UNC.","The SavaJe OS supports various connectivity options including short-range peripheral access, synchronization to PC or corporate server and Internet access. SavaJe OS supports a variety of protocols for the following connectivity solutions, including: Ethernet, 802.11 Wireless LAN, Packet Switched wireless networks (e.g., GPRS, CDMA 1xRTT, EDGE, UMTS), Bluetooth, IRDA, USB and Serial.","SavaJe OS provides support for standard protocols over IP networks. An IP network may consist of a home-network, corporate intranet, the Internet or a Peer to Peer connection. Connectivity can occur over a wired Ethernet, a wireless 802.11 Ethernet, or a PPP Link. A PPP link can be established over a standard raw-serial link, IRDA, Bluetooth, or USB connections. Alternatively a network connection can be established over the various cellular wireless technologies such as CDMA, GPRS or UMTS. Java APIs are used to access the network. In general uses the standard Java Socket APIs. Additional industry defined specific Java APIs are supported, e.g. JSR-82 for Bluetooth.","In the SavaJe OS the TCP stack is an efficient implementation optimized for client use. The expectation is that a SavaJe-driven device is a personal, handheld unit. This does not preclude it from functioning as a server, but recognizes the fact that the target device is an end-user node not a large server-oriented appliance. This allows for various size\/speed optimizations to be performed, resulting in a reliable, very efficient network access layer.","On the SavaJe OS a Java application can make use of raw TCP or UDP sockets to implement its own application level protocols. In addition application level protocols such as HTTP, POP, SMTP, etc can be utilized. For advanced, distributed applications SavaJe OS provides the Java APIs for RMI, CORBA, JNDI, JDBC and JINI. This full range of application support allows SavaJe OS to function as a powerful node on the network.","SavaJe OS 2.0 supports Personal Area Networking (PAN) via Bluetooth and IRDA. PAN is useful for quick short-range information transfer between two devices. Support for application registration and discovery is provided by the SavaJe OS. Applications can then use standard Java APIs to utilize OBEX, vCard and vCal as well as connections to devices such as headsets or PDA\/laptops.","SavaJe OS 2.0 includes full support for industry standard SyncML client data synchronization. Various object types including vCard and iCal are used for synchronization to the built in PIM functions. This enables synchronization to a wide variety of industry standard server solutions.","SavaJe OS 2.0 provides a services architecture that offers infrastructure for a number of core services. A service is a high-level system component that contains no user interface and may provide functionality to one or more user applications and\/or other system components. The service framework is a simple, flexible message routing mechanism. Certain services are created at system startup and are critical to proper system behavior. Others are started on demand when needed.","In a modern OS there are a number of operations that periodically occur which are of interest to higher-level components or to end-user applications. These operations are presented as events. System components or applications can register interest in various events and are notified when they occur. The event system is flexible and can be extended. The following are examples of event types: dynamic device introduction\/removal (i.e. CF Card insertion), network connection and battery status (low\/charging).","A document manager service presents applications with a simple access mechanism for all available files over a number of installed file systems. Within each file system the document manager will maintain a set of managed files. Files will be managed based on type. This frees applications from traversing multiple file systems. In addition it can hide the various file systems and their directory structure from the end user. When new file systems are mounted the document manager automatically discovers any previous managed files and adds them to its working set.","Applications can make use of a messaging service that handles the low level details of delivering various forms of user level messages\u2014email, SMS, MMS and IM. This facility enables applications to be developed with messaging features without concern for the lower level detailed functionality. For example a browser may have a send Viewed Page feature, yet an email client contains message creation, send and view features. Both applications can utilize the messaging service. This encourages developer creativity in the application GUI without any need to modify the core messaging functionality.","There are times when the system, system components, or applications need a simple and consistent way to provide information to the end user. The Info Service answers this requirement. According to the circumstances this information may interrupt the user's current activity, may require immediate response, or may be ignored by the user. The OS service provides this functionality without requiring the information generator to be aware of the exact presentation of the information for any given device.","The user interface of a device is critical to the successful adoption of a wireless device. The SavaJe OS is designed to provide a flexible infrastructure upon which device makers can provide their own value-add interfaces. SavaJe OS can be shipped with: device specific\/custom UI, SavaJe SmartPhone Reference UI, SavaJe Pen Reference UI and\/or SavaJe Web Terminal Reference UI. The SavaJe OS can be simply configured to use a UI that replaces any of the reference SavaJe provided UI's. This allows a customer to take full control of the UI specification and implementation. All SavaJe-provided Reference U's contain features that allow for OEM\/Operator\/end-user customization. Such customizations can be end-user themes or skins, operator fixed or OTA-delivered branding, or OEM branding. The SmartPhone UI is appropriate for advanced wireless handsets that include numeric keypad, color screens (typically 208\u00d7176 to 320\u00d7240 pixel resolution), and no pen\/mouse. The Pen UI is appropriate for pen-based tablet devices (typically 320\u00d7240 to 640\u00d7480) with hardware or software keyboards and handwriting recognition. Finally, the Web Terminal UI is intended for a large screen device (typically 640\u00d7480 to 1280\u00d71024) with a keyboard and pointing device (pen, mouse, or a combination). It is also possible for a given device to support multiple U's that are available in certain configurations.","Each UI is composed of a GUI presentation layer and interface to a common core engine. The core engine handles the tasks of managing installed applications, including: what applications can be started, where the applications reside, what icons are associated with the applications, and how to launch the applications. This allows GUI presentation layer designer to be concerned with the details of how to present the information to the user and not with the mechanics of actually installing or launching the applications. The core engine is based on the Java JNLP specification and is compatible with both J2ME MIDP 2.0 OTA specifications, as well as the J2SE paradigm for client applications management. This meets the requirements for OTA application provisioning specified by individual wireless carriers. In addition, the core GUI engine also manages locally installed applications.","In addition to Applications Provisioning and Management SavaJe OS includes capabilities to patch the OS from a connected server. This enables OTA upgrades and patches to be delivered, securely, to customers without the requirement for expensive handset recalls or upgrades. In addition, complete OS replacement can be carried out through a high speed network connection or using a memory card (if available).",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 1","b":["200","210","212","214","220","230","232","234","300","320","102","110","112","114","104","116","118","120","200","220","302","310","312","314","322","330","332","334","300","320","200","220","200","220","214","234","300","310","330","304","324","300","200","220","200","220","300","320","310","312","314","330","332","334"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 2","b":["230","210","212","214","250","230","232","234","420","410","400","420","230","250","400","414","116","118","120","230","250","102","110","112","114","230","250","210","212","214","230","230","232","234","250","420","230","250","230","250"],"i":["a","a","a"]},"The normally separate class data structures of a language runtime system in the prior art and the corresponding support class data structures maintained by the operating system are merged in the present invention into a single class data structure and common set of class methods accessible to both the kernel and the language runtime.","In an object oriented language a class is a definition of an object's data and methods that act on that object. An object is an instance of the class in memory. Thus, for one class and there can be any objects, all of which have similar data structure and the same code to act upon those data structures. Each individual object can have different data contents. In some languages, the class can also contain mutable data of its own. In this case much there is one set of \u201cclass data\u201d per class. Again, there is many objects, one class (and thus one set of class data). In the present invention preserves the expectation of each process seeing \u201cone class\u201d by providing each process with its own unique set of \u201cclass data\u201d, while sharing the class definition (e.g., data structure and meta-data which describe information about the class, and the class methods) across all processes. This provides the notion of one shared class where each process is given its own view. This is in contrast to prior art implementations where each process replicates all bits of information.","The integration of the application programming language runtime environment with the operating system kernel provides for greatly reduced overall memory consumption and processing for systems that execute two or more applications written for the same application language runtime environment.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 3","b":["262","262","262","264","266","268","310","310","310","100","100","310","260","310","268","310","310","268","262"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 4","b":["450","450","450","262","262","270","450","420","410","262","420","450"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":["502","504","506"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 6","b":["50","60","50","70","50","60","70"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 7","FIG. 6"],"b":["50","60","80","80","80","82","86","70","90","92","94","95","92","94"]},"A central processor unit  is also attached to the system bus  and provides for the execution of computer instructions (e.g., PLRT-OS program  and PLRT-OS data ), thus providing for integrating an application programming language runtime environment with an operating system kernel.","While this invention has been particularly shown and described with references to preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims. Specifically, a preferred embodiment of the present invention is implemented as the SavaJe OS. The scope of the present invention encompasses integration of an application programming language runtime context with an operating system kernel context and is not limited to the SavaJe OS. Additionally, any application programming language runtime and operating system kernel can be integrated using the method and apparatus of the present invention, the present invention is not limited to the Java language, nor its corresponding Java Virtual Machine (JVM) application programming language runtime."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of preferred embodiments of the invention, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3","b":"262"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 7","FIG. 6"]}]},"DETDESC":[{},{}]}
