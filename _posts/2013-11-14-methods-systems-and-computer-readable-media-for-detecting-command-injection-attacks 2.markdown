---
title: Methods, systems and computer readable media for detecting command injection attacks
abstract: Methods and systems are described for detecting command injection attacks. A positive, taint inference method includes receiving signature fragments on one hand, converting command injection instructions into command fragments on another hand, thus identifying potential attacks upon the condition that a command injection instruction includes critical untrusted parts by using signature fragments. A system detects command injection attacks using this kind of method, and remediates and rejects potential attacks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09635033&OS=09635033&RS=09635033
owner: University of Virginia Patent Foundation
number: 09635033
owner_city: Charlottesville
owner_country: US
publication_date: 20131114
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","STATEMENT OF GOVERNMENT INTEREST","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMETNS OF THE INVENTION","EXAMPLES","ADDITIONAL EXAMPLES","REFERENCES"],"p":["The present application is a national stage filing of International Application No. PCT\/US2013\/070180, filed Nov. 14, 2013, which claims priority under 35 U.S.C. \u00a7119(e) from U.S. Provisional Application Ser. No. 61\/726,353, filed Nov. 14, 2012, entitled \u201cMethod and System for Securing Applications Against Command Injection Attacks,\u201d the disclosures of which are hereby incorporated by reference herein in their entirety.","This invention was made with Government Support under Grant No. FA8650-10-C-7025, awarded by the Office of U.S. Air Force. The government has certain rights in the invention.","The present invention relates generally to the field of computer system security. More specifically, providing a system and method for detecting and mitigating command injection attacks from occurring on a network, system, device, or media.","Command injection attacks exploit flaws in software. The present inventors recognize that one solution to prevent such attacks would be to avoid software flaws by using safe programming practices or programming constructs that do not allow such flaws. While this approach may be technically feasible, in many instances it is not practical. First, it would be impractical to redesign or re-implement the large body of legacy software that already exists. Second, even for newly-developed software, time-to-market pressure favors the quick delivery of new features over careful security considerations. Third, many software applications are produced by programmers that have not been properly trained in best security practices. And fourth, a software application is often created by composition with other software components whose provenance and adherence to security best practices can be of dubious quality. In short, not only are command injection attacks severe, they are here to stay for the foreseeable future.","Overview","An aspect of an embodiment of the present invention provides, among other things, a method, system, and computer readable medium for protecting software against a class of attacks known as \u201ccommand injection attacks\u201d that exploit common vulnerabilities found in software. The #1 and #2 listed items on MITRE's 2011 list of the \u201cTop 25 Most Dangerous Software Errors\u201d (https:\/\/cwe.mitre.org\/top25\/index.html) and the #1 and #2 listed flaws on the Open Web Application Security Project \u201cTop 10 Application Security Risks\u201d (https:\/\/www.owasp.org\/index.php\/Top_10_2010-Main) enable attackers to craft command injection attacks. Similarly, the #4 listed item on MITRE's list\u2014\u201cImproper Neutralization of Input During Web Page Generation (\u2018Cross-site Scripting\u2019)\u201d\u2014enables attacker to craft command injection attacks. Still yet, the #23 listed item on MITRE's list\u2014\u201cUncontrolled Format String\u201d\u2014enables attacker to craft command injection attacks.","These attacks are dangerous because they will frequently allow attackers to completely take over the software, steal data, or prevent the software from working at all.","Accordingly, an aspect of an invention of the present invention provides an efficient solution for thwarting command injection attacks and for allowing software to continue operating despite attempts at subverting software.","An aspect of the present invention provides for, but not limited thereto, an approach for preventing or mitigating command injection attacks; and accordingly it recognizes that various attacks inject a payload that then gets processed by the software to carry out the attackers' intentions. The problem is that software vulnerabilities allow the malicious attacker payload to be processed normally as if it were a non-malicious payload.","The attack payload can be viewed as foreign genetic material that will typically not be present in the native software. Thus, one approach of stopping command injection attacks is to track all external data processed by software, e.g., network input, data entered in a web form, files uploaded to a server, and monitor its use in security-critical commands. If such data is detected, the software can refuse to carry out the command. Such an approach is referred to as taint propagation. The present inventors recognize that while such an approach may be effective in terms of stopping command injection attacks, this approach is not practical as tracking the flow of data through a software program is expensive and severely impacts performance.","Instead of keeping track of external (potentially malicious) data, an aspect of an embodiment of the present invention provides a method, system, and computer readable medium to identify native genetic material, such as but not limited thereto, command fragments. An aspect of an embodiment of the present invention scans software for fragments that can be used to form commands issued by the software. Whenever the software issues a command, the method or system of the present invention can intercept the command and uses a matching algorithm or method to reassemble the command using the identified fragments. The method or system of the present invention detects an attempted attack by looking for critical parts of the command that do not originate from the previously identified fragments. Once an attack is detected, the method or system of the present invention performs an analysis to determine the type of attacks, and then is able to remediate the attack to allow the software to continue normal operation.","By identifying native genetic material used to form a command (instead of attempting to track foreign material), an aspect of an embodiment of the present invention provides an approach that dispenses with expensive taint propagation techniques.","Furthermore, an aspect of an embodiment of the present invention provides an approach that is transparent and can be automatically applied to software already installed on a computing system, without necessarily involving the original software manufacturer, and without requiring modifications to the software program to be protected.","Accordingly, an aspect of various embodiments of the present invention is that it would have wide applicability. In particular, an aspect of an embodiment of the present invention can be used to secure any software that is network-enabled. An aspect of an embodiment of the present invention protects software against a severe class of attacks known as command injection attacks. Examples of such attacks include Structured Query Language (SQL) Injection Attacks (e.g., database attack), operating system (OS) Command Injection Attacks, Cross-Site Scripting Attacks, LDAP Injection Attacks, XML Injection Attacks, Cross-Site Scripting (XSS) Attacks, and format string attacks. Command injection attacks exploit the #1, #2, #4 and #23 software errors as described in MITRE's list of Top 25 Most Dangerous Software Errors. Further, an aspect of an embodiment of the present invention also allows many software programs to continue normal operation even after an attempted attack.","An aspect of an embodiment of the present invention protects software even after the software manufacturer has shipped it. An aspect of an embodiment of the present invention does not require users to modify the program. An aspect of an embodiment of the present invention can even be applied directly to programs shipped in binary form. Furthermore, modern software makes frequent use of third-party components whose quality may be unknown or untrusted. Accordingly, an aspect of an embodiment of the present invention allows such software to be built with security protection despite these third party components.","The novel aspects of the present invention provides, but not limited thereto, a process and algorithms (and related system and computer readable medium) for determining fragments, reassembling fragments to match commands to determine whether a command is safe or suspicious, such as a potential attack, and allowing software to continue execution despite potential attacks or actual attacks. This may all be done transparently, efficiently, without requiring any efforts from software developers.","An aspect of various embodiments of the present invention may provide a number of advantages, such as but not limited thereto, the ability to protect software without requiring users to modify the software, which therefore makes it a practical solution.","An aspect of an embodiment of the present invention thwarts a severe and important class of attacks, namely command injection attacks. These attacks exploit software vulnerabilities that are in the MITRE's list of the \u201cTop 25 Most Dangerous Software Errors\u201d. An aspect of an embodiment of the present invention also allows many software programs to continue normal operation even after an attempted attack.","An aspect of various embodiments of the present invention may be utilized for a number of products and services, such as but not limited thereto, as discussed below. An aspect of an embodiment of the present invention is applicable to all software. It can be applied on a wide variety of platforms and applications, including laptops, desktops, cell phones, tablets, photo frames, cameras, video recorders, PDAs, routers, web browsers and servers, music players, televisions, game consoles, handheld gaming devices, critical infrastructure devices (traffic lights, power relays), heart-rate monitors, biometric monitors, networked-enabled sensors, etc. The importance of the invention will only rise over time as more and more devices are becoming network-enabled, e.g. refrigerator, home thermostats, automobiles, medical devices, etc. Further, an aspect of an embodiment can be applied on a wide variety of applications for infrastructure related systems and devices, such as power utilities, water utilities, public utilities, office infrastructure, home dwellings, department of defense infrastructure and systems, military equipment and systems, medical equipment and systems, vehicles, aircraft, server farms, and watercraft.","An aspect of an embodiment of the present invention provides a method, system and computer readable medium that can thwart OS command injection attacks (as well as data base or SQL injection attacks, database and web based application; format string attacks; LDAP injection attacks, XPATH injection attacks, cross-site scripting (XSS) attacks, attacks against scripting languages, and NoSQL injection attacks or the like) by matching the program's signature fragments to the commands it attempts to issue. If commands cannot be matched, the software, system and method of an embodiment of the present invention assumes that the command that has been injected into the program is potentially dangerous.","An aspect of an embodiment of the present invention provides, among other things, a method, system and computer readable medium that provides, among other things, taint inference and positive tainting resulting in positive taint inference","An aspect of an embodiment of the present invention is that it does not require the software manufacturer to change their code. In fact, as discussed above, an aspect of an embodiment of the invention can be applied even after the manufacturer has shipped the software.","An aspect of an embodiment of the present invention provides, but not limited thereto, a computer method for detecting command injection attacks. The method may comprise: receiving software code; extracting string fragments from the received software code to provide extracted signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining if the critical parts are untrusted or trusted by matching with the extracted signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","An aspect of an embodiment of the present invention provides, but not limited thereto, a computer method for detecting command injection attacks. The method may comprise: receiving software code; receiving string fragments to provide signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining untrusted or trusted parts of the command instructions by using the signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","An aspect of an embodiment of the present invention provides, but not limited thereto, a system for detecting command injection attacks based on command instructions to be received from a client processor or client data memory (or other processor or data memory as desired, needed or required). The system may comprise: a memory unit operative to store software code; and a processor. The processor may be configured to: extract string fragments from the software code to provide extracted signature fragments; receive the client command instructions; convert the received command instructions into command fragments; identify critical parts from the commands fragments; determine if the critical parts are untrusted or trusted by matching with the extracted signature fragments; identify potential attacks upon the condition that a command includes critical parts that are untrusted; and communicate the identification of potential attacks to an output device.","An aspect of an embodiment of the present invention provides, but not limited thereto, a system for detecting command injection attacks based on command instructions to be received from a client processor or client data memory (or other processor or data memory as desired, needed or required). The system may comprise: a memory unit operative to store software code and a processor. The processor may be configured: receive string fragments to provide signature fragments; receive command instructions; convert the received command instructions into command fragments; identify critical parts from the commands fragments; determine untrusted or trusted parts of the command instructions by using the signature fragments; identify potential attacks upon the condition that a command includes critical parts that are untrusted; and communicate the identification of potential attacks to an output device.","An aspect of an embodiment of the present invention provides, but not limited thereto, a non-transitory computer readable medium including instructions executable by a processor for detecting command injection attacks. The instructions may comprise: receiving software code; extracting string fragments from the received software code to provide extracted signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining if the critical parts are untrusted or trusted by matching with the extracted signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","An aspect of an embodiment of the present invention provides, but not limited thereto, a non-transitory computer readable medium including instructions executable by a processor for detecting command injection attacks. The instructions may comprise: receiving software code; receiving string fragments to provide signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining untrusted or trusted parts of the command instructions by using the signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","An aspect of an embodiment of the present invention provides, but not limited thereto, methods and systems that are described herein for detecting command injection attacks. A positive, taint inference method includes receiving signature fragments on one hand, converting command injection instructions into command fragments on another hand, thus identifying potential attacks upon the condition that a command injection instruction includes critical untrusted parts by using signature fragments. A system detects command injection attacks using this kind of method, and remediates and rejects potential attacks.","These and other objects, along with advantages and features of various aspects of embodiments of the invention disclosed herein, will be made more apparent from the description, drawings and claims that follow.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 9A","b":["302","304","302","306"]},"Still referring to , a command interception module  is provided for intercepting the security-critical commands from the running software  (for example, command injections or executing software) so as to extract security critical commands  there from). As will be discussed herein, the running software  (for example, command injections) may be executed offline instead of online\u2014or a combination thereof. This particular embodiment, for example, may be directed toward OS type command instructions. However, it should be appreciated that the present invention may be applicable to database command instructions or structured query language (SQL) language instructions, instructions to (or for) a web based language; instructions for a format string interpreter; instructions to (or for) a LDAP interpreter, instructions to (or for) a XPATH interpreter, instructions to (or for) a scripting language, and instructions to a NoSQL database, or other types of instruction command or languages. Regarding OS type commands, for example, it should be appreciated that some primary candidates for the family of functions for security-critical commands may include the following families of function: system, popen, rcmd and exec. It should be appreciated that other types of functions or families of functions could be intercepted as well. Also, a type of attack may be a cross-site scripting (XSS) attack.","Additionally, a command parsing module  is provided for identifying the security-critical parts of a command . Some examples of critical parts of a command  may include, for example, critical tokens and keywords. Accordingly, this shall parse the intercepted security-critical commands  to identify the security-critical parts of a command , such as critical tokens and keywords. For OS commands, the security critical parts  may consist of command names, options, delimiters, special characters and the setting of environment variables. This command parsing module  is responsible for identifying the security-critical parts of a command. For example, for OS commands may include implementing a simple, combined lexical analyzer and parser.","Additionally, a trust inference module  is provided for determining the parts of the command that are untrusted or trusted. In an approach, the trust inference module  makes this determination by matching or comparing the intercepted commands  against the extracted signature fragments . If a match is found then that part of the command of the signature fragment is considered trusted according to the trust inference module . Conceptually, the trust inference component  infers which portions of the command come from within the program, and which ones come from external sources (i.e., potentially malicious). In another embodiment, the trust inference component may use different policies for establishing trust. Examples include requiring that critical parts of a command come from one signature, or from a set of related signatures, or using any available annotations.","Accordingly, still referring to , an attack detection module  is provided for 1) scanning the command for any character that has been marked as untrusted by the trust inference component  and 2) scanning the critical tokens and keywords  generated by the command parsing component . If parts of the command are both untrusted and critical then untrusted critical characters  are thereby identified and therefore a potential attack is detected . Whereas, if no parts of the critical command  are both untrusted and critical then it is determined that the whole command  is deemed trusted and blessed  and therefore deemed safe . If deemed safe  then the command may be accepted  and transmitted to a command interpreter  (e.g., a server, such as a backend server). Again, the command interpreter  may be one or more of the following: OS command interpreter, a data base or SQL interpreter, web scripting language interpreter; format string interpreters; LDAP interpreter, XPATH interpreter, and a scripting language interpreter. In addition, a command interpreter may be distributed (e.g., across multiple devices).","For instance, where a potential attack is detected , then the command may be rejected  with an error message  or remediated  for instances where remediation is deemed appropriate. The remediation may include altering the command  so as to deem it acceptable and therefore acceptable for transmission to the command interpreter  (e.g., a server, such as a backend server).","A command response  is transmitted from the command interpreter  (for example, operating system) to the runtime software .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 9B","FIG. 9B","FIG. 9A"],"b":["302","304","306"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 9C","FIG. 9C","FIG. 9A"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 10","b":["401","402","403","428","410","412","414","416","418","420","422","424","426","404","410","404","410","430","404","406","408"]},"Still referring to , in an embodiment the end user, such as a remote user  or intermediate users  may be on the client side while the command interpreter  may be on the server side. However, it should be appreciated that the client side may be at a distance from the server side such as being: in different locations within a building, in different buildings or vehicles, or in various geographical locations. The geographical locations may include different locations within a state or out of state, as well being in different countries or continents. The communications may entail satellite or aerospace communications, for example.","Still referring to , in an embodiment the end user, such as a local user  or the like may be on the client side while the command interpreter  may be on the server side. However, it should be appreciated that both the client side and server side may be integrally located within a single device such as a smart phone, laptop, computer notebook, iPad, PDA, PC or other processor based machines (or machine executable system or device). Moreover, it should be appreciated that rather than being located within single device (e.g., smart phone, laptop, computer notebook, iPad, PDA, PC, desktop, tablet, camera, gaming device, or television or the like) the client side and server side components or modules may be present in multiple devices. Still yet, it should be appreciated that indifferent of being contained within a single device or present in multiple devices, the subject approach may be applied to multiple devices that are networked together either wirelessly or hardwired or both so as to communicate amongst the various devices or some other remote site or system; as well as a combination of communicating amongst the devices as well as with a remote site(s), system(s) or network(s).","Next, referring to  (A, B & C) and  together, it should be appreciated that an embodiment of the present invention system and method may provide an end-user, that may include, for example, a remote user , an intermediate user , and\/or local user  that sends in command injection instructions through the software . In an embodiment, the security device  may include various components or related steps as illustrated in . In some instances, the security device  may include everything in  other than the software ,  and command Interpreter . The security device  detects, monitors, and remediates potential injection attacks received from the software ,  before transmitting accepted\/remediated commands to Command Interpreter , . The remote user , intermediate user , and local user  may be configured to interact or communicate with one another such as through one or more devices, systems, or networks. Alternatively, remote user , intermediate user , and local user  may be configured to be independent of one another.","Still referring to  (A, B & C) and , operationally, for example but limited thereto, the software ,  may be between a user (for example, a remote user , an intermediate user  or a local user ) and the security device . It should be appreciated that physically speaking, the software component ,  may be located at the same location as the command interpreter . Moreover, it should be appreciated that in other embodiments the software component ,  may be located at or inside any of the related components reflected in the illustration of \u2014as well as other locations and devices and systems not shown. For instance, in an embodiment for certain operations, an end user tries to communicate with the command interpreter through software. An aspect of embodiment of the present invention (security device) comes in-between to protect the command interpreter from potential attacks.","Various embodiments or aspects of the invention may be implemented as software in a computing device, or alternatively, on hardware. For example,  schematically depicts a computing device  in which an embodiment of the invention may be implemented. In its most basic configuration, the computing device may include at least one processing unit  and memory . Memory  can be volatile, non-volatile, or some combination of the two. Additionally, the device  may also have other features and\/or functionality. For example, the device may also include additional removable storage  and\/or non-removable storage  including, but not limited to, magnetic or optical disks or tape, as well as writable electrical storage media. The device  may also include one or more communication connections  that may allow the device to communicate with other devices (e.g., other computing devices). The communication connections  may carry information in a communications media. Communications media may embody computer-readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and may include any information delivery media. Computer-readable media may include both storage and communication media. A modulated data signal may include a signal that has one or more of its characteristics set or changes in such a manner as to encode, execute, or process information in the signal. For example, a communication medium may include wired media such as radio, RF, infrared, and other wireless devices.","In addition to implementation on a standalone computing machine, embodiments of the invention may also be implemented on a network system comprising a plurality of computing devices that are in communication with a networking means, such as a network with an infrastructure or an ad hoc network. The network connection may be wired, wireless, or a combination thereof.","As a way of example,  illustrates a network system in which embodiments of the invention may be implemented. In this example, the network system comprises a computer  (e.g., a network server), network connection means or structure  (e.g., wired and\/or wireless connections), computer terminal , and PDA (e.g., a smart-phone)  (or other handheld or portable device, such as a cell phone, laptop computer, tablet computer, GPS receiver, mp3 player, handheld video player, pocket projector, etc. or handheld devices (or nonportable devices) with combinations of such features). The embodiments of the invention may be implemented in anyone of the devices of the system. For example, execution of the instructions or other desired processing maybe performed on the same computing device that is anyone of , , and . Alternatively, an embodiment of the invention maybe performed on different computing devices of the network system. For example, certain desired or required processing or execution may be performed on one of the computing devices of the network (e.g., server ), whereas other processing and execution of the instruction may be performed at another computing device (e.g., terminal ) of the network system, or vice versa. In fact, certain processing or execution may be performed at one computing device (e.g., server ); and the other processing or execution of the instructions may be performed at different computing devices that may or may not be networked. For example, the certain processing may be performed at the terminal , while the other processing or instructions may be passed to a device  where the instructions are executed. This scenario may be of particular value especially when the PDA device, for example, accesses to the network through computer terminal  (or an access point in an ad hoc network). For another example, software to be protected may be executed, encoded or processed with one or more embodiments of the invention. The processed, encoded or executed software can then be distributed to customers. The distribution can be in a form of storage media (e.g. disk) or electronic copy.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 12","FIG. 12","FIG. 12","FIG. 12"],"b":["130","140","11","11","140","140","137","138","137","140","134","137","138"]},"Main memory  also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system  further includes a Read Only Memory (ROM)  (or other non-volatile memory), or other static storage device coupled to a bus  for storing static information and instructions for processor . A storage device  may be coupled to the bus  for storing information and instructions. The storage device  may include a magnetic disk or optical disk, a hard disk drive for reading from and writing to a hard disk, a magnetic disk drive for reading from and writing to a magnetic disk, and\/or an optical disk drive (such as DVD) for reading from and writing to a removable optical disk. The hard disk drive, magnetic disk drive, and optical disk drive may be connected to the system bus by a hard disk drive interface, a magnetic disk drive interface, and an optical disk drive interface, respectively. The drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the general purpose computing devices. Typically computer system  includes an Operating System (OS) stored in a non-volatile storage for managing the computer resources and provides the applications and programs with an access to the computer resources and interfaces. An operating system commonly processes system data and user input, and responds by allocating and managing tasks and internal system resources, such as controlling and allocating memory, prioritizing system requests, controlling input and output devices, facilitating networking and managing files. Non-limiting examples of operating systems are Microsoft Windows, Mac OS X, and Linux.","The term \u201cprocessor\u201d is meant to include any integrated circuit or other electronic device (or collection of devices) capable of performing an operation on at least one instruction including, without limitation, Reduced Instruction Set Core (RISC) processors, CISC microprocessors, Microcontroller Units (MCUs), CISC-based Central Processing Units (CPUs), and Digital Signal Processors (DSPs). The hardware of such devices may be integrated onto a single substrate (e.g., silicon \u201cdie\u201d), or distributed among two or more substrates. Furthermore, various functional aspects of the processor may be implemented solely as software or firmware associated with the processor.","Computer system  may be coupled via bus  to a display , such as a Cathode Ray Tube (CRT), a Liquid Crystal Display (LCD), a flat screen monitor, a touch screen monitor or similar means for displaying text and graphical data to a user. The display may be connected via a video adapter for supporting the display. The display allows a user to view, enter, and\/or edit information that is relevant to the operation of the system. An input device , including alphanumeric and other keys, may be coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The computer system  may be used for implementing the methods and techniques described herein. According to one embodiment, those methods and techniques are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the arrangement. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d (or \u201cmachine-readable medium\u201d) as used herein is an extensible term that refers to any medium or any memory, that participates in providing instructions to a processor, (such as processor ) for execution, or any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). Such a medium may store computer-executable instructions to be executed by a processing element and\/or control logic, and data which is manipulated by a processing element and\/or control logic, and may take many forms, including but not limited to, non-volatile medium, volatile medium, and transmission medium. Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio wave and infrared data communications, or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.). Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punch-cards, paper-tape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer-readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector may receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also may include a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an Integrated Services Digital Network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another non-limiting example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. For example, Ethernet based connection based on IEEE 802.3 standard may be used such as 10\/100 BaseT, 1000 BaseT (gigabit Ethernet), 10 gigabit Ethernet (10 GE or 10 GbE or 10 GigE per IEEE Std 802.3ae-2002 as standard), 40 Gigabit Ethernet (40 GbE), or 100 Gigabit Ethernet (100 GbE as per Ethernet standard IEEE P802.3ba), as described in Cisco Systems, Inc. Publication number 1-587005-001-3 (6\/99), \u201cInternetworking Technologies Handbook\u201d, Chapter 7: \u201cEthernet Technologies\u201d, pages 7-1 to 7-38, which is incorporated in its entirety for all purposes as if fully set forth herein. In such a case, the communication interface  typically include a LAN transceiver or a modem, such as Standard Microsystems Corporation (SMSC) LAN91C111 10\/100 Ethernet transceiver described in the Standard Microsystems Corporation (SMSC) data-sheet \u201cLAN91C111 10\/100 Non-PCI Ethernet Single Chip MAC+PHY\u201d Data-Sheet, Rev. 15 (Feb. 20, 2004), which is incorporated in its entirety for all purposes as if fully set forth herein.","Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network Internet . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on the network link  and through the communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","The processor  may execute received code as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","The concept of instruction location randomization may be implemented and utilized with the related processors, networks, computer systems, internet, modules, and components and functions according to the schemes disclosed herein.","Referring to ,  provides a flow chart depicting an aspect of an embodiment of the present invention computer related method that may include the following steps: receiving software code ; extracting string fragments from said received software code to provide extracted signature fragments ; receiving command instructions ; converting the received command instructions into command fragments ; identifying critical parts from said commands fragments ; determining if said critical parts are untrusted or trusted by matching with said extracted signature fragments ; identifying potential attacks upon the condition that a command includes critical parts that are untrusted ; and communicating said identification of potential attacks to an output device . It should be appreciated that an embodiment may entail a system that comprises an assembly of hardware component modules (or firmware) configured to perform the functions of the enumerated steps.","Referring to ,  provides a flow chart depicting an aspect of an embodiment of the present invention computer related method that may include the following steps: receiving software code ; extracting string fragments from said received software code to provide extracted signature fragments ; intercepting the command instructions ; extracting the intercepted command instructions into command fragments ; parsing commands fragments to determine the critical parts from said command fragments ; matching or comparing the intercepted command instructions against the extracted signature fragments ; wherein if a match is found then that part of the command of the signature fragment is considered trusted ; wherein if parts of the command are both untrusted and critical then such untrusted characters are thereby identified and therefore a potential attack is detected ; wherein if a potential attack is detected, then the command may be rejected with an error message or remediated for instances where remediation is deemed appropriate ; wherein, the remediation may include altering the command so as to deem it acceptable and therefore acceptable for transmission to the command interpreter ; and transmitting the command response from the command interpreter to the run time software . It should be appreciated that an embodiment may entail a system that comprises an assembly of hardware component modules (or firmware) configured to perform the functions of the enumerated steps.","Referring to ,  provides a flow chart depicting an aspect of an embodiment of the present invention computer related method that may include the following steps: receiving software code ; receiving string fragments to provide signature fragments ; receiving command instructions ; converting the received command instructions into command fragments ; identifying critical parts from the commands fragments ; determining untrusted or trusted parts of the command instructions by using the signature fragments ; identifying potential attacks upon the condition that a command includes critical parts that are untrusted ; and communicating the identification of potential attacks to an output device .","It should be appreciated that an embodiment may entail a system that comprises an assembly of hardware component modules (or firmware) configured to perform the functions of the enumerated steps.","Practice of an aspect of an embodiment (or embodiments) of the invention will be still more fully understood from the following examples and experimental results, which are presented herein for illustration only and should not be construed as limiting the invention in any way.","Example and Experimental Results Set No. 1","A. Architecture and Related Method",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 1","b":["204","202","206"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 2"},"The command interception component or module  intercepts security-critical commands so that they can be vetted. The trust inference component or module  determines which characters in the intercepted command should be trusted by matching the command against the extracted string fragments, i.e., signature fragment . Any unmatched character is deemed untrusted. Combining fragments native to the protected binary to infer trust is a novel form of positive taint inference and one of the advantages associated with an embodiment the present invention architecture.","The command parsing component or module  parses the intercepted command to identify critical tokens and keywords. The attack detection component or module  combines the output of the trust inference component\/module  and command parsing component\/module  to determine whether an attack has occurred. A command is deemed an attack if a critical token or keyword is marked as untrusted.","Upon attack detection, an embodiment of the present invention system or method that either rejects  the command outright and returns an error code , or it alters  the command before passing it on to the operating system  (or other command interpreter). Altering may entail changing a part of the command or removing a part of the command. The current prototype uses a simple form of error virtualization that simulates a failed command invocation by substituting an error code in place of the actual command [See 24], [See 25].","To illustrate how an embodiment may work, the present inventors use the following vulnerable program as a working example:",{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","char *path = \u2033\/bin\u2033;"]},{"entry":[{},{},"int main (int argc, char** argv) {"]},{"entry":[{},{},"\u2003char cmd[100];"]},{"entry":[{},{},"\u2003snprintf(cmd, 100,"]},{"entry":[{},{},"\u2003\u2003\u2033%s\/cat %s\u2033, path, argv[1]);"]},{"entry":[{},{},"\u2003system(cmd);"]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"When the program in the working example is passed a benign input such as \u201cREADME\u201d, the resulting command is shown in the first line of . The Trust Inference component annotates each character in the command (B denotes that the character is trusted, U denotes untrusted), as denoted by the second line of the figure. In this case, \/bin\/cat is trusted as it matches the composition of the signature fragments \u201c\/bin\u201d and \u201c\/cat\u201d extracted in the offline signature Fragment Extraction process (see ). The command parsing component  identifies critical tokens and keywords (c denotes critical), as shown in the third line of the . Lastly, the Attack Detection component  takes as input the intercepted commands along with all annotations and marks any critical command that is not trusted. Since all critical commands are trusted, the command is determined to be legitimate and is allowed to execute.","C. Example with Attack Input","Consider the malicious input README; rm -fr * that seeks to recursively delete user files. The resulting command is shown in . Like the other example, the Trust Inference component annotates each character in the command. Again, only \/bin\/cat matches the extracted fragments. The Command Parsing component identifies critical tokens and keywords, like before, except that this time the semicolon, rm command, and the -fr flags identified as critical, as shown on the third line. Lastly, the Attack Detection component is invoked, and detects that there are critical command characters that are untrusted (shown with asterisks on the fourth line of ). Since this particular embodiment of the system and method has detected the attack, an appropriate remediation technique can be applied. The program can be shut down or the command can be blocked or sanitized before allowing it to be passed to the operating system.","Example and Experimental Results Set No. 2","Software, System and Method Detailed Overview","While the present illustration architecture is generic, e.g., it could be applied to web applications, mobile applications, or the like as discussed throughout the present disclosure, the present inventors present details and discuss challenges encountered as the inventors map the software, system and method into a practical instantiation to defeat OS command injection attacks for binary programs.","A. Signature Fragment Extraction","The accuracy of the fragment extraction process may be crucial. If fragments are missed, valid commands might be flagged as injections. If extra fragments are extracted, malicious command injections might not be flagged (See Example Set No. 4 at Section B for further discussion).","1) String extraction: Extracting string fragments from binary programs is more difficult than it first appears. The present inventors' first attempt used the Linux program strings, which linearly scans a binary program and extracts null-terminated sequences of ASCII characters that have a length larger than a given threshold. Unfortunately, short strings are sometimes important. Consider this C++ snippet:",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","string q = \u2033rm \u2033;"]},{"entry":[{},{},"q += \u2033-f \u2033;"]},{"entry":[{},{},"q += filename;"]},{"entry":[{},{},"system(q.c_str( ) ) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Using strings, the threshold needs to be sufficiently low to find short strings. Unfortunately, low thresholds tend to yield lots of garbage strings, which affects accuracy. Furthermore, compilers use many optimizations that can make strings harder to detect. For example, to initialize a string on the stack, a compiler might use a sequence of store instructions:",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","move [esp+28], 0x2d206d72 # \u2033rm -\u2033"]},{"entry":[{},{},"move [esp+32], 0x00002066 # \u2033f \\0\\0\u2033"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"To deal with these issues, the present inventors use static analysis of the program to derive the string fragments. The static analysis starts by fully disassembling the program into a database which holds each instruction in the program, indexable by address, function, and control flow information. The present inventors use a hybrid linear-scan disassembler and recursive-descent disassembler to ensure we get good coverage of all instructions, as described by Hiser. et al. [See 26], [See 27].","After disassembly is complete, the instructions are scanned for accesses or creation of string values. The present inventors analyze each instruction's immediate operands and apply three heuristics to identify string fragments:\n\n","2) Post-processing of Signature Fragments: Programs compiled from C or C++ often contain statements that use format specifiers, e.g. % d, % f, % s, % x. We split such fragments into their constituent sub-fragments using the format specifiers as delimiters. A fragment such as","\u201c\/bin\/rm -f % s; \/bin\/touch % s\u201d","would be split into the sub-fragments \u201c\/bin\/rm -f\u201d, and \u201c; \/bin\/touch\u201d. As the analysis cannot be sure that such fragments are used as format strings, the original fragment as well as the sub-fragments are retained in the list of signatures.",{"@attributes":{"id":"p-0107","num":"0110"},"figref":"FIG. 4","b":["11","34","173","46","57","314","273","282"]},"The present inventors noticed the short fragments that contain potentially dangerous shell metacharacters (fragments -), or short fragments that could be composed in an attack (fragments -). In Example Set No. 2 at Section E and Example Set No. 3, the present inventors discuss how the software, system and method policies deal with short and potentially dangerous fragments.  provides sample fragments manually extracted from SpamAssassin Miller Plugin [See 4] (28 shown out of 315 fragments total).","B. Command Interception","For binaries derived from C\/C++, commands are typically encapsulated in an Application Programming Interface (API) and accessed via dynamically-linked shared libraries.","The software, method and system prototype may leverages standard library interposition facilities to transparently intercept and wrap function calls to the underlying operating system. The software, method and system intercepts the system, popen, rcmd, and exec family of functions. Other functions could be intercepted as well, but the present inventors have identified these as the primary candidates for OS command injection.","C. Command Parsing","This component is responsible for identifying the security-critical parts of a command. For OS commands, the critical parts consist of command names, options, delimiters, and the setting of environment variables.","The software, method and system prototype uses a simple, combined lexical analyzer and parser. The parser is careful to identify special characters which could indicate the start of a new command (such as the semicolon character), match quotation marks and parentheses, etc. Ideally, the present inventors would use a full, formally-verified lexical analyzer and distinct parser to detect keywords, etc. However, it may be difficult due to the nature of the shell language (bash in our case). Consider this command:","echo Touching $(file); touch \u2018foobar\u2019","What are the \u201ccorrect\u201d lexical analysis and parse for this command? The answer depends on the value of the file variable and the output of the foobar executable. If file is set to a single quote character and foobar returns the same thing, then there is exactly one command, echo. Since variables are expanded and sub-processes are executed before the command is parsed, the correct parse cannot be determined a priori. Under most circumstances, though, such odd substitutions are not the case.","For the purposes of detecting OS command injections, we need to know the possible places where a command could be invoked. The present system or method may provide a simple parser for the subject prototype assumes that the structure of the command is not changed by the results of executing subcommands. In the case of the present inventors' simple example, the parser marks the command like so:",{"@attributes":{"id":"p-0116","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","echo Touching $(file); touch \u2032foobar\u2032"]},{"entry":[{},{},"CCCC\u2003\u2003CCCCCCCC CCCCC C\u2003C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Conceptually, the Trust Inference component infers which portions of the command come from within the program, and which ones come from external sources. To accomplish this step, it checks each substring in the command to determine if that location is within the set of signature fragments. This pseudocode illustrates the process:",{"@attributes":{"id":"p-0118","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","for each signature fragment, f"]},{"entry":[{},{},"\u2003for each position, i , in the command"]},{"entry":[{},{},"\u2003\u2003L=len (f)"]},{"entry":[{},{},"\u2003\u2003if f==command [i . . i + L\u22121]"]},{"entry":[{},{},"\u2003\u2003\u2003mark_trusted (command [i . . i + L\u22121] ) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Conceptually, this algorithm and related method could be quite expensive, O(n) where n=max(length(sig),#sigs,length(command)). In practice, though, the present inventors use a move-to-front heuristic to organize the signature fragments required to trust commands and exit the outermost loop when enough of the command is trusted to verify its safety. Further, each command and each signature fragment is typically short, on the orders of tens or hundreds of characters. These simple observations and adjustments dramatically reduce the time necessary to make the inference. Example Set No. 3 at Section D empirically evaluates the overhead associated with inferring trust markings.","E. Attack Detection","Attack detection may consist of scanning the command for any character that has been marked as untrusted by the Trust Inference component and critical by the Command Parsing component. In addition, it may desirable to impose the constraints shown in  that command names, shell metacharacters used for starting subcommands and their associated command names, option flags, and environment variable names must come from a single signature fragment (same fragment origin policy).","This policy helps to compensate for the case when a short, critical token, such as a semi-colon or a quotation mark, is present in the set of signature fragments. Such fragments allow attackers great latitude to create strings that append new commands, as in \u201c; rm -rf\u201d. Unfortunately, these signature fragments cannot simply be discarded, because many programs do use such fragments to terminate their commands. However, it appears uncommon for a program to use such fragments to introduce a new command, so the present inventors disallow this behavior entirely.  indicates where attack detection policies might use the same fragment origin policy ([\\s] denotes an optional whitespace.",{"@attributes":{"id":"p-0122","num":"0125"},"figref":"FIG. 6"},"When no attack is detected then the software, method and system passes the command to the operating system to execute. However, if an attack is detected, the software, method and system do not pass through the command, but can enact any one of a variety of remediation responses, such as shutting down the program, warning the user and asking for permission to continue, or logging the attack. For the prototype described in this example set, the present inventors chose to return an error code as if the library call had failed. This policy makes sense in many cases, as well-written programs are designed to gracefully handle error conditions.  indicates overlapping policies lo detect attacks.","Example Set No. 4 discusses potential sources of false negatives and false positives, and their implications in further detail.","Example and Experimental Results Set No. 3","Evaluation","To evaluate the security and performance of an aspect of an embodiment of the present invention system and method the present inventors have prototyped a system and applied it to a variety of engineered and real-world benchmarks. This Example Set describes the Experimental Setup, Benchmarks, Performance Evaluation and Security Evaluation in more detail.","A. Experimental Setup","For an evaluation, the present inventors used a 32-bit Virtual Box virtual machine running Ubuntu 12.04 with 4 GB of RAM and a 2 GHz Xeon E5-2620 processor.","B. Benchmarks","To evaluate the performance and security of an aspect of an embodiment of the present invention system and method, the present inventors have collected a variety of benchmarks. For real-world benchmarks with CVE reports, the present inventors used the SpamAssassin Milter Plugin [See 28], an email filler interface for detecting spam, and cbrPager [See 29] version 0.9.16. a program to decompress and view high-resolution images. The present inventors configured SpamAssassin Milter version 0.3.1 with SpamAssassin version 3.3.2 and Postfix version 2.9.6. Both of these programs have real-world OS command injection vulnerabilities.","The present inventors also used a set of vulnerable programs independently developed by MITRE Corporation from real-world, open-source software. Each program was seeded with a command injection vulnerability. This process was repeated to create many variants with the vulnerability at many locations. Each variant has inputs that represent normal program input, as well as exploit inputs.","Finally, the present inventors used a set of small exploitable programs, most less than 100 lines, that were developed by Raytheon. Like the MITRE programs, normal and exploit inputs are provided.","Lastly, to help evaluate performance, the present inventors developed a series of microbenchmarks. These benchmarks create an OS command from command line input, and use a tight loop to execute that command as frequently as possible, doing no other work. There are two dimensions of variation in the micro benchmarks: 1) the command to be executed and 2) the primitive used to invoke the command. There are two possible commands to be executed. The command to be executed in one case is echo hello, and in the second case is bzip2 dickens.txt [See 30], [See 31]. The two cases represent a fast command and a somewhat more reasonable workload that compresses a 775 KB file. Each microbenchmark uses one of the following primitives to invoke the command: execv, popen, or system.","C. Security Evaluation","The present inventors used a combination of programs with reported real-world vulnerabilities, synthetic test programs, and real-world programs seeded with vulnerabilities by an independent testing team to evaluate the strength of an aspect of an embodiment of the present invention system and method.","1) Real-World Attacks: the present inventors evaluated an aspect of an embodiment of the present invention system and method against two reported command-injection vulnerabilities that the present inventors were able to reproduce in open-source binaries.","The first attack, based on CVE-2008-2575, is a command injection in cbrPager [See 32]. To extract images, cbrPager invokes the system library call to execute unzip or unrar on the archive, without sanitizing the filename. By crafting an input such as \u201c; rm -rf *;\u201d.cbr and providing it where a filename is expected, cbrPager is tricked into executing a malicious command when it attempts to open the putative file. An aspect of an embodiment of the present invention system and method is to have the ability to detect attempts to open a malicious filename and return an error from the system library call. These actions result in the program displaying a message that the file cannot be opened, and exiting harmlessly.","The second attack, based on CVE-2010-1 132, is a remote exploit in the SpamAssassin Milter Plugin [See 4] (spamass-milter), which integrates the SpamAssassin spam filter with either sendmail or Postfix. The vulnerability occurs when the milter is invoked with the -x \u201cexpand\u201d option, to pass the email address through alias and virtusertable expansion to allow emails to be redirected to other accounts. In this case, the popen function is invoked on sendmail with the email address provided from SMTP as an argument, without properly sanitizing the email address, which can contain a pipe character. With an SMTP command such as RCPT TO: <username+: \u201c|rm \/var\/spool\/mail\u201d>, arbitrary commands can be executed; with careful crafting, these may be sufficient to open a remote shell. This particular embodiment of the system and method was able to harmlessly block any command injections. The signatures extracted from spamass-milter do not include the vertical bar (pipe) character, foiling any attempt to exploit this weakness. Moreover, the Milter plugin properly error-checks the popen function call, so it continues to function without loss of service in the face of an attempted exploit.","2) Synthetic Attacks: The present inventors evaluated an aspect of an embodiment of the present invention system and method against engineered test suites developed by Raytheon and independently by MITRE. The Raytheon engineered suite consists of 18 microtests demonstrating command injections with 22 good inputs and 35 bad inputs, using 9 different function calls ([f]exec[1, 1e, 1p, v, ve, vp], system and popen) and a variety of input-processing techniques. This particular embodiment of the system and method mitigates all of the bad inputs while breaking none of the good inputs in this test suite.","The MITRE test suite includes 477 OS command injection (based on CWE-78) and 516 OS argument injection (based on CWE-88) test cases [See 33]. These test cases are based on inserting vulnerabilities into seven base programs: Cherokee, grep, nginx, tepdump, wget, w3c (from libwww), and zsh. Each test case involves inserting a vulnerable call to popen at various locations in the base program. For the CWE-78 test cases, this call invokes nslookup with an unsanitized argument specified from an environment variable or untrusted file. For the CWE-88, the program builds the command using the format string \u201cfind \/-iname % s.\u201d Semicolon characters are properly sanitized when constructing the command, but the user can still include input that has a -exec argument that is ultimately passed to find. Consequently, they could use an input such as \u201c*-exec rm { } \\;\u201d to remove files or execute other commands. For each test case, ten good inputs and two bad inputs are provided. In each case, an aspect of an embodiment of the present invention system and method was able to intercept the bad inputs without altering behavior on the good inputs.","D. Performance Evaluation",{"@attributes":{"id":"p-0137","num":"0140"},"figref":"FIG. 15"},"The present inventors selected two of the benchmarks from the MITRE suite where the seeded vulnerability was in the main loop of a server; most vulnerabilities were injected into startup or shutdown code, and there was no significant performance difference. The seeded vulnerability was set to execute only once, but for timing purposes the present inventors modified the code slightly so that it executed on every request to the server. The benchmarks are based on Cherokee (C-0078-CHER-04-DF09-02) and nginx (C-0078-NGIN-04-DT03-02), two production-quality web servers. An aspect of an embodiment of the present invention system and method performed 50 timings, each consisting of downloading a small html file (574 bytes). Even with the seeded vulnerability in the main loop and the small download size, no statistically significant difference in timing was observed with this particular embodiment of the system and method.","For SpamAssassin Milter, the present inventors wrote a simple client that uses gettimeofday to measure the time spent in processing an email transaction. The present inventors also modified cbrPager to measure the time to render the first page of a 49 MB input file. Like the MITRE benchmarks, these benchmarks show no statistically significant overhead.","Unfortunately, the server applications have relatively high variance due to network latencies, disk caching, etc. To deal with this issue and benchmark worst-case overhead, the present inventors use the microbenchmarks described in Example Set No. 3 at Section C2. For these benchmarks, an aspect of an embodiment of the present invention system and method performs 50 timings, where each timing invokes 10 or 1,000 OS commands for the bzip2 or echo microbenchmark, respectively. The microbenchmarks that invoke bzip2 to compress a file show that an aspect of an embodiment of the present invention system and method causes practically no overhead, only 0.2%. The true worst-case performance overhead is when the program does nothing but issue OS commands, and each OS command invocation completes extremely quickly. This case is represented by the microbenchmark that issues the echo hello command. These benchmarks show that the absolute worst case overhead might be as high as 22%. However, in practice the actual work performed by the program and by executing the OS command clearly dominates the overall run-time. Only our worst-case microbenchmarks demonstrate that a particular embodiment of the system and method generates any measurable overhead.","To verify the move-to-front heuristic was working properly, the present inventors measured the overhead of the echo microbenchmark that uses the system function to invoke OS commands as the present inventors vary the number of signature fragments. The present inventors automatically added randomly generated strings to the program's DNA fragments.  shows the average time in microseconds for the microbenchmark to execute the system call 100 times, using from 300 to 10,000 signatures (timing starts after steady state has been reached). There is a very slight positive correlation as shown by the line of best fit y=0.002x; +1194. The present inventors' investigation indicates that the command processing and matching time after initialization was fixed across the differing number of signatures, but that as there are more signatures in the process's address space, the fork system call (used to implement system) takes longer. The present inventors suspect this is a result of taking slightly longer to copy additional page table entries for the new process.","In practice, this additional overhead is negligible since most programs have few signatures. For example, SpamAssassin Milter has 316 signatures and nginx has 2,017.  shows the average time in milliseconds to process an email transaction over 50 trials applying this particular embodiment of the system and method with from 320 to 10,000 signatures to SpamAssassin Milter, which shows no trend. The present inventors would not have expected to see any correlation, given an expected increase of only 20 microseconds based on our microbenchmark and the higher time variance of the email benchmark.","Based on these microbenchmark and real-world benchmark performance results, the present inventors believe that in practice an aspect of an embodiment of the present invention system and method would introduce no measurable overhead, and is the fastest OS command injection detector to date.","E. Analysis Time","An aspect of an embodiment of the present invention system and method measured the time for offline analysis (i.e., signature Fragment Extraction) of the real-world benchmarks. The results are shown in the table of . This table shows the size of the analyzed executables and libraries, the entire static analysis time, and the portion of that time spent in fragment extraction and processing. This analysis needs to be performed only once. These results show the analysis taking up to four minutes for nginx. The time is dominated by the disassembly and IR recovery steps that can be shared by other binary analyses and protections. The actual time devoted to string extraction and post-processing amounts to about 2% of the analysis, completing in between 0.5 to 8 seconds on our benchmarks.","In summary, an aspect of an embodiment of the present invention system and method provides, among other things, a new, efficient, approach for detecting faint markings based on positive taint inference. The present inventors' findings indicate that an aspect of the particular system and method can be effectively used to detect OS command injection attacks on binary programs. Furthermore, an aspect of an embodiment of the present invention system and method has demonstrated that it can be used in many real-world situations because it has negligible performance overhead and can be applied directly to binary programs without need for source code or compiler support.","Example and Experimental Results Set No. 4","4.1 Signature Fragment Extraction","The goal of signature fragment extraction is provided to extract string fragments, i.e., signature fragments, from the binary software and its associated libraries. It may include steps of Signature Fragment Mining and Signature Analysis and Filtering.","(a) Signature Fragment Mining","A purpose of this step is to analyze the software and extract possible command fragments from the software program. In a subsequent step, the signature fragment matching step, command fragments will be reassembled using a variety of techniques to match parts of commands issued by the software program.","Depending on how the software is delivered, e.g. as a binary file, a binary file with a set of libraries, as a set of source files, as byte code, as assembly language code, as a text file in a scripting language, different methods may be used to identify potential fragments. These methods include:\n\n","(b) Signature Fragment Analysis and Filtering","A purpose of this step is to further process signature fragments to aid in the Signature Matching process (later described below in this Set Number in the signature fragment matching section). This is an example of post-processing. This step may include:\n\n","Note that this step is optional as signature fragments generated in the Signature Fragment Mining step may be used directly.","4.2 Trust Inference (AKA Signature Fragment Matching)","A purpose of this step is to analyze commands emitted by the software program and locate signature fragments that are contained within the command. For example, a program may emit the following command to access a database:","command: SELECT * from users where userid=\u2018john\u2019;","If the fragments included the following:","fragment 1: bob the frog","fragment 2: SELECT * from users","fragment 3: where userid=\u2018","fragment 4:\u2019;","Then the matching process would find that the following parts of the command were made up from fragments (shown underlined): SELECT * from users where userid=\u2018john\u2019;","In this example, the only part of the command that is not matched by a string fragment would be: j ohn","Another convention of representing the same effect would be as follows:","Then the matching process would find that the following parts of the command were made up from fragments (shown with \u2018T\u2019s for trusted, \u2018U\u2019s for untrusted):",{"@attributes":{"id":"p-0166","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","SELECT * from users where userid=\u2032john\u2032 ;"]},{"entry":[{},{},"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUUTT"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"There are many possible ways to find fragments within a command. Examples include:\n\n","For the remainder of this exposition, the present inventors will refer to the portions of the command that have been matched against a signature fragment as vetted. As mentioned above, another convention would be designated as trusted (as designated with a \u2018T\u2019).","The signature fragment matching process may be carried out in several ways, including:\n\n","4.3 Detection","A purpose of this step is to detect suspicious commands that may indicate that an entity is carrying out an attack or is otherwise trying to manipulate emission of various commands emitted by the software program.","Detection is performed by analyzing a command and checking whether critical parts of the command have been vetted in the signature fragment matching step. If a critical part of a command has not been vetted, then this provides a strong indication that an attack is underway.","(a) Command Parsing","A command parsing component is provided for identifying the security-critical parts of a command. Some examples of critical parts of a command may include, for example, critical tokens and keywords.","Determining what is critical depends on the nature of the command and what resources may be accessed via the command. Consider the case of queries to a database expressed in the Structured Query Language (SQL). The present inventors use two different commands.","Command 1: SELECT * from users where userid=\u2018john\u2019;","Command 2: SELECT * from users where userid=\u2018 \u2018OR 1=1; -- john\u2019;","Then the command parsing process would find that the following parts of the command were security-critical parts (shown with \u2018C\u2019 for critical; and left blank if not critical):",{"@attributes":{"id":"p-0179","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","SELECT * from users where userid= \u2032john\u2032 ;"]},{"entry":[{},"CCCCCC\u2003CCCC\u2003\u2003CCCCC\u2003\u2003CC\u2003CC"]},{"entry":[{},"SELECT * from users where userid=\u2032\u2003\u2032 OR 1 = 1; -- \u2032john\u2032 ;"]},{"entry":[{},"CCCCCC\u2003CCCC\u2003\u2003CCCCC\u2003\u2003CC C CC\u2003C\u2003C CCCCCCCCC"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Note that in many cases establishing whether a given portion of a command is deemed critical (and should be checked to see whether it is vetted) may involve a process known in the computer science literature as parsing a string with respect to a given language. This process is somewhat analogous to identifying the parts of speech in a language such as English. Using this analogy, one could deem verbs (but not nouns) to be critical. In the first example, the string john is not deemed critical as it corresponds to data once the command is parsed with respect to SQL. However, the string OR is deemed critical as it corresponds to an instruction in the query. In fact, this query would return all users contained in the database, which would represent a severe leakage of information.","(b) Attack Detection","One could use the policy that SQL keywords or tokens contained in the command should be vetted.","In the first example (vetted portions of the command are shown underlined),",{"@attributes":{"id":"p-0184","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003",{"u":["SELECT","*","from","users","where","userid=","\u2032","\u2032",";"]}]},{"entry":[{},{},"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUUTT"]},{"entry":[{},{},"CCCCCC\u2003CCCC\u2003\u2003CCCCC\u2003\u2003\u2003CC\u2003CC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0185","num":"0205"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT * from users where userid= \u2032\u2003\u2032 OR 1 = 1; -- john\u2032 ;"},{"entry":"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUTT"},{"entry":"CCCCCC\u2003CCCC\u2003\u2003CCCCC\u2003\u2003CC C CC\u2003C\u2003C CCCCCCCCC"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"If a command is deemed normal (nothing suspicious has been detected), then the query can be issued normally. However, if a command is deemed suspicious, several remediation policies may be applied (Example Set No. 4 at Section 4.5).","4.4 Validation","Note that the detection step may yield both false positives and false negatives.","For example, if the signature fragment matching step does not identify a critical part of a command as vetted, then the detection step will deem the command suspicious when it should not. The error represents a false positive.","If the signature fragment mining or the signature fragment analysis and filtering steps yield a signature fragment that would be used in an attack, then this signature fragment would be vetted, and therefore the malicious command would evade detection. This error represents a false negative.","Several techniques may be used to minimize false positives, including:",{"@attributes":{"id":"p-0191","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":{"@attributes":{"id":"ul0012-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["executing the software program under a test suite. If any commands are deemed suspicious during the execution of the test suite, then the commands that were deemed suspicious may be analyzed in order to extract further signature fragments. These fragments may then be added to the set of signature fragments that will be used in the signature fragment matching step;","executing the software program under a test suite and monitoring commands issued by the software program to find common patterns in the commands. These patterns may then be used to generate further signature fragments;","using more sophisticated algorithms in either the signature fragment mining or the signature fragment analysis and filtering steps; and","using additional heuristics in the detection steps to exclude certain patterns from resulting in an alert. For example, one could use a policy to raise an alert when a critical part of a command is not vetted only if previous parts of the command have been vetted.\n\nSeveral techniques may be used to minimize false negatives, including:\n","removing signature fragments shorter than a certain length;","using fault injection techniques to force the program to issue suspicious command and making sure that these commands result in an alert. If the command is not detected as suspicious, then the set of signature fragments can be analyzed to determine which fragment caused the suspicious command to not be detected. The offending fragment could then be removed; and"]}}}},"Note that when seeking to minimize false positives or negatives, or in general, when using signature fragments, any of the information associated with the fragments may be used. Finally, the validation step is optional, as the rate of false negatives or positives may already fall within acceptable ranges.","4.5 Remediation","Once a command is deemed suspicious, a wide array of policies may be applied.","Example policies include:",{"@attributes":{"id":"p-0195","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":{"@attributes":{"id":"ul0014-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":["terminating the software program;","logging that a suspicious command is being attempted;","alerting a supervisory remote computer that a breach is being attempted;","notifying an administrator of the suspicious command;","not issuing the command but returning an error code;","not issuing the command but returning a non-error code;","issuing a known bad command and returning the resulting error codes;","displaying an alert to the end user; and","any combination thereof."]}}}},"4.6 Monitoring","Once a command is deemed suspicious, or at a desired time or predetermined time, a wide array of policies may be applied.","Example policies include:",{"@attributes":{"id":"p-0198","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":{"@attributes":{"id":"ul0016-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["enabling more expensive dynamic analysis for the command interpreter as the command instruction is executed,","running the command interpreter within a VM to contain possible attacks. And","rejecting the command, but turning on more expensive analysis (again, taint tracking) for the application after realizing that the system may be under attack"]}}}},"The monitoring may include methods like \u201cexpensive dynamic analysis.\u201d It may be more efficient to do it on suspicious command injections, but it is not a requirement.","Example and Experimental Results Set No. 5: Preventing SQL Injection Attacks","In this embodiment of the present invention, the software program is written in the C language. While this embodiment of the invention operates directly on the compiled binary form of the program, the C source code is shown for a simple example program to aid in the understanding of Applicant's invention. In this example, the program issues commands and accesses results from a back-end Postgres database server via several functions: PQfinish, PQconnectdb, PQexec, PQstatus, PQresultStatus. PQClear. The set of functions used to access the database server is often referred to as an API, or Application Programming Interface. While the present inventors show examples of API functions for the Postgres database, the present inventors note that other databases typically offer their own API functions.","In general, an API will be available for any commands of interest.","5.1 C Source Code",{"@attributes":{"id":"p-0202","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include <stdio.h>"},{"entry":"#include <stdlib.h>"},{"entry":"#include \u201clibpq-fe.h\u201d"},{"entry":"void exitNicely(PGconn *p_conn)"},{"entry":"{"},{"entry":"\u2003PQfinish(p_conn);"},{"entry":"\u2003exit(1);"},{"entry":"}"},{"entry":"int main(int argc, char **argv)"},{"entry":"{"},{"entry":"\u2003char conninfo[1024];"},{"entry":"\u2003char query[1024];"},{"entry":"\u2003PGconn *conn;"},{"entry":"\u2003PGresult *res;"},{"entry":"\u2003sprintf(conninfo, \u201cdbname = %s\u201d, getenv(\u201cPGDATABASE\u201d));"},{"entry":"\u2003conn = PQconnectdb(conninfo);"},{"entry":"\u2003if (PQstatus(conn) != CONNECTION_OK)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003fprintf(stderr, \u201cConnection to database failed: %s\u201d,"},{"entry":"PQerrorMessage(conn));"},{"entry":"\u2003\u2003exitNicely(conn);"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ this line is vulnerable to SQL injection"},{"entry":"\u2003sprintf(query, \u201cselect * from doip where comment ="},{"entry":"\u2018%s\u2019;\u201d, argv[1]);"},{"entry":"\u2003res = PQexec(conn, query);"},{"entry":"\u2003if (PQresultStatus(res) == PGRES_TUPLES_OK)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003fprintf(stderr, \u201cQuery success: %s\\n\u201d, query);"},{"entry":"\u2003}"},{"entry":"\u2003else"},{"entry":"\u2003{"},{"entry":"\u2003\u2003fprintf(stderr, \u201cQuery failed: %s\\n\u201d, query);"},{"entry":"\u2003}"},{"entry":"\u2003PQclear(res);"},{"entry":"\u2003PQfinish(conn);"},{"entry":"\u2003return 0;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"5.2 Signature Fragment Extraction","(a) Signature Fragment Mining","To identify the initial set of signature fragments an embodiment of the present invention method and system may process the binary that results from compiling the C source code example with the Unix strings utility. Possible fragments produced are:",{"@attributes":{"id":"p-0206","num":"0241"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","[{circumflex over (\u2009)}_]"]},{"entry":[{},"__bss_start"]},{"entry":[{},"Connection to database failed: %s"]},{"entry":[{},"dbname = %s"]},{"entry":[{},"_edata"]},{"entry":[{},"_end"]},{"entry":[{},"exit"]},{"entry":[{},"_fini"]},{"entry":[{},"fprintf"]},{"entry":[{},"getenv"]},{"entry":[{},"GLIBC_2.0"]},{"entry":[{},"GLIBC_2.4"]},{"entry":[{},"__gmon_start__"]},{"entry":[{},"_init"]},{"entry":[{},"_IO_stdin_used"]},{"entry":[{},"_Jv_RegisterClasses"]},{"entry":[{},"libc.so.6"]},{"entry":[{},"__libc_start_main"]},{"entry":[{},"\/lib\/ld-linux.so.2"]},{"entry":[{},"libpq.so.5"]},{"entry":[{},"PGDATABASE"]},{"entry":[{},"PQclear"]},{"entry":[{},"PQconnectdb"]},{"entry":[{},"PQerrorMessage"]},{"entry":[{},"PQexec"]},{"entry":[{},"PQfinish"]},{"entry":[{},"PQresultStatus"]},{"entry":[{},"PQstatus"]},{"entry":[{},"PTRh0"]},{"entry":[{},"Query failed: %s"]},{"entry":[{},"Query success: %s"]},{"entry":[{},"select * from doip where comment = \u2018%s\u2019;"]},{"entry":[{},"sprintf"]},{"entry":[{},"__stack_chk_fail"]},{"entry":[{},"stderr"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Note that many of the strings in the C source code are successfully extracted from the program binary.","(b) Signature Fragment Analysis and Filtering","In this step of post processing, signature fragments that correspond to function names are filtered out, along with common symbol names and strings that correspond to well-known libraries. This can be done using the nm facility in Unix or other tools to extract symbol name information. Furthermore, signature fragments that contain % s or other format string specifiers can be replaced with signature fragments that are generated by removing the % s. For example, the fragment:\n\n","5.3 Trust Inference (AKA Signature Fragment Matching)","Using the interposition facilities in modern Unix systems, API function calls related to issuing commands to the database are intercepted. As an example of interposition, the code below illustrates how calls to PQexec, one of the major function for issuing commands to the database, are intercepted:",{"@attributes":{"id":"p-0212","num":"0261"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","PGresult* PQexec(PGconn* p_conn, const char *p_query)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003static PGresult* (*my_pgExec) (PGconn*, const char *) ="]},{"entry":[{},"NULL;"]},{"entry":[{},"\u2003if (!my_pgExec)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"my_pgExec = dlsym(RTLD_NEXT, \u201cPQexec\u201d) ;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003char *errMsg = NULL;"]},{"entry":[{},"\u2003if (sqlfw_verify(p_query, &errMsg))"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003PGresult *ret = my_pgExec(p_conn, p_query);"]},{"entry":[{},"\u2003\u2003return ret;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003\/\/ remediation policy: issue bad query on purpose and"]},{"entry":[{},"return resulting error"]},{"entry":[{},"\u2003\u2003PGresult *ret = my_pgExec(p_conn, \u201cnot a query -"]},{"entry":[{},"force error\u201d);"]},{"entry":[{},"\u2003\u2003return ret;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"This code intercepts the calls to PQexec which then enables the signature fragment matching, the detection and the remediation steps. The function sqlfw_verify( ) encodes the signature fragment matching and detection steps. If the query command (p_query) is deemed normal then the query is passed through to the original function that implements PQexec. Otherwise, if the query command is deemed to be suspicious, then a remediation policy is applied.","Consider the case where the program input yields a command query that is not an attack:\n\n",{"@attributes":{"id":"p-0215","num":"0266"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"u":["select\u2002*\u2002from\u2002doip\u2002where\u2002comment\u2002=\u2002\u2018","\u2019;"]}]},{"entry":[{},"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUTT"]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["select * from doip where comment=\u2018 \u2019 or 1=1; -- bob\u2019;","The attack would result in a leak of all entries from the doip table. The fragment matching process would mark the following characters as vetted (shown underlined, and can also be designated as trusted, \u2018T\u2019 or untrusted, \u2018U\u2019.):"]}},{"@attributes":{"id":"p-0216","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{"u":["select\u2002*\u2002from\u2002doip\u2002where\u2002comment\u2002=\u2002\u2018","\u2019;"]},{}]},{"entry":"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUTT\u2003"}]}}}}},"5.4 Detection","To determine whether the query command is malicious, Applicant parses the query string to look for critical parts (shown with \u2018C\u2019 for critical; and left blank if not critical) of the commands that are not vetted. In the case of the normal query:",{"@attributes":{"id":"p-0219","num":"0272"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"u":["select\u2002*\u2002from\u2002doip\u2002where\u2002comment\u2002=\u2002\u2018","\u2019;"]}]},{"entry":[{},"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUTT"]},{"entry":[{},"CCCCCC\u2003\u2003\u2003CCCC\u2003\u2003\u2003\u2003\u2003\u2003CCCCC\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003C\u2003C\u2003\u2003\u2003CC"]}]}}}}},"All critical parts of the command, i.e., SQL keywords and tokens such as select from where=\u2018 \u2019; are all vetted.","However, in the case of an attack:",{"@attributes":{"id":"p-0222","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{"u":["select\u2002*\u2002from\u2002doip\u2002where\u2002comment\u2002=\u2002\u2018","\u2019;"]},{}]},{"entry":"TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUTT"},{"entry":"CCCCCC\u2003\u2003\u2003CCCC\u2003\u2003\u2003\u2003\u2003\u2003CCCCC\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003C\u2003CC\u2003CC\u2003\u2003C\u2003C\u2003CCCCCCC"}]}}}},"br":{}},"If a command is deemed normal, i.e. non-malicious, the present method and system may go ahead and let the command be issued. Otherwise, if a command is deemed suspicious, i.e. a potential attack, the user or system may perform some remediation action.","5.5 Remediation","Once an attack is detected, there are multiple remediation actions that are possible. In this example, the present inventors generate a malformed query command intently, execute this malformed query, and return any resulting errors to the software program.","5.6 Validation","In this example, the present method and system may does not attempt to perform any validation of the detection algorithm. However, if a regression test were supplied with the software program, the present method and system may execute the program with known non-malicious test inputs. If any inputs resulted in a detection of an attack, then the inputs could be analyzed to generate further signature fragments. Alternatively, the present inventors could create tests manually or by recording all inputs given to the program during a user session.","If attack inputs were supplied or published, the present inventors could verify that the detection algorithm detected the attack. If the detection step did not detect the attack, we could judiciously remove signature fragments until the attack was detected.","Example and Experimental Results Set No. 6: Preventing OS Injection Attacks","In this embodiment, the original software program is also written in the C language. However, as was the case with the embodiment discussed in Example Set No. 3, an embodiment of the present invention may operate directly on the compiled binary form of the program. In the example shown below, the program issues operating system commands using API functions contained in the standard C libraries, e.g. system.","6.1 C Source Code",{"@attributes":{"id":"p-0230","num":"0283"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","#include <stdio.h>"]},{"entry":[{},"int main(int argc, char *argv[ ])"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if (argc < 2)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003fprintf(stderr, \u201cmust specify at least one"]},{"entry":[{},"argument\\n\u201d);"]},{"entry":[{},"\u2003\u2003return 1;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003char command[2048];"]},{"entry":[{},"\u2003sprintf(command, \u201c\/bin\/ls %s\u201d, argv[1]);"]},{"entry":[{},"\u2003int ret = system(command);"]},{"entry":[{},"\u2003fprintf (stdout, \u201c%s returned with code: %d\\n\u201d,"]},{"entry":[{},"command, ret);"]},{"entry":[{},"\u2003return 0;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"6.2 Signature Fragment Extraction","(a) Signature Fragment Mining","To identify the initial set of signature fragments an embodiment of the present method and system may process the binary that results from compiling the C source code example with the Unix strings utility. The fragments produced are:",{"@attributes":{"id":"p-0234","num":"0287"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","[{circumflex over (\u2009)}_]"]},{"entry":[{},"\/bin\/ls %s"]},{"entry":[{},"fprintf"]},{"entry":[{},"fwrite"]},{"entry":[{},"GLIBC_2.0"]},{"entry":[{},"GLIBC_2.4"]},{"entry":[{},"__gmon_start__"]},{"entry":[{},"_IO_stdin_used"]},{"entry":[{},"libc.so.6"]},{"entry":[{},"__libc_start_main"]},{"entry":[{},"\/lib\/ld-linux.so.2"]},{"entry":[{},"must specify at least one argument"]},{"entry":[{},"PTRh"]},{"entry":[{},"QVh4"]},{"entry":[{},"sprintf"]},{"entry":[{},"%s returned with code: %d"]},{"entry":[{},"__stack_chk_fail"]},{"entry":[{},"stderr"]},{"entry":[{},"stdout"]},{"entry":[{},"system"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(b) Signature Fragment Analysis and Filtering (e.g., Post-Processing).","Using similar techniques as those described in Section (b) of this Example Set No. 6, the final set of signature fragments produced is:",{"@attributes":{"id":"p-0237","num":"0290"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","[{circumflex over (\u2009)}_]"]},{"entry":[{},"\/bin\/ls"]},{"entry":[{},"must specify at least one argument"]},{"entry":[{},"PTRh"]},{"entry":[{},"QVh4"]},{"entry":[{},"returned with code:"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"6.3 Trust Inference (AKA Signature Fragment Matching)","Using the interposition facilities in modern Unix systems, API function calls related to issuing operating systems commands are intercepted. These functions include:\n\n","Consider the case when the command is not an attack, for example when a file is supplied to the program. The resulting command would be:\n\n","The fragment matching process would mark the following characters as vetted (shown underlined, and can also be designated as trusted, \u2018T\u2019 or untrusted, \u2018U\u2019.):",{"@attributes":{"id":"p-0242","num":"0297"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"u":"\/bin\/ls"}]},{"entry":[{},"TTTTTTT\u2003UUUUUU"]}]}}}}},"In the case when the command query is an attack, e.g., the program is supplied with the input someOtherFile; cat \/etc\/passwd","The resulting command would be:\n\n",{"@attributes":{"id":"p-0245","num":"0301"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"u":"\/bin\/ls"}]},{"entry":[{},"TTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU"]}]}}}}},"6.4 Detection","To determine whether the command is malicious, the present method and system may look for critical parts (critical character designated with \u201cC\u201d and non-critical designated by leaving blank) of the commands that are not vetted. In the example:",{"@attributes":{"id":"p-0248","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"u":"\/bin\/ls"}]},{"entry":[{},"TTTTTTTTUUUUUU"]},{"entry":[{},"CCCCCCC"]}]}}}}},"The critical parts (designated with \u2018C\u2019) of the command \/bin\/ls is marked as vetted (i.e. underlined or with the alternative convention, trusted), and therefore this command is deemed non-malicious.","However, in the case of the following command,",{"@attributes":{"id":"p-0251","num":"0307"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"u":"\/bin\/ls"}]},{"entry":[{},"TTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU"]},{"entry":[{},"CCCCCCC\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003C\u2003CCC"]}]}}}}},"The shell program cat follows the ; terminator symbol and is deemed critical. Since cat is not vetted (i.e. without underline or with the alternative convention, untrusted), the command is deemed suspicious.","An embodiment of the current prototype treats the first shell program in the command as critical, and well as any shell programs that follow a separator symbol such as ; , |, \u2225, & & .","In addition, shell program options and the name of environment parameters are deemed critical. Thus in the following command, the characters shown in boldface are deemed critical:",{"@attributes":{"id":"p-0255","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","tabstyle":"monospace"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"b":["MYENV=","\/bin\/ls","rm","fr","\/"]}]},{"entry":[{},"CCCCCC\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CCCCCCC\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CC\u2003CC\u2003CCC"]}]}}}}},"6.5 Validation","In this embodiment, validation is not performed. If desired validation would proceed as described in Example Set No. 4 at Section 4.5 and Example Set No. 5 at Section 5.5.","7 Example and Experimental Results Set No. 7: Additional Notes","The present inventors note that while the SQL injection and OS injection attack examples are presented separately, they can, in practice, be combined into one protection mechanism or approach. In general, an aspect of an embodiment of the present invention allows for the interception of arbitrary API functions, and thus it is in fact quite easy to compose various protections against a wide variety of command injection attacks. Further examples of command injection attacks include: LDAP Injection Attacks, XPATH Injection Attacks, Cross-Site (XSS) Scripting Attacks, Log Injection Attacks, and Format String Attacks. In general, aspects of various embodiments of the present invention may apply to any injection attacks wherein an attacker can manipulate critical parts of a command.","The examples provided illustrated the use of an embodiment of the invention for program binaries compiled from C source code. As was already described in Example Set No. 4, the present inventors note that an aspect of an embodiment of the present invention is generally applicable to, but not limited thereto, a variety of software program types, including software expressed in various scripting languages (Ruby, Python, PHP, Perl, etc.), byte code (e.g. Java byte code, Microsoft's Common Intermediary Language, Dalvik byte code), assembly language, etc. An aspect of an embodiment of the present invention also applies to software program binaries generated from a wide variety of languages, including C and C++, and other languages that are compiled to binary form.","Example 1. An aspect of an embodiment of the present invention provides, but not limited thereto, a computer method for detecting command injection attacks. The method may comprise: receiving software code; extracting string fragments from the received software code to provide extracted signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining if the critical parts are untrusted or trusted by matching with the extracted signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","Example 2. The method of example 1, further comprises: remediating or rejecting one or more of said identified potential attack commands.","Example 3. The method of example 2, wherein said remediation includes altering the identified potential attack command.","Example 4. The method of example 2 (as well as subject matter of example 3), further comprising: transmitting said remediated command to a command interpreter module.","Example 5. The method of example 4 (as well as subject matter of one or more of any combination of examples 2-3), further comprising: executing said remediated command in said command interpreter; and generating a command response.","Example 6. The method of example 2 (as well as subject matter of one or more of any combination of examples 3-5), further comprising: transmitting said remediated command for execution; and generating said executed command as a command response.","Example 7. The method of example 2 (as well as subject matter of one or more of any combination of examples 3-6), wherein said remediation of said identified potential attack command includes providing one or more of the following instructions: terminating the software program, repairing the potential attack command, enabling additional system monitoring, enabling additional analysis, logging that a suspicious command is being attempted, alerting a supervisory remote computer that a breach is being attempted, notifying an administrator of the suspicious command, not issuing the command but returning an error code, not issuing the command but returning a non-error code, issuing a known bad command and returning the resulting error codes, displaying an alert to the end user, or any combination thereof.","Example 8. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-7), wherein said identifying critical parts includes at least one of the following: parsing, dissecting, lexical analyzing, or tokenizing.","Example 9. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-8), wherein said extracting comprises a string extracting technique, and said method further comprises: post-processing of said extracted signature fragments.","Example 10. The method of example 9 (as well as subject matter of one or more of any combination of examples 2-8), wherein said post-processing may comprise one or more of the following: removing said extracted signature fragments; adding said extracted signature fragments; modifying said extracted signature fragments; or annotating said extracted signature fragments with additional information","Example 11. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-10), wherein said identifying potential attacks includes using annotations.","Example 12. The method of example 11 (as well as subject matter of one or more of any combination of examples 2-10), wherein said annotations are generated by said post-processing step.","Example 13. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-12), wherein said signature fragments specify patterns.","Example 14. The method of example 13 (as well as subject matter of one or more of any combination of examples 2-12), wherein said patterns comprise one or more of the following: regular expressions, wild-card specifiers, format string specifiers, context-free grammars, or grammars.","Example 15. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-14), wherein if the condition to identify that potential attacks have occurred has not been satisfied then said command is deemed as safe, thereby defining a safe command.","Example 16. The method of example 15 (as well as subject matter of one or more of any combination of examples 2-14), further comprising: transmitting said safe command to a command interpreter module.","Example 17. The method of example 16 (as well as subject matter of one or more of any combination of examples 2-15), further comprising: executing said safe command; and generating a command response.","Example 18. The method of example 15 (as well as subject matter of one or more of any combination of examples 2-14 and 16-17), further comprising accepting said safe command.","Example 19. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-18), wherein said output device includes at least one of the following: storage, memory, network, printer or a display.","Example 20. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-19), wherein said command instructions comprise instructions to an operating system (OS).","Example 21. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-10), wherein said command instructions comprise database commands or structured query language (SQL) instructions.","Example 22. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-21), wherein said command instructions comprise instructions to a format string interpreter.","Example 23. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-22), wherein said command instructions comprise instruction to an LDAP interpreter.","Example 24. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-23), wherein said command instructions comprise instruction to an XPATH interpreter.","Example 25. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-24), wherein said command instructions comprise instructions to a web language.","Example 26. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-25), wherein said command instructions comprise instructions to a scripting language interpreter.","Example 27. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-26), wherein said command instructions comprise instructions to a NoSQL database.","Example 28. The method of example 1 (as well as subject matter of one or more of any combination of examples 2-28), wherein said command instructions include any combination of one or more of the following: instructions to an operating system (OS), instructions to a data base or instructions to an, SQL interpreter, instructions to a web based language; instructions to a format string interpreter; instructions to a LDAP, interpreter, instructions to an XPath interpreter, instructions to a scripting language, and instructions to a NoSQL database.","Example 29. An aspect of an embodiment of the present invention provides, but not limited thereto, a computer method for detecting command injection attacks. The method may comprise: receiving software code; receiving string fragments to provide signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining untrusted or trusted parts of the command instructions by using the signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","Example 30. The method of example 29, wherein said receiving string fragments further comprises extracting string fragments from said received software.","Example 31. The method of example 29 (as well as subject matter of example 30), wherein said receiving string fragments includes one or more of any of the following: receiving from the software developer, downloading from a networked resource, distributed with the software, manually specifying string fragments, or static or dynamic analysis of the software code.","Example 32. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-31), further comprises: monitoring, remediating or rejecting one or more of said identified potential attack commands.","Example 33. The method of example 32 (as well as subject matter of one or more of any combination of examples 30-31), wherein said remediation includes altering the identified potential attack command.","Example 34. The method of example 32 (as well as subject matter of one or more of any combination of examples 30, 31 and 33), further comprising: transmitting said remediated command to a command interpreter module.","Example 35. The method of example 34 (as well as subject matter of one or more of any combination of examples 31-33), further comprising: executing said remediated command in said command interpreter; and generating a command response.","Example 36. The method of example 32 (as well as subject matter of one or more of any combination of examples 30, 31 and 33-35), further comprising: transmitting said remediated command for execution; and generating said executed command as a command response.","Example 37. The method of example 32 (as well as subject matter of one or more of any combination of examples 30, 31, and 33-36), wherein said monitoring, remediation or rejection of said identified potential attack command includes performing one or more of the following actions: terminating the software program, repairing the potential attack command, enabling additional system monitoring, enabling additional analysis, logging that a suspicious command is being attempted, alerting a supervisory remote computer that a breach is being attempted, notifying an administrator of the suspicious command, not issuing the command but returning an error code, not issuing the command but returning a non-error code, issuing a known bad command and returning the resulting error codes, displaying an alert to the end user, or any combination thereof.","Example 38. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-37), wherein said identifying critical parts includes at least one of the following: parsing, dissecting, scanning, tokenizing, or lexical analysis.","Example 39. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-38), further comprising post-processing of said received string fragments.","Example 40. The method of example 39 (as well as subject matter of one or more of any combination of examples 30-38), wherein said post-processing may comprise one or more of the following: removing some of said string fragments; adding additional fragments to said string fragments; modifying said string fragments; or annotating said string fragments with additional information.","Example 41. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-40), wherein said determining untrusted or trusted parts of the command instructions includes using a trust-verification policy.","Example 42. The method of example 41 (as well as subject matter of one or more of any combination of examples 30-40), wherein said trust-verification policy includes ensuring that certain critical parts of said command instructions exactly match one signature fragment.","Example 43. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-42), wherein said identifying potential attacks includes using a trust-verification policy.","Example 44. The method of example 43 (as well as subject matter of one or more of any combination of examples 30-42), wherein said trust-verification policy includes ensuring that certain critical parts of said command instructions exactly match one signature fragment.","Example 45. The method of example 40 (as well as subject matter of one or more of any combination of examples 30-39 and 41-44), wherein said identifying potential attacks includes using annotations.","Example 46. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-45), wherein said identifying potential attacks includes using annotations.","Example 47. The method of example 45 (as well as subject matter of one or more of any combination of examples 30-44 and 46), wherein said annotations are generated by said post-processing step.","Example 48. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-47), wherein said signature fragments specify patterns.","Example 49. The method of example 48 (as well as subject matter of one or more of any combination of examples 30-47), wherein said patterns comprise one or more of the following: regular expressions, wild-card specifiers, format string specifiers, context-free grammars, or grammars.","Example 50. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-49), wherein if the method of identifying potential attacks results in no potential attacks then said command is deemed as safe, thereby defining a safe command.","Example 51. The method of example 50 (as well as subject matter of one or more of any combination of examples 30-49), further comprising: transmitting said safe command to a command interpreter module.","Example 52. The method of example 51 (as well as subject matter of one or more of any combination of examples 30-50), further comprising: executing said safe command; and generating a command response.","Example 53. The method of example 50 (as well as subject matter of one or more of any combination of examples 30-49 and 51-52), further comprising accepting said safe command.","Example 54. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-53), wherein said output device includes at least one of the following: storage, memory, network, printer or a display.","Example 55. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-54), wherein said command instructions comprise instructions to an operating system (OS).","Example 56. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-55), wherein said command instructions comprise database commands or structured query language (SQL) instructions.","Example 57. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-56), wherein said command instructions comprise instructions to a format string interpreter.","Example 58. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-57), wherein said command instructions comprise instruction to an LDAP interpreter.","Example 59. The method of example 29, wherein said command instructions comprise instruction to an XPATH interpreter.","Example 60. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-59), wherein said command instructions comprise instructions to a web language.","Example 61. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-60), wherein said command instructions comprise instructions to a scripting language interpreter.","Example 62. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-61), wherein said command instructions comprise instructions to a No SQL database.","Example 63. The method of example 29 (as well as subject matter of one or more of any combination of examples 30-62), wherein said command instructions include any combination of one or more of the following: instructions to an operating system (OS), instructions to a data base or instructions to an, SQL interpreter, instructions to a web based language; instructions to a format string interpreter; instructions to a LDAP, interpreter, instructions to an XPath interpreter, instructions to a scripting language, and instructions to a NoSQL database.","Example 64. An aspect of an embodiment of the present invention provides, but not limited thereto, a system for detecting command injection attacks based on command instructions to be received from a client processor or client data memory. The system may comprise: a memory unit operative to store software code; and a processor. The processor may be configured to: extract string fragments from the software code to provide extracted signature fragments; receive the client command instructions; convert the received command instructions into command fragments; identify critical parts from the commands fragments; determine if the critical parts are untrusted or trusted by matching with the extracted signature fragments; identify potential attacks upon the condition that a command includes critical parts that are untrusted; and communicate the identification of potential attacks to an output device.","Example 65. The system of example 64, wherein said output device includes at least one of the following: storage, memory, network, printer or a display.","Example 66. The system of example 64, wherein the command instructions to be received from the client processor or client data memory includes one or more of the following types: instructions to an operating system (OS), instructions to a data base or instructions to an SQL interpreter, instructions to a web based language; instructions to a format string interpreter; instructions to a LDAP interpreter, XPATH interpreter, instructions to a scripting language, and instructions to a NoSQL database.","Example 67. The system of example 64, wherein said processor is further configured to: reject said command that includes critical parts that are untrusted.","Example 68. The system of example 64, wherein said processor is further configured to: remediate said command that includes critical parts that are untrusted;","Example 69. The system of example 68, wherein said remediation of said identified potential attack command includes providing one or more of the following instructions: terminating the software program, repairing the potential attack command, enabling additional system monitoring, enabling additional analysis, logging that a suspicious command is being attempted, alerting a supervisory remote computer that a breach is being attempted, notifying an administrator of the suspicious command, not issuing the command but returning an error code, not issuing the command but returning a non-error code, issuing a known bad command and returning the resulting error codes, displaying an alert to the end user, or combination thereof.","Example 70. The system of example 68, said remediation includes altering said identified potential attack command.","Example 71. The system of example 68, further comprising:","a command interpreter module, and wherein said processor is further configured to: transmit said remediated command to said command interpreter module for execution. to generate a command response.","Example 72. The system of example 68, wherein said processor is further configured to: transmit said remediated command for execution to generate a command response.","Example 73. The system of example 68, wherein said system further comprise: a command interpreter, and wherein said processor is further configured to: wherein if a command does not include critical parts that are untrusted then the command is deemed safe; and accept said safe command and transmit said safe command to said command interpreter module for execution to generate a command response.","Example 74. The system of example 64, wherein said processor is further configured to: remediate or reject one or more of said identified potential attack","Example 75. The system of example 74, further comprising: a command interpreter module, and wherein said processor is further configured to: transmit said remediated command to said command interpreter module for execution. to generate a command response.","Example 76. The system of example 73, wherein said identifying critical parts includes at least one of the following: parsing, dissecting, lexical analyzing, or tokenizing.","Example 77. The system of example 64, wherein said extracting comprises a string extracting technique, and said compute processer being configured to:","post-process of said extracted signature fragments.","Example 78. The system of example 77, wherein said post-processing may comprise one or more of the following: removing said extracted signature fragments; adding said extracted signature fragments; modifying said extracted signature fragments; or annotating said extracted signature fragments with additional information.","Example 79. The system of example 64, wherein said identifying potential attacks includes using annotations.","Example 80. The system of example 79, wherein said annotations are generated by said post-processing.","Example 81. The system of example 64, wherein said signature fragments specify patterns.","Example 82. The system of example 81, wherein said patterns comprise one or more of the following: regular expressions, wild-card specifiers, format string specifiers, context-free grammars, or grammars.","Example 83. The system of example 64, wherein said memory unit, said processor, and said client processor or client data memory are disposed within a single device.","Example 84. The system of example 83, wherein said device comprises: smart phone, laptop, computer notebook, iPad, PDA, PC, desktop, tablet, camera, gaming device, or television:","Example 85. The system of example 64, wherein said memory unit and said processor are remotely located from the client processor or client data memory.","Example 86. The system of example 85, wherein said processor is in communication with said client processor or client data memory by a wired network or a wireless network.","Example 87. An aspect of an embodiment of the present invention provides, but not limited thereto, a system for detecting command injection attacks based on command instructions to be received from a client processor or client data memory. The system may comprise: a memory unit operative to store software code and a processor. The processor may be configured: receive string fragments to provide signature fragments; receive command instructions; convert the received command instructions into command fragments; identify critical parts from the commands fragments; determine untrusted or trusted parts of the command instructions by using the signature fragments; identify potential attacks upon the condition that a command includes critical parts that are untrusted; and communicate the identification of potential attacks to an output device.","Example 88. The system of example 87, wherein said received string fragments are provided by extracting string fragments from said received software.","Example 89. The system of example 87, wherein said received string fragments are provided by one or more of any of the following: receiving from the software developer, downloading from a networked resource, distributed with the software, manually specifying string fragments, or static or dynamic analysis of the software code.","Example 90. The system of example 87, wherein said processor is further configured to: monitor, remediate or reject one or more of said identified potential attack commands.","Example 91. The system of example 90, wherein said remediation includes altering the identified potential attack command.","Example 92. The system of example 90, wherein said processor is further configured to: transmit said remediated command to a command interpreter module.","Example 93. The system of example 92, wherein said processor is further configured to: execute said remediated command in said command interpreter; and generate a command response.","Example 94. The system of example 90, wherein said processor is further configured to: transmit said remediated command for execution; and generate said executed command as a command response.","Example 95. The system of example 90, wherein said monitoring, remediation or rejection of said identified potential attack command includes performing one or more of the following actions: terminating the software program, repairing the potential attack command, enabling additional system monitoring, enabling additional analysis, logging that a suspicious command is being attempted, alerting a supervisory remote computer that a breach is being attempted, notifying an administrator of the suspicious command, not issuing the command but returning an error code, not issuing the command but returning a non-error code, issuing a known bad command and returning the resulting error codes, displaying an alert to the end user, or any combination thereof.","Example 96. The system of example 87, wherein said identifying critical parts includes at least one of the following: parsing, dissecting, scanning, tokenizing, or lexical analysis.","Example 97. The system of example 87, wherein said processor is further configured to: post-process said received string fragments.","Example 98. The system of example 97, wherein said post-processing may comprise one or more of the following: removing some of said string fragments; adding additional fragments to said string fragments; modifying said string fragments; or annotating said string fragments with additional information.","Example 99. The system of example 87, wherein said determining untrusted or trusted parts of the command instructions includes using a trust-verification policy.","Example 100. The system of example 99, wherein said trust-verification policy includes ensuring that certain critical parts of said command instructions exactly match one signature fragment.","Example 101. The system of example 87, wherein said identifying potential attacks includes using a trust-verification policy.","Example 102. The system of example 101, wherein said trust-verification policy includes ensuring that certain critical parts of said command instructions exactly match one signature fragment.","Example 103. The system of example 98, wherein said identifying potential attacks includes using annotations.","Example 104. The system of example 87, wherein said identifying potential attacks includes using annotations.","Example 105. The system of example 103, wherein said annotations are generated by the post-processing.","Example 106. The system of example 87, wherein said signature fragments specify patterns.","Example 107. The system of example 106, wherein said patterns comprise one or more of the following: regular expressions, wild-card specifiers, format string specifiers, context-free grammars, or grammars.","Example 108. The system of example 87, wherein if said identifying potential attacks results in no potential attacks then said command is deemed as safe, thereby defining a safe command.","Example 109. The system of example 108, wherein said processor is further configured to: transmit said safe command to a command interpreter module.","Example 110. The system of example 109, wherein said processor is further configured to: execute said safe command; and generate a command response.","Example 111. The system of example 108, wherein said processor is further configured to accept said safe command.","Example 112. The system of example 87, wherein said output device includes at least one of the following: storage, memory, network, printer or a display.","Example 113. The system of example 87, wherein said command instructions comprise instructions to an operating system (OS).","Example 114. The system of example 87, wherein said command instructions comprise database commands or structured query language (SQL) instructions.","Example 115. The system of example 87, wherein said command instructions comprise instructions to a format string interpreter.","Example 116. The system of example 87, wherein said command instructions comprise instruction to an LDAP interpreter.","Example 117. The system of example 87, wherein said command instructions comprise instruction to an XPATH interpreter.","Example 118. The system of example 87, wherein said command instructions comprise instructions to a web language.","Example 119. The system of example 87, wherein said command instructions comprise instructions to a scripting language interpreter.","Example 120. The system of example 87, wherein said command instructions comprise instructions to a NoSQL database.","Example 121. The system of example 87, wherein said command instructions include any combination of one or more of the following: instructions to an operating system (OS), instructions to a data base or instructions to an, SQL interpreter, instructions to a web based language; instructions to a format string interpreter; instructions to a LDAP, interpreter, instructions to an XPath interpreter, instructions to a scripting language, and instructions to a NoSQL database.","Example 122. The system of example 87, wherein said memory unit, said processor, and said client processor or client data memory are disposed within a single device.","Example 123. The system of example 122, wherein said device comprises: smart phone, laptop, computer notebook, iPad, PDA, PC, desktop, tablet, camera, gaming device, or television:","Example 124. The system of example 87, wherein said memory unit and said processor are remotely located from the client processor or client data memory.","Example 125. The system of example 124, wherein said processor is in communication with said client processor or client data memory by a wired network or a wireless network.","Example 126. An aspect of an embodiment of the present invention provides, but not limited thereto, a non-transitory computer readable medium including instructions executable by a processor for detecting command injection attacks. The instructions may comprise: receiving software code; extracting string fragments from the received software code to provide extracted signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining if the critical parts are untrusted or trusted by matching with the extracted signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","Example 127. The non-transitory computer readable medium of example 126, wherein said output device includes at least one of the following: storage, memory, network, printer or a display.","Example 128. The non-transitory computer readable medium of example 126, wherein said instructions further comprise performing any of the steps recited in any one of examples 1-28","Example 129. An aspect of an embodiment of the present invention provides, but not limited thereto, a non-transitory computer readable medium including instructions executable by a processor for detecting command injection attacks. The instructions may comprise: receiving software code; receiving string fragments to provide signature fragments; receiving command instructions; converting the received command instructions into command fragments; identifying critical parts from the commands fragments; determining untrusted or trusted parts of the command instructions by using the signature fragments; identifying potential attacks upon the condition that a command includes critical parts that are untrusted; and communicating the identification of potential attacks to an output device.","Example 130. The non-transitory computer readable medium of example 129, wherein said output device includes at least one of the following: storage, memory, network, printer or a display.","Example 131. The non-transitory computer readable medium of example 129, wherein said instructions further comprise performing any of the steps recited in any one of examples 29-63.","The following patents, applications and publications as listed below and throughout this document are hereby incorporated by reference in their entirety herein. The devices, systems, materials, compositions, networks, computer readable media, and methods of various embodiments of the invention disclosed herein may utilize aspects disclosed in the following references, applications, publications and patents and which are hereby incorporated by reference herein in their entirety (and which are not admitted to be prior art with respect to the present invention by inclusion in this section).\n\n","The references listed above, as well as all references cited in the specification, including patents, patent applications, journal articles, and all database entries, are incorporated herein by reference to the extent that they supplement, explain, provide a background for, or teach methodology, techniques, and\/or compositions employed herein (and which are not admitted to be prior art with respect to the present invention by inclusion in this section).","In summary, while the present invention has been described with respect to specific embodiments, many modifications, variations, alterations, substitutions, and equivalents will be apparent to those skilled in the art. The present invention is not to be limited in scope by the specific embodiment described herein. Indeed, various modifications of the present invention, in addition to those described herein, will be apparent to those of skill in the art from the foregoing description and accompanying drawings. Accordingly, the invention is to be considered as limited only by the spirit and scope of the following claims, including all modifications and equivalents.","Still other embodiments will become readily apparent to those skilled in this art from reading the above-recited detailed description and drawings of certain exemplary embodiments. It should be understood that numerous variations, modifications, and additional embodiments are possible, and accordingly, all such variations, modifications, and embodiments are to be regarded as being within the spirit and scope of this application. For example, regardless of the content of any portion (e.g., title, field, background, summary, abstract, drawing figure, etc.) of this application, unless clearly specified to the contrary, there is no requirement for the inclusion in any claim herein or of any application claiming priority hereto of any particular described or illustrated activity or element, any particular sequence of such activities, or any particular interrelationship of such elements. Moreover, any activity can be repeated, any activity can be performed by multiple entities, and\/or any element can be duplicated. Further, any activity or element can be excluded, the sequence of activities can vary, and\/or the interrelationship of elements can vary. Unless clearly specified to the contrary, there is no requirement for any particular described or illustrated activity or element, any particular sequence or such activities, any particular size, speed, material, dimension or frequency, or any particularly interrelationship of such elements. Accordingly, the descriptions and drawings are to be regarded as illustrative in nature, and not as restrictive. Moreover, when any number or range is described herein, unless clearly stated otherwise, that number or range is approximate. When any range is described herein, unless clearly stated otherwise, that range includes all values therein and all sub ranges therein. Any information in any material (e.g., a United States\/foreign patent, United States\/foreign patent application, book, article, etc.) that has been incorporated by reference herein, is only incorporated by reference to the extent that no conflict exists between such information and the other statements and drawings set forth herein. In the event of such conflict, including a conflict that would render invalid any claim herein or seeking priority hereto, then any such conflicting information in such incorporated by reference material is specifically not incorporated by reference herein."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated into and form a part of the instant specification, illustrate several aspects and embodiments of the present invention and, together with the description herein, serve to explain the principles of the invention. The drawings are provided only for the purpose of illustrating select embodiments of the invention and are not to be construed as limiting the invention.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 9B","FIG. 9A"],"b":["302","304","306"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 9C","FIG. 9A"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
