---
title: Method and system for dynamically generating a watermarked document during a printing or display operation
abstract: A dynamic watermarking capability is implemented in an enterprise rights management (ERM) or similar system that comprises a central server to which end user client machines are connectable. The central server has a database in which watermark definitions created by authorized entities are centrally stored. An end user client machine is provided with a client component that typically includes wrapper code, and watermarking rendering code. The wrapper and rendering code are instantiated when a given calling application is started, or when the application initiates a given rendering function such as a print or display operation. When the calling application begins the rendering operation, the wrapper code intercepts a given rendering function call, connects to the central server and then retrieves a watermark definition. Alternatively, the watermark definition is retrieved when a document to be rendered is first accessed on the client machine. The watermark definition is then applied by the watermark rendering code, preferably using local rendering resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321947&OS=08321947&RS=08321947
owner: EMC Corporation
number: 08321947
owner_city: Hopkinton
owner_country: US
publication_date: 20051215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT STATEMENT","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["This application includes subject matter that is protected by copyright. All rights are reserved.","1. Technical Field","The present invention relates generally to document protection using digital watermarking techniques.","2. Background of the Related Art","Digital watermarking is a well-defined art. The following are representative patents that describe watermarking techniques in the context of document or image printing.","U.S. Pat. No. 6,970,259 describes a print management system that implements a policy to determine a protection level for a document to be printed. The document is printed using watermarks, glyphs, and digital signatures, which are appropriate to the level of protection determined by the policy. A set of printers are managed by a print management system. Each printer can provide a range of protection technologies. The policy determines the protection technologies for the document to be printed. The print management system routes the print job to a printer that can apply the appropriate protections and sets the appropriate parameters in the printer. Copy evidence that can establish that a document is a forgery and\/or tracing information that identifies the custodian of the document and restrictions on copying of the document and use of the information in the document are included in the watermark that is printed on the document. A document can be verified as an original or established as a forgery by inspecting the copy evidence and\/or tracing information in the watermark.","U.S. Pat. No. 5,488,664 describes a method and device for protecting visual information against unauthorized access and modification using a printed cryptographic watermark includes printing a first array of shapes on a first sheet of material to be protected and printing a second array of shapes on a second sheet of material, which is transparent so as to form a developer for developing a watermark encoded in a combination of the first and second arrays of shapes. The watermark is encoded by preparing each array using black and white pixels.","U.S. Pat. No. 6,389,151 describes a document validating system. Documents are produced by beginning with a template that defines the placements of elements on the document and the interrelationships between hidden and visual information on the document. The template specifies the placement of elements such as images, photographs, and text and it also specifies the interrelationship between information that is visually perceptible to a user of the document and information that is hidden by means of digital watermarks. Different hidden digital watermark data is included in multiple elements of the document. The watermarks in the different graphic elements of the document are correlated to each other and correlated to the visual material on the document. The system also includes a physical characteristic reader for automatically reading a physical characteristic of a person presenting the document and multiple hidden digital watermarks from different elements of said document, and a comparator for comparing the output of the physical characteristic reader with information stored in the hidden digital watermarks.","In addition, software applications such as Microsoft Word provide a document author with the capability of defining a watermark prior to creating a document, as well as defining how the watermark should be \u201capplied\u201d to a given document.","While these prior art techniques provide generally useful solutions, they require that the watermark to be created and the manner in which it is to be applied to be predetermined. They do not afford an authorized entity the ability to create a custom watermark in a centralized manner that can then be applied dynamically during a given rendering operation.","The present invention addresses this need in the art.","It is an object of the present invention to enable a calling application running on a client machine to securely receive centrally-defined watermark definition data that is then used locally to render a watermark, preferably during a given document printing or display operation.","In a representative embodiment, a dynamic watermarking capability is implemented in an enterprise rights management (ERM) or similar system that comprises a central server to which end user client machines are connectable. The central server has a database in which watermark definitions created by authorized entities are centrally stored. An end user client machine is provided with a client component that typically includes wrapper code, and watermarking rendering code. The wrapper and rendering code are instantiated when a given calling application is started, or when the application initiates a given rendering function such as a print or display operation. When the calling application begins the rendering operation, the wrapper code intercepts a given rendering function call, connects to the central server and then retrieves a watermark definition. The watermark definition is then applied by the watermark rendering code, preferably using local rendering resources. In the alternative, the watermark definition is retrieved by the client component prior to the actual rendering operation, e.g., when a document to be printed or displayed is first opened by an application, which typically occurs when the ERM system provides the application with a decryption key or the like. In this alternative embodiment, the watermark definition may be provided to the client machine at the same time (or along with) the decryption key used to enable access to the document.","Preferably, the wrapper code hooks into one or more calling application graphic device interface (GDI) function calls to securely retrieve centrally-defined watermark definition data that is then used locally to render an \u201cunderlay\u201d or \u201coverlay\u201d watermark.","The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.","The present invention enables a digital watermark to be defined centrally in a policy-based manner and then applied at an enterprise workstation \u201con-the-fly\u201d (i.e. dynamically) as a document is being rendered (e.g., printed, displayed, or the like), e.g., by operating system resources. For illustrative purposes only, the watermark rendering aspect of the invention is described in the context of a workstation having a Microsoft\u00ae Windows\u00ae operating system platform such as Windows XP. The present invention, however, is described in this context by way of example only; the rendering aspect of the dynamic watermarking technique may be implemented in any operating system including, without limitation, UNIX, Linux, OS\/X, or the like. A representative machine or data processing system comprises a processor, an operating system, a set of input\/output devices such as a display, a printer, or the like. The data processing system may be a standalone machine or connected to a network, such as a LAN, a WAN, the Internet, an intranet, or the like. The data processing system is assumed to execute a host or calling application, such as Microsoft Word, Excel, or the like, from which a document is to be printed or displayed (more generally, rendered) by a rendering device such as a printer or video display. It is also assumed that a watermark \u201cdefinition\u201d is created and stored on a separate machine, typically a server, such as a dedicated watermarking server (or as a server process). The watermarking server may be a standalone machine or associated with another type of server. Thus, for example, in one embodiment the watermarking server is a server process that executes in association with a digital rights management (DRM) solution such as Authentica\u00ae Secure Documents\u2122 platform. That platform provides an enterprise rights management solution that protects information that is actively being revised or must otherwise remain in a native (e.g., Microsoft Office) format. Information is encrypted and persistently protected even while it is being accessed. In the Authentica system, a policy server enables a system administrator or other content owners to change and securely enforce user permissions (view, copy, forward, print or edit) and recall documents after they have been distributed. To access a protected document (which may be of any type) in such a system, the policy server provides a calling application plug-in with a decryption key and a policy that are then applied at the application to enable access to and use of a protected document. Further details regarding an enterprise rights management solution of this type is described in commonly-owned U.S. Pat. No. 6,289,450, the disclosure of which is incorporated herein by reference.","According to one advantage of the present invention, an enterprise rights management server (such as a policy server on which centralized document policies are created and enforced) is augmented with a watermarking process to facilitate policy-based watermarking. This enables an enterprise administrator or other permitted entity to centrally apply a printed or visual watermark on documents, e.g., to communicate data classification and deter unauthorized forwarding and copying by recipients. In one embodiment, as the rights management server provides a client application plug-in with a decryption key and policy to enable access to and use of a protected document, that server (or some process therein or associated therewith) can also provide a watermark definition to be applied to that document.","Thus, the dynamic watermarking function of the present invention preferably is implemented using a set of components, as illustrated in . In a typical scenario, a server  executes a server component  of the invention, while a data processing machine  executes a client component . The server component  and client component preferably communicate over a secure link , e.g., via SSL, or TLS, or some other proprietary protocol. As will be seen, the information communicated from the server component to the client component is sometimes referred to as a \u201cwatermark definition.\u201d This data is used by the client to create a watermark \u201con-the-fly\u201d as a given rendering operation takes place on the data processing machine. If a lesser degree of security can be tolerated, the client component  may communicate with the server as a Web service or in any other non-secure or semi-secure manner. Typically, however, it will be desired to have watermark data (e.g., the watermark definition) created and stored in the server and available to the client component on an as-needed basis only. This is sometimes referred to herein as a policy-based watermarking scheme. In a typical use case, an administrator defines a watermark centrally and associates a use policy therewith. When the policy is triggered, the watermark data is transmitted from the server component to the client component only when required (e.g.,. when a protected document is opened, or as a protected document is about to be rendered), and that watermark data preferably is retained in system memory (instead of stored on disk) at the machine . As will be described in more detail below, preferably the server  also has or is associated with a database  in which the watermark data (a set of watermark definitions) is stored. In one embodiment, the data processing system also includes a graphical user or command line interface  that provides an administrator with the ability to design custom watermarks for use, for example, by authorized or permitted users, and to associate a given policy defining use conditions.","As will be seen, the client component  generally has two functional modules, a wrapper component , and a watermark rendering engine . In operation, it is assumed that a host (or \u201ccalling\u201d) application loads the client component  of the present invention when that application starts up or initiates a rendering (e.g., a print, a display) operation. Upon loading, the client component is instantiated and hooks into one or more application programming interface (API) rendering (e.g., print or display) functions. This hooking function enables the client component to intercept various function calls generated to the operating system by the calling application, and to take various actions thereafter, namely, to securely retrieve information from the watermarking server from which the watermark is then created and rendered. As will be seen, these actions are carried out transparently to the calling application, which is not aware that the client component has taken over the printing or display process.","By way of brief background, the Microsoft Windows operating system uses a graphics device interface (GDI) to enable applications to use graphics and formatted text on both a printer as well as a video display. Thus, Windows-based applications do not access graphics hardware directly; rather, the device interface typically interacts with device drivers on behalf of the calling application. The GDI print functions in Windows include, for example, functions such as CreateDC( ), StartDoc( ), StartPage( ), EndPage( ) and EndDoc( ). The CreateDC( ) function acquires a device context that can be used to draw to a printer device. The StartDoc( ) function starts a print job. The EndDoc( ) function ends a print job. The StartPage( ) function prepares the printer driver to accept data. The EndPage( ) function notifies the printer device that the application has finished writing to a page. This latter function is typically used to direct the device driver to advance to a new page. Different GDI functions are used to render information on a video display. In particular, the operating system notifies an application that portions of its display area need to be drawn, typically by sending the application a WM_PAINT notification message. The application typically responds to the WM_PAINT notification by calling GetDC( ) or GetDCEx( ) GDI function acquire a device context that can be used to draw to the screen. After drawing is complete, the application calls the ReleaseDC( ) function.","Thus, in both printing and video display, a calling application creates or acquires a device context and uses a set of rendering functions to render the desired content. According to the present invention, this rendering process is enhanced through the inclusion of a watermark, which is created, preferably on-the-fly, from a watermark definition that is securely retrieved from the server component. Typically, the watermark itself is not stored in the database, although this is not a limitation. According to one illustrative embodiment of the invention, there are primarily two (2) different types of watermarks. As used herein, an \u201cunderlying\u201d or \u201cunderlay\u201d watermark is a watermark that is designed to be rendered under information before the information is rendered by printing or display. In contrast, an \u201coverlying\u201d or \u201coverlay\u201d watermark is a watermark that is designed to be rendered on top of or over information after the information is rendered. According to the present invention, once a given printer or display device context has been created and is available for rendering, the client component securely retrieves a watermark definition from the server component, creates a watermark dynamically, and uses local resources (e.g., GDI functions) to write an underlay or overlay watermark. This process will now be described in more detail by reference to the process flow diagram shown in . In this embodiment, a host application  is assumed to be executing on an end user client machine having an operating system , and the wrapper code  has been instantiated. A watermarking server  has stored therein a watermark definition and is connectable to the end user client machine, preferably over a secure link. Watermark rendering code  is also instantiated in the end user client machine and waits for work.","The process typically begins when a user of the data processing system opens some resource (e.g., a Word document, an Excel spreadsheet, a PowerPoint presentation, or the like) in the host application and initiates a given rendering (e.g., print or display) operation. Any calling application may use the present invention, and the watermark may be applied to any type of document, e.g., a text document, an spreadsheet, a presentation, an email, a document processed in another format (e.g., PDF), or the like. For purposes of the following discussion, the invention is described in the context of a printing operation. In a conventional print operation (i.e. where the client component is not present), the host application calls the StartDoc( ) API function at step . Because this API call has been hooked, however, the wrapper code of the present invention is invoked. In particular, the wrapper code intercepts the StartDoc( ) API function call transparently to the host application. In other words, as far as the host application is concerned, the StartDoc( ) API function is proceeding normally. At this point, the server component is contacted, preferably over a secure connection, and a determination is made regarding whether the user has authority to perform a print operation. This is step . In the alternative, as noted above, the watermarking server or process may be contacted to obtain the watermark definition when an application (or some plug-in associated therewith) first opens a given document to be rendered. In an enterprise rights management system, the application may need to obtain a decryption key and policy before it can open a given document; in such case, the watermark definition may be provided from the watermarking server process at the same time the application obtains the decryption key and policy, usually from a separate policy server. The determining step may be omitted if the user has already been authorized or authenticated through some other known means or mechanism (e.g., secure logon, user id and password checking, ACL checking, encryption, or the like). If the outcome of any determination is positive, the wrapper code fetches a watermark definition from the server at step . As noted above, preferably this data is obtained over a secure connection and is not exposed to the calling application or the end user. The wrapper code then uses the watermark definition to create one or more watermarks, which are then passed to the watermark rendering code at step . At step , optionally the server is also notified by the wrapper code that the print operation has begun. The server can use this information for auditing or other administrative or management purposes, such as reporting on when a given watermark was supplied to a given document. At step , the wrapper code then passes the StartDoc( ) API function call to the operating system kernel. The operating system returns a print job identifier at step ; thereafter, at step , this identifier is then passed back to the calling application. At this point, the semantics of the original StartDoc( ) API function call have been preserved.","The calling application then begins the print job, typically by printing a first page. To this end, the calling application issues a StartPage( ) function call to the operating system kernel. This function call is once again intercepted by the wrapper code, which has hooked the application's native print function. This is step . At step , the wrapper code forwards the StartPage( ) function call to the operating system kernel. It then increments a page number count at step . If the watermark definition retrieved from the server defines an \u201cunderlay\u201d watermark, the wrapper code instructs the renderer code to draw the watermark at this time. This is step . The renderer code then proceeds to draw what is, in effect, a \u201ccustom\u201d watermark, as it is a watermark that has been created for this particular rendering operation. Preferably, the renderer code draws the watermark using the native GDI functions. This is step . Thus, for example, the renderer code generates the underlay watermark by passing to the operating system a TextOut( ) function call, which writes a character string at a specified location using a currently selected font, background color and text color, or a BitBlt( ) function call, which performs a bit-block transfer of color data corresponding to a rectangle of pixels, or calling whatever other underlying rendering function is required. The above are merely representative functions, of course. At step , after any underlay watermark is rendered, the host application writes the page output, also preferably using the available GDI operating system calls. This page output is written on top of any watermark drawn in step .","At step , the host application calls an EndPage( ) API function. The wrapper code also intercepts this function call. If the watermark definition retrieved from the server contains an \u201coverlay\u201d watermark, the wrapper instructs the rendering code to print this watermark at step . As described above, preferably the watermark renderer code calls the necessary GDI functions to draw the overlay watermark. This is step . At step , the original EndPage( ) function call is then passed from the wrapper to the operating system kernel to preserve the expected function call semantics. This completes the watermark rendering process.","Thus, as can be seen, the wrapper code hooks into one or more calling application graphic device interface (GDI) function calls to securely retrieve centrally-defined watermark definition data that is then used locally to render a watermark.","Although not described in detail, one of ordinary skill in the art will appreciate that more than one watermark may be laid under or laid over given output information within a given printer or display device context. Of course, a given page may include both an underlay and an overlay watermark. A given watermark may comprise any given information (e.g., text, alphanumeric data, symbols, messages, graphics, images, or combinations thereof). The watermark rendering code may also include logic that applies a given mathematical or other function to given watermark data to create the watermark.","As noted above, the present invention is not limited to dynamic watermarking during a print operation. As noted above, the invention may also be used to provide \u201con-screen\u201d watermarking during a display operation. To implement on-screen watermarks, the watermarks are applied before (as an underlay) or after (as an overlay) as the calling application writes its output to the display device. This is achieved by hooking an application's WM_PAINT notification message handler. Underlay watermarks are drawn before the WM_PAINT message is passed to the host application; overlay watermarks are drawn after the WM_PAINT message has been processed by the host application.","As noted above, preferably the watermark definitions are stored in a central database, with access thereto being managed by a server component over a secure link. This provides a policy-based watermark solution when the invention is implemented in conjunction with or as part of an enterprise rights management solution. In this manner, neither the end user nor the calling application can easily interfere with the watermark process or tamper with the contents of the watermark itself. Preferably, as noted above, the watermark is maintained in-memory only in the machine that hosts the calling application. The server component, however, preferably receives information from the client component that enables the server to log the watermark created, the watermark creation time, whether the watermark was supplied under or over the rendered output, as well as the printer or display device content in which the watermark was supplied. A given watermark definition on the server may also be changed as a result of the connection that is established between a client computer and the server. In particular, additional \u201cdynamic\u201d information (e.g., user name, password, and\/or IP address from which the client connects to the server, or other such information) may be substituted into the watermark definition and logged as necessary.","Thus, according to the centralized policy aspect of the present invention, preferably a system administrator or other authorized entity defines the watermarks that may be rendered dynamically and when and how those watermarks are applied to end user client machines that are connectable to the server. In a representative enterprise rights management environment, watermarks are associated with data classifications, user policies, document policies, policy templates, or site or default policies. In one embodiment, a watermark comprises user-defined text that will appear on a protected document page when it is viewed or printed. In a typical use scenario, an administrator having secure access to the watermarking server creates a watermark definition by defining the watermark text, its color or shade characteristics (gray scale), translucency, as well as its position and orientation, e.g., top or bottom of a page, diagonally across a page, or the like. The watermark definition is then associated with or made a component of a user policy, a site policy, a default policy, or the like.","The watermarking function watermarks a document with information that an authorized entity (e.g., an administrator) specifies in a data structure, referred to herein for convenience as a \u201cwatermark definition.\u201d Typically, the watermark definition is a text file (or, more generally, a data structure) that contains margin settings, text to watermark, and formatting information for each watermark item. The administrator or other permitted entity can change a sample watermark definition or can create a custom watermark definition. Typically, there is a watermark definition that includes a watermark item for each piece of information to watermark. Thus, a watermark may be represented internally in the system by a watermark definition. The parsing of the watermark text and processing of substitution variables may be based on a native application function. In a representative implementation, there are classes that take over the functionality of parsing a watermark description and formatting of watermarking text. Watermarking may also provide run-time variable substitution of information, such as user name, document ID, server time, and the like. Similarly, conditional logic may be executed to control the content of the watermark, e.g., based on any number of environment conditions such date, time, software version, user or group, network address, or the like. A representative watermark definition is shown in .","Generalizing, a watermark definition contains margin settings and one or more watermarks. For example, it may be desired that a document have the date and time watermarked at the top of its pages and page numbers watermarked at the bottom of its pages. Or, the administrator might want to watermark different information on different page ranges. The information watermarked on the document pages is contained in message blocks. A message block contains the parameters for one piece of information that can be watermarked on one or more pages. A message block begins with the text begin_message on a line by itself. The message block contains required and optional information used to create and position the watermarked information. A message block ends with the text end_message on a separate line. The table in  shows each of the parameters included in a representative message block. In addition, preferably there are a number of variables that can be used to format text to watermark. For example, the user might want to watermark the date and time on document pages. There are several date formats to choose from. These variables let the administrator indicate exactly how he or she wants the date to appear.  is a table showing representative variables for information such as dates, times, and page numbers. Preferably, each variable is case sensitive and has a specific format as indicated.","As noted above, preferably the server includes an administrative GUI or other CLI to enable an authorized entity to create a watermark definition and to apply that definition to a given policy that is enforceable by the enterprise rights management system. In a representative embodiment, the entity obtains authorized or permitted access and opens a watermark definition creation dialog. A display panel identifies existing watermark definitions or affords the user an opportunity to create a new watermark definition. In the latter case, the user identifies the new watermark definition, enters descriptive text, and creates the new definition. Suitable menus and display objects are useful for this purpose, although the particular details of any design GUI or CLI are not material to the present invention. Once the new watermark definition has been created, it is saved in the server database. Of course, there may be many servers and databases, and they may be connected in any convenient manner. In one alternative embodiment, the watermarking server is operated as a managed service that is available online, e.g., on the public Internet, or via a secure intranet.","The following provides additional details of a representative implementation.","Watermark Classes","The following watermark classes preferably are callable from a library and available to a client.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class WatermarkItem"},{"entry":"{"},{"entry":"\u2003public:"},{"entry":"\u2003\u2003enum Layer {Underlay, Overlay};"},{"entry":"\u2003\u2003enum Justification {Left, Center, Right};"},{"entry":"\u2003\u2003enum Position {Top, Bottom, DiagTopLeft, DiagBottomLeft};"},{"entry":"\u2003\u2003enum TextType {Outline, Filled};"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Callback to retrieve info about the document for formatText( )."},{"entry":"\u2003\u2003\/\/ Return false if error encountered or info item not found."},{"entry":"\u2003\u2003\/\/ This will halt the formatText( ) processing."},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003typedef (bool *)DocInfoCallback(string &infoName, string &infoVal,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003void *cbParm);"},{"entry":"\u2003\u2003WatermarkItem( );"},{"entry":"\u2003\u2003virtual ~WatermarkItem( );"},{"entry":"\u2003\u2003void setName(string &name);"},{"entry":"\u2003\u2003void setText(string &text);"},{"entry":"\u2003\u2003void setPosition(Position pos);"},{"entry":"\u2003\u2003void setJustification(Justification just);"},{"entry":"\u2003\u2003void setStartPage(int startPage);"},{"entry":"\u2003\u2003void setEndPage(int endPage);"},{"entry":"\u2003\u2003void setSize(int size);"},{"entry":"\u2003\u2003void setColor(int color);"},{"entry":"\u2003\u2003void setTextType(TextType ttype);"},{"entry":"\u2003\u2003void setLayer(Layer layer);"},{"entry":"\u2003\u2003string getName(void);"},{"entry":"\u2003\u2003string getText(void);"},{"entry":"\u2003\u2003Position getPosition(void);"},{"entry":"\u2003\u2003Justification getJustification(void);"},{"entry":"\u2003\u2003TextType getTextType(void);"},{"entry":"\u2003\u2003Layer getLayer(void);"},{"entry":"\u2003\u2003int getStartPage(void);"},{"entry":"\u2003\u2003int getEndPage(void);"},{"entry":"\u2003\u2003int getSize(void);"},{"entry":"\u2003\u2003int getColor(void);"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Translate the watermark variables and replace"},{"entry":"\u2003\u2003\/\/ them with the appropriate values. Passing \u22121"},{"entry":"\u2003\u2003\/\/ for totalPages inhibits processing of %G."},{"entry":"\u2003\u2003\/\/ Passing \u22121 for curPageNum inhibits processing"},{"entry":"\u2003\u2003\/\/ of %g. Passing a null pointer for cb inhibits"},{"entry":"\u2003\u2003\/\/ processing of %i. Passing a null pointer for"},{"entry":"\u2003\u2003\/\/ fileName inhibits processing of %N. Passing a"},{"entry":"\u2003\u2003\/\/ null pointer for filePath inhibits processing of"},{"entry":"\u2003\u2003\/\/ %P. Variables that are not processed are replaced"},{"entry":"\u2003\u2003\/\/ with the empty string."},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003bool formatText(int totalPages, int curPageNum,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003DocInfoCallback *cb, void *cbParm,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string *fileName, string *filePath,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string &outText);"},{"entry":"\u2003private:"},{"entry":"\u2003\u2003string m_name;"},{"entry":"\u2003\u2003string m_text;"},{"entry":"\u2003\u2003Position m_position;"},{"entry":"\u2003\u2003Justification m_justification;"},{"entry":"\u2003\u2003TextType m_textType;"},{"entry":"\u2003\u2003Layer m_layer;"},{"entry":"\u2003\u2003int m_startPage;"},{"entry":"\u2003\u2003int m_endPage;"},{"entry":"\u2003\u2003int m_size;"},{"entry":"\u2003\u2003int m_color;"},{"entry":"};"},{"entry":"class WatermarkSet"},{"entry":"{"},{"entry":"\u2003public:"},{"entry":"\u2003\u2003WatermarkSet(string &data);"},{"entry":"\u2003\u2003virtual ~WatermarkSet( );"},{"entry":"\u2003\u2003int getTopMargin(void);"},{"entry":"\u2003\u2003int getBottomMargin(void);"},{"entry":"\u2003\u2003int getLeftMargin(void);"},{"entry":"\u2003\u2003int getRightMargin(void);"},{"entry":"\u2003\u2003list<WatermarkItem> &getItems(void);"},{"entry":"\u2003private:"},{"entry":"\u2003\u2003list<WatermarkItem> m_items;"},{"entry":"\u2003\u2003int m_version;"},{"entry":"\u2003\u2003int m_topMargin;"},{"entry":"\u2003\u2003int m_bottomMargin;"},{"entry":"\u2003\u2003int m_leftMargin;"},{"entry":"\u2003\u2003int m_rightMargin;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As noted above, preferably, the print watermarks are generated by hooking the StartDoc, EndDoc, StartPage, and EndPage Windows API print functions. In StartDoc( ), the code determines if this is a protected document and if its policy includes watermarks. In StartPage( ), the code applies all watermarks whose Underlay setting is Yes. In EndPage( ), the code applies all watermarks whose Underlay setting is No. For watermarks whose Position setting is diag-topleft or diag-bottomleft, the code tiles the watermark text across and down each page and the Justification setting is ignored. Watermarks whose Position is top or bottom appear at the top or bottom, respectively, and their Justification settings are observed. The Outline, StartPage, EndPage, Size, and Color settings preferably are observed for print watermarks. To support outline, the notion of a path is used. In the GDI API, if BeginPath( ) is invoked and then TextOut( ) calls are followed by EndPath( ), the code converts the text into drawn lines. Invoking StrokePath( ) provides the text appearing in outline form; invoking StrokeAndFillPath( ) provides a non-outline form of the text. For non-outline, preferably both the GDI pen and brush are set to the same color.","Diag-topleft watermarks are very straightforward to achieve, e.g., by creating a logical font the baseline of which is at an angle of 45 degrees below the horizontal and to the right. Preferably, the code creates a path from the text with that orientation and determines its bounding rectangle. The code then creates replicant paths using the width and height of the rectangle as the step between starting points of the text in each path.","Diag-bottomleft watermarks are handled similarly to the diag-topleft type, with the logical font having a baseline that is at an angle of 45 degrees above the horizontal and to the right. The main difference in handling the tiling is that the starting points of the text must be the bottom left corner of the bounding rectangle rather than its top left corner.","Preferably, color is interpreted using a formula R=0\u00d7FF*color\/100 and the same for G and B. This allows the choice of 101 of the 256 shades of grey possible.","The code preferably keeps track of the page count in a StartPage( ) hook; this allows support of a watermark page range as given by the StartPage and EndPage watermark definition settings.","The name and path of the file are available from the document involved.","Routines and Data Structures","The following are illustrative routines and data structures used to print watermarks dynamically according to the present invention.","As described above, these routines are hooked to control printing. The hook calls AllowsPrint( ), which is a routine, internal to this embodiment, that checks the print option for the document. Because the only parameter to EndDoc( ), StartPage( ), and EndPage( ) is an HDC (device context handle), the code keys off that parameter to determine what, if anything, the StartPage( ) and EndPage( ) hooks should do.","The code passes the HDC to AllowsPrint( ) and uses that device handle for registering the print watermark information. The information needed is the HDC, a WatermarkSet, a page counter, and a reference to the document object (alternatively, the function needs to cache built-in document properties, file name, and the file path). The WatermarkSet is the watermark definition, as described above. The class ASOWatermarkPrint contains these data and establishes a global map from the HDC to the ASOWatermarkPrint object for the document being printed.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct ASOWatermarkPrint"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ A list of WatermarkSet that came from the server for the"},{"entry":"\u2003\u2003\/\/ \u201ccurrent\u201d document"},{"entry":"\u2003\u2003list<WatermarkSet> m_wmarks;"},{"entry":"\u2003\u2003\/\/ The current state of the document (contains the file name,"},{"entry":"\u2003\u2003\/\/ path, document properties)."},{"entry":"\u2003\u2003ASOActiveDocumentState *m_state;"},{"entry":"\u2003\u2003\/\/ Reference to the current document. In this embodiment, the"},{"entry":"\u2003\u2003\/\/ current document is represented using a COM IDispatchPtr"},{"entry":"\u2003\u2003\/\/ (this is how Office documents are represented)."},{"entry":"\u2003\u2003IDispatchPtr m_theDoc;"},{"entry":"\u2003\u2003\/\/ The total number of pages in the document."},{"entry":"\u2003\u2003int m_pageCount;"},{"entry":"\u2003\u2003\/\/ Constructor for ASOWatermarkPrint data structure (initializes"},{"entry":"\u2003\u2003\/\/ fields to their default values)."},{"entry":"\u2003\u2003ASOWatermarkPrint( );"},{"entry":"\u2003\u2003\/\/ Destructor for ASOWatermarkPrint data structure (destroys"},{"entry":"\u2003\u2003\/\/ allocated memory)."},{"entry":"\u2003\u2003~ASOWatermarkPrint( );"},{"entry":"\u2003\u2003\/\/ Applies the watermark to the specified device context"},{"entry":"\u2003\u2003\/\/ (HDC means \u201chandle to device context\u201d). The caller"},{"entry":"\u2003\u2003\/\/ specifies which type of watermarks should be drawn"},{"entry":"\u2003\u2003\/\/ (\u201coverlay\u201d or \u201cunderlay\u201d) through the \u201clayer\u201d parameter."},{"entry":"\u2003\u2003Apply(HDC dc, WatermarkItem::Layer layer);"},{"entry":"\u2003\u2003\/\/ Increments the page number."},{"entry":"\u2003\u2003IncrPageNum(void);"},{"entry":"\u2003\u2003\/\/ Retrieves the current page number."},{"entry":"\u2003\u2003int PageNum(void);"},{"entry":"\u2003\u2003\/\/ Registers the device context for printing (called from"},{"entry":"\u2003\u2003\/\/ the StartDoc wrapper). This creates a new ASOWatermarkPrint"},{"entry":"\u2003\u2003\/\/ object that can be retrieved using the Lookup method."},{"entry":"\u2003\u2003static Register(HDC dc, ASOActiveDocumentState *info,"},{"entry":"\u2003\u2003IDispatchPtr doc);"},{"entry":"\u2003\u2003\/\/ Unregisters the device context for printing (called from"},{"entry":"\u2003\u2003\/\/ the EndDoc wrapper)."},{"entry":"\u2003\u2003static Unregister(HDC dc);"},{"entry":"\u2003\u2003\/\/ Locates the ASOWatermarkPrint associated with the specified"},{"entry":"\u2003\u2003\/\/ device context."},{"entry":"\u2003\u2003static ASOWatermarkPrint* Lookup(HDC dc);"},{"entry":"};"},{"entry":"\/\/ The map data structure that holds the HDC to ASOWatermarkPrint"},{"entry":"\/\/ mapping. New ASOWatermarkPrint objects are added to this"},{"entry":"\/\/ mapping through calls to ASOWatermarkPrint::Register. Objects are"},{"entry":"\/\/ removed from this mapping through calls to"},{"entry":"ASOWatermarkPrint::Unregister."},{"entry":"map<HDC, ASOWatermarkPrint> g_wmarkPrints;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ASOActiveDocumentState *info = ..."]},{"entry":[{},"\u2003."]},{"entry":[{},"\u2003."]},{"entry":[{},"\u2003."]},{"entry":[{},"if (bAllowPrint && dc != 0)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003ASOWatermarkPrint::Register(dc, info, docPtr);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The hook for this routine calls the original StartPage( ) routine and then looks up the ASOWatermarkPrint object using the HDC. If there is an ASOWatermarkPrint object registered for the HDC, the page count is incremented. If the watermark type is underlay and the page count is in range, the watermark is applied.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ASOWatermarkPrint *wmark;"]},{"entry":[{},"\/\/ Call the OS StartPage function first."]},{"entry":[{},"retVal = s_pfnStartPage(dc);"]},{"entry":[{},"\/\/ Find the ASOWatermarkPrint object that applies (if any)."]},{"entry":[{},"\/\/ This would have been registered in StartDoc."]},{"entry":[{},"wmark = ASOWatermarkPrint::Lookup(dc);"]},{"entry":[{},"if (wmark != 0)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/ Increment the page number so the rendering will"]},{"entry":[{},"\u2003\/\/ contain the correct page number."]},{"entry":[{},"\u2003wmark->IncrPageNum( );"]},{"entry":[{},"\u2003\/\/ Draw any underlay watermarks to the print device."]},{"entry":[{},"\u2003wmark->Apply(dc, WatermarkItem::Underlay);"]},{"entry":[{},"}"]},{"entry":[{},"return retVal;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The hook for this routine looks up the ASOWatermarkPrint object using the HDC. If there is an ASOWatermarkPrint object registered for the HDC, the watermark type is overlay and the page count is in range, the watermark is applied. Regardless of the state of watermarking, the original EndPage( ) routine will be called.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ASOWatermarkPrint *wmark;"]},{"entry":[{},"\/\/ Find the ASOWatermarkPrint object that applies (if any)."]},{"entry":[{},"\/\/ This would have been registered in StartDoc."]},{"entry":[{},"wmark = ASOWatermarkPrint::Lookup(dc);"]},{"entry":[{},"if (wmark != 0)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\/\/ Draw any overlay watermarks to the print device."]},{"entry":[{},"\u2003\u2003wmark->Apply(dc, WatermarkItem::Overlay);"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ Call the OS EndPage function now that we're done writing"]},{"entry":[{},"\/\/ the overlay watermark."]},{"entry":[{},"retVal = s_pfnEndPage(dc);"]},{"entry":[{},"return retVal;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The hook for this routine looks up the ASOWatermarkPrint object using the HDC. If there is an ASOWatermarkPrint object registered for the HDC, the ASOWatermarkPrint object is unregistered, freeing all resources associated with it.",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Unregister the ASOWatermarkPrint that was registered in StartDoc."]},{"entry":[{},"ASOWatermarkPrint::Unregister(dc);"]},{"entry":[{},"\/\/ Call the OS EndDoc function."]},{"entry":[{},"retVal = s_pfnEndDoc(dc);"]},{"entry":[{},"return retVal;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This routine iterates over all WatermarkSet objects to get all WatermarkItems. For each WatermarkItem whose underlay value matches that specified, its text is formatted and emitted via the HDC. The following code illustrates the mechanism.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2002list<WatermarkSet>::iterator i;"},{"entry":"\/\/ Step through each Watermark that applies (they can come from"},{"entry":"\/\/ multiple places, so many may apply)."},{"entry":"for (i = m_state->w_marks.begin( ); i != m_state->m_wmarks.end( );"},{"entry":"i++)"},{"entry":"{"},{"entry":"\u2003\/\/ Each Watermark is made up of 1 or more WatermarkItem objects."},{"entry":"\u2003\/\/ Step through each one of these WatermarkItem objects and"},{"entry":"\u2003\/\/ draw them."},{"entry":"\u2003list<WatermarkItem>::iterator item;"},{"entry":"\u2003for (item = i->GetItems( ).begin( ); item != i->GetItems( ).end( );"},{"entry":"\u2003item++)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/ If the page is within the range specified in the WatermarkItem"},{"entry":"\u2003\u2003\/\/ and the layer (overlay or underlay) specified in the"},{"entry":"\u2003\u2003\/\/ WatermarkItem matches the value specified by the caller then"},{"entry":"\u2003\u2003\/\/ we will draw the watermark. If either of those conditions"},{"entry":"\u2003\u2003\/\/ is false, then the WatermarkItem object will be skipped."},{"entry":"\u2003\u2003if (item->PageInRange(m_pageCount) &&"},{"entry":"\u2003\u2003item->getLayer( ) == layer)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003int colorVal = 255 * item->getColor( ) \/ 100;"},{"entry":"\u2003\u2003\u2003COLORREF textColor = RGB(colorVal, colorVal, colorVal);"},{"entry":"\u2003\u2003\u2003int angle;"},{"entry":"\u2003\u2003\u2003int fontHeight;"},{"entry":"\u2003\u2003\u2003string itemText;"},{"entry":"\u2003\u2003\u2003bool fmtGood;"},{"entry":"\u2003\u2003\u2003string fileName;"},{"entry":"\u2003\u2003\u2003string filePath;"},{"entry":"\u2003\u2003\u2003int minX;"},{"entry":"\u2003\u2003\u2003int minY;"},{"entry":"\u2003\u2003\u2003int maxX;"},{"entry":"\u2003\u2003\u2003int maxY;"},{"entry":"\u2003\u2003\u2003int txtWid;"},{"entry":"\u2003\u2003\u2003int txtHgt;"},{"entry":"\u2003\u2003\u2003\/\/ Get the file name from the document (this might be"},{"entry":"\u2003\u2003\u2003\/\/ needed when rendering the watermark)."},{"entry":"\u2003\u2003\u2003fileName = getFileNameFromDoc(m_doc);"},{"entry":"\u2003\u2003\u2003\/\/ Get the file path from the document (this might be"},{"entry":"\u2003\u2003\u2003\/\/ needed when rendering the watermark)."},{"entry":"\u2003\u2003\u2003filePath = getFilePathFromDoc(m_doc);"},{"entry":"\u2003\u2003\u2003\/\/ Format the text to be displayed (store result in \u201citemText\u201d)"},{"entry":"\u2003\u2003\u2003item->formatText(\u22121, m_pageCount, getDocProperty,"},{"entry":"\u2003\u2003\u2003\u2003this, fileName, filePath, itemText);"},{"entry":"\u2003\u2003\u2003\/\/ Determine the angle to use when creating the font. The angle"},{"entry":"\u2003\u2003\u2003\/\/ to use depends on the positioning specified in"},{"entry":"\u2003\u2003\u2003the WatermarkItem."},{"entry":"\u2003\u2003\u2003if (item->getPosition( ) == WatermarkItem::DiagTopLeft)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003angle = 3150;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else if (item->getPosition( ) == WatermarkItem::DiagBottomLeft)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003angle = 450;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003angle = 0;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\/\/ Calculate the height of the font (specified in the"},{"entry":"\u2003\u2003\u2003\/\/ WatermarkItem)."},{"entry":"\u2003\u2003\u2003fontHeight = pointSizeToLogical(dc, item->getSize( ));"},{"entry":"\u2003\u2003\u2003\/\/ Create the font, pen and brush objects needed to render"},{"entry":"\u2003\u2003\u2003\/\/ the text."},{"entry":"\u2003\u2003\u2003font = CreateFont(fontHeight, 0, angle, angle, ...);"},{"entry":"\u2003\u2003\u2003pen = CreatePen(PS_SOLID, penWidth, textColor);"},{"entry":"\u2003\u2003\u2003brush = CreateSolidBrush(textColor);"},{"entry":"\u2003\u2003\u2003\/\/ Select the font, pen and brush into the context so they're"},{"entry":"\u2003\u2003\u2003\/\/ used by TextOut below."},{"entry":"\u2003\u2003\u2003oldFont = SelectObject(dc, font);"},{"entry":"\u2003\u2003\u2003oldPen = SelectObject(dc, pen);"},{"entry":"\u2003\u2003\u2003oldBrush = SelectObject(dc, brush);"},{"entry":"\u2003\u2003\u2003\/\/ Set the background mode to be \u201ctransparent\u201d so the bounding"},{"entry":"\u2003\u2003\u2003\/\/ box of the watermark text will be invisible"},{"entry":"\u2003\u2003\u2003\/\/ content won't get occluded by the watermark text."},{"entry":"\u2003\u2003\u2003oldBackgroundMode = SetBkMode(dc, TRANSPARENT);"},{"entry":"\u2003\u2003\u2003\/\/ Determine the size of the bounding box."},{"entry":"\u2003\u2003\u2003BeginPath(dc);"},{"entry":"\u2003\u2003\u2003status = TextOut(dc, 0, 0, itemText.c_str( ), itemText.size( ));"},{"entry":"\u2003\u2003\u2003EndPath(dc);"},{"entry":"\u2003\u2003\u2003textRegion = PathToRegion(dc);"},{"entry":"\u2003\u2003\u2003GetRgnBox(textRegion, &textRect);"},{"entry":"\u2003\u2003\u2003txtWid = textRect.right \u2212 textRect.left;"},{"entry":"\u2003\u2003\u2003txtHgt = textRect.bottom \u2212 textRect.top;"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Emit the watermark"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003if (angle == 0)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Observe justification and don't tile."},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003if (item->getPosition( ) == WatermarkItem::Top)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003minY = i->getTopMargin( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003minY = pageHeight \u2212 i->getBottomMargin( ) \u2212 txtHgt;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if (item->getJustification( ) == WatermarkItem::Left)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003minX = i->getLeftMargin( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003minX = pageWidth \u2212 i->getRightMargin( ) \u2212 txtWid;"},{"entry":"\u2003\u2003\u2003\u2003if (item->getJustification( ) == WatermarkItem::Center)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003minX \/= 2;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003BeginPath(dc);"},{"entry":"\u2003\u2003\u2003status = TextOut(dc, minX, minY, itemText.c_str( ),"},{"entry":"\u2003\u2003\u2003itemText.size( ));"},{"entry":"\u2003\u2003\u2003EndPath(dc);"},{"entry":"\u2003\u2003\u2003if (item->getTextType( ) == WatermarkItem::Outline)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003StrokePath(dc);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003StrokeAndFillPath(dc);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/ Tile and ignore justification."},{"entry":"\u2003\u2003\u2003minX = i->getLeftMargin( );"},{"entry":"\u2003\u2003\u2003maxX = pageWidth \u2212 i->getRightMargin( );"},{"entry":"\u2003\u2003\u2003minY = i->getTopMargin( );"},{"entry":"\u2003\u2003\u2003maxY = pageHeight \u2212 i->getBottomMargin( );"},{"entry":"\u2003\u2003\u2003for (eks = minX; eks < maxX; eks += (textRect.right \u2212"},{"entry":"\u2003\u2003\u2003textRect.left))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003for (why = minY; why < maxY; why += (textRect.bottom \u2212"},{"entry":"\u2003\u2003\u2003\u2003textRect.top))"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003BeginPath(dc);"},{"entry":"\u2003\u2003\u2003\u2003\u2003status = TextOut(dc, eks, why, itemText.c_str( ),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003itemText.size( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003EndPath(dc);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (item->getTextType( ) == WatermarkItem::Outline)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003StrokePath(dc);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003StrokeAndFillPath(dc);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"While the above describes a particular order of operations performed by certain embodiments of the invention, it should be understood that such order is exemplary, as alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic.","While the present invention has been described in the context of a method or process, the present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including an optical disk, a CD-ROM, and a magnetic-optical disk, a read-only memory (ROM), a random access memory (RAM), a magnetic or optical card, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. As has been described, a given implementation of the present invention is software written in a given programming language that runs on a server on a standard Intel hardware platform running an operating system such as Microsoft Windows.","While given components of the system have been described separately, one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions, program sequences, code portions, and the like.","As noted above, in many circumstances it will be desirable to have a watermark definition securely provided to the end user client machine and maintained (preferably in-memory only) prior to a given rendering operation. In particular, where the watermarking process is ancillary to or used in conjunction with an enterprise rights management system, it is useful to have the watermark definition provided substantially concurrently with the providing (usually to an application plug-in) of a decryption key and policy associated with a protected document that will be watermarked. Indeed, if the watermarking server or server process is co-located with or part of an ERM policy server, the watermark definition can be provided to the calling application together with the decryption key and policy over the same secure link. In this embodiment, the wrapper and rendering code may be part of the application plug-in that enables access to and use of the protected document. As used herein, a \u201cprotected document\u201d should be broadly construed to cover any \u201cobject\u201d (e.g., a Word document, an Excel spreadsheet, an email, a PowerPoint presentation, an email attachment, a PDF document, or any other, irrespective of format). Also, a \u201cdocument\u201d may refer to a given portion thereof.","Stated another way, according to the invention, the watermark definition may be retrieved from the server either before or after a given device context (to render a given document) is initiated by a calling application.","Also, the invention may be implemented irrespective of whether the end user client machine has a dedicated graphics device interface (such as Microsoft Windows GDI); rather, the wrapper code may hook into any convenient interface or API across which one or more rendering function calls to the operating system are carried out.","Having described our invention, what we now claim is as follows."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
