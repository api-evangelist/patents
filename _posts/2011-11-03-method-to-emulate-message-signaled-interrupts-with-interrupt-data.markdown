---
title: Method to emulate message signaled interrupts with interrupt data
abstract: Methods to emulate a message signaled interrupt (MSI) with interrupt data are described herein. An embodiment of the invention includes a memory decoder to monitor a predetermined memory block allocated to a device, an interrupt controller to receive an emulated messaged signaled interrupt (MSI) signal from the memory decoder in response to a posted write transaction to the predetermined memory block initiated from the device, and an execution unit to execute an interrupt service routine (ISR) associated with the device to service the MSI using interrupt data retrieved from the predetermined memory block, without having to obtain the interrupt data from the device via an input output (IO) transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08996760&OS=08996760&RS=08996760
owner: Intel Corporation
number: 08996760
owner_city: Santa Clara
owner_country: US
publication_date: 20111103
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This patent application is a U.S. National Phase Application under 35 U.S.C. \u00a7371 of International Application No. PCT\/US2011\/059179, filed Nov. 3, 2011, entitled METHOD TO EMULATE MESSAGE SIGNALED INTERRUPTS WITH INTERRUPT DATA.","Embodiments of the present invention relate generally to data processing systems. More particularly, embodiments of the invention relate to emulating message signaled interrupts.","Message signaled interrupts (MSI) are a feature that enables a device function to request service by writing a system-specified data value to a system-specified address using, for example, a memory write transaction. An MSI transaction enables a device function to request an interrupt service by sending the MSI transaction as an inbound memory write on its bus to the front-side bus (FSB) or the processor bus. Because an MSI transaction is generated in the form of a memory write, MSI transactions support transaction conditions such as a retry, master-abort, target-abort or normal completion. As added benefits, MSI transactions simplify board design by removing out of band interrupt routing and represent another step towards a legacy-free environment.","Message signaled interrupts allow a device to write a small amount of data to a special address in memory space. The chipset will deliver the corresponding interrupt to a processor (also referred to as a central processing unit or CPU). A common misconception with message signaled interrupts is that they allow the device to send data to the CPU as part of the interrupt. The data that is sent as part of the write is used by the chipset to determine which interrupt to trigger on which CPU; it is not available for the device to communicate additional information to the interrupt handler.","A drawback of MSI transactions is the latency involved with servicing an interrupt. For example, when a device requests an interrupt service using MSI, the device generates a MSI transaction including a system-specified message and a system-specified address. Once a processor receives the MSI transaction, the processor has to communicate with the requesting device to retrieve data required to service the interrupt. The processor may then service the interrupt using interrupt data received from the device. However, the latency involved with communications with the device may be relatively long. As a result, each interrupt serviced via a MSI transaction involves a long latency and adds traffic to, for example, the FSB, the memory controller hub (MCH), and\/or, the input-output controller hub (ICH) coupling the device to the processor.","Various embodiments and aspects of the inventions will be described with reference to details discussed below, and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However, in certain instances, well-known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification do not necessarily all refer to the same embodiment.","According to some embodiments, a mechanism is provided to allow a device to request an MSI interrupt by sending interrupt data or messages, including an interrupt vector, to processor directly to emulate an MSI interrupt, without having to send an actual MSI interrupt request to a system defined address for MSI. The interrupt data is not limited to the format or size required by a conventional MSI request. As a result, a device can send to the processor more data in a variety of formats than a regular MSI request would allow. Decoder logic associated with the processor or a chipset is configured to monitor and detect the emulated MSI request and to invoke an interrupt controller to issue an MSI interrupt based on the interrupt data.","According to one embodiment, for each device that is capable of handling MSI interrupts, a specific block of memory is allocated for the device. Such a block of memory may be allocated from a processor cache (e.g., processor level-2 (L2) or level-3 (L3) cache) or from a specific memory region of a system memory coupled to the processor. Each device is able to directly access its associated block of memory, for example, via a posted write transaction (e.g., using direct cache or memory access techniques). The size of a memory block associated with a device may vary dependent upon the specific configuration or needs, which may be configurable during an initialization of the system or device.","According to one embodiment, when a device is about to assert an MSI, instead of sending a regular MSI request message to a system defined address for MSI, the device is configured to send and store all the necessary data (also referred to herein as interrupt data) to be utilized during the interrupt service to the associated memory block via a posted write transaction. The interrupt data also includes an interrupt vector associated with an interrupt service routine (ISR) of the device. In response to the posted write transaction, decoder logic is configured to invoke an interrupt controller, such as an advanced programmable interrupt controller (APIC), to retrieve the interrupt vector from the memory block. In one embodiment, an MSI interrupt is directly sent to processor and the interrupt vector of the MSI is intercepted by processor APIC. The decoder logic may assert a signal (e.g. toggling an internal data signaling line) to processor APIC to inform processor APIC of a pending emulated MSI interrupt. In one embodiment, the decoder logic is configured to: 1) obtain the interrupt vector from memory block and send the interrupt vector to processor APIC; and\/or 2) pass the memory block address to processor APIC and processor APIC then fetches the interrupt vector from the memory block based on the received memory block address.","When the processor invokes an interrupt service routine (ISR) associated with the interrupt vector of a device, the processor can access the memory block specifically allocated to the device to retrieve the interrupt data and service the interrupt using the interrupt data without having to obtain the same data from the device via one or more IO transactions, which may take a relatively long period of time.","According to a further embodiment, the interrupt data to be stored in the memory block may include multiple interrupt vectors, each being associated with an ISR or an entry point of an ISR. In response to detection of a posted write transaction to the memory block, decoder logic is configured to retrieve the interrupt vectors from the memory block. For each of the interrupt vectors, the decoder logic is configured to invoke the interrupt controller to access the interrupt vector from the memory block and invoke a processor or a processor core to execute an ISR associated with the interrupt vector. Such interrupt vectors may be associated with ISR routines that service multiple functions of a device or multiple devices. As a result, a single posted write transaction can request multiple MSI interrupts, including all the necessary interrupt data to be utilized during the associated interrupt services, without having to individually requesting multiple MSI interrupts to the system defined address for MSI.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 1","FIG. 1"],"b":["100","101","102","106","102","103","104","107","101","101","110","101","103","104","105","101","108","103","104","111","109","101","108","111","102","106","107"]},"According to one embodiment, when a device such as device  or device  is about to assert an MSI, the device is configured to store interrupt data  to be utilized during the interrupt service to the associated block of cache  via a posted write transaction. Interrupt data  further includes an interrupt vector representing an entry point of an ISR associated with the device. Decoder logic  is configured to monitor and detect any posted write transaction to the allocated cache lines for the purpose of detecting emulated MSI interrupts initiated from devices -. In some embodiments, decoder logic  may also reside in chipset  and coupled to MCH  for detecting writes to memory . In response to detection of such posted write transaction, decoder logic  retrieves or causes interrupt controller  to retrieve an interrupt vector from the allocated cache lines. Interrupt controller  then invoke processor  to service the interrupt associated with the interrupt vector. When processor  invokes an interrupt service routine (ISR) associated with the device based on the interrupt vector, processor  can access interrupt data  from the allocated cache lines associated with the device and service the interrupt using the interrupt data, without having to obtain the same interrupt data from the device via one or more IO transactions.","One of the reasons for specific cache lines to be allocated is to prevent interrupt data written to these allocated cache lines from being automatically replaced by the cache line replacement algorithm (e.g. least recently used (LRU) cache line replacement policy). For example, device  pushes interrupt data into cache line  to request an MSI interrupt. Processor  branches to device 's ISR  and executes the ISR's callback function. When processor  services the interrupt (assuming that processor core 1 is servicing the interrupt), a second process from another processing core (core 2) accesses data from system memory  and encounters a cache miss, which causes the interrupt data contents of cache line  to be automatically replaced by data in system memory . This will cause ISR  to access the no longer valid interrupt data from cache line  and compromise the whole system. In addition, preallocating cache lines also prevents decoder logic  from erroneously invoking processor to service an interrupt when a write to the allocated cache line is triggered by an automatic cache line data replacement event instead of an actual emulated MSI interrupt posted write transaction to the allocated cache line from a device. In one embodiment, the allocated cache line is allocated by marking it unavailable for automatic replacement and it is allocated to a device (e.g. device ) by writing its cache line or memory address into device 's interrupt data register , such that device  is the only device that can write to that cache line.","Note that the configuration as shown in  is described for the purpose of illustration only. The memory blocks allocated to store interrupt data  for devices - can also be allocated from other memories such as system memory  and accessible by processor  via MCH . Also note that MCH  may be integrated with chipset , where chipset  further includes input output controller hub (ICH)  to control IO devices such as devices -, as shown in .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 1","FIG. 2","FIG. 3"],"b":["300","100","200","300","105","101","301","302","303","103","104","301","301","103","104","302","303"]},"When a device (e.g., device ) wishes to request an MSI interrupt, the device is configured to issue a posted write transaction to a system defined address for MSI, including an interrupt vector representing an entry point of the associated ISR. The MSI request causes an interrupt controller to invoke processor  to call back the ISR (e.g., ISR ) to service the interrupt. Conventionally, when the ISR is invoked, the processor has to access the corresponding device to retrieve the necessary interrupt data such as data of one or more registers (e.g., control and status register or CSR) of the device via one or more IO transactions, which may consume a relatively long period of time).","According to one embodiment, for each of devices -, a dedicated block of memory is allocated to store interrupt data to be utilized by the corresponding ISR when an MSI interrupt is serviced by processor , where the interrupt data includes an interrupt vector associated with an MSI to be serviced. The memory block can be allocated from processor cache  or alternatively from a specific region of the system memory such as memory . Such memory blocks can be allocated during an initialization of system  (e.g., boot) or during initialization of device drivers -. Alternatively, a memory block may be dynamically allocated when a device is connected with the system (e.g., detected by a plug-and-play manager).","For example, according to one embodiment, during initial enumeration of devices, the system firmware such as a basic input output system (BIOS), a boot loader or a low level OS initialization component can allocate and assign a block of memory to each device. For example, the system may directly configure or write a particular cache line address and\/or size, or memory address and\/or size associated with the corresponding memory block of each device in a predetermined register of the device (e.g., registers -). The system may allocate a fixed size memory block for each device such as memory blocks -. For example, during system initialization, the system may allocate and write a memory address and\/or size of the allocated block to a predetermined register such as interrupt data registers - of devices -, respectively. Subsequently, when device drivers - are loaded and initialized by OS , each of devices - can retrieve the cache line address or memory address from its interrupt data register (e.g., registers -) and directly access the associated memory block (e.g., memory blocks -) for the purpose of storing the interrupt data, for example, via a direct cache access (DCA) or direct memory access (DMA) method when it wants to send an MSI interrupt to processor . Similarly, during system initialization, OS  may also write the same memory address and\/or size of the allocated memory block previously allocated to device - to a device driver - interrupt data parameter (e.g., interrupt data address\/size -) for the purpose of accessing device interrupt data from the same memory block during ISR interrupt service processing.","In a particular embodiment, during initialization, OS  allocates a cache line (e.g., cache lines -) and writes the memory addresses to both the device driver interrupt data register (e.g., registers -) and also a device driver interrupt data parameter (e.g. interrupt data address\/size -). For the purpose of illustration, when device  wishes to interrupt processor . Device  proactively sends its interrupt data including an interrupt vector as a posted write transaction into cache line  via DCA using the memory address previously stored in its interrupt data register , which may be detected by decoder logic . In response to the detection, decoder logic  transmits an emulated MSI signal to an interrupt controller . In response to the emulated MSI signal, interrupt controller  is configured to access the interrupt vector from cache line  and trigger processor  to branch to device driver's ISR  associated with the interrupt vector. When ISR  is invoked, processor  obtains device 's interrupt data using the cache line address pointed to by device driver interrupt data parameter  and uses the interrupt data to process the interrupt. Storing the same cache line or memory address to both device data register  and an interrupt data parameter  inside device driver  during initialization enables device  and processor  executing device driver  (e.g., two separate entities) to know where to send and retrieve interrupt data (including interrupt vector(s)) without having to query each other.","Alternatively, according to another embodiment, when a device driver is loaded and initialized by OS , the device is configured to communicate with OS  or the BIOS to request a block of memory (from processor cache or system memory) with a particular size. For example, a device driver can call a specific application programming interface (API) to BIOS or OS  to negotiate a block of memory either from processor cache  or system memory . In return, the system allocates and provides a starting memory address and\/or size to the device driver, which may be maintained (in memory ) by the device driver throughout the life of the device driver or alternatively, it can be written in a register of the device (e.g., interrupt data registers -). As a result, each device driver has the capability of negotiating various sizes of memory blocks for storing interrupt data, which is not limited to traditional MSI request messages.","For the purpose of illustration only, it is assumed that device driver  is configured to control and operate device  and memory block  has been allocated to device  for storing interrupt data. When an interrupt event of device  occurs, device  is configured to store the associated interrupt data to memory block . Note that an interrupt requester of a driver is invoked only once during device configuration to reserve (request for) an MSI interrupt, which may include setting up the interrupt vector and linking it to the interrupt service routine callback function of the device and reserving a memory block for storing interrupt data. The device is the one that contains additional logic, firmware or software to proactively push its interrupt data including its own CSR values, filled DMA buffer addresses, device messages, tags and other information to processor cache or memory when it wishes to send an MSI interrupt to processor. When this is done, device driver 's interrupt service routine no longer needs to poll the device for its interrupt data using multiple IO transactions. For example, when device  wishes to assert an MSI interrupt to processor , interrupt request logic , which may be implemented as a DCA\/DMA logic or firmware, proactively pushes interrupt data of device  (e.g. CSR , DMA filled buffer addresses, interrupt messages, tags, etc.) into memory block  as a posted write transaction. The interrupt data further includes one or more interrupt vectors associated with the interrupt.","Once the interrupt data has been stored in memory block , decoder logic  detects such a transaction as decoder logic  constantly or periodically monitors the activities at the cache lines allocated to devices -. In response to the detection, decoder logic  is configured to transmit an emulated MSI request signal to interrupt controller . In response to the emulated MSI request, interrupt controller  causes processor  to branch to its interrupt handler and calls ISR  of device driver . In this embodiment, decoder logic  may retrieve the interrupt vector from interrupt data  and hands the interrupt vector to interrupt controller . Alternatively, decoder logic  informs interrupt controller  an MSI interrupt request signal and a particular cache line to retrieve the interrupt vector for the MSI interrupt request, and interrupt controller  then retrieve the interrupt vector from the cache line to trigger processor  to branch to ISR  which is associated with the interrupt vector.","When ISR  is invoked, processor  is configured to access memory block  to retrieve the interrupt data stored therein based on the memory address associated with the allocated memory block and to service the MSI interrupt using the retrieved interrupt data without having to access device  via one or more IO transactions. In this way, an embodiment of the invention provides an alternatively way to trigger an MSI interrupt without having the device to request an MSI interrupt by writing to a system defined address according to an MSI specification. In addition, an amount of interrupt data to be pushed to cache  is not limited to those defined in MSI messages. A device can push as much as information as part of interrupt data as it wants, as long as the device can negotiate enough space of cache  to store the same. Thus, a single posted write transaction to a predetermined memory block allocated can allow a device to request an MSI interrupt for the device, as well as push all the necessary interrupt data utilized during the corresponding interrupt service that would normally not fit in a conventional MSI request.","Note that the interrupt controller (e.g. processor APIC\u2014Advanced Programmable Interrupt Controller) processes the interrupt vector associated with the MSI interrupt and causes processor  to branch to its interrupt handler. The interrupt handler will invoke ISR . Each device's MSI interrupt data includes a unique interrupt vector that is mapped to the device ISR. When decoder logic  detects that a posted write transaction is to certain cache lines allocated to a device, it passes the posted write transaction data (e.g., the interrupt vector) to the processor APIC. The processor APIC uses the interrupt vector to locate the interrupt handler which may reside in some specified memory address. The interrupt handler then invokes the device driver's ISR  callback function to service the interrupt. In this embodiment, ISR  obtains its interrupt data from memory  without having to poll device  using multiple IO transactions.","According to one embodiment, when device  wishes to request an MSI interrupt, interrupt request logic  of device  is configured to issue a posted write transaction to a preconfigured memory address corresponding to memory block  to a bus (e.g., IO bus and\/or FSB) with all the necessary interrupt data included therein, including an interrupt vector. The memory address may be retrieved from interrupt data register  and also maintained by device driver . Once the interrupt data has been stored in memory block  and detected by decoder logic , decoder logic  is configured to transmit an emulated MSI request signal to an interrupt controller that may reside within processor  or within a chipset . The interrupt controller causes processor  to branch to ISR . While executing ISR , processor  is configured to access memory block  to retrieve interrupt data such as CSR information corresponding to CSR register , device specific messages, and other information as needed. Based on the information, processor  can determine the type of interrupt services requested by device , the state of device , and\/or the statues of device ; and service the requested interrupt using the retrieved interrupt data accordingly. After servicing the interrupt, processor  may update certain registers of device  via one or more IO or memory mapped IO transactions, notifying device  that the interrupt has been serviced. According to one embodiment, there may be multiple preconfigured memory addresses for intercepting emulated MSI interrupts. For example, a first device may write to a first memory address such as 0xA and a second device may write to a second memory address such as 0xB when any one of the first and second devices wants to issue an emulated MSI interrupt with interrupt data to processor.","Dependent upon the size of an allocated memory block, according to one embodiment, interrupt data can include a variety of information that can be utilized by ISR  when servicing the MSI interrupt. For example, as shown in , interrupt data  may include, but is not limited to, interrupt vector , service request symbol or tag , CSR register value , direct memory access (DMA) addresses , device specific messages , device power state information , device thermal data and thermal control information , and other data . Service request symbol or tag  may be utilized by an ISR to determine the type of service or function should be performed during the interrupt service (e.g., a filled DMA buffer to be processed; an error condition occurred and error recovery is needed; data available to be processed; or device ready to receive data, etc). Service request symbol or tag  may be internally defined by a device logic developer and\/or device software developer specifically tailored to the device's needs. CSR register values  may be retrieved from one or more CSR register of the device and posted via the posted write transaction to memory block . Note that information - is shown for the purpose of illustration only; more or less of information - may be included dependent upon the specific configuration.","For example, interrupt data  may further include any device register values, first-in-first-out (FIFO) entries, queue entries, or any other device information can may otherwise be obtained using one or more IO transactions to query device registers during an ISR callback (after MSI interrupt has been received and processor execution has entered the ISR). Device power state information  may allow the device to proactively interrupt processor in response to a change in its power state or in response to a power state transition event. Device thermal data and thermal control information  may allow the device to proactively interrupt processor in response to a thermal event such as overheating or the need to turn on\/turn off a fan or a cooling system. Other data information  may include some relatively \u201csmall size\u201d interrupt data, such as keystrokes and\/or coordinates information from a user input device such as a mouse, touchpad or keyboard, etc.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 5"],"b":["500","100","200","501","502","503","504","505"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6","FIG. 3","FIG. 6","FIG. 4","FIG. 3","FIG. 3"],"b":["600","601","602","400","604","601","602","317","318","603","604","306","307"]},"It can be seen that embodiments of the invention enable a device to proactively push certain information such as its CSR register values and other data into processor's cache or certain regions of the system memory when interrupting the processor for service using a single coalesced bus write transaction. The processor can have fast access to information it needs to service the interrupt and does not have to poll a register of the device via an IO transaction which can be inefficient and time consuming. It can also be seen that devices may selectively push only subsets of information needed by the processor to service the interrupt, for example, as shown in . It will be appreciated that a device designer may choose to use conventional methods of servicing an MSI interrupt, an improved MSI method as described above, or a combination of both methods. The choices of MSI processing methods may be selected dependent upon the complexity of the devices and\/or the bandwidth or processing power available at the point in time (e.g., whether it is more efficient to \u201cpush\u201d instead of \u201cpoll\u201d under the circumstances). In one embodiment, multiple cache lines may be allocated to a device if the device needs additional space to store its interrupt data.","According to some embodiments, the interrupt data pushed by a device to the corresponding allocated memory block includes multiple interrupt vectors associated with multiple ISRs or multiple entry points of a single ISR associated with multiple devices or a single device. As a result, a single posted write transaction can request multiple MSI interrupts for one or more devices. For example, a device can request multiple MSI interrupts, one MSI interrupt for one of multiple functions associated with the device. Alternatively, an interrupt coalescing agent on the bus (e.g., a backbone bus) can intercept the MSI requests from multiple devices and combine multiple MSI interrupt requests of multiple devices and request multiple MSI interrupts via a single posted write transaction to a predetermined memory block other than the conventional MSI request address, including all the necessary interrupt data associated with the interrupt vectors. Devices that may want to perform interrupt coalescing may include network devices coupled to a common backbone bus or a device that processes multiple video streams. In response to a \u201ccombined\u201d MSI interrupt request, the interrupt controller can assign the processing of different interrupt vectors to different processors or different processor cores. Conventional interrupt mechanisms are only able to send one interrupt vector at a time to the processor.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 3","FIG. 7","FIG. 4","FIG. 4","FIG. 7"],"b":["700","312","314","700","701","702","704","700","400","400","702","704","702","704","400"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 8","FIG. 8"],"b":["800","100","200","801","802","803","804","805","806"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 9","FIGS. 1 and 2","FIG. 9"],"b":["900","100","200","900"]},"Referring to , in one embodiment, system  includes processor  and chipset  to couple various components to processor  including memory  and devices - via a bus or an interconnect . Processor  may represent a single processor or multiple processors with a single processor core or multiple processor cores  included therein. Processor  may represent one or more general-purpose processors such as a microprocessor, a central processing unit (CPU), or the like. More particularly, processor  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processor  may also be one or more special-purpose processors such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), a network processor, a graphics processor, or the like. For example, processor  may be a Pentium\u2122 4, Pentium\u2122 Dual-Core, Core\u2122 2 Duo and Quad, Xeon\u2122, Itanium\u2122, XScale\u2122 or StrongARM\u2122 microprocessor available from Intel Corporation of Santa Clara, Calif. Processor  is configured to execute instructions for performing the operations and steps discussed herein.","Chipset  may include memory control hub (MCH)  and input output control hub (ICH) . MCH  may include a memory controller (not shown) that communicates with a memory . MCH  may also include a graphics interface that communicates with graphics device . In one embodiment of the invention, the graphics interface may communicate with graphics device  via an accelerated graphics port (AGP), a peripheral component interconnect (PCI) express bus, or other types of interconnects. ICH  may provide an interface to I\/O devices such as devices -. Any of devices - may be a storage device (e.g., a hard drive, flash memory device), universal serial bus (USB) port(s), a keyboard, a mouse, parallel port(s), serial port(s), a printer, a network interface (wired or wireless), a wireless transceiver (e.g., WiFi, Bluetooth, or cellular transceiver), a media device (e.g., audio\/video codec or controller), a bus bridge (e.g., a PCI-PCI bridge), or other devices.","MCH  is sometimes referred to as a Northbridge and ICH  is sometimes referred to as a Southbridge, although some people make a technical distinction between them. As used herein, the terms MCH, ICH, Northbridge and Southbridge are intended to be interpreted broadly to cover various chips who functions include passing interrupt signals toward a processor. In some embodiments, MCH  may be integrated with processor . In such a configuration, chipset  operates as an interface chip performing some functions of MCH  and ICH , as shown in . Furthermore, graphics accelerator  may be integrated within MCH  or processor .","Memory  may store data including sequences of instructions that are executed by processor , or any other device. For example, executable code and\/or data of a variety of operating systems, device drivers, firmware (e.g., input output basic system or BIOS), and\/or applications can be loaded in memory  and executed by processor . An operating system can be any kind of operating systems, such as, for example, Windows\u00ae operating system from Microsoft\u00ae, Mac OS\u00ae\/iOS\u00ae from Apple, Android\u00ae from Google\u00ae, Linux\u00ae, Unix\u00ae, or other real-time operating systems. In one embodiment, memory  may include one or more volatile storage (or memory) devices such as random access memory (RAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), static RAM (SRAM), or other types of storage devices. Nonvolatile memory may also be utilized such as a hard disk or a flash storage device. Front side bus (FSB)  may be a multi-drop or point-to-point interconnect. The term FSB is intended to cover various types of interconnects to processor . Chipset  may communicate with other devices such as devices - via point-to-point interfaces.","Cache  may be any kind of processor cache, such as level-1 (L1) cache, L2 cache, L3 cache, L4 cache, last-level cache (LLC), or a combination thereof. Cache  may be shared with processor cores  of processor . Cache  may be embedded within processor  and\/or external to processor . Processor  may further include a direct cache access (DCA) logic to enable other devices such as devices - to directly access cache . Processor  and\/or chipset  may further include an interrupt controller to handle interrupts such as message signaled interrupts.","Processor  may further include one or more register files including, but are not limited to, integer registers, floating point registers, vector or extended registers, status registers, and an instruction pointer register, etc. The term \u201cregisters\u201d is used herein to refer to the on-board processor storage locations that are used as part of macro-instructions to identify operands. In other words, the registers referred to herein are those that are visible from the outside of the processor (from a programmer's perspective). However, the registers should not be limited in meaning to a particular type of circuit. Rather, a register need only be capable of storing and providing data, and performing the functions described herein. The registers described herein can be implemented by circuitry within a processor using any number of different techniques, such as dedicated physical registers, dynamically allocated physical registers using register renaming, combinations of dedicated and dynamically allocated physical registers, etc. In one embodiment, integer registers store 32-bit or 64-bit integer data. A register file may contain extended multimedia SIMD registers (e.g., XMM) for packed data. Such registers may include 128 bits wide XMM registers and 256 bits wide registers (which may incorporate the XMM registers in their low order bits) relating to SSE2, SSE3, SSE4, GSSE, and beyond (referred to generically as \u201cSSEx\u201d) technology to hold such packed data operands.","According to one embodiment, a portion of process cache  and\/or memory  is utilized to allocate a memory block for at least one of devices - to store interrupt data. When a device wishes to request an MSI interrupt, the device issues a posted write transaction to the memory block to store its interrupt data, including one or more interrupt vectors. Decoder logic  associated with processor  is configured to monitor the allocated memory block and in response to such detection, an interrupt controller is invoked to issue an emulated MSI interrupt with interrupt data based on the interrupt vector retrieved from the memory block. Thereafter, an ISR associated with the device is invoked to service the MSI interrupt using the interrupt data retrieved from the memory block, without having to communicate with the device via an IO transaction, as described above.","Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as those set forth in the claims below, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non-transitory computer readable medium. A machine-readable medium includes any mechanism for storing information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium (e.g., read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices).","The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware (e.g. circuitry, dedicated logic, etc.), software (e.g., embodied on a non-transitory computer readable medium), or a combination of both. Although the processes or methods are described above in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in a different order. Moreover, some operations may be performed in parallel rather than sequentially.","Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.","In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
