---
title: Testing subsystems on platforms for software applications
abstract: Techniques for testing subsystems on a platform for a software application are provided. A test application receives instructions for calling platform dependent subsystems directly. The instructions can be designed to fully test the capabilities of the subsystems. Once the instructions are executed, the results of the subsystems can be analyzed for platform certification, performance, reliability, and/or characteristics.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07831962&OS=07831962&RS=07831962
owner: Oracle International Corporation
number: 07831962
owner_city: Redwood Shores
owner_country: US
publication_date: 20030603
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present invention relates to testing of software applications. More specifically, the invention relates to testing subsystems of a platform for software applications.","Software applications are commonly designed to be executed on many different platforms. Each platform can have different operating systems, device drivers, file systems, cluster software and interconnects, storage hardware, software and host bus adaptors (HBAs), and the like. It is an extremely challenging task to test subsystems (or changes thereof) of a platform for a software application.","In order to illustrate why this task is so challenging,  shows a diagram of examples of the capability and tested areas for a platform. Capability space  represents all the capabilities of a platform. The capability space is quite large and is not generally tested by platform vendors. However, it is common for platform vendors to test certain areas, which are shown as platform vendor tested areas .","Application utility space  represents the capabilities of platform  that are utilized by a software application. As shown, application utility space  overlaps some platform vendor tested areas but is, for the most part, not tested by the platform vendors.","An instance area  represents the capabilities that are utilized by the application at a specific moment in time. As shown, this area is smaller than application utility space . As the application executes, instant utilization space  can shrink, grow and move around within application utilization space .","Currently, some software applications are tested to cover a test area . As shown, the test area covers what may be utilized by an application at one instance in time. However, test coverage  can be substantially less than application utility space . Therefore, a running application will often exceed the bounds of test area  utilizing untested capabilities so there is a risk of failure and error.","Testing tools exist (e.g., IOZONE) that allow users to do performance testing of subsystems (e.g., file systems). These tools typically produce comparative performance rates between various systems but do not provide debug information if something goes wrong. Moreover, these tools are not designed with an application in mind. Therefore, these tools are similar to the test performed by platform vendors in that they are generic and not designed for testing subsystems on a platform for a specific software application.","It would be beneficial to have innovative techniques for testing software applications subsystems on a platform for software applications. Additionally, it would be beneficial to test the full application utility space (and perhaps more).","The present invention provides innovative techniques for testing subsystems on a platform for software applications. In general, a test application calls platform (or hardware) dependent subsystems directly (e.g., not through a generic application interface). The testing application receives instructions to call the platform dependent systems, makes the calls, and analyzes the results. By calling the platform dependent subsystems directly, the subsystems can be tested more thoroughly than with conventional techniques and can be designed to test the actual application utility space. Additionally, testing, reproducing and identifying bugs or incompatibilities can be accomplished in a very short amount of time. Some specific embodiments of the invention are described below.","In one embodiment, the invention provides a method of testing subsystems of a platform for a software application. Instructions to call the platform dependent subsystems are received. Calls to the platform dependent subsystems are performed according to the instructions to test the subsystems. Results from the calls to the platform dependent subsystems are then analyzed. The platform dependent subsystems can be subsystems of the software application, operating subsystems, device driver subsystems, hardware subsystems, and the like.","In another embodiment, the invention provides a method of testing subsystems of a platform for a software application. A test application that is capable of performing calls directly to platform dependent subsystems. The test application receives instructions to call the platform dependent subsystems and performs calls to the subsystems according to the instructions to test the subsystems. Results from the calls to the platform dependent subsystems are then analyzed. In some embodiments, the instructions are stored in a file that may be readily changed for more accurate testing.","In another embodiment, the invention provides a method of testing the shared subsystems of a platform cluster. Such a cluster consists of a group of independent application platforms linked by a high performance interconnect that share a carefully defined set of subsystems. In this environment, the testing application receives instructions to call the shared subsystems and uses the high performance interconnect to perform calls on each application platform according to the instructions to test the shared subsystems. Results from the calls made by each independent application platform to the shared subsystems are then collected, collated, and analyzed using the high performance interconnect. As with some other embodiments, the instructions to perform these tests are stored in a file that may be readily changed for more accurate testing.","Other features and advantages of the invention will become readily available apparent upon review of the following description in association with the accompanying drawings, where the same or similar structures are designated with the same reference numerals.","In the description that follows, the present invention will be described in reference to embodiments that test subsystems on a platform for a software application, such as a database application. However, embodiments of the invention are not limited to any particular architecture, environment, application, or implementation. For example, although embodiments will be described in reference to database applications, the invention may be advantageously applied to any software application. Therefore, the description of the embodiments that follows is for purposes of illustration and not limitation.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1"],"b":["1","3","5","5"]},"By increasing the portions of application utility space  that are tested, a tested area  can be achieved where the full application utility space is tested. Additionally, the instructions can be designed to over stress the application for the platform such that a safety envelope  is achieved further insuring that the software application is fully tested for the platform.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["101","103","103","105"]},"A fixed storage  can store computer programs and data such that it is typically persistent and provides more storage when compared to memory . At present, a common fixed storage for databases is multiple (e.g., arrays) hard drives. A removable storage  provides mobility to computer programs and\/or data that are stored thereon. Examples of removable storage are floppy disks, tape, CD\/ROM, flash memory devices, and the like.","Memory , fixed storage  and removable storage  provide examples of computer readable storage media that can be utilized to store and retrieve computer programs incorporating computer codes that implement the invention, data for use with the invention, and the like. An input  allows a user to interface with the system. Input can be done through the use of a keyboard, a mouse, buttons, dials, or any other input mechanism. An output  allows the system to provide output to the user. Output can be provided through a monitor, display screen, LEDs, printer or any other output mechanism.","A network interface  allows the system to interface with a network to which it is connected. The system bus architecture of computer system  is represented by arrows . The components shown in  can be found in many computer systems. However, components can be added, deleted and combined. For example, fixed storage  could be a file server that is accessed through a network connection. Thus,  is for illustration purposes and not limitation.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 4"]},"A software application  is shown as the highest level in . Software application  represents a generic layer as the computer code is designed to operate on any platform. Layer  includes Application Programming Interfaces (APIs) of the software application that are specific to the operating system of the platform. Below that, a layer  represents system level software on the platform such as the operating system, device drivers, and the like. Hardware  represents hardware components of the system.","With a database application, it is common for users to enter structured query language (SQL) statements. Software application  interprets the SQL statements and performs the appropriate processing. Many statements result in calling APIs in layer , which in turn call APIs in layer , which in turn direct or access components in hardware .","As shown, layers , , and  are platform dependent. Although  shows exemplary layers, the invention can be advantageously applied to any number layers and any configuration of the layers.","Conventional database applications are tested in a manner similar to how a user operates the database (e.g., executing high level SQL statements). However, it takes one that is very knowledgeable in the software application and platform dependent layers in order to devise high level statements that fully test the platform dependent subsystems. In fact, it may be very difficult, if not impossible, to effectively stress test the subsystems utilizing high level commands.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":["251","201"]},"Test application  can be designed to simulate the performance and characteristics of software application . However, test application  can directly call platform dependent subsystems as shown. Thus, test application  can be directed by high level commands like software application , but can also receive instructions to call platform dependent subsystems directly.","By allowing the platform dependent subsystems to be called directly, it is much easier to fully test the subsystems. For example, with embodiments of the invention, bugs or errors can be identified in a matter of hours instead of days because the test application can be easily directed to stress test areas of interest.","In some embodiments, software application  is not required to test subsystems of a platform with test application . In other words, test application  can be utilized to test a platform regardless of whether a software application  has been installed. In other embodiments, the test application functionality can be included in software application .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6"},"At a step , instructions to call platform dependent subsystems are received. The instructions can be stored in a file, such as a text file that is easily modified by test personnel. Details of one embodiment of the file (or jobfile) will be describe below.","Calls to the platform dependent subsystems are performed according to the instructions at a step . Additionally, calls can also be made to platform independent subsystems including high level software application commands.","At a step , results from the calls to the platform dependent subsystems are analyzed. The results of any test can be in many forms. For example, results can be pass\/fail, performance, reliability, characteristics, and the like.","In one embodiment, the instructions for the test application are stored in a jobfile as shown in . One or more jobfiles  store instructions to test subsystems on the platform for a software application. A test application  receives the one or more jobfiles and the instructions contained therein.","Test application  interprets each jobfile and creates any internal data structures that are required to perform the instructions better contained in the jobfile. The jobfile can be a text file where each of the instructions has parameters that are readily identifiable by test personnel so that the jobfiles can be changed with ease.","Test application  performs calls to platform dependent subsystems on platform . As the calls are being made and executed, test application  monitors platform  and creates results  indicating how the one or more subsystems performed. As mentioned previously, the results can be in many formats.","In one embodiment, test application  is able to do concurrent input\/output (I\/O) to multiple files or devices, as is common with database applications. A stream can be defined in a jobfile that translates to a process with its own address space at one time. A process can do read, write, or a mix of both one of a specified I\/O discipline, into multiple devices of different types, in a specified pattern, for a certain period of time, and with a certain achievable rate.","A stream can be specified in the jobfile to run on the same node or a remote node in a cluster. Streams in a cluster environment can be coordinated to work coherently during the test. Streams can also be coupled together if needed to capture I\/O or other subsystem dependencies between them. For example, a stream emulating the database writer process can be coupled with a stream emulating the log writer process. The streams can also be used to emulate the various database processes doing I\/O in a system.","Parameters relating to I\/O can be easily manipulated in the jobfile and the effects of doing do can be readily seen. This enables a user to effectively test the functional corners of an I\/O platform very quickly.","Within the jobfile, each stream can have a target I\/O rate specified. The test application measures the I\/O rate at a frequent interval to try to ensure that the actual rate of doing the I\/O to\/from the stream is as close the I\/O rate as possible. Accordingly, it is possible to maintain a steady rate of doing I\/O through the duration of the stream.","The test application can provide accurate timing measurements to monitor various activities like I\/O rates, write-ordering, and the like. The steady I\/O rates and the ordering of various I\/O activities can typically only be done through a precise timer or mechanism. Depending on the availability on a particular platform, the test application uses the real time system clock and measures time in the order of nanoseconds.","Each stream can have two memory sections shared and private. The shared memory region can be used to keep the I\/O buffers shared among a group of processes and the private area can be for data structures local to a process. The size of the shared memory region may be a configurable parameter in the jobfile.","The results of executing instructions from a jobfile can be obtained in several different forms depending on the purpose of use. The pass\/fail output for certification of platforms, the overall and interval I\/O for performance and reliability tests, and the graphical output for I\/O characteristics.","The test application can provide data validation where the I\/O to the devices can be validated on the next reading of the block in this mode. A preset pattern is written on the I\/O device along with the checksum. While doing regular I\/O, the checksum is verified against the one from the recently read block to validate the I\/O to the block.","Additionally, the test application can provide non-interfering event logging. Logging of I\/O events occur to memory mapped files. A central logging server accepts logging requests from all the processes in the system with a specified level and determines the appropriate time to dump the most recent contents to a file on a different file system. This can ensure that there is minimum interference between the I\/O patterns of the streams and the I\/O due to tracing. In some embodiments, users have the ability of specifying various logging levels as desired.","Now that details of the jobfile and functional specifications of the test application have been described,  shows another process of the testing subsystems of a platform for a software application.","At a step , a jobfile including instructions to call platform dependent subsystems is received. The jobfile can also call platform independent subsystems and can include many different parameters to define the one or more tests in the jobfile.","The jobfile is interpreted at a step  to create any internal data structures. At this step, the test application prepares data structures for executing tests defined by the instructions in the jobfiles.","As at step , calls to the platform dependent subsystems are performed according to the instructions. The results of the instructions on the platform are noted and at a step , the results are analyzed. If the platform passes at a step , the user may be notified accordingly. Otherwise, error messages may be displayed at a step . Additionally, the test application could automatically enter a debug environment at a step  in order to attempt to isolate the problem.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 8"},"An embodiment of this invention for testing database clusters is very similar in architecture and operation. A database cluster consists of two or more computer systems, each of which can be described by the block diagram in . These computer systems employ dedicated hardware, such as a set dedicated network interfaces , to implement a set of cluster services. These services provide APIs as in layer  of  that communicate with cluster-dedicated hardware in layer .","Access to these cluster services is provided by both operating system specific and application generic software layers,  and  in  respectively. Test application  in  would communicate with these cluster services in a manner designed to simulate software application . The subsystem testing processes shown in  could be conceptually the same but slightly different in embodiments that test database clusters.","Differences could include, but are not limited to, extensions to the format of jobfile  to describe clusters and their operation, the ability of test application  to start and control processes on each computer system within the cluster, display special results and error messages that describe the performance of cluster services, and the like.","While the above is a complete description of preferred embodiments of the invention, various alternatives, modifications, and equivalents can be used. It should be evident that the invention is equally applicable by making appropriate modifications to the embodiments described above. For example, although the format and characteristics of jobfiles for some embodiments are described, embodiments of the invention are not limited to these specific features of the embodiment described herein. Therefore, the above description should not be taken as limiting the scope of the invention that is defined by the metes and bounds of the appended claims along with their full scope of equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
