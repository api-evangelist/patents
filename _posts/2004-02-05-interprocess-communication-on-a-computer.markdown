---
title: Inter-process communication on a computer
abstract: The invention provides a method of inter-process communication between at least two application processes on one computer. One embodiment of the invention includes a first process of a first application determining a name of a first file in a file system of the computer, the name of the first file being associated with a second application, the first file containing information for the first process to connect to a second process of the second application for inter-process communication; and the first process initiating a first connection to the second process using the information contained in the first file; the first process communicating with the second process using the first connection if the first connection is successfully established; and the first process starting a third process of the second application if the first process fails to establish a connection with the second process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07454758&OS=07454758&RS=07454758
owner: AOL LLC, a Delaware limited liability company
number: 07454758
owner_city: Dulles
owner_country: US
publication_date: 20040205
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Technical Field","This invention relates to inter-process communication in a computer environment. One embodiment of the invention relates to the inter-process communication on a single computer environment.","2. Description of Prior Art","Inter-process communications (IPC) use various communication methods, for example, shared memory, pipe, message queue or semaphore, to enable interactions between different application processes within the same computer or among different computers in a computer network system. The inter-process communications among multiple applications on a single computer allows individual application processes running on the computer to work together cooperatively.","The existing cross-platform inter-process communication methods, such as those based on the Common Object Request Broker Architecture (CORBA), can be used for the inter-process communication between application processes running on different computers with different operating systems. For example, CORBA provides a set of common interfaces through which object-oriented software can communicate, regardless of the computer platform on which the object-oriented software is running. However, such cross-platform inter-process communication methods are too heavy-weight to be a good solution for application processes running on a single computer. Existing inter-process communication methods for application processes running on a single computer, such as Component Object Model (COM) from Microsoft, Inc., are operating system-dependent and are not compatible with other platforms. For example, it would be difficult to port a set of software programs based on Component Object Model (COM) running on operating systems provided by Microsoft, Inc. to other operating systems, such as UNIX or Mac OS, etc.","Therefore, it would be advantageous to provide a method of inter-process communication for processes running on a single computer so that software applications based on such a method can be easily implemented and ported to different computer platforms running different operating systems.","The invention provides a method of inter-process communication between at least two application processes on one computer. One embodiment of the invention includes a first process of a first application for determining a name of a first file in a file system of the computer. The name of the first file is associated with a second application. The first file contains information for the first process to connect to a second process of the second application for inter-process communication. The first process initiates a first connection to the second process using the information contained in the first file. The first process communicates with the second process using the first connection if the first connection is successfully established; and the first process starts a third process of the second application if the first process fails to establish a connection with the second process.","The invention further allows the first process to initiate a second connection to the third process using the information in the first file, in response to the third process. This informs the first process that the third process is ready for a connection. The third process is started in a server mode without a user interface. Further, the first process fails to establish a connection with the second process because the second process is not running. The first file being missing from the file system indicates that the second process is not running.","In one embodiment, when the first process is started, the first process determines if a fourth process of the first application is running. The first process requests the fourth process to perform a task for the first process if the fourth process is running; and the first process exits after requesting the fourth process to perform the task for the first process.","Furthermore, the first process determines if the fourth process of the first application is running. This includes the first process of the first application determining a name of a second file in the file system of the computer, the name of the second file being associated with the first application. The second file being missing from the file system indicates that the fourth process of the first application is not running.","The second file contains information for the first process to connect to a fourth process for inter-process communication. Failure in connecting to the fourth process using the information contained in the second file indicates that the fourth process of the first application is not running; and success in connecting to the fourth process using the information contained in the second file indicates that the fourth process of the first application is running.","The first process communicates with the second process using the first connection through an Application Program Interface (API), which is platform independent. When the second process is started, the second process determines if a fourth process of the second application is running.","In one embodiment, the second process requests the fourth process to perform a task for the second process if the fourth process is running; and the second process exits after requesting the fourth process to perform the task for the second process.","The IPC process according to the one embodiment of the invention provides a lightweight, cross-platform mechanism for applications to communicate with one another. For example, the IPC mechanism according to one embodiment of the invention is purposefully restricted to communication between applications running on a single computer under the control of a single instance of an operating system.","In addition, a mechanism is used to ensure that only one instance of each application runs at a time to provide the service. For example, when a second instance of an application is started while a first instance of the application is still running, the second instance of the application communicates the task to be performed to the first instance of the application. After the second instance of the application communicates the task to the first instance, the second instance automatically exits. The task is then performed by the first instance of the application. More details are described below.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIG. 1"],"b":["102","110"]},"However, various different types of operating systems all provide access to files. In one embodiment of the invention, an inter-process communication mechanism is based on the access to rendezvous files, which contain platform-dependent information for establishing inter-process communication. Those skilled in the art will appreciate that a product other than rendezvous may be used to implement the discussed invention. The IPC library  makes use of the available communication facilities provided by the operating system  to provide an inter-process communication mechanism through a cross-platform Application Programming Interface (API) for different application processes, such as a process A  and a process B . Because the application programs for the process A  and the process B  are written using the cross-platform API for inter-process communication, the application programs can be easily ported to an operating system that is different from the operating system .","In one embodiment of the invention, each application program has an associated rendezvous file. The rendezvous file contains the information about a running instance of the application program so that other running process can use the information to establish inter-process communication with this running instance of the application program. For example, a client application process, e.g. the process A , can find a server application process, e.g. the process B , by mapping the server's name to a file, e.g. the rendezvous file A , in the file system .","In one example, the rendezvous file of an application program is named after the application program and placed in a predetermined location in the file system so that other application processes can locate the rendezvous file without prior knowledge of the running instance of the application program. The file contains rendezvous information, including parameters necessary for the client to connect to the server. For example, the file system  can have a rendezvous file A  for process A of an application program, e.g. Application A, and a rendezvous file  for process B of another application program, e.g. Application B. The file  contains rendezvous information for the application process  and the file  contains the rendezvous information for the application process .","When the application process  needs to establish an inter-process communication channel to communicate with the application process A , the application process  computes the file name of rendezvous file A  from the name of the application program of process , opens the rendezvous file A , connects to the application process  using the information in the rendezvous file A , and communicates with process , using IPC library  through platform-independent API .","If a server application, e.g. process , is not running, the rendezvous file  will be missing or contain stale information that causes the connection to fail. In that case, a client application process  can start the server process , with a command line argument of \u201c-server,\u201d which tells the server application to initialize itself and to get ready to serve the IPC requests, but not to display a user interface (UI). The client application process can start the server process in a server mode without a user interface so that the user is not bothered with a user interface of the server application program while the client application process obtains service from the server application. After the server process, e.g. , has initialized itself, the server process informs the client process, e.g. , that the server  is ready for IPC traffic and the client  makes a second attempt to connect, which normally succeeds.","In one embodiment of the invention, application processes can use the rendezvous files to combine multiple instances of an application program into one running instance. For example, when the application process B  of an application program is started to perform a task, the application process B  uses the IPC mechanism to look for a prior instance of the same application program. For example, before the application process B  initializes its rendezvous file, the application process  can try to locate the rendezvous file of the same application program and to communicate with a prior instance of the application program if the rendezvous file exists. If a prior instance  exists, the application process B  can establish an inter-process communication channel with the prior instance  and communicates the task of the application process B , such as the command line arguments for the application process, to the prior instance . After instructing the prior instance  to perform the task of the application process B , the application process B  exits. In this way, the action requested by the user of the second instance of an application program is actually performed by the first instance of the application program. Thus, multiple instances of a same application program can consolidate the tasks to be performed in one instance of the application program.","In one embodiment of the invention, all instances of one application program use the same rendezvous file. The rendezvous file contains valid information for only one instance of the application program at a time. When tasks for multiple instances of an application program are consolidated for process in only one instance of the application program, the computational resources of the computer can be used more efficiently. Further, inter-process communication between different instances of a same application or different applications can be simplified.","The client and the server status of application processes  and  can be interchangeable. For example, the process  can be an instance of a first application program, e.g. an email program, which has rendezvous information stored in file ; and, the process  can be an instance of a second application program, e.g. an address book program, which has rendezvous information stored in file . The process  of the address book program can initiate an IPC channel using the rendezvous file  and request the process  of the email program to send an email message. In this scenario, the process  of the address book program is a client process and the process  of the email program is a server process.","In another scenario, the process  of the email program can initiate an IPC channel using the rendezvous file  and request the process  of the address book program to look up an email address of a person, in which the process  of the address book program is a server process and the process  of the email program is a client process. In general, a set of application programs may each provide services to others and obtain services from others. The set of application program can use the method of IPC according to embodiments of the invention to communicate with each other.","One embodiment of the invention provides a cross-platform API  for exchanging messages between applications. Each message has one or more key and value pairs. The applications specify the meanings of the keys and values so that applications can exchange meaningful information. There are two basic forms of messages: 1) commands from one application to tell another application to do something; and 2) events sent from a source application to a target application to inform the target application that something of interest has occurred in the source application.","In one embodiment of the invention, the cross-platform API  provides a simple mechanism for transmitting sets of keys and values between two processes running on the same computer. In one implementation, the keys and values are transmitted as strings; and, the unit of the transmission of the keys and values is an IPCMessage, which includes a set of keys and values.","For example, the following code creates an IPCMessage and associates some keys and values with it. In the following code example, the message \u201citem\u201d has keys \u201ccn,\u201d \u201cmail,\u201d \u201clocality,\u201d and \u201cst,\u201d hich may represent a name, an email address, locality, and a state. Key \u201ccn\u201d has a value of \u201cRoger\u201d in the message; key \u201cmail\u201d has a value of \u201crogc@netscape.com;\u201d key locality\u201d has a value of \u201cGranite Bay\u201d; and key \u201cst\u201d has a value of \u201cCA.\u201d",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IPCMessage* item = IPC_NewMessage( );"]},{"entry":[{},"IPC_MessageSetValue(item,\u201ccn\u201d,\u201cRoger\u201d);"]},{"entry":[{},"IPC_MessageSetValue(item,\u201cmail\u201d,\u201crogc@example.com\u201d);"]},{"entry":[{},"IPC_MessageSetValue(item,\u201clocality\u201d,\u201cGranite Bay\u201d);"]},{"entry":[{},"IPC_MessageSetValue(item,\u201cst\u201d,\u201cCA\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"More complex data structures can be stored in an IPCMessage by using the function \u201cIPC_Serialize.\u201d In the following code example, the item that has key \u201ccn\u201d with value \u201cRoger\u201d and key \u201cmail\u201d with value \u201crogc@example.com\u201d is serialized as the value of key \u201citem;\u201d and, the item that has key \u201ccn\u201d with value \u201cBob\u201d and key \u201cmail\u201d with value \u201cbob@example.com\u201d is serialized as the value of key \u201citem.\u201d The message includes keys \u201citem\u201d and \u201citem\u201d with the corresponding serialized values.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IPCMessage* message = IPC_NewMessage( );"]},{"entry":[{},"IPCMessage* item = IPC_NewMessage( );"]},{"entry":[{},"IPC_MessageSetValue(item,\u201ccn\u201d,\u201cRoger\u201d);"]},{"entry":[{},"IPC_MessageSetValue(item,\u201cmail\u201d,\u201crogc@example.com\u201d);"]},{"entry":[{},"IPC_MessageSetValue(message,\u201citem1\u201d,IPC_Serialize(item));"]},{"entry":[{},"IPC_DestroyMessage(item);"]},{"entry":[{},"item = IPC_NewMessage( );"]},{"entry":[{},"IPC_MessageSetValue(item,\u201ccn\u201d,\u201cBob\u201d);"]},{"entry":[{},"IPC_MessageSetValue(item,\u201cmail\u201d,\u201cbob@example.com\u201d);"]},{"entry":[{},"IPC_MessageSetValue(message,\u201citem2\u201d,IPC_Serialize(item));"]},{"entry":[{},"IPC_DestroyMessage(item);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The preceding example creates a message having two keys: \u201citem\u201d and \u201citem.\u201d To extract the nested keys and values that are serialized as the values of the two keys, the receiving code can use IPC_Deserialize, as illustrated in the following code example. In the following code example, the received message is deserialized as item and item, respectively. The values for keys \u201ccn\u201d and \u201cmail\u201d for item is retrieved and stored in variables name and mail, respectively; and the values for keys \u201ccn\u201d and \u201cmail\u201d for item is retrieved and stored in variables name and mail, respectively:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IPCMessage* item1 = IPC_NewMessage( );"]},{"entry":[{},"IPC_Deserialize(item1,IPC_MessageGetValue(message,\u201citem1\u201d));"]},{"entry":[{},"const char* name1 = IPC_MessageGetValue(item1,\u201ccn\u201d);"]},{"entry":[{},"const char* mail1 = IPC_MessageGetValue(item1,\u201cmail\u201d);"]},{"entry":[{},"IPCMessage* item2 = IPC_NewMessage( );"]},{"entry":[{},"IPC_Deserialize(item2,IPC_MessageGetValue(message,\u201citem2\u201d);"]},{"entry":[{},"const char* name2 = IPC_MessageGetValue(item2,\u201ccn\u201d);"]},{"entry":[{},"const char* mail2 = IPC_MessageGetValue(item2,\u201cmail\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2"},"Referring now to , a client process determines a name of a file associated with a target application . If the file associated with the target application does not exist, the client process may abort the attempt to connect to the target application . If the file associated with the target application exists, the client process initiates a connection to the target application using the information containing in the file .","It is then determined whether the connection is successful or not . If it is determined that the connection is not successful , the information in the rendezvous file may be invalid, stale, and the client process aborts the attempts to connect to the target application . If it is determined that the connection is successful , the client process communicates with the target application using the established connection .","The client process may start one instance of the target application, which may display with or without a user interface. Typically, however, the client process starts the target application in the server mode without displaying a user interface.","Once an instance of the target application is started, the target application creates its associated rendezvous file. The client process may wait for the target process to create the rendezvous file. Alternatively, the client process may wait for the target process to open a channel using the rendezvous file of the client process and to inform the client process that the target process is ready for IPC traffic.","Once the client process locates the rendezvous file of the target application, the client process starts connecting to the target application process by opening an IPC communication channel using the information in the rendezvous file.","In one embodiment of the invention, each member of a group of IPC applications according to the invention provides services to the others. For example, the address book provides a service for resolving addresses and the mailer provides a service for creating new compose windows.","In one implementation, the IPC process according to the invention is provided by a cross-platform C API, a programming language which includes codes in a directory, e.g. the lib\/ipc directory of the source tree. Each application using the IPC process subclasses a base class, e.g. PhotonApp from lib\/wxutil. PhotonApp uses lib\/ipc to establish itself as a server to other applications by creating the rendezvous file, and also enforces the invariant that only one instance of each application runs to perform tasks at a time. Other started instances transfer their tasks to the running instance for which the information in the rendezvous files is valid. The details are described below.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3"},"Referring now to , a first process in the application program is started and its associated rendezvous file is created subsequently . The rendezvous file describes a communication channel that allows a later started processes to connect to the first process. Then, a second process of the same application program is started .","The second process of the application program determines whether a prior instance of the application program exists or not, e.g. another process of the application program is already running or not . If the rendezvous file of the application program already exists, the second process thus determines that another process, i.e. the first process, is already running. The second process of the same application program can use the information in the rendezvous file to connect to the first process.","If it is determined that a prior instance of the application program, e.g. the first process is already running , the second process then requests the first process to perform the task of the second process using the communication channel . Then, the second process automatically exits . Thus, the task of the second process is actually performed by the first process.","However, if the rendezvous file of the application program does not exist or the connection using the rendezvous file of the application program fails, no prior instance of the application program is running. Thus, the second process of the application creates the rendezvous file and\/or stores the rendezvous information in the rendezvous file of the application program .","In this way, the invention provides a method of IPC where only one copy of an application runs to perform tasks at a given moment. It is understood that an instance of an application program is a copy of running process of the application program.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 4"},"Referring now to , the invention provides a method of IPC between two applications on a single computer using a channel. To transmit an IPCMessage from one process to another an IPCChannel is used. One process is the server and the other process is the client. For example, the client creates an IPCChannel using",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IPC_ReadMessage to receive a response:"},{"entry":"IPCChannel*chan = IPC_OpenChannel(\u201cnsmail\u201d);"},{"entry":"if (chan) {"},{"entry":"IPCMessage* message = IPC_NewMessage( );"},{"entry":"IPC_MessageSetValue(message,\u201cph_command\u201d,\u201ccompose\u201d);"},{"entry":"IPC_MessageSetValue(message,\u201cto\u201d,\u201croger@example.com\u201d);"},{"entry":"if(IPC_WriteMessage(chan,message)==PR_SUCCESS) {IPCMessge*"},{"entry":"reply=IPC_NewMessage( );"},{"entry":"if (IPC_ReadMessage(chan,reply,"},{"entry":"PR_INTERVAL_NOTIMEOUT)==PR_SUCCESS) {\/*"},{"entry":"* mailer launched a compose window with"},{"entry":"* \u201croger@example.com in the \u201cTo:\u201d field."},{"entry":"*\/}"},{"entry":"IPC_DestroyMessage(reply);"},{"entry":"IPC_DestroyMessage(message);"},{"entry":"IPC_CloseChannel(chan);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IPC_OpenChannel takes the name of an application and returns an IPCChannel that can be used to communicate with the one and only instance of that application.","The client finds the server using a file in the preference directory . The file is associated with the server. The client determines whether the rendezvous information is present in the server . If it is determined that the rendezvous information is present in the server , the client reads the rendezvous information and tries to connect to the server .","For example, when the string nsmail is passed to the interface channel IPC_OpenChannel, the rendezvous file is $PREFS_DIR\/nsmail.sok. The \u201cnsmail.sok\u201d is a file that contains a platform-dependent information that a client can use to contact a server.","If \u201cnsmail.sok\u201d is present, IPC_OpenChannel reads it and then tries to establish a connection to the 16-bit port number specified using the localhost interface to the server using the platform-dependent parameters in nsmail.sok.","The server then determines whether a connection is successfully established . If it is determined that the connection is successful , the client and the server establish a communication channel . For example, If a connection is established, the client writes the client key to the connection and then reads 64 bits from the connection. If the read is successful and the 64 bits read from the connection match the 64-bit server key, an IPCChannel is created and returned to the caller.","If any of the above steps fail, the client assumes that the server is not running and should be started. The client starts the server  and waits for the server to be initialized . For example, the NSPR function CreateProcess is used to start the server, and then a platform-specific mechanism is used to wait for the server to initialize, e.g. WaitForInputIdle on Windows and Inheritable file descriptor on other platforms.","After the server has been initialized , , the client attempts to connect to the server again . For example, the client may attempt to connect using nsmail.sok as in the preceding paragraph. If the second attempt to connect fails, IPC_OpenChannel returns NULL to the caller .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 5"},"Referring now to , the server initialization code is stored in a file on the server. For example, a server initialization code may be stored in a file \u201clib\/wxutil\/PhotonApp.cpp\u201d. At initialization, the server acquires a semaphore , e.g., an NSPR PRSem semaphore to prevent races involving multiple clients launching the same server simultaneously. After acquiring the semaphore , the server determines whether a prior instance exists .","If it is determined a prior instance exists , it is further determined whether a connection to the prior instance can be established . If such a connection can be established , the server allows the prior instance to run and exits . For example, after a server sends its command line arguments to the previously existing instance, the server releases the semaphore and exits.","If it is determined that no previous instance exists , the server generates a rendezvous file . A typical rendezvous file contains a client key, a server key and transport parameters information. For example, the server creates a socket and binds it to a port on the local host interface. Then the server generates two 64-bit random numbers, and writes out a rendezvous file, e.g. a rendezvous file for Mail can be \u201cnsmail.sok.\u201d","The server waits for connections from a client . Typically, a new thread is spawned to await connections from the client. The client attempts to establish a connection to the server. In one embodiment, the client reads the rendezvous file and starts sending a client key to the server. The server verifies the client key. Meanwhile, the server sends to the client the server key and the client verifies the server key. It is then determined whether the server is successfully connected to the client .","If it is determined that the server is successfully connected to the client , it is then determined whether the user interface on the server shall be displayed .","If it is determined that the user interface on the server shall be initialized , in one embodiment, the semaphore is released and the server's user interface initializes . Alternatively, if it is determined that the user interface on the server shall not be initialized , the server stays hidden with the user interface hidden . For example, the server can be started with the \u201c-server\u201d argument.","After the client and the server are successfully connected and properly initiated, an IPC process begins . Typically, an IPC Message traffic starts to flow.","If it is determined that the server is not successfully connected to the client , the client initiates the server .","In this way, one embodiment of the invention provides a method of initiating a server application and only one copy of the server application by a client application running on a single computer.","Although the invention is described herein with reference to the preferred embodiment, one skilled in the art will readily appreciate that other applications may be substituted for those set forth herein without departing from the spirit and scope of the present invention. Accordingly, the invention should only be limited by the claims included below."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
