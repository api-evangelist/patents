---
title: Methods, systems, and computer program products for transparently controlling communications between network applications and a plurality of network communications protocol stacks using deferred protocol stack association
abstract: Methods, systems, and computer program products for controlling communications between network applications and multiple network communications protocol stacks using deferred protocol stack association are disclosed. In one method, a socket creation function call is received from an application. A socket creation function call is terminated, a pseudo communications endpoint is created, and a socket descriptor corresponding to the pseudo communications endpoint is returned to the application. At least one subsequent sockets-related function call is received. Based on the subsequent sockets-related function call, it is determined whether the application is a client or a server. In response to determining that the application is a server, communications endpoints are created on each of the network communications protocol stacks and server-related sockets function calls are made to each of the underlying protocol stacks. In response to determining that the application is a client, a protocol stack is selected, a protocol-stack-specific communications endpoint is created, and client-related sockets function calls are made to the underlying protocol-stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07734829&OS=07734829&RS=07734829
owner: EMC Corporation
number: 07734829
owner_city: Hopkinton
owner_country: US
publication_date: 20040609
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND ART","DISCLOSURE OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to methods, systems, and computer program products for controlling communications between network applications and a plurality of network communications protocol stacks. More particularly, the present invention includes methods, systems, and computer program products for transparently controlling communications between network applications and a plurality of network communications protocol stacks using deferred protocol stack association.","In computer networks, application programs communicate with other application programs through network communications protocol stacks, such as TCP\/IP protocol stacks. Network communications protocol stacks are usually implemented in software that is part of computer operating systems. Network applications access network communications protocol stacks via function calls provided by application programming interfaces (APIs) to the computer operating systems. One common application programming interface for accessing network communications protocol stacks is referred to as the sockets application programming interface. The sockets application programming interface was originally developed by the University of California at Berkeley as an interface to the TCP\/IP protocol stack of the Berkeley UNIX operating system. AT&T developed a similar interface, based on a streams implementation referred to as Transport Layer Interface or (TLI), for the System V UNIX operating system. The Berkeley sockets interface has been adapted for use with the WINDOWS\u2122 operating system. The WINDOWS\u2122 version is often referred to as WINDOWS\u2122 Sockets or Winsock.","The term \u201csocket,\u201d as used herein, refers to a data structure identified by a descriptor that an application uses to communicate with a remote application via a local communications protocol stack and is not intended to be limited to any operating-system-specific data structure. A socket may be created using a socket creation function call provided by a sockets API or a streams function call provided by a streams API. The function call returns a socket descriptor to the calling application that the application uses to send and receive data over a network in a manner similar to the way that an application reads and writes data to a file using a file descriptor. The term \u201csockets layer,\u201d as used herein, is not intended to be limited to any operating-system-specific transport interface and instead is intended to refer generically to an application programming interface for accessing a network communications protocol stack, such as the sockets API or the streams transport layer interface (TLI).","Communications protocol stacks, sockets layers, and applications are typically implemented in different software layers.  illustrates a network application, a sockets layer, and a software-implemented network communications protocol stack. Referring to , network application  may be a client or a server that desires to communicate with other applications over a computer network. A sockets layer  provides sockets-related function calls that allow network application  to access a network communications protocol stack . In the illustrated example, network communications protocol stack  is a TCP\/IP protocol stack. TCP\/IP protocol stack  implements reliable, connection-oriented communications over an unreliable network. Exemplary functions performed by TCP\/IP protocol stack include connection establishment and tear-down, message sequencing, timeout and retransmission, congestion control, and network layer routing. TCP\/IP protocol stack  accesses underlying network  via network interfaces  and . Network interfaces  and  may be any suitable physical layer interfaces, such as Ethernet interfaces, for sending and receiving data over underlying network or networks . For example, network interfaces  and  may be connected to different IP subnets.","One problem with the architecture illustrated in  is that network communications protocol stack  consumes a large amount of processor cycles. For example, a TCP\/IP protocol stack  implements connection establishment and tear-down, timeouts, retransmission, and other functions for each connection implemented through TCP\/IP protocol stack . If network application  is a server, network application  may have multiple simultaneous connections through TCP\/IP protocol stack . Concurrency can also exist in network clients, again resulting in multiple simultaneous connections through protocol stack . As a result, the processing required to implement TCP\/IP protocol stack  is multiplied by the number of simultaneous connections. The processor that executes the instructions that implement TCP\/IP protocol stack  becomes overloaded and the time for network application  to service each connection is increased.","In order to avoid the processor overload conditions that can be caused by software-implemented network communications protocol stacks, portions of network communications protocol stacks have been implemented in hardware. For example, hardware-implemented network communications protocol stacks, referred to as TCP offload engines or TOEs, move the data path of the network communications protocol stack to hardware, while the control portion of the network communications protocol stack is implemented in software. Moving the data path of the network communications protocol stack into hardware frees processor cycles to perform other functions, such as accepting more connections or performing application functions.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["200","202","204","206","202","204","110","202","204","110","206","206","202","204","206","100"]},"Even though the architecture illustrated in  includes multiple TCP offload engines, the architecture functions as a single TCP\/IP protocol stack, and a socket is associated with protocol stack when the socket is created. For example, when application  makes a socket creation function call via sockets layer , a socket is created and associated with protocol stack . This association is fixed for the life of the socket and cannot be altered using existing sockets APIs. While such an architecture may be useful in certain situations, future architectures may include multiple TCP\/IP protocol stacks. However, because sockets layer  fixes the association between a socket and a communications protocol stack at socket creation time, an application can only communicate with remote applications over one protocol stack. If data arrives over a different protocol stack from the protocol stack with which the application's socket is associated, the data will not reach the application. Alternatively, the application must create a socket for each protocol stack, requiring the application to be aware of each protocol stack in the system. Requiring the application to be aware of each protocol stack in the system greatly increases the complexity of application design.","Accordingly, there exists a long felt need for methods, systems, and computer program products for controlling communications between network applications and a plurality of network communications protocol stacks.","According to one aspect, the present invention includes a method for transparently controlling communications between a network application and a plurality of network communications protocol stacks using deferred protocol stack association. According to this method, an application makes a function call to create a socket. Rather than immediately making the association between the socket and the network communications protocol stack in response to the socket creation function call, the method includes deferring association between the socket and the network protocol stack and creating a pseudo communications endpoint. As used herein, the term \u201cpseudo communications endpoint\u201d refers to a data structure implemented in a protocol layer that resides between the application layer and a plurality of network communications protocol stacks. In one exemplary implementation, the pseudo communications endpoint may be implemented in a protocol layer between the sockets layer and the network communications protocol stacks. In another exemplary implementation, the pseudo communications endpoint may be implemented in an application library that resides between the application and the sockets layer. In a third exemplary implementation, the pseudo communications endpoint may be implemented as a pseudo transport driver implemented as a streams multiplexer between the application's stream and the underlying protocol stacks. In a sockets environment the pseudo communications endpoint may include stack-specific state block used to store information regarding subsequently created protocol-stack-specific communications endpoints. In a streams environment, the pseudo communications endpoint is contained within the pseudo transport driver and is used to store information regarding subsequently created protocol-stack-specific streams and the associated communications endpoints.","The layer in which the pseudo communications endpoint is created is referred to herein as the stack multiplexer layer. The stack multiplexer layer controls communications between a network application and a plurality of network protocol stacks. The stack multiplexer layer may be implemented in hardware, software, firmware, or any combination thereof. As stated above, the stack multiplexer layer may be located between the sockets layer and the communications protocol stacks in the socket or streams environments or between the application and the sockets layer as an application level library.","When the application makes a standard socket creation function call, the stack multiplexer layer terminates the original socket creation call, creates a pseudo communications endpoint and returns a socket descriptor to the application. The application then uses the pseudo communications endpoint in making subsequent function calls. The stack multiplexer layer receives the calls, terminates the calls, returns the appropriate values to the calling application, and uses the calls to determine whether the application is a client or a server. For example, if the application is a server, the application may execute a listen function call to indicate it wishes to accept new connections on this socket. Since client applications typically do not call listen, the stack multiplexer layer may identify an application that executes a listen function call as a server. If the application is determined to be a server, the stack multiplexer layer may create a plurality of protocol-stack-specific communications endpoints via socket attach function calls to the network communications protocol stacks. In a sockets environment, a socket attach function call is a function call made by the kernel to a communications protocol stack to create a protocol-stack-specific protocol control block. In a streams environment, the protocol-stack-specific streams can be created by making open device function calls to each protocol stack. In an application library a protocol-stack-specific socket may be opened via a protocol-stack-specific socket function call. Thus, the term communications endpoint may represent a protocol control block in a sockets implementation, an open stream in a streams environment, or a socket in an application library.","For a server, an association is made between the application socket and each underlying communications protocol stack. Socket state, protocol-stack-specific communications endpoints, and other information returned by the transport function calls (i.e., the socket attach function calls) may be stored in the pseudo communications endpoint data structure. Once the protocol-stack-specific communications endpoints have been created deferred function calls such as, bind and listen, may be made to each underlying protocol stack.","When the application makes an accept function call the stack multiplexer layer monitors each protocol stack for incoming connection requests. When connection requests are received from remote applications, the stack multiplexer layer completes the accept function calls to the protocol stacks on which the connection requests are received and returns new socket descriptors to the application for subsequent communications with the remote applications. Thus, by creating a stack multiplexer layer that allows a server to transparently communicate with a plurality of communications protocol stacks, the method avoids the difficulties caused by conventional sockets implementations that fix the association between a socket and a single protocol stack at socket creation time.","If the application is determined to be a client, the method may include performing a protocol stack lookup and assigning a protocol stack to the client based on any suitable criteria, such as load sharing, a table lookup of the destination address, or routing tables from the underlying protocol stacks. A client application may be identified by the presence of a connect function call, which is typically made by client applications and not by server applications. When a connect function call is received, the stack multiplexer layer may pend the connect function call, select one of the communications protocol stacks, create a protocol-stack-specific communications endpoint, complete any deferred function calls, and then complete the connect function call on the selected protocol stack. When the stack multiplexer layer makes a connect call to the protocol-stack-specific socket, a connection request is sent to a remote application via the selected communications protocol stack. When the connection request is accepted a remote protocol stack, the protocol-stack-specific connect function call returns. On a successful connection request the stack multiplexer layer populates remote endpoint data structures with an IP address and a port number for the remote application and returns a successful status to the application. The stack multiplexer layer will also forward an error return code to the application in response to a failed connect function call made by the application. Once a connection with a remote application has been established, data is sent to and received from the remote application using the information contained in the socket, pseudo communications endpoint and the protocol-stack-specific communications endpoint. Because of the one-to-one correspondence between the protocol-stack-specific communications endpoint and the socket for a client application, data written by the application to the socket may be directly passed to the underlying protocol stack without processing in the stack multiplexer layer. Similarly, data received from the underlying protocol-stack may be directly written to the application's socket.","Accordingly, it is an object of the invention to provide methods, systems, and computer program products for controlling communications between applications and a plurality of network communications protocol stacks using deferred protocol stack association.","It is another object of the invention to provide a stack multiplexer layer that terminates a socket call made by an application, creates a pseudo communications endpoint, makes the appropriate transport-related function calls depending on whether the application is a client or a server, and associates the pseudo communications endpoint with the communications endpoints in the underlying protocol stacks.","Some of the objects of the invention having been stated hereinabove, and which are addressed in whole or in part by the present invention, other objects will become evident as the description proceeds when taken in connection with the accompanying drawings as best described hereinbelow.","As stated above, the present invention includes methods, systems, and computer program products for controlling communications between an application and a plurality of network communications protocol stacks using deferred protocol stack association.  is a block diagram illustrating an exemplary system for controlling communications between a network application and a plurality of network communications protocol stacks using deferred protocol stack association according to an embodiment of the present invention. Referring to , network application  may be a client or a server for communicating with other applications over a network. Sockets layer  may be a conventional sockets layer that associates sockets with communications protocol stacks at the time a socket is created. Stack multiplexer layer  preferably intercepts calls from the socket layer to the underlying protocol stack and defers association of the sockets with one or more of a plurality of network communications protocol stacks until the nature of the application, i.e., whether the application is a client or a server, can be determined. Stack multiplexer layer  may create a pseudo communications endpoint, create one or more protocol-stack-specific communications endpoints, and, after it is determined whether the application is a client or a server, make the appropriate client- or server-related socket function calls to the protocol stacks. Socket layer  may return a socket descriptor to the application that the application uses to perform sockets-related functions. Stack multiplexer layer  may also maintain associations between sockets and the protocol-stack-specific communications endpoints created by stack multiplexer layer . By creating and maintaining the associations between a socket and protocol-stack-specific communications endpoints, stack multiplexer layer  enables applications to transparently use any or all of the network communications protocol stacks in a system with multiple network communications protocol stacks. For example, the application is not required to be aware of the details of whether the operating system and\/or network communications hardware has a single or multiple protocol stacks. The application simply makes standard sockets function calls to a single socket via a sockets or streams API, and the stack multiplexer layer interfaces with the network communications protocol stack or stacks. Because the application is only required to manage a single socket, application design is simplified over an implementation in which the application is required to manage connections with multiple protocol stacks and\/or multiple sockets.","Stack multiplexer layer  enables communication between an application and any number of network communications protocol stacks implemented in hardware, software, firmware, or any combination thereof. In the illustrated example, three network communications protocol stacks are included. The first network communications protocol stack  includes a software-implemented TCP\/IP stack  and separate network interfaces  and . Communications protocol stacks  and  each include TCP offload engines . TCP offload engines  offload TCP\/IP processing to hardware. TCP\/IP offload engines  also include integrated network interfaces.","As stated above, stack multiplexer layer  detects socket creation function calls from application  and defers association of the sockets with one or more of the protocol stacks , , and , until the nature of application  can be determined.  are a flow chart illustrating exemplary steps that may be performed by stack multiplexer layer  in controlling communications between application  and protocol stacks , , and . Referring to , in step , application  makes a socket creation call. The socket creation call may be a socket call made using any standard communications API. In response to the socket creation call, a socket descriptor is created and the socket is normally associated with a specific protocol stack. However, rather than associating the socket with a specific protocol stack, in step , stack multiplexer layer  terminates the socket creation call, creates a pseudo communications endpoint, and the socket descriptor is returned to the application. The pseudo communications endpoint is a data structure that stores information for associating the application's socket with the communications endpoints associated with each protocol stack. For example, the pseudo communications endpoint may store the application's socket descriptor, descriptors that identify each protocol-stack-specific communications endpoint, and state information (i.e., whether the protocol-stack-specific communications endpoint is open, closed, listening, connected, etc.) for each protocol-stack-specific communications endpoint.","In step , stack multiplexer layer  handles subsequent transport-related function calls originated by the application. By handling transport-related function calls originated by the application, it is meant that stack multiplexer layer  intercepts the corresponding calls made to the protocol stack and terminates these calls. Examples of the application-originated function calls may include bind calls, listen calls, and connect calls. As used herein, a bind call refers to a function call that associates a socket with a local endpoint address. A listen call is a call that sets the state of a stream-oriented socket to LISTEN, where the socket is willing to accept incoming connection requests. In some environments, the presence of a bind function call may be sufficient to identify an application as a server. In other environments, client applications may make bind function calls. In these environments, it may be necessary to distinguish clients from servers by the presence of listen function calls, which are typically made only by servers. A connect call is a call that initiates a TCP three-way handshake to connect a socket to a remote endpoint. Connect calls are typically implemented by clients.","Although the terms \u201cbind\u201d, \u201clisten\u201d, and \u201cconnect\u201d are used herein to describe the sockets-related function calls and their associated calls from the socket layer to the transport, these calls are specific to BSD and Winsock sockets implementations, the present invention is not limited to only BSD or Winsock socket calls. The functionality provided by stack multiplexer layer  may be used with any socket- or stream-related function calls that perform equivalent functions to the bind, listen, and connect calls without departing from the scope of the invention.","Additional sockets function calls that will be used to describe the functionality of embodiments of the invention include accept, send, and receive function calls. An accept function call is a call used by a server to accept an incoming connection request. A send function call is a call used by clients and servers to send data to a remote application. A receive function call is a call used by clients and servers to receive data from a remote application. As with the sockets-related function calls described above, the accept, send, and receive functions calls are used herein to refer to calls that perform the indicated sockets-related functions and are not intended to be limited to any operating-system-specific sockets function calls.","In step , stack multiplexer layer  defers the subsequent transport-related-function calls, stores state information so that the requested operations can be performed later, and returns temporary status information to the application. Execution of the application may block unless the sockets-related functions return with successful return codes. For example, in response to the bind function, the application expects a return value indicating whether or not the bind function successfully executed. It is desirable for the application to continue execution before the protocol stack can be selected, so stack multiplexer layer  may return a temporary successful return code in response to a bind function or any of the other sockets-related functions that are deferred as described above.","As an example of how steps  and  may be implemented in practice, when an application makes a bind call, it may be necessary to wait until a listen or connect call is made before determining whether the application is a client or a server. Thus, when the application makes the bind call, stack multiplexer layer  handles (i.e., terminates the corresponding call to the protocol stack) the bind function call, stores the local address and port information in the pseudo communications endpoint so that the bind function call can be performed later, and returns a temporary successful return value to the application. Subsequently, if the application makes a listen function call, stack multiplexer layer  will conclude the application is a server. If the application makes a connection call the stack multiplexer layer  will conclude the application is a client","In step , stack multiplexer layer  determines whether the application is client or a server. This step may be performed by analyzing the sockets-related function call or calls made by the application. For example, if the calls include a bind function, call the application may be identified as a server. In an alternative implementation, a server may be identified by the presence of a listen call. A client application may be identified by the presence of a connect call.","If the application is determined be a server, control proceeds to step  where communications endpoints are created for each protocol stack. Stack multiplexer layer  may perform step  by making the transport-related function calls normally used during socket creation to each protocol stack. Examples of the transport-related function calls may include socket attach function calls for sockets environments or call stream open device and linking function calls for streams environments or call protocol stack specific socket create functions in an application library environment. In step , stack multiplexer layer  stores the association between the protocol-stack-specific communications endpoints, and the application socket in the pseudo-communications endpoint. In step , stack multiplexer layer  completes the deferred function calls from step . For example, if stack multiplexer layer  has received a bind call and a listen call, stack multiplexer layer  may execute calls corresponding to a bind call and a listen call to each of the protocol-stack-specific sockets, so that the application will be bound to and listening on all of the protocol stacks. In step , stack multiplexer layer  stores return values for each of the function calls made in step , summarizes the results, and returns the summarized results to the application. For example, if the application is waiting for a return value to the listen function, and all three protocol-stack-specific listen function calls return successfully, stack multiplexer layer  may return a single successful return code to the application. Similarly, if any of the protocol-stack-specific listen calls fail, stack multiplexer layer may return an unsuccessful return code to the application.","After stack multiplexer layer  has created associations between the applications socket and the underlying protocol stacks and all the underlying protocol-stack specific communications endpoints are passively listening for connections, control proceeds to step  where the application makes an accept function call to wait for new connection requests. The accept function call blocks until a connection request is received from a remote application. In step , stack multiplexer layer  monitors the underlying protocol-stacks for incoming connection requests. Such monitoring may be performed using functionality similar to that provided by a select( ) function call, which allows stack multiplexer layer  to monitor a list of socket descriptors to determine if any of the socket descriptors have received a connection request from a remote application. In step , one of the underlying protocol stacks , , and  receives a connection request from a remote application, creates a new protocol-stack-specific communications endpoint for the connection and awakens stack multiplexer layer  to complete the accept call. Stack multiplexer layer  will associate a new socket with the new underlying protocol-stack-specific communications endpoint. The socket descriptor corresponds to a new socket through which subsequent communications with each remote application will occur. In step , stack multiplexer layer  forwards the new socket descriptor to the application. The application can then use the new socket to communicate directly with the remote application. Steps - may be executed continuously to accept incoming connection requests from any of the protocol-stack-specific sockets and forward the new socket descriptors to the application. Thus, using the steps illustrated in , the pseudo-transport allows a server application to transparently communicate with remote applications via multiple network communications protocol stacks.","Returning to step  in , if it is determined that the application is a client, control proceeds to step  in  where a stack lookup is performed to select a protocol stack with which the client will be associated. The protocol stack may be selected based on any suitable criteria, such as load sharing criteria. In another example, it may be desirable to select hardware-implemented TCP\/IP protocol stacks before software-implemented TCP\/IP protocol stacks in order to conserve processor cycles on the host machine. Alternatively, the stack may be selected based on the destination address of the connect call by consulting an IP routing table in one or more of the underlying protocol stacks.","In step , stack multiplexer layer  creates a protocol-stack-specific communications endpoint. This step may be accomplished by making the transport-related function calls normally used by the kernel during socket creation to the selected communications protocol stack. Examples of the transport-related function calls include socket attach function calls in a sockets environment and call stream device open function calls in a streams environment or call protocol stack specific socket create functions in an application library environment. In step , stack multiplexer layer  stores an association between the protocol-stack-specific communications endpoints and the socket in the pseudo communications endpoints.","In step  any function calls that were deferred in step  must be completed. Completing the deferred function calls may include making the sockets layer-to-protocol-stack function calls corresponding to the application-to-sockets layer function calls. In step , stack multiplexer layer  makes a connect function call using the protocol-stack-specific communications endpoint and data extracted from the application-originated connect function call. The data from the application-originated connect function call may include the socket descriptor and a pointer to the data structure that identifies the remote endpoint with which the application is seeking to connect. In step , the protocol-stack-specific connect function call returns in response to a connection acceptance from a remote network communications protocol stack. In step , stack multiplexer layer  stores the return value received in response to the protocol-stack-specific connect call. Stack multiplexer layer  may store the IP address and port number of the local and remote endpoints along with other state in the pseudo communications endpoint.","In step , stack multiplexer layer  sends data to and receives data from the remote application using the socket and the protocol-stack-specific communications endpoint. Step  may include handling send function calls made by the local client application by terminating the original sockets layer-to-stack multiplexer layer send function calls and formulating new send function calls to the specific protocol-stack, or stack multiplexer layer  may associate the socket and the underlying protocol stack in a way that stack multiplexer layer  need not be directly involved in the sending of data. For receiving data, step  may include handling receive function calls made by the local client application by terminating the sockets-layer-to-stack-multiplexer-layer receive function calls and formulating new receive function calls to the specific protocol-stack or the stack multiplexer layer  may associate the socket and underlying protocol stack in a way that stack multiplexer layer  need not be directly involved in the receiving of data. In one exemplary implementation the stack multiplexer  acts as a proxy and passes data and subsequent socket-related function calls between sockets layer  and the underlying protocol stack. In another exemplary implementation, stack multiplexer  may set up the socket data structure and the underlying communications endpoint so that the socket data structure and the underlying communications endpoint are directly connected, thus bypassing the pseudo communications endpoint for data transmissions and subsequent socket-related calls. Thus, using the steps illustrated in , a client application can be associated with any communications protocol stack of a plurality of communications protocol stacks for sending and receiving data.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 5"],"b":["500","502","504","506","502","504","506","502","504","506","508","510","512","514","516","518","300","500","520","300","500","520","500","520","300"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6","FIG. 6"],"b":["600","602","602","604","514","606","600","608","300","300","610","612","612"]},"Although the examples illustrated in  include a single pseudo-communications endpoint associated with protocol stacks , , and , stack multiplexer layer  is not limited to generating a single pseudo communications endpoint. Multiple pseudo communications endpoints may be created and associated with any number of protocol stacks without departing from the scope of the invention. For example, stack multiplexer layer  may create and maintain multiple pseudo communications endpoints for multiple client and\/or server applications executing on the host machine.","In addition, in the example illustrated in , separate stack multiplexer and sockets layers have been shown to reflect a modular implementation of stack multiplexer layer . However, functionality provided by these layers may be combined without departing from the scope of the invention. In such a combined implementation, stack multiplexer layer  may store socket creation function calls until the nature of the application can be determined. Once the nature of the application is determined, stack multiplexer layer  may modify the socket creation function calls and\/or make additional socket creation function calls to the protocol-stack-specific sockets. Subsequent sockets-related function calls received from an application may be made to the appropriate underlying protocol stacks, as described above.","Although in the examples described above, stack multiplexer layer  terminates sockets-layer-to-transport function calls and makes the corresponding kernel function calls to the appropriate protocol stack, the present invention is not limited to a kernel-implemented stack multiplexer layer. In an alternate embodiment, stack multiplexer layer  may be implemented as an application library that an application uses to access multiple protocol stacks using sockets-related function calls to a single protocol stack. In an application-library implementation, stack multiplexer layer  may perform similar functionality to that described above by intercepting and deferring sockets functions calls made by the application, determining whether the application is a client or a server and making the corresponding sockets function calls to an underlying sockets layer. The underlying sockets layer may then communicate with the individual protocol stacks.","Thus, the present invention includes methods, systems, and computer program products for transparently controlling communications between a network application and a plurality of network communications protocol stacks. By deferring stack association from the time a socket call is made until the nature of the application can be determined and protocol-stack-specific communications endpoints can be created, the methods, systems, and computer program products described herein enable the application to see a single socket while multiple protocol stacks underlie that socket. As a result, the application can communicate with multiple communications protocol stacks using standard sockets function calls and without the increased complexity required to manage communication with multiple protocol stacks.","It will be understood that various details of the invention may be changed without departing from the scope of the invention. Furthermore, the foregoing description is for the purpose of illustration only, and not for the purpose of limitation, as the invention is defined by the claims as set forth hereinafter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Preferred embodiments of the invention will now be explained with reference to the accompanying drawings of which:",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 4A-4C"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
