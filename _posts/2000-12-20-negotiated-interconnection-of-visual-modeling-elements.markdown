---
title: Negotiated interconnection of visual modeling elements
abstract: Described is a method and system that enables open, non-proprietary and extensible visualization and modeling tools by providing multiple-way negotiations between model element end points (nodes) and a connecting model element (arc). Based on these negotiations, a user is guided to make appropriate interconnections between model elements. A protocol is provided for intelligent model elements (objects) to communicate their information to one another, e.g., an arc communicates its capabilities and requirements to a node, and vice-versa, whereby the model element objects themselves decide whether they can interconnect, and if so, how they need to interconnect. The objects themselves enforce semantics and rules. According to the protocol, either object can reject the interconnection (break off the negotiation) with the other object if it determines it is not compatible with the other object, or is otherwise unable to connect to it.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07103527&OS=07103527&RS=07103527
owner: Microsoft Corporation
number: 07103527
owner_city: Redmond
owner_country: US
publication_date: 20001220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention is generally directed to computer systems, and more particularly to visualization and modeling in computer systems.","Visualization and modeling software is extensively used in industry. Visualization generally refers to computer tools for viewing existing layouts, such as for viewing a representation of a network topology, an electrical wiring system or various other things that are designed. Visualization has general relevance in various applications, e.g., viewing a network topology is a scenario that is applicable to many different products. Modeling refers to computer tools used to design things, such as software, databases, integrated circuits, CAD\/CAM applications and the like. Thus, in general, in visualization, a user looks at interconnected model elements placed on a viewing surface. In modeling, a user places the model elements on a work surface and connects them together in some manner. The semantics of connecting two or more model elements using other model elements is the fundamental operation in modeling and visualization.","However, existing visualization and modeling tools have a number of drawbacks, including that the developers of the tools have made them closed and proprietary. For example, the file formats that store the designs are proprietary. Similarly, the rules and semantics of connecting two or more model elements together are embedded in the modeling tool. For example, an integrated circuit design tool will allow or disallow a connection between two elements based on some hard-coded knowledge about those elements. As a consequence, the tool that has the hard-coded rules and semantics, and the model elements, typically come from the same vendor, or at least come from sources having detailed knowledge of one another, resulting in a closed and proprietary tool in which independent software vendors (ISVs) or other third parties cannot participate. Moreover, existing tools are essentially not extensible, but rather require a newer version from the vendor each time updates (e.g., to modify the hard-coded rules or semantics) are required.","Briefly, the present invention provides a method and system that enables open, non-proprietary and extensible visualization and modeling tools by providing multiple-way negotiations between model element end points (nodes) and a connecting model element (arc). Based on these negotiations, a user is guided to make appropriate interconnections between model elements. This is accomplished in part by providing a protocol via which intelligent model elements (objects) communicate their information to one another, e.g., an arc communicates its capabilities and requirements to a node, and vice-versa. As a result, any software vendor can provide such model element objects, as the model element objects themselves decide whether they can interconnect, and if so, how they need to interconnect. Because the objects themselves enforce semantics and rules, instead of the tool or the framework, they are not limited to any one tool or framework, and new model element objects may be created and used with any existing framework that supports such objects.","The objects initiate the negotiation through a Visualization and Modeling Engine (VME) when the user indicates that two objects should connect, such as when the user's pointing device drags one object over the other. According to the protocol, either object can reject the interconnection (break off the negotiation) with the other object if it determines it is not compatible with the other object, or is otherwise unable to connect to it.","In one implementation, a user works with a visual modeling framework (VMF) tool to select nodes from a palette for placing on a drawing surface. When the user selects a connector (arc) element from a palette, the VMF tool provides the arc, and the user typically selects a model element from which to start the arc, i.e., a \u201cfrom\u201d node.","To initiate negotiation, when the user moves the mouse over a model element, the VMF tool notifies the model element over which the user is hovering, whereby the model element can request to negotiate with the arc. VMF provides a set of functions (e.g., methods or application programming interfaces, or APIs) that the model elements use to implement the negotiation. The negotiation usually involves finding out the kind of arc, its semantics and so forth. Negotiations also may involve other concepts, such as which side to connect from, which angle to connect at, and other criteria. If the model element being hovered on decides that this is an acceptable arc for which it can be the \u201cfrom\u201d side of a connection, it indicates this to the VMF tool. The VMF tool can highlight or otherwise change the appearance of the model element to indicate to the user that this is a valid element from which to connect, and a connector line appears on the modeling surface. When the user creates a \u201cto\u201d connection to another model element, similar negotiation takes place, except that this time the potential \u201cto\u201d node element typically requests to negotiate with both the connector element and the \u201cfrom\u201d node element. At this stage, any of the elements involved can fail the negotiations, i.e., the arc, the \u201cfrom\u201d node or the \u201cto\u201d node each can choose to reject the proposed interconnection.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Examplary Operating Environment",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through a output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in FIG. . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Visual Modeling Framework","As generally represented in , the Visualization and Modeling Framework (VMF) is a component-based framework  for visualization and modeling tools. VMF is a general-purpose modeling tool having a paradigm-independent surface  capable of modeling numerous kinds of model elements. Nevertheless, unlike other diagramming tools, VMF is still capable of enforcing model semantics and constraints.","A minimum VMF architecture requires the surface , a host  and a paradigm server . Model persistence, such as in the form of a repository , is optional, but is very likely in many modeling scenarios, for example, to maintain properties and other information for model elements. In keeping with the present invention as described below, the VMF components such as the surface , core graphic components and other components are designed to be reusable across modeling paradigms. For example, new model elements may be introduced by registering new paradigm servers (e.g., ActiveX\u00ae controls). Similarly, new project types may be introduced, (e.g., as ActiveX\u00ae servers). Some or all of the components that comprise the VMF  may be incorporated into an operating system, such as the operating system  () of the computer .","The VMS host  is a tool that uses the services of the VMF  to solve a problem for the end user. In one straightforward situation, this tool may be a stand-alone executable program, wizard or add-in, with a specific problem domain for which it will provide solutions. For example, a simple host can be just a tool that hosts the surface  and a known paradigm server , e.g., a type-modeling tool may be created that utilizes a Unified Modeling Language (UML) paradigm server to model Visual Basic (VB) classes, and then generates the code for those VB classes.","A more complex host may be a generic modeling tool that may be hosted through hosting layers in a variety of host shells, such as the shell  (FIG. ). Such a modeling tool may model virtually anything, using one or more registered paradigms and one or more project types  () dedicated to solving problems utilizing those paradigms in different problem domains. More complex hosts, such as a generic modeling tool, can be hosted in a number of shells (including VS, IE, MMC, and Access) through thin hosting layers to provide shell independence. As described below, these more-complex hosts may also implement the project types  (like VB project types) to provide scenario-based tool support for individual sets of paradigms without compromising paradigm independence.","In the VMF architecture represented in , the visualization and modeling surface  comprises an HTML rendering engine  (e.g., browser and\/or editor) such as found in Microsoft Corporation's Internet Explorer product. The surface  thus provides a complete HTML interpreter along with HTML editing capabilities. For example, the surface supports dynamic models built from Visual Basic and C++ ActiveX\u00ae controls and behaviors, as well as static models rendered in XML\/VML.","The surface  (which in one preferred implementation is an ActiveX\u00ae control) provides the actual drawing canvas on which model elements are arranged to form diagrams, represented in  as the modeling surface window . As described below, the surface  also acts as the central communication point for model elements to communicate with each other, including performing interconnection (or possibly other) negotiations in accordance with one aspect of the present invention. Most of the properties, methods and events of the surface  are directed to adding, editing and deleting model elements, and to managing the interactions between them. A preferred modeling surface, to be provided to third parties such as independent software vendors, is further described in U.S. patent application entitled \u201cDynamic, Live Surface and Model Elements for Visualization and Modeling,\u201d assigned to the Assignee of the present invention and herein incorporated by reference. Note that while this surface  is rich, consistent and straightforward to use, the surface  provides a set of defined interfaces, and is thus capable of being replaced by an arbitrary component that supports the same set of interfaces.","The surface  also includes a Visualization and Modeling Engine (VME)  that provides additional support for rendering and editing models beyond that available via the rendering engine . In other words, via extensions, the VME  provides capabilities that the rendering engine  does not natively provide. For example, a more sophisticated way to determine whether one model element is above or in close proximity to another model element on the modeling surface, known as four-point hit testing, is not natively handled by the rendering engine , but is instead provided by the VME . Moreover, in accordance with one aspect of the present invention and as described below, the VME  includes negotiation methods  or the like (e.g., API functions) to handle negotiating interconnections with model elements.","In one particular implementation using ActiveX\u00ae controls as represented in , a VMS host such as the host  may site the surface ActiveX\u00ae control , which provides standard ActiveX\u00ae interfaces to access the rendering engine . Any ActiveX\u00ae capability that the rendering engine  does not currently provide natively, such as the above-described four-point hit testing, are also provided by this surface ActiveX\u00ae control . Alternatively, thin clients may access most of the same capabilities of the VMS ActiveX\u00ae control with Dynamic HTML, utilizing Document Object Model (DOM) extensions .","As also represented in , paradigm servers  provide notations and semantics to hosts, such as the VMS host , independent from the functional use of those notations and semantics. In one implementation, a paradigm server  may comprise an ActiveX\u00ae control server dedicated to providing and controlling the model elements of a single modeling paradigm. A paradigm server (e.g., ) will often be broken apart into to separate notation and semantic servers.","In general, a notation server  provides the shapes of the paradigm, as well as the basic behaviors and rules for editing and connecting those shapes. Notation servers (e.g., ) may be implemented as VB or C++ custom control servers, or, for thin clients, they may comprise \u201cbehaviors\u201d of the rendering engine .","Semantic servers (e.g., ) provide direct access to the notation independent model (meta-data represented by the model). This is particularly useful for non-graphical hosts, like wizards and generators. Semantic servers may be COM class servers or behaviors for thin clients. By way of example, one graphic primitive server (e.g.,  of ) provides base shapes such as lines, polygons and ellipses from which more complex shapes may be constructed, i.e., it provides basic shapes to utilize as building blocks for the more complex notation objects of a paradigm server. Typical examples of controls provided by this server include base nodes ranging from simple non-sizable icons to more complex polygons or ellipses and base arcs ranging from simple node centered non-routable single segment arcs to routable multi-segment arcs with semantic adornments. These building blocks may encapsulate both shared graphical behavior such as drawing, zooming, resizing, moving, hovering, and selecting, as well as shared modeling behavior inherent in the communication protocols with the surface, the host, semantic objects, and other notation objects. Thus, many complex behaviors such as zooming, resizing, moving and surface communication protocols are built directly into these primitive shapes, which, as can be readily appreciated, significantly simplifies the building of a notation server. Notation servers and semantic servers are further described in U.S. patent application entitled \u201cPluggable Notations and Semantics for Visual Modeling Elements,\u201d assigned to the Assignee of the present invention and herein incorporated by reference.","A primitive server  shown in  (such as the graphic primitive server) may also provide any shared tools that multiple notations will likely wish to implement. For example, most model elements have some text which can often be formatted, and it would be inefficient for every paradigm server to contain its own text-formatting dialog and toolbar or in-place editing textbox. The graphic primitive server thus may contain these shared tools.","As further represented in , model persistence  may be provided as a generic pluggable component for a given tool. This component may be provided by the surface  or through a component known to the paradigm server . Persistence may be meta-model driven through information models or the paradigm server may already know the schema. More reusable paradigm servers will persist through a published persistence interface on a persistence component provided by the surface .","Model persistence is optional. If persisted, VMF models are preferably persisted in the Open Information Model (OIM) in the persistence\/repository , and therefore can automatically be used by existing and future tools. OIM is based on the Unified Modeling Language (UML), which is a graphical language for visualizing and modeling. A suitable persistence stream for VMF is XML\/VML, however additional persistence formats, such as repository objects or database record sets, may be provided to the host. Moreover, in VMF, models are persisted through published COM interfaces for OIM and UML, whereby the actual persistence component may be easily changed from repository , to database tables, to XML, or the like, without effecting the paradigm servers. This component architecture maximizes flexibility and extensibility and increases the preservation of investment in the individual components as the applications of those components change.","The model persistence\/repository  is designed to be a point of interoperability for software vendors. Any information placed in the repository  can be read, updated and extended by any application with appropriate access to that repository . Since update access is exclusively through published (e.g., COM interfaces), adding application-specific extensions through new repository interfaces does not effect those applications already leveraging the existing interfaces.","As represented in , the repository  may contain one or more models and\/or templates , each of which may be composed of packages for organization. Templates  are static instances of models in the repository . They are usually designed to be examples or good starting points for modeling a vertical market domain, however they can also be design patterns (model structure templates) that can be utilized by wizards to apply a standard architectural design to a model. Many templates can be built dynamically as the user needs them through wizards.","A model instance  includes model elements, diagrams and the projections of those model elements onto those diagrams. If the model is persisted in a versioned repository  then a model instance includes the versions of model elements, diagrams and projections. Information models  specify the schema for persisting model instances. They are meta-models of model instances and contain meta-data about those instances. For example, the repository OIM  specifies the interfaces for persisting types, components and database entities. The schema of a particular database may comprise a model instance  of this information model .","As also represented in , the surface component  may provide universal shared components  that can be shared by hosts, such as to accomplish selection, hovering, zooming, and printing functions. Larger tools that may not be required by hosts and are thus optional may be provided as separate, pluggable components . This reduces the footprint requirements of smaller VMF applications that may not need these components, and the physical separation also makes it easy to provide several alternative implementations of these components. By way of example, model-independent persistence, such as XML\/VML persistence, is a good candidate for a pluggable component because not every host will need every persistence mechanism, and indeed, some will not require a VMF provided persistence mechanism at all. As another example, automatic graph layout is a suitable candidate for a pluggable, shared component because layout algorithms are substantially different for different classes of modeling paradigms, and yet a single layout algorithm is often useful for many or all modeling paradigms within a class. Automatic layout is further described in U.S. patent application entitled\u201c Incremental and Interruptible Layout of Visual Modeling Elements,\u201d assigned to the Assignee of the present invention and herein incorporated by reference.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["204","208","406","4","408","208","202","210","406","408","300"]},"Project types can support a scenario, modeling paradigm, problem domain or an entire methodology. Virtually any scenario in the software development problem space may be addressed, e.g., abstraction layers, modeling paradigms, programming languages, product layers, product architectures, vertical market domains, development lifecycle and code architectures. Project types could be linked together into larger hierarchies to support many more complex scenarios.","Model Elements\u2014Nodes and Arcs","In general, shapes rendered on the surface are collectively referred to as model elements, (or projections). In VMF, model elements are projected onto diagrams, (which in UML terminology is somewhat analogous to a projection being a single rendering of a model element on a view element). Each model element instance projected on a diagram corresponds to exactly one model element in a repository , however the same repository  model element may be projected onto multiple diagrams or even several times onto the same diagram.","As generally represented in , each node ,  is generally an icon, polygon, ellipse or other bounded shape, whereas an arc  is generally a line (possibly multi-segmented) that connects nodes (and sometimes other arcs) together. Arcs are used to connect two model elements together, semantically forming a relationship between the two. Model elements are typically peer ActiveX\u00ae controls on a window  of the surface . Properties of the model elements are persisted in the repository .","In one preferred embodiment, each model element in a model comprises an ActiveX\u00ae control. As such, each model element can autonomously control most of its presentation and much of its notational semantics. Usually, these controls will be light, windowless controls to improve scalability of models and therefore utilize the surface or graphic primitive server to provide basic windowing capability where required. Note that while the behavior of projects and diagrams is type-specific and is implemented in the project type, and the behavior of model elements and their projections is type-specific, and is implemented in one of the paradigm servers, the behavior of other elements is type-independent and is implemented in the surface server .","Each such model element thus also includes component interfaces, the primary purpose of which is to handle component communication between model elements, between a paradigm server and the model elements it serves, and between the surface and the model elements it contains.","As also represented in , the exact point where the arc touches either of these nodes is known as the attach point. In , the two attach points are labeled  and . The two attach points are conceptually owned by the arc but are managed by the surface . For example, the surface uses the attach points to determine whether other model elements may be affected when a model element is moved or resized, e.g., if a node is moved, then all of the arcs attached to that node will need to move with it. However, the surface  cannot move the affected model elements when an attach point moves, because it has insufficient information about how those projections should react to this move. In such an instance, the surface  is responsible for raising events so that each of affected model elements can respond properly to the change.","Negotiated Interconnection","In accordance with the present invention, the visualization and modeling framework  (FIG. ), and in particular the visualization and modeling engine (VME)  of the surface , provides protocols and policies (e.g., negotiation methods ) which enable appropriate interconnections to be negotiated between model elements. In general, nodes and arcs are modeling elements, and an interconnection happens between a node and an arc or between two arcs. Note that as described above, various tools can host a visualization and modeling engine, and the present invention is flexible enough to allow intelligent interconnections in virtually any scenario.","One secondary interface (VMEAttachNegotiation) that appears on arcs and nodes that can interconnect (e.g., have arcs attach to them) is for the purpose of negotiating the interconnection, or attachment. The process of establishing an attachment between one end of an arc and a node or other arc has been designed so that interconnection may be investigated and subsequently instigated or canceled by either party. The party that is investigating a possible attachment ordinarily first determines whether it is interested in attaching to the other party. For example, some arcs may only be used to attach certain types of nodes. If the node it is investigating is not one of these types, then there is no reason to continue with the negotiation. If the investigating element is interested in continuing the negotiation, then it also needs to be determined whether the investigated element is interested in attaching to it. Note that no matter which party begins a negotiation, the arc that attaches (attacher arc) is ultimately responsible for initiating the attachment with the other element (attachee). This is because the arc actually owns the attach points. It can be readily appreciated, however, that it is essentially equivalent to provide an architecture in which the node is responsible for initiation.","To accomplish negotiation in one particular COM object-based implementation, if the investigating party is the attachee, then it calls a method, QueryAttacher, via a VMEArc interface of the attacher. If the return value is true, then the attachee should determine an appropriate attach point location and then invoke a method, InitiateAttach, of the attacher's VMEArc interface. This method will create the attach point and inform the surface of the end attachment. These and other relevant methods are described further below.","If the investigating party is the attacher, then it begins by determining if the attachee supports the VMEAttachNegotiation interface. If it does not, then the attacher may not attach to this attachee and the negotiation is complete. If the attachee does support the VMEAttachNegotiation interface, then the attacher should determine an appropriate attach point location by invoking GetNearestAttachPointX and GetNearestAttachPointY methods on the attachee's VMEAttachNegotiation interface. The attacher should then call the QueryAttachee method on the Attachee's VMEAttachNegotiation interface. If the Cancel parameter is false, then the attachee has accepted the attachment. If the attacher has an adornment (symbol at the end of the arc) then they may also need to invoke the GetNearestAttachPointAngle to determine which direction this adornment should face. Finally, the attacher should initiate the attachment by creating the attach point on the surface.","Turning to an explanation of the operation of the present invention, the flow diagram of  and the following description generally represent what takes place when a user chooses an arc and indicates in some manner that the arc should be connected to a node, if possible. For example, the user may select an arc from a displayed palette, and via a pointing device, drag it over a displayed node to which a connection is desired. As can be appreciated, many other ways of indicating a desired connection are feasible. Note that if the arc is already connected to another node, the arc will essentially be attempting to connect the two nodes together.","As the user drags an arc object (e.g., selected from a palette) over the surface , the VME  tracks the position of the arc and checks to see if the arc is hovering over any other model element. Note that although steps  and  represent this via a loop, it is understood that such hit testing is typically event driven.","Upon detection of the arc hovering over another model element (e.g., a node) at step , the VME calls into the arc (step ) and queries the arc as to whether it wants to attach (interconnect) to the node, passing in the ID of the node over which the arc is currently positioned. As generally described above, arcs and nodes are objects (e.g., COM objects), and thus along with having registered IDS, provide interfaces via which methods therein can be called. The arc can cancel the interconnection at any time, such as if it determines that it is already connected to too many other elements, and so on. If the arc does not want to attach, via step  the arc calls the VME to cancel negotiation. Cancellation, which raises an event, is described below with reference to step .","If the arc wants to attempt attachment, the arc then calls the VME  at step  to find out more about the node. For example, it ordinarily calls the VME  to find the type and subtype of the node. The node ID that the arc obtained from the VME  is used to identify and obtain this information. If the arc does not find the node type and\/or subtype to be compatible with it, via step  the arc calls the VME  to cancel negotiation.","If canceled, at step  the VME  raises an event telling all interested parties (e.g., typically the node over which the arc is positioned and the tool or tools that host the VME ) that the arc rejected the interconnection. As part of the cancellation event, the arc that rejected the interconnection, the node which was rejected, and the reason for rejection (e.g., incompatible type\/subtype) are identified. Note that any time a decision is made to continue with the negotiations, (i.e., not to cancel), a suitable event indicating that acceptable negotiations are occurring can be raised by the VME, (e.g., on appropriate branches on decision diamonds in , although for purposes of simplicity this it not separately shown herein). Parties consuming events raised during any part of the negotiations may have the power to decide the policy for interconnection. For example, the tool hosting the VME  typically acts as a policy authority, deciding whether to passively let the node\/arc interconnect, to override the node\/arc, or to give the node\/arc the veto power in the negotiation. However, the tool can designate another software entity as the policy authority so that that entity consumes the negotiation events and responds. For purposes of this example, the event-consuming parties let the node and arc make their own interconnection determination.","If the arc indicates to the VME  that it is compatible and wants to attach, the negotiation process continues to step  of  wherein the VME  calls the node on which the arc is positioned to initiate a similar operation. In general, as represented by steps -, if the node is interested in attaching, the node now gets the arc type\/subtype and can continue or cancel negotiation. If canceled, at step , the VME  raises a similar event, this time to inform interested parties (e.g., typically the arc over the node and the tool or tools that host the VME ) that the node rejected the interconnection. As part of the cancellation event, the node that rejected the interconnection, the arc which was rejected, and the reason for rejection (e.g., incompatible type\/subtype) are identified.","If both the arc and node approve each other as compatible type\/subtypes, then negotiation continues at step , wherein the VME  provides the arc with a COM interface of the node, and provides the node with a COM interface of the arc. At this time, the arc initiates direct negotiation with the node, as represented by step . The typical negotiation involves querying for scenario or domain-specific interfaces. For example, objects representing electrical appliances\/wiring will likely implement certain interfaces directed to electrical requirements to enable deeper negotiation. Once such domain-specific interfaces are obtained, the arc can call through this interface to obtain more-domain specific information of the node to fully ensure compatibility.","The arc may also find out from the VME  what other interconnections a node has. The arc can then walk through, communicating with each of those connected elements to identify and get domain specific interfaces and\/or information from them as part of its decision-making process as to whether to attach. For example, an arc representing an electrical wire of a certain gauge attaching to a node representing an electrical outlet can communicate with a node representing a circuit breaker to which the outlet is attached, in order to ensure that the wire does not exceeded its maximum allowed amperage.","Following step , when the arc has communicated with the node and any other nodes and\/or arcs, via step  of  the arc informs the VME  its acceptance or rejection of the node. If canceling, this is again raised as an event at step  by the VME  for all interested parties to receive, including relevant information as to what caused the cancellation.","Assuming negotiation has not been canceled, step  represents the operation performed by the node to obtain information from the arc. At this stage, the node is essentially given permission to continue with its side of the negotiation. In essence, the node performs the same process as the arc, e.g., obtaining domain specific interfaces, getting more information, including information from other connected nodes and\/or arcs as desired by the node, and so forth. If at the end of the node's information-gathering process the node wants to attach, the node indicates its acceptance\/rejection of the interconnection. The node can cancel or continue negotiations as represented by its decision at step , with a suitable event raised.","If the node wants to attach, the node also indicates its list of allowed attach-points for this arc, wherein an attach-point is the location on the node where an interconnection may be made. More particularly, a node may have multiple attach-points, each with its own significance. For example, for a triangle-shaped node, attachment on the vertices may have one meaning, whereas attachment on the sides may have another meaning. As a result, the node may need to decide where the arc should attach. Step  represents providing the allowed attach-points, e.g., via a list or the like. Other criteria, such as angle of attachment, may be specified.","If the negotiation results in attachment being allowable, at step  the tool typically provides a visual or other indication (e.g., changing the displayed color of the node) to indicate that the interconnection can happen. If the user desires interconnection as represented by step , the user clicks on the node or otherwise acts to effect interconnection. If the user does not effect interconnection, e.g., the user drags the arc elsewhere, the VME  may raise a suitable cancellation event. If the user selects interconnection, the VME  raises an event at step  to indicate that the interconnection happened.","Negotiation Methods","The following sets forth details for certain methods used in the above described negotiation process:","QueryAttacher(ProjectionId: Long): Boolean","The attachee calls this method to inquire whether the attacher will attach to it. The ProjectionId of the attachee is provided as a parameter. The actual attachee object can be obtained with this ProjectionId using the GetProjectionObject method on the IVMESurface interface. The arc this method was called on is the attacher. This method will return True if the attacher accepts the attachment and false if the attacher rejects the attachment.","QueryAttachee(ArcId: Long, X: Long, Y: Long, Cancel: Boolean)","This method is called by the attacher to request an attachment to the attachee. The ArcId parameter identifies the attacher and the X and Y parameters specify the point of attachment. The actual attacher Arc object may be retrieved using a GetProjectionObject method on the IVMESurface interface. The Cancel parameter is a return parameter. The attachee sets the Cancel parameter to True to reject the attachment and the attach operation will be canceled. The attachee should set the Cancel parameter to False to accept the attachment. The attacher is then responsible for actually initiating the attachment.","InitiateAttach(ProjectionId: Long, X: Long, Y: Long)","The attachee calls this method after a successful attach negotiation to commit the attachment. The ProjectionId of the attachee and the X and Y coordinates of the attach point are provided as parameters. The actual attachee object can be obtained with this ProjectionId using the GetProjectionObject method on the IVMESurface interface. The arc this method was called on is the attacher.","GetNearestAttachPointX(ArcId: Long, X: Long, Y: Long, NearestX: Long)","This method is called by the attacher to request the X coordinate of the closest attach point to the point specified by the X and Y parameters. This method should not be called until the attacher has already determined that the attachment is acceptable to the attachee by calling the QueryAttachee method. The ArcId parameter identifies the attacher. The X coordinate of the best attach point is returned as the NearestX parameter.","GetNearestAttachPointY(ArcId: Long, X: Long, Y: Long, NearestY: Long)","This method is called by the attacher to request the Y coordinate of the closest attach point to the point specified by the X and Y parameters. This method should not be called until the attacher has already determined that the attachment is acceptable to the attachee by calling the QueryAttachee method. The ArcId parameter identifies the attacher and the actual arc object may be retrieved using the GetProjectionObject method on the IVMESurface interface. The Y coordinate of the best attach point is returned as the NearestY parameter.","OnAttach (AttachPointId: Long)","This method is invoked automatically on the attachee's VMEAttachNegotiation interface by the surface when the attach point is added. Invoking this method makes the attachment officially complete. The attacher does not receive a similar message because the attacher always initiates the attachment and therefore is already aware. The AttachPointId parameter is the id of the newly created attach point. The attach point object with this Id may be retrieved using the GetAttachPointobject method on the IVMESurface interface.","OnDetach(AttachPointId: Long)","This method is invoked automatically on the attachee's VMEAttachNegotiation interface by the surface when the attach point is removed. Invoking this method makes the attachment officially over. The attacher does not receive a similar message because the attacher always initiates the detachment and therefore is already aware. The AttachPointId parameter is the ID of the removed attach point. The attach point object cannot be retrieved via this Id using the GetAttachPointObject method on the IVMESurface interface because the attach point no longer exists.","As can be seen from the foregoing detailed description, there is provided a negotiation method and system that eliminates many of the drawbacks resulting from the embedded rules and semantics of closed visualization and modeling tools. Via the component-based negotiations, the present invention provides significant extensibility, e.g., as new types of components are developed or as requirements change, new objects can be developed to handle such new components and\/or rules, without waiting for an entire new revision of a modeling tool. Moreover, because the various objects themselves handle the negotiations, the modeling tool is able to work with a far greater variety of objects, providing significant flexibility.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 6-8"}]},"DETDESC":[{},{}]}
