---
title: Methods, systems, and computer program products for identifying computer program source code constructs
abstract: Methods, systems, and computer program products for identifying computer source code constructs are disclosed. According to one method, computer source code is converted to a format suitable for an automated inference engine. The automated inference engine receives as inputs the converted source code, a set of elemental design patterns defining patterns to be identified, and a set of rules defining relationships between patterns. The automated inference engine outputs proofs indicative of patterns present in the source code. The proofs may be converted to a source code pattern report.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07627861&OS=07627861&RS=07627861
owner: THe University of North Carolina
number: 07627861
owner_city: Chapel Hill
owner_country: US
publication_date: 20041203
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","GOVERNMENT INTEREST","TECHNICAL FIELD","BACKGROUND ART","DISCLOSURE OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","REFERENCES"],"p":["This application claims the benefit of U.S. Provisional Patent Application Ser. No. 60\/527,418, filed Dec. 5, 2003; the disclosure of which is incorporated herein by reference in its entirety.","This invention was made with U.S. Government support under Grant No. R82-795901-3 awarded by United States Environmental Protection Agency. The U.S. Government has certain rights in the invention.","The subject matter described herein relates to methods, systems, and computer program products for analyzing computer program source code. More particularly, the subject matter described herein relates to methods, systems, and computer program products for identifying computer program source code constructs.","1. Related Prior Research","The decomposition and analysis of computer source code patterns is an established idea, and the concept of creating a hierarchy of related patterns has been in the literature almost as long as patterns themselves [9, 17, 29, 37]. The few researchers who have attempted to provide a truly formal basis for patterns have most commonly done so from a desire to perform refactoring of existing code, while others have attempted the more pragmatic approach of identifying core components of existing patterns in use.","Refactoring Approaches","Refactoring [14] has been a frequent target of formalization techniques, with fairly good success to date [10, 22, 25]. The primary motivation of refactoring is to facilitate tool support for, and validation of, transformation of code from one form to another while preserving behavior. This is an important step in the maintenance and alteration of existing systems and patterns are seen as the logical next abstraction upon which they should operate. These approaches, however, have one missing aspect: they lack appropriate flexibility of implementation.","Fragments: As developed by Florijm, Meijers, and van Winsen [13], fragments provide a practical implementation of pattern analysis and coding support in the Smalltalk language and demonstrate the power of application of these concepts. Their fragments are abstractions of a design elements, such as classes, patterns, methods, or code, and contain roles, or slots, which are filled by other fragments. In this way fragments are bound to each other to produce an architecture in much the same way that objects, classes, and such are in a working system, but the single definition of a fragment allows them to work with all components of the system in a singular way. This approach, while successful in assisting an engineer in working with a system, does have some limitations. For example, detection of existing patterns in the system was deemed unlikely, due to the fact that \u201cmany conceptual roles did not exist as distinct program elements, but were cluttered onto a few, more complex ones.\u201d This indicates that there may be a lower level of conceptual roles to address, below fragments.","LePuS: Eden's work on LePuS [11] is an excellent example of formalizing a language for pattern description, based on the fragments theory. LePuS lacks a tie to the more traditional formal denotational semantics of language theory, however, severely limiting its usefulness as a unifying system for code analysis. Pattern analysis and metrics are but one portion of the spectrum of tasks associated with system maintenance and design. An exquisitely elegant architecture may in fact be a poor choice for a system where performance or some other criteria is of paramount importance. System architects must have available all the relevant information for their system to be able to appropriately design and maintain it. Legacy systems, in particular, benefit from more procedural-based analysis, including cohesion and coupling metrics, slice analysis, and other data-centric approaches. One goal of the methods and systems described herein is to enhance the tools for refactoring, not only of current object-oriented systems, but of older code that may just now be being converted to an object-oriented approach. It is therefore desirable to incorporate such analysis systems into any pattern analysis framework. To not do so is to further the chasm between the abstract concepts and the concrete code, instead of unifying them, as patterns are designed to do.","Minipatterns: \u00d3 Cinn\u00e9ide's work in transformation and refactoring of patterns in code [23] is an example of the application of minipatterns, portions of patterns that are used to compose larger bodies. \u00d3 Cinn\u00e9ide treats the minipatterns as stepping stones along a refactoring path, allowing each to be a discrete unit that can be refactored under a minitransformation, in much the same way that Fowler's refactorings [14] are used to incrementally transform code at and below the object level. These minipatterns are demonstrated to be highly useful for many applications, but cannot capture some of the more dynamic behavior of patterns, instead relying heavily on syntactical constructs for evidence of the minipatterns.","Structural Analyses","An analysis of the \u2018Gang of Four\u2019 (GoF) patterns [15] reveals many shared structural and behavioral elements, such as the similarities between Composite and Visitor [15]. Relationships between patterns, such as inclusion or similarity, have been investigated by various practitioners, and a number of meaningful examples of underlying structures have been described [5, 9, 29, 36, 37].","Objectifier: The Objectifier pattern [37] is one such example of a core piece of structure and behavior shared between many more complex patterns. Its intent is to:\n\n","All of the class diagrams illustrated herein are drawn in Unified Modeling Language (UML) format. UML is a standard for graphic modeling of software. Since UML is known to those of skill in the art of computer software development, a detailed description thereof will not be presented herein. The UML standard is described in a number of commercially-available publications, including Fowler, Martin, UML Distilled: A Brief Guide to the Standard Object Modeling Language, Third Edition, Addison-Wesley 2004, the disclosure of which is incorporated herein by reference in its entirety.","Zimmer uses Objectifier as a \u2018basic pattern\u2019 in the construction of several other GoF patterns, such as Builder, Observer, Bridge, State, Command and Iterator. It is a simple yet elegantly powerful structural concept that is used repeatedly in other patterns.","Object Recursion: Woolf takes Objectifier one step further, adding a behavioral component, and naming it Object Recursion [36].  is a class diagram illustrating the Object Recursion class structure. The class diagram in  is extremely similar to Objectifier, with an important difference, namely the behavior in the leaf subclasses of Handler. Exclusive of this method behavior, however, it seems to be an application of Objectifler in a more specific use. Note that Woolf compares Object Recursion to the relevant GoF patterns and deduces that: Iterator, Composite and Decorator can, in many instances, be seen as containing an instance of Object Recursion; Chain of Responsibility and Interpreter do contain Object Recursion as a primary component.","Relationships: Taken together, the above instances of analyzed pattern findings comprise two parts of a larger chain: Object Recursion contains an instance of Objectifler, and both in turn are used by larger patterns. This indicates that there are meaningful relationships between patterns, yet past work has shown that there are more primary forces at work. Buschmann's variants [7], Coplien and others' idioms [4,9,20], and Pree's metapatterns [27] all support this viewpoint. Shull, Melo and Basili's BACKDOOR's [31] dependency on relationships is exemplary of the normal static treatment that arises. It will become evident that these relationships between concepts are a core piece which grant great flexibility to the practitioner implementing patterns in design, through constructs we term isotopes, which will be treated in Section 4 13. A related, but type-based approach that works instead on UML expressed class designs, is Egyed's UML\/Analyzer system [12] which uses abstraction inferences to help guide engineers in code discovery. Reiss's PEKOE [28] uses a relational database language for queries and conceptual component definition.","Accordingly, in light of the difficulties associated with conventional source code analysis methods, there exists a need for improved methods and systems for identifying computer program source code constructs.","Accordingly to one aspect, the subject matter described herein includes a method for detecting constructs in computer program source code in a manner that is independent of underlying source code variations used to implement the source code constructs. The method includes converting a first computer source code file into a fact set in a mathematical notation suitable for inputting into an automated inference engine, such as an automated theorem prover or a deductive database. A catalog including elemental design patterns (EDPs) and constructs composed of element design patterns used for identifying source code constructs is accessed. The elemental design patterns and the constructs are independent from source code semantic tags. A set of rules in the mathematical notation usable by the automated inference engine is accessed to identify relationships between source code constructs. The fact set, the catalog, and the rules are input to the automated inference engine for identifying constructs present in the computer source code file.","As described in the preceding paragraph, the methods and systems described herein are capable of identifying source code constructs independently of the source code semantic tags. A source code semantic tag includes any semantic information contained in the naming of source code elements, such as a method named doHighlightingOfText, or a data field named highestAltitudeReached. The name explains what it does by description. By identifying source code constructs independently of the underlying source code naming conventions, the methods and systems described herein can identify common source code structure, regardless of the naming conventions used by individual programmers.","The methods and systems described herein can be implemented in hardware, software, firmware, or any combination thereof. In one exemplary implementation, the methods and systems for identifying computer source code constructs may be implemented as computer program products comprising computer-executable instructions embodied in computer-readable media. Exemplary computer-readable media suitable for implementing the methods and systems described herein include optical, electrical, and magnetic memory storage devices.","The sections below described methods and systems for identifying computer source code constructs and how they overcome the shortcomings of previous methods. In section 2, formal semantics that underlie the methods and systems described herein, including formalizations for elemental design patterns, pattern isotopes, and an extension of the object calculus, referred to herein as rho-calculus, are described. In section 4 exemplary tools to put this EDP-based approach into practice are described. A detailed example of how the tools find patterns in source code is then described. In section 5 extensions for both EDPs and the tools are described.","Accordingly, it is an object of the subject matter described herein to provide methods, systems, and computer program products for identifying computer source code constructs.","It is another object of the subject matter described herein to provide methods, systems, and computer program products for identifying computer source code constructs independently of the syntax of the underlying source code.","Some of the objects of the subject matter described herein having been stated hereinabove, and which are addressed in whole or in part by the subject matter described herein present invention, other objects will become evident as the description proceeds when taken in connection with the accompanying drawings as best described hereinbelow.","2. EDPs, Isotopes, and Automated Inference","Elemental Design Patterns and the rho-calculus would be interesting academic exercises only, unless there were good reasons for performing this work. Three applications, including as an education tool, a set of concepts for programming language design, and a formal basis for source code analysis tools will be described in detail below.","2.1. Elemental Design Patterns","Elemental Design Patterns are design patterns that cannot be decomposed into smaller patterns\u2014they sit one level above the primitives of object-oriented programming, such as objects, fields, and methods. As such, they occupy much of the same space as idioms, but are language independent, relying only on the core concepts of object-oriented theory. They perform the same conceptual task as the more common design patterns however, in that they provide solutions to common programming situations, and do so in orthogonal ways, differing only in scope. EDPs are the foundational nuts and bolts from which conceptual design frameworks are created. Also, relying only on the theoretical basis object-oriented, they have one distinct advantage over other approaches directly involving design patterns: they are formalizable. According to an aspect of the subject matter described herein the sigma-calculus, as described in [1], has been extended with a small set of relationship operators that provide a simple but solid basis, the rho calculus, from which to perform interesting analyses.","EDP and SPQR Summary","According to one aspect of the subject matter described herein, a system for pattern query and recognition (SPQR) is provided. The SPQR [34] improves on previous approaches for finding design patterns in source code. Other systems have been limited by the difficulty of describing something as abstract as design patterns. A single design pattern when reduced to concrete code can have myriad realizations, all of which have to be recognized as instances of that one pattern. Other systems have encountered difficulty in spanning these possible implementation variations, due to their reliance on static definitions of patterns and variants. SPQR overcomes this problem by using an inference engine based on core concepts and semantic relationships. The formal foundation of SPQR defines base patterns and rules for how variation can occur, and the inference engine is free to apply variation rules in an unbounded manner. A finite number of definitions in SPQR can match an unbounded number of implementation variations.","The concepts contained in patterns are those that the professional community has deemed important and noteworthy, and they are ultimately expressed as source code that is reducible to a mathematically formal notation. The core concepts themselves have evaded such formalization to date. The methods and systems described herein illustrate that such a formalization is possible, and in addition that it can meet certain essential criteria. Applications of the methods and systems described herein as tools for the developer with a need for extracting patterns from an existing system are also described.","Such a formal solution should be implementation language independent, much as design patterns are, if it is truly to capture universal concepts of programming methodology. A formal denotation for pattern concepts should be a larger part of the formal semantics literature. Patterns are built on the theory and concepts of object-oriented programming, as surely as object-oriented approaches are built on procedural theory.","The formal foundation of the methods and systems described herein is composed of two parts: the fundamental concepts of object-oriented programming and design (Elemental Design Patterns, or EDPs), and the rules for their variation and composition (rho calculus). The EDPs were deduced through careful analysis of the Gang of Four (GoF) design patterns [15] for use of core object-oriented language concepts (such as inheritance, delegation, recursion, etc); this analysis produced eleven EDPs from which the GoF patterns can be composed. It also produced a design space which was filled out to produce sixteen comprehensive EDPs. These additional EDPs may prove useful in defining design patterns from other sources.","2.2 Exemplary System Architecture and Overall Operation",{"@attributes":{"id":"p-0068","num":"0068"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["300","302","302","302","304","306","302","308"]},{"@attributes":{"id":"p-0069","num":"0069"},"figref":["FIG. 4","FIG. 3","FIG. 4","FIG. 3","FIG. 4"],"b":["400","300","402","304","404","306","406","302"]},"3. Theory: EDPs, Isotopes, and Rho-Calculus","In this section more complete discussions of the generation of elemental design patterns and a formal presentation of the rho-calculus will be provided. The Elemental Design Patterns were deduced through analysis of the existing design pattern literature and then extended to comprehensively cover the most interesting ways in which objects can interact in object-oriented programming. The sixteen EDPs comprise the core of any design space.","3.1. Examination of Design Patterns","The first task undertaken was to examine the existing canon of design pattern literature, and a natural place to start is the ubiquitous Gang of Four text [15]. Instead of a purely structural inspection, common concepts used in the patterns were identified. A first cut of analysis resulted in eight identified probable core concepts:\n\n",{"@attributes":{"id":"p-0072","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Calling Styles in Gang of Four Patterns"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Obj","Method",{},{}]},{"entry":["Ownership","Type","Type","Abstract","Used In"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["N\/A","self","diff","Y","Template Method,"]},{"entry":[{},{},{},{},"Factory Method"]},{"entry":["N\/A","super","diff",{},"Adapter (class)"]},{"entry":["N\/A","super","same",{},"Decorator"]},{"entry":["held","parent","same","Y","Decorator"]},{"entry":["held","parent","same",{},"Composite, Interpreter,"]},{"entry":[{},{},{},{},"Chain of Responsibility"]},{"entry":["ptr","sibling","same",{},"Proxy"]},{"entry":["ptr\/held","none","none","Y","Builder, Abstract"]},{"entry":[{},{},{},{},"Factory, Strategy, Visitor"]},{"entry":["held","none","none","Y","State"]},{"entry":["held","none","none",{},"Bridge"]},{"entry":["ptr","none","none",{},"Adapter (object),"]},{"entry":[{},{},{},{},"Observer, Command,"]},{"entry":[{},{},{},{},"Memento"]},{"entry":["N\/A",{},{},{},"Mediator, Flyweight"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["Iteration\u2014A runtime behavior indicating repeated stepping through a data structure. It may or may not be possible to create an appropriate pattern-expressed description, but it would be highly useful in such patterns as Iterator and Composite.","Invariance\u2014Encapsulates the concept that parts of a hierarchy or behavior do not change. The Invariance EDP is used by Strategy and Template Method.","AggregateAlgorithm\u2014Demonstrates how to build a more complex algorithm out of parts that do change polymorphically. The AggregateAlgorithm EDP is used in Template Method.","CreateObject\u2014Encapsulates creation of an object, similar to \u00d3 Cinn\u00e9ide's Encapsulate Construction minipattern [23]. The CreateObject EDP is used in most Creational Patterns."]}},"Of the EDPs listed above, AbstractInterface, DelegatedImplementation and Retrieval could be considered simplistic, while Iteration and Invariance are, on the face of things, extremely difficult.","On inspection, five of these possible patterns are centered around some form of method invocation. This led to the investigation of what the critical forms of method calling truly are and whether they could provide insights towards producing a comprehensive collection of EDPs. For the sake of this investigation, a dynamically bound language environment is assumed, but not required. No assumptions regarding features of implementation languages were made. Categorizing the various forms of method calls in the GoF patterns can be summarized as in Table 1, grouped according to four criteria.","Assume that an object a of type A has a method f that the program is currently executing. This method then internally calls another method, g, on some object, b, of type B. The columns in Table 1 represent, respectively, how a references b, the relationship between A and B, if any, the relationship between the types of f and g, whether or not g is an abstract method, and the patterns that this calling style is used in. Note that this is all typing information that is available at the time of method invocation, since only the types of the objects a and b and the methods f and g are being inspected. Polymorphic behavior may or may not occur, but a runtime analysis is not being performed. This is strictly an analysis based on the point of view of the calling code.","If the ownership attribute is eliminated, the table vastly simplifies, as well as reducing the information to strictly type information. In a dynamic language, the concept of ownership begins to break down, reducing the question of access by pointer or access by reference to a matter of implementation semantics in many cases. By reducing that conceptual baggage in this particular case, such traits can be later reintroduced. Similarly, other method invocation attributes could be assigned, but do not fit within the present typing framework for classification. For instance, the concept of constructing an object at some point in the pattern is used in the Creational Patterns: Prototype, Singleton, Factory Method, Abstract Factory, and Builder, as well as others, such as Iterator and Flyweight. This reflects the CreateObject component, but can be placed aside for now to concentrate on the typing variations of method calls.",{"@attributes":{"id":"p-0077","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Final Method Calling Styles in Gang of Four Patterns"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Obj","Method",{}]},{"entry":[{},"Type","Type","Used In"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","self","diff","Template Method, Factory Method"]},{"entry":["2","super","diff","Adapter (class)"]},{"entry":["3","super","same","Decorator"]},{"entry":[{},"parent","same","Composite, Interpreter, Chain of"]},{"entry":[{},"sibling","same","Responsibility, Decorator"]},{"entry":["4","none","none","Proxy"]},{"entry":["5",{},{},"Builder, Abstract Factory, Strategy, Visitor,"]},{"entry":["6",{},{},"State, Bridge"]},{"entry":[{},{},{},"Adapter (object), Observer, Command,"]},{"entry":[{},{},{},"Memento"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Table 1 can be reorganized, removing the Mediator and Flyweight entry on the last line, as no typing attributable method invocations occur within those patterns. State and Bridge can be merged into the appropriate calling styles. After margining State and Bridge, four of the remaining list of EDPs are simply variations on whether the called method is abstract or not. By identifying this as an instance of the AbstractInterface component from above, this list can be further simplified to a final collection of the six primary method invocation styles in the GoF text, shown in Table 2. Reincorporation of AbstractInterface to rebuild the calling styles used in the original patterns will be described in detail below.","A glance at the first column of Table 2 reveals that it can be split into two larger groups, those which call a method on the same object instance (a=b) and those which call a method on another object (a\u2260b). The method calls involved in the GoF patterns now can be classified by three orthogonal properties:\n\n","This last item recurs often in analysis, and once it is realized that it is the application of Beck's Intention Revealing Message best practice pattern [4], it becomes apparent that this is an important concept, referred to herein as similarity.","3.2. Method Call EDPs","The first axis in the above list is simply a dichotomy between Self and Other. The second describes the relationship between A and B, if any, and the third compares the types (consisting of a function mapping type, F and G, where F=X\u2192Y for a method taking an object of type X and returning an object of type Y) of f and g, simply as another dichotomy of equivalence.","It is illustrative at this point to attempt creation of a comprehensive listing of the various permutations of these axes, and see where the invocation styles identified herein fall into place. For the possible relationships between A and B, the list items may include \u2018Parent\u2019, where A<: B, \u2018Sibling\u2019 where A<: C and B<: C: for some type C, and \u2018Unrelated\u2019 as a collective bin for all other type relations at this point. The notation<: is taken from Abadi and Cardelli's calculus [1]. A<: B reads, \u201cA is a subtype of B.\u201d To these items, \u2018Same\u2019 or A=B can be added as a simple type relation between the objects.","3.2.1. Initial List","The invocation styles can be filled in from the final list from the GoF patterns, mapping them to the six categories in Table 2:",{"@attributes":{"id":"p-0084","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1. Self (a = b)",{}]},{"entry":[{},"(a) Self (A = B, or a = this)"]},{"entry":[{},"i. Same (F = G)"]},{"entry":[{},"ii. Different (F \u2260 G)","Conglomeration[1]"]},{"entry":[{},"(b) Super (A <: B, or a = super)"]},{"entry":[{},"i. Same (F = G)","ExtendMethod[3]"]},{"entry":[{},"ii. Different (F \u2260 G)","RevertMethod[2]"]},{"entry":[{},"2. Other (a \u2260 b)"]},{"entry":[{},"(a) Unrelated"]},{"entry":[{},"i. Same (F = G)","Redirect[6]"]},{"entry":[{},"ii. Different (F \u2260 G)","Delegate[6]"]},{"entry":[{},"(b) Same (A = B)"]},{"entry":[{},"i. Same (F = G)"]},{"entry":[{},"ii. Different (F \u2260 G)"]},{"entry":[{},"(c) Parent (A <: B)"]},{"entry":[{},"i. Same (F = G)","RedirectInFamily[4]"]},{"entry":[{},"ii. Different (F \u2260 G)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(d) Sibling (A <: C, B <: C, A is not a subtype of B)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i. Same (F = G)","RedirectInLimitedFamily[5]"]},{"entry":[{},"ii. Different (F \u2260 G)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Each of the categories listed above captures a concept as much as a syntax. Each expresses a direct and explicit way to solve a common problem, providing a structural guide as well as a conceptual abstraction. In this way they fulfill the requirements of a pattern, as generally defined, and more importantly, given a broad enough context and minimalist constraints, fulfill Alexander's original definition as well as any decomposable pattern language can [2]. These categories are described herein as meeting the definition of design patterns.","The EDP nomenclature used herein is a reflection of the intended uses of the various constructs, but requires some defining:\n\n","A complete list of method call EDPs is provided below.",{"@attributes":{"id":"p-0088","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1. Self (a = b)",{}]},{"entry":[{},"(a) Self (a = this)"]},{"entry":[{},"i. Same (F = G)","Recursion"]},{"entry":[{},"ii. Different (F \u2260 G)","Conglomeration"]},{"entry":[{},"(b) Super (a = super)"]},{"entry":[{},"i. Same (F = G)","ExtendMethod"]},{"entry":[{},"ii. Different (F \u2260 G)","RevertMethod"]},{"entry":[{},"2. Other (a \u2260 b)"]},{"entry":[{},"(a) Unrelated"]},{"entry":[{},"i. Same (F = G)","Redirect"]},{"entry":[{},"ii. Different (F \u2260 G)","Delegate"]},{"entry":[{},"(b) Same (A = B)"]},{"entry":[{},"i. Same (F = G)","RedirectedRecursion"]},{"entry":[{},"ii. Diff (F \u2260 G)","DelegatedConglomeration"]},{"entry":[{},"(c) Parent (A <: B)"]},{"entry":[{},"i. Same (F = G)","RedirectInFamily"]},{"entry":[{},"ii. Different (F \u2260 G)","DelegateInFamily"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(d) Sibling (A <: C, B <: C, A is not a subtype of B)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i. Same (F = G)","RedirectInLimitedFamily"]},{"entry":[{},"ii. Different (F \u2260 G)","DelegateInLimitedFamily"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Recursion -- a concrete link between primitive language features and EDPs."]},{"entry":[{},"RedirectedRecursion -- a form of object level iteration."]},{"entry":[{},"DelegatedConglomeration -- gathers behaviors from external instances of the current class."]},{"entry":[{},"DelegateInFamily -- gathers related behaviors from the local class structure."]},{"entry":[{},"DelegateInLimitedFamily -- Limits the behaviors selected to a particular base definition."]}]}}]}},"br":{}},"At this point a fairly comprehensive array of method\/object invocation relations has been described. The original list of concepts culled from the GoF patterns can now be re-visited. Of the original eight, three are absorbed within the method invocations list: DelegatedImplementation, ExtendMethod, and AggregateAlgorithm. Of the remaining five, two are some of the more problematic EDPs to consider: Iteration, and Invariance. These can be considered sufficiently difficult concepts at this stage of the research and they will be more fully explored in the proposed project.","The remaining three EDPs, CreateObject, AbstractInterface, and Retrieve, deal with object creation, method implementation, and object referencing, respectively. These are core concepts of what objects and classes are and how they are defined. CreateObject creates instances of classes, AbstractInterface determines whether or not that instance contains an implementation of a method, and Retrieve is the mechanism by which external references to other objects are placed in data fields. These are the elemental creational patterns and they provide the construction of objects, methods, and fields. Since these are the three basic physical elements of object oriented programming [1], they provide a complete base core of EDPs for this classification. Classes, prototypes, traits, selectors, and other aspects of various object oriented languages are expressible using only the three constructs identified [1].\n\n","The method invocation EDPs from the previous section are descriptions of how these object elements interact, defining the relationships between them. One further relationship is missing, however: that between types. Subtyping is a core relationship in object-oriented languages, usually expressed though an inheritance relation between classes. Subclassing, however, is not equivalent to subtyping [1], and should be noted as a language construct extension to the core concepts of object-oriented theory. Because of this, a typing relation EDP, inheritance, that creates a structural subtyping relationship between two classes is introduced. Not all languages directly support inheritance. For example, some languages rely on dynamic subtyping analysis to determine appropriate typing relations. Examples of such language include prototype-based languages, such as Cecil [8] or Newton Script [3].\n\n","Desired traits of a formalization language include that it be mathematically sound, consist of simple reduction rules, have enough expressive power to encode directly object-oriented concepts, and have the ability to encode flexibly relationships between code constructs. The sigma calculus [1] is used herein as a formal basis, given the above requirements. It is a formal denotational semantics that deals with objects as primary components of abstraction and has been shown to have a highly powerful expressiveness for various language constructs.","A subset of sigma-calculus is described herein for the purposes of illustrating the operation of the methods and systems for identifying source code constructs described herein. Specifically, the concepts of type definition, object typing, and type subsumption (inheritance) are used. A type T is defined by T\u2261[ . . . ], where the contents of the brackets are method and field definitions. An object O is shown to be of type T by O:T. If type T\u2032 is a subtype of type T, such as it would be under inheritance, then T\u2032<:T.","3.5 Rho Calculus","The EDPs are useful in many areas as they stand, but for formal analysis of source code, an approach that would provide a semantic basis for logical inferences was needed. Rho-calculus is the formal foundation of the EDP catalog. It allows facts about a codebase to be encoded into a simple yet powerful notation that can be directly input to automated theorem provers, such as the OTTER system used in SPQR. Without this, the EDPs would be conceptually useful but impractical to use in an automated tool system.","This section defines the rho fragment (\u0394) of the rho-calculus which results when this fragment is added to the sigma-calculus. By defining this as a calculus fragment, researchers can add it to the proper mix of other fragments defined in [1] to create the particular formal language they need to achieve their goals.","3.6. Definitions","Let O be defined as the set of all objects instantiated within a given system. Then \u03b5O is some object in the system. Similarly, let M be the set of all method signatures within the system. Then \u03bc\u03b5M is some method signature in the system. .\u03bc is then the selection of some method signature imposed on some object. We make no claim here that this is a well-formed selection, and in fact we have no need to\u2014the underlying sigma-calculus imposes that construct for us. \u03c4 is some type in the set of all types T defined in the system such that if  is of type \u03c4, then : \u03c4\n\n\u03b5O, \u03bc\u03b5M, \u03c4\u03b5T\n","Let A be either an object  or a method selection .\u03bc. Let A\u2032 be another such set for distinct object and method selections. (By convention, the base forms of the symbols will appear on the left side of the reliance operator (relop), and the prime forms will appear on the right hand side to indicate distinct items.) \u03c7 is a signifier that a particular reliance operator may be one of our five variants: {\u03bc, \u03c6, \u03c3, \u03ba, \u03b3}. \u03bc is a method selection reliance, \u03c6 is a field reliance, \u03c3 is a state change reliance, \u03ba is a data cohesion reliance, and \u03b3 is a \u2018generalized\u2019 reliance where a reliance is known, but the exact details are not. (It is analogous to more traditional forms of coupling theory.)  an operator trait indicator, allowing for the three types of reliance specialization (+, \u2212, o) to be abstracted in the following rules. The appearance of this symbol indicates that any of the three may exist there.\n\nA={, . \u03bc}\n\nA\u2032={\u2032, \u2032. \u03bc\u2032}\n\n\u03c7={\u03bc, \u03c6, \u03c3, \u03ba, \u03b3}\n\n={+, \u2212, }\n","The basic reliance operator symbol, <, was selected to be an analogue to the inheritance\/subsumption of types indicator in sigma calculus, <:, which can be interpreted to mean a reliance of type. Since the typing symbol is :, this leaves <as a natural for the concept of \u2018reliance on\u2019. This, combined with our three symbols from \u03c7 above, gives rise to five reliance operators: <, <, <, <<.","3.7. Creation","Three rules create instances of reliance operators. The first rule is the Method Invocation Relop rule which states that given a method \u03bc invoked on object , if that method contains a method invocation call to method \u03bc\u2032 of another object \u2032, a method reliance exists between the two, indicated by the \u03bc form reliance operator (<):",{"@attributes":{"id":"p-0100","num":"0122"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mo":"\u00b7","mi":"\u03bc"},{"mo":["[","]"],"mrow":{"mi":"\u03bc","mo":"=","mrow":{"mrow":[{"mi":"\u03c2","mo":["(",")"]},{"msup":[{"mi":"\u2032"},{"mi":["\u03bc","\u2032"]}],"mo":"\u00b7"}],"mo":"\u2062"}}}],"mo":"\u2261"},{"mrow":[{"mo":"\u00b7","mi":"\u03bc"},{"msup":[{"mi":"\u2032"},{"mi":["\u03bc","\u2032"]}],"mo":"\u00b7"}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03bc"}}]}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}},"br":{},"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00017","he":"3.13mm","wi":"2.12mm","file":"US07627861-20091201-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00018","he":"3.13mm","wi":"2.12mm","file":"US07627861-20091201-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]},"A similar rule can be used for deriving an instance of a field reliance operator. This one states that if an object's method .\u03bc contains a reference to another object \u2032, then there is a reliance between the two based on reference access of the field, indicated by the \u03c6 form reliance operator (<). This is the Method Field Relop rule:",{"@attributes":{"id":"p-0102","num":"0124"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mo":"\u00b7","mi":"\u03bc"},{"mo":["[","]"],"mrow":{"mi":"\u03bc","mo":"=","mrow":{"mrow":{"mi":"\u03c2","mo":["(",")"]},"mo":"\u2062","msup":{"mi":"\u2032"}}}}],"mo":"\u2261"},{"mrow":{"mo":"\u00b7","mi":"\u03bc"},"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"},"msup":{"mi":"\u2032"}}]}},{"mrow":{"mo":["(",")"],"mn":"2"}}]}}}}},"Similarly, if an object \u2032 is referenced as an instance variable data field of an object , then the Object Field Relop rule can be used:",{"@attributes":{"id":"p-0104","num":"0126"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mo":":","mi":"\u03c4"},{"mi":"\u03c4","mo":"=","mrow":{"mo":["[","]"],"mrow":{"msup":[{"mi":"\u2032"},{"mi":["\u03c4","\u2032"]}],"mo":":"}}}],"mo":","},{"msup":[{"mi":"\u2032"},{"mi":"\u2032"}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}}]}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}}},"Possible state changes in an object can actually now be detected. Assume that the only way to perform imperative side-effects on an object's state is through calling a method of that object.","Assume an object  with methods f and g, and state instance object  which has it's own method h: : \u03c4, \u03c4=[f: \u03c4\u2032, g: \u03c4\u2033, : \u03c4\u2032\u2033], \u03c4\u2032\u2033=[h: \u03c4\u2033\u2033]. The only way a state change of  can happen is if h is called on , since that's the only way  is going to change state. Since \u2032 is hidden, only  can call . h, and only .f or .g call do so. The only time we would care is if .f or .g relied on \u2032 for some reason.","So, if for some \u03bc in the method dictionary of , and some \u03bc\u2033 in the method dictionary of \u2032, .\u03bc calls . \u2032\u03bc\u2033, and for some \u03bc\u2032 in the method dictionary of , . \u03bc\u2032 relies on . \u2032 for any reason, then . \u03bc\u2032 relies on a *possible* state change by . \u03bc in the State Change Relop:",{"@attributes":{"id":"p-0108","num":"0130"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mrow":[{"mo":"\u00b7","mi":"\u03bc"},{"mrow":{"mo":"\u00b7","msup":{"mi":"\u2032"}},"mo":"\u2062","msup":{"mi":["\u03bc","\u2033"]}}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03bc"}},{"mrow":[{"mo":"\u00b7","msup":{"mi":["\u03bc","\u2032"]}},{"mo":"\u00b7","msup":{"mi":"\u2032"}}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}}],"mo":","},{"mrow":[{"mo":"\u00b7","msup":{"mi":["\u03bc","\u2032"]}},{"mo":"\u00b7","mi":"\u03bc"}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c3"}}]}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}},"br":{}},"Further details of the relationships between the operands of the reliance operators can be determined by inspecting the method signatures or the object instances for the relops, reflecting the similarity trait found in the EDP Catalog.","Similarity is a formalization of the concept behind Kent Beck's Intention Revealing Message best practice pattern [4], in which Beck states \u201cName methods after what they accomplish.\u201d Following this pattern means that if we see two methods with the same name, then we can deduce that for most cases, they are intended to perform similar, if not exactly, the same task. This concept can be extended to a more generalized form: \u201cSimilarly named methods, fields, and classes are likely to have similar intent, behaviour, or function.\u201d We call these entities similar.","On each side of a reliance operator, there is a construct of the form lhs.rhs. These two sides of the dot operator are referred to respectively as leftdot and dotright, to distinguish them from the left hand side and right hand side of the reliance operator itself. We can take each of these construct halves and perform a similarity analysis, which in this case is done by a simple lexicographic equality. Other, more sophisticated analyses such as semantic analysis or retrieving known semantic information from a database are other possible approaches.","After establishing that two entities are similar, we can note this in the formalization by (+). If we can prove that two entities are definitively not similar, we refer to them as dissimilar, noted as (\u2212). If similarity or dissimilarity has not been established, then the similarity is said to be indeterminant, shown by (\u2218).","Once a similarity relationship is established between either the leftdot or rightdot entities, it can be added to the reliance operator as so: <. The similarity trait is patterned after the construct found in leftdot and dotright. The similarity trait on the left side of the dot indicates any relationship between the leftdot entities, while the right side of the similarity trait and the dotright entities have an equivalent correspondence.","For example, assume that we have an object O with method m that calls method m\u2032 of object O\u2032. This mu-form relop can be shown as:\n\nO.m<O\u2032.m\u2032\u2003\u2003(5)\n","This is the most general form, indicating no known similarity relationships, either positive or negative. Now, if we can ascertain that O and O\u2032 are indeed the same object, we can add that relationship to the relop:\n\nO.m< O\u2032.m\u2032\u2003\u2003(6)\n","Note that the \u2218 is used as a placeholder to make the notation more clear, but establishing that the dotright correlation is unknown. Likewise, if we can ascertain that m and m\u2032 have the same method signature (indicating a similar intent), then we can add that to the relop:\n\nO.m< O\u2032.m\u2032\u2003\u2003(7)\n","This is the core of the formalization of the Recursion EDP, and demonstrates how the rho-calculus provides a solid basis for formal analysis of the EDPs. If, however, we are able to establish that the leftdot entities are in fact not the same, then we can indicate this as well, leading to the formal basis for the Redirect EDP:\n\nO.m<O\u2032.m\u2032\u2003\u2003(8)\n\nIn this way we can establish similarity or dissimilarity relationships and convey them in a straightforward and clear manner in the formal notation. This approach works for all five relop forms, and provides a strong semantic clue as to the conceptual relationship between the entities on either side of the relop.\n\n3.9. Transitivity\n","Transitivity is the process by which large chains of reliance can be reduced to simple facts regarding the reliance of widely separated objects in the system. The five forms of relop all work in the same manner in these rules. The specialization trait of the relop (\u00b1) is not taken into consideration, and in fact can be discarded during the application of these rules\u2014appropriate traits can be re-derived as needed.","Given two relop facts, such that the same object or method invocation appears on the dotright of the first and the leftdot of the second, then the leftdot of the first and dotright of the second are involved in a reliance relationship as well. If the two relops are of the same form, then the resultant relop will be the same as well.",{"@attributes":{"id":"p-0120","num":"0142"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mfrac":{"mrow":[{"mrow":[{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c7"},"msup":{"mi":["A","\u2032"]}},{"msup":[{"mi":["A","\u2032"]},{"mi":["A","\u2033"]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","msup":{"mi":["\u03c7","\u2032"]}}}],"mo":","},{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c7"},"msup":{"mi":["A","\u2033"]}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","f","\u03c7"]},"mo":"=","msup":{"mi":["\u03c7","\u2032"]}}},{"mrow":{"mo":["(",")"],"mn":"9"}}]}}}}},"If, however, the two relops are of different forms, then the resultant relop is our most general form, \u03b3. This indicates that while a relationship exists, we can make no hard connection according to our definitions of the other four forms. Note that this is the only point at which \u03b3 form relops are created.",{"@attributes":{"id":"p-0122","num":"0144"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mfrac":{"mrow":[{"mrow":[{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c7"},"msup":{"mi":["A","\u2032"]}},{"msup":[{"mi":["A","\u2032"]},{"mi":["A","\u2033"]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","msup":{"mi":["\u03c7","\u2032"]}}}],"mo":","},{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03b3"},"msup":{"mi":["A","\u2033"]}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","f","\u03c7"]},"mo":"\u2260","msup":{"mi":["\u03c7","\u2032"]}}},{"mrow":{"mo":["(",")"],"mn":"10"}}]}}}}},"This is the key element of our isotopes, which allow design patterns to be inferred in a flexible manner. We do not require each and every variation of a pattern to be statically encoded, instead the transitivity in the rho-calculus allows us to simply encode the relationships between elements of the pattern, and an automated theorem power can infer as many possible situations as the facts of the system provide. In this way a massive search space can be created automatically from a small number of design pattern definitions.","3.10. Generalizations","These are generalizations of relops, the opposite of the specialization rules earlier. Each of them generalizes out some piece of information from the system that may be unnecessary for clear definition of certain rules and situations. Information is not lost to the system, however, as the original statements remain.","The first two generalize the right hand side and left hand sides of the relop, respectively, removing the method selection but retaining the object under consideration. They are RHS Generalization and LHS Generalization.",{"@attributes":{"id":"p-0126","num":"0148"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mfrac":{"mrow":[{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03c7","mo":"\u2062","mover":{"mi":"\u00b0","mo":"\u00b1"}}},"mrow":{"msup":[{"mi":"\u2032"},{"mi":["\u03bc","\u2032"]}],"mo":"\u00b7"}},{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03c7","mo":"\u2062","mover":{"mi":"\u00b0","mo":"\u00b1"}}},"msup":{"mi":"\u2032"}}]}},{"mrow":{"mo":["(",")"],"mn":"11"}}]},{"mtd":[{"mfrac":{"mrow":[{"mrow":{"mo":"\u00b7","mi":"\u03bc"},"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03c7","mo":"\u2062","mover":{"mi":"\u00b0","mo":"\u00b1"}}},"msup":{"mi":["A","\u2032"]}},{"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03c7","mo":"\u2062","mover":{"mi":"\u00b0","mo":"\u00b1"}}},"msup":{"mi":["A","\u2032"]}}]}},{"mrow":{"mo":["(",")"],"mn":"12"}}]}]}}},"br":{}},{"@attributes":{"id":"p-0127","num":"0149"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c7"},"msup":{"mi":["A","\u2032"]}},{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03b3"},"msup":{"mi":["A","\u2032"]}}]}},{"mrow":{"mo":["(",")"],"mn":"13"}}]}}}},"br":{}},{"@attributes":{"id":"p-0128","num":"0150"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["\u03c7","\u03bc"],"mo":"="},"mo":",","mi":"\u03d5"}},"mo":"\u2062","mfrac":{"mrow":[{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","msup":{"mi":"\u03c7","mo":"\u00b1"}},"msup":{"mi":["A","\u2032"]}},{"mi":"A","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c7"},"msup":{"mi":["A","\u2032"]}}]}}},{"mrow":{"mo":["(",")"],"mn":"14"}}]}}}},"br":{}},"It would seem natural to use types instead of actual objects in the reliance operators, but there is a fundamental incompatibility between \u0394\u03c1 and subsumption of types which makes this approach difficult for most practical applications of our analysis technique. Instead, since we are directly analyzing source code, we have the opportunity to use more information regarding object instances than would be evident in class diagramming notations such as UML.\n\nFamilyHead\u2261[operation: A]\u2003\u2003(15)\n\nRedirector<: FamilyHead\u2003\u2003(16)\n\nRedirector\u2261[target: Family Head, operation: A=\u03b6(\u03c7){target.operation}]\u2003\u2003(17)\n\nr: Redirecter\u2003\u2003(18)\n\nfh: FamilyHead\u2003\u2003(19)\n\nr.target=fh\u2003\u2003(20)\n\n3.12. Example: RedirectInFamily\n","Consider the class diagram for the structure of the EDP RedirectInFamily [33], in . Taken literally, it specifies that a class wishes to invoke a \u2018similar\u2019 method (where similarity is evaluated based on the signature types of the methods, as hinted at by Beck's Intention Revealing Message best practice pattern [4]: equivalent signatures are \u2018similar\u2019, nonequivalent signatures are \u2018dissimilar\u2019) to the one currently being executed, and it wishes to do so on an object of its parent-class' type. This sort of open-ended structural recursion is a part of many patterns.","If we take the Participants specification of RedirectInFamily, we find that:\n\n","We can express each of these requirements in sigma-calculus, as in Equations 15 through 20.","This is a concrete implementation of the RedirectInFamily structure, but it fails to capture the reliance of the method Redirecter.operation on the behavior of the called method FamilyHead.operation. It also has an overly restrictive requirement concerning r's ownership of target when compared to many coded uses of this pattern. So, we introduce our reliance operators to produce a rho-calculus definition:\n\nr.operation<r.target.operation\u2003\u2003(21)\n\nr<r.target\u2003\u2003(22)\n\nWe can reduce two areas of indirection . . .\n",{"@attributes":{"id":"p-0134","num":"0158"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mrow":{"mi":["r","target"],"mo":"."},"mo":"=","mi":"fh"},{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["r","target","operation"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}}],"mo":","},{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["fh","operation"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}}]}},{"mrow":{"mo":["(",")"],"mn":"23"}}]},{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mi":"r","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"},"mrow":{"mi":["r","target"],"mo":"."}},{"mrow":{"mi":["r","target"],"mo":"."},"mo":"=","mi":"fh"}],"mo":","},{"mi":["r","fh"],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}}]}},{"mrow":{"mo":["(",")"],"mn":"24"}}]}]}}},"br":{}},{"@attributes":{"id":"p-0135","num":"0159"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["Redirector","FamilyHead"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["r","Redirecter"],"mo":":"},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":["fh","FamilyHead"],"mo":":"},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["fh","operation"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}}}}]}}},{"mtd":{"mrow":{"mi":["r","fh"],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":"RedirectInFamily","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":"(","mrow":{"mi":"Redirecter","mo":","}}}}},{"mtd":{"mrow":{"mrow":{"mi":["FamilyHead","operation"],"mo":","},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"25"}}]}}}},"br":{}},"Conventional wisdom holds that formalization of patterns in a mathematical notation will inevitably destroy the flexibility and elegance of patterns. An interesting side effect of expressing our EDPs in the rho-calculus, however, is an increased flexibility in expression of code while conforming to the core concept of a pattern. We term variations of code expression that conform to the concepts and roles of an EDP isotopes.","Consider now , which illustrates the RedirectInFamily isotope. At first glance,  does not look much like the original class diagram for the RediretinFamily EDP illustrated in . A new class has been introduced to the system, and the static criteria that the subclass' method invoke the superclass' instance has been replaced by a new calling chain. In fact, this construction looks quite similar to the transitional state while applying Martin Fowler's Move Method refactoring [14].","This is precisely an example of a variation of RedirectInFamily when viewed as a series of formal constructs, as in Equations 26 though 34.\n\nRedirecter<:FamilyHead\u2003\u2003(26)\n\nr:Redirecter\u2003\u2003(27)\n\nfh: FamilyHead\u2003\u2003(28)\n\nr.mediary=m\u2003\u2003(29)\n\nm.object=fh\u2003\u2003(30)\n\nr.operation<r.mediary.operation2\u2003\u2003(31)\n\nm.operation2<m.object.operation\u2003\u2003(32)\n\nr.operation<r.mediary\u2003\u2003(33)\n\nm.operation<m.object (34)\n","Equations 26-34 can be reduced. One reduction that can be performed includes an equality operation on Equations 29 and 31:",{"@attributes":{"id":"p-0140","num":"0164"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["r","mediary","operation2"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"-"}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["r","mediary"],"mo":"."},"mo":"=","mi":"m"}}}]},"mrow":{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["m","operation2"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"-"}}}}},{"mrow":{"mo":["(",")"],"mn":"35"}}]}}}},"br":{}},{"@attributes":{"id":"p-0141","num":"0165"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mfrac":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["m","operation2"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"-"}}},"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mi":["m","operation2"],"mo":"."},{"mi":["m","object","operation"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"-"}}}}}]},"mrow":{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["m","object","operation"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}}}},{"mrow":{"mo":["(",")"],"mn":"36"}}]},{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["m","object","operation"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}},{"mrow":{"mi":["m","object"],"mo":"."},"mo":"=","mi":"fh"}],"mo":","},{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["fh","operation"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}}]}},{"mrow":{"mo":["(",")"],"mn":"37"}}]}]}}},"br":{}},{"@attributes":{"id":"p-0142","num":"0166"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["r","operation"],"mo":"."},{"mi":["r","mediary"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["m","operation"],"mo":"."},{"mi":["m","object"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["r","mediary"],"mo":"."},"mo":"=","mi":"m"},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":["m","object"],"mo":"."},"mo":"=","mi":"fh"}}}]},"mrow":{"mi":["r","fh"],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}}}},{"mrow":{"mo":["(",")"],"mn":"38"}}]}}}}},"If we now take Equations 26, 27, 28, 37, and 38 we find that we have satisfied the clause requirements set in our original definition of RedirectInFamily, as per Equation 25. This alternate structure is an example of an isotope of the RedirectInFamily pattern and required no adaptation of our existing rule. Our single rule takes the place of an enumeration of static pattern definitions.","The concepts of object relationships and reliance are the key. It is worth noting that, while this may superficially seem to be equivalent to the common definition of variant, as defined by Buschmann [7], there is a key difference: encapsulation. Isotopes may differ from strict pattern structure in their implementation, but they provide fulfillment of the various roles required by the pattern and the relationships between those roles are kept intact. From the view of an external calling body, the pattern is precisely the same no matter which isotope is used. Variants are not interchangeable without retooling the surrounding code, but isotopes are. This is an essential requirement of isotopes, and precisely why we chose the term. This flexibility in internal representation grants the implementation of the system a great degree of latitude, while still conforming to the abstractions given by design patterns.","4. Exemplary SPQR Toolchain","The methods and systems described herein provide solutions to a ubiquitous problem in software engineering\u2014how best to aid an engineer in comprehending a large or complex system. One such way is to provide automated tools to extract conceptual information and present it to the user in a meaningful way. The present System for Pattern Query and Recognition [34] (SPQR) performs this task, finding instances of known design patterns within source code and alerting the engineer to their presence. Such a system has many direct applications, such as system inspection during education, ensuring that intended patterns exist in the final code, and investigation of unintended pattern instances that may provide cues for refactoring.","SPQR relies on the formal nature of EDPs and the rho-calculus to perform the bulk of the discovery, by using an automated inference engine to infer the existence of patterns in the source code under scrutiny. The SPQR toolchain may include several components, shown in . In , the components of the SPQR toolchain include the gcc compiler, a gcctree2poml converter, the OTTER automated theorem prover, a proof2pattern converter, an EDP catalog, and Rho Calculus. Each of these components represents specific examples of the functional components illustrated in . For example, the gcc compiler and the gcctree2poml converter in  are examples of source-code-to-fact-set converter  illustrated in . OTTER in  is an example of automated inference engine  illustrated in . The EDP catalog in  corresponds to EDP catalog  illustrated in . Rho Calculus in  corresponds to rules  illustrated in . The proof2pattern component illustrated in  corresponds to proof to pattern converter  illustrated in .","From the engineer's point of view, SPQR is a single fully automated tool that performs the analysis from source code and produces a final report. A simple script provides the workflow, by chaining several modular component tools, centered around tasks of source code feature detection, feature-rule description, rule inference, and query reporting. Compiler output of the syntax tree of a codebase (one current input source is gcc) is transformed into our formal notation encoded as input to the OTTER automated theorem prover [19]. This fact set, combined with the pre-defined encodings for the EDP Catalog and the relationships rules of rho-calculus are operated on by OTTER to find instances of design patterns which are then reported to the user. SPQR is language and domain independent, and would be impractical without the formal foundations of our EDPs and rho-calculus.","As an example,  is a class diagram of a file system that was designed as many are: through growth. In , three distinct libraries are interacting in well-formed ways, each under the control of a different engineering group. Source code is unavailable to the other groups, and design issues are partitioned as well. After analysis by SPQR, however, it becomes clear, as illustrated by the post-SPQR class diagram of , that there is a hidden instance of the Decorator design pattern that provides an intriguing clue to the engineers how to refactor the three libraries to work more effectively together. This example is illustrated in complete detail, and SPQR is discussed more thoroughly, in sections  and .","4.1. Using SPQR","An example of how SQPR operates to located patterns in source code will now be described. In the example, a fictitious company, Widgets, Inc., develops source code referred to herein as the Killer Widget application. At Widgets, Inc., there are many teams working on the Killer Widget application. Each is responsible for a well-defined and segmented section of the application, but they are encouraged to share code and classes where possible. As is often normal in such situations, teams have write access only for their own code\u2014they are responsible for it, and all changes must be cleared through regular code reviews. All other teams may inspect the code, but may not change it. Suggestions can be made to the team in charge, to be considered at the next review, but no one likes their time wasted and internal changes take priority during such reviews.","Three main phases of development by three different teams have taken place on a core library used by the application, resulting in a conceptually unclear system, shown in . The first phase involved the File system having a MeasuredFile metric gathering suite wrapped around it. Secondly, multiple file handling was added by the FilePile abstraction, and lastly, a bug fix was added in the FilePileFixed class to work around an implementation error that become ubiquitously assumed. A review of the design is called for the next development cycle.","Hidden patterns exist within the architecture which encapsulate the intent of the larger system, would facilitate the comprehension of the novice developers, and help point the architects towards a useful refactoring of the system. The system illustrated in  will be used as the driving example to illustrate exemplary operation of the methods and systems for identifying computer source code constructs described herein.","The chain of tools will be described from the viewpoint of a practitioner using them on Killer Widget. As described above with regard to , from the engineer's point of view, SPQR is a single tool that performs the analysis from source code and produces a final report. A simple script provides the workflow, by chaining several modular component tools, centered around tasks of source code feature detection, feature-rule description, rule inference, and query reporting.","In SPQR, source code is first analyzed for particular syntactic constructs that correspond to the rho-calculus concepts we are interested in. It turns out that the ubiquitous gcc has the ability to emit an abstract syntax tree suitable for such analysis. Our first tool, gcctree2poml, reads this tree file and produces an XML description of the object structure features. We chose an intermediary step so that various back ends could be used to input source semantics to SPQR. A second tool, poml2otter then reads this POML file and produces a feature-rule input file to the automated inference engine, in the current package we are using Argonne National Laboratory's OTTER. OTTER finds instances of design patterns by inference based on the rules described herein. Finally, proof2pattern analyzes the OTTER proof output and produces a POML pattern description report that can be used for further analysis, such as the production of UML diagrams.","Each stage of SPQR is independent, and is designed to allow other languages, compilers, workflows, inference engines, and report compilation systems to be added. Additionally, as new design patterns are described by the community, perhaps local to a specific institution or workgroup, they can be added to the catalog used for query.","The Killer Widget example has been successfully analyzed and a salient Decorator pattern was found using SPQR.  shows the source code snippet for the Killer Widget Application that is input to source-code-to-fact-set converter .  shows the corresponding OTTER input generated by source-code-to-fact-set converter . Equations 44 through 59 in  represent the equivalent set of rules in the rho-calculus.","The inputs to OTTER include the set of facts of the system under consideration (shown in , as would be output by gcctree2poml and poml2otter from the code snippet in ), the necessary elements of rho-calculus encoded as OTTER rules, and the design patterns of interest, including the EDPs, similarly encoded (both of which are provided as part of SPQR). For example, the RedirectInFamily pattern is shown in .","The work required of the developer is to simply request SPQR to perform the analysis, and the resultant found patterns are reported by proof2pattern as a POML XML snippet, such as:",{"@attributes":{"id":"p-0159","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<pattern name=\u201dDecorator\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<role name=\u201dComponent\u201d>","\u201cFile\u201d <\/role>"]},{"entry":[{},"<role name=\u201dDecorator\u201d>","\u201cFilePile\u201d <\/role>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<role name=\u201dConcreteComponent\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cFileFAT\u201d <\/role>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<role name=\u201dConcreteDecorator\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cFilePileFixed\u201d <\/role>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<role name=\u201doperation\u201d>","\u201cop1\u201d <\/role>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/pattern>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Such information can then be used to produce diagrams such as , which may be generated manually based on the object XML snippet or automatically by proof-to-pattern converter . The intermediate patterns have been omitted from  for clarity, as have finer granularity relationships. The annotations in  indicate which classes fulfill which roles in the pattern descriptions, such as Pattern::Role. Note that a single class can fulfill more than one role in more than one pattern.","Preliminary speed results indicate that scaling to larger systems in production code should be effective. One tolerance threshold that may be used is whether or not the SPQR analysis is roughly equivalent to compilation of the same source code, and to date this has held true in informal tests. The comprehensive coverage of the EDPs suggests that scaling will be dependent solely on the number of facts generated by the original source analysis, coupled with the scaling performance of the inference engine.and yet for Killer Widget, this has averaged only 0.71 seconds, as reported by the POSIX time utility over 20 runs, on a 400 MHz PowerPC G3 CPU.","While SPQR is highly straightforward in implementation and use, it encapsulates a highly formalized semantics system that allows for the use of an automated inference engine for rule inference. It is the formalization that, paradoxically, provides the flexibility of describing the complex programming abstractions of design patterns. The practitioner can avoid this level of detail, however, and SPQR can be adapted to work at multiple levels of formal analysis, depending on the particular need.","5. Reconstruction of Known Patterns Using EDPs","An example of using EDPs to express larger and well-known design patterns will now be provided. The example begins with AbstractInterface, a simple EDP and concludes with Decorator, visiting two other established patterns along the way.","AbstractInterface ensures that the method in a base class is truly abstract, forcing subclasses to override and provide their own implementations. The rho-calculus definition can be given by simply using the trait construct of sigma-calculus:",{"@attributes":{"id":"p-0165","num":"0189"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mi":"A","mo":"\u2261","mrow":{"mo":["[","]"],"mrow":{"mrow":[{"mi":"new","mo":":","mrow":{"mo":["[","]"],"mrow":{"msub":{"mi":["I","i"]},"mo":":","mrow":{"mi":"A","mo":"\u2192","msubsup":{"mi":["B","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","n"]}}}}}}},{"mi":"operation","mo":":","mrow":{"mi":["A","B"],"mo":"\u2192"}}],"mo":","}}},{"mi":"AbstractInterface","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","operation"],"mo":","}}}]}},{"mrow":{"mo":["(",")"],"mn":"39"}}]}}}},"br":{},"figref":"FIG. 13"},"Objectifier is simply a class structure applying the Inheritance EDP to an instance of AbstractInterface pattern, where the AbstractInterface applies to all methods in a class. This is equivalent to what Woolf calls an Abstract Class pattern. Referring back to  from our earlier discussion in Section 1, we can see that the core concept is to create a family of subclasses with a common abstract ancestor. We can express this in rho-calculus as:",{"@attributes":{"id":"p-0167","num":"0191"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":":","mrow":{"mo":["[","]"],"mrow":{"msub":{"mi":["I","i"]},"mo":":","msubsup":{"mi":["B","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","n"]}}}}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"AbstractInterface","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"Objecifier","mo":",","msubsup":{"mi":["I","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","n"]}}}}}},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"msub":{"mi":["ConcreteObjectifier","j"]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":"Objectifier","mrow":{"mi":"j","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}}},"mo":","}}}]}}},{"mtd":{"mrow":{"mi":"Client","mo":":","mrow":{"mo":["[","]"],"mrow":{"mi":["obj","Objectifier"],"mo":":"}}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":["Objectifier","Objectifier"],"mo":"("}}},{"mtd":{"mrow":{"mrow":{"msubsup":{"mi":["ConcreteObjectifier","j"],"mrow":{"mi":"j","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}},"mo":",","mi":"Client"},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"40"}}]}}}}},"We briefly described Object Recursion in section 1, and gave its class structure in . We now show that this is a melding of the Objectifler and RedirectInFamily patterns.indicate which roles of which patterns the various components of ObjectRecursion play. A formal EDP representation is given in Equation 41.",{"@attributes":{"id":"p-0169","num":"0193"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["Handler","Initiator"],"mo":[",",","],"msubsup":{"mi":["Recurser","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}}}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["Handler","Initiator"],"mo":[",",","],"msubsup":{"mi":["Terminator","j"],"mrow":{"mi":"j","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","n"]}}}}}},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":"init","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03bc"},"mrow":{"mi":["obj","handleRequest"],"mo":"."}},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":["init","Initiator"],"mo":":"},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":["obj","Handler"],"mo":":"},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["Recurser","Handler","handleRequest"],"mo":[",",","]}}},"mo":","}}}]}}},{"mtd":{"mrow":{"mo":"!","mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["Terminator","Handler","handleRequest"],"mo":[",",","]}}}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":"ObjectRecursion","mo":"(","mrow":{"mi":"Handler","mo":[",",","],"msubsup":{"mi":["Recurser","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}}}}}},{"mtd":{"mrow":{"mrow":{"msubsup":{"mi":["Terminator","j"],"mrow":{"mi":"j","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","n"]}}},"mo":",","mi":"Initiator"},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"41"}}]}}}}},"The ExtendMethod EDP is used to extend, not replace, the functionality of an existing method in a superclass. This pattern illustrates the use of super, formalized in Equation 42.",{"@attributes":{"id":"p-0171","num":"0195"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"OriginalBehavior","mo":":","mrow":{"mo":["[","]"],"mrow":{"mrow":[{"msub":{"mi":["I","i"]},"mo":":","msubsup":{"mi":["B","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}}},{"mi":"operation","mo":":","msub":{"mi":"B","mrow":{"mi":"m","mo":"+","mn":"1"}}}],"mo":","}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["ExtendedBahavior","OriginalBehaviour"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":{"mi":["eb","ExtendedBehavior"],"mo":":"},"mo":","}}}]}}},{"mtd":{"mrow":{"mrow":[{"mi":["eb","operation"],"mo":"."},{"mi":["super","operation"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"+"}}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":"ExtendedMethod","mo":"(","mrow":{"mi":"OriginalBehaviour","mo":","}}}},{"mtd":{"mrow":{"mrow":{"mi":["ExtendedBehaviour","operation"],"mo":","},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"42"}}]}}}},"br":{},"figref":"FIG. 15"},"Now we can produce a pattern directly from the GoF text, the Decorator pattern. class diagram for Decorator annotated to show how the EDP ExtendMethod and ObjectRecursion pattern interact. Again, we provide a formal definition in Equation 43, although only for the method extension version (the field extension version is similar but unnecessary for our purposes here). The keyword any indicates that any object of any class may take this role, as long as it conforms to the definition of ObjectRecursion.",{"@attributes":{"id":"p-0173","num":"0197"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"ObjectRecursion","mo":"(","mrow":{"mi":"Component","mo":[",",","],"msubsup":{"mi":["Decorator","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}}}}}},{"mtd":{"mrow":{"mrow":{"mrow":{"msubsup":{"mi":["ConcreteComponent","j"],"mrow":{"mi":"j","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","n"]}}},"mo":",","mi":"any"},"mo":")"},"mo":","}}}]}}},{"mtd":{"mrow":{"mi":"ExtendedMethod","mo":"(","mrow":{"mi":"Decorator","mo":","}}}}]}}},{"mtd":{"mrow":{"mrow":{"mrow":{"msubsup":[{"mi":["ConcreteDecoratorB","k"],"mrow":{"mi":"k","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","o"]}}},{"mi":["operation","k"],"mrow":{"mi":"k","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","o"]}}}],"mo":","},"mo":")"},"mo":[",",","]}}}]},{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"Decorator","mo":"(","mrow":{"mi":"Domponent","mo":[",",","],"msubsup":{"mi":["Decorator","i"],"mrow":{"mi":"i","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}}}}}},{"mtd":{"mrow":{"msubsup":{"mi":["ConcreteComponent","j"],"mrow":{"mi":"j","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","m"]}}},"mo":","}}}]}}},{"mtd":{"mrow":{"msubsup":{"mi":["ConcreteDecoratorB","k"],"mrow":{"mi":"k","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","o"]}}},"mo":","}}}]}}},{"mtd":{"mrow":{"msubsup":{"mi":["ConcreteDecoratorA","l"],"mrow":{"mi":"l","mo":"\u2208","mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","p"]}}},"mo":","}}}]}}},{"mtd":{"mrow":{"msubsup":{"mi":["operation","k"],"mrow":{"mi":"k","mo":"\u2208","mrow":{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u2026","o"]},"mo":"+","mi":"p"}}},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"43"}}]}}}},"br":{},"figref":["FIG. 14","FIG. 14","FIG. 16","FIG. 16"]},"We have created a formally sound definition of a description of how to solve a problem of software architecture design. This definition is now subject to formal analysis, discovery, and metrics. Following our example of pattern composition, this definition can be used as a building block for larger, even more intricate patterns that are incrementally comprehensible. At the same time, we believe that we have retained the flexibility of implementation that patterns demand. Also, we believe that we have retained the conceptual semantics of the pattern by intelligently and diligently making precise choices at each stage of the composition.","6. Killer Widget Analysis in Detail","We can now build a picture of what SPQR is doing within OTTER's inference system.  illustrates the Decorator class structure without the annotation of .  illustrates exemplary equations corresponding to the poml2otter output illustrated in .","It can be seen that the AbstractInterface rule is fulfilled for class File, method op1 by Equation 44. Furthermore, File and FilePile fulfill the requirements of the Objectifler pattern, assuming, as we will here assert, that the remainder of File's methods are likewise abstract.",{"@attributes":{"id":"p-0177","num":"0201"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"File","mo":":","mrow":{"mo":["[","]"],"mrow":{"mi":["op1","\u2022"],"mo":":"}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"AbstractInterface","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","op1"],"mo":"."}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":"FilePile","mo":"<"},"mo":":","mi":"File"},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["mfile","file"],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}},"mo":","}}},{"mtd":{"mrow":{"mi":["file","File"],"mo":":"}}}]},"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","FilePile","MeasuredFile"],"mo":[",",","]}}}}},{"mrow":{"mo":["(",")"],"mn":"60"}}]}}}}},"Objectifier (File, FileFAT, MeasuredFile) and analogous instances of Objectifier for the other concrete subclasses of the File class, can be similarly derived.","Finding an instance of RedirectInFamily is a bit more complex and requires the use of our isotopes. Following the example in Section 3.13, however, it becomes straightforward to derive RedirectInFamily:",{"@attributes":{"id":"p-0180","num":"0204"},"maths":{"@attributes":{"id":"MATH-US-00021","num":"00021"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mfrac":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"FilePile","mo":["\u2062","<"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mstyle":[{"mtext":":"},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":["\u2062","\u2062"],"mi":"File"}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["fp","FilePile"],"mo":["\u2062",":","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["f","File"],"mo":["\u2062",":","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["fp","op1"],"mo":"."},{"mi":["fp","mfile","op2"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"-"}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["fp","mfile"],"mo":"."},"mo":["\u2062","=","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mi":"mf"},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["mf","op2"],"mo":"."},{"mi":["mf","file","op2"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mrow":{"mi":"\u03bc","mo":"-"}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["mf","file"],"mo":"."},"mo":["\u2062","=","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mi":"f"},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":["fp","op1"],"mo":"."},{"mi":["fp","mfile"],"mo":"."}],"mo":["\u2062","\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mi":["mf","op2"],"mo":"."},{"mi":["mf","file"],"mo":"."}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mo":"<","mi":"\u03d5"}}}}]},"mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["FilePile","File","op1"],"mo":[",",","]}}}}}},{"mrow":{"mo":["(",")"],"mn":"61"}}]}}}}},"It can also be shown that one simply cannot derive the fact RedirectInFamily (FileFAT, File, op1). We now see that ObjectRecursion derives cleanly from Equations 60 and 61 and their analogues, in Equation 62.",{"@attributes":{"id":"p-0182","num":"0206"},"maths":{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","FilePileMeasuredFile"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":","}}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","FileFAT","MeasuredFile"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":","},{"mtext":","}]}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["mf","MeasureFile"],"mo":["\u2062",":","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"mf","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mo":"<","mi":"\u03bc"},"mrow":{"mi":["file","op1"],"mo":"."}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["file","File"],"mo":["\u2062",":","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["FilePile","File"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":","}},"mo":",","mi":"op1"}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mo":"!","mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["FileFAT","File","op1"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":","},{"mtext":","}]}}}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":"ObjectRecursion","mo":"(","mrow":{"mrow":{"mi":["File","FilePile"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":","}},"mo":","}}}},{"mtd":{"mrow":{"mrow":{"mi":["FileFAT","MeasuredFile"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":","}},"mo":")"}}}]}]},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"1.4em","height":"1.4ex"}}}}},{"mrow":{"mo":["(",")"],"mn":"62"}}]}}}},"br":{}},{"@attributes":{"id":"p-0183","num":"0207"},"maths":{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","FilePileMeasuredFile"],"mo":","}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"Objectifier","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","FileFAT","MeasuredFile"],"mo":[",",","]}}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["mf","MeasureFile"],"mo":["\u2062",":","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"mf","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mo":"<","mi":"\u03bc"},"mrow":{"mi":["file","op1"],"mo":"."}},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["file","File"],"mo":["\u2062",":","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["FilePile","File"],"mo":[",",","],"mrow":{"mi":"op","mo":"\u2062","mn":"1"}}}},"mo":","}}},{"mtd":{"mrow":{"mo":"!","mrow":{"mi":"RedirectInFamily","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["FileFAT","File","op1"],"mo":[",",","]}}}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":"ObjectRecursion","mo":"(","mrow":{"mi":["File","FilePile"],"mo":[",",","]}}}},{"mtd":{"mrow":{"mrow":{"mi":["FileFAT","MeasuredFile"],"mo":","},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"63"}}]}}}},"br":{}},{"@attributes":{"id":"p-0184","num":"0208"},"maths":{"@attributes":{"id":"MATH-US-00024","num":"00024"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"ObjectRecursion","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["File","FilePile","FileFAT","MeasuredFile"],"mo":[",",",",","]}}},"mo":","}}},{"mtd":{"mrow":{"mi":"ExtendMethod","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["FilePile","FilePileFixed","op1"],"mo":[",",","]}}}}}]},{"mtr":[{"mtd":{"mrow":{"mi":"Decorator","mo":"(","mrow":{"mi":["File","FilePile"],"mo":[",",","],"mrow":{"mi":"FileFAT","mo":"\u2062","mstyle":{"mtext":","}}}}}},{"mtd":{"mrow":{"mrow":{"mi":["FilePileFixed","op1"],"mo":","},"mo":")"}}}]}]}},{"mrow":{"mo":["(",")"],"mn":"64"}}]}}}},"br":{}},"The EDPs can provide a path for educators to guide students to learning OO design from first principles, demonstrating best practices for even the smallest of problems. Note that the core EDPs require only the concepts of classes, objects, methods (and method invocation), and data fields. Everything else is built off of these most basic object oriented constructs, which map directly to the core of UML class diagrams. The new student needs only to understand these extremely basic ideas to begin using the EDPs as a well formed approach to learning the larger and more complex design patterns. As an added benefit, the student will be exposed to concepts that may not be directly apparent in the language in which they are currently working. These concepts are language independent, however, and should be transportable throughout the nascent engineer's career.","This transmission of best practices is one of the core motivations behind design patterns, but even the simplest of the usual canon requires some non-trivial amount of design understanding to be truly useful to the implementer. By reducing the scope of the design pattern being studied, one can reduce the background necessary by the reader, and therefore make the reduced pattern more accessible to a wider audience, increasing the distribution of the information. This parallels the suggestions put forth by Goldberg in 1994 [16].","8. EDPs as Language Design Hints","It is expected that some will see the EDPs as truly primitive, but the development of programming languages has been a reflection of directly supporting features, concepts, and idioms that practitioners of the previous generation languages found to be useful. Cohesion and coupling analysis of procedural systems gave rise to many object oriented concepts, and each common OO language today has features that make concrete one or more EDPs. EDPs can therefore be seen as a path for incremental additions to future languages, providing a clue to which features programmers will find useful based precisely on what concepts they currently use, but must construct from simpler forms.","8.1. Delegation","A recent, and highly touted, example of such a language construct is the delegate feature found in C#[21]. This is an explicit support for delegating calls directly as a language feature. It is in many ways equivalent to the decades old Smalltalk and Objective-C's selectors, but has a more definite syntax which restricts its functionality, but enhances ease of use. It is, as one would expect, an example of the Delegation EDP realized as a specific language construct, and demonstrates how the EDPs may help guide future language designers. Patterns are explicitly those solutions that have been found to be useful, common, and necessary in many cases, and are therefore a natural set of behaviors and structures for which languages to provide support.","8.2. ExtendMethod","Most languages have some support for this EDP, through the use of either static dispatch, as in C++, or an explicit keyword, such as Java and Smalltalk's super. Others, such as BETA[18], offer an alternative approach, deferring portions of their implementation to their children through the inner construct. Explicitly stating \u2018extension\u2019 as a characteristic of a method, as with Java's concept of extends for inheritance, however, seems to be absent. This could prove to be useful to the implementers of a future generation of code analysis tools and compilers.","8.3. AbstractInterface","The Abstract Interface EDP is, admittedly, one of the simplest in the collection. Every OO language supports this in some form, whether it is an explicit programmer created construct, such as C++'s pure virtual methods, or an implicit dynamic behavior such as Smalltalk's exception throwing for an unimplemented method. It should be noted though that the above are either composite constructs (virtual foo( )=0; in C++) or a non construct runtime behavior (Smalltalk), and as such are learned through interaction with the relationships between language features. In each of the cases, the functionality is not directly apparent in the language description, nor is it necessarily apparent to the student learning OO programming, and more importantly, OO design. Future languages may benefit from a more explicit construct.","9. Malignant Patterns","One of the exciting aspects of this research is that it provides the foundation for finding not just established design patterns, but any combination of relationships between language entities and programming concepts we choose to define. One such application is looking for common poor solutions to common problems, where one can identify common mistakes made by programmers when attempting to follow design pattern guidelines. Also, one can describe situations where common solutions are found to exist, but known to be poor fits for many applications. These are both similar to what is often termed \u2018anti-patterns\u2019, but that phrasing has become so diluted by misuse as to have lost much of its original preciseness. Instead, these patterns are referred to herein as \u2018malignant patterns\u2019. They do indeed solve the problem at hand, but are likely to cause more problems in the long run, particularly during maintenance, than they solved in the first place SPQR is as capable of finding these as it is the more common design patterns, since they are still only code constructs and relationships.","9.1. \u2018Bad Smells\u2019 as Refactoring Opportunity Discovery","Fowler [14] uses the term \u2018bad smells\u2019 to describe many such situations . . . the code looks okay from many perspectives, but there's just something not quite right about it to the trained eye. These are assumed to be cues for opportunities for refactoring, which is usually the case. Usually these \u2018bad smells\u2019 are quantifiable as relationships between concepts\u2014precisely the type of constructs that SPQR is designed to extract. It is entirely possible to provide an engineering team with information not only on the conformance of a system with the design as expressed as design patterns, but also to provide them with indicators that there may be refactoring opportunities that they had not considered.","9.2. Semi-Automated Support for the Refactoring Process","Refactoring is not likely to ever be, in our opinion, a fully automatable process. At some point the human engineer must make decisions about the architecture in question, and guide the transformation of code from one design to another. Several key pieces, however, may benefit from the work described herein. Our isotope example in Section 3.13 indicates that it may be possible to support verification of Fowler's refactoring transforms through use of the rho-calculus, as well as various other approaches currently in use [14, 25, 22]. {acute over (\u25ef)} Cinn\u00e9ide's minitransformations likewise could be formally verified and applied to not only existing patterns, but perhaps to code that is not yet considered pattern ready, as key relationships are deduced from a formal analysis [23,24]. Furthermore, we believe that the fragments-based systems such as LePuS can now be integrated back into the larger domain of denotational semantics.","10. Aspect Oriented Programming","Related to fragments in many ways, Aspect Oriented Programming (AOP) provides a language support framework for working with conceptual fragments. SPQR can be used in this context as well, due to the flexibility of the reliance operators. As aspects are added or deleted from the codepath, SPQR can quickly and easily take into account new reliances while ensuring conformance with the original pattern intents AOP is, at its core, an establishment of a Notification design pattern injected into a language's runtime with high-level support within the language itself. Since the Notification design pattern is an established design pattern in the SPQR lexicon, this is directly supportable by SPQR. As AOP matures, the combination of SPQR and dedicated AOP environments will prove to be very powerful.","11. SPQR Refinements\u2014Tools","SPQR is of course a work in progress. It was designed to be as flexible as possible to take advantage of new programming environments, target languages, and solver engines, but there are specific improvements that we have already identified as important refinements.","11.1. Iterative Searching","Currently SPQR treats the fact base of the source code as a monolithic system, and searches for design patterns of various complexities on equal terms. Since it is the case that the more complex patterns are composed of the more elemental ones, we can produce some optimization by adding facts about found patterns to the fact base. In this manner we reduce the re-derivation of many patterns, speeding up the discovery of the more complex patterns of interest.","11.2. Level of Detail Control","As a user-level analogue to the above iterative approach, SPQR needs to provide the user with control over the level of detail of patterns that are searched for, and expressed. A large system may include an immense number of EDPs, for example, and yet the practitioner is not likely to be interested in them as a primary comprehension cue. By default, reporting of EDPs should be suppressed, but available as an option for research purposes and more precise interaction with the system.","One approach for fulfilling this need is to allow the user to select which sections of the pattern dependency graph they wish to have reported. The pattern dependency graph is a directed acyclic graph that indicates which design patterns are composited from others. The EDPs form the base of the graph, the lowest layer, while patterns such as Objectifier lie at the next level up the hierarchy, and so on. The example patterns from section 5 are shown in  as an example graph. An engineer may select a depth level slice (\u201cpatterns no lower than X, no higher than Y\u201d), or only particular patterns (\u201conly patterns in the Decorator subgraph\u201d), or a combination (\u201conly patterns in the Decorator subgraph, lower than Decorator, but higher than the EDPs\u201d).","11.3. Alternate Automated Inference Engines","OTTER is a highly generalized theorem prover, and while more than adequate for SPQR, may not be optimal. As ATPs and my familiarity with the field improve, other engines may provide a better fit with the needs of SPQR. One move that can be done immediately is to use the TPTP intermediate language for expressing the ATP form of the fact base. It would mean yet another step in the analysis process, but would open up a wide array of ATPs to investigate as SPQR options. The fundamental fact is that SPQR allows, today, for any inference engine to be incorporated as part of the toolchain.","11.4. Alternate Environments","Currently gcc 3.x is the target environment for SPQR. However, SPQR may function in other environments, such as .NET, Xcode, Eclipse, and more direct language sources such as the Squeak Smalltalk runtime, and the Java Virtual Machine, without departing from the scope of the subject matter described herein.","11.4.1. IDE Integration","The former would be treated much like gcc, but with the possibility of providing the results of SPQR unified within the environment offering some intriguing possibilities. For instance, Eclipse's extensible UI gives one the opportunity to integrate SPQR directly into the IDE, with a direct menu item or button click triggering SPQR, feeding it a simplified (and pre-selected) fact base on the source code under its control, and displaying the results in a textual or graphical format as another View on the system. Xcode and .NET have similar capabilities for plugin tools, and SPQR is well suited for this task.","11.4.2. Runtime Environment Snapshots","Interacting directly with the language runtimes leads to a wider array of languages that SPQR can handle. While SPQR is a static analysis engine and would seem to be unusable for analysis of dynamically bound and\/or loaded languages, it should be noted that at any given moment in time the typing environment of a dynamic runtime environment is a static fact base. That set of facts about the system may change over time, but if we select the point at which we choose to initiate our analysis, such as post-loading of all expected classes, we can analyze a snapshot of the environment just as if it were described in source code. In fact, we can take a series of snapshots over time and view the changes that a design architecture makes during its lifetime, a fascinating and tantalizing research possibility. Sample-based profiling of a system's performance is now an established technique, we will do the same for a system's architectural design.","11.5. Alternate Data Sources","SPQR was designed to be language, framework, platform, and OS independent, and it meets this requirement. It is unimportant what language, library, framework, or system is to be analyzed, as long as it can be expressed as an abstract description of the relationships between code entities. (The rho calculus, as the formal basis for these relationships, ensures that all object-oriented languages that are expressible in sigma calculus can be so expressed.) Our example implementation of this abstraction is the Pattern\/Object Modeling Language (POML), an XML Schema. Other abstractions could be possible, and SPQR could easily be adapted to use them. The concept of the POML as part of SPQR allows for a unified approach to describing source code relationships, independent of the source language, the operating environment, or the application domain. This is a critical piece to SPQR, by providing a single definition for object oriented design elements, and through which SPQR gains an unprecedented level of flexibility and applicability. We currently have a gcc based translator for producing POML from C++, but as shown in the previous section, any environment is possible, and here we claim that any sigma-calculus conformant language is possible.","11.6. Distributed Analysis","SPQR is inherently distributable in the manner in which it analyzes a system. Assume that we have a set of patterns, P, that we wish to search for in a codebase, C. We transform C into a set of rho-calculus facts, as per normal operation of SPQR, let's call it . Break P into n subsets, P. . . P. Send a search subset, P, along with , to another thread, process or machine capable of running SPQR and complete the process there. All n sets of search results are then compiled into a final report.","11.7. Expanding Pattern Libraries","Of course SPQR will continue to incorporate new design patterns as they are defined in the literature, and new combinatorials may come to light as research continues. We expect that the libraries will also start to include site, application, and domain specific patterns as SPQR is used in real world practice and useful constructs are identified through its use.","SPQR facilitates this by performing the exact task for which it was designed\u2014finding patterns. By constructing the EDPs, we have provided a solid and pervasive base from which to compose almost any code construct one cares to produce. Instances of the EDPs can be found in anycode, and as such can be used to describe the codebase. In fact, this bootstrapping approach is precisely how we defined the design patterns in our current library, and it can be extended to any design patterns or code constructs one cares to describe. First, an engineer creates a \u2018canonical codebase\u2019, an example of the design pattern that is to be added to SPQR, in source code. This example is run through SPQR, which finds instances of all EDPs and intermediate patterns which comprise the example. The relationships between these found instances form the definition of the new code construct or pattern. This new definition will be added to the library, and used to refine current definitions of other constructs and patterns, or in the defining of new, future constructs. This training of the system requires no knowledge of the inner workings of SPQR, rho calculus, or the EDPs; it is quite automatic. The EDPs are the basis, however, and should be seen as fundamental to the process.","This is an important advancement of the state of the art in code analysis\u2014while the Gang of Four design patterns reference was our initial inspiration, we have produced a tool and methodology that go far beyond that. Instead, we can, with the same system, incorporate any architecturally well formed design pattern currently known or yet to be discovered.","In addition, while SPQR was designed to discover instances of design patterns in source code, it has, in fact, solved a much more fundamental problem, finding generalized relationships within source code. As such, we foresee SPQR working on a much broader base of possible constructs to find within source code than just design patterns.","12. SPQR Refinements\u2014Theory","The SPQR toolset will continue to evolve as outlined above, but the more theoretical aspects offer some research opportunities as well. Currently SPQR is a static analysis engine only\u2014a highly flexible analysis engine, but purely static. SPQR will grow to incorporate more dynamic analysis features, preferably without requiring actual run-time analysis. One design goal for SPQR is to have it require only the source code for full analysis, and it would be desirable to maintain that goal for reasons of practicality as a toolset.","12.1. State Changes","A new reliance operator, State Change (indicated by <) opens up a tremendous realm of analysis currently unavailable to static engines. This is an operator indicating a candidate state change, not an absolute one, but it still provides more analysis than we currently have. Simply put, < can be described as:","Assume that all fields of any object are private. (If this is not the case, it can be easily mocked up through a level of abstraction.) Then all changes of the state of an object will require calls on the internal field object's methods. (Since the field itself is an object.)","So if object  has field object o, then the only way  can change state is if .o has a method called on it. Assume that \u2018h\u2019 is in .o's dictionary of methods, such that is a way to change .o's state.","Since .o is private, then only some method in  can call .o.h. Call that method f, from s dictionary.","So if we have .f<.o.h, then we have a possible state change of .o and by extension, . Therefore any object or method that relies on the state of  or .o will rely on .f's possible change to their state.","Assume that .g relies on .o as a field: .g<.o, then .g relies on .f for a state change: .g<.f.","Since <.o by definition, this extends naturally to outside the object, so we have one simple rule:",{"@attributes":{"id":"p-0219","num":"0243"},"maths":{"@attributes":{"id":"MATH-US-00025","num":"00025"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mfrac":{"mrow":[{"mrow":[{"mrow":[{"mi":["\u03b8","f"],"mo":"."},{"mi":["\u03b8","o","h"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03bc"}},{"mrow":[{"mi":["\u03b8","g"],"mo":"."},{"mi":["\u03b8","o"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"}}],"mo":","},{"mrow":[{"mi":["\u03b8","g"],"mo":"."},{"mi":["\u03b8","f"],"mo":"."}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c3"}}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"or"}},{"mrow":{"mo":["(",")"],"mn":"65"}}]},{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mrow":[{"mi":["\u03b8","f"],"mo":"."},{"mi":["\u03b8","o","h"],"mo":[".","."]}],"mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03bc"}},{"mi":"\u03b8","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03d5"},"mrow":{"mi":["\u03b8","o"],"mo":"."}}],"mo":","},{"mi":"\u03b8","mo":["\u2062","\u2062"],"msub":{"mo":"<","mi":"\u03c3"},"mrow":{"mi":["\u03b8","f"],"mo":"."}}]}},{"mrow":{"mo":["(",")"],"mn":"66"}}]}]}}}},"This captures imperative side effects which no UML or type based system can.","12.2. Data Cohesion","Similar to the above State Change, where a field relies on a method, we can have a field rely on another field. This concept of data cohesion is well established in the literature, but this is the first time it has been unified with other object-based analyses as described herein. The relop form of <, or a kappa form relop, is used to indicate a mnemonic for cohesion. Because of our transitivities, and because parameters and return values are treated equally in the rho calculus, we can cross method boundaries in a single approach that binds the object-oriented sigma-calculus and the procedural lambda-calculus. This gives us our fifth and final reliance operator form.\n\n12.3. Temporal Logic\n","Temporal logic would allow SPQR to distinguish between the case where rule  occurs before rule  as distinct from when rule  occurs before rule , as in the two method calls shown in , both of which currently derive to the equivalent non-temporal ruleset S={method<obj.method1, method<obj.method2}. Currently the two situations are seen equivalently, and many dynamic run-time situations are beyond SPQR's analysis. Temporal logics would provide for refinement of the search space, confirming or excluding candidate patterns from the results. This would of course require a new inference engine, and it is now that the inclusion of TPTP begins to bear fruit, as it would allow for simple switching of ATPs as necessary.","12.4. Sigma-Calc Interpretation","Finally, the last piece of dynamicism, true run-time analysis, is in fact theoretically possible within SPQR without needing to run the binary of the target system. Sigma is a sigma-calculus interpreter created by Santiago M Pericas-Geertsen [26], and is an open-source research project at Boston University. The SPQR analysis produced to date, combined with the temporal logic extensions, will likely reduce the amount of code that would actually need to be run for final verification of a pattern candidate to a very small set. Since rho-calculus is a strict superset of sigma-calculus, and since SPQR can encode the source code as rho-calculus, we can target small sections of the original code for translation and interpretation. Sigma shows that this is not only possible, but practical. The results of this interpretation can be directly analyzed within SPQR for the run-time behaviors we wish to confirm. In this manner SPQR gains much greater analysis capabilities. Prior to SPQR, however, Sigma's practicality has been limited to examples of theory, as it is only able to provide reasonable performance on extremely small sets of code. By using SPQR to definitively pare down the code base to small sample selections of source code, we bring added value to Sigma, raising it from a purely theoretical tool to one of practical worth. This is simply an example implementation, however, and we are by no means tied to using Sigma as the interpreter engine.","13. Comprehension of Code","Finally, we revisit the original motivation for this research, to reduce the time and effort required for an engineer to comprehend a system's architecture well enough to guide the maintenance and modification thereof. It is believed that the approaches described herein, along with the full catalog of EDPs and rho calculus, can form a formal basis for some very powerful source code analysis tools such as Choices [30], or KT [6], that operate on a higher level of abstraction than just \u201cclass, object and method interactions\u201d [30]. Discovery of patterns in an architecture should be become much more possible than it is today, and the discovery of unintended pattern uses should prove enlightening to engineers. In addition, the flexibility inherent in the rho-calculus will provide some interesting possibilities for the identification of new variations of existing patterns.","13.1. Training and Communication","SPQR will become a vital part of training new engineers on existing codebases, and EDPs are poised to become the lingua franca for describing design patterns and other architectural constructs. Using the two in tandem provides a powerful tool for corporate and academic education. The EDPs are too trivial in detail to be practical on their own without automated support, and SPQR is not effective without the common semantics of the EDPs. The combination of SPQR and the EDPs creates a unique training tool and communication platform.","13.2. Comprehension Metrics","Once we have the ability to quantify the pervasiveness of comprehensional units (design patterns or other constructs) within a source code base, it is natural to extend this to quantified metrics about that system. Such metrics will be beneficial not only to the engineers, but to the management of such systems as well SPQR offers, for the first time, the ability to quantify comprehensibility of a system in such a way that it does not require knowledge of the system in any respect to be able to use metrics about that system. Prior metrics have been limited to the engineering realm, as they necessarily required significant understanding of the system, environment, and domain to interpret. SPQR unifies the various architectural patterns and distills them into quantities of quality, eliminating the technical knowledge needed for many metrics.","Example metrics include coverage and concentration metrics to quantify comprehension and possible areas of interest in the code.","13.2.1. Comprehensibility Coverage","As a simple metric of code comprehensibility, we can measure the percentage of code elements that are used to directly and indirectly fulfill design pattern roles. For example, if a class A has five methods, one of which directly fulfills a design pattern role, and two of which are in support roles, then A has a 0.2 DirectPatternRole (Method) score, and a 0.4 IndirectPatternRole (Method) score. These two can be weighted heuristically to create an indication of the amount of code which is prominent in playing roles in design patterns. Since the patterns are a common language for discussion of architectural design, they are excellent indicators for the presence of comprehensibility cues. Quantifying the coverage of design patterns across the codebase gives a general guideline for the comprehensibility of the system, as expressed in design patterns. Engineers and management therefore have a common scaling for design comprehensibility, allowing justifications for code refactoring and redesign to be communicated effectively, and providing a basis for probabilistic estimations of maintenance costs for various designs.","13.2.2. Hotspot Detection","Once design pattern instances have been found, and the role fulfillment elements identified, those elements can begin to be weighted for cumulative effect. For instance, a method element can be given a weight of 1.0 as a primary role fulfiller for each unique role it fills. A lower weight, for example, 0.7, could be given for each occurrence of that method as a support role. 0.5 for a secondary support position, etc. High scoring methods would then be indicative of either a central calling point, and\/or a necessary high-level abstraction. This convergence of practical implementation and high-level abstraction in a single metric is unique to SPQR.","14. Analysis of Procedural Code","Given that SPQR can provide a path from OO source code to the discovery, documentation, and comprehension of pattern use within the code, then it is theoretically possible to produce the same end result from procedural code using slice and interface analysis.","Argument:","Slice analysis is used to help in refactoring procedural code to OO code by finding common data to function bindings, and suggesting which groupings would be natural candidates for class descriptions. These pseudo-, or degenerate, objects aren't true OO objects, but have many of the same features especially when viewed from a formal sigma-calculus point of view.","So, it comes down to this: can these degenerate classes (or objects) be properly represented in sigma-calculus such that SPQR can be applied? It is believed that these classes can be represented in sigma calculus. Others are working on refining this segment of the analysis and their work is highly promising (Ott, Bieman, etc, etc.)","Now, given the above path from procedural to patterns, it is believed that the analysis can be taken several more steps, drilling down all the way to a binary representation. Consider that moving from a binary to assembly code is a more or less solved problem, a purely mechanical transformation. Further consider that conversion of assembler to procedural code is likewise a fairly solved problem. (Aliasing of data is still an issue, but the core problems are well understood.) The problem with such reverse engineered code is that it is completely incomprehensible to human engineers; the main semantic tags used to comprehend the system, the names of variables and functions, are missing.","This is where SQPR steps in\u2014the analysis to identify pattern use is completely independent of the nomenclature used in the source code. Therefore, discovery of pattern use is just as capable on highly obfuscated code as it is on well named code.","Now, assuming we have the above binary to patterns path, several extremely interesting possibilities come to light:\n\n","The fact that SPQR is fully automated allows us to use it to brute-force problems that are currently beyond practical consideration. Once such application is mining for previously unidentified patterns amongst systems. (Unidentified in this sense means previously undescribed in the patterns literature, not just undiscovered within a specific system.)","Begin with the set of EDPs, E, and our rho-calculus rules for combining them. Mechanically generate all possible combinations, call this set E\u2032=E\u00d7\u03c1. Use this as the input search catalog for SPQR, and search on a codebase C. The subset \u00ca\u2032 of E\u2032 that was found in C is retained. Generate a new search catalog E\u2033=E\u2032\u00d7\u03c1, and repeat the process on C. Continue generating such search sets and retain the found elements of those sets. When the found set has been reduced to one member, the union of all found sets (\u00ca{circumflex over (\u2032)}\u222a\u00ca{circumflex over (\u2033)}\u222a\u00ca{circumflex over (\u2032)}{circumflex over (\u2033)}\u222a . . . ) comprises every combinatorial possibility of programmatic elements within the system. This will be a massive set. Remove those elements which are known, described patterns, (call this set P), again by using SPQR to search the set. The remaining elements are all constructs that are previously unknown to or undescribed in the patterns community. Call this results set R=(\u00ca{circumflex over (\u2032)}\u222a\u00ca{circumflex over (\u2033)}\u222a\u00ca\u2032\u2033\u222a . . . )\u2212P.","If this process is performed on a large number of systems, then the result sets from each can be cross-referenced. The intersection of these sets, (R\u2229R\u2229R\u2229 . . . ) will be a set of constructs who appear in several systems, yet are undescribed since the known patterns were eliminated from consideration. This is now a candidate set for manual inspection by an engineer as a place to start identifying new architectural patterns.","The sets generated by this approach will be immense . . . but since it's fully automatable, and since SPQR is inherently distributable (section 11.6), we can merely initiate and walk away until results are compiled.","16. Additional Features of the Subject Matter Described Herein","Our methods have been described in the context of the patterns described in the popular \u201cGang of Four\u201d textbook, however the applicability of these methods are in no way limited to these patterns. The SPQR methods will work with all patterns defined in other text books and research papers, as well as for future patterns since we have an effective training method.","SPQR is \u201ctrained\u201d by example. We write code that exhibits the pattern we wish it to find. The tools and methods analyze the structure of this sample code, and the results of analysis produce definitions of the new pattern structure in the formats required by the methods. There after, the new pattern definition is in the dictionary and can be found in subsequent code examinations by SPQR.","Our methods are independent of source language, operating system, computing platform, or software framework, or Integrated Development Environment. The tool chain is modular and for application to new source language, new frameworks, new platforms all that is needed is re-writing segments of the chain to deal with new input formats. The concepts are independent of these input formats.","Our methods are used for finding any general source code structure (such as the patterns we have indicated) that can be defined in the rho-calculus and other supporting formalisms described herein. This mean not only patterns, but what are commonly called \u201canti-patterns\u201d or structures to be avoided. This allows our methods to be used in support of software construction that is intended to produce code that matches some sort of important structure, or to \u201cavoid\u201d some structures.","SPQR can be implemented as stand-alone tools in a chain, as described above, or a plug-ins and add-ons for integrated development environments such as, but not limited to, Eclipse, Xcode, Project builder, etc. Our methods can be realized as tools and plug-ins that process the source code in \u201cbatch mode\u201d, processing the files completely as they operate; the methods can also be implemented so that the analysis is done piecemeal, such as in a software \u201cagent\u201d. This mean the methods can be applied constantly as development proceeds with the agent keeping constant checks on the developing code, applying the analysis continuously to determine if the developing code is adhering to the proper structures, or avoiding the proper structures.","17. EDP Catalog","The following pages give details of the Elemental Design Patterns (EDPs) corresponding to the most common object creation and method invocation forms. Those EDPs corresponding to object management, data cohesion, state change and field reliance are omitted.","CreateObject Object Creation","Also Known As","Instantiation","Intent",{"@attributes":{"id":"p-0248","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["To ensure that newly allocated data structures conform to a set of assertions and pre-conditions before they are operated on by the rest of the system, and that can only be operated on in predefined ways.\n\nMotivation\n","An object is a single indivisible unit of data and applicable methods that are conceptually related. We wish to ensure that this unit is in a particular coherent and well defined state before we attempt to operate on the object, and we wish to ensure that only well-defined operations can be performed on the object. In procedural languages, we can emulate an object rather well using records (C structs), and groupings of functions (libraries, perhaps with namespace encapsulation). We cannot, however, ensure either of our conditions.","We cannot, for example guarantee that at the time of allocation of the record that the record's contents conform to any specific assertion we may choose to make. We can make certain that particular classes of static assertions will hold (\u201cAll records will have their third entry be set to \u20185\u2019\u201d)."]}}}},{"@attributes":{"id":"p-0249","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef","struct {",{}]},{"entry":[{},{},"int a;"]},{"entry":[{},{},"float b;"]},{"entry":[{},{},"short c = 5;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} myStruct;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":"We can get around this problem in imperative languages by creating an initializer function that is to be called on all new allocated data records before use."}}}},{"@attributes":{"id":"p-0250","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void initializeMystruct( myStruct* ms ) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"static mt modulo3 = 0;"]},{"entry":[{},"if (modulo3 =\u2009= 2) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"modulo3 = 0;"]},{"entry":[{},"if (checkDay(\u2019tue\u2019)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ms\u2212>a = 1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"modulo3++;"]},{"entry":[{},"ms\u2212>a = 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["This will be an effective solution, but not an enforceable one. Enforcement relies on policy, documentation, and engineer discipline, none of which have proven to be ultimately accurate or reliable. Therefore, we are back to the original problem of not being able to guarantee that any given assertion holds true on the newly allocated data. A malicious, careless or lazy programmer could allocate the structure, and then fail to call the proper initialization procedure, leading to possible catastrophic consequences.","Object-based systems (and class-based systems) provide an alternative. When an object is allocated by a runtime, it is initialized in a well-formed way that is dependent on the language and environment. All object-oriented environments provide some analogous mechanism as a fundamental part of their implementation. This mechanism is the hook at which the implementor can create a function (usually called the initializer or constructor) that performs the appropriate setup on the object. In this way any specific assertion can be imposed on the data before it is available for use by the rest of the system.","More formally, we can say that by using the CreateObject pattern for some assertion A and some object o, A(o) is always true immediately following the creation of o. Without the CreateObject pattern, we can only state that either A(o), or D(o), where D is the default state of allocated storage in our system. The former is preferred for reducing errors.","There is no way for a user of the object to bypass this mechanism, it is enforced by the language and runtime environment. The hypothetical malicious, careless or lazy programmer is thwarted, and a possible error is avoided. Since this type of error is generally extremely difficult to track down and identify, avoidance is preferred.","Similarly, we could emulate an object by the record and library approach of an imperative language and document that only certain operations from a pre-defined library may be used on that data structure, but there is no way to enforce such a policy. An object has a pre-defined set of methods that correspond to the functionality of that object, and only they may interact directly with the embedded data structure.\n\nApplicability\n"]}}}},"Use CreateObject when:\n\n",{"@attributes":{"id":"p-0252","num":"0303"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Bunny {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Bunny( int earLength );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"int"]},{"entry":[{},"main(int argc, char** argv) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Bunny b = new Bunny(1);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":{"@attributes":{"id":"ul0025-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":["To provide a common interface for operating on an object type family, but delaying definition of the actual operations to a later time.\n\nAlso Known As\n","Virtual Method, Polymorphism, Defer Implementation\n\nMotivation\n","Often we will find that while we have a hierarchy of classes using the Inheritance pattern that conforms well to our conceptual design, occasionally we see that we run into a situation where we simply cannot provide a meaningful method implementation. We know conceptually what we want to do, we're just not entirely sure exactly how to go about doing it.\n\nApplicability\n","Use AbstractInterface when:\n        \n        ",{"@attributes":{"id":"ul0026-0005","num":"0311"},"figref":"FIG. 22","br":{}},"A The class type that declares an interface for operation\n\nCollaborations\n","A defines an interface for a method, that some unknown later subclass will implement.\n\nConsequences\n","The CreateObject pattern lets us instantiate objects, and the Retrieve pattern shows how to fill in the fields of that newly created object.","AbstractInterface is unusual in that it indicates the absence of a method implementation; instead of showing us to fill in the method, it shows us how to defer the method definition until a later date. Note that this pattern does not actually provide the fill picture, including the later definition of the method. See the related FulfillMethod pattern for the rest of the solution.","The method is declared, to define the proper interface for our conceptual needs, yet the method body is left undefined. This does not mean that we simply define an empty method, one that does nothing . . . the method has no definition at all. This is a critical point, and one that is often missed by new object-oriented programmers. How this is done will vary from language to language. For instance, in C++ the method is set \u2018equal to zero\u2019 as shown in the example code.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0253","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class AbstractOperations {"]},{"entry":[{},"public:"]},{"entry":[{},"virtual void operation(\u2009) = 0;"]},{"entry":[{},"};"]},{"entry":[{},"class DefinedOperations : public AbstractOperations {"]},{"entry":[{},"public:"]},{"entry":[{},"void operation(\u2009);"]},{"entry":[{},"};"]},{"entry":[{},"void"]},{"entry":[{},"DefinedOperations::operation(\u2009) {"]},{"entry":[{},"\/\/ Perform the appropriate work"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":{"@attributes":{"id":"ul0028-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":["To use an object from another non-local source in the local scope, thereby creating a relationship and tie between the local object and the remote one.\n\nMotivation\n","Objects are a solid mechanism for encapsulating common data and methods, and enforcing policy, as shown in CreateObject. Singular objects, however, are of extremely limited power. In fact, if there were only one object in a system, and nothing external to it, it could be considered a procedural program\u2014all data and methods are local and fully exposed to one another. Non-object data types can be faked in any OO system that supports the use of function objects and method-less classes. It is therefore critical that a well formed methodology be put into place for transporting objects across object boundaries. There are two situations where this is applicable and they differ only slightly.","First, there is the simplest case where an external object has an exposed field that is being accessed, and secondly, where an external object has a method which is called, and the return value of that method is being used in the internal scope.\n\nApplicability\n","Use Retrieve when:\n        \n        ",{"@attributes":{"id":"ul0029-0005","num":"0325"},"figref":"FIG. 21","br":{},"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":["Source","The object (or class) type that contains selected.","Sink","The object (or class) type that includes the item, target, to be given a new value.","Retrieved","The type of the value to be updated, and the value that is returned.","target","The field that is given a new value.","selected\n\nThe method or field that produces the new value. Collaborations\n"]}},"This is a very simple relationship, consisting of two objects, and two methods. The distinguishing factors are the transferral of a return value into the local object space, and an update to a local field using that retrieved object.\n\nConsequences\n","Most object-oriented languages do not allow the updating of methods with new values (method bodies), instead only data fields can be updated in this manner. From a theoretical point of view, there is no appreciable difference between these two scenarios, and we allow for both, instead relying on the language semantics themselves to govern which cases are valid and which are not. By deferring our definition until we have a set of well-formed calculus facts, we avoid much of the complexity of handling the myriad of language quirks.","Tying two objects and\/or types like this is an everyday occurrence, but it is one that should not be done without thought.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0254","num":"0338"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Source {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Retrieved giveMeAValue(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class Sink {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Retrieved target;"]},{"entry":[{},"Source srcobj;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation(\u2009) { target = srcobj.giveMeAValue(\u2009); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":{"@attributes":{"id":"ul0032-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":["To use all of another classes' interface, and all or some of its implementation.\n\nAlso Known As\n","IsA\n\nMotivation\n","Often times an existing class will provide an excellent start for producing a new class type. The interface may be almost exactly what you're looking for, the existing methods may provide almost what you need for your new class, or at the very least, the existing class is conceptually close to what you wish to accomplish.","In such cases, it would be highly useful and efficient to reuse the existing class instead of rewriting everything from scratch. One way of doing so is by the use of Inheritance. Every object-oriented language supports this approach of code reuse, and it is usually a core primitive of that language.","At its most basic, this pattern offers a relationship between a superclass or base class, and a subclass or derived class. The superclass (let's call it Superclass) is an existing class in the system, one that provides at a minimum an interface of concepts for methods, and\/or data structures. A second class can be defined as being derived from Superclass, let's call it Subclass. The Subclass class inherits the interface and implementations of all methods and fields of Superclass, and this provides a starting point for a programmer to begin work on Subclass.\n\nApplicability\n","Use Inheritance when:\n        \n        ",{"@attributes":{"id":"ul0033-0007","num":"0348"},"figref":"FIG. 23","br":{}},"Superclass","An existing class in a system that is used as a basis for producing a further class","Subclass","The secondary class that relies on the first for its basic interface and implementation\n\nCollaborations\n","The Superclass creates a basic set of method interfaces and possibly accompanying method implementations. Subclass inherits all the interface elements of Superclass, and, by default, all of the implementations as well, which it may choose to override with new implementations.\n\nConsequences\n","Inheritance is a powerful mechanism, but has some interesting limitations and consequences. For one thing, a subclass may not remove a method or data field in most languages. (There a few exceptions, but these are rare, and beyond the scope of this pattern, as this gets to the heart of a subtlety of object-oriented theory.) A subclass is limited to overriding a method with a new implementation, or adding new methods or data fields.","It may seem that overriding is a waste of good code in the base class, and in many cases this is true. Look to the ExtendMethod pattern for a solution to this problem.","In some cases, one may not wish to inherit an entire existing class, but instead just small pieces of functionality may be desired. This may be due to a lack of confidence in the actual implementations of the method bodies (often when the original source code is unavailable), a reluctance to absorb a large class when only a small segment is needed, or other scenarios. In such situations, consider instead the Delegate pattern.\n\nImplementation\n","The mechanism for creating an inheritance relationship will vary from language to language, but is almost always readily apparent. Assume that we are modeling a rabbit farm, and wish to keep track of the health of the bunnies on hand. We make a class Bunny that contains the basic info for all rabbits, of any type. In addition, though, for lop-eared rabbits, we want to keep track of the ear length for breeding purposes. We can subclass a new class LopEaredBunny from Bunny, gaining all the necessary data and methods to model a rabbit, and we can then add additional information as we see fit:"]}}}},{"@attributes":{"id":"p-0255","num":"0358"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Bunny {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Bunny(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class LopEaredBunny : public Bunny {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"LopEaredBunny (\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":{"@attributes":{"id":"ul0035-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["To parcel out, or delegate, a portion of the current work to another method in another object.\n\nAlso Known As\n","Messaging, Method Invocation, Calls\n\nMotivation\n","In the course of working with objects, it invariably comes about that \u2018some other object\u2019 can provide a piece of functionality we want to have. Delegate embodies the most general form of a method call from one object to another, allowing one object to send a message to another, to perform some bit of work. The receiving object may or may not send back data as a result.\n\nApplicability\n","Use Delegate when:\n        \n        ",{"@attributes":{"id":"ul0036-0005","num":"0364"},"figref":"FIG. 24","br":{}},"Delegator The object type sending the message to the Delegate","operation","The method within the Delegator that is currently being executed when the message is sent\u2014the point of invocation of the operation2 method call","Delegate","The object type receiving the message, with an appropriate method to be invoked","operation2","The method being invoked from the call site\n\nCollaborations\n","A simple binary relationship, one method calls another, just as in procedural systems, and with the same sorts of caveats and requirements. Since we are working in an object-oriented realm, however, we have a couple of additional needs. First, that the object being called upon to help with the current task must be visible at the point of invocation. Second, that the method being invoked must be visible external to the enclosing object.\n\nConsequences\n","All operations between any two objects can be described as an instance of the Delegate pattern, but it is much more useful to be able to describe further attributes of the relationship. See the further Method Invocation EDPs for refinements of Delegate that will be more useful.\n\nImplementation\n","The most generalized and basic style of method invocation in object-oriented programming, Delegate is how two objects communicate with each other, as the sender and receiver of messages, performing work and returning values."]}}}},{"@attributes":{"id":"p-0256","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Delegator {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Delegatee target;"]},{"entry":[{},"void operation(\u2009) {target.operation2(\u2009);};"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class Delegatee {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation2(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":{"@attributes":{"id":"ul0038-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":["To request that another object perform a tightly related subtask to the task at hand, perhaps performing the basic work.\n\nMotivation\n","A small refinement to Delegate, Redirect takes into consideration that methods performing similar tasks are often named similarly. We can take advantage of this to provide more clarity as to the intent of this pattern over the more general form.\n\nApplicability\n","Use Redirect when:","A task to be performed by a method can be broken down into subtasks.","One of those subtasks can be achieved by using another object.","That target object has a method that has a similar intent, expressed through its signature name after Kent Beck's Intention Revealing Selector pattern.","There is no distinct type relationship between the two objects.\n\nStructure\n",{"@attributes":{"id":"ul0039-0008","num":"0383"},"figref":"FIG. 25","br":{}},"Redirector","The originating site of the method call, contains a method named operation which has a subtask to be parceled out to another object. This object, redirectTarget, is a field element of type Redirectand Redirector's operation calls redirectTarget.operation to perform a portion of its work.","Redirectand","The receiver of the message, which performs the subtask asked of it.\n\nCollaborations\n","As with Delegate (and indeed all the Method Invocation EDPs), Retrieve is a binary relationship, between two objects and their enclosed methods.\n\nConsequences\n","Almost identical to the Delegate pattern, the seemingly small equivalence of method names has some far-reaching effects, particularly when this pattern is combined with other EDPs and typing information to form complex interactions, as we will see in later patterns. By leveraging the fact that both methods have the same name, and that this is a common way of declaring the intent of a method, we can deduce that this is an appropriate way of indicating that our originating call site method is requesting the invoked method to do some portion of work that is tightly related to the core functionality of the original method.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0257","num":"0390"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Foo {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"operation(\u2009)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class Bar {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Foo f;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"operation (\u2009) { f.operation (\u2009); };"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0040","list-style":"none"},"li":{"@attributes":{"id":"ul0040-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0041","list-style":"none"},"li":["To bring together, or conglomerate, diverse operations and behaviors to complete a more complex task within a single object.\n\nAlso Known As\n","Decomposing Message\n\nMotivation\n","Often times an object is asked to perform a task which is too large or unwieldy to be performed within a single method. It usually makes conceptual sense to break the task into smaller parts to be handled individually as discrete methods, and then built back into a whole result by the method responsible for the larger task. (Kent Beck refers to this as the Decomposing Message pattern.) It may also happen that related subtasks can be unified into single methods, resulting in reuse of code inside a single object.\n\nApplicability\n","Use Conglomeration when:","A large task can be broken into smaller subtasks","That task can, or must, be performed within a single object","Several subtasks may be unified into a single method body\n\nStructure\n",{"@attributes":{"id":"ul0041-0008","num":"0398"},"figref":"FIG. 26","br":{}},"Conglomerator","Enclosing object type","operation","Master controlling method that is parcelling out subtasks","operation2","Subservient method performing a particular subtask\n\nCollaborations\n","A specialization of Delegate, the object is calling a method of itself.\n\nConsequences\n","As with Delegate, this pattern ties two methods into a reliance relationship, with operation relying on the behaviour and implementation of operation2. In this case, however, there may be immediate side effects to shared data within the confines of the object that they share.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0258","num":"0407"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Conglomerate {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void operation(\u2009) { operation2(\u2009); };"]},{"entry":[{},"void operation2(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0042","list-style":"none"},"li":{"@attributes":{"id":"ul0042-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":["To accomplish a larger task by performing many smaller similar tasks, using the same object state.\n\nMotivation\n","Sometimes we run across a problem that, after analysis, can be broken down into smaller subtasks that are identical to the original task, except at a smaller scale. Sorting an array of items using the Merge Sort algorithm is one such example. Merge Sort takes an array and divides it into two halves, sorting each individually, then merging the two sorted arrays into a unified whole. Of course, each half sorted is done so by calling Merge Sort again, so they are again halved, and so on. Eventually arrays of a single item are reached, at which point the merging begins.","The process by which a method calls itself is known as recursion, and is ubiquitous in general programming. In object-oriented programming, the same principle applies, except that we have the added requirement that the object must be calling on itself, through an implicit or explicit use of self. (See Redirect for an example of calling another object, and RedirectedRecursion for calling another object of the same type.)","Recursion is, generally speaking, a way of folding a large amount of computation into a small conceptual space. Say we want to sort an array, and we decide that the easiest way to sort a large array is to split it into two roughly equal sized arrays, and then merge the two subarrays. The merging will be easy\u2014if the head of array A is less than the head of array B, then the head of A is copied to the new, larger array, otherwise, copy the head of B. Remove the copied item from the appropriate array, and repeat until both arrays are merged.","Now, since this Merge Sort scheme relies on the subarrays being properly sorted, we correctly surmise that we can perform the sort algorithm on the two subarrays, splitting, sorting, then merging each in turn. Again, we are faced with the same sorting problem, so we continue in the same manner until we reach the smallest indivisible array, namely a single item. At that point, merging of sorted subarrays at each step can begin.","Assume we have an Array class that has the usual methods of add and delete. If we knew that the length of the beginning array was 4 items, then we could hardcode the entire sorting in pseudo-code like so:"]}}}},{"@attributes":{"id":"p-0259","num":"0414"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Array"]},{"entry":[{},"sort_merge(Array a) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a11 = a[0];"]},{"entry":[{},"a12 = a[1];"]},{"entry":[{},"a21 = a[2];"]},{"entry":[{},"a22 = a[3];"]},{"entry":[{},"\/\/ Sort first half"]},{"entry":[{},"if (a11 < a12) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a1.add(a11);"]},{"entry":[{},"a1.add(a12);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a1.add(a12);"]},{"entry":[{},"a1.add(a11);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Sort second half"]},{"entry":[{},"if (a21 < a22) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a2.add(a21);"]},{"entry":[{},"a2.add(a22);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a2.add(a22);"]},{"entry":[{},"a2.add(a21);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Merge"]},{"entry":[{},"if (a1[0] < a2[0]) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a1[0]);"]},{"entry":[{},"a1.delete(0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a2[0]);"]},{"entry":[{},"a2.delete(0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (a1[0] < a2[0]) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a1[0]);"]},{"entry":[{},"a1.delete(0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a2[0])."]},{"entry":[{},"a2.delete(0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (a1.length =\u2009= 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a2[0]);"]},{"entry":[{},"res.add(a2[1]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (a2.length =\u2009= 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a1[0]);"]},{"entry":[{},"res.add(a1[1]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (a1.length =\u2009= 1 && a2.length =\u2009= 1) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a1[0]);"]},{"entry":[{},"res.add(a2[0]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0044","list-style":"none"},"li":{"@attributes":{"id":"ul0044-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":"While highly efficient (more on this later), this has a drawback . . . it is limited to only working for arrays of length 4. A much more general version of this is one using looping. Here, we illustrate a for loop implementation (assuming for simplicity that the length of the array is a power of 2):"}}}},{"@attributes":{"id":"p-0260","num":"0416"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sort_array(Array a) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Slice a into subarrays"]},{"entry":[{},"subarray[0][0] = a"]},{"entry":[{},"for (i = 1 to log_2(a.length(\u2009))) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for (j = 0 to 2{circumflex over (\u2009)}i) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"prevarray = subarray[i\u22121][floor(j\/2)]"]},{"entry":[{},"subarray[i][j] = prevarray.slice("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(j mod 2) * (prevarray.length(\u2009) \/ 2),"]},{"entry":[{},"((j mod 2) + 1) * (prevarray.length(\u2009) \/ 2))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Sort subarrays and merge"]},{"entry":[{},"for (i = log_2(a.length(\u2009)) to 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for (j = 1 to 0) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"subarray[i][j]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return subarray[0][0]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0046","list-style":"none"},"li":{"@attributes":{"id":"ul0046-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0047","list-style":"none"},"li":"This succeeds in making our algorithm much more flexible, but at a cost of making it almost unreadable due to the overhead mechanisms. Note that we are looping inward to the base case (length of array is a single unit), storing state at every step, then looping outward using the state previously stored. This process of enter, store, use store, and unroll is precisely what a function call accomplishes. We can use this fact to vastly simplify our implementation using Recursion:"}}}},{"@attributes":{"id":"p-0261","num":"0418"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Array"]},{"entry":[{},"sort_array(Array a, int beg, int end) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if(a.length(\u2009) > 1) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return merge(sort_array(a, beg, end\u2212beg\/2),"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sort_array(a, (end\u2212beg\/2) + 1, end));"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return a"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0262","num":"0419"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Array"]},{"entry":[{},"merge(Array a, Array b) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Array res;"]},{"entry":[{},"while (b.length(\u2009) > 1 || a.length(\u2009) > 1) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ If a or b is empty, then a[0] or b[0] returns a min value"]},{"entry":[{},"if (a[0] < b[0]) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(a[0]);"]},{"entry":[{},"a.delete(0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"res.add(b[0]);"]},{"entry":[{},"b.delete(0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return res;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0048","list-style":"none"},"li":{"@attributes":{"id":"ul0048-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0049","list-style":"none"},"li":["This is a much cleaner conceptual version that performs the same task as our looping variation. We are letting the runtime of the language handle the overhead for us.","There are times, however, when that overhead handling may be determined to be excessive for our needs, such as in a high-performance embedded system. In such cases, optimizing away the recursion into loops, or further into linear code, is a possibility. These instances are extreme however, and tend to be highly specialized. In most cases the benefits of Recursion (conceptual cleanliness, simple code) greatly outweigh the small loss of speed.","The above example is based on the recursion of a method, but that is strictly for simplification of the problem. In an object-oriented system, there are no free methods, therefore any method that is truly recursive is bound to a particular object, not just a specific type.\n\nApplicability\n","Use Recursion when:","A task can be divided into highly similar subtasks","The subtasks must be, or are preferred to be, performed by the same object, usually due to a necessity of access to common stored state.","A small loss of efficiency is overwhelmed by the gain in simplicity.\n\nStructure\n",{"@attributes":{"id":"ul0049-0008","num":"0427"},"figref":"FIG. 27","br":{}},"Recursor","The only participant, Recursor has a method that calls back on itself, within the same instantiation.\n\nCollaborations\n","Recursor's method operation collaborates with itself, requesting smaller and smaller tasks to be performed at each step, until a base case is reached, at which point results are gathered into a final result.\n\nConsequences\n","The reliance of Recursion on a properly formed base case for termination of the recursion stack is the weakest point of this pattern. It is nearly impossible in most modern systems to wantonly consume all available resources . . . but recursion can do it easily by having a malformed base case that is never satisfied.\n\nImplementation\n","See above code examples.\n\nRevertMethod Object Behavioral\n\nIntent\n","Bypass the current class' implementation of a method, and instead use the superclass' implementation, reverting to an \u2018earlier\u2019 method body.\n\nMotivation\n","There are times when polymorphism works against us. One such instance would be when providing multiple versions of classes for simultaneous use within a system. Imagine a library of classes for an internet data transfer protocol. A base library is shipped as 1.0. With the 1.1 library, changes to the underlying protocol are made, and an application using the 1.1 protocol must be able to fall back to the 1.0 protocol when it detects that the application at the other end of the connection is only 1.0 enabled.","Now, one approach would be to use polymorphism directly, and have a base class that abstractly provides the protocol's methods, as in , and create the proper class item on protocol detection. Unfortunately, this doesn't give us a lot of dynamic flexibility . . . what if the protocol needs to adapt on the fly, so that the two ends can handle graceful degradation of the connection, for instance. You could instantiate objects of each protocol type, and swap back and forth as needed, but there may be protocol state issues that would be troublesome.","So instead we may elect to have the base protocol class subclassed by a 1.1 version class, and just instantiate that instead. We now have only a single class to deal with, but we still need to be able to revert to the previous version. In  we show an extended variant of this approach, with several versions.","In this case we can instantiate an object of just the last class in the chain, ProtocolHandler1.2, and conditional statements in the code will pass the protocol handling back up the chain to the appropriate version if needed. Note that we can make a simple test for whether or not the current object's version is appropriate for the protocol, and if not, pass it simply to super, and let the test be re-enacted there, and so on. This vastly simplifies further maintenance of code that supports this protocol, since only the instance(s) of the ProtocolHandler need to be changed to the latest version anytime a new update to the library comes out, and all the graceful degradation is handled automatically. (Or, a specific version can be hardcoded for various reasons\u2014it is up to the application developer.)\n\nApplicability\n","Use RevertMethod when:","A class wishes to a prior implementation of a method that it has overridden.\n\nStructure\n",{"@attributes":{"id":"ul0049-0021","num":"0440"},"figref":"FIG. 30","br":{}},"OriginalBehaviour","A base class, defining two methods, operation and operation2.","RevertedBehavior","A subclass of OriginalBehaviour, with operation and operation2 overridden. operation calls the OriginalBehaviour implementation of operation2 (when one would normally expect it to call its own implementation of that method.)\n\nCollaborations\n","In most cases when a subclass overrides a parent class' method, it is to replace the functionality, but the two method definitions can work together to allow an extension of the behaviour. RevertedBehaviour relies on OriginalBehaviour for a core implementation.\n\nConsequences\n","There is an odd disconnect conceptually between the overriding of a base class' method, and the utilization of that same method that can be confusing to some students. Overriding a method does not erase the old method, it merely hides it from public view for objects of the subclass. The object still has knowledge of its parent's methods, and can invoke them internally without exposing this to the external world.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0263","num":"0447"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class OriginalBehaviour {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation(\u2009) { operation2(\u2009); };"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"protected:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation2(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class RevertedBehavior: public OriginalBehaviour {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation(\u2009) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (oldBehaviorNeeded) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"OriginalBehaviour::operation2(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"operation2(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"private:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation2(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0050","list-style":"none"},"li":{"@attributes":{"id":"ul0050-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0051","list-style":"none"},"li":["Add to, not replace, behavior in a method of a superclass while reusing existing code.\n\nAlso Known As\n","Extending Super\n\nMotivation\n","There are many times when the behavior of a method needs to be altered or extended, for reasons such as fixing a bug in the original method when the source code is unavailable, adding new functionality without changing the original method, etc.","One of the most common ways of doing this is, of course, to cut and paste the old code into the new method, but this presents a host of problems, including consistency of methods, and results in a potential maintenance morass. It is much better to adhere to the Single Point Principle and instead reuse the existing code, tweaking the results as needed.","It is possible, of course, to create a reference to a delegate object with the original behavior, and then call into it when needed. This is the approach taken in the Redirect EDP.","In other cases, it is necessary or desired to subclass directly off of the original class. In such cases, we have two options for extending the original method. One is to cut and paste the old code into the new subclass' method, but this is not only undesirable from a maintenance standpoint, but also may not be possible, as in cases where the original source code is unavailable.","The second is Extend Method EDP. In this case, we use Inheritance EDP to provide the mechanism for reuse. We then override the original method, but make a call back to the superclass' implementation of the method. This provides us with simple maintenance, reuse, and encapsulation of the altered behavior.\n\nApplicability\n","Use Extend Method when:","Existing behavior of a method needs to be extended but not replaced.","Reuse of code is preferred or necessitated by lack of source code.","Polymorphic behavior is required.\n\nStructure\n",{"@attributes":{"id":"ul0051-0012","num":"0459"},"figref":"FIG. 31","br":{}},"OriginalBehaviour","Defines interface contains a method with desired core functionality.","Extended Behaviour","Uses interface of OriginalBehaviour, re-implements method as call to base class code with added code and\/or behavior.\n\nCollaborations\n","In most cases when a subclass overrides a parent class' method, it is to replace the functionality, but the two method definitions can work together to allow an extension of the behaviour. ExtendedBehaviour relies on OriginalBehaviour for both interface and core implementation.\n\nConsequences\n","There is an odd disconnect conceptually between the overriding of a base class' method, and the utilization of that same method that can be confusing to some students. Overriding a method does not erase the old method, it merely hides it from public view for objects of the subclass. The object still has knowledge of its parent's methods, and can invoke them internally without exposing this to the external world. Code reuse is optimized, but the method Operation in OriginalBehaviour becomes somewhat fragile\u2014its behaviour is now relied upon by ExtendedBehaviour::Operation to be invariant over time. Behaviour is extended polymorphically and transparently to clients of OriginalBehaviour.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0264","num":"0466"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class OriginalBehaviour {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"virtual void operation(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class ExtendedBehaviour : public OriginalBehaviour {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"void"]},{"entry":[{},"OriginalBehaviour::operation(\u2009) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ do core behavior"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"void"]},{"entry":[{},"ExtendedBehaviour::operation(\u2009) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"this\u2212>OriginalBehaviour::operation(\u2009);"]},{"entry":[{},"\/\/ do extended behavior"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{},{}],"ul":{"@attributes":{"id":"ul0052","list-style":"none"},"li":{"@attributes":{"id":"ul0052-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0053","list-style":"none"},"li":["A Conglomeration pattern is appropriate, but we need to work with a distinct instance of our object type, resulting in a need for the Delegate pattern to be used.\n\nMotivation\n","Many times we have objects of the same type working in concert to perform tasks. User interfaces are frequently coded as a collection of like objects collaborating to produce a larger functionality.\n\nApplicability\n","Use DelegatedConglomeration when:","A task can be broken into subtasks that are properly handled by the same object type","Many objects of the same type work in concert to complete a task","A single object is unable to complete the task alone\n\nStructure\n",{"@attributes":{"id":"ul0053-0007","num":"0473"},"figref":"FIG. 32","br":{}},"Delegator","The object type that contains references to other instances of its own type","delegateTarget","The enclosed instance that is called upon to perform a task","operation","The calling point within the first object","operation2","The subtask to be completed\n\nCollaborations\n\nConsequences\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0265","num":"0482"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Delegator {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Delegator delegateTarget;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void operation(\u2009) { delegateTarget.operation2(\u2009); };"]},{"entry":[{},"void operation2(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0054","list-style":"none"},"li":{"@attributes":{"id":"ul0054-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0055","list-style":"none"},"li":["To perform a recursive method, but one that requires interacting with multiple objects of the same type.\n\nMotivation\n","Frequently we will wish to perform an action that is recursive in nature, but it requires multiple objects working in concert to complete the task. Imagine a line of paratroopers getting ready for a jump. Space it tight, so instead of the commander indicating to each trooper to jump at the door, he stands at the back of the line, and when time has come, taps the last trooper on the shoulder. He knows to tap the shoulder of the trooper in front of him, and when that soldier has jumped, jump himself. This can continue on down a line of arbitrary length, from 2 to 200 troopers. All they have to do is when they feel a tap on their shoulder, tap the next person in line, wait, shuffle forward as space is available, and when they see the soldier in front of them go, jump next. The commander issues one order, instead of one to each soldier. A sample coding of this might look like:"]}}}},{"@attributes":{"id":"p-0266","num":"0485"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Paratrooper::jump(\u2009) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"nextTrooper\u2212>jump(\u2009);"]},{"entry":[{},"while (! nextTrooper\u2212>hasJumped(\u2009) ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"shuffleForward(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"leap(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":{"@attributes":{"id":"ul0056-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":["The current paratrooper cannot jump until the trooper in front has completed their task, and so on, and so on.\n\nApplicability\n","Use RedirectedRecursion when:","Recursion is a clean way of breaking up the task into subparts","Multiple objects of the same type must interact to complete the task\n\nStructure\n",{"@attributes":{"id":"ul0057-0005","num":"0490"},"figref":"FIG. 33","br":{}},"Recursor","An object type that holds a reference to another instance of its own type","redirectTarget","The enclosed instance","operation","A method within Recursor that is recursive on itself . . . but through redirectTarget\n\nCollaborations\n\nConsequences\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0267","num":"0497"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class Recursor {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Recursor redirectTarget;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation(\u2009) { redirectTarget.operation(\u2009); };"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0058","list-style":"none"},"li":{"@attributes":{"id":"ul0058-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0059","list-style":"none"},"li":["Related classes are often defined as such to perform tasks collectively. In such cases, multiple objects of related types can interact in generalized ways to delegate tasks to one another.\n\nMotivation\n","User interfaces are a familiar type of system in which to find DelegatelnFamily and related patterns (DelegateInFamily, RedirectInFamily, RedirectInLimitedFamily). This pattern allows one to parcel out tasks within a family of classes (often called a class cluster) when the interface, and method name, are known, but the precise object type (and therefore method body) may not be. It is a form of polymorphic delegation, where the calling object is one of the polymorphic types.","Consider a windowing system that includes slider bars and rotary dials as input controls, and text fields and bar graphs as display widgets. A input control is tied to a particular display widget, and sends it updates of values when the control is adjusted by the user. The input controls don't need to know precisely what kind of display widget is at the other end, they just need to know that they must call the updateValue method, with the appropriate value as a parameter. Since input controls also display a value implicitly, it is possible to programmatically change their adjustment accordingly, so they too need an updateValue method. By our Inheritance pattern, it looks as if the input controls and display widgets are of the same family, and in fact we want to make sure that they can all interact, so we create a class hierarchy accordingly:"]}}}},{"@attributes":{"id":"p-0268","num":"0501"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class UIWidget {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void updateValue( int newValue );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"class InputControl : UIWidget{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UIWidget* target;"]},{"entry":[{},"void userHasSetNewValue(\u2009) {. . . target-"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":">updateValue(myNewValue); . . . }"},{"entry":"};"},{"entry":"class SliderBar : InputControl {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void updateValue( int newValue );"]},{"entry":[{},"\/\/ Moves the slider bar accordingly"]},{"entry":[{},"void acceptUserClick(\u2009) {. . . userHasSetNewValue(\u2009); . . . };"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"class RotaryKnob : InputControl {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void updateValue( int newValue );"]},{"entry":[{},"\/\/ Rotates the knob image accordingly"]},{"entry":[{},"void acceptUserClick(\u2009) {. . . userHasSetNewValue(\u2009); . . . };"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"class DisplayWidget : UIWidget {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GraphicsContext gc;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"class TextField : DisplayWidget {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void updateValue( int newValue ) { gc.renderAsText( newValue"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"); };"},{"entry":"};"},{"entry":"class BarGraph : DisplayWidget {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void updateValue ( int newValue ) { gc.drawBarLengthOf("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"newValue ); };"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"ul":{"@attributes":{"id":"ul0060","list-style":"none"},"li":{"@attributes":{"id":"ul0060-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0061","list-style":"none"},"li":["In the above example, the InputControl and UIWidget classes are the ones fulfilling roles in a DelegateInFamily pattern.","The SliderBar and RotaryKnob objects don't have to know anything about where their value is going, and in fact, they could be tied to each other, with each adjusting the other in sync. (You could even have two objects of the same lnputControl subclass tied together, such as two SliderBar instances.) We have separated the concerns of who is sending what data, and who is receiving it. All that is of concern is that the data is being sent to a properly receiving client polymorphically, and that the current calling object is of that polymorphic family. This allows for a single unified interface for many classes that can work in tandem to perform many tasks.\n\nApplicability\n","Use DelegateInFamily when:","Delegation is appropriate, with not necessarily related subtasks to be performed","Polymorphism is required to properly handle the message request","The calling object is of a type in the polymorphic hierarchy\n\nStructure\n",{"@attributes":{"id":"ul0061-0007","num":"0508"},"figref":"FIG. 34","br":{}},"FamilyHead","The base class for a polymorphic class cluster","Delegator","A subclass of FamilyHead","target","A polymorphic instance of FamilyHead that is contained by Delegator","operation","The calling site","operation2","The called subtask\n\nCollaborations\n\nConsequences\n\nImplementation\n","The target can be defined in either the base class, or the subclass, itjust needs to be accessible from with the subclass."]}}}},{"@attributes":{"id":"p-0269","num":"0520"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"In C++:"},{"entry":"class FamilyHead {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void operation(\u2009);"]},{"entry":[{},"void operation2(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"class Delegator : public FamilyHead {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"FamilyHead target; void operation(\u2009) { target\u2212>operation2(\u2009); };"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0062","list-style":"none"},"li":{"@attributes":{"id":"ul0062-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0063","list-style":"none"},"li":["Redirect some portion of a methods implementation to a possible cluster of classes, of which the current class is a member.\n\nMotivation\n","Frequently a hierarchical object structure of related objects will be built at runtime, and behavior needs to be distributed among levels.\n\nApplicability\n","Use RedirectInFamily when:","An aggregate structure of related objects is expected to be composed at compile or runtime.","Behavior should be decomposed to the various member objects.","The structure of the aggregate objects is not known ahead of time.","Polymorphic behavior is expected, but not enforced.\n\nStructure\n",{"@attributes":{"id":"ul0063-0008","num":"0528"},"figref":"FIG. 35","br":{}},"FamilyHead","Defines interface, contains a method to be possibly overridden.","Redirecter","Uses interface of FamilyHead redirects internal behavior back to an instance of FamilyHead to gain polymorphic behavior over an amorphous object structure\n\nCollaborations\n","Redirecter relies on the class FamilyHead for an interface, and an instance of same for an object recursive implementation.\n\nConsequences\n","Redirecter is reliant on FamilyHead for portions of its functionality.\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0270","num":"0535"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class FamilyHead {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"virtual void operation(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class Redirecter : public FamilyHead {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void operation(\u2009);"]},{"entry":[{},"FamilyHead* target;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"void"]},{"entry":[{},"Redirecter::operation(\u2009) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ preconditional behavior"]},{"entry":[{},"target\u2212>operation(\u2009);"]},{"entry":[{},"\/\/ postconditional behavior"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0064","list-style":"none"},"li":{"@attributes":{"id":"ul0064-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0065","list-style":"none"},"li":["When DelegateInFamily is too generalized, and it is necessary to pre-select a sub-tree of the class hierarchy for polymorphism.\n\nMotivation\n","Static typing is a way of pre-selecting types from a well defined pool, and forming more concrete notions of an object's type at runtime. Polymorphism is a technique for abstracting out typing information until runtime. Sometimes we need a balance of the two. This pattern and the related RedirectInLimitedFamily both weigh these opposing forces but for slightly different outcomes.","This pattern is concerned with Delegation, the more generalized form of computational subtasking.\n\nApplicability\n","Use DelegateInLimitedFamily when:","DelegateInFamily is the appropriate general pattern . . .",". . . but greater control over the possible types of objects is required\n\nStructure\n",{"@attributes":{"id":"ul0065-0007","num":"0542"},"figref":"FIG. 36","br":{}},"FamilyHead","The base class for a polymorphic class cluster","Delegator","A subclass of FamilyHead","DelegateSibling","Another subclass of FamilyHead","target","A polymorphic instance of DelegateSibling that is contained by Delegator","operation","The calling site","operation2","The called subtask\n\nCollaborations\n\nConsequences\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0271","num":"0555"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class FamilyHead {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void operation(\u2009);"]},{"entry":[{},"void operation2(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class DelegateSibling : public FamilyHead {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation2(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class Delegator : public FamilyHead {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DelegateSibling* target;"]},{"entry":[{},"void operation(\u2009) { target\u2212>operation2(\u2009); };"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0066","list-style":"none"},"li":{"@attributes":{"id":"ul0066-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0067","list-style":"none"},"li":["When RedirectInFamily is too generalized, and it is necessary to pre-select a sub-tree of the class hierarchy for polymorphism.\n\nMotivation\n","Static typing is a way of pre-selecting types from a well defined pool, and forming more concrete notions of an object's type at runtime. Polymorphism is a technique for abstracting out typing information until runtime. Sometimes we need a balance of the two. This pattern and the related DelegateInLimitedFamily both weigh these opposing forces but for slightly different outcomes.","This pattern is, obviously, concerned with redirection, having some advance knowledge of the intimacies of the task at hand to be able to determine that similarly named methods will be calling each other in a chain of subtasking.\n\nApplicability\n","Use RedirectInLimitedFamily when:","RedirectInFamily is the appropriate general pattern . . .",". . . but greater control over the possible types of objects is required\n\nStructure\n",{"@attributes":{"id":"ul0067-0007","num":"0562"},"figref":"FIG. 37","br":{}},"FamilyHead","Defines interface, contains a method to be possibly overridden, is the base class for both Redirecter and RedirectSibling","Redirecter","Uses interface of FamilyHead, redirects internal behaviour back to an instance of RedirectSibling to gain polymorphic behaviour over an amorphous but limited in scope object structure.","RedirectSibling","The head of a new class tree for polymorphic behaviour\n\nCollaborations\n\nConsequences\n\nImplementation\n"]}}}},{"@attributes":{"id":"p-0272","num":"0569"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"In C++:"]},{"entry":[{},"class FamilyHead {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"virtual void operation(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class RedirecterSibling : public FamilyHead {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void operation(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"class Redirecter : public FamilyHead {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void operation(\u2009);"]},{"entry":[{},"RedirecterSibling* target;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"void"]},{"entry":[{},"Redirecter::operation(\u2009) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ preconditional behaviour"]},{"entry":[{},"target\u2212>operation(\u2009);"]},{"entry":[{},"\/\/ postconditional behaviour"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0273","num":"0000"},"ul":{"@attributes":{"id":"ul0068","list-style":"none"},"li":["[1] Martin Abadi and Luca Cardelli. . Springer-Verlag New York, Inc., 1996.","[2] Christopher W. Alexander. . Oxford Univ Press, 1964. Fifteenth printing, 1999.","[3] Apple The NewtonScript programming language. Apple Computer, Inc., 1993","[4] Kent Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997.","[5] Jan Bosch. Design patterns as language constructs. Journal of Object Oriented Programming, 1(2): 18-52, May 1998.","[6] Kyle Brown. Design reverse-engineering and automated design pattern detection in smalltalk. Master's thesis, North Carolina State University, 2000.","[7] Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. -. John Wiley & Sons, 1996.","[8] Craig Chambers. The cecil language: Specification and rationale. Technical Report TR-93-03-05, University of Washington, 1993.","[9] James Coplien. C++ idioms. In , July 1998.","[10] Serge Demeyer, St\u00e9phane Ducasse, and Oscar Nierstrsz. Finding refactoring via change metrics. In -, pages 166-177. ACM Press, November 2000.","[11] Amnon H Eden. . PhD thesis, Tel Aviv University, Tel Aviv, Israel, 2000.","[12] Alexander Egyed. Automated abstraction of class diagrams. 211(4): 449-491, October 2002.","[13] G Florijn, M. Meijers, and P. van Winsen. Tool support for object-oriented patterns. In M. Askit and S. Matsuoka, editors, 11\u2014ECOOP'97. Springer-Verlag, Berlin 1997.","[14] Martin Fowler. . Addison-Wesley, 1999.","[15] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. . Addison Wesley 1995.","[16] Adele Goldberg. What should we teach? In 10-(), pages 30-37. ACM Press, 1995.","[17] Bent Bruun Kristensen. Complex associations: abstractions in object-oriented modeling. In -, pages 272-286. ACM Press, 1994.","[18] O. L Madsen, B. M\u00f8ller-Pederson, and K. Nygaard. -. Addison-Wesley, 1993.","[19] W. McCune. Otter 2.0 (theorem prover). In M. E. Stickel, editor, 10, pages 663-664, July 1990.","[20] Scott Meyers. ++. Addison-Wesley, 1992.","[21] Microsoft Corporation, editor. . Microsoft Press, 2002.","[22] Ivan Moore. Automatic inheritance hierarchy restructuring and method refactoring. In -, pages 235-250. ACM Press, 1996.","[23] Mel \u00d3 Cinn\u00e9ide. . Ph.D. dissertation, University of Dublin, Trinity College, 2001.\n\n[24] Mel \u00d3 Cinn\u00e9ide and Paddy Nixon. Program restructuring to introduce design patterns. In ---, Brussels, July 1998.\n","[25] William F. Opdyke and Ralph E Johnson. Creating abstract superclasses by refactoring. In 1993 , page 66, 1993. Feb. 16-18,1993.","[26] Santiago M. Pericas-Geertsen. -Boston University, 2001.","[27] Wolfgang Pree. -. Addison-Wesley, 1994.","[28] Steven P. Reiss. Working with patterns and code. In 33, January 2000.","[29] Dirk Riehle. Composite design patterns. In 1997 -, pages 218-228. ACM Press, 1997.","[30] Mohlalefi Sefika, Aamod Sane, and Roy H Campbell. Architecture-oriented visualization. In -, pages 389-405. ACM Press, 1996.","[31] Forrest Shull, Walcelio L. Melo, and Victor R. Basili. An inductive method for discovering design patterns from object-oriented software systems. Technical Report CS-TR-3597, University of Maryland, 1996.","[32] Jason McC. Smith and David Stotts. Elemental design patterns: A formal semantics for composition of oo software architecture. In 27, pages 183-190, December 2002.","[33] Jason McC. Smith and David Stotts. Elemental design patterns: A link between architecture and object semantics. Technical Report TR-02-011, Univ. of North Carolina, 2002.","[34] Jason McC. Smith and David Stotts. SPQR: Flexible automated design pattern extraction from source code. In 18, October 2003.","[35] Bobby Woolf. The abstract class pattern. In Neil Harrison, Brian Foote, and Hans Rohnert, editors, 4. Addison-Wesley, 1998.","[36] Bobby Woolf. The object recursion pattern. In Neil Harrison, Brian Foote, and Hans Rohnert, editors, 4. Addison-Wesley, 1998.","[37] Walter Zimmer. Relationships between design patterns. In James O. Coplien and Douglas C. Schmidt, editors, , pages 345-364. Addison-Wesley, 1995."]}},"Each of the publications referenced herein is hereby incorporated by reference herein in its entirety.","It will be understood that various details of the invention may be changed without departing from the scope of the invention. Furthermore, the foregoing description is for the purpose of illustration only, and not for the purpose of limitation, as the invention is defined by the claims as set forth hereinafter."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Preferred embodiments of the subject matter described herein will now be explained with reference to the accompanying drawings, of which:",{"@attributes":{"id":"p-0025","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0032"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0033"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0034","num":"0034"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0035","num":"0035"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0036","num":"0036"},"figref":["FIG. 12","FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0037","num":"0037"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0038","num":"0038"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0039","num":"0039"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0040","num":"0040"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0041","num":"0041"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0042","num":"0042"},"figref":["FIG. 18","FIG. 9"]},{"@attributes":{"id":"p-0043","num":"0043"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0044","num":"0044"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0045","num":"0045"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0046","num":"0046"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0047","num":"0047"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0048","num":"0048"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0049","num":"0049"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0050","num":"0050"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0051","num":"0051"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0052","num":"0052"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0053","num":"0053"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0054","num":"0054"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0055","num":"0055"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0056","num":"0056"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0057","num":"0057"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0058","num":"0058"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0059","num":"0059"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0060","num":"0060"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0061","num":"0061"},"figref":"FIG. 37"}]},"DETDESC":[{},{}]}
