---
title: Optimizing application compiling
abstract: A computer implemented method includes receiving a client programming language input and a server programming language input, processing the client and server programming language inputs, and translating the client programming language input into an executable client application and the server programming language input into an executable server application, the executable client and server applications operable to communicate with each other. Processing the client and server programming language inputs includes identifying any invocations of server procedures of the server programming language input in the client programming language input, producing a combined server procedure in the server programming language input for identified server procedures invoked by the client programming language input, and replacing invocations of the identified server procedures in the client programming language input with an invocation of the combined server procedure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08615750&OS=08615750&RS=08615750
owner: Adobe Systems Incorporated
number: 08615750
owner_city: San Jose
owner_country: US
publication_date: 20090612
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates to optimizing compilation of an input into a distributed software application. A software developer typically uses an integrated development environment (IDE), also known as integrated design environment or integrated debugging environment, for developing software applications. An IDE generally provides comprehensive facilities for software development and normally includes a source code editor, a compiler and\/or interpreter, build automation tools, and a debugger. Sometimes a version control system and various other development tools are integrated into the IDE to simplify the construction of a graphical user interface (GUI). Some IDEs also have a class browser, an object inspector, and a class hierarchy diagram, for use with object oriented software development.","Software applications, such as rich internet applications (RIAs), which are web applications that generally have the features and functionality of traditional desktop applications, may include client and server portions for execution on a respective client computing device and a server computing device. RIAs typically form a stateful client application with a separate services layer on the backend. RIAs typically run in a web browser, or do not require software installation on a local machine, and run locally in a secure environment called a sandbox. A sandbox is generally a security mechanism for safely running programs. Sandboxes are often used to execute untested code, or non-trusted programs from unverified third-parties, suppliers and non-trusted users. An IDE may be used to develop an RIA and to manage the client and server portions of the application.","In general, in one aspect, a computer implemented method includes receiving a client programming language input and a server programming language input, processing the client and server programming language inputs, and translating the client programming language input into an executable client application and the server programming language input into an executable server application, the executable client and server applications operable to communicate with each other. Processing the client and server programming language inputs includes identifying any invocations of server procedures of the server programming language input in the client programming language input, producing a combined server procedure in the server programming language input for identified server procedures invoked by the client programming language input, and replacing invocations of the identified server procedures in the client programming language input with an invocation of the combined server procedure.","These and other implementations can optionally include one or more of the following features. In some implementations, the method includes producing a communication service that marshals information between the executable client and server applications to support the combined server procedure. The method may include identifying any invocations of client procedures of the client programming language input in the server programming language input, producing a combined client procedure in the client programming language input for identified client procedures invoked by the server programming language input, and replacing invocations of the identified client procedures in the server programming language input with an invocation of the combined client procedure. In some examples, the method includes producing a communication service that marshals information between the executable client and server applications to support the combined client procedure.","In general, another aspect of the subject matter described in this specification can be embodied in a computer program product, encoded on a computer-readable medium, operable to cause a data processing apparatus to perform operations that include receiving a client programming language input and a server programming language input, processing the client and server programming language inputs, and translating the client programming language input into an executable client application and the server programming language input into an executable server application, the executable client and server applications operable to communicate with each other. Processing the client and server programming language inputs includes identifying any invocations of server procedures of the server programming language input in the client programming language input, producing a combined server procedure in the server programming language input for identified server procedures invoked by the client programming language input, and replacing invocations of the identified server procedures in the client programming language input with an invocation of the combined server procedure.","These and other implementations can optionally include one or more of the following features. In some implementations, the operations performed by the data processing apparatus include producing a communication service that marshals information between the executable client and server applications to support the combined server procedure. The operations performed by the data processing apparatus may include identifying any invocations of client procedures of the client programming language input in the server programming language input, producing a combined client procedure in the client programming language input for identified client procedures invoked by the server programming language input, and replacing invocations of the identified client procedures in the server programming language input with an invocation of the combined client procedure. In some examples, the operations performed by the data processing apparatus include producing a communication service that marshals information between the executable client and server applications to support the combined client procedure.","In general, another aspect of the subject matter described in this specification can be embodied in a system including a computer-readable medium including instructions and a computing device including one or more processors configured to execute the instructions and perform operations comprising providing a compiler configured for receiving a client programming language input and a server programming language input, processing the client and server programming language inputs, and translating the client programming language input into an executable client application and the server programming language input into an executable server application, the executable client and server applications operable to communicate with each other. Processing the client and server programming language inputs includes identifying any invocations of server procedures of the server programming language input in the client programming language input, producing a combined server procedure in the server programming language input for identified server procedures invoked by the client programming language input, and replacing invocations of the identified server procedures in the client programming language input with an invocation of the combined server procedure.","These and other implementations can optionally include one or more of the following features. In some implementations, the compiler is configured for producing a communication service that marshals information between the executable client and server applications to support the combined server procedure. The compiler may be configured for identifying any invocations of client procedures of the client programming language input in the server programming language input, producing a combined client procedure in the client programming language input for identified client procedures invoked by the server programming language input, and replacing invocations of the identified client procedures in the server programming language input with an invocation of the combined client procedure. In some examples, the compiler is configured for producing a communication service that marshals information between the executable client and server applications to support the combined client procedure.","In general, in one aspect, a computer implemented method includes receiving a client programming language input and a server programming language input. Client symbols of the client programming language input are usable in the server programming language input and server symbols of the server programming language input are usable in the client programming language input. The method includes identifying the usage of any client symbols in the server programming language input and any server symbols in the client programming language input, replacing any client symbols in the server programming language input that represent static client data of the client programming language input with the static client data, and replacing any server symbols in the client programming language input that represent static server data of the server programming language input with the static server data. The method further includes producing one or more communication services to support the usage of any non-replaceable client symbols in the server programming language input and the usage of any non-replaceable server symbols in the client programming language input, and translating the client programming language input into an executable client application and the server programming language input into an executable server application. The executable client and server applications are operable to communicate with each other and each communication service marshals information between the executable client and server applications.","These and other implementations can optionally include one or more of the following features. In some implementations, the method includes combining communication services that each marshal information to a common procedure of one of the executable applications into a combined communication service. The method may include receiving a main programming language input comprising the client programming language input and the server programming language input and parsing the main programming language input to separate the client programming language input from the server programming language input. In some examples, parsing the main programming language input includes identifying metadata indicating inclusion in the server programming language input. Parsing the main programming language input may include identifying a start server portion tag and an end server portion tag, and including any portion of the main programming language input between the start and end server portion tags in the server programming language input.","In some implementations, symbols of the client programming language input and symbols of the server programming language input share a common namespace. Each symbol may be selected from a group consisting of an object, a variable, a method, and a function. In some implementations, the method includes selecting an executable client application type and an executable server application type independent of the programming language inputs. The method may include translating the client programming language input into the respective executable client application portion with a first compiler and translating the server programming language input into the respective executable server application portion with a second compiler. The first and second compilers may be selected based on at least one of the received programming language input, the executable format of the executable application, and a platform for executing the executable client application. The method may include producing a communication module for communication between the executable client and server applications to facilitate the usage of any client symbols and any server symbols there between.","In general, another aspect of the subject matter described in this specification can be embodied in a computer program product, encoded on a computer-readable medium, operable to cause a data processing apparatus to perform operations including receiving a client programming language input and a server programming language input. Client symbols of the client programming language input are usable in the server programming language input and server symbols of the server programming language input are usable in the client programming language input. The operations include identifying the usage of any client symbols in the server programming language input and any server symbols in the client programming language input, replacing any client symbols in the server programming language input that represent static client data of the client programming language input with the static client data, and replacing any server symbols in the client programming language input that represent static server data of the server programming language input with the static server data. The operations also include producing one or more communication services to support the usage of any non-replaceable client symbols in the server programming language input and the usage of any non-replaceable server symbols in the client programming language input, and translating the client programming language input into an executable client application and the server programming language input into an executable server application. The executable client and server applications operable to communicate with each other, and each communication service marshals information between the executable client and server applications.","These and other implementations can optionally include one or more of the following features. In some implementations, the operations performed by the data processing apparatus further include combining communication services that each marshal information to a common procedure of one of the executable applications into a combined communication service. The operations performed by the data processing apparatus may include receiving a main programming language input comprising the client programming language input and the server programming language input and parsing the main programming language input to separate the client programming language input from the server programming language input. In some examples, parsing the main programming language input comprises identifying metadata indicating inclusion in the server programming language input. Parsing the main programming language input may include identifying a start server portion tag and an end server portion tag, and including any portion of the main programming language input between the start and end server portion tags in the server programming language input.","In some implementations, the symbols of the client programming language input and symbols of the server programming language input share a common namespace. Each symbol may be selected from a group consisting of an object, a variable, a method, and a function. The operations performed by the data processing apparatus may include selecting an executable client application type and an executable server application type independent of the programming language inputs. In some examples, the operations performed by the data processing apparatus include translating the client programming language input into the respective executable client application portion with a first compiler and translating the server programming language input into the respective executable server application portion with a second compiler. The first and second compilers may be selected based on at least one of the received programming language input, the executable format of the executable application, and a platform for executing the executable client application. The operations performed by the data processing apparatus may include producing a communication module for communication between the executable client and server applications to facilitate the usage of any client symbols and any server symbols there between.","In general, another aspect of the subject matter described in this specification can be embodied in a system including a computer-readable medium including instructions and a computing device including one or more processors configured to execute the instructions and perform operations comprising providing a compiler configured for receiving a client programming language input and a server programming language input. Client symbols of the client programming language input are usable in the server programming language input and server symbols of the server programming language input are usable in the client programming language input. The compiler is configured for identifying the usage of any client symbols in the server programming language input and any server symbols in the client programming language input, replacing any client symbols in the server programming language input that represent static client data of the client programming language input with the static client data, and replacing any server symbols in the client programming language input that represent static server data of the server programming language input with the static server data. The compiler is configured for producing one or more communication services to support the usage of any non-replaceable client symbols in the server programming language input and the usage of any non-replaceable server symbols in the client programming language input, and translating the client programming language input into an executable client application and the server programming language input into an executable server application. The executable client and server applications operable to communicate with each other. Each communication service marshals information between the executable client and server applications.","These and other implementations can optionally include one or more of the following features. In some implementations, the compiler combines communication services that each marshal information to a common procedure of one of the executable applications into a combined communication service. In some implementations, the compiler receives a main programming language input comprising the client programming language input and the server programming language input and parses the main programming language input to separate the client programming language input from the server programming language input. In some examples, parsing the main programming language input includes identifying metadata indicating inclusion in the server programming language input. Parsing the main programming language input may include identifying a start server portion tag and an end server portion tag, and including any portion of the main programming language input between the start and end server portion tags in the server programming language input.","In some implementations, the symbols of the client programming language input and symbols of the server programming language input share a common namespace. Each symbol may be selected from a group consisting of an object, a variable, a method, and a function. In some examples, the compiler selects an executable client application type and an executable server application type independent of the programming language inputs. The compiler may translate the client programming language input into the respective executable client application portion with a first compiler and translate the server programming language input into the respective executable server application portion with a second compiler. The compiler may select the first and second compilers based on at least one of the received programming language input, the executable format of the executable application, and a platform for executing the executable client application. In some examples, the compiler produces a communication module for communication between the executable client and server applications to facilitate the usage of any client symbols and any server symbols there between.","Particular embodiments of the subject matter described in this specification can be implemented to realize one or more of the following advantages. The present disclosure provides a technique for developing an application under a single framework (e.g., single code base), such that a compiler and\/or virtual machine produces the client and server portions of the application, thereby allowing a user (e.g., software developer) to develop the application as a single application (e.g., within an IDE) without managing separate client and server applications and the communications there between. Replacing any client symbols in the server programming language input that represent static client data of the client programming language input with the static client data, and replacing any server symbols in the client programming language input that represent static server data of the server programming language input with the static server data reduces the number of communication service calls between the executable client and server applications, thus increasing the efficiency of those applications. Likewise, combining communication services that each marshal information to a common procedure of one of the executable applications into a combined communication service as increases the efficiency of the executable client and server applications by reducing the number of communication service calls between the two applications. Other advantages include freeing the software developer from having to worry about client capabilities since different versions of the client code can be compiled for devices with different specifications and capabilities.","The details of one or more implementations of the disclosure are set forth in the accompanying drawings and the description below. Other aspects, features, and advantages will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 1","FIG. 1","FIG. 3"],"b":["100","310","120","110","500","400","310","330","332","334","332","334","330","332","334","332","334","334","330","310","122","120","25","330","332","334","312","314","310","310","312","314","310","310","310"]},"The software development paradigm includes a compiling stage, a debugging stage, and a deploying stage. In the compiling stage, a compiler  (e.g., a process or program(s) that transforms source code into an executable form, such as a compiler or interpreter), executable on the computer  or another computer, compiles or translates the application  into client and server applications , , which together form the executable application . In the debugging stage, the user uses a debugger , executable on the computer  or another computer (e.g., a computing device  in a cloud computer service ), for debugging the code (e.g., to find and correct errors) so that the executable application  runs or functions substantially without errors. In the deploying stage, the user utilizes a deployer , executable on the computer  or another computer, for deploying the executable application  to a deployment space. For example, the client application  may be deployed to the client device  (e.g., portable computing device) and the executable server application  may be deployed to the cloud computing service  where the executable server application  executes on a server computing device , for example. The IDE  receives a deployment request from a user, and in response to the deployment request, executes deployment of the executable application  via the deployer . The user may click a button (e.g., as a single user event) in the graphical user interface  of the IDE  to send the deployment request. The IDE  recognizes receipt of the deployment request and calls the deployer  to carry out deployment of the executable application .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2A","b":["200","210","220","210","212","212","214","216","218","220","222","222","224","226","228"]},"Referring to , a homogeneous programming model B for cloud computing may include a client-side development process  and server-side development process  that entails writing code in the same or different languages (e.g., in the same or different contexts). The client-side development process  entails writing client-side code , such as a Flex Application in MXML and Actionscript, and the server-side development process  entails writing server-side code , such as a Coldfusion Application in Coldfusion Markup Language (CFML). A compiler  (e.g., pre-processor) receives the client-side code  and the server-side code  for processing (e.g., for optimization and compilation or translation). The compiler  is configured to receive an input (e.g., the client-side code  and the server-side code , respectively, from the IDE ) and compile or translate the input into an executable client-side application , such as SWF file, executable on a client computing device  and an executable server-side application  executable on a server computing device . In some implementations, the compiler  includes one or more client compilers  and one or more server compilers  that may receive the client-side code  and the server-side code , respectively, and compile or translate them into the executable client-side application , and the executable server-side application , respectively. Each compiler ,  may be a computer program (or set of programs) that translates text or symbols written in a computer programming language into another a target language, for example, to create a executable application or program. In some instances, the client and server compilers ,  are specified in default settings (e.g., by a user configuration). In other instances, the user specifies the specific compiler ,  in source code metadata, such as scripting tags.","Traditionally, compilers optimize the code of a given application, and the scope of optimization is the scope of the application. Thus, the client-side code  (e.g., written in Flex) and the server-side code  (e.g., written in Java) are compiled and optimized independently with no coordination and by two separate compilers that do not share any context. In the homogeneous programming model B, the compiler  detects any points in the client-side code  and the server-side code  that require communication between the executable client-side application  executing on the client computing device  and the executable server-side application  executing on the server computing device  and minimizes this communication by looking at the client-side code  and the server-side code  as a single application or system, rather than two independent applications, and combining distinct communications where possible. Although writing the client-side code  and the server-side code  in same language offers several benefits, such as productivity, it is not necessary to take advantage of the compiler optimizing process.","The example in  illustrates function optimization processing of the client-side code  and the server-side code  received by the compiler . The client-side code  includes a \u201cfor\u201d loop which iterates through a set of employee IDs (empID) to generate a list of employee names and respective salaries. Inside the \u201cfor\u201d loop, the variable totalSalary is assigned the summation of the employee base salary and bonuses, provided by respective server functions (i.e., totalSalary=getEmployeeBaseSalary(empID)+getEmployeeBonuses(empID);). Without optimization, compilation of the client-side code  will result in an executable client-side application  that individually communicates with the respective executable server-side application  for invocation of each server-side function (e.g., getEmployeeBaseSalary(empID) and getEmployeeBonuses(empID)). With optimization, the compiler  identifies that two or more server-side functions are invoked in the same statement (e.g., source code statement, procedure, class, object, function, method, etc.) and replaces the multiple invocations with a single communication between the executable client-side application  and the executable server-side application . In the example shown, the compiler  creates a server-side function \u201cf(employeeID)\u201d that combines getEmployeeBaseSalary(employeeID) and getEmployeeBonuses(employeeID). The compiler  replaces the client-side invocation of getEmployeeBaseSalary(empID) and getEmployeeBonuses(empID) with f(empID) in client-side code , thereby reducing multiple client-server communications to a single communication. The optimized client-side code  and server-side code  are received by their respective client and server compilers ,  for compilation or translation into the respective executable client-side and server-side applications , . The compiler  may include instructions, algorithms, and\/or logic routines for discerning which communications to combine, how to create combined function, how to order sub-functions within a combined function, and testing of combined functions.","The example in  illustrates constant folding optimization processing of the client-side code  and the server-side code  by the compiler. The client-side code  includes usage of a server variable b, which is a defined as a constant in the server-side code . The compiler  identifies the usage of the server variable b in the client-side code  as well as the fact that the server variable b is defined as a constant in the server-side code . The compiler  replaces the reference to the server variable b in the client-side code  with a string constant (e.g., \u201cversion 1.0\u201d) corresponding to the value defined in the server-side code , thus avoiding a web service transaction between the executable client-side and server-side applications , . Similarly, the compiler  may also identify the usage of client variables, defined as constants in the client-side code , in the server-side code  and replace the reference to the client variable with a corresponding constant value.","The example in  illustrates loop optimization processing of the client-side code  and the server-side code  by the compiler. The client-side code  includes a \u201cfor\u201d loop which iteratively loads an array x[i] with the value of a server variable c defined in the server-side code . Without optimization processing, the server variable c will be retrieved through a web service 1000 times for each iteration of the loop; however, with the optimization processing it will be read just once. The compiler  identifies the usage of the server variable c in the client-side code  as well as the fact that the server variable c is defined as a constant. The compiler  replaces the reference to the server variable c in the client-side code  with the value of the constant (i.e., ) defined in the server-side code , thus avoiding multiple web service transactions between the executable client-side and server-side applications , . In some examples, the compiler  performs constant folding optimization processing of an expression in the client-side and\/or server-side code ,  to determine that a symbol refers to a constant. The compiler  then replaces the identified expression with the referenced constant(s) or equated expression as a constant.","The example in  illustrates additional loop optimization processing of the client-side code  and the server-side code  by the compiler. The client-side code  includes a \u201cfor\u201d loop which iteratively loads an array x[i] with the concatenation of server variable d and server variable e, both defined in the server-side code . Without optimization processing, the executable client-side application  will have to make two web service transactions with the executable server-side application  to individually retrieve the values of server variables d and e for each iteration of the loop. In contrast, with the optimization processing, the compiler  identifies the usage of the server variables d and e in the client-side code  and the multiple web service transactions. The compiler  produces a combined server symbol f (e.g., variable, function, method, etc.) in the server-side code  that combines (e.g., concatenates) the two server variables d and e, and replaces the references to the server variables d and e in the client-side code  with the combined server symbol f, thus avoiding multiple web service transactions between the executable client-side and server-side applications , . Similarly, the compiler  may also identify the usage of multiple client variables, defined in the client-side code , in the server-side code  and replace the references to the identified client variables with a combined client symbol that provides the information and\/or functionality of each of the identified client variables.","Referring to , a unified programming model  for cloud computing allows a user to write and maintain an application  in a single language (although multiple languages may be used in some implementations) that has both client and server portions , . The application  can be written in a single context (e.g., shared symbol namespace), where client symbols such as variables, objects, methods, functions of the client application portion  are available to the server application portion  and vice versa. While writing the application , the application developer may use server symbols in the client application portion  and client symbols in the server application portion and the compiler , upon processing the application , provides the communication between the two application portions ,  and separates them into respective client and server executable applications , . The seamless use of client and server symbols (e.g., variables, objects, methods, functions, etc.) within a single language allows an application developer to create client and server side code as a single code base. For example, the application developer may write a program in a single language that provides a graphical user interface (GUI) that displays data retrieved from a database, where the client-side code for the GUI is seamless or coextensive with the server-side code for the database interactions. In a mixed language environment, where one programming language is used for the client application portion  and another language is used for the server application portion , for example, there is a shared namespace (e.g., shared nomenclature for objects, variables, methods, functions, and so on shared between the two application portions , ).","The compiler  is configured to receive input (e.g., the application  from the IDE ) and compile or translate the input into an executable client application  and an executable server application , which together form an executable application . The compiler  may be a computer program (or set of programs) that translates text or symbols written in a computer programming language into another a target language, for example, to create a executable application or program , , . The application  comprises source code (e.g., a high-level programming language), which is translated into executable code (e.g., object code, intermediate code, or a lower level language, such as assembly language or machine language) of the executable application . The compiler  parses the application  into the client and server portions , , resolves any communications between the client and server application portions, and produces any necessary server side scripts to support the client-server communications. For example, the application developer may write a program in a single language that provides a graphical user interface (GUI) that displays and allows manipulation of data retrieved from a database, without creating a separate code base for the database interactions.","In some implementations, the compiler  divides the application  into the client application portion  and the server application portion  based on metadata (e.g., source code tags) in the application . A configuration object, file, or parameter may be passed to the compiler  to identify parsing tags, objects, and so on, for parsing the application source code  and\/or library paths for compilation and\/or output paths. The compiler  resolves the usage of client and server symbols (e.g., variables, objects, methods, functions, etc.) between the two application portions ,  by identifying the connections between the separated client and server application portions ,  and producing any necessary support for communications between the separate executable client and server applications , . For example, the client and server symbols may be replaced with web service calls in the executable client and server applications , . During development of the application , the user may select specific local and remote classes of a single programming language designated for respective use in the executable client and server applications , . During compilation of the application , the compiler  recognizes the local and remote classes and translates the source code into the respective executable applications , .","The compiler  may be configured to provide a communication module  for communication (e.g., asynchronous communication) between the executable client application  and the executable server application . The communication module  may provide an application programming interface (API) as a web service for communications between the executable client an server applications , . The user may specify a communication protocol (e.g., Action Message Format (AMF), Simple Object Access Protocol (SOAP), JavaScript Object Notation (JSON), etc.) for communications between the executable client and server applications , . The user may also stipulate in the source code metadata a type of encryption and\/or authentication between the executable client and server applications , .","In some implementations, the compiler  partitions the application  into the client and server application portion , , resolves the usage of the client and server symbols, as used in a single context, and translates or compiles the client application portion  into the executable client application  with a client application compiler  and the server application portion  into the executable server application  with a client application compiler . The compiler  may choose the client and server application compilers ,  based on the language of the application  and\/or a desired output format of the executable client and server applications , . For example, upon receiving an application  written in MXML and Actionscript (AS), the compiler  may choose to compile the client application portion  on an MXML\/AS compiler\/linker , which includes Flash\/Flex client-side libraries, to produce a SWF file as the executable client application  (to be executed by a Flash client). The compiler may choose to compile the server application portion  on a client application compiler  that provides a user-specified output, such as server-side script (e.g., for a CFML or Ruby application), server-side byte code (e.g., for implementation as a Java class), or a server-side SWF file (e.g., for implementation as a Flash application). A project type in the IDE  may also be used to designate the type of client and\/or server application compilers ,  to use for compilation of the application .","In some implementations, the compiler  translates the application  into a executable application , which is divided or segmented into the executable client application  and the executable server application  at run-time, for example, by a virtual machine (VM), a native code client computing device, and\/or a native code server computing device. In some examples, the user attributes metadata (e.g., a \u201cdynamic\u201d metadata type) to the source code of the application  indicating that the executable client and server applications ,  will be produced at run-time from the executable application . The same criteria for apportioning the client and server application portions ,  described with respect to the compiler  may be used by the virtual machine.","The compiler  may be configured to perform one or more of the following operations: lexical analysis, preprocessing, parsing, semantic analysis, code generation, and code optimization. The output produced by the compiler  may be executable on a virtual machine that may or may not reside on the same platform as the compiler .","Generally, the executable code has a form suitable for processing by other programs (e.g., a linker) or a virtual machine, but may be a human-readable text file.","The application developer may write the source code of the application  in a single language context, such that the developer can use client-side and server-side variables interchangeably. The client-side application portion  may invoke a server function or reference a server variable, and the server-side application portion  can invoke a client function and access a client variable. For example, the client-side application portion  can define, use, and bind to a server-side variable. As a result, the client-side application portion  can write to (e.g., define) and read from (e.g., use) a server-side variable as well as receive automatic updates of changes on the server (e.g., binding). Likewise, the server-side application portion  can define, use, and bind to a client-side variable. As a result, the server-side application portion  can write to (e.g., define) and read from (e.g., use) a client-side variable as well as receive automatic updates of changes on the client (e.g., binding). The interchangeable use of variables between the client and server application portions ,  includes all possible invocations between the two. For example, the client application portion  may make a local function call that takes a server-side class as an input parameter (e.g., doSomethingInClient(serverMath c)).","Referring to , in the example shown, the function \u201cdoSomethingInClient\u201d, written in Actionscript, runs in the client application portion  and takes an object \u201cc\u201d which is of the class \u201cserverMath.\u201d The class serverMath is declared in the server application portion  and invokes a method \u201cadd\u201d in this object. This is an example of seamless integration of client and server contexts (e.g., interchangeable usage of client and server symbols in each application portion , ). In the executable client and server applications , , the interchangeably used symbols may be replaced with web service calls. For example, in the executable client application , the invocation of the \u201cadd\u201d method of the serverMath class can be replaced with a web service call (e.g., application programming interface (API)) to the executable server application , which includes the necessary support to respond to such a call.","In some instances, a user of the executable application  needs to be authenticated on the server computing device . The executable application  displays a username text input box and a password text input box for receiving the user's username and password, respectively. The received username and password are passed to the server computing device  for authentication and depending on the result a suitable message is displayed.","In the example shown in , the user authentication scenario is implemented in the client application portion  by invoking a server-side function \u201cauthenticate\u201d of the server application portion  transparently in the client-side code. The code examples are written in MXML and Actionscript. The source code delineates the client application portion  from the server application portion  by the use of tags. In the example shown, code of the server application portion  is held between the start tag \u201c<mx:ServerScript>\u201d and end tag \u201c<\/mx:ServerScript>\u201d. When processing the source code of the application , the compiler  identifies the ServerScript tags and parses out the server application portion . In this example, the client application portion  defines the username text input box (e.g., <mx:TextInput id=\u201cun\u201d \/>) and the password text input box (e.g., <mx:TextInput id=\u201cpw\u201d \/>) and invokes the server-side function \u201cauthenticate\u201d of the server application portion  (e.g., authenticate(un.text, pw.text)) by passing in the input received in the username text input box and the password text input box. Upon compilation, the compiler  resolves the invocation of the server-side function \u201cauthenticate\u201d in the client application portion . This example demonstrates the seamless use of server application defined methods in the client application portion . The server application portion  may contain a library of frequency used methods or symbols (e.g., authenticate, email, database query, etc.). In examples that require user authentication by querying a database, the server application portion  may include a \u201cdbQuery\u201d class that receives parameters or objects and handles interacting with a database. For example, the developer may call a method of an instantiated object of the dbQuery class to return a result set, where the dbQuery object creates and executes any necessary queries against a designated database.","In the example shown in , the user authentication scenario is implemented by defining the username text input box (e.g., <mx:TextInput id=\u201cun\u201d \/>) and the password text input box (e.g., <mx:TextInput id=\u201cpw\u201d \/>) in the client application portion  and invoking the server-side function \u201cauthenticate\u201d of the server application portion ; however, instead of passing in parameters to the server-side function, the server application portion  uses the inputs of the username and password text input boxes directly. This example demonstrates the seamless of client application defined variables in the server application portion .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 6","b":["1","312","314","330","314","410","314"]},"While processing the application , the compiler  identifies the usage of client symbols of the client application portion  in the server application portion  and the usage of server symbols of the server application portion  in the client application portion . In some examples, the compiler  may substitute web service calls (or messaging) for each symbol to facilitate communications between the produced executable client and server applications , . However, to optimize or increase the efficiency of the executable applications , , , the compiler  may reduce the number of web service calls by analyzing the usage of client and server symbols between the client and server application portions ,  and determining whether web service calls can be combined or eliminated. In the example shown in , the client application portion  uses a server symbol, variable b, that is defined as a constant in the server application portion . Without optimization, the compiler  can provide communication (e.g., a web service call) between the executable server application  and the executable client application  to allow the deliverance\/retrieval of the value of server variable b. With constant folding optimization, the compiler  identifies that the server symbol, variable b, used in the client application portion  is a constant (e.g., static server data) defined on the server and reference to the variable b in the client application portion  is replaced by a string constant thus avoiding a web service transaction between the executable client and server applications , . Similarly, if the compiler  identifies that a client symbol used in the server application portion  is a constant (e.g., static client data) defined on the client, reference to the client symbol in the server application portion  is replaced by a string constant thus avoiding a web service transaction between the executable client and server applications , . Furthermore, the compiler  may perform constant folding processing of an expression to determine that a symbol refers to a constant. The compiler  then replaces the identified expression with the referenced constant(s) or equated expression as a constant.","Referring to the example shown in , the client application portion  iterates through a \u201cfor\u201d loop to load an array \u201cx\u201d with the value of a server variable \u201ca.\u201d Without optimization, the server variable \u201ca\u201d will be retrieved through a web service 1000 times for each iteration of the loop in the executable client application . However, with the compiler optimization, while processing the application , the compiler  parses the application  into separate client and server portions ,  and resolves the usage of client and server symbols there between by recognizing the usage of the server symbol, variable \u201ca\u201d, in the \u201cfor\u201d loop of the client application portion  and determining that the server variable is defined as a constant in the server application portion . Rather than implementing a communication routine, such a web service call, for retrieval by the executable client application  of the server variable from the executable server application , the compiler  substitutes the value of the server variable for variable \u201ca\u201d in the client application portion  before compilation or translation. In instances where separate client and server compilers ,  are used to compile the client and server application portions , , the substitution may be made before deliverance to or receipt by the client and server compilers , .","In the \u201cHello World\u201d example of , the client application portion  defines two text labels L and L that each call a server function of the server application portion  to load text into each label. Text label L invokes the \u201cgetHelloMessage( )\u201d function and text label L invokes the getWorldMessage( ) function of the server application portion . The two server functions each return a message (i.e., \u201chello\u201d or \u201cworld\u201d, respectively) from a server computing device  that is displayed as the Label text of L and L, respectively. Without the optimization process, the compiler  (or in some instances, the client and server compilers ,  as sub-compilers) translates the client and server application portions ,  into respective executable client and server applications ,  with the two server functions being invoked in the executable client application  through two different web service calls to the executable server applications . With the optimization process, the compiler  resolves the invocation of the server functions in the client application portion  by recognizing the usage of the two server functions and determining that the two server functions can be executed in a single call to the server application portion . Rather than implementing two separate communication routines, such as web service calls, between the executable client and server applications , , the compiler  combines invocation of the two server functions (\u201cgetHelloMessage( )\u201d and getWorldMessage( )\u201d) into a single communication (e.g., web service call) between the executable client and server applications , . In a similar fashion, the compiler  may combine other communications between the executable client and server applications ,  for marshalling data or invoking other client symbols or server symbols.","Referring to , in some implementations, an example system  includes at least one of the local computing device  (e.g., a computer), the client computing device , and the cloud computing service . The local computing device  executes the IDE , and may also execute the compiler  and the deployer . In some examples the IDE  includes the compiler , the debugger , and the deployer . The cloud computing service  includes at least one server computing device  which may include a service abstraction layer  and a hypertext transfer protocol wrapper over the server virtual machine  instantiated thereon. The server computing device  may be configured to parse HTTP requests and send HTTP responses. The deployer  is configured to receive the executable application  (e.g., from the compiler , which may be part of the IDE ) for deployment to a deployment space ,  (e.g., according to a user preference).","In the example illustrated in , the compiler  is configured to produce the executable client and server applications ,  for deployment to a respective client deployment space  and a server deployment space . Each deployment space ,  is associated with a name and a permissions requirement. The server deployment space  is in a cloud computing service  having a plurality of computing devices  and a service abstraction layer . In some implementations, the deployer  is configured to verify user credentials before deploying the executable application . Deploying the executable application  may include associating the executable client and server applications ,  with the respective deployment spaces , , and installing the executable client and server applications ,  to a corresponding client computing device  and a server computing device  in the cloud computing service . In some examples, the server computing device  is selected from the plurality of server computing devices  in the cloud computing service  by evaluating a computing load for each server computing device . The cloud computing service  may assign a permanent unique URL to the server deployment space , which may be mapped to a user-selected domain name. Also, the cloud computing service  may process a permissions requirement of the server deployment space , and manage access to the executable server application  according to the permissions requirement of the server deployment space . In some examples, the cloud computing service  manages access to the executable server application  by requiring at least one of a user name and password to access the permanent unique URL. A virtual machine  on the server computing device  is configured to execute the executable server application  and communicate with the client computing device  for execution of the executable client application .","In some examples, the cloud computing service  is configured to communicate with a repository  (e.g., database, file server, etc.) for storing and accessing at least one of the executable application  and the executable client and server applications , . In the example shown in , the server computing device  (e.g., HTTP server) communicates with the repository  for accessing and executing the executable client and server applications , .","Referring to , a flowchart  represents an arrangement of compiling operations of the compiler . Typically, the compiling operations are executed on a processor present in the computer , upon which the compiler  resides; however, the compiling operations may also be executed by multiple processors present in the computer . While typically executed by a single computer  (e.g., electronic device or computing device), in some arrangements, operation execution may be distributed among two or more computers . Compiling operations include receiving  an input, dividing  the input into a client portion and a server portion, resolving  the usage of client symbols and server symbols among the client and server input portions, replacing  any client symbols in the server input portion that reference static client data of the client input portion with the static client data, and replacing  any server symbols in the client input portion that reference static server data of the server input portion with the static server data. Compiling operations also include translating  the client input portion into an executable client output, and translating  the server input portion into an executable server output. The operation of dividing the input into the client and server input portions may include applying a criteria to the input for selecting the two portions. In some examples, the operation of dividing the input into the client and server input portions is implemented by identifying server portion tags and parsing out the portions within those tags. Compiling operations may also include producing one or more communication services to support the usage of any non-replaceable client symbols in the server input portion and any non-replaceable server symbols in the client input portion. Each communication service marshals information between the executable client and server applications","Referring to , a flowchart  represents an arrangement of deploying operations of the deployer . Typically, the deploying operations are executed on a processor present in the computer , upon which the deployer  resides; however, the operations may also be executed by multiple processors present in the computer . While typically executed by a single computer  (e.g., electronic device or computing device), in some arrangements, operation execution may be distributed among two or more computers . Deploying operations include receiving  a executable application  (e.g., from a compiler  and\/or IDE ) having executable client and server applications , , receiving  a client portion deployment space location, receiving  a server portion deployment space location, and in response to receiving a deployment request (e.g., via the GUI  of the IDE ), deploying  the executable client application portion to a client deployment space  according to the received client portion deployment space location, and also in response to receiving the deployment request, deploying  the executable server application portion to a server deployment space  according to the received server portion deployment space location. Example client portion deployment space locations may include at least one of a local computing device  and a client computing device  having a plurality of computing devices and a service abstraction layer. Example server portion deployment space locations may include at least one of a local computing device  and a cloud computing service  having a plurality of computing devices  and a service abstraction layer . Each deployment space ,  may be associated with a name and a permissions requirement. Deploying operations may also include verifying user credentials before deploying the corresponding executable client and server applications , , associating the corresponding executable client and server applications ,  with a computing device of the designated deployment space , , and installing the corresponding executable applications ,  to that computing device. Deploying operations may also include managing access to the corresponding executable client and server applications ,  according to a permissions requirement of the respective deployment space , . Deploying operations can include assigning a permanent unique URL to each deployment space ,  and mapping the permanent unique URL to a user-selected domain name.","In the example illustrated in , the deployer  is configured to receive the executable application  (e.g., from the compiler ) for deployment to the server deployment space . A user preference may be set in the IDE  (e.g., via metadata, specific class usage in the source code, and\/or properties) for producing the executable client and server applications ,  at run-time from the executable application . Deploying the executable application  may include associating the executable application  with the server deployment space , and installing the executable application  to a server computing device  in the cloud computing service . In some examples, the server computing device  is selected from the plurality of server computing devices  in the cloud computing service  by evaluating a computing load for each server computing device . The cloud computing service  may assign a permanent unique URL to the server deployment space , which may be mapped to a user-selected domain name. Also, the cloud computing service  may process a permissions requirement of the server deployment space , and manage access to the executable application  according to the permissions requirement of the server deployment space . In some examples, the cloud computing service  manages access to the executable application  by requiring at least one of a user name and password to access the permanent unique URL. In the illustrated example, the virtual machine  on the server computing device  receives the executable application  and is configured to produce the server and client applications , , for example by applying a criteria. The criteria may include selecting portions of the executable application  that have an execution time on the client computing device  less than a threshold client execution time and\/or relate to a graphical user interface (GUI), and translating those portions into the executable client application . In some examples, the criteria includes selecting portions of the executable application  having an execution time on a client computing device  greater than a threshold client execution time, invoke services executable on a server computing device , and\/or invoke application programming interfaces (API) executable on a server computing device , and translating those portions into the executable server application . The server computing device  delivers the executable client application  to a client deployment space  on a client computing device . The virtual machine  is configured to execute the executable server application  and communicate with the client computing device  for execution of the executable client application .","In the example illustrated in , the deployer  is configured to receive the executable application  (e.g., from the compiler ) for deployment to the client deployment space . A virtual machine  on the client computing device  receives the executable application  and is configured to produce the server and client applications , , for example by applying a criteria. The criteria may include any of the criteria described herein. The client computing device  delivers the executable server application  to a server deployment space  on a server computing device . The virtual machine  is configured to execute the executable client application  and communicate with the server computing device  for execution of the server client application . The virtual machine  on the server computing device  may execute the received server client application .","A communication module  (shown in ) may be produced for communication between the executable client and server applications , . The communication module  may be produced by the compiler , the deployer , and\/or a virtual machine , . In some examples, the compiler  produces the communication module  upon producing the executable client and server applications , . In other examples, the server virtual machine  produces the communication module  upon producing the executable client and server applications ,  at run-time. The communication module  accommodates or facilitates the resolved usage of any client and server symbols between the executable client and server applications , .","Referring to , in some implementations, the debugger  is configured to receive input from the IDE , such as the application  and\/or the executable application , for testing and debugging (e.g., identifying and correcting errors). The debugger  may be a computer program executable on the computer  or another computer. In some implementations, the debugger  uses artifacts (e.g., translated code, symbol table, and\/or any special debugging output) in the executable application  for debugging the application. In other implementations, the debugger  communicates with the compiler  to debug compilation and\/or execution of the executable application . In some examples, the source code of the application  to be monitored and\/or examined by the debugger  may be executed on an instruction set simulator (ISS), which allows an execution sequence of the application  to be halted when specific conditions are encountered. In some implementations, the compiler  and the debugger  are part of the IDE  and communicate with each other for execution and testing of the application . While running the executable application  produced by the compiler , the debugger  may show the position in the original source code of the application  when the executable application  crashes or otherwise experiences an error and cannot continue to execute properly. In some examples, the debugger  is configured to offer the following operations while running the application : executing step by step (e.g., single-stepping), stopping execution (e.g., breaking or pausing the application to examine the current state) at some kind of event by way of a breakpoint, for example, and tracking values of variables in the application . In some examples, the debugger  is configured to modify the state of the executable application  while running executable application , rather than merely to observe it.","In some implementations, the debugger  is configured to receive a user testing preference for selecting a testing location of the executable client and server applications , . For example, the user may set the user testing preference for testing the executable application  (both the executable client and server applications , ) on a local computing device  executing the IDE . In the example shown in , the debugger  is part of the IDE  and communicates with the compiler  to receive the executable client and server applications , . The compiler  is shown separate from the IDE , but may be incorporated in the IDE . Similarly, the debugger  is shown part of the IDE , but may be separate from and communicates with the IDE . The compiler , debugger , and IDE  are shown as executing on a computer ; however, each of them may be executed on one or more separate computers or services communicating with one another. The debugger  is configured to run or execute the executable client application  on a local client virtual machine  instantiated by the IDE  and run the executable server application  on a local server virtual machine  instantiated by the IDE . The debugger  communicates with the local client and server virtual machines ,  for monitoring execution of the executable client and server application , . A virtual machine (VM) is a software implementation of a machine (e.g., a computer) that executes programs like a real machine. For example, a program written in Java receives services from a Java Runtime Environment (JRE) software program by issuing commands from which the expected result is returned by the Java software. By providing these services to the program, the JRE software is acting as a \u201cvirtual machine\u201d, taking the place of the operating system or hardware for which the program would ordinarily have had to have been specifically written. The debugger  may communicate with the virtual machines ,  over a network in an example format of extensible markup language (XML), JSON, plain text, or a binary protocol. For example, the debugger  may communicate over TCP\/IP sockets using hyper-text transfer protocol (HTTP). If both the client and server virtual machines are executing on the same computer, communication may occur through shared memory.","In some examples, the user sets the testing preference for testing the executable client application  on a local computing device  (e.g., the computing device executing the IDE ), and test the executable server application  on the cloud computing service . In the example shown in , the debugger  is configured to run or execute the executable client application  on the local client virtual machine  instantiated by the IDE  and run the executable server application  on the server virtual machine  instantiated by the server computing device  in the cloud computing service . The debugger  communicates with the local client virtual machines  and the server virtual machine  for monitoring execution of the executable client and server applications , .","In some examples, the user sets the testing preference for testing the executable client application  on the client computing device , and test the executable server application  on the cloud computing service . In the example shown in , the debugger  is configured to run or execute the executable client application  on a client virtual machine  instantiated by the client computing device  and run the executable server application  on the server virtual machine  instantiated by the server computing device  in the cloud computing service . The debugger  communicates with the client virtual machine  and the server virtual machine  for monitoring execution of the executable client and server applications , .","Referring to , a flowchart  represents an arrangement of debugging operations of the debugger . Typically, the debugging operations are executed on a processor present in the computer , upon which the debugging  resides; however, the operations may also be executed by multiple processors present in the computer . While typically executed by a single computer  (e.g., electronic device or computing device), in some arrangements, operation execution may be distributed among two or more computers . Debugging operations include receiving  a executable client application , receiving  a executable server application , instantiating  a client virtual machine , , and instantiating  a server virtual machine , . Debugging operations include executing  the executable client application  on the client virtual machine , , executing  the executable server application  on the server virtual machine , , and monitoring  execution of the executable client and server application , , as by communicating with the local and server virtual machines , , , . In some implementations, debugging operations include receiving a testing location preference, such as testing the one or both of the executable client and server applications ,  on one or more of a local machine , a cloud computing service , and a client computing device . The client virtual machine ,  is instantiated on the local computing device  for testing the executable client application  thereon. Similarly, the server virtual machine ,  is instantiated on the local computing device  for testing the executable server application  thereon. For testing on the cloud computing service , the server virtual machine ,  is instantiated on a server computing device  in the cloud computing service  for executing the executable server application . For testing on the client computing device , client virtual machine ,  is instantiated on the client computing device  for executing the executable client application . Monitoring execution of the executable application  may include providing a source code location of the application  related to a failure of the executable application , executing the executable application  step-by-step of the application source code, stopping execution of the executable application  for providing a variable state, and modifying a state of the executed executable application .","Various implementations of the systems and techniques described here (e.g., the compiler , the debugger , and the deployer ) can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and\/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and\/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.","Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).","The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.","The term \u201cdata processing apparatus\u201d encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.","A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.","Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.","While this specification contains many specifics, these should not be construed as limitations on the scope of the invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of the invention. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable sub-combination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a sub-combination or variation of a sub-combination.","Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.","A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly, other implementations are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2C-2F"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 4-7C"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 11 and 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
