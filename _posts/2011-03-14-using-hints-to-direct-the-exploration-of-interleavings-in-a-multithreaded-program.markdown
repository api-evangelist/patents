---
title: Using hints to direct the exploration of interleavings in a multithreaded program
abstract: A program code data structure is described. The data structure contains substantive code of a multithreaded computer program that includes a plurality of communicating instructions that effect communication between threads. The data structure further contains, at each of one or more points in the substantive code, an indication that, when the computer program is being executed, one or more communicating instructions that are in a selected relationship with the indication should be executed by any thread that reaches the point in a particular order relative to execution of one or more other communicating instructions by other threads. The contents of the data structure may be used to determine an order in which to execute communicating instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08893092&OS=08893092&RS=08893092
owner: F5 Networks, Inc.
number: 08893092
owner_city: Seattle
owner_country: US
publication_date: 20110314
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is related to the following applications: U.S. patent application Ser. No. 13\/047,716, filed Mar. 14, 2011, entitled \u201cAUTOMATIC IDENTIFICATION OF INTERESTING INTERLEAVINGS IN A MULTITHREADED PROGRAM,\u201d and U.S. patent application Ser. No. 13\/047,713, filed Mar. 14, 2011, now U.S. Pat. No. 8,843,910, entitled \u201cIDENTIFYING A SET OF FUNCTIONALLY DISTINCT REORDERINGS IN A MULTITHREADED PROGRAM,\u201d both of which are hereby incorporated by reference in their entireties.","This application claims the benefit of U.S. Provisional Patent Application No. 61\/313,695, filed on Mar. 12, 2010, which is hereby incorporated by reference in its entirety.","This application is related to the following applications, each of which is incorporated by reference in its entirety: U.S. Provisional Patent Application No. 61\/313,692 entitled \u201cIDENTIFYING A SET OF FUNCTIONALLY DISTINCT REORDERINGS IN A MULTITHREADED PROGRAM;\u201d and U.S. Provisional. Patent Application No. 61\/313,693 entitled \u201cAUTOMATIC IDENTIFICATION OF INTERESTING INTERLEAVINGS IN A MULTITHREADED PROGRAM.\u201d","This application is further related to the following applications, each of which is hereby incorporated by reference in its entirety: U.S. Provisional Application No. 61\/013,019, filed Dec. 12, 2007; U.S. application Ser. No. 12\/334,336, filed Dec. 12, 2008; U.S. Provisional Application No. 61\/035,490, filed Mar. 11, 2008; and U.S. application Ser. No. 12\/402,395, filed Mar. 11, 2009.","The described technology is directed to the field of software development and testing techniques, and, more particularly, to the field of debugging techniques.","A multithreaded program is a program that is capable of having two or more threads that can each be simultaneously executed by a different processor of a multiprocessor system or a different core of a multicore processor. Executing two or more threads of the program simultaneously can increase the processing speed of the program and\/or the efficiency of the computer. Although each thread is executed by a single processor or core, it is common for threads to share other resources (e.g., memory) of the computer. As a result, two or more threads of a multithreaded program may access the same shared resource. For example, one thread may execute code that writes a value of a shared memory location at approximately the same time (e.g., shortly before or after) that another thread executes code that reads the shared memory location.","The inventors have recognized that the different orders in which threads of a multithreaded program\u2014or tasks of another type that are executing some sort of programmatic entity\u2014access (e.g., read, write, etc.) one or more memory locations may produce different program behaviors or results, at least some of which are of interest to the developer of the multithreaded program. As one example, threads' access to a particular memory location in a particular order may cause a multithreaded program to crash or perform other undesirable behavior. Where the developer of the multithreaded program is able to detect this situation, the developer may wish to modify the multithreaded program code, such as by adding a synchronization mechanism to guarantee that the threads access the memory locations in an order that avoids this result, removing or modifying one of the accessing instructions, etc.","Accordingly, a hardware and\/or software facility is described that explores different execution schedules for the threads of the program in which the threads access shared memory locations in different orders to identify thread execution schedules that produce interesting results, such as undesirable results. As used herein, the term \u201cschedule\u201d refers to any subset of potentially communicating memory accesses and the order in which those accesses are executed by threads of the multithreaded program. Potentially communicating memory accesses are two or more accesses, at least one of which is a write, that overlap in memory and are present in a program execution. In some embodiments, a schedule may define one or more pairs of potentially communication memory accesses to the same location (referred to herein as \u201cinterleavings\u201d). These explorations of schedules by the facility are called \u201csimulations.\u201d A group of simulations performed together is called a \u201csimulation round.\u201d","Communication between threads can occur when a thread reads a memory location that was written by another thread or when a thread writes to a memory location that is subsequently read by another thread. Where multiple threads communicate by all accessing at least one same memory location in common, multiple schedules are possible. A schedule specifies an order in which different threads access one or more locations in common. A schedule typically specifies this order in a way that identifies the accesses of each thread. In various embodiments, a schedule further specifies the location accessed in each access operation; the type of each access operation (e.g., read, write, or exchange); the instruction at which each access is performed; an absolute or relative time at which each access is performed; and\/or other related information. For example, where location A is the only communicating location and thread 1 writes location A once and thread 2 reads location A once, two schedules are possible: {<location A, thread 1>, <location A, thread 2>}\u2014meaning that thread 1 writes location A before thread 2 reads location A\u2014and A{<location A, thread 2>, <location A, thread 1>}\u2014meaning that thread 2 reads location A before thread 1 writes location A. The facility's exploration of different thread execution schedules in a simulation round involves selecting a number of \u201cpaths\u201d for execution as individual simulations in simulation round, where each path is a combination of one possible interleaving for each of multiple locations. Continuing the example, where location A is accessed as described above and location B is written once by thread 2 and once by thread 3, the 24 possible schedules may be:\n\n","In some embodiments, to cause the threads to access an identified memory location in a different order as part of pursuing a particular path than an individual simulation, the facility suspends the execution of one or more threads. For example, in response to a thread requesting to access an identified memory location, the facility may suspend the thread's execution for a period of time determined to be adequate for another thread to access the identified memory location. As another example, in response to a thread requesting to access an identified memory location, the facility may suspend the thread's execution until another thread actually accesses the selected memory location. In some embodiments, if another thread has not accessed the selected memory location within a threshold period of time, the facility determines that the reordering was unsuccessful. Typically, a reordering is unsuccessful when the multithreaded program includes a synchronization mechanism to control the threads' access to selected memory location. If the facility identifies a successful reordering for a selected memory location, then the facility determines that the threads' access to the selected memory location is not controlled and, as a result, the program may behave unpredictably or crash.","In some embodiments, the facility selects an execution point from which, or after which, the facility attempts to perform a round of simulations to reorder the threads' access to one or more identified memory locations. At the selected execution point, the facility captures and saves the state of the multithreaded program and the state of the \u201croot machine\u201d on which the program is executing. This state is collectively referred to herein as the \u201csaved state.\u201d The saved state includes the state necessary to execute the multithreaded program from the selected execution point. For example, the initial state may include: control registers, general purpose registers, floating point registers, data registers, program counters, flags, the address space of the multithreaded program (e.g., the page table, stack, heap, etc.), the state of emulated or physical devices (e.g., clocks, network, storage, I\/O, timers, network interface card, or advanced programmable interrupt controller etc.), or the like. After the facility captures a saved state, the facility enters into a period of simulation in which a number of different paths are explored beginning at the saved state.","In some embodiments, to simulate execution of the multithreaded program from the initial state, the facility initializes a virtual machine with the entire saved state. The facility observes execution of the multithreaded program from the selected execution point within the virtual machine to identify one or more memory locations that are accessed by two or more threads. The facility may initialize the same or another virtual machine with the saved state and deterministically execute the multithreaded program to reorder the threads' access to at least one of the identified memory locations, and thus simulate a different path.","In some embodiments, to simulate execution of the multithreaded program from the saved state, the facility performs speculative execution using a copy-on-write (\u201cCOW\u201d) strategy. That is, instead of initially initializing the virtual machine with the entire saved state, the facility waits for a thread to perform an access operation that would change a region of memory in the saved state, and in response creates a copy of the region of memory and the access operation is performed on the copied region. When a COW strategy is used to simulate execution, the facility is able to perform multiple simulations to explore multiple schedules because the saved state is left unchanged.","After the facility has conducted a number of different simulations in a simulation round, the facility selects one of the simulations based on judging it the most interesting. The facility \u201cretires\u201d the selected simulation by causing the root machine to resume executing the program from the saved state while imposing the path used in the selected simulation. The facility may also or instead \u201cpackage\u201d the selected simulation for later replay on the same or another virtual machine. In some embodiments, rather than considering for simulation all possible paths\u2014that is, every possible combination of different schedules\u2014the facility considers only paths that include a functionally distinct set of possible schedules by eliminating possible schedules that are functionally equivalent with possible schedules in the functionally distinct set. In particular, in such embodiments, the facility employs a system of vector clocks that track, throughout the course of a simulation, for each thread, the most recent state of each of the other threads that it could have been made aware of by communications from the other thread. In maintaining such vector clocks, the facility regards any write to an address by a first thread that is followed by a read from the same address by a second thread as a communication from the first thread to the second thread. Each update to a clock component of a first thread regarding a communication from a second thread that is completed in a particular read instruction executed by the first thread is said to establish a reorderability window of the second thread with respect to the location read by the completing read instruction. For each reorderability window established in this way by the facility, it identifies as a functionally distinct reordering any reordering that reconstitutes a reordering between the completing read instruction of the second thread and the write instructions for the same location by the first thread that are within the window.","In some embodiments, the facility exhaustively explores the minimized set of possible schedules, conducting a separate simulation for each path that can be constructed from the functionally distinct set of schedules. In some embodiments, the facility explores the paths through the functionally distinct reorderings incompletely. As an example, in some embodiments, the facility randomly selects fewer than all such paths. As another example, in some embodiments, the facility actively identifies promising paths among these based upon explicit hints included in the program by its developer that identify points or regions in the code that the developer expected to be interesting to explore. The facility observes, during the foregoing simulation, which points or regions identified by hints were executed. The facility then selects one or more schedules proximate to the identified points and regions to perturb in the path for the prior simulation to arrive at the path for the next simulation.","In some embodiments, the facility attributes a \u201cretirement score\u201d to each simulation in a simulation round these as a basis for selecting the simulation from the simulation round to retire or replay. In some embodiments, a simulation's retirement score is based upon whether a crash or other error was encountered during the simulation, including processor faults such as a general protection fault, a divide by zero exception, accessing a null pointer, etc. In some embodiments, a simulation's retirement score is based upon explicit hints included in the program by its developer. As one example of hints, the developer can include one or more assertions in the program. Each assertion specifies a condition that the developer always expects to be true when execution reaches the point in the program where the assertion is placed. In some embodiments, whether the condition specified by one of these assertions evaluates as false during a simulation contributes to the simulation's retirement score. As another example of hints, the developer can include specialized function calls or other constructs that identify a point in the program or a region in the program as being interesting, such as points or regions that contain error-prone code or are otherwise sensitive. In some embodiments, the number and\/or weight of interesting points and sections encountered by the simulation contributes to the simulation's retirement score. In some embodiments, when a simulation round is completed, the facility selects the simulation having the highest retirement score to be retired and\/or replay. In some embodiments, as soon as a simulation is completed whose retirement score exceeds a predetermined threshold, but simulation round is terminated and the simulation question is retired and\/or replayed.","In some embodiments, the facility provides a mechanism for delivering at least some types of interrupts to simulations executing on a virtual machine\u2014such as inter-processor interrupts (\u201cIPIs\u201d) and timer device interrupts (\u201cTDIs\u201d)\u2014and\/or permits simulations to continue to execute in the virtual machine through the invocation of an interrupt handler after an interrupt of one of these types occurs. In some embodiments, the facility provides such a mechanism by providing a synthetic advanced programmable interrupt controller (\u201cAPIC\u201d) that sends and receives IPIs, and\/or by providing virtual timers to generate TDIs.","By operating in some or all of the ways described above, the facility enables developers to more efficiently and\/or effectively identify interesting schedules in a multithreaded program, such as schedules that surface concurrency defects.",{"@attributes":{"id":"p-0032","num":"0055"},"figref":"FIG. 1","b":["100","100","105","110","115","105","100","105","110","100","105","100","105","105"]},"The interconnect system  shown in  is an abstraction that represents any one or more separate physical buses and\/or point-to-point connections, connected by appropriate bridges, adapters and\/or controllers. The interconnect system  may include, for example, a system bus, a form of Peripheral Component Interconnect (PCI) bus, a HyperTransport or industry standard architecture (ISA) bus, a small computer system interface (SCSI) bus, a universal serial bus (USB), an Institute of Electrical and Electronics Engineers (IEEE) standard 1394 bus (sometimes referred to as \u201cFirewire\u201d), and so on.","System memory  includes a memory  for storing programs and data while they are being used; a persistent storage device , such as a hard drive, for persistently storing programs and data; and a computer-readable media drive , such as a CD-ROM or DVD-ROM drive, for reading programs and data stored on a computer-readable medium. As used herein, system memory  includes any form of volatile, nonvolatile, removable, and non-removable media, or any combination of such media devices that are capable of storing information such as computer-readable instructions, data structures, program modules, and other data of the computing system .","Also connected to the processors  through the interconnect system  is a network adapter  and one or more input devices and output devices (\u201cI\/O devices\u201d) . The network adapter  provides the computing system  with the ability to communicate with other computing systems over a network and may be, for example, an Ethernet adapter. The I\/O devices  provide a user of the computing system  with the ability to access programs and data stored in system memory . For example, I\/O devices  may include input devices such as a keyboard, pointing device, microphone, etc., and output devices such as a display device, speakers, a printer, and so on.","While computing systems configured as described above are typically used to support the operation of the facility, those skilled in the art will appreciate that the facility may be implemented using devices of various types and configurations, and having various components.",{"@attributes":{"id":"p-0037","num":"0060"},"figref":"FIG. 2","b":["200","205","200","200","205","200","210","200","215","215","205","220","210","225","215","205","205","230","235","235","250","230","230","250","230","250","250","215","225"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["In some embodiments, while simulating execution of the multithreaded program on the virtual machine , the facility speculatively executes the multithreaded program using a copy-on-write (\u201cCOW\u201d) strategy. In response to a thread's request to write to a memory location, the facility creates a copy of the region of memory that contains the memory location and the write operation is performed on the copied region. When a COW strategy is used to simulate execution, the facility is able to perform multiple simulations to explore multiple schedules because the copied address space  is left unchanged. For each explored schedule, the facility maintains a record of the regions of memory accessed (e.g., read, written, etc.) by threads of the multithreaded program. For each explored schedule that is included in the replay package , the facility includes a copy of the regions of memory  from the address space  or . In some embodiments, if multiple explored schedules are included in the replay package , the facility includes the union of the regions of memory accessed by the threads to perform each of the explored schedules.","In some embodiments, while simulating execution of the multithreaded program on the virtual machine , the facility executes the multithreaded program using a copy-on-access (\u201cCOA\u201d) strategy. In response to a thread's request to access (e.g., read, write, etc.) a location within a region of memory, the facility determines whether the request is the first request to access any location within the region memory. If the request is the first request, the facility creates a copy of the region of memory  from the address space  or  before the access operation is performed. If the simulation is included in the replay package , the copied regions of memory  are included in the replay package . In some embodiments, if multiple simulations are performed using the COA strategy, the facility includes the union of the regions of memory accessed by the threads for each of the simulations included in the replay package ."]}}}},"In some embodiments, a selected path  is \u201cretired\u201d on the root machine  by deterministically executing the multithreaded program on the root machine  in accordance with the path .",{"@attributes":{"id":"p-0039","num":"0064"},"figref":["FIG. 3","FIGS. 4-7","FIG. 10","FIGS. 10-12"],"b":["301","302","303","303","303","304","304","304","305","302","306","305","306","307","306","307","307","308","309","310","309","307","309","305","310","307","311","310","311","310","311"]},"While  shows the use of only a single virtual machine to perform simulations, in some embodiments, the facility uses multiple virtual to simultaneously perform different simulations. These multiple virtual machines may execute on the same or different physical machines.","Those skilled in the art will appreciate that the steps shown in  and in each of the flow diagrams discussed below may be altered in a variety of ways. For example, the order of the steps may be rearranged; some steps may be performed in parallel; shown steps may be omitted, or other steps may be included; etc.",{"@attributes":{"id":"p-0042","num":"0067"},"figref":"FIG. 4"},"The facility loops through steps - for each request by a thread of the multithreaded program to access a memory location within a region of memory.  can be better understood in the context of  and the table listed below, which shows the regions of memory accessed as a result of the operations shown in . In various embodiments, those regions are pages of memory, pages in the page table, or portions of pages, such as quarter-pages, cache lines, or words.",{"@attributes":{"id":"p-0044","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"location","memory region","accessed?"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A, B, C","1","Yes"]},{"entry":[{},"D","2","Yes"]},{"entry":[{},"E, F, G","3","No"]},{"entry":[{},"H","4","No"]},{"entry":[{},"W, X, Y, Z","5","Yes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0045","num":"0070"},"figref":["FIG. 5","FIG. 5"],"b":["500","505","510","515","520","405","430","405","430","405","430"]},"While  and each of the table diagrams discussed below show a table whose contents and organization are designed to make them more comprehensible by a human reader, those skilled in the art will appreciate that actual data structures used by the facility to store this information may differ from the table shown, in that they, for example, may be organized in a different manner; may contain more or less information than shown; may be compressed and\/or encrypted; etc.","Returning to , in step , the facility traps a request by a thread to access a memory location within a region of memory. For example, at time 1, the facility traps the access operation (\u201cwrite A\u201d) that is to be performed by thread 1. In step , the facility determines whether the request is the first request to access any location within the region of memory. If the request is the first request to access any location within the region of memory, then the facility continues at step ; else the facility continues at step . In step , the facility records an identifier associated with the accessed region of memory to identify that the region of memory has been accessed by a thread of the multithreaded program. For example, a region identifier of an accessed region may be recorded in a table or other data structure. As another example, the facility can mark a region as accessed in response to a thread requesting to access a location within the region. In some embodiments, instead of or in addition to recording an identifier associated with the accessed region of memory, the facility creates a copy of the region of memory before the access operation is performed. If the simulation is included in the replay package, the copied regions of memory are included in the replay package. In the example illustrated in , the facility determines that memory region 1 is first accessed by thread 1 at time 1; memory region 2 is first accessed by thread 1 at time 2; and memory region 5 is first accessed by thread 1 at time 3. Each of these access operations are trapped by the facility and an identifier associated with the accessed region is recorded in step . In the example illustrated in , the remaining instructions are trapped and the facility determines that the requested locations are within regions of memory previously accessed. For example, for the access operation (\u201cwrite B\u201d) performed by thread 2 at time 3, the facility determines that the requested location (\u201cB\u201d) is not the first access to the region of memory (region 1), in which case, the facility continue at step .","In step , the facility determines whether the requested memory location has been accessed by another thread during the simulation. If the memory location has been accessed by another thread, the facility continues at step ; else the facility continues at step . To determine whether a memory location has been accessed by another thread, the facility may maintain a list of each memory location that has been accessed during the simulation, for example. In step , the facility records the order in which the threads accessed the memory location (\u201cschedule order\u201d). For example, for the access operation performed at time 2 by thread 2, the facility determines that memory location A has been previously accessed by thread 1. In this example, in step  for the access operation performed at time 2 by thread 2, the facility records the schedule order for memory location A as A(1, 2). As another example, in step  for the access operation performed at time 4 by thread 1, the facility records the schedule order for memory location A as A(1, 2, 1). As yet another example, in step  for the access operation performed at time 5 by thread 3, the facility records the schedule order for memory location B as B(2, 3).","In step , the facility determines whether the simulation is complete. For example, the facility may determine that a simulation is complete if the multithreaded program crashes. As another example, the facility may determine that a simulation is complete if the multithreaded program reaches an unexpected state. As yet another example, the facility may determine that a simulation is complete if the multithreaded program ends. If the simulation is not complete, the facility continues at step  to trap the next access operation; else, the process  ends.","In some embodiments, the schedule is the subset of potentially communicating accesses in the order in which those accesses are executed by the threads of a multithreaded program. For example, the schedule illustrated in  is {<location A, thread 1>, <location A, thread 2>, <location B, thread 2>, <location A, thread 1>, <location C, thread 1>, <location B, thread 3>, <location C, thread 2>}.",{"@attributes":{"id":"p-0051","num":"0076"},"figref":["FIG. 6","FIG. 6","FIG. 7"],"b":"601"},{"@attributes":{"id":"p-0052","num":"0077"},"figref":"FIG. 7","b":["700","714","715","716","718","711","712","713","715","715"]},"Returning to , in step , the facility advances the accessing thread's component of its own clock vector to reflect the advancement of absolute time. As an example, for the memory access instruction performed by thread 1 at time 2, the clock vector for accessing thread 1 in column  is changed from <1, 0> to <2, 0>, such that its first component corresponding to accessing thread 1 is set equal to time 2.","Returning to , in step , the facility determines the type of memory access operation that the accessing thread is performing; if the performed access operation is a write (shown as \u201cwr\u201d in ), then the facility continues in step ; if the performed access operation is a read (shown as \u201crd\u201d in ), then the facility continues in step . As mentioned above, the facility treats some complex memory access operations, such as the exchange operation (shown as \u201cx\u201d in ) as both a read and a write, and so continues at both step  and step .","In step  where the access operation is a write, the facility modifies the clock vector for the accessed memory location based upon the clock vector of the accessing thread. In particular, the facility sets the clock vector for the accessed memory location to be the component-wise maximum of the current clock vector for the accessed memory location and the clock vector of the accessing thread. The facility performs step  as a recognition that, by writing information to the accessed memory location, the accessing thread could have stored in the accessed memory location information that is based on its current state, or the state of any other thread of which the accessing thread is currently aware. This information may be later obtained and used by any thread that subsequently reads the accessed memory location. For example, for the access operation performed at time 6 by thread 2 that involves writing to location C, the facility determines the new clock vector state <, > for location C at time 6 in column  by performing a component-wise maximum of the clock vector state for location C at times 0-5, <0, 0>, and the clock vector state for thread 2 at time 6, <4, 6>. In some embodiments, if a clock vector does not exist for the accessed memory location, the facility creates and initializes a new clock vector for the accessed memory location as part of step . After step , the facility continues in step  to trap the next access operation.","In step  where the access operation is a read, the facility modifies the clock vector of the accessing thread based upon the clock vector of the accessed memory location. In particular, the facility sets the clock vector for the accessing thread to be the component-wise maximum of the current clock vector for the accessing thread and the clock vector for the accessed memory location. The facility performs step  as a recognition that, by reading information from the accessed memory location, the accessing thread could have obtained and used information stored in the accessed memory location by any earlier writer to the accessed memory location that reflects the writing thread's state on writing, as well as the state of any other thread of which the writing thread is then aware. For example, for the access operation performed at time 2 by thread 1 that involves reading from location B, the facility determines the new clock vector state <2, 0> for thread 1 in the box for time 1 in column  by performing a component-wise maximum of the current clock vector state for accessing thread 1, <1, 0>, and the clock vector state for location C, <0, 0, 0>. After step , the facility continues in step  to trap the next access operation.",{"@attributes":{"id":"p-0057","num":"0082"},"figref":["FIG. 8","FIG. 7"],"b":["800","802","806","801","803","804","803","805","804","806","802"]},{"@attributes":{"id":"p-0058","num":"0083"},"figref":["FIG. 9","FIG. 7","FIG. 7","FIG. 8","FIG. 7"],"b":["902","909","712","713","911","9","902","914","905","914","903","904"]},{"@attributes":{"id":"p-0059","num":"0084"},"figref":"FIG. 10","b":["1001","1001"]},"One type of hint recognized by the facility in some embodiments is assertions. Each assertion specifies a condition that the developer always expects to be true when execution reaches the point in the program where the assertion is placed. For example:",". . .","price=*A;","Assert (price >=0);","ChargeCustomer (quantity*price);",". . .","By including the assertion in this code snippet, the developer is indicating that something has gone wrong if the value for the variable price, retrieved from location A, is negative. In some cases, the facility leverages assertions added to the code by the developer for a purpose other than guiding exploration, such as for use with a debugger. An example of such assertions that are leveraged in some embodiments is a language level assertion. In some embodiments, the facility causes a compiler or a compiler pre-processor to substitute specialized simulation hinting assertions for language-level assertions.","One type of hint recognized by the facility in some embodiments is hints relating to a level of interestingness of code near a point or within a region, referred to herein as \u201ccode interestingness hints.\u201d Interestingness hints may be either positive, indicating that nearby code is interesting and nearby schedules should be explored, or negative, indicating that nearby code is not interesting and nearby schedules should not be explored. In some embodiments, the facility can specify weightings for interestingness hints, particularly positive interestingness hints, indicating how interesting code nearby the hint is. In some embodiments, interestingness hints are further subdivided, such as into a class where the nearby code is interesting because it is sensitive, as contrasted with another class where the nearby code is interesting because it is expected to be rarely executed. In some embodiments, hints, such as interestingness hints, can be conditional, such as a hint that specifies that code near a certain point is interesting if, at that point in the program's execution, the available resources of a certain type is below a specified threshold.","It is typical to add a hint relating to a particular point in the code by adding a single function call specifying the type of hint to the code at the point in question. For example:",". . .","InterestingPoint( )","average_price=price\/0;",". . .","It is typical to add a hint relating to a particular region of code by adding two different function calls specifying the type of the hint to the code, one at the beginning of the region and one at the end of the region. For example:",". . .","BeginInterestingRegion(23);","price=*A;","quantity=*B;","EndInterestingRegion(23);",". . .","One type of hint recognized by the facility in some embodiments is hints relating to a level of interestingness of a piece of data or a data structure, referred to herein as \u201cdata interestingness hints.\u201d It is typical to add a data interestingness hint relating to a particular piece of data or data structure by adding a function call specifying the type of hint to the code adjacent to the declaration for the data or data structure. For example:",". . .","int foo;","InterestingnessData( );",". . .","One type of hint recognized by the facility in some embodiments is \u201cdirective hints,\u201d which specify that particular schedules of memory accesses should occur, either during all simulations or during a particular percentage of simulations. In some embodiments, the developer adds such a directive hints to the code by adding hints at the beginning and end of a region of code executed by first thread, and adding a third hint to a point in code executed by a second thread that indicates that the second thread should be suspended at the point of the third hint until the first thread finishes executing the region defined by the first two hints.","In some embodiments, the facility automatically adds hints to the code in response to actions by users. For example, in some embodiments, where a user uses a debugger to establish a watch point for a piece of data or data structure, the facility automatically adds a data interestingness hint for that data or data structure. As another example, in some embodiments, in response to a user using a debugger to add a break point to the program's code at a particular point, the facility automatically establishes a code interestingness hint at that point.","Returning to , in step , during each simulation, the facility uses some or all of the code and\/or data hints it encounters while executing the simulation to score paths that are related to the path pursued during the current simulation. These scores are then used by the facility in step  to select a path to be pursued in a future simulation. In some embodiments, the facility uses some or all of interestingness hints and directive hints as a basis for scoring paths in step .",{"@attributes":{"id":"p-0088","num":"0113"},"figref":["FIG. 11","FIG. 8"],"b":["1111","1112","113","1114","1115","1122","1132","1143","1153","1164","1174","1184","1955","1100","1143","1153","1164","1174","1184"]},"Returning to , in step , after each simulation has completed, the facility uses some or all of the hints include in the code in step  to score the path pursued during the simulation as a basis for selecting a simulation of the round to retire. In some embodiments, the facility uses failed assertions as a basis for determining this retirement score for the simulation. In some embodiments, the facility uses crashes or other errors encountered during the simulation as a basis for determining the retirement score for the simulation, including such errors as general protection faults, divide by zero exceptions, accessing a null pointer, etc. after step , these steps conclude.","In some embodiments, interestingness hints are instead or also used by the facility to choose paths to pursue in future simulations in a different way. In such embodiments, the facility determines at what times during the current simulation interesting points or regions occur in different threads, and designs a future path intended to cause interesting points and regions in different threads to intersect in time.  is the thread timing diagram showing the relative timing of execution of interesting regions by different threads. Timeline  shows the execution schedule for thread 1, and timeline  shows the execution schedule for thread 2. Timeline  shows that thread 1 encounters an interesting region during time period , which is completely distinct from time period  in which thread 2 encounters an interesting region. In these embodiments, the facility designs a path for a future simulation in which thread 1 is suspended when it reaches point , and is only allowed to resume execution when thread to reaches point , thus causing these interesting regions to intersect in time.","In some embodiments, the facility provides a mechanism for delivering at least some types of interrupts to simulations executing on a virtual machine\u2014such as inter-processor interrupts (\u201cIPIs\u201d) and timer device interrupts (\u201cTDIs\u201d)\u2014and\/or permits simulations to continue to execute in the virtual machine through the invocation of an interrupt handler after an interrupt of one of these types occurs. In some embodiments, the facility provides such a mechanism by providing a synthetic advanced programmable interrupt controller (\u201cAPIC\u201d) that sends and receives IPIs, and\/or by providing virtual timers to generate TDIs.","In some embodiments, the facility employs a fully or partly-virtualized advanced programmable interrupt controller (\u201cAPIC\u201d) that has the ability to send IPIs and deliver and acknowledge incoming IPIs and timer interrupts. Such APIC's effect IPIs by calling an IPI handler callback. A default such callback posts IPIs to the physical APIC.","In some embodiments, the facility prohibits simulation at a time when a pending IPI exists in the physical APIC. In some embodiments, the facility similarly prohibits simulation when any bit is set in the physical APIC IRR.","In some embodiments, when an IPI is sent to a virtual processor executing a thread that is presently suspended by the facility, the facility unsuspends the thread and virtual processor so that the IPI can be acknowledged.","When an IPI is sent to a virtual processor that is presently in a halted or power saving state, the facility unhalts the virtual processor so that the IPI can be acknowledged and appropriate interesting actions taken, such as the scheduling of a new thread on the virtual processor.","In some embodiments, if a simulation sets a bit of the in-service register (\u201cISR\u201d) bit but does not clear it, the facility does not allow that simulation to retire. In some embodiments, the facility enforces this constraint using its simulation scoring mechanism.","In some embodiments, the facility takes steps to avoid suspending any thread and corresponding virtual processor for an extended period of time that may be an IPI target. In some cases, the facility achieves this by observing a rule that no thread and associated virtual processor can be suspended in an interval of a predetermined length that begins when an IPI is sent.","In some embodiments, the facility is able to begin a simulation with an ISR bit set in the physical APIC. If the ISR bit is cleared in the simulation by an end of interrupt signal (\u201cEOI\u201d), the facility replays the EOI to the physical APIC during replay of the simulation. If the ISR bit is not cleared by an EOI during the simulation, then the physical APIC is still in the correct state when replay concludes.","In some embodiments, the facility forces additional thread schedules by delaying the delivery of interrupts such as IPIs and TDIs. In some cases, the facility delivers broadcast IPIs to some processors before others, which in some cases can cause the operating system scheduled to create new scheduling combinations. In some embodiments, the facility uses this technique to reorder across a context switch: On a two-processor machine on which thread set (, ) is running concurrently before an IPI, and thread set (, ) is running concurrently after the IPI; by delaying the IPI to thread 2's virtual processor but delivering it to thread 1's virtual processor, the facility causes thread set (, ) to run concurrently, and similarly causes thread set (, ) to run concurrently.","In some embodiments, the facility forces additional thread schedules by delaying or creating timer device interrupts (TDIs), so as to manipulate the perceived time the program has spent executing and thus influence the operating system scheduler into creating rare thread scheduling combinations. In other embodiments, manipulation of the operating system scheduler by varying time inputs may be accomplished, or augmented, by accelerating or decelerating the observed passage of time through various virtualized clock devices, such as the real time timestamp counter (TSC).","In some embodiments, the facility speculates based on the state of inputs other than the timing of answer-thread communications, such as input from a variety of devices. In some embodiments, the facility speculates based upon network card inputs in order to perform security testing or fuzz testing. In some embodiments, the facility speculates based upon clock inputs to ensure more complete test coverage. The facility can use the hypervisor to inject these inputs on behalf of devices that cannot easily be simulated by the developer of the program.","While various embodiments are described with reference to multithreaded program code, in some embodiments, the facility identifies bugs and\/or generates a replay package for other types of program code, including a single-threaded program executing alone, a single-threaded program running on top of an operating system, a task-based application, operating system code, or the like.","It will be appreciated by those skilled in the art that the above-described facility may be straightforwardly adapted or extended in various ways. While the foregoing description makes reference to particular embodiments, the scope of the invention is defined solely by the claims that follow and the elements recited therein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
