---
title: URL mapping methods and systems
abstract: An input URL string is searched for a particular pattern, the pattern being defined in a manner such that the search may be satisfied while allowing variability among constituent parts of the input URL string. The input URL string is mapped to an output URL string if the pattern is found in the input URL string.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06882999&OS=06882999&RS=06882999
owner: Microsoft Corporation
number: 06882999
owner_city: Redmond
owner_country: US
publication_date: 20030722
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation of a U.S. patent application entitled \u201cURL Mapping Methods and Systems\u201d, Ser. No. 09\/304,133; U.S. Pat. No. 6,654,741 by inventors Rico Mariani, Bassam Tabbara, Ariye M. Cohen, and Sanjeev K. Rajan, filed May, 3, 1999, hereby incorporated herein by reference.","URLs or universal resource locators are used to access resources which can be provided over a communications network such as the Internet. URLs are simply formatted strings that identify particular resources. Typically, a user or client will send a URL to a network server that will respond by sending the requested resource, such as a web page, back to the client. URLs that are provided by a client sometimes have a different, simpler form than those that are used by the server and\/or web-site rendering engine that provides the requested resource. For example, a client-provided URL might take the following form: http:\/\/<hostname>\/<Abs Path>, where the \u201chostname\u201d is a network host domain name or address, and \u201cAbs Path\u201d is the location of the resource requested. The location could be a simple directory path to a .htm file, or a list of parameters that the web site rendering engine can act upon to generate HTML-formatted content. Yet, the URL which is used by the web-site rendering engine is often much more complex in form than the client-provided URL. For example, the form used by the rendering engine might take the following form: <Abs Path>\/script\/foo.dll\/<identifier>. The URL form that is used by different rendering engines can really take many forms, and contain the required details that are necessary for the rendering engine to find or generate the requested resource. It is desirable for this more complex URL form to be transparent to the client. This way, the client need only see and\/or provide the more simple \u201cuser-friendly\u201d URL to the server or web-site rendering engine. Additionally, the underlying complex URL may in fact change over time, while it is desirable for the external form of the URL to remain unchanged so as to not affect customers of the service.","Against this backdrop, a need has arisen for a solution to the problem of translating or mapping the simpler, user-friendly URLs into the more complex URLs needed by a rendering engine. Attempts in the past have failed to provide truly flexible, convenient, and dynamic solutions. For example, one past solution was a so-called hard-coded approach which simply provided fixed software code with built-in logic to handle the desired mappings. One way of doing this is to provide a series of IF, THEN statements or a CASE statement to handle the mapping. Problems associated with this approach include that the set of mappings which is supported is fixed, and any changes, such as adding new mapping statements, or modifying existing mapping statements, requires the code to be modified or rewritten. This, in turn, results in a large turn around time which is highly undesirable. In addition, the web service must typically be stopped and restarted which is undesirable and unacceptable for large web-sites that see a large amount of traffic. Moreover, building the rule-mapping logic into the code makes it difficult to have any hierarchical organization of the rules, or to support reverse mapping of the rules. So, in short, the solutions which have been proposed and implemented to date do not provide the flexibility, convenience, and dynamic performance which is so desirable, and in fact, necessary in the current operating environment.","The invention provides for flexible, convenient, and dynamic URL mapping methods and systems by providing generalized approaches which specify patterns in term of recognizable syntax. The recognizable syntax can be defined by one or more rules. The rules are used and applied to an input URL string which is provided by a client to map the input URL string to an output URL string which is used by a rendering engine to provide a requested resource.","Embodiments of the invention provide for a rule cache or internal store in which rules are kept. The rule cache allows for rules to be added, deleted, or modified as desired, without the need to stop and re-start the web service. The rule cache can be populated dynamically at run time. In addition, embodiments of the invention conveniently group rules into rule groups. Individual rule groups can be selectively applied to an input URL string. Furthermore, reverse mapping is supported by embodiments of the invention simply through the use of suitable rule additions or rule group additions in the rule cache, as may be appropriate.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":"10","i":"The World Wide Web: Complete Reference"},"Communication network  includes a server  and a client . The client and server communicate over a communications medium or link such as the Internet  or some other network medium.","In the described embodiment, server  is an Internet information server. A web-site rendering engine  runs on server . The web-site rendering engine is responsible for rendering or providing a resource that is requested by client . The request for the resource includes an input URL string or user-friendly URL that is in a simple form or easily recognizable form, an example of which was given above.","A mapping engine  also executes on server  and initially receives the input URL string. In the illustrated example, mapping engine  includes a rule cache  and a parser . Rule cache  includes one or more rules which are applied to the input URL string. Parser  performs parsing functions on the input URL string. The result of the operations of rule cache  and parser  is an output URL string which is provided to web-site rendering engine . The output URL string is in a form which can be understood by web-site rendering engine . Web-site rendering engine  responds by performing the appropriate operations to generate and return the requested resource to client  via a response which is sent over communication medium .",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2","b":["130","14","12"]},"Computer  includes one or more processors or processing units , a system memory , and a bus  that couples various system components including the system memory  to processors . The bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM .","Computer  further includes a hard disk drive  for reading from and writing to a hard disk (not shown), a magnetic disk drive  for reading from and writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the bus  by an SCSI interface  or some other appropriate interface. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROMs), and the like, may also be used in the exemplary operating, environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM , or RAM , including an operating system , one or more application programs , other program modules , and program data . A user may enter commands and information into computer  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are connected to the processing unit  through an interface  that is coupled to the bus . A monitor  or other type of display device is also connected to the bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices (not shown) such as speakers and printers.","Computer  commonly operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to computer , although only a memory storage device  has been illustrated in FIG. . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the bus  via a serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Generally, the data processors of computer  are programmed by means of instructions stored at different times in the various computer-readable storage media of the computer. Programs and operating systems are typically distributed, for example, on floppy disks or CD-ROMs. From there, they are installed or loaded into the secondary memory of a computer. At execution, they are loaded at least partially into the computer's primary electronic memory. The invention described herein includes these and other various types of computer-readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described below.","For purposes of illustration, programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer, and are executed by the data processor(s) of the computer.","Although  show all of these functions being performed within a single server computer, it is likely that actual embodiments will involve several server computers acting together to satisfy requests of large numbers of clients. Furthermore, the various functions described might be distributed among more than one computer. Also, the mapping engine and web-site rendering engine in the described embodiment are designed to work in conjunction with a Microsoft product called \u201cInternet Information Server.\u201d This product performs many of the management functions of a web server, while allowing customization through the use of so-called \u201cfilters\u201d and \u201cextensions.\u201d Mapping engine 22 is implemented as an ISAPI (Internet Server Application Programming Interface) filter for use in conjunction with Microsoft's Internet Information Server. Web-site rendering engine  is implemented as an \u201cextension,\u201d again for use with Internet Information Server.","As a preliminary matter, the following discussion will use the terminology below:\n\n","In any particular server, a plurality of input expressions are defined in accordance with a predefined syntax. The predefined syntax makes use of pattern matching rules. In the described embodiment, this syntax utilizes complex pattern matching rules known as regular expressions. A regular expression comprises a character string in which literal characters indicate text that must exist identically in an input URL string. Regular expressions can also include special characters to indicate portions of an input string in which variability is allowed.","As an example, assume that it is desired to map the \u201cfriendly\u201d URL input string \u201cseattle.sidewalk.com\u201d to \u201csidewalk.com\/script\/foo.dll\/seattle\u201d. Assume further that similar mappings are to be made for other cities, such as Portland, Cincinnati, etc.","Generally, a matching input string will be any string in which some undefined characters precede the string \u201c.sidewalk.com\u201d. Using a simple form of pattern matching rules, this might be expressed as the following input expression: \u201c*.sidewalk.com\u201d. The \u201c*\u201d indicates any combination of characters, while the following literal characters (\u201c.sidewalk.com\u201d) are to be matched character-by-character with the input string.","To produce the appropriate output string, an output expression corresponding to the input string, is formulated as a replacement template. In this example, the output expression might be \u201csidewalk.com\/script\/foo.dll\/*\u201d. The \u201c*\u201d in an output string is an identifier and represents whatever characters corresponded to the \u201c*\u201d in the input string. In this example, the corresponding characters would have been those of the string \u201cseattle\u201d. Thus, this output expression would generate the output string \u201csidewalk.com\/script\/foo.dll\/seattle.\u201d It should be apparent that the same input\/output expression pair would work with any city specified by a user. This example illustrates a fairly simple and easily understandable syntax. However, more powerful syntax can be used and are often desirable.",{"@attributes":{"id":"p-0032","num":"0035"},"figref":"FIG. 3","b":"22"},{"@attributes":{"id":"p-0033","num":"0036"},"figref":"FIG. 4","b":["100","102","12","14","1","12","104","106","108","16","106","110","104","106","112"]},"In the described embodiment of the invention, mapping engine  stores a plurality of rules in its rule cache . Each rule comprises an input expression and an output expression. The rules are organized in groups. The rules of a particular group are designed for a particular purpose.",{"@attributes":{"id":"p-0035","num":"0038"},"figref":["FIGS. 5-7","FIG. 5","FIG. 6","FIG. 7"],"b":"3"},"Referring specifically to , each rule includes a Rule ID. Here, the Rule IDs number one through twelve. The Rule ID is a number that uniquely identifies a rule inside a rule group. Rules from different groups might take on non-unique Ids, but all rules within a certain group have unique IDs. Rules within each group are applied in the order of the Rule ID, which implies the order in which the rules were added to the group.","Each rule is also given a Rule Action Type. Three exemplary Rule Action Types are as follows:","\u201cR\u201d Repeat Rule","\u201cA\u201d Abort Mapping","\u201cN\u201d No Action","The Repeat Rule action forces a rule to be applied once again if the rule succeeds. The rule will get applied until the rule fails. The Abort Mapping action implies that if the concerned rule is successfully applied, the mapping process should be immediately aborted and a notification is sent to server . The No Action action implies that no special action should be taken if the rule concerned succeeds. That is, the processing of the input URL string should simply continue, i.e. continue following the prescription indicated by the current rule group.","Each rule also includes an input expression and an associated output expression. An input expression in the described embodiment is a regular expression in accordance with the syntax of FIG. . The output expression is a pattern in accordance with the syntax set forth in FIG. . The output expression can be a simple replacement string, or a string including special characters. A \\n (where n is a digit [0-9]) in the output expression of a rule corresponds to the n-tagged expression in the input expression. This provides a convenient notation to extract variable strings from the input expression and insert them into the output expression.","A rule is satisfied or succeeds if each of the following events takes place: (1) the input URL string matches the input expression of the rule, based either on a simple string comparison, or a more complex regular expression search; and (2) an attempt to generate the output string based on the output expression succeeds. If a rule is successful, the Rule Action associated with the rule and the Group Tag (discussed below) of the concerned rule group determines what happens next. If this is the last rule in the last group, then this completes the mapping process.",{"@attributes":{"id":"p-0044","num":"0047"},"figref":"FIG. 6","i":"Inside OLE","sup":"th "},{"@attributes":{"id":"p-0045","num":"0048"},"figref":"FIG. 7"},"As mentioned above, in order to provide for flexibility in the application of rules, the rules can be aggregated in sets to form one or more groups. In essence then, mapping engine  comprises a plurality of rule groups, each of which can contain one or more rules. Groups allow aggregation of rules that achieve one aspect of the mapping process into a group. For example, say an input URL stream needs to be decoded by replacing \u2018+\u2019 with a space and \u2018% xx\u2019 with the character corresponding to the hex value of xx. These operations form two separate rules that take care of one aspect of the URL mapping (that of preprocessing the URL) and can be grouped together in one group.","Groups have the following attributes: (1) Group ID, (2) Group Tag, and (3) Group Mask ID. These are shown for the rule groups in .","The Group ID is a unique identifier for the group and is used to identify the group when rules are changed, i.e. added, deleted, or modified. The Group Tag specifies a protocol to use when applying the rules in a particular group. For example, a \u201cmatch-all\u201d tag specifies that all the rules in a group should be applied. That is, if a rule succeeds, the output of that rule becomes the input of its successor. A \u201cmatch-one\u201d tag specifies that mapping for that rule group should terminate as soon as a rule matches or succeeds. That is, the output for the rule that succeeds becomes the input of the next group (if one exists) to be considered for mapping. If a rule does not succeed, the output of the rule is the same as the input for the rule (as if the rule does not exist).","The Group Mask ID is a bit mask which is used during the mapping process. Each group is given a bit mask upon its creation. When a client needs to send a string for mapping, the client can specify a bit-mask key that is logically combined, e.g. ANDed, with the bit mask of each group. If the result of the logical combination is TRUE, then the group is included in the mapping process, otherwise it is skipped. This use of the Group Mask ID provides a convenient method of specifying which groups of rules need to get included in the mapping and which do not. An example of how this feature can be exploited is as follows.","It is desirable to have mapping which is bi-directional in the sense that where a given set of rules yields a particular output URL string from a given input URL string, there should be another set of rules in which that particular output URL string yields the given (i.e. the same) input URL string. When doing mapping in one direction, the rules for mapping in the other direction should not apply. One way to achieve this is to provide forward-mapping sets of rule groups with one Group Mask ID, and provide reverse-mapping sets of rule groups with another Group Mask ID. For example, assume groups 1, 2, and 3 have the forward-mapping rules, and groups 4, 5, and 6 have the reverse-mapping rules. Group Mask IDs can then be assigned to the respective groups as follows:","Group 1\u20140x0000 0001","Group 2\u20140x0000 0002","Group 3\u20140x0000 0004","Group 4\u20140x0000 0010","Group 5\u20140x0000 0020","Group 6\u20140x0000 0040","If the client requests for an input string to be mapped and specifies the bit-mask key to be \u201c0x0000 0007\u201d, then a logical ANDing with the Group Mask IDs would result in only Groups 1, 2, and 3 getting included in the mapping. This would, in turn, provide for forward mapping. On the other hand, a bit-mask key of \u201c0x0000 0070\u201d would result in only Groups 4, 5, and 6 being considered in the mapping, and not groups 1, 2, and 3. In this case, reverse mapping would be applied.","As another example, consider a situation where rule groups are desired to be removed. If you want to change the rules, the best way to do it is to add the new rules (using bitmasks not currently in use), then once they are all successfully added, switch to using the new bitmasks and stop using the old ones. Subsequently, the old rule groups can be removed. In this way there is a clean move over to the new rule set.","In one specific implementation, a mapping system is provided through the use of Microsoft's Internet Information Server's extension facilities and Microsoft's COM methodologies mentioned above. For purposes in assisting in understanding this implementation, components of the mapping system and pertinent interfaces are described.","The mapping engine is implemented as an ISAPI filter. Hence, it implements the functions every ISAPI filter needs to implement, e.g. GetFilterVersion( ) and HttpFilterProc( ).","GetFilterVersion( ): This function is called only once when IIS (Internet Information Server) is started. It is used for exchanging version information between IIS and the mapping engine. The mapping engine also informs IIS of the notifications that it is interested in. Later, when a certain event occurs, IIS will invoke only those filters that have requested notification for that event.","HttpFilterProc( ): IIS notifies the mapping engine by calling HttpFilterProc( ) and passing it the notification types and a pointer to the structure corresponding to that notification. Using this pointer the mapping engine will gain access to the header information such as<hostname>and <abs_path> (the two parts of the URL discussed above).","The mapping engine is a COM server. This means that it can provide its services to anyone who can obtain a pointer to its appropriate interface. This results in generic, rule-based mapping capabilities. Some of the interfaces that can be used to populate and use the mapping engine are as follows:","SWFriendly Interface","This interface provides various methods for managing and using the mapping engine's rules. It provides support for adding new groups of rules to the rule cache and new rules to the groups. It can also provide support for loading rules from a file, and for storing rules back to a file so that the rules persist even after IIS is restarted. Other methods that can be supported can include methods for modifying and deleting rules. For example, \u201cremove\u201d operations that are analogous to the \u201cAdd\u201d operations discussed just below can readily be added. A few examples of such methods are given below.","AddGroup( )\u2014This method is used by the clients to add a new group to the rule cache. The client specifies a group tag and group mask Id as input parameters, and the method returns a group Id for the newly added group in the output parameter. The client can then use this group Id to add rules to this group.",{"@attributes":{"id":"p-0067","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT AddGroup"]},{"entry":[{},"\/\/---------------------------------------------------------"]},{"entry":[{},"\/\/ Add a new group (or cache) of rules to Friendly"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EGroupTag eGroupTag,"]},{"entry":[{},"\/\/ [in] the group Tag (match one or match all)"]},{"entry":[{},"DWORD dwGroupMaskID,"]},{"entry":[{},"\/\/ [in] the group bit-mask ID. Used to decide whether"]},{"entry":[{},"\/\/ group is to be included in the mapping process"]},{"entry":[{},"DWORD * pdwGroupID"]},{"entry":[{},"\/\/ [out] the groupID generated for the new group"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"AddRule( )\u2014This method is used to add a rule to a group that is identified by its group Id. The client provides the following: group Id of the group to which the rule is to be added, the action associated with the rule, the input expression and the output expression for the rule.",{"@attributes":{"id":"p-0069","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT CSWFriendly::AddRule"]},{"entry":[{},"\/\/---------------------------------------------------------"]},{"entry":[{},"\/\/ Add a new rule to a certain Group."]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD dwGroupID,"]},{"entry":[{},"\/\/ [in] GroupID identifying the group to which the"]},{"entry":[{},"\/\/ rule should be added"]},{"entry":[{},"ERuleAction eRuleAction,"]},{"entry":[{},"\/\/ [in] Action associated with this rule"]},{"entry":[{},"LPCSTR pszSrcString,"]},{"entry":[{},"\/\/ [in] Input Expression for the rule"]},{"entry":[{},"LPCSTR pszDestString"]},{"entry":[{},"\/\/ [in] Output Expression for the rule"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"ProcessURL( )\u2014This method is called by the client to send an input URL string to the mapping engine. The client specifies a bit-mask that is used to decide which groups of rules are to be included for mapping.",{"@attributes":{"id":"p-0071","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT CSWFriendly::ProcessUrl"]},{"entry":[{},"\/\/---------------------------------------------------------"]},{"entry":[{},"\/\/ Takes the incoming Url as input and sends it through"]},{"entry":[{},"\/\/ the mapping engine. The input Url gets sent through each"]},{"entry":[{},"\/\/ group of rules."]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LPCSTR pszUrl,"]},{"entry":[{},"\/\/ [in] Incoming Url"]},{"entry":[{},"DWORD dwBitMask,"]},{"entry":[{},"\/\/ [in] this parameter decides the set of groups that"]},{"entry":[{},"\/\/ get used for mapping"]},{"entry":[{},"LPSTR pszNewUrl"]},{"entry":[{},"\/\/ [in, out] Out Url"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"ISWFriendlyLookUp Interface","This interface provides a method for conducting a lookup procedure. Here, a rule can invoke a lookup procedure that gets its input from the input URL string. The output of this procedure is used in the output generated by the rule, e.g. an output URL string. Objects that implement this interface are referred to as Friendly Lookup Objects or FLOs. Each FLO has a CLSID and a ProgID and registers itself in the registry on compilation. A cache is provided and is referred to as the Friendly Lookup cache. The Friendly Lookup cache contains two fields in each entry\u2014a progid (or a string) and a pointer to the ISWFriendlyLookup interface. When a rule needs to invoke the Lookup method of a FLO, it will use the FLO's ProgID to create an instance of it and will then cache the pointer to the, interface in its cache for future references. Specifically, if the output expression of a rule has a tagged expression with the following syntax, it means that the rule requires a Lookup method to be invoked:\n\n","If the input URL string matches the input expression for a certain rule, and the output expression contains a tagged expression of the type shown above, the mapping engine performs the following steps:\n\n","The ISWFriendlyLookup interface has the following method:","Lookup( )\u2014This method takes as input a string (obtained as explained above) and returns a pointer to a string buffer pointer. The callee allocates memory to hold the output of the Lookup( ) and the caller frees the buffer.",{"@attributes":{"id":"p-0077","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Lookup"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[in] LPCWSTR pwszSource,"]},{"entry":[{},"\/\/ pointer to a buffer containing the string that"]},{"entry":[{},"\/\/ the Lookup method needs for doing the lookup"]},{"entry":[{},"[in, out] LPWSTR * ppwszDestination"]},{"entry":[{},"\/\/ a pointer to a buffer that will hold a pointer"]},{"entry":[{},"\/\/ to the actual string allocated by the callee."]},{"entry":[{},"\/\/ The callee must use IMalloc:Alloc to allocate"]},{"entry":[{},"\/\/ the memory."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Various embodiments of the invention described above provide for a flexible and generic solution to the problem of mapping input URL strings to output URL strings. Rules for mapping can now be changed, i.e. added, deleted, or modified dynamically, without the need to access and rewrite code, or shut down the communication network server. And, while the described embodiments have been described in terms of processing input URL strings, it is possible that other inputs can be used as well. For example, various mapping methods and systems can use other information as inputs, such as that gleaned from an http header. Examples of such other information include cookies, user agent, user browser capabilities and the like. Typically, these are provided as strings. Thus, in these methods and systems, there are two or more inputs to the mapping engine. For example, the two methods specified just below can enable the use of two regular expressions (e.g. one for the URL, and one to process on all of the headers) in order to process the rules.",{"@attributes":{"id":"p-0079","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT AddRuleWithHeader"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"("]},{"entry":[{},"[in] DWORD dwGroupID,"]},{"entry":[{},"[in] ERuleAction eRuleAction,"]},{"entry":[{},"[in] LPCSTR pszSrcString,"]},{"entry":[{},"[in, optional] LPCSTR pszSrcHeaderString,"]},{"entry":[{},"[in] LPCSTR pszDestString,"]},{"entry":[{},"[in] LPCSTR pszAccelerator"]},{"entry":[{},");"]},{"entry":[{},"HRESULT ProcessUrlWithHeader"]},{"entry":[{},"("]},{"entry":[{},"[in] LPCSTR pszUrl,"]},{"entry":[{},"[in, optional] LPCSTR pszHeaders,"]},{"entry":[{},"[in] DWORD dwGroupMaskID,"]},{"entry":[{},"[in, out] LPSTR pszNewUrl,"]},{"entry":[{},"[in] UINT cchSize"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Other advantages will be apparent to those of skill in the art.","Although the invention has been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
