---
title: Method and system for debugging a program from within a thread of execution of the program
abstract: In a method and system for debugging a program, a debugging module is loaded into a normal thread of execution of the program. A user may then send commands to the debugger module from a command console module operating in a safe separate process. The debugger module receives the commands and converts them into function calls to objects that are accessible by the program. This allows the user to interact manually with the objects and achieve substantially the same responses from the object as the program itself would have obtained during its normal execution. Thus the user can effectively debug the program without having to know the internal structure of any of its constituent objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07555744&OS=07555744&RS=07555744
owner: Microsoft Corporation
number: 07555744
owner_city: Redmond
owner_country: US
publication_date: 20041021
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED PATENT APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This patent application is a continuation of U.S. patent application Ser. No. 09\/606,973, Now U.S. Pat. No. 6,915,509, filed Jun. 28, 2000.","This invention relates generally to computer program debugging techniques and, more particularly to a method and system for debugging a program from within a thread of execution of the program.","An object is a logically grouped set of computer-executable functions and computer-readable data. Objects are well-known to programmers of object-oriented languages such as the C++ programming language, the ADA programming language, the PERL programming language, and the JAVA programming language. While the implementation details of objects varies from programming language to programming language, they all have certain characteristics in common. One such characteristic is known as \u201cencapsulation.\u201d Encapsulation means that an object performs its designated purpose in a manner that is hidden from the rest of the program in which it is being used. The hidden data and functions that an object uses to perform its purpose are collectively referred to as private data. Outside entities, such as a main program or a function, may only access an object through its public functions and data. The set of public functions and data for an object is often referred to as a public interface or programming interface. An object may be written according to a variety of well-known standards, including the MICROSOFT COMPONENT OBJECT MODEL (COM) standard, the MICROSOFT DISTRIBUTED COMPONENT OBJECT MODEL (DCOM) standard, and the common object request broker architecture COMMON OBJECT REQUEST BROKER ARCHITECTURE (COBRA) standard. An object may also be compiled into machine code, assembly code, binary code, byte code, or the like, and may be executed on a computer as, for example, an executable file, a DLL, or the like.","One of the advantages of writing a program using an object-oriented language is that the program may be broken up into set of self-contained units or \u201cobjects.\u201d Each object in an object-oriented program typically has a set of public functions and public data that can be accessed by other parts of the program, and a set of private functions and private data that are hidden from the rest of the program. Anything outside an object that wishes to use the object to perform some task must access the object using the public functions and data. How the object performs its task is hidden from the outside through the use of private functions and data. In effect, an object functions as a \u201cblack box\u201d that can receive data, perform a task, and possibly return a result to a caller. Because the internal implementation details of an object are hidden, it is very convenient to create libraries of objects that can be used over and over in multiple programming projects. The public functions and data of an object are typically exposed as one or more interfaces. An interface generally contains pointers to classes that contain the public functions and data.","Frequently, libraries of objects are developed and sold along with programming packages to relieve programmers of the burden of creating their own objects from scratch. The objects in such libraries are generally provided as compiled binary files for the sake of convenience and to keep their internal implementation details confidential. As long as a programmer knows what a particular object is capable of doing, what public functions it exposes, and what inputs it requires, he or she does not have to know how the function is implemented, and may, in fact, create a program from a set of objects written by someone else.","Currently, debugging a program that uses objects often requires more than just a \u201cblack-box\u201d knowledge of the objects. Specifically, it may require a programmer to learn the internal structure of the objects and thereby violate the principle of encapsulation. It is frequently the case, however, that data contained in an object is not present in the memory to which the programmer has access, thus making it nearly impossible to learn its internal structure. For example, a DCOM object may have a proxy on one machine of a network while the bulk of its functions and data are located on another machine of the network and are only accessible by a stub. There are also cases in which a public interface pointer actually points to a thread-specific proxy and not to the real data, such as when the \u201capartment threading model\u201d is used.","In accordance with the foregoing, a novel method and system for debugging a program is provided. According to the method and system, a debugging module is loaded into a normal thread of execution of the program. A user may then send commands to the debugger module from a command console module operating in a separate process. The debugger module receives the commands and converts them into function calls to objects that are accessible by the program. This allows the user to interact manually with the objects and achieve substantially the same responses from the object as the program itself would have obtained during its normal execution. Thus, the user can effectively debug the program without having to know the internal structure of any of its constituent objects.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments that proceeds with reference to the accompanying figures.","Turning to the drawings, wherein like reference numerals refer to like elements, an example environment for implementing the invention is shown in . The environment includes a general purpose-computing device , including a central processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computing device , such as during start-up, is stored in the ROM . The computing device  further includes a hard disk drive  for reading from and writing to a hard disk , a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media.","The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical disk drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, programs and other data for the computing device . Although the exemplary environment described herein employs a hard disk , a removable magnetic disk , and a removable optical disk , it will be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories, read only memories, and the like may also be used in the exemplary operating environment.","A user may enter commands and information into the computing device  through input devices such as a keyboard , which is typically connected to the computing device  via a keyboard controller , and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, joystick, game pad, wireless antenna, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port, a universal serial bus (USB), or a 1394 bus. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computing devices typically include other peripheral output devices, not shown, such as speakers and printers.","The computing device  may operate in a networked environment using logical connections to one or more devices within a network , including another computing device, a server, a network PC, a peer device or other network node. These devices typically include many or all of the elements described above relative to the computing device . The logical connections depicted in  include a land-based network link, for which there are many possible implementations, including a local area network (LAN) link and a wide area network (WAN) link . Land-based network links are commonplace in offices, enterprise-wide computer networks, intranets and the Internet and include such physical implementations as coaxial cable, twisted copper pairs, fiber optics, wireless links, and the like. Data may transmitted over the network links -according to a variety of well-known transport standards, including Ethernet, SONET, DSL, T-1, and the like. When used in a LAN, the computing device  is connected to the network link through a network interface card or adapter . When used in a WAN, the computing device  typically includes a modem  or other means for establishing communications over the network link , as shown by the dashed line. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, programs depicted relative to the computing device , or portions thereof, may be stored on other devices within the network .","Those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, parts of a program may be located in both local and remote memory storage devices.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more logic elements. As such, it will be understood that such acts and operations may include the execution of microcoded instructions as well as the use of sequential logic circuits to transform data or to maintain it at locations in the memory system of the computer. Reference will also be made to one or more \u201cprograms\u201d or \u201cmodules\u201d executing on a computer system or being executed by parts of a CPU. A \u201cprogram\u201d or \u201cmodule\u201d is any instruction or set of instructions that can execute on a computer, including a procedure, function, executable code, dynamic-linked library (DLL), applet, native instruction, module, or the like. On many computers, programs and modules execute within an address space of the computer's memory, which is typically defined as a \u201cprocess.\u201d The point of execution of the program instructions is often referred to as a \u201cthread.\u201d As is conventional, multiple threads of execution may exist for a single program in a process. A program or module may also include a commercial software application or product, which may itself include several programs or components. However, while the invention is being described in the context of software, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","The invention is generally realized as a novel method and system in which a novel debugger (hereinafter referred to as an \u201cin-thread debugger\u201d) operates inside a thread of a program being debugged (hereinafter referred to as the \u201cdebuggee thread\u201d). By operating within the debuggee thread, the in-thread debugger is able to make calls to objects that are known to the debuggee thread and achieve the same results that would be achieved by the thread itself. In a preferred embodiment of the invention, the in-thread debugger communicates with an outside entity, such as a command line console, through a socket. This allows a user, such as a test engineer, to halt the debuggee thread during execution, manually send calls to the in-thread debugger module from outside of the thread, and observe the resulting behavior of the accessed objects without having to know the internal details of the objects.","Referring to , an example of a software environment in which the in-thread debugger may be introduced is shown. A computer  is communicatively linked to computers  and . The computer ,  and  include memories ,  and  respectively. The computer  also includes a CPU  that is communicatively linked to the memory . The CPU  includes a register memory  having one or more registers for holding frequently accessed data. The computers  and  also have CPUs (not shown). The memories ,  and  may be main memory, cache, disk or other types of memory. The memory  includes an object  having public interfaces  and , while the memory  of the computer  includes an object  having a public interface . The memory  also includes a process  that defines the address space for a program in the memory . Although the process  is depicted as a contiguous block, it is understood that it may, in fact, be distributed in pieces throughout the memory .","The process  includes an object  having a public interface . The point at which the CPU  is currently executing instructions of the program within the process  is depicted as a thread . The process  may have multiple threads of execution running simultaneously or nearly simultaneously, with the CPU  executing each thread for a period of time before moving to another thread. The process  also includes: a stack  for holding the data of the thread , a proxy  for representing the interface  of the object , a proxy  for representing the interface  of the object , and a proxy  for representing the interface  of the object . Each proxy has a respective public interface ,  and . The object  may be implemented as a COM object, while the objects  and  may be implemented as DCOM objects. As is conventional, a proxy contains a pointer, an address or other reference that can be used to locate the object represented by the proxy. Although not shown, the memories  and  may also have stubs, for allowing remote clients to call functions of the objects  and . For example, if implemented in DCOM, the proxy  may contain a reference to a stub in the memory , which itself may contain a pointer to the interface .","The register memory  and the stack  contain data that allows the CPU  to execute code along the thread . Specifically, the register memory  contains the state data for the thread , including a pointer  for holding the address of the next line of code to be executed by the CPU , and a pointer  to the stack . The state information includes the contents of other registers as well. For example, when implemented using INTEL architecture the thread state information may include the contents of the general purpose registers and the contents of the flag registers. The stack  contains pointers that allow the thread  to access the objects ,  and , including a pointer to the public interface , and pointers to the proxy interfaces ,  and  which represent the interfaces ,  and  respectively.","Referring to , an overview of how an in-thread debugger may operate in accordance with the teachings of the invention will now be described using the thread  of  as an example. The execution of the thread  is first halted, such as by a \u201cbreak\u201d command inserted into the program code or as a result of an error. The current state of the thread  is copied from the register memory  to the thread stack . An in-thread debugger module  is executed within the thread . The in-thread debugger module  has a communication link , such as a TCP\/IP socket, that allows outside entities to communicate with the in-thread debugger module . A console module  executes outside of the process  and interacts with a user. Although the console module  is depicted as being executed on the same computer as the debuggee thread , it may also be executed on a separate computer that is linked for communication with the computer .","The user may enter commands into the console module . The console module  sends the commands to the in-thread debugger, which converts the commands into corresponding function calls, and sends the function calls to one or more of the objects ,  and . When the in-thread debugger module  receives responses back from the accessed objects, it relays those responses to the console module . The in-thread debugger module  is able to access the objects ,  and  by virtue of the fact that it operates within the context of the thread  and thus can safely call interface pointers that are normally used in this thread. This allows that the user to make functions calls normally to one or more of the objects from within the context of the thread . Since the objects are called from the context of a thread of the program, the objects should behave as if they were being called during normal execution of the program. Once the user is ready to resume execution of the thread , the thread state information is restored to the register  by copying it from the stack .","It is understood that there are other ways to initiate the in thread debugger. For example, the in-thread debugger  may be inserted into the process space of a running program and given the thread context of the running program, provided that the user has the proper access permissions. Referring to the flowchart of , and the diagrams of , an example of how the in-thread debugger may be executed within a thread's context according to the teachings of the invention will be described, using the environment of  and the thread  of  as a starting point.","Turning to , the thread  () is halted due to a previously defined breakpoint or due to an error at step . At step , a conventional debugger  allocates a block  of memory inside the process . In the WINDOWS 2000 operating system environment, this may be accomplished through the use of the \u201cVirtualAllocEx\u201d Application Programming Interface (API). At step , the conventional debugger  creates a loader module  for loading an in-thread debugger into the process . In creating the loader module  the conventional debugger  reads the current value of the instruction pointer  and writes the value into the loader module . The loader module  may also include: the file name of an in-thread debugger module, the name of the in-thread debugger entry point, the name and port of the machine with which the in-thread debugger will communicate during the debugging session, and the code for loading the in-thread debugger.","At step  the conventional debugger copies the loader module  into the memory block . At step , the conventional debugger  stores a new value for the instruction pointer  into the register memory . This new value will be the address of the beginning of the memory block . The execution of the thread  is then resumed at this new address (block ). The loader module  (copied from the conventional debugger ) then executes in the context of the thread . At step , the loader module  saves the current state of the thread . When implemented using INTEL architecture, this may be accomplished by, for example, pushing the contents of the general-purpose registers and the flag registers of the register memory  onto the stack .","At step , the loader module  writes the old value of the instruction pointer  (inserted into the loader module  at step ) into the stack , thus creating a call-frame that will behave as if called from the program at the location at which the thread  was halted. At step , the loader module  loads the in-thread debugger into the process  and calls its entry function (). At step , the in-thread debugger module  () creates a socket  to the machine specified in the loader module , and waits for commands to arrive from the console module .","If the in-thread debugger module  receives a \u201cgo\u201d command, then the flow proceeds to step , in which the in-thread debugger module  closes the socket , cleans up the resources used, and exits. The execution then continues in the loader module  at step , which restores the state of the thread  by, for example, reading it back from the stack  and into the register memory . If the in-thread debugger module  receives a command requiring interaction with an object, then the flow proceeds to step , at which the in-thread debugger module  converts the command into a call to a public interface of the object. The in-thread debugger module  then makes the function call at step . The function call may be performed by one or more extension modules  that get loaded by the in-thread debugger module  as needed. The extension modules will be discussed below. When the response is received from the object, the in-thread debugger module  relays it to the console module . The in-thread debugger module then returns to a wait state at step .","There are many variations possible to the above-described steps. For example, when implementing in a WINDOWS 2000 environment, the in-thread debugger module  may be inserted into the context of the thread  using the SetThreadContext API at step  (). It is also possible to insert the in-thread debugger module  without the aid of a conventional debugger. The in-thread debugger module  may be invoked in a variety of ways, such as by the thread  itself at a predefined break or on error. Additionally, the in-thread debugger may take the place of the conventional debugger initially. In such a case, the in-thread debugger module may be designed to recognize a special command for invoking a conventional debugger. For example, if the user types in \u201cbreak\u201d at the console module  (), the in-thread debugger module  could respond by issuing a debug breakpoint, and loading a conventional debugger into the process  (this may be implemented as a \u201cDebugBreako( )\u201d in the MICROSOFT WINDOWS 2000 environment). When the user exits the conventional debugger, the in-thread debugger module  may then resume.","According to an embodiment of the invention, the in-thread debugger may use one or more debug extension modules , as shown in . Each debug extension module implements a set of simple functions for converting commands into one or more function calls. Each debug extension module may be shipped along with a corresponding object library. For example, a set of debug extension modules may be provided along with the WINDOWS 2000 operating system or the development kit to investigate the basic COM interfaces like IStream, and IStorage. The debug extension modules can also be generated automatically from IDL files or from the object declarations. The Type-Library information (TLB files) or the symbolic information (PDB files) can also be used to convert commands into interface calls.","Referring to , an example an embodiment of a user interface, generally labeled , for the console module  of FIGS.  and - is shown. When the debugger is in a wait state, it sends a prompt string , which is displayed in the interface . The user then may enter a commands, which are sent as a string to the debugger . The debugger  then searches the loaded extension modules  to locate the function in which the command is defined. The debugger  then executes the function, which handles this command.","An example of how a user may use the in-thread debugger to read data from a public interface of a COM or DCOM object will now be described. The commands shown are only meant to be illustrative. It is assumed that a debuggee thread has been halted, that an in-thread debugger has already been inserted into the debuggee thread, and that the user is on a computer that is executing a command console module linked for communication with the in-thread debugger, as depicted, for example, in . Referring to , on line  the user tells the debugger to load the extension which supports the IStream and IStorage interfaces by entering the command \u201c!load stgext.dll.\u201d On line  the user enters the text \u201cIUnkown 78f0ba QueryInterface IID_IStream\u201d\u2014which means \u201cquery the IUnkown interface and return a pointer to the IStream interface.\u201d Here it is assumed that the user has obtained a pointer  to the object (by, for example, reading it from the current thread stack), and that the value of the pointer is hex 78f0ba. The user receives the response \u201cinterface IID_IStream of the object 78f0ba is 78f0b.\u201d On line , the user then uses the newly obtained pointer 78f0ba to find out the contents of a block of data in the object by entering \u201cIStream 78f0b0 db  \u201d\u2014which means \u201cinitialize IStream pointer with value of hex 78f0b0, call IStream::Seek to the position 0\u00d7300, call IStream::Read for 0\u00d7200 bytes, and print out the data in byte format.\u201d","According to an embodiment of the invention, a single command console module may be used to debug multiple threads through the use of a multiplexor module. To illustrate, reference is made to , in which a computer  is communicatively linked to a computer  via a network link . Processes ,  and  are defined on computers ,  and  respectively. The processes ,  and  include in-thread debugger modules ,  and . Each in-thread debugger module may operate within a thread of execution of a program in its process, similar to the in-thread debugger module  of FIGS.  and -. The in-thread debugger modules have sockets ,  and , which may be created by the in-thread debugger modules as previously described. The computer  is itself communicatively linked to computers ,  and  by a network link . A console module  executes on the computer  to receive commands from a user and transmit them to the in-thread debuggers in a manner similar to that of the console module  of , except that, as will be described in more detail, the console module  allows a user to select a process with which to communicate. A multiplexor module  executes on the computer  to route commands and responses between the processes ,  and  and the console module . The multiplexor module  may, using standard networking protocols, communicate with the console module , and with the processes ,  and  via the sockets ,  and . Communication between the multiplexor module  and a socket will hereinafter be referred to as a \u201csession.\u201d A session is a well-known abstraction used to logically describe communication with a socket.","In the embodiment of , the console module  and the multiplexor module  allow a user to select a process out of the processes ,  and , enter a command, and have the command converted into a function call to an object in that process. The user need not be aware of the location of the machines on which the objects and processes are stored or executing. The console module  opens up one user interface for process , one for the process  and one for the process . Each interface is associated with one of the sockets, and communicates with the associated socket in a session. The user may enter a command into the user interface corresponding to the process having the thread to which he or she wishes to have the command sent. The console module  sends the command to the multiplexor module . Based on the logical mapping between the interface at which the command is entered and the socket sessions, the multiplexor module  sends the command to the appropriate process via the appropriate socket. Although the processes ,  and  are depicted as executing on separate computers, the multiplexor module  can also route commands and responses to and from multiple processes executing on the same computer. If one or more conventional debugging session is required, the conventional debugging commands may be directed to the multiplexor  by, for example, a conventional debugger console  (shown as a dashed line), which may be located on a separate computer.","Mission-critical systems that cannot afford to be shut down for debugging may benefit from an in-thread debugger that operates in accordance with the teachings of the present invention. An example of such a system and how it can be maintained in accordance with an embodiment of the invention will now be described. Referring to , a commercial web server  facilitates electronic commerce purchases for a large number of consumers at any given time via a public network , which may be the Internet. A module  of MICROSOFT INTERNET INFORMATION SERVER (IIS) executes on the web server  and cooperates with a MICROSOFT ACTIVE SERVER PAGE (ASP) module  to receive and fulfill purchase requests from consumers. As is conventional, the ASP module  includes several COM objects . The ASP module  communicates with a consumer  via the consumer's browser . If the ASP module  begins experiencing errors, a technician  at the server  contacts a consultant  at a remote service center. The consultant  instructs the technician  to give the consultant  the necessary permission to access the web server  and to make modifications. The consultant  may then execute an instance of a console module  on a computer  and remotely access the web server  via the public network . The consultant  may then execute a thread  of the ASP module . The thread  may run concurrently with many other threads  that are currently fulfilling consumers purchase requests. Running a separate thread for diagnostic purposes allows the consultant  to service the ASP module  without having to shut it down or otherwise slow down the purchase requests. The consultant  may then inject an in-thread debugger  into the thread , communicate with the in-thread debugger  via a socket , make function calls to the various COM objects , receive results, and thereby diagnose the problem. During the debugging process, the consultant  may even access an object  running on the consumer's browser , via a proxy .","It can thus be seen that a new and useful method and system for debugging program has been described. In view of the many possible embodiments to which the principals of this invention may be applied, it should be recognized that the embodiments described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of the invention. It should also be recognized that the various steps involved in carrying out the methods described above as well as the specific implementation of each step described above may be changed in ways that will be apparent to those of skill in the art.","Finally, those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa, and that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
