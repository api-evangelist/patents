---
title: Synchronization mechanisms based on counters
abstract: A method and apparatus which maintain a plurality of counters to synchronize a plurality of requests for a lock independent of interlocks. The plurality of counters include a lock counter and an unlock counter. The requests wait in a wait queue maintained separately from the counters without direct access between the counters and the wait queue. The lock counter indicates a cumulative number of lock requests to acquire the lock. The unlock counter indicates a cumulative number of unlock requests to release the lock acquired. One or more requests waiting for the lock are selected according to the counters to be granted with the lock when the lock is released. A request corresponds to a task performing synchronized operations when granted with the lock.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08392925&OS=08392925&RS=08392925
owner: Apple Inc.
number: 08392925
owner_city: Cupertino
owner_country: US
publication_date: 20090326
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND","SUMMARY OF THE DESCRIPTION","DETAILED DESCRIPTION"],"p":["The present invention relates generally to synchronization mechanisms. More particularly, this invention relates to using counters to support synchronizers without the use of interlocks.","Modern operating systems for computing devices typically support parallel programming to enable concurrent execution of a plurality of applications running different tasks to increase device throughput or speed up interface responses. Usually, concurrent execution require synchronization to coordinate asynchronous activities among different tasks. Most operating systems provide synchronization primitives to facilitate synchronization for programming concurrent tasks. However, depending on how such primitives are implemented, the overhead incurred to allow multiple tasks to execute in parallel may differ from one operating system to another.","For example, multiple threads or processes may be synchronized via synchronization primitive (or synchronizer) such as mutex (a thread may be the minimum scheduling entity of a process for an application). Typical implementation for a mutex may include an interlock in user-space memory that may require continuously polling the contents of the memory by each thread or process trying to participate in the use of the mutex (via a primitive, lock, unlock, try, etc.). As a result, valuable processing resources are wasted when a thread or process interacts with that mutex.","Additionally, an interlock based synchronization primitive may degrade responsiveness of real-time threads or processes. For example, a preemptive task scheduler, as commonly adopted in most operating systems, may force a thread or a process associated with an interlock to be removed from a processor with a preemptive event. An interlock implemented in user-space memory may be associated with the thread or process without kernel interactions. As a result, the scheduler does no know that the interlock is held by the particular thread or process when it is preempted. A subsequent real-time thread or process that attempts to interact with the same interlock may have to (e.g. at least temporarily) relinquish its real-time characteristics in order to allow the thread or process that was preempted to release the interlock. It must do so without the scheduler knowing which thread or process needs to be scheduled to release the contended interlock. This is known as an unbounded priority inversion\u2014something that must be avoided in real-time systems.","A typical solution is to move the complete implementation of the synchronizer into the kernel, so the scheduler always knows which thread or process holds the interlock and can prevent preemption for the duration. Although such a solution does not introduce unbounded priority inversions, it adds latency to each synchronization operation in order to make the transition to the appropriate kernel interface.","Therefore, traditional implementations of synchronization primitives for computing devices fail to support real-time characteristics of modern multitasking applications without incurring a latency penalty.","An embodiment of the present invention includes a method and apparatus to maintain a plurality of counters including a lock counter and an unlock counter to synchronize a plurality of requests for a lock. The lock counter indicates a cumulative number of lock requests to acquire the lock. The unlock counter indicates a cumulative number of unlock requests to release the lock acquired. One or more requests waiting for the lock are selected for granting the lock according to the counters when the lock is released. A request corresponds to a task performing synchronized operations when granted with the lock.","In an alternative embodiment, one or more counters are maintained to synchronize a plurality of requests for a lock. The counters have a state including count values of the counters at an instance of time. A first kernel interface is called with argument data according to a first state of the counters to wait for the lock. A second state of the counters is returned from the first kernel interface as part of return data. Synchronized operations are performed subsequent to updating the counters atomically based on the second state.","In another alternative embodiment, one or more counters are maintained to synchronize a plurality of lock requests. Each lock request is associated with a lock count indicating a cumulative number of the lock requests initiated for a lock when the lock request is received in a wait queue. In response to receiving an unlock request to release the lock, a state of the counters is compared with the unlock request to determine whether to expect additional lock requests. If no additional lock request is expected, one or more lock requests are selected from the wait queue to grant the lock to performing synchronized operations.","In yet another alternative embodiment, a lock counter is counted up atomically to wait for a lock to synchronize operations among a plurality of tasks. Synchronized operations are performed for at least one of the plurality of tasks when the lock is granted. The unlock counter is count up atomically subsequent to the synchronized operations.","Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.","A method and an apparatus for a counter based synchronization mechanism are described. In the following description, numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent, however, to one skilled in the art, that embodiments of the present invention may be practiced without these specific details. In other instances, well-known components, structures, and techniques have not been shown in detail in order not to obscure the understanding of this description.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification do not necessarily all refer to the same embodiment.","The processes depicted in the figures that follow, are performed by processing logic that comprises hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general-purpose computer system or a dedicated machine), or a combination of both. Although the processes are described below in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in different order. Moreover, some operations may be performed in parallel rather than sequentially.","The term \u201chost\u201d and the term \u201cdevice\u201d are intended to refer generally to data processing systems rather than specifically to a particular form factor for the host versus a form factor for the device.","According to certain embodiments, synchronization mechanisms are provided using a plurality of operational sequence counters for POSIX (Portable Operating System Interface) based synchronizers (e.g. at user level) without using user level global data or per synchronizer (or synchronization primitive) interlock. Counters may be updated based on atomic instructions. When contending tasks (or threads, processes) block, kernel calls may be made carrying sequence counts of the counters as part of argument data for the calls. The kernel may not need to access or modify a lock associated with the counters to support a synchronization primitive. Thus, lock content may remain at user level (or in user space) in an operating environment.","In one embodiment, the kernel provides different policies to assign ownership of a lock to waiting tasks based on sequence counts from argument data of an interface call to support a variety of synchronization primitives, such as mutex, event, critical section, barrier, semaphore, conditional variables, readers\/writer lock, etc. For example, a lock may be assigned in a strict fair share manner, e.g. following a sequence of lock attempts or requests. In other embodiments, CPU priority may be used as a hint to decide how a lock should be granted. Priority ceiling and\/or inheritance based on identifiers of owners (tasks) of a lock may be applied for lock assignment. The term \u201clock\u201d may refer to generic synchronization primitives or synchronizers including barriers, semaphore, condition variables and other primitives.","A lock bit or a bit flag may be used to avoid inadvertent releasing (or freeing) of a lock. In one embodiment, a lock bit enables a first fit policy to assign ownership to a lock. For example, when an unlock request arrives to release a lock, a lock bit may be reset to allow any task contending at the time to grab the ownership of the lock. Therefore, a contending thread already running on a core requiring only a very short time period for performing synchronized operations may be allowed the ownership of the lock without blocking. As a result, synchronization overhead, such as acquiring and dropping a lock, may be reduced. In some embodiments, synchronization primitives shared across address spaces, such as POSIX pshared mode, are supported based on sequence counters.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 1","b":["100","101","101","1","111","2","113","1","143","139","101","145"]},"In one embodiment, operating environment  provides a synchronization mechanism via a synchronization library  linked with different tasks. Synchronization library  may be accessed at a user level supporting standard synchronization APIs, e.g. based on POSIX standard. Synchronization library  may include APIs outside of POSIX standard. In one embodiment, a synchronization library  includes an atomic operation module  to update counters for a lock. An atomic operation may be a set of operations that can be combined together appeared as one single operation with only two possible outcomes as either a success or a failure. For example, the atomic operation module  may implement an atomic operation using CAS (Compare And Swap) instructions provided by a processor. Other instructions which can be used to implement lock-free or wait-free algorithms for atomic operations may be included.","In one embodiment, a synchronization library  includes a user lock handler module  and a user unlock handler module  to manage synchronization requests from tasks. Typically, synchronizing a group of tasks may be coordinated based on a data structure or a synchronization identifier such as a lock. For example, a task (e.g. task_ , task_  or task_m ) makes a request for a lock (a lock request) to perform synchronized operations via the user lock handler module . Once a task completes the synchronized operations, it releases the lock (or sending an unlock request) for other waiting tasks (e.g. task_w_ , task_w_ , or task_w_k ) via the user unlock handler module .","A lock may be associated with synchronization counters  representing a state of the lock synchronizing a group of tasks. In one embodiment, synchronization counters  include one or more counters, e.g. counter_  and counter_n , having counts as integer sequence values. Synchronization counters  may include status flags  as a set of bits (or status bits) indicating binary statuses. In response to synchronization requests from tasks, the synchronization library  may create the synchronization counters  together with a corresponding lock. The synchronization counters  may be updated atomically via the atomic operation module . In one embodiment, the synchronization library  maintains the synchronization counters  and communicates with a kernel  including passing lock and\/or unlock requests with snapshots of counters  back and forth to coordinate granting and releasing of the corresponding lock. A snapshot of a state may include the counts of the synchronization counters  retrieved at a particular instance of time.","In one embodiment, a task waits for a lock in a wait queue  associated with the lock within a kernel . The wait queue  may store lock requests for the corresponding tasks, e.g. task_w_ , task_w_  or task_w_, waiting for the lock. In one embodiment, the wait queue  includes pre-post counters for indicating, for example, whether there are additional lock requests expected to be inserted into the wait queue . In one embodiment, a kernel lock handler module  and a kernel unlock handler module  process a lock request and an unlock request respectively according to interface calls invoked from the synchronization library . A pre-post handler module  may maintain, e.g. atomically, the pre-post counters  according to counter states passed along with the lock or unlock requests from the synchronization library .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2","FIG. 1"],"b":["103","200","201","32","203","205","203","205","207","203","209","201","203","209"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["300","300","100","301","300","103"]},"An atomic operation may be a CAS operation. In one embodiment, the processing logic of process  atomically counts up by one a lock counter from its current count when a request for a lock is initiated. A current count of a counter may be based on a snapshot (or retrieval) of synchronization counters at an instance of time. In one embodiment, a CAS operation to count up a counter from a current count succeeds only when the counter has not been changed from the current count (or blocked from counting with the current count) at the time the counter is updated with a count up number. The processing logic of process  may continuously taking snapshots of the synchronization counters and performing atomic operations to update synchronization counters (e.g. counting up a lock counter) until the atomic operation is successfully applied.","In one embodiment, at block , the processing logic of process  schedules lock requests in a wait queue, such as wait queue  of . Each lock request may be assigned a sequence number according to, for example, a lock count counted up for initiating the lock request. Thus, sequence numbers associated with lock requests for a lock may be monotonically and consecutively ordered. A lock request may be associated with the sequence number of the lock counter when the lock request arrives. Each lock request may be assigned a unique sequence number among all requests for a single lock. In some embodiments, if a lock request is not contended (e.g. the only one requesting the lock) and the lock is available (not yet granted), the lock request acquires the lock and returns after updating the counters and status bits without accessing kernel resources (e.g. waiting in the wait queue).","At block , according to one embodiment, the processing logic of process  selects one or more lock requests waiting in the wait queue to grant the lock. A lock may be exclusively granted to at most one single lock request at a given time. The processing logic of process  may select a lock request to grant a lock according to an unlock request releasing the lock, e.g. when a corresponding task to the unlock request completes synchronized operations after being granted with the lock. In one embodiment, a lock request is selected from a wait queue as ordered according to the unique sequence number associated with the lock request. In some embodiments, more than one lock requests may be granted with the lock at the same time. For example, multiple readers are allowed to access a common file together.","The processing logic of process  may update the counters at block  to indicate a status of the lock granted. In one embodiment, for example, the processing logic of process set an exclusive flag in the counters, such as in status flags  of , when a lock is granted to a lock request requesting exclusive ownership of the lock. A task to perform synchronized operations as a writer writing to a file may request a lock granted exclusively. In another embodiment, the processing logic of process  may set a wait flag in the counters to indicate there is at least one request for the lock as a writer remaining in the wait queue.","At block , the processing logic of process  may proceed to perform synchronized operations for tasks corresponding to the selected lock requests granted with the lock. Subsequently, at block , when completing the synchronized operations, the processing logic of process  may update the counters atomically to indicate completion of synchronized operations for the selected requests. For example, the processing logic of process  my count up an unlock counter, such as counter U of , indicating a cumulative number of tasks completing the operations synchronized by the lock. The processing logic of process  may update the counters to reset an exclusive flag to indicate a lock is no longer exclusively owned. At block , the lock may be released for the remaining lock requests still waiting in the wait queue. In one embodiment, the processing logic of process  determines the lock is no longer needed based on current counts of the counters.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4","FIG. 1","FIG. 2"],"b":["400","400","100","401","400","203","207","209","205","400"]},"The counters may be updated atomically, such as based on CAS operations. Each atomic operation may update all the counters together or selectively update a portion of the counters. In one embodiment, the processing logic of process  takes a snapshot of the counters to determine an updated state for the counters. A snapshot of the counters may correspond to a state of the counters retrieved at an instance of time. A state of the counters may include counts and status values of the counters. In one embodiment, the processing logic of process  updates the lock counter and the wait counter to indicate a new request for the lock. When an atomic operation to update the counters fails, the processing logic of process  may repeat the atomic operation until the counters are successfully updated.","In one embodiment, at block , the processing logic of process  calls a first kernel interface to wait for the lock. The first kernel interface may be based on a function call provided by a kernel which has access to privileged data and structures allocated for the lock. In one embodiment, the processing logic of process  passes argument data for requesting the lock via the first kernel interface. The argument data may include a state of the counters, such as an updated state for counting up the lock counter and the waiter counter based on a snapshot of the counters. Typically, the argument data may include a lock identifier along with a lock count, an unlock count, a waiter count and status bits. Once the lock is granted, the processing logic of process  may return from the first interface kernel with a return data indicating a return state of the counters. In one embodiment, the return state of the counters may be based on a state of the counters at the time when the lock is granted. In addition, the return state may include status flags updated to reflect status information related to the lock granted, for example, whether the lock is exclusively granted and\/or whether there are writers (i.e. lock requests for the lock as writers) waiting for the lock.","At block , according to one embodiment, the processing logic of process  updates the counters to release the lock. For example, the processing logic of process  may count up a current count retrieved from the unlock counter. The unlock counter may indicate a cumulative number of requests having released the lock. In some embodiments, at block , the processing logic of process  calls a second kernel interface with an updated state of the counters (e.g. the up counted count of the lock counter) for granting the lock to the waiting requests. The processing logic of process  may not block to return from the second kernel interface with a return state of the counters specified by the kernel, which may reflect a more recent state of the counters than the updated state. In one embodiment, at block , the processing logic of process  may determine to update the counters according to a current state and the return state of the counters. For example, the processing logic of process  may reset the counters to start counting up from preset initial values (e.g. 0).",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 5","FIG. 1","FIG. 1"],"b":["500","500","127","100","501","500","1","111","115","1","143","139","500"]},"When receiving a lock request at block , the processing logic of process  may update the counters. For example, if the lock request received is an additional lock request expected, the processing logic of process  may count down (e.g. atomically) the wait counter (e.g. a pre-post wait counter inside a kernel). In some embodiments, the processing logic of process  may count down the wait counter based on kernel data protection mechanism associated with, e.g., mutex lock or spin lock. A lock request may be associated with a lock count, e.g. embedded inside an argument data of an interface call, indicating a cumulative number of lock requests already initiated. In one embodiment, the processing logic of the process  compares the lock count of the lock request received with the counters, e.g. the target sequence counter, to determine if the lock request received is an additional lock request expected.","At block , the processing logic of process  may insert the lock request into a wait queue to wait for the lock. A lock request may be assigned with a sequence number corresponding to a lock count associated with the lock request. In one embodiment, the processing logic of process  maintains a consecutive sequence order among lock requests waiting in a wait queue according to the corresponding sequence numbers. Additional lock requests expected may be identified if there are missing gaps in the consecutive sequence of the sequence numbers in a wait queue (e.g. sequence number  may be missing from a sequence of numbers , , ).","In one embodiment, at block , the processing logic of process  determines whether there are additional lock requests to expect in response to an unlock request to release the lock. Typically, an unlock request corresponds to a lock request previously granted with the lock. When a task finishes performing synchronized operations according to a lock granted, a corresponding unlock request may be generated to release the lock. An unlock request may be associated with an unlock count (or a sequence number), e.g. embedded inside an argument data of an interface call, indicating a cumulative number of unlock requests already generated to release the lock. In one embodiment, an unlock request is also associated with a lock count. The processing logic of process  may inspect the wait queue according to the lock and unlock counts associated with the unlock request to determine if there are additional lock requests to expect.","If there are additional lock requests to expect, at block , the processing logic of process  may update the counters to wait for the additional lock requests expected. The counters may be updated to specify sequence numbers to identify the additional lock requests expected. Otherwise, at block , the processing logic of process  may select one or more lock requests from the wait queue to grant the lock. In one embodiment, the selected lock requests may be associated of sequence numbers consecutive in order in the wait queue.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 6","FIG. 1","FIG. 2"],"b":["600","600","100","601","600","203","600"]},"At block , in one embodiment, the processing logic of process  performs operations (e.g. synchronized operations) simultaneously for one or more tasks granted with the lock. Once the synchronized operations for a task are completed, the processing logic of process  may count up atomically an unlock counter. In one embodiment, at block , the processing logic of process  counts up an unlock counter from a current unlock count of the unlock counter by one. If the atomic up counting of the unlock counter is successful, at block , the processing logic of process  may compare the lock and unlock counters to determine if there is any remaining task waiting to be synchronized by the lock. The processing logic of process  may reset the lock and unlock counters at block  if no more tasks are waiting to be synchronized by the lock according to the comparison (e.g. counts from the lock and unlock counters are equal).","Exemplary Process to Synchronize a Reader",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 7","FIG. 1","FIG. 1","FIG. 2"],"b":["700","700","100","1","111","701","700","1","1","1","203","207","209","205"]},"Based on the state retrieved from the counter, at block , the processing logic of process  may determine updated values L and WC to count up counts L and WC by one for the lock and waiter counters. Updated counts of L and WC may indicate a newly arrived lock request. At block , the processing logic of process  may detect whether the lock is currently granted exclusively or if there is any lock request waiting for the lock as a writer. Typically, a thread or a process performing synchronization operations as a writer may require a lock granted exclusively, such as when writing to a common file accessed by multiple threads. In one embodiment, the bit set retrieved from the status flags include a w bit and an e bit indicating, when set as 1, respectively that the lock is exclusively granted and there is a lock request waiting as writer for the lock.","If both w and e bits are not set, at block , the processing logic of process  may perform an atomic operation CAS(L(w=0)(e=0), L) to update the lock counter from count L to count L conditioned on both w and e bits are not set. In one embodiment, atomic operation CAS(L(w=0)(e=0), L) cannot succeed if the specified conditions, e.g. the lock counter has a count as L and both w and e bits are not set, are not met at the time the atomic operation is applied. Usually, atomic operations such as CAS may be supported by underlying hardware, e.g. based on specific executable instructions for a processor. When the lock counter is successfully counted up, at block , the processing logic of process  may proceed to perform the corresponding synchronized operations with the lock granted as a reader at block . Otherwise, the processing logic of process may retrieve another state of the counters again repeating at block .","At block , if either the w bit or the e bit is set, indicating the lock is cannot be granted without waiting, the processing logic of process  may perform an atomic operation CAS(LWC, LWC) to update the lock counter and waiter counter from count L to count L and count WC to count WC respectively together to indicate an addition of a lock request waiting for the lock. Success of the atomic operation CAS(L,WC, LWC) may be conditioned on both the lock counter and the wait counter having not been updated (e.g. by other threads or processes) from count L and count WC at the time of the atomic operation. If the atomic operation is not successful at block , the processing logic of process  may return back to retrieving another state of the counters repeating at block .","Otherwise, if the atomic operation is successful, the processing logic of process  may proceed to wait for the lock at block . In one embodiment, the processing logic of process  calls a kernel interface, e.g. a programming interface function, to a kernel routine, e.g. stored in kernel  of , to block and wait for the lock. A kernel interface call may be associated with argument data including, for example, a lock identifier and\/or a state of the counters, such as the up counted counts of the lock counter and\/or the waiter counter. In some embodiments, the processing logic of process  may wake up (or return) from the kernel interface call by external interrupts (e.g. signaling a timer clock timing out). The processing logic of process  may continue waiting for the lock calling back the kernel interface if detecting a lock is not yet granted when returning from the kernel interface call (e.g. according to flag settings).","At block , in one embodiment, the processing logic of process  is granted with a lock returning from the kernel interface call with the return data including a bit set w and e for status bits w and e bits, and a lock count L for the lock counter. The processing logic of process  may proceed to retrieve a current state of the counters, for example, L for the lock counter, at block . Proceeding at block , in one embodiment, the processing logic of process  performs atomic operations to update the waiter counter and\/or status flags. The processing logic of process  may count down (e.g. by one) the waiter counter based on CAS operation conditioned on the waiter count retrieved at the time together with L for the lock counter. In one embodiment, the processing logic of process  updates status flags with a bit set, e.g. (we), for w and e bits according to the return data from the kernel interface call when waiting for the lock.","At block , the processing logic of process  may identify whether the return data from a kernel interface indicates a latest snapshot of the counters should be passed back to the kernel for releasing the lock (or unlocking) to additional waiting requests. For example, if lock count L (for the lock counter via the return data from a kernel interface call waiting for the lock) equals lock count L (for the lock counter retrieved from the counters after returning from the kernel interface call), there may not be additional waiting requests for the lock and the processing logic of process  may proceed to perform the synchronized operation at block . If the return data indicates the kernel should handle unlocking for additional waiting requests at block , the processing logic of process  may call a kernel interface with argument data including the latest available state (snapshot) of the counters, e.g. L for the lock counter, to handle unlocking additional waiting requests. The processing logic of process  may not block at the call to handle unlocking requests at block . The processing logic of process  may continue to release the lock at block  after completing the synchronized operation.","Exemplary Process to Synchronize a Writer",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 8","FIG. 1","FIG. 7"],"b":["800","800","100","800","1","1","1","801","701"]},"Based on the state retrieved from the counter, at block , the processing logic of process  may determine updated counts L and WC to count up counts L and WC by one for the lock and waiter counters. If there is no request currently waiting for the lock, e.g. according to whether lock count L equals to 0 at block  and\/or status bits w and e are both 0, the processing logic of process may mark the counters indicating the lock is now exclusively owned at block . In one embodiment, the processing logic of process  performs an atomic operation CAS(0,1(e=1)) to update the lock counter from 0 to 1 and set an e bit (exclusive bit) of the status flags of the counters. If the atomic operation is not successful at block  (e.g. the lock count has been counted up from 0 by new lock requests), the processing logic of process  may repeat taking another snapshot of the counters back to block . Otherwise, the processing logic of process  may proceed to perform the corresponding synchronized operations exclusively at block .","If there are already lock requests requesting for the lock at block , the processing logic of process  may update the counters atomically to register for the lock. For example, the processing logic of process  may perform an atomic operation CAS(LWC,LWC(w=1)) to update the lock counter and the waiter counter from L to L, WC to WC and set the w bit of the status flag (e.g. indicating a lock request waiting for the lock as a writer) at block . If the counters are updated successfully by the atomic operation, at block , the processing logic of process  may proceed to wait for the lock at block . In one embodiment, the processing logic of process  calls a kernel interface to block and wait for the lock with an argument data including, for example, a lock identifier and\/or the latest available state of the counters, such as L for the lock counter, U for the unlock counter, WC for the waiter counter and bit set ((w=1)e) for the status bits w and e of the status flags.","When an exclusive lock is granted, at block , the processing logic of process  may wake up (or return) from the kernel interface call with the return data including a bit set w and e for status bits w and e, and a lock count L for the lock counter. The processing logic of process  may proceed at block  to retrieve a current state of the counters, for example, L for the lock counter and bit set (we) for status bits w and e of the status flags. Subsequently at block , the processing logic of process  may determine updated status flags including bit set (we) for w and e status bits according to a state transition table. In one embodiment, a state transition table may be predetermined to generate a set of status bits from two sets of corresponding sets of status bits. For example, set bit set (we) may be generated from bit set (we) from the return data and bit set (we) currently retrieved from the counters according to the state transition table.","The processing logic of process  may proceed, at block , to update the counters, for example, to count down the wait counter atomically and\/or set (we) for status bits w and e of the status flags. Subsequently, the processing logic of process  may perform the synchronized operations with an exclusive lock at block . In some embodiments, if the atomic operation to update the counters fails at block , e.g. the unlock counter and\/or the status flags have been changed, the processing logic of process  may return back to wait for the lock at block . The processing logic of process  may continue to release the lock at block  after completing the synchronized operation.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 9","FIG. 1"],"b":["900","900","100","901","900","1","1","1"]},"At block , the processing logic of process  may determine an update count U=U+1 to count up the unlock counter by one to indicate the arrival of an unlock request to release a lock after completing corresponding synchronized operations. The processing logic of process  may determine whether the present unlock request is the last one for the lock, for example, according to whether L equals U indicating there is no request waiting for the lock at block .","If the present unlock request is the last one, at block , the processing logic of process  may reset the counters. In one embodiment, the processing logic of process  resets the unlock counter from U to  according to an atomic operation CAS(U, ) at block . If resetting of the unlock request fails (e.g. the unlock count U has been changed), the processing logic of process  may abort resetting the counters to retrieve the state of the counters again returning back to block . Otherwise, if resetting the unlock counter is successful at block , the processing logic of process  may proceed to reset the lock counter at block , for example, according to an atomic operation CAS(L, ) to update the lock counter from L to . If the atomic operation is successful at block , the processing logic of process  may retrieve the current state of the counters again returning back to block .","Otherwise, if resetting the lock counter fails, at block , the processing logic of process  may undo the resetting of the unlock counter. For example, in one embodiment, the processing logic of process  retrieves count U from the unlock counter at block . Subsequently at block , the processing logic of process  may undo the resetting of the unlock counter by updating the unlock counter from U to (U+U) according to atomic operation CAS(U,U+U). The processing logic of process  may repeatedly trying to undo the resetting of the unlock counter at blocks  and , if the update of the unlock counter fails at block . Otherwise, if successful, releasing the lock is completed at block .","If there are lock requests waiting for the lock, at block , in one embodiment, the processing logic of process  updates the counters by counting up the unlock counter from U to U atomically according to operation CAS(U,U) at block . If counting up the unlock counter fails, at block , the processing logic of process  may retrieve the current state of the counters again returning back to block . Otherwise, if counting up the unlock counter is successful, in on embodiment, the processing logic of process  determines at block  whether to call a kernel interface for unlock kernel transition, e.g. based on whether wait count WC equals the difference between lock count L and updated unlock count U. If there is no need for kernel unlock transition, the processing logic of process  may complete releasing the lock at block . Otherwise, the processing logic of process  may proceed at kernel unlock transition to release the lock at block .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 10","FIG. 1","FIG. 9"],"b":["1000","1000","100","1001","1000","1","2","1","1001"]},"When returning from the kernel at block , the return data may include a bit set (we) for w and e status bits of the status flags and L for the lock counter. At block , the processing logic of process  may retrieve a current state of the counters including, for example, L and WC for the lock counter and the waiter counter. In some embodiment, the processing logic of process  updates bit set (we) according to a predetermined state transition table based on the current state. If status bit e from the return data indicates an exclusive lock has been granted to a lock request (e.g. e is set with value e=1) at block , the processing logic of process  may update the lock counter from L to L and set the status flags with bit set (we) for the w and e status bits according to an atomic operation CAS(L, L(we)) at block . If the atomic operation fails, at block , the processing logic of process  may retrieve again the current state of the counters back at block . Otherwise, the processing logic of process  may conclude the kernel unlock transition at block .","If the lock is not exclusively granted at block , the processing logic of process  may determine whether there are additional lock requests to consider for sharing the lock at block . In one embodiment, if lock count L from the return data of the kernel interface call and lock count L of the lock counter retrieved are not equal, additional lock requests may share the lock. If there is no additional lock request to consider at block , the processing logic of process  may update the counters at block . Otherwise, the processing logic of process  may call another kernel interface (e.g. a non-blocking call) passing argument data including the latest available state of the counters to consider additional lock requests to share the lock at block . In one embodiment, the argument data includes L, U, and WC for the lock counter, the unlock counter and the waiter counter respectively. The processing logic of process  may generate, according to a predetermined transition table, a bit set for w and e status bits for the argument data based on bit set (we) and a corresponding bit set of the current state of the counters retrieved as in block .","After returning back from the kernel interface call with return data at block , the processing logic of process  may update the counters according to the return data at block  to complete the kernel unlock transition at block . In one embodiment, the return data includes L for the lock counter and bit set (we) for status bit w and e of the status flags. The processing logic of process  may update the counters atomically from the latest state available, e.g. including L for the lock counter, to L and (we) for the lock counter and status bits w and e to release the lock.","Exemplary Kernel Process to Block a Synchronization Request",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 11","FIG. 1","FIG. 7","FIG. 8"],"b":["1100","1100","127","1100","711","813","1101","1100","1100"]},"At block , in one embodiment, the processing logic of process  retrieves a state of pre-post counters, such as counters  of . The state of pre-post counters may include counts PT and PW for a target sequence counter and a wait counter respectively. At block , the processing logic of process  may determine if the lock request is an additional lock request expected. For example, if the state of pre-post counters is non-empty, the processing logic of process  may compare a lock count L passed via the argument data with count PT for the target sequence counter at block. Lock count L may indicate a sequence number associated with the lock request. If lock count L for the lock request is less than or equal to target sequence count PT, the present lock request may be identified as one of additional lock requests expected. The processing logic of process  may count down (e.g. atomically) the pre-post wait counter (e.g. CAS(PW,(PW\u22121)) for an additional lock request expected. The processing logic of process  may retrieve the state of the pre-post counters again back at block  if the atomic operation to count down the pre-post wait counter fails.","If the updated wait counter is cleared with count  at block , indicating all additional lock requests expected have arrived, the processing logic of process  may select waiters or lock requests waiting for the lock in the wait queue to grant the lock at block . Each waiter selected may be waken up and de-queued from the wait queue to perform corresponding synchronized operations. At bock , the processing logic of process  may determine if the present lock request can be granted with the lock. For example, a lock request as a reader may share a lock already granted to other lock requests. If a lock is granted, the processing logic of process  may set up return data at block  to return to a user at block , such as synchronization library  of . In one embodiment, return data may include error indicators identifying occurrences of errors, if there is any, and\/or a lock count for a lock counter according to argument data received. The return data may include a bit set with w bit flag set to 1 to indicate, for example, there are remaining waiters waiting in the wait queue as writers.","If the present lock request is not an additional lock request expected at block  and\/or if there are more additional lock requests expected (e.g. the updated wait counter is not empty) at block , in one embodiment, the processing logic of process  inserts the lock request to the wait queue at block . A sequence number may be assigned to the lock request waiting in the wait queue according to the lock count L. In one embodiment, the processing logic of process  may update a number of characteristic data associated with the wait queue, such as the highest and lowest number of sequence numbers in the wait queue.","Subsequently, at block , the processing logic of process may wait (or block) in the wait queue waiting for the lock. When the lock is granted, the processing logic of process  may wake up from the wait queue at block . In certain embodiments, the processing logic of process  may wake up responding to an error condition such as caused by an external interrupts. The processing logic of process  may return back to wait in the wait queue at block  if an error condition is identified when waking up at block . In one embodiment, the processing logic of process  removes the present lock request from the wait queue and update characteristics data of the wait queue accordingly at block . In one embodiment, a wait queue may be associated with characteristic data include, for example, the highest sequence number, the lowest sequence number, or the number of requests currently waiting in the wait queue. The processing logic of process  may proceed to set up return data at block  to return to user at block .","Exemplary Kernel Process to Grant a Synchronization Request",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 12","FIG. 1","FIG. 10","FIG. 1"],"b":["1200","1200","127","1200","1001","1201","1200","1","1","1","103","1200"]},"At block , the processing logic of process  may compare a last unlock sequence number and count U from the lock request to detect whether the lock request is a spurious request, e.g. a lock request erroneously generated. The last unlock sequence number may be the sequence number of the unlock counter when the most recent or last successful unlock operation is granted. If the last unlock sequence number is greater than count U, the processing logic may ignore the present lock request as a spurious one and return to a user , e.g. synchronization library  of .","Otherwise, if the lock request is not a spurious request, the processing logic of process  may determine if there are additional lock requests to expect at block . In one embodiment, the processing logic of process  identifies from the wait queue waiting lock requests having sequence numbers less than or equal to count L. If all the sequence numbers identified are consecutively less then or equal to L (e.g. L-, L- . . . ), there may be no additional lock requests expected. The processing logic of process  may proceed to select waiters from the wait queue to grant the lock at block . Otherwise, at block , if there are additional lock requests expected, the processing logic of process  may determine PW as the number of additional lock requests expected. In One embodiment, PW is determined according to the difference between the waiter count WC of the lock request and the current number of waiters waiting in the wait queue. The processing logic of process  may update the pre-post counters at block  to assign L and PW respectively to the target sequence counter and the wait counter.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":["FIG. 13","FIG. 1","FIG. 11","FIG. 7"],"b":["1300","1300","127","1300","1113","729","1301","1300","1300","0"]},"At block , in one embodiment, the processing logic of process  determines if a selected waiter associated with the lowest sequence number in the wait queue is requesting the lock as a writer. If the selected lock request (e.g. to grant the lock) is a writer, the processing logic of process  determines if there is any other waiter in the wait queue requesting the lock as a writer at block . The processing logic of process  may setup a return bit set () for status bits w and e at block  if there is any remaining waiting lock request as writer and, otherwise, the return bit set () for status bits w and e at block . In one embodiment, status bit w is set (e.g. of value ) to indicate there is lock request waiting in the wait queue as writer and status bit e is set if the lock is granted exclusively (e.g. to a lock request as writer). At block , the processing logic of process may update the wait queue according to the selected writer. For example, characteristic data such as the lowest sequence number associated with the wait queue may be updated. A thread associated with the selected waiter may be woken up carrying updated status bits back to the user space or user land. The selected waiter may be dequeued from the wait queue.","If a selected waiter associated with the lowest sequence number in the wait queue is not a writer at block , the processing logic of process  may identify the lowest sequence number associated with a writer within the wait queue at block . If the next writer is identified at block , the processing logic of process  may setup a return bit set at block , e.g. setting status bit w as 1 and status bit e as 0 indicating there are waiters remaining in the wait queue requesting the lock as writers. The return bit set may include status bit e as 0 indicating granting a shared lock. Otherwise, if no writer is identified in the wait queue, the processing logic of process  may setup a return bit set at block , e.g. setting status bits w and e to 0. Subsequently, the processing logic of process  may update the wait queue to grant the lock as a shared lock to all waiters with sequence numbers up to (e.g. not including) the next writer (e.g. dequeing all the waiters granted with the shared lock from the wait queue) at block . The processing logic of process  may determine return data, e.g. including the return bit set at block  to return to user . The return data may include the highest sequence number of the wait queue.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":["FIG. 14","FIG. 1"],"b":["1","111","139","117","1401","1421","1407","1421","1401","1409","1403","1409","1401"]},"In one embodiment, from the no lock state , the task may call API wrlock  to request a lock as a writer. If the lock is not available, the task may transition to a blocked state  to wait for the lock (e.g. blocking). If a lock is available for API wrlock, e.g. when the lock is free and no other tasks are currently waiting, the task may transition to the exclusive lock state  to perform synchronized operation exclusively as a writer. In one embodiment, the task calls API rdlock  to request a lock as a reader. If successfully granted with the lock, the task may transition to the shared lock state  to perform synchronized operation sharing the lock with other tasks. Otherwise, if the lock is not available, e.g. already granted exclusively for another task, the task may transition to the blocked state  waiting for the lock (e.g. blocking).","In one embodiment, from the exclusive lock state , the task downgrades an exclusive lock granted to a shared lock. For example, the task may call API downgrade  (e.g. pthread_rwlock_downgrade_np( )) transitioning from the exclusive lock sate  to the blocked sate  to wake up other shared lock waiters who might be granted a shared lock along with the task (or thread). The task may drop the exclusive lock state  block waiting in the blocked state  for acquiring the lock as a shared lock along with other eligible tasks (or threads). When the lock is available as a shared lock, the task may wake up to call API wakeup  to transition to the shared lock state . A task holding an exclusive lock may prevent others from modifying the data related to the lock. While downgrading, a task may not lose the lock as long as the lock is held as a shared lock (e.g. by preventing others from modifying the data related to the lock). In some embodiments, a task calls API unlock to release the exclusively owned lock transitioning from the exclusive lock state  to the no lock state .","Likewise, from the shared lock state , the task may call API unlock  transitioning back to the no lock state  to release the shared lock. The task may upgrade a shared lock granted to an exclusive lock. For example, the task may call API upgrade  from the shared lock state  to block waiting in the blocked state  for other tasks holding the shared lock to unlock. Once all others drop (or release) the shared lock, the task may be granted with an exclusive lock. While waiting for others to unlock the shared lock at block , the task may not give up the shared lock and no waiters other than the task may modify the data related to the lock. A task requesting upgrading may have precedence over other waiting writers. In some embodiments, from a blocked state , a task may receive external interrupt eintr , e.g. according to a timer timing out, and go back to the blocked state  waiting for a lock.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 15","FIG. 1"],"b":["127","109","1500","8","821","10","1005","1500","1501","1503","1501","1503","1509","1511","1513","10","01","11","1500","1505","1507","1505","1507"]},{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 16","FIG. 1"],"b":["1600","103","1600","1601","1603","1600","1605","1600","1607","7","1623","8","1625","1","1619","1609","1611","1613","1617","1615"]},"For example, at sequence  , a lock request RL is received from a reader as a first lock request for a lock. The request RL is granted with the lock without calling a kernel interface with a lock count counted up by 1. At sequence  , a lock request WL arrives to request the lock as a writer calling the kernel interface to block waiting in the wait queue. The lock request WL is associated with a sequence number  corresponding to the lock count counted up from 1 to 2 at sequence  , while the wait counter is counted atomically together with the lock counter to 1 and status bit w is set to indicate a waiter is in queue waiting for the lock as a writer. A count W for the lock counter may correspond to a lock counter with lock count  with w status bit set to 1.","At sequence  , the reader releases the lock with a first unlock request UL to up count the unlock counter from 0 to 1 while updating neither the lock counter nor the waiter counter. In one embodiment, an indication to reset both the lock counter and unlock counter is based on a condition that the lock counter are equal to the unlock counter. In response to the unlock request UL, a kernel interface is called to select waiters to grant the lock, such as next waiting request WL. On the way back from the kernel interface call, at sequence  , status bit e is set to indicate the lock has been granted exclusively (e.g. based on return value of the interface call) according to the unlock count WE. Two requests for a lock as readers may be granted with the shared lock in sequences  and  . When a task is waken up from waiting in a wait queue returning from a kernel interface call, the wait counter may be counted down atomically to indicate a change of the number of waiters waiting in the wait queue. When there is no waiters waiting in the wait queue, at sequence  , an unlock request to release the lock may reset both the lock and unlock counters atomically returning back from a kernel interface call, absent from additional intervening lock requests.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIGS. 17A-17C","FIG. 1","FIG. 9"],"b":["1700","1700","103","1700","1701","3","2","0","900","1703","1705","1707"]},"Sequences B demonstrate multiple lock requests interfere with an unlock request attempting to reset synchronization counters. During sequences , in one embodiment, the unlock request performs an atomic operation to reset the unlock counter U. Subsequently during sequences , prior to another atomic operation to reset the lock counter L via the unlock request, a first lock request and a second lock request arrive to request the lock as a shared lock (e.g. as a reader). Both lock requests are granted with the lock. A first unlock request corresponding to the first lock request arrives prior to the unlock request completing an atomic operation resetting the lock counter L. As a result, during sequences , the unlock request restores the unlock counter and completes unlocking operations to count up the unlock counter U. When a second unlock request corresponding to the second lock request arrives, during sequences , counters L and U are reset accordingly.","Sequences C illustrate multiple lock requests including a writer request interfere with an unlock request attempting to reset synchronization counters. During sequences , in one embodiment, the unlock request performs an atomic operation to reset the unlock counter U. Subsequently during sequences , prior to another atomic operation to reset the lock counter L via the unlock request, a first lock request as a reader and a second lock request as a writer arrive to request the lock. The first lock request is granted with the lock while the second lock request waits in a wait queue with status bit w and the waiter count updated accordingly. As a result, during sequences , the unlock request restores the unlock counter and completes unlocking operations to count up the unlock counter U. During sequences , a first unlock request corresponding to the first lock request arrives to release the lock for granting exclusively to the second lock request. Status bit e and the waiter counter WC are updated accordingly. The second lock request arriving during sequences  returns at sequence . When a second unlock request corresponding to the second lock request arrives, during sequences , counters L and U are reset accordingly.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIGS. 18-19","FIG. 1"],"b":["1800","1900","103","1800","1800","1800","1900","1900","1900"]},"For example, at sequence  in , the arrival of barrier request BW trigger a condition (e.g. the number of requests or threads reaches a number initialized for a barrier) to grant the lock to each requests for the lock. BW and BW may return from a queuerespectively at sequences  and . BW may be assigned as barrier serial thread (BST) returning with a predetermined value. Variations of condition variables, for example, based on timeout and\/or broadcast settings, may be supported using counters. In some embodiments, multiple synchronization schemes may be implemented based on reader locks and\/or writer locks supported using counters.",{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIG. 20","FIG. 1"],"b":["117","2000","2001","2001"]},"In one embodiment, exemplary API  provides a lock request as a long reader. A lock may be granted to a long reader without kernel transitions according to certain conditions including, for example, whether there is any writer or yielding writer in progress (e.g. have not released the granted lock) and\/or whether there is any writer or yielding writer pending in queue. A long reader may block waiting in queue via kernel transitions if at least one writer (e.g. regular writer, yielding writer or other kinds of writer) is also waiting in queue. A waiting long reader may be granted with a lock in turn according to the wait queue. If multiple long readers are waiting in queue, all of the waiting long readers may be granted with a lock when one of them is granted with the lock. If a long reader is granted with a lock, all blocked short and long readers in queue may jump ahead. A long reader arriving in a queue after a lock has been already granted may not jump over waiting yielding writers.","In another embodiment, exemplary API  provides a lock request as a writer (or regular writer). A lock may be granted to a writer (lock request) without kernel transitions when the lock is not currently owned and no request is waiting. A writer may block waiting in queue via kernel transitions if at least one writer (e.g. regular writer, yielding writer or other kinds of writer) is also waiting in queue. A writer waiting long reader may be granted with a lock in turn according to the wait queue. If multiple long readers are waiting in queue, all of the waiting long readers may be granted with a lock when one of them is granted with the lock. Short readers and long readers can jump ahead of writers. In one embodiment, a long reader arriving at a wait queue after a lock has been granted does not jump over waiting writers. Exemplary API  may provide a lock request as a yielding writer. Typically, a yielding writer is granted with a lock from a wait queue in turn.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 21","FIG. 1","FIG. 21"],"b":"2100"},"As shown in , the computer system , which is a form of a data processing system, includes a bus  which is coupled to a microprocessor(s)  and a ROM (Read Only Memory)  and volatile RAM  and a non-volatile memory . The microprocessor  may retrieve the instructions from the memories , ,  and execute the instructions to perform operations described above. The bus  interconnects these various components together and also interconnects these components , , , and  to a display controller and display device  and to peripheral devices such as input\/output (I\/O) devices which may be mice, keyboards, modems, network interfaces, printers and other devices which are well known in the art. Typically, the input\/output devices  are coupled to the system through input\/output controllers . The volatile RAM (Random Access Memory)  is typically implemented as dynamic RAM (DRAM) which requires power continually in order to refresh or maintain the data in the memory.","The mass storage  is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data (e.g. large amounts of data) even after power is removed from the system. Typically, the mass storage  will also be a random access memory although this is not required. While  shows that the mass storage  is a local device coupled directly to the rest of the components in the data processing system, it will be appreciated that the present invention may utilize a non-volatile memory which is remote from the system, such as a network storage device which is coupled to the data processing system through a network interface such as a modem, an Ethernet interface or a wireless network. The bus  may include one or more buses connected to each other through various bridges, controllers and\/or adapters as is well known in the art.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":["FIG. 22","FIG. 1","FIG. 22"],"b":["2200","2200","2211","2201","2200","2205"]},"A display controller and display device  provide a visual user interface for the user; this digital interface may include a graphical user interface which is similar to that shown on an iPhone phone device or on a Macintosh computer when running OS X operating system software. The system  also includes one or more wireless transceivers  to communicate with another data processing system. A wireless transceiver may be a WiFi transceiver, an infrared transceiver, a Bluetooth transceiver, and\/or a wireless cellular telephony transceiver. It will be appreciated that additional components, not shown, may also be part of the system  in certain embodiments, and in certain embodiments fewer components than shown in  may also be used in a data processing system.","The data processing system  also includes one or more input devices  which are provided to allow a user to provide input to the system. These input devices may be a keypad or a keyboard or a touch panel or a multi touch panel. The data processing system  also includes an optional input\/output device  which may be a connector for a dock. It will be appreciated that one or more buses, not shown, may be used to interconnect the various components as is well known in the art. The data processing system shown in  may be a handheld computer or a personal digital assistant (PDA), or a cellular telephone with PDA like functionality, or a handheld computer which includes a cellular telephone, or a media player, such as an iPod, or devices which combine aspects or functions of these devices, such as a media player combined with a PDA and a cellular telephone in one device. In other embodiments, the data processing system  may be a network computer or an embedded processing device within another device, or other types of data processing systems which have fewer components or perhaps more components than that shown in .","At least certain embodiments of the inventions may be part of a digital media player, such as a portable music and\/or video media player, which may include a media processing system to present the media, a storage device to store the media and may further include a radio frequency (RF) transceiver (e.g., an RF transceiver for a cellular telephone) coupled with an antenna system and the media processing system. In certain embodiments, media stored on a remote storage device may be transmitted to the media player through the RF transceiver. The media may be, for example, one or more of music or other audio, still pictures, or motion pictures.","The portable media player may include a media selection device, such as a click wheel input device on an iPhone, an iPod or iPod Nano media player from Apple Computer, Inc. of Cupertino, Calif., a touch screen input device, pushbutton device, movable pointing input device or other input device. The media selection device may be used to select the media stored on the storage device and\/or the remote storage device. The portable media player may, in at least certain embodiments, include a display device which is coupled to the media processing system to display titles or other indicators of media being selected through the input device and being presented, either through a speaker or earphone(s), or on the display device, or on both display device and a speaker or earphone(s). Examples of a portable media player are described in published U.S. patent application numbers 2003\/0095096 and 2004\/0224638, both of which are incorporated herein by reference.","Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine-executable instructions that cause a machine that executes these instructions to perform certain functions. In this context, a \u201cmachine\u201d may be a machine that converts intermediate form (or \u201cabstract\u201d) instructions into processor specific instructions (e.g., an abstract execution environment such as a \u201cvirtual machine\u201d (e.g., a Java Virtual Machine), an interpreter, a Common Language Runtime, a high-level language virtual machine, etc.), and\/or, electronic circuitry disposed on a semiconductor chip (e.g., \u201clogic circuitry\u201d implemented with transistors) designed to execute instructions such as a general-purpose processor and\/or a special-purpose processor. Processes taught by the discussion above may also be performed by (in the alternative to a machine or in combination with a machine) electronic circuitry designed to perform the processes (or a portion thereof) without the execution of program code.","The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), RAMs, EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.","A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine readable medium includes read only memory (\u201cROM\u201d); random access memory (\u201cRAM\u201d); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc.","An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as, but is not limited to, one or more memories (e.g., one or more flash memories, random access memories (static, dynamic or other)), optical disks, CD-ROMs, DVD ROMs, EPROMs, EEPROMs, magnetic or optical cards or other type of machine-readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a propagation medium (e.g., via a communication link (e.g., a network connection)).","The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be kept in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cdisplaying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion, the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 17A-17C"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 18 and 19"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 22"}]},"DETDESC":[{},{}]}
