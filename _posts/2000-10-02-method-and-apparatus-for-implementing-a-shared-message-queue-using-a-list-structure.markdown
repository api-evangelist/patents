---
title: Method and apparatus for implementing a shared message queue using a list structure
abstract: A method and apparatus for implementing a shared message queue using a list structure. A put list is defined comprising a sequence of list entries, each of which corresponds to a message in the queue and has an associated list entry key. Each list entry key corresponding to an uncommitted message falls within an uncommitted key range defining an uncommitted portion of the put list, while each list entry key corresponding to a committed message falls within a committed key range defining a committed portion of the put list. To write a message to the queue, a list entry is added to the put list having a list entry key within the uncommitted key range.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06862595&OS=06862595&RS=06862595
owner: International Business Machines Corporation
number: 06862595
owner_city: Armonk
owner_country: US
publication_date: 20001002
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","General Operation","Specific Implementation","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4","Get\/Wait Processing","List Limit Override","Rollback Counts"],"p":["This application is related to the following commonly owned copending applications, incorporated! herein by reference:\n\n","1. Field of the Invention","This invention relates to a method and apparatus for implementing a shared message queue using a list structure and, more particularly, to a method and apparatus for implementing a message queue that is shared across a sysplex using a coupling facility list structure.","2. Description of the Related Art","IBM's MQSeries\u00ae is a set of middleware products that allow user applications to rag intercommunicate using messages, without having to know the complexities of the underlying hardware and software platform. Applications communicate using the MQSeries application programming interface (API), issuing such calls as MQPUT to put a message onto a queue and MQGET to get a message from a queue. (In this specification, the terms \u201cget\u201d and \u201cput\u201d are used generally interchangeably with the terms \u201cread\u201d and \u201cwrite\u201d, respectively.) MQSeries is described in such publications as , IBM GC33-1349-07 (January 1999), incorporated herein by reference:","The IBM S\/390\u00ae Parallel Sysplex\u00ae configuration is a cluster of interconnected processing nodes with attachments to shared storage devices, network controllers, and core cluster technology components, consisting of coupling facilities, coupling support facilities, and external time references (ETRs). A coupling facility (CF) enables high-performance read\/write sharing of data by applications running on each node of the cluster through global locking and cache coherency management mechanisms. It also provides cluster-wide queuing mechanisms for workload distribution and message passing between nodes.","The coupling facility is described in the following patents and publications, incorporated herein by reference:\n\n","It would be desirable to be able to use the list-processing capabilities of the coupling facility to implement a message queue that is shared by queue managers residing on different systems across a sysplex. To be suitable for this purpose, the CF list architecture should allow MQSeries to efficiently implement the following message-queuing semantics:\n\n","If the read is backed out, the message must again become visible to other units of work executing in the queue-sharing group. When the get is backed out, the message must be reinserted into the committed portion of a list with respect to both its priority and its time of arrival (when the message was originally put).\n\n","In general, the present invention contemplates a method and apparatus for implementing a shared message queue using a list structure. A put list is defined comprising a sequence of list entries, each of which corresponds to a message in the queue and has an associated list entry key. Each list entry key corresponding to an uncommitted message falls within an uncommitted key range defining an uncommitted portion of the put list, while each list entry key corresponding to a committed message falls within a committed key range defining a committed portion of the put list. To write a message to the queue, a list entry is added to the put list having a list entry key within the uncommitted key range. Putting messages initially into the uncommitted portion of the put list in this manner hides uncommitted puts from other units of work (which only look at the committed list portion) without requiring explicit locking protocols.","List entry keys in the uncommitted key range are assigned in order of message priority and in order of arrival time for messages of a given priority. Each list entry key has a more significant portion indicating the list portion to which the corresponding list entry belongs and a less significant portion indicating the order of the list entry in the list portion. To commit messages to the queue, the list entry keys associated with the list entries are modified to fall within the committed key range to move the list entries to the committed portion of the put list while preserving their relative order as determined by the list entry keys.","To read a message from the queue, the list entry whose list entry key has the lowest value in the committed key range is moved from the committed portion of the put list to a get list defined for the queue manager. This insures that only the highest-priority committed message is returned in response to a read request without knowing the key of the entry to be read. Also, this insures no other unit of work can read a message that another unit of work has already read. Again, this is accomplished without requiring any explicit locking protocols.","If there are no messages currently in the committed portion of the put list, the requester waits and is notified of a subsequent change in state of the committed portion of the list from an empty state to a not-empty state. Monitoring the committed key range in this manner allows a requester to know when a committed message of any priority is available for reading without having to know the explicit key beforehand.","To abort a read of the message from the queue, the list entry is moved back from the get list to the committed portion of the put list. To commit a read of the message from the queue, the list entry is removed from the get list.","The following terms, used throughout this description, are reproduced here for ready reference.","A \u201cbackout\u201d (or \u201cabort\u201d) is an operation that reverses all the changes made during the current unit of work. After the operation is complete, a new unit of work begins.","A \u201ccommit\u201d is an operation that applies all the changes made during the current unit of work. After the operation is complete, a new unit of work begins.","A \u201csyncpointi\u201d is an intermediate or end point during processing of a transaction at which the transaction's protected resources are consistent. At a syncpoint, changes to the resources can safely be committed, or they can be backed out to the previous syncpoint.","A \u201cunit of work\u201d is a recoverable sequence of operations performed by an application between two points of consistency. A unit of work begins when a transaction starts or after a user-requested syncpoint. It ends either at a user-requested syncpoint or at the end of a transaction.",{"@attributes":{"id":"P-00089","num":"00089"},"figref":"FIG. 1","b":["100","100","102","104","106","102","104"]},"Within each system , user applications  perform sequences of operations, referred to herein as units of work (UOWs), on shared message queues  via a shared queue manager (SQM)  resident on that system. Shared queue managers  on different systems  that share the same message queue  are referred to herein as a queue-sharing group (QSG). In the preferred embodiment, each shared queue manager  in turn interacts with the coupling facility via a component  of the OS\/390 operating system known as Sysplex Services for Data Sharing (XES). Sysplex Services for Data Sharing (XES) is described more fully in the IBM publication , GC28-1495-02 (June 1995), incorporated herein by reference.","User applications  on a system  interact with the shared queue manager  on that system via a series of Message Queue Interface (MQI) calls, the most important of which are MQPUT (to put a message onto a message queue ) and MQGET (to get a message from a message queue ). In response to such a call, shared queue manager  issues a call to XES  to invoke a requested system service (e.g., IXLLSTC, IXLLSTE and IXLLSTM, as described below) to communicate with the coupling facility . In response to receiving a call from a shared queue manager , XES  sends an appropriate message command block (MCB) containing data and other operands to the coupling facility  to perform the requested operation. XES  receives back from the coupling facility  a message response block (MRB) containing data and\/or a response code.",{"@attributes":{"id":"P-00092","num":"00092"},"figref":"FIG. 10","b":["1000","104","102","1000","1002","1004","1006","1002","1008","1010","1004","1012","1014","1008","104","1010"]},"As part of its list-processing capability, coupling facility  performs requested operations on lists composed of one or more entries. Referring now to , in accordance with one aspect of the present invention, each logical message queue  is implemented as a set of lists: a put list , comprising a put list header (PLH) and optionally one or more list entries , and one or more get lists  (one get list for each shared queue manager ), each comprising a get list header (GLH) and optionally one or more list entries . (The terms \u201clist\u201d and \u201clist header\u201d are used interchangeably herein in view of their one-to-one correspondence.) Each put list  is associated with a particular shared queue  and is shared by the shared queue managers  in the queue-sharing group. Each get list , on the other hand, is associated with a particular shared queue manager  and may be used for messages gotten from multiple shared queues . Each list entry  corresponds to a message. (The terms \u201clist entry\u201d and \u201cmessage\u201d are used interchangeably herein.) Associated with each list entry , along with a message and other data, is a list entry key LEK that is used to determine the order of the entry  in the list  or . Keys LEK enforce the order of entries on a list ; more particularly, the keys form the basis for partitioning the put list  into a committed portion , in which the keys LEK fall within a committed key range, and an uncommitted portion , in which the keys LEK fall within an uncommitted key range that does not overlap the committed key range.","Lists  and  and key ranges  and  supply the mechanism for writing, reading and committing messages  in accordance with the present invention. More particularly, the process of \u2018hiding\u2019 uncommitted put messages , hiding messages  that have been read, and making committed puts globally visible is done simply by movement between list headers  and  and\/or key assignment changes without the use of any explicit locking protocols.","The keys LEK that a list entry (message)  can be assigned are defined by the shared queue manager , as described below. Referring to , when a message  is initially put (step ), it is first assigned the following 16-byte key LEK in the uncommitted key range (step ):\n\n","The set of list entries  whose key LEK begins with X\u2018F6\u2019 define the uncommitted portion  of the (put) list header .","Referring to , when an uncommitted message  (first byte of key LEK is X\u2018F 6\u2019) is committed (step ), it is moved from the uncommitted portion  of the list header  to the committed portion  of the same list header . In this case, the list entry  moves from one position on the list header  to another position on the same list header . The movement is accomplished by changing the list entry's key LEK so that it falls within the committed key range (step ). Referring to , the uncommitted put key LEK is changed to the following:\n\n","The set of list entries  whose keys begin with (00 . . . 09) inclusive defines the committed portion  of the put list header .","Referring to , if a unit of work decides to abort a write of a message  (step ), it deletes the message  from the uncommitted portion  of the put list  (step ). This portion  of the put list is available only to the unit of work that originally wrote the message  and is invisible to other units of work.","Referring to , when a unit of work requests the highest committed message  on a get request (step ), only the committed portion  of the list header  is eligible to be scanned, that is, list entries  whose keys begin with (00 . . . 09) inclusive. Entries  that begin with X\u2018F 6\u2019 do not participate in the scan.","This is accomplished by using an IXLLSTE invocation (as described below) that examines the entry  at the head of the list  (step ) and returns it only if the first byte of its key is in the inclusive range (00 . . . 09). (This is referred to herein as key range checking on read.) If there are no messages  on the list header  or if the key of the message at the head of the list header begins with a value outside the committed key range (step ), then no message is returned (step ).","If there are committed messages , then the message  that is returned is the message at the head of the list header , since the messages  are in priority order and within priority by time of arrival. Thus, if the message  at the head of the list  is a committed message (step ), then two things happen in an atomic fashion:\n\n","As noted above, steps  and  occur atomically, avoiding the need for serialization on the queues.","Once the message  is moved to the shared queue manager 's uncommitted get queue , it is no longer visible to other get requests because all get requests for the shared queue  reference the shared queue's put list header .","The final disposition of the message read will be either commit or abort. Referring to , if the disposition is commit (step ), the message  is deleted from the shared queue manager 's uncommitted get queue  (step ). Referring to , if the disposition is abort (step ), then the message  is moved back to the committed portion of the put list header  from whence it came into its proper priority\/time sequence position (step ).","Consider the following: at the time of the get request, the message  at the head of the list  has priority . (From an external perspective, MQSeries supports 10 priorities: (0 . . . 9); 0 is the lowest priority, 9 is the highest. However, to accommodate the CF list architecture, in which list entries are arranged in ascending key order, these priorities are inverted when forming a key so that 0 is the highest priority and 9 is the lowest priority, as described below. Unless otherwise indicated, the priorities referred to herein are these inverted priorities.) It is the only committed message  on the list header . It is moved to the shared queue manager 's uncommitted get queue . The committed portion  of the list  is now null. While the message  is on the uncommitted get queue  a unit of work commits a message  of priority , which puts the message at the head of the put list . While the priority  message  is at the head of the list , the unit of work that read the priority  message  aborts, causing the message to be moved back to the committed portion of the put list header . There are now two committed messages  on the put list header : a message with priority  followed by a message with priority .","Another example: The only committed message  on the put list header  is of priority . A get request moves the message  to the shared queue manager 's uncommitted get queue . The committed portion  of the put list  is null. While the priority  message is on the shared queue manager 's uncommitted get queue , two additional messages  are committed, one of priority  and one of priority . Let's refer to the priority  message  on the put list  as 1\u2032. If the unit of work that read the priority  message  aborts, then when the entry is returned to the committed portion of the put list header, the order of messages on the put list header  is:\n\n","The reason that the priority  message  is placed before the priority \u2032 message is that the time stamp component of the priority  message (near the front of the list entry's key LEK) is less than the timestamp component of the priority \u2032 message, since the priority  message was written first. (Strictly speaking, it is the order of the shared queue manager  assigning the STCK value that matters here, not the order of the write.)","The above discussions provide examples in which there was a single get or put operation in the unit of work. However there can be multiple gets and puts in a unit of work. If a unit of work does 10 puts to the same shared queue , then there are 10 list entries  for the unit of work on the uncommitted portion  of the put list header . If the unit of work aborts, those 10 entries  are deleted. If the unit of work commits, then those 10 entries  are moved (by a key change) from the uncommitted portion  to the committed portion  of the put list header . If the unit of work does 10 gets (possibly one get from 10 different shared queues ), then there are 10 list entries  for the unit of work on the shared queue manager 's uncommitted: get queue . If the unit of work aborts, then the 10 list entries  are moved back to their proper positions on the put list header(s)  from which they came. If the unit of work commits, then the list entries  are deleted from the uncommitted get queue .","If a unit of work does 10 puts, each to a different shared queue  (each shared queue possibly referencing a different CF list structure) then a commit or abort causes 10 different list headers  to be accessed to complete the operation.","The following sections discuss the implementation of get and put processing for nonindexed queues (i.e., queues that are not indexed as described below) and show the IXLLSTE invocations that limit get requests to process only the committed portion  of the PLH .","The list architecture of coupling facility , insofar as it is pertinent to the present application, is fully set forth in the concurrently filed related application referenced above and incorporated herein by reference. A brief summary of this description is set forth below.","Referring to , coupling facility  contains microcode , also referred to as coupling facility control code (CFCC), for managing one or more list structures .","Referring to , each list structure  contains a set of list structure controls , a list set  comprising one or more lists , user controls , a lock table  comprising one or more lock table entries (LTEs) , and one or more event queue controls  and corresponding event queues .","A set of user controls  is created for each user (such as a shared queue manager  on a system , as described below) of a list structure . Among the user controls  is a list notification token LNT that specifies a list notification vector  () on the system.","Referring to , each list  contains list controls  (including a key range monitor table  and a list monitor table ) and, optionally, one or more list entries . Each list entry  in turn contains a set of list entry controls  (including a list entry ID (LEID) and a list entry key (LEK), a data list entry  comprising one or more list elements (LEs) , and an adjunct list entry  (including a secondary list entry key SLEK if defined).","Key range monitor table  contains information used to process the list notification vector  of each user who has registered an interest in key range state transitions (as described in the related application referenced above). Referring to , key range monitor table (KRMT)  comprises an array of KRMT entries  (equal in number to the maximum number of list structure users plus one) indexed by user ID (UID).","Similarly, list monitor table  contains information used to process the list notification vector  of each user who has registered an interest in state transitions of the list  (as described in the related application referenced above). Referring to , list monitor table (LMT)  comprises an array of LMT entries  (equal in number to the maximum number of list structure users plus one) similarly indexed by user ID (UID).","Each user of a list structure  has an event queue  for each list entry key type defined for the list structure. Thus, if only primary list entry keys (LEKs) are defined for a list structure , then only a primary event queue  is defined for each user. On the other hand, if secondary list entry keys (SLEKs) are also defined for a list structure , then a secondary event queue  is also defined for each user. Referring to , each event queue  comprises a sequence of event monitor controls (EMCs) . Event queue  is used to notify a user (by adding an EMC  to the queue) of such events as the transition of a monitored subsidiary list (a subset of a list whose entries have the same key) to an empty or a nonempty state or to notify the user of the initial state of the subsidiary list, as described in the concurrently filed application of D. A. Elko et al. referred to above.","Referring to , the following modules of the shared queue manager  support put and get processing.\n\n","Each is discussed in detail in the following sections.","Thread Anchor Block (CSQETHRD)",{"@attributes":{"id":"P-00146","num":"00146"},"figref":"FIG. 15","b":["1500","106","106","1500"]},"By way of review, a shared queue  maps to (references) a CF list structure . Shared queues  are defined through interactions with a repository manager , a component of the shared queue manager . When a shared queue  is defined, it is assigned to a CF list structure . When the repository manager  \u2018sees\u2019 a list structure name for the first time, it creates a structure record in the repository and assigns the structure  a queue-sharing group unique numeric identification in the inclusive range (1 . . . 255). When a shared queue  is defined, it too is assigned a unique numeric ID in the inclusive range (1 . . . 512). (This range is specific to this implementation and may differ in another implementation.) This is because 512 different shared queues  can reference the same CF list structure . Each shared queue  is assigned a unique list header  (as a put list header ) in the CF list structure .","In the embodiment shown (other implementations may differ), the maximum number of list structures  that can be defined for a sysplex is 255, while the maximum number of concurrent connections to a specific list structure  is 32.","CF Manager  is a module of the shared queue manager  that directly interacts with XES , invoking list structure services as described below. Since the CF Manager  has no way of knowing in advance what shared queues  a UOW will access (and to what structures  the queues map), it must be prepared to access any one of up to 255 structures . Hence the CF thread anchor block  (mapped by a CSQETHRD module ) contains an array of 255 elements , array element one representing structure one, array element two representing structure two, and so on.","Besides the 255 array elements , there is a section  that is used to represent the UOW ID. The UOW ID  is an eight-byte field composed of a one-byte numeric queue manager ID concatenated with the high-order 7-bytes of a system clock (STCK) value. A UOW ID  is assigned when a UOW makes its first put or get request.","A shared queue  accessed by a UOWV is represented by a control block  known as a TRQS (Thread Related QueueS) and is mapped by a CSQETRQS module . An operation (put or get) against a shared queue  is represented by a control block  known as a TROP (Thread Related Operation) and is mapped by a CSQETROP module .",{"@attributes":{"id":"P-00152","num":"00152"},"figref":"FIG. 15","ul":{"@attributes":{"id":"ul200010","list-style":"none"},"li":["1. A UOW has accessed three different shared queues  (represented by three TRQSes ), and each shared queue  accessed by the UOW maps to CF list structure .","2. One operation (get or put) (represented by a TROP ) has been done against Shared Queue , two operations have been done against Shared. Queue  and one operation has been done against Shared Queue ."]}},"The UOW's thread structure is processed by CSQETHDP module . The TROPs  are ordered by priority and by time of arrival within priority.","Messages  are committed\/backed out in priority sequence, from highest priority (which is priority zero) to lowest priority (which is priority ).","CSQETHDP ","Module CSQETHDP  (thread processing) supports the following set of function codes:","CSQE_Create_Or_Add_Thread_Info","This function is requested whenever a UOW issues a put or get of a shared message  both in and out of syncpoint. Other input information that is passed across the interface to CSQETHDP  includes a shared queue token (mapped by a CSQESQTK module ) which uniquely identifies the shared queue  that is being accessed in the shared queue manager . From information contained in the shared queue token, information about the corresponding CF list structure  can be obtained\u2014an important piece of information is the numeric ID (range: 1-255, inclusive) of the structure . The numeric ID is used as an index into the thread block structure array . Each entry  in the thread block structure array  anchors a queue of TRQSes  which represent shared queues .","The first phase of processing scans the selected TRQS queue and determines whether a TRQS  already exists for the shared queue  currently being accessed. If one does not exist (the first time the shared queue  is being accessed in the unit of work) then one is created. The TRQS  is queued at the tail of the TRQS queue.","A TROP  is then obtained and queued to the TRQS . There may be one or more TROPs  queued to a TRQS \u2014each TROP  identifies an action (put or get) issued by the UOW against the shared queue  represented by the TRQS .","The TRQS  contains control information about the shared queue . Some of the control information includes: (1) pointer to the first TROP  queued; (2) a pointer to last TROP  on the queue; (3) the structure number that the shared queue  maps to; (4) the list header number in the list structure  to which this shared queue  maps; (5) the list header number assigned to this shared queue manager 's uncommitted get queue ; and (6) the best overall and best persistent keys (discussed below).","The TROP  contains information about the operation issued. Some of the control information includes: (1) the operation: put or get; (2) the address of the next TROP  (if any) on the queue of TROPs ; (3) the PLEID (programmable list entry ID) of the corresponding list entry, which uniquely identifies the message  in the CF list structure ; and (4) the 16 byte key of the entry. This key can represent either a committed or uncommitted entry. For example, if a UOW did a get of a committed message , the key is a committed key. If the message  was put in syncpoint and not yet committed then the key is an uncommitted entry key.","Another function performed is to set up control information so that the last operation can be backed out. This is covered in the discussion of CSQE_Backout_Last_Msg.","CSQE_Delete_Thread_Info","This function is requested by a call from module CSQESYN, which is responsible for committing, aborting and preparing units of work. This function code instructs CSQETHDP  to free all TRQS and TROP control blocks  and  allocated for the unit of work. This call is made from CSQESYN after the unit of work is successfully committed, aborted or prepared.","CSQE_Backout_Last_Msg","This function, deletes the last TROP  added to the last TRQS  accessed by a UOW. This function is requested by CSQESYN when it is called to backout the last message . This request is made in response to a successful get request and it is determined that the user-specified buffer is too small to hold the message  and that the caller does not accept truncated messages .","CSQE_Expire_Last_Msg","EXPIRY is a period of time expressed in tenths of a second, set by the application which puts the message . The message  becomes eligible to be discarded if it has not been removed from the destination queue  before the period of time elapses.","When CF Manager  returns a message  to its caller in response to any one of the various types of get requests, the caller may determine that the message  is expired, that is, it is not to be returned to the caller. Rather it is to be moved to the getting shared queue manager 's expiry queue (not shown).","If the last message  read was in response to a get request (CSQEMGE) or a get under cursor request (CSQEMGE), the corresponding TROP  is removed from the TROP chain. The corresponding message  is moved from the shared queue manager 's uncommitted queue to the shared queue manager 's expiry queue. The flow of events is:\n\n","During CSQEMGE and CSQEMGE processing, a TROP  is created before the message  is actually read. Because of this protocol, it is assumed that the priority of the message  to be read is 9. This causes the TROP  to be queued at the end of the TROP chain. After the message  is read, its real priority can be determined. If its priority is different that the assumed 9, then the TROP  is moved to its proper position (priority,timestamp) in the TROP queue. The function CSQE_Prioritize_Last_Msg is called from CSQEMGE and CSQEMGE after a message  is read.","Put Processing: CSQEMPU","This module is responsible for writing a message  to a shared queue . It supports the following options:\n\n","In general the flow for an MQPUT request is:\n\n","Parm_FRE: recovery environment","Parm_SQToken: shared queue token. Returned on successful open","Parm_Buffer: contains message  to be written","Parm_Buffer_Length=length of message  to be written, rounded up to the next 256-byte multiple","Parm_Priority: user specified priority of the message .","Parm_Options:\n\n","Parm_Index_Key: message or correlation ID if put to an indexed shared queue ","Parm_Second_Locator: can be null or if Parm_Index_Key is a message ID then this value can specify a correlation ID; if Parm_Key is a correlation ID then this value can specify a message ID. MQSeries supports getting a message  by both message and correlation ID. A shared queue , when defined, is either indexed on message or correlation ID, not both.","CSQE_Put_In_SyncPoint_Persistent","Since this message  is in syncpoint, it is assigned an uncommitted key (a key beginning with X\u2018F 6\u2019) so that it is placed on the uncommitted portion of the list header  assigned to the shared queue .","A call is then made to module CSQETHDP  to create or add thread information. Upon return, an IXLLSTE macro instruction is issued to write the message  to the corresponding list header . If the IXLLSTE operation is successful, control returns to the caller. If the IXLLSTE operation was not successful, then a call is made to CSQETHDP  to backout the last message , which results in the last TROP  being deleted from the queue of TROPs .","The fact that the message  is persistent is remembered in the TROP . Message persistence is handled in get processing (CSQEMGE) and is addressed in more detail in that section.","CSQE_Put_In_SyncPoint_Non_Persistent","Since this message  is in syncpoint, it is assigned an uncommitted key (a key beginning with X\u2018F 6\u2019) so that it is placed on the uncommitted portion  of the list header  assigned to the shared queue .","A call is then made to module CSQETHDP  to create or add thread information. Upon return, an IXLLSTE macro instruction is issued to write the message  to the corresponding list header . If the IXLLSTE operation is successful, control returns to the caller. If the IXLLSTE operation was not successful, then a call is made to CSQETHDP  to backout the last message , which results in the last TROP  being deleted from the queue of TROPs . If the queue of TROPs  is empty, then the corresponding TRQS  is also deleted.","The fact that the message  is nonpersistent is remembered in the TROP . Message persistence is handled in get processing (CSQEMGE) and is addressed in more detail in that section.","CSQE_Put_Out_Of_SyncPoint","Even though this message  is out of syncpoint (meaning that it should be immediately visible to a get request) it is first assigned an uncommitted key and written to the uncommitted portion  of the corresponding put list header .","A call is then made to module CSQETHDP  to create or add thread information. Upon return, an IXLLSTE macro instruction is issued to write the message  to the corresponding list header . If the IXLLSTE operation is successful, control returns to the caller. If the IXLLSTE operation was not successful, then a call is made to CSQETHDP  to backout the last message , which results in the last TROP  being deleted from the queue of TROPs . If the queue of TROPs  is empty then, the corresponding TRQS  is also deleted.","If the operation is successful, control returns to the non-CF Manager caller, who then calls CSQESYN to sync the last message , which causes the message  to be moved (by changing the entry's key to a committed key) to the committed portion  of the put list .","This two-phase process for messages  put out of syncpoint is done to avoid unresolvable ambiguities during queue manager recovery processing. An alternative would be to have data manager  logging the put out of syncpoint before calling CSQEMPU. However, if there was a failure after CSQEMPU was called and before it returned to data manager  (e.g., the system failed), the queue manager , when restarting and processing its logs, could not determine if the message  was or was not actually written and therefore it would not know how to recover that message . The two-phase process described above effectively handles this situation and removes any ambiguities.","List Entry Version Numbers","To recap, any message  put is first put to the uncommitted portion  of the put list header . When the list entry is written it is assigned an eight-byte version number which is the UOW ID. The UOW ID is created by CSQETHDP  when it encounters the first put or get (CSQE_Create_Or_Add_Thread_Info) in a UOW. The UOW ID is a one-byte numeric shared queue manager ID concatenated with the 7 high order bytes of a STCK value. Placing the shared queue manager numeric ID in the most significant position of the version number insures sysplex-wide uniqueness, as there cannot be multiple instances of the same queue manager  executing in the sysplex.","Buffers\/Buffer Length","The buffer containing the data to be written begins on a 4K boundary. The buffer is made up of one or more 4K pages. If the message  to be written is less than or equal to 4096 bytes, the buffer is composed of one page. If the message  to be written is greater than 4096 bytes and less than or equal to 8192 bytes, the buffer is composed of two pages. The fact that the buffer always begins on a 4K boundary and is composed of a multiple 4K pages insures that XES buffer requirements are met. The buffer size and alignment requirements are discussed in the IBM publication , GC28-1495-02 (June 1995) referenced above.","List Element Size","A list entry  () is made up of one or more list elements (LEs) . The size of a list element  can be one of the following: 256, 512, 1024, 2048 and 4096 bytes. In the embodiment shown, the list element size (CSQE_Element_Size) is 256. The maximum size of a list entry  allowed by the disclosed coupling facility  is 64K. If 4K list elements  are being used and a message  of 64K bytes is to be written, then 16 4K list elements  are needed to represent the list entry . If 512-byte list elements are being used then 128 512-byte list elements are required.","It is impossible to represent a 64K-byte message  using an element size of 256 bytes. To do so would require 256 256-byte list elements. The maximum number of elements  that can comprise a list entry  is 255. So if 256-byte element sizes are used the largest size message  that can be supported is 64K minus 256.","The number of list elements  times the list element size cannot exceed 64K, so it would be an error to specify a 4K list element size and attempt to write more than 16 list elements .","IXLLSTE Invocation",{"@attributes":{"id":"P-00227","num":"none"},"ul":{"@attributes":{"id":"ul200018","list-style":"none"},"li":"?IXLLSTE EntryType(New)\n    \n    "}},"EntryType(New): a new list entry is to be created","AssignEntryID: CF Manager  is assigned a structure-unique 12-byte PLEID to the entry  to be created. (PLEID is the same as LEID in this context.) The PLEID is mapped by a CSQEPLEI module . It is constructed as follows:\n\n","ListNum: the list number assigned to the shared queue . The assigned list number is maintained in a control block known as an SCB.","LockOper(NotHeld): this operation is to execute only when the lock on the list header  is not held.","Authcomp: each instance of the CF Manager  in the queue-sharing group remembers the last valid list authority value it used. List authority, maintained in list controls, is increased by +1 whenever: (1) the list resident LHQC is updated; and (2) the change needs to be made visible to other shared queue managers  in the queue-sharing group when they next access the corresponding list header .","Here is an example: all shared queue managers  know that the valid list authority value is zero and that the shared queue  is not put inhibited. A shared queue manager  in the queue-sharing group is told to change the status of the shared queue  to put inhibited. That instance of the shared queue manager  reads the LHQC and also retrieves the current list authority. It updates its virtual storage copy of the LHQC to set the put inhibited indicator. It then attempts to rewrite the LHQC specifying what it believes to be the current list authority and requesting that if its passed list authority value matches what is in list controls that the list authority be increased by +1. (This processing occurs in an atomic fashion). Assuming that the update worked, the LHQC is updated and the list's list authority is now 1. Next another shared queue manager  attempts to put a message  believing that the current list authority is zero. Its put fails with a list authority comparison failure. This failure is returned to the caller of put processing. The error return code causes the caller to reread the LHQC (via a CSQERCAT module ) and it now notices that the put inhibited indicator is set and therefore fails the put request initiated by the application address space.","VersUpdate(SET): the 8-byte version number of the entry created is set to the unit of work ID.","Priority Inversion","From an external perspective, MQSeries supports priority  through . 9 is the higest priority, zero is the lowest priority. A list structure  orders entries by the entry key from lowest to highest (ascending order). Recall that when a message  is committed, the first byte of its committed key is set to its priority. If a unit of work puts 10 messages  to the same shared queue , one message  of each possible priority, and then commits the messages , the order of messages  would be priority zero, one, . . . nine. This would violate the MQSeries guarantee that a get gets the highest-priority message , because in this example the lowest-priority message  is at the head of the committed portion  of the list header . The entry with priority nine should be first, followed by priority , . . . followed by priority zero.","To address this CF Manager  does priority inversion. It subtracts the priority specified on input to CSQEMPU from 9, that is, inverted priority=(9\u2014input priority). Hence the following mapping:",{"@attributes":{"id":"P-d0e6525","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Input Priority","Inverted Priority"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"9","0"]},{"entry":[{},"8","1"]},{"entry":[{},"7","2"]},{"entry":[{},"6","3"]},{"entry":[{},"5","4"]},{"entry":[{},"4","5"]},{"entry":[{},"3","6"]},{"entry":[{},"2","7"]},{"entry":[{},"1","8"]},{"entry":[{},"0","9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"A shared queue  can be indexed by either message  or correlation ID. New enhancements to the architecture of coupling facility , described in the referenced related application, allow MQSeries to provide a robust, performance-sensitive solution for indexed queues. As described in that application, a secondary list entry key (SLEK) is maintained in the first 32-bytes of the adjunct area  associated with a list entry .","If a message or correlation ID was specified on the put, it is not assigned as the secondary key at put time. However, CF Manager  remembers what the secondary key should be when the message  is committed. That is, the secondary key (if any) is assigned when the message  is committed.","Examining the IXLLSTE invocation above, notice that the SECONDARYKey keyword is not explicitly specified. Even though the secondary key is moved into the adjunct in CSQEMPU, this IXLLSTE invocation does not assign the secondary key to the list entry. This is because the secondary key is not \u2018formally\u2019 assigned until the message  is committed. (The operation of XES  is such that if the user does not specify SECONDARYKey, the secondary key is set to all zeros.) By placing it in the adjunct area , CF Manager  simply saves the message or correlation ID. The secondary key is assigned when the message  is committed. By delaying the assignment of the secondary key until commit time, CF Manager  can insure that any get by message or correlation ID will not be returned an uncommitted message  with a matching secondary key.","So upon successful completion of the IXLLSTE invocation above, a list entry  is written. Its primary key begins with X\u2018F 6\u2019 (the uncommitted key designation) and the associated secondary key is binary zeros.","GET PROCESSING: CSQEMGE","This module is responsible for reading messages  from a shared queue . The operations that this module supports are:\n\n","This is the interface into CSQEMGE:\n\n","Parm_Second_Locator: this parameter is optional. If the shared queue  is indexed by message ID then this parameter can be a correlation ID. If the shared queue  is indexed by correlation ID, this parameter can be a message ID. When a value is provided for this parameter it means that the message  returned must have an exact match on the input message and correlation ID.","The following sections discuss CSQEMGE processing with respect to nonindexed shared queues .","CSQE_Get_Out_Of_SyncPoint","This function code requests that the highest-priority committed message  (if any) be returned. An uncommitted message  can never be returned in response to this function code. The highest-priority message  is moved from the corresponding put queue  to the requesting shared queue manager 's uncommitted get queue . A call is made to CSQETHDP  to create thread-tracking information. Control then returns to data manager . Two things can happen when control returns to data manager :\n\n","The LXLLSTE invocation is as follows:\n\n","This IXLLSTE invocation moves the first committed message  (if one exists) to the getting shared queue manager 's uncommitted get queue .","Key_Of_Message_To_Move is set to X\u20180A0000000000 . . . 00\u2019. The above IXLLSTE invocation is telling the coupling facility  to look at the entry  at the head of the list  (Direction=HeadToTail) and to return it in the specified buffer only if its entry key is less than or equal to X\u20180A0000000000 . . . 00\u2019. Since a committed message  has priority in the first byte of its entry key and priority is in the inclusive range (0 . . . 9) this invocation guarantees that only a committed message  is returned. If the first message  on the list was an uncommitted put (X\u2018F 6 . . .\u2019) that message  would not be returned because X\u2018F 6 . . . \u2019 is not less than or equal to X\u20180A0000000000 . . . 00\u2019.","LockOper(NotHeld): this operation is to execute only when the lock on the list header  is not held.","CSQE_Get_In_SyncPoint","CSQE_Get_In_SyncPoint_If_Persistent","These two functions are quite similar and are therefore covered together.","CF Manager , on a shared queue by shared queue basis, keeps track of the highest-priority uncommitted message  put by a UOW and the highest-priority uncommitted persistent message  put by the unit of work. MQSeries will return an uncommitted put in response to a get request provided the UOW put the (uncommitted) message . That is, MQSeries will not return an uncommitted put that was put by a different UOW.","Processing is similar to what is documented in CSQE_Get_Out_Of_SyncPoint above. The most eligible message  is moved from the put list  to the shared queue manager 's uncommitted get queue  and a TROP  is created to track the operation. Upon return to data manager , the next request that could be seen for the UOW is one of the following: (1) (2) get (in or out of syncpoint); put (in or out of syncpoint); (3) commit; (4) abort; (5) prepare; (6) sync last message; or (7) backout last message.","The difference in processing when compared to CSQE_Get_Out_Of_SyncPoint is that an uncommitted put that was put by the UOW may be returned in response to the UOW's get request. Whenever a TROP  for an uncommitted put is added to a TRQS-anchored TROP chain, CSQETHDP  examines all TROPs  that represent uncommitted puts and calculates two values: (1) the highest-priority uncommitted put written by this UOW (ignoring the persistence attribute); and (2) the highest-priority uncommitted persistent put written by this UOW.","Here are some examples to demonstrate the concept:","A UOW puts 5 messages , M through M, all of the same priority. M and M are put out of syncpoint. M is in syncpoint, message is nonpersistent. M is in syncpoint, message is persistent. M is put out of syncpoint. At the end of these five puts, the order of messages  on the list header  are M, M, M, M, M, as shown in FIG. A. (The messages  put out of syncpoint are committed \u2018immediately\u2019).","Best overall uncommitted message is M, best overall persistent message is M. (Remember that message M was written after M and M so M has a later timestamp value in its key than M and M). Next, 5 get in syncpoint requests are issued: order of messages  returned is: M, M, M, M and M. The UOW is returned uncommitted puts in response to its get request.","A UOW puts 5 messages , M through M, all of the same priority. M and M are put out of syncpoint. M is in syncpoint, message is nonpersistent. M is in syncpoint, message is persistent. M is put out of syncpoint. At the end of these five puts, the order of messages  on the list header  are M, M, M, M, M, as shown in FIG. A. Best overall uncommitted message is M, best overall persistent message is M. (Remember that message M was written after M and M so M has a later timestamp value in its key than M and M). Next, 5 get requests are issued specifying get in syncpoint if persistent: order of messages  returned is: M, M, M and M. M is NOT returned because it is nonpersistent and the get request only wants committed messages  or persistent uncommitted puts that it wrote returned.","A UOW puts 5 messages , M through M, M, M, M and M each with inverted priority  (lowest priority). Message M inverted priority  (highest priority message). M and M are put out of syncpoint. M is in syncpoint, message is nonpersistent. M is in syncpoint, message is persistent. M is put out of syncpoint. At the end of these five puts, the order of messages  on the list header  are M, M, M, M, M, as shown in FIG. B.","Best overall uncommitted message is M, best overall persistent message is M. (Remember that message M was written after M and M so M has a later timestamp value in its key than M and M). Next, 5 get in syncpoint requests are issued specifying get in syncpoint: order of messages  returned is: M, M, M, M and M.","A UOW puts 5 messages , M through M, M, M and M each with inverted priority  (lowest priority message). Message M priority inverted . M inverted priority . M and M are put out of syncpoint. M is in syncpoint, message is nonpersistent. M is in syncpoint, message is persistent. M is put out of syncpoint. At the end of these five puts, the order of messages  on the list header  are M, M, M, M, M, as shown in FIG. C.","Best overall uncommitted message is M, best overall persistent message is M. (Remember that message M was written after M and M so M has a later timestamp value in its key than M and M). Next, 5 get in syncpoint requests are issued specifying get in syncpoint: order of messages  returned is: M, M, M, M and M.","The following describes how CF Manager  returns the most appropriate message . In general, whenever a TROP  is added to the TRQS-anchored TROP chain that represents a put in syncpoint nonpersistent or a put in syncpoint persistent, CF Manager  calculates the best overall uncommitted message  and the best overall uncommitted persistent message . A pointer to these two TROPs  (provided they exist) as well as the corresponding uncommitted key is created. The field names are:\n\n","When a TRQS  is allocated (because of the first get or put for a shared queue ) the two fields (eTRQS_Best_Overall_Key and eTRQS_Best_Persistent_Key) are initialized to CSQE_Committed_Key_Comparator (X\u20180A00 . . . 00\u2019). If a best candidate uncommitted message  does not exist the field(s) are set to X\u20180A00 . . . 00\u2019.","If the first operation for a TRQS  is a get in syncpoint then the IXLLSTE invocation specifies:\n\n","The value for Key_Of_Message_To_Move is set to eTRQS_Best_Overall_Key, which initially is by X\u20180A0000 . . . 00\u2019. If there is a committed message  on the list header , then it will be returned because its key is guaranteed to be less than X\u20180A00 . . . 00\u2019.","Now suppose that the unit of work does a put in syncpoint nonpersistent. Since this is a put in the unit of work, CF Manager  calculates the message's corresponding committed key and places it in field eTRQS_Best_Overall_Key and initializes the TRQS pointer field to the address of the corresponding TROP . If the unit of work does another get in syncpoint request, then the value for the variable Key_Of_Message_To_Move is set from eTRQS_Best_Overall Key. When the IXLLSTE request executes it examines the list entry (if any) at the head of the list. If its key is less than or equal to the committed key of the best overall uncommitted message , then the committed message  at the head of the list is returned. If the list entry at the head of the list has a: key that is greater than the value specified in variable Key_Of_Message_To_Move then the move operation fails and CF Manager  returns to the caller the uncommitted put that it previously wrote. The corresponding TROP  is updated to indicate an operation of get (and not put since the message  has been read).","The same processing is performed for CSQE_Get_In_SyncPoint_If_Persistent with the exception that the value in variable eTRQS_Best_Persistent_Key is copied into field Key_Of_Message_To_Move.","Buffer Sizes","CSQEMGE issues an IXLLSTE to move an entry from the put list header  to the shared queue manager 's uncommitted get queue . The move request also specifies DATAOPER(Tail) so that the contents of the message  can be read into processor virtual storage. When the IXLLSTE Move request is issued the size of the list entry to be read is unknown.","If the message  to read is small (less than or equal to 4K) and CF Manager  specifies a buffer greater than 4K then the move request is likely to go asynchronous. If in this case a buffer size of 4K was specified then it is highly probable that the move request would have completed synchronously. On the other hand, if MQSeries specifies a 4K buffer and the data to be read into processor storage is greater than 4K, the IXLLSTE Move request fails with a reason code that indicates that the buffer is too small to contain the list entry. In this case MQSeries needs to redrive the move operation, this time specifying a large enough buffer. In this second case, it took two access to the CF to retrieve the message data.","With this in mind, CSQEMGE implements the following algorithm: the buffer passed to CSQEMGE is always 64K in size. The first time MQSeries attempts to move the message  it specifies a buffer size of 4K on the move request. If a reason code of zero is returned, the operation is complete and control returns to the caller. If the reason code indicates that the buffer is too small then the IXLLIST request is redriven, this time specifying a buffer size of 64K. If the reason code from this request is zero, control returns to the caller. Otherwise a different type of error was encountered which CSQEMGE then handles.","Because of the parallel nature of shared queues , the following could have happened: CF Manager  issued the IXLLIST Move request and it failed with a reason code of buffer too small. Before we can redrive the move request with the 64K buffer another queue manager moves the message (and there are no more messages  on the queue) so that when MQSeries redrives the move it gets a return code back indicating no entries on the list.","GET PROCESSING\u2014BROWSE: CSQEMGE","To \u201cbrowse\u201d a message is to use the MQGET call to copy a message without removing it from the queue. This contrasts with \u201cgetting\u201d a message, which is using the MQGET call to remove a message from a queue.","This module is responsible for nondestructively reading messages  from a shared queue . That is, the selected message  is copied into a virtual storage buffer but it is not moved to the shared queue manager 's uncommitted get queue ","The interface into CSQEMGE is:\n\n","Parm_Index_Key: if Parm_Input_Options is qualified with \u2018CSQE_Get_With_Key\u2019, then this parameter contains either a message or a correlation ID depending on how the shared queue  is indexed. If indexed by message ID then this parameter contains a message ID. If indexed by correlation ID then parameter contains a correlation ID.\n\n","The following sections discuss CSQEMGE processing with respect to nonindexed shared queues . A subsequent section discusses the processing for indexed shared queues .","CSQE_Get_Browse_First","This function code requests that the highest-priority committed message  (if any) be returned nondestructively. An uncommitted message  can never be returned in response to this function code. The highest-priority message  is read into virtual storage if one is available. The returned list entry remains on the put  list available to all other types of get requests. The net is that the committed message  at the head of the list is returned.","The IXLLSTE Invocation is:\n\n","This IXLLSTE invocations read the first committed message  (if one exists) from the head of the list. EntryType(Old) says that the entry must exist; if no such entry exists the read will fail.","KeyToRead is set to X\u2018000000000000 . . . 00\u2019. The above IXLLSTE invocation tells the CF  to find the first entry on the list with a key value greater than or equal to binary zeros and to return it in the specified buffer. The above invocation may return an uncommitted message . When this happens the caller receives a return code indicating that no message  is available.","If a committed message  is returned, the value of Parm_Token is set to the key of the entry read. The Token is used on a browse get next call.","CSQE_Get_Browse_Next","This function code requests that the next committed message  with a key greater than or equal to the key of the last message  returned on a browse request be returned. The token that was returned on a browse first or a browse next request is passed as an input The token is the corresponding committed key of the message  returned in response to the get first\/browse call. The low-order four bytes of the committed put key are not used and are always binary zeros. The CF Manager  constructs a key in anticipation of issuing an IXLLSTE request. It takes the input Parm_Token and places X\u201800000001\u2019 in the low-order four bytes of the key. It then issues its IXLLSTE request asking for the next message  with a key greater than or equal to the newly constructed key. This invocation returns the next message  (if any) with a key greater than the key of the message  returned on the previous invocation. If an uncommitted put or the LHQC is read no message  is returned and the return code is set to no message available.","The IXLLSTE Invocation is:\n\n","Get Processing\u2014CSQEMGE: Get Under Cursor","This function code requests that CF Manager  return the message  to which the cursor points. The cursor is initially set via get browse first and updated across get browse next requests.","The interfaces into CSQEMGE is:\n\n","This function code requests that CF Manager  return the message  to which the cursor points. The cursor is initially set via get browse first and updated across get browse next requests.","The message  to which the cursor points to may no-longer exist. Since browse requests are nondestructive another get request (CSQEMGE) or get under cursor request (CSQEMGE) may already have read the message .","The IXLLSTE invocation is:\n\n","This IXLLSTE invocation read the first committed message  (if one exists) from the head of the list. EntryType(Old) says that the entry must exist, if no such entry exists: the read will fail.","Key_To_Read is set to X\u2018000000000000 . . . 00\u2019. The above IXLLSTE invocation is telling the CF to find the first entry on the list with a key value greater than or equal to binary zeros and to return it in the specified buffer. The above invocation may return an uncommitted message . When this happens the caller receives a return code indicating that no message  is available.","If a committed message  is returned, the value of Parm_Token is set to the key of the entry read. The Token is used on a browse get next call.","A request to read a committed put may fail because a committed message  that meets caller requirements does not exist. For example: (1) request to get a message  from a nonindexed queue and no committed messages  exist; (2) a request to get a message  by message ID or correlation ID from an indexed shared queue  and no committed message  with the corresponding message ID or correlation ID exists; or (3) a request to get a message  by both message ID and correlation ID and no committed message  with a matching message ID and correlation ID exists","In these cases CF Manager  returns a return code indicating that no entry is available. Data manager  upon receipt of this return code calls a CSQEBMO module  (the stub module is CSQEBMON module \u2014begin monitoring) to request either list transition or sublist monitoring support.","CSQEBMON \/CSQEBMO","This is the interface into CSQEBM:\n\n","This section describes the processing that is done for CSQE_GetWaitRequest and CSQE_GetWaitSpecificRequest.","List Transition Vectors","A list transition vector is a set of bits, a multiple of 32 bits, in processor storage in the processor where the shared queue manager is executing. XES  provides interfaces that allows the CF Manager  to associate a list header  in a list structure  with a specific vector bit. For simplicity, CF Manager  (within a list structure ) associates list header  (shared queue ) with vector bit , list header  (shared queue ) with vector bit , . . . list header  with vector bit . If the CF Manager  is monitoring list header  for transitions from empty to not-empty transitions across the monitored committed range, then when an eligible message  arrives, XES  turns on the vector bit that corresponds to the list header that just transitioned and drives a list transition exit of the monitoring shared queue manager . Both lists and key ranges within lists can be monitored for such transitions.","Nonindexed Queues","This section details the processing performed when CF Manager  indicates to its caller that no committed message  (on a nonindexed shared queue ) exists. The application specifies that if no committed message , exists then it is to be suspended until a committed message  can be returned.","Data manager  calls CSQEBMO with the request CSQE_GetWaitRequest. This instructs CF Manager  to monitor the committed key range  of the put list header  for transitions from the empty to the not-empty state.","Let's analyze the IXLLSTC request that is used to begin the key range monitoring:\n\n","The ability to monitor a key range is new architected function provided in coupling facility , as described in the referenced related application.","Monitor_Keyrange requests that key range monitoring of the list specified by the ListNum keyword be started for a particular key range that has previously been defined.","As for where the key range gets initialized, during open shared queue processing, a CSQEOPEN  module calls a CSQESLCT module  (set list controls). Here is the IXLLSTC invocation in, module CSQESLCT :\n\n","Assuming that the values of the keywords associated with triggering are set to the MQSeries default, then:\n\n","The IXLLSTC invocation above simply initiates list transition monitoring. Using the assumptions above and further assuming that the committed key range of the put list header  is empty, then when the first message  appears within the committed range  (either because an uncommitted put is committed or an uncommitted get of a committed put is backed out) the associated CF Manager 's list transition exit is scheduled. Upon notification of the list transition, data manager  is informed that it can redrive pending get waits that are suspended waiting for a committed message  to appear on the committed portion of the list header .","Of course, if there are multiple get waiters and one message  materializes, it is unpredictable which get waiter actually retrieves the committed message . Several sharing queue managers  can thus share their work.","Indexed Queues","A request can be made for a message  with a specific message or correlation ID. A shared queue  can be indexed by either message ID or correlation ID and not both. As discussed earlier, a message's secondary key (representing the message ID or correlation ID) is not assigned until the message  is committed.","When a Get Wait request is made specifying a message or correlation ID, CF Manager  attempts to find a list entry with the corresponding secondary key. If no message  with the specified secondary key is found, a return code is set indicating no entry available.","Upon receipt of this return code, data manager  calls CSQEBMO with a function code specifying CSQE_GetWaitSpecificRequest. Note that monitoring on the committed key range (described above) only informs us that a committed message  has arrived with a key in the key range and provides no indication when a message  with a specific (entry or secondary) key arrives on the list.","So in response to CSQE_GetWaitSpecificRequest, CF Manager  initiates sublist monitoring. A sublist is a set of zero or more entries that share the same entry Dr secondary key. XES  provides an interface in which CF Manager  can be informed when the first message  with a user-specified entry or secondary key first appears on the monitored list. When a message  with the specified key is placed into the list, an EMC  is queued to the monitoring shared queue manager 's event queue , the corresponding list transition vector bit is set on and then the shared queue manager 's list transition exit scheduled.","Here is the monitor sublist invocation specified by CF Manager :\n\n","Before analyzing the above invocation, a few other explanations are needed.","Each connection to a list structure  is assigned its own event queue . That is, there is one event queue  per list structure connection. In the disclosed embodiment, there are two such event queues: one for primary key events, the other for secondary key events. Either or both can be used or monitored.","When a list entry  with a key appears on a list that is being monitored, an Event Monitor Control (EMC) entry  is queued to the monitoring queue manager(s) event queue  and the bit in the list transition exit that corresponds to the event queue  is set on. Then the connection's list transition exit is invoked.","CF Manager  assigns a vector bit to the event queue . Bit CSQE_Monitor_EventQ_VectorBit (whose value is zero) is assigned to the event queue . When a list entry with a monitored key appears on the monitored list, an EMC  is queued to the monitoring shared queue manager 's event queue  and bit CSQE_Monitor_EventQ_VectorBit is turned on and the corresponding list transition exit is scheduled.","Before CF Manager  can monitor a sublist (or a set of sublists) it tells XES  that it wants to monitor its event queue  and what bit it has assigned for the event queue . This processing is done in a CSQECONN module . The invocation is:\n\n","Now back to the Monitor_Subist invocation described above. UNC stands for User Notification Controls. CF Manager 's use of this field is mapped by a CSQEUNC module . This 16-byte value is included in the EMC  that is queued to the shared queue manager 's event queue . When CF Manager  recognizes that its event queue  has transitioned, it issues an IXLLSTC Request(DEQ_EVENTQ) macro to retrieve the queued EMC  into virtual storage. One of the component fields in the EMC  is the UNC value that was specified when sublist monitoring was initiated.","The control information in UNC helps CF Manager  to identify the reason why the EMC  was queued (CSQE_Identifier), the structure and list header with structure that the EMC  is for, the Data Manager Token associated with the shared queue  and the shared queue token which identifies the shared queue .","CF Manager  then calls a CSQEMLTRX module  to inform it of the transition passing on the call the following data:\n\n","Synchronization Services: CSQESYN","This program is responsible for committing, aborting or preparing a unit of work.","This is the interface into CSQESYN:\n\n","The commit of a unit of work is a two-phase process. The first phase of commit is CSQE_Commit_UOW_Begin. When CSQESYN receives this directive it marks the thread block  () to indicate \u2018in commit\u2019 and then calls CSQEWUOW  to write one or more UOW descriptors (eUOWDs)  () described below to the shared queue manager 's UOW list header, which resides in the queue-sharing group's administrative structure. The thread block structure  indicates that the UOW is in begin commit state. In the thread block structure  is maintained state information. Before setting the begin commit indicator in the thread block , a check is made to insure that the value of ethr_State  is binary zeros. If not binary zeros, an abend is issued (CSQE_Inconsistent_Thread_State). After writing the UOW descriptors  control returns to the caller.","Data manager  then calls CSQESYN again, this time specifying a function code of CSQE_Commit_UOW, which initiates phase  of commit processing. A call is made to CSQEWUOW  to change the status of the unit of work from \u2018begin commit\u2019 to \u2018in commit\u2019. (The processing that occurs in CSQEWUOW  is documented in the section devoted to CSQEWUOW ). This phase of commit processes the TRQSes  from left to right. Queue  is committed first, followed then by queue  and then by queue  in structure . For each TRQS  processed, the corresponding queue of TROPs  are processed in priority\/time sequence order. The thread block structure array entries  are processed from entry  to . That is, after the TRQSes  and TROPs  for structure  are processed, structure  is processed, then structure , . . . then structure . In other words, commit processing is done a structure  at a time beginning with structure  and finishing with structure .","If the TROP  represents a get request, the list entry  is deleted from th(e shared queue manager 's uncommitted get queue . The information needed to delete the list entry  is in the TRQS  and the TROP .","If the TROP  represents a put request, the list entry  is moved from the uncommitted portion  of the put list header  to the committed portion , that is, the entry's key is changed from a uncommitted to a committed key. The information needed to move the list entry is in the TRQS  and the TROP . If the put specified a secondary key (i.e., the TRQS  indicates that the shared queue  is indexed), then the secondary key is assigned as part of the move from the uncommitted portion  to a committed portion  of the PLH .","Note: An uncommitted put written by a UOW may have been returned to the UOW in response to a get request. In that case, the original TROP  (representing the put) is updated in place to indicate that it now represents a get request. After the put is turned into a get the next function code that CSQESYN might see for the UOW is to backout the last message  because it would not fit into the caller's buffer and the caller does not accept truncated messages . In this case, the TROP  is again updated in place to indicate that it now represents a put request.","After this second phase of commit processing is complete, module CSQEWUOW  is called and told to delete the UOW descriptors  for this UOW, and then CSQETHDP  is called to collapse the thread-tracking structure: that is, to delete all the TRQSes  and TROPs .","When phase  commit begins, CSQESYN first checks to see if the ethr_State  is in prepare. If it is in prepare state, a call is made to CSQEWUOW  to change the state in the UOW descriptor  from \u2018in prepare\u2019 to \u2018committed\u2019.","More Detail: Commit processing obtains two buffers: one is used to specify the set of messages  to be deleted. Gets that are committed are deleted. The other buffer is used to specify the set of messages  to be moved. Uncommitted puts that are committed are moved from the uncommitted portion  to the committed portion  of the put list header . Commit processing processes one TRQS  at a time. This means that the move or delete buffers only contain data that map to a particular shared queue  as represented by a TRQS . With respect to committing puts, there are two choices of move interface to use:","If the shared queue  represented by the TRQS  is not an indexed queue, then the uncommitted puts need to be moved from the uncommitted portion  to the committed portion  of the PLH  by being given its corresponding committed key. An IXLLSTM Request(Move_EntryList) is issued. The buffer is mapped by IXLYMELI (MELI=Move_EntryList). The MELI interface allows a set of entries to be specified by their corresponding PLEID. For each vector entry, the new key to be assigned to the entry that is being moved is specified (MELI_Target_Key).","If the shared queue  represented by the TRQS  is an indexed queue, then the uncommitted puts need to be moved from the uncommitted portion  to the committed portion  of the list header  by being given its corresponding committed entry key and its secondary key must also be assigned. In this case, the buffer specified on the IXLLSTM Request(Move_EntryList) is mapped by IXLYMELI. This mapping of the buffer allows CF Manager  to specify the entry's secondary key as well as its committed entry key.","(XES  determines if the buffer is mapped by MELI or MELI as follows: MELI: MoveToKey(TargetKey) and MoveToSKey(Unchanged) specified\/defaulted. MELI: MoveToSKey(TargetKey) specified. A MELI interface is supported which CF Manager  does not use in CSQESYN. MELI allows the movement of an entry between lists without changing its entry key. That is MoveToKey(Unchanged) and MoveToSKey(Unchanged).)","With respect to committing uncommitted gets, the list entries are deleted. CSQESYN uses the IXLSTMRequest(Delete_EntryList) interface, which allows the specification of a set of PLEIDs that represent the list entries to be deleted. The buffer specified on the Delete_EntryList request is mapped by IXLYDELI (in which DELI signifies Delete_EntryList).","The call to move or delete the list of PLEIDs may time out before all entries in the buffer are processed. CSQESYN handles this return code and when received redrives the request specifying the first unprocessed entry, within the Move_EntryList or Delete_EntryList, in the buffer.","Aborting a UOW","Aborting a UOW is a one-phase process, that is, there are not two calls from data manager  as there are for the commit case documented above. CSQESYN first checks to see if the ethr_State  is in prepare. If it is in prepare state, a call is made to CSQEWUOW  to change the state in the UOW state from \u2018in prepare\u2019 to \u2018abort\u2019. Otherwise, CSQEWUOW  is called to write one or more eUOWDs  for the unit of work to be aborted. CSQEWUOW  indicates that the UOW is in abort.","Aborting a unit of work is very similar to the commit processing in that Delete_EntryList and Move_EntryList buffers are obtained. A major difference is that uncommitted puts are deleted and uncommitted gets are moved back to the list header  from which they came.","After abort processing is complete, module CSQEWUOW  is called and told to delete the UOW descriptors  for this UOW and then CSQETHDP  is called to tear down the thread tracking-structure: that is, to delete all the TRQSes  and TROPs .","Backout Last Message","When this routine is invoked one of the following operations were requested immediately prior to this backout last message call:\n\n","In either case, it is determined that the message  will not fit into the user's supplied buffer and the user does not accept truncated messages . If the TROP  represents a committed put that was returned to the previous get request, the list entry is moved back to the put queue and the TROP  is deleted. If the TROP  represents an uncommitted put that was returned to the previous get request then the TROP  is updated in place to look again like a put.","The request to backout the last message  is assumed to immediately follow the get of the message . This means that there are no intervening requests for the UOW between the get and the backout last message call.","Prepare","Preparing a UOW is a one-phase process. CSQESYN first checks to see if the ethr_State  is in any state other than the null state. If ethr_State  is nonzero then the request to prepare is abended.","Prepare then calls CSQEWUOW  to write the UOW descriptors  and to indicate that the UOW is prepared. The next request expected to be seen for the UOW is either commit UOW or abort UOW.","Mark Skip BackOut","Mark Skip Backout support allows an application to identify a single message  it has read within a UOW to not be a participant in UOW backout (abort) processing.","For example, if a unit of work read  messages , M through M, it could identify message M as \u2018mark skip backout\u2019. If the UOW requests a backout (abort), then messages M through M are moved backed to the put list headers  from which they came while message M remains on the shared queue manager 's uncommitted get queue . Message M is now in a UOW which will eventually be aborted or committed. Only one message  read in a UOW can be marked \u2018skip backout\u2019. CF Manager  supports this semantic for shared queues .","The intent is that the message  remaining on the shared queue manager 's uncommitted get queue  (M in the example scenario above) is committed, which means it is deleted.","CSQESYN insures that the mark skip backout token (Parm_Token) passed on input is valid. The token, 8 bytes in length, is composed of a four-byte TRQS address and a four-byte TROP address. If then insures that the corresponding TROP  does in fact represent a get operation. It also insures that this is the first request to mark a get as mark skip backout. One and only one get within a unit of work can be so marked. Any attempt to mark more than one get as mark skip backout results in an abend being issued.","The next section of this document discusses the CF Manager implementation of the mark skip backout function.","MQSeries provides facilities to limit the number of messages  on a local queue. If the limit is specified as N then there cannot be more than N messages  on the queue.","This concept is carried over to shared queues . When a limit of N is specified for a shared queue , it means that there cannot be more than N committed and uncommitted puts on the corresponding list header . The number of list entries that can be on a list is specified in the associated list controls and is updated via the IXLLSTC service. Its value is changed whenever a command is issued that changes queue depth. Let's look at some examples.","Assume that queue depth is specified as 10 and that the initial state of the list is empty.","A unit of work puts 10 messages  and they are initially in the uncommitted state. If the UOW attempts to put the eleventh message , the CF prohibits it and CF Manager  receives a list full return\/reason code. This error condition is returned to the caller.","Assume that there are 10 messages  (either committed or uncommitted, it does not matter) on the put list header  and the list limit (queue depth) is set to 10. While in this state, a command is issued that changes the queue depth to 5. The change is accepted and list controls is updated to indicate a list limit of 5. The 10 messages  that are already resident on the list remain on the list. Any subsequent put while there are more than 5 messages  on the queue are rejected with the list full return\/reason code.","The queue depth specified for a shared queue  is modified by the CF Manager  because there is another control entry that resides on the put list header , namely the LHQC. So if an installation requests a queue depth of 10, CF Manager  actually puts the value 11 in list controls to take into account the existence of the LHQC.","Let us examine another scenario: queue depth is set to 10. There are 10 committed messages  on the put list header . A unit of work reads 5 of the messages  and has not yet committed or aborted. There are 5 messages  on the put list header , 5 messages  on the shared queue manager 's uncommitted get queue . Another unit of work writes an additional 5 messages  so that there are now 10 messages  on the put list header . Next the unit of work that did the 5 gets decides to abort (backout). As described in other parts of this document, the backout process moves the messages  previously read back to the put list header  from whence they came. Since there are already 10 messages  on the put list header , the attempt to move the 5 gets back to the put list header  will fail with return\/reason code list full. However, MQSeries must be able to move the messages  back regardless of the queue depth setting of the target list header .","This could be solve programmatically: CF Manager  could temporarily increase the list limit, perform the move operations, and then reset the list limit back to what it should be. This would be extremely complex to implement because:\n\n","New puts to the put list header  need to be inhibited during the time interval that the list limit has been temporarily increased. Restart\/Peer Level Recovery would need to reset the list limit and uninhibit subsequent put requests.","In support of shared queues , the CF Architecture was extended to indicate on particular move operations that the list limit specification for the list is to be ignored. Hence when the CF Manager  aborts gets, it specifies that the list limit of the list to which the entries are being moved back is to be ignored. The extension of the architecture allows the list limit to be ignored but does not allow the entry's data to be changed. That is, it is not possible for the CF Manager  to say move an entry from one list header to another ignoring list limit on the target list and modify the entry data.","There are two other cases where the CF Manager  requests that target list limits be ignored when moving list entries:\n\n","CF Manager  keeps track the number of times a message  that has been read (moved from the put list header  to a shared queue manager 's uncommitted queue) has been rolled back (i.e., moved back to the put list header  from whence it came). This maps the same semantics that are supported for local queues to a shared queue environment. CF Manager  caps the rollback count at 255 to be consistent with local queues.","Each list entry has an associated 8-byte version number. When a list entry is created (put processing) the entry's version number is set to zero. Whenever a message  is moved from the shared queue manager 's uncommitted get list header  back to the put list header  from whence it came, its version number is increased by . Whenever a message  is read, (CSQEMGE, CSQEMGE and CSQEMGE) its version number is captured and the rollback count (up to a maximum value of 255) is returned to the caller across the interface.","CSQEWUOW : Write UOW Descriptors","This module is responsible for writing UOW descriptors  to a shared queue manager 's UOW list header in the administrative structure. A unit of work descriptor is mapped by CSQEUOWD.","The interface into CSQEWUOW  is:\n\n","CSQEWUOW  is responsible for writing UOW descriptors (eUOWDs)  for a unit of work when the UOW commits, aborts or prepares. A unit of work descriptor is 4K bytes in size and contains key information needed for shared queue manager  restart and peer recovery. eUOWDs  allow a peer connection to forward complete a UOW marked \u2018in commit\u2019 or \u2018abort\u2019. The UOW descriptor  contains a subset of information from TRQSes  and TROPs . A UOW descriptor  is shown in FIG. .","If a unit of work accessed queues in two structures , then a minimum of two UOW descriptors  are written. The first UOW descriptor  represents the shared queues  accessed (and their associated operations) in structure , the second UOW descriptor  represents the same information but as it relates to structure .","Based on the number of shared queues  accessed in a unit of work as well as the number of operations issued, it may not be possible to store all information in a single UOW list descriptor.","Support is provided for writing multiple UOW descriptors  per list structure  accessed in the unit of work. The last four bytes of the UOW descriptor  are a sequence component. The first entry begins with sequence number zero.","Assume a UOW commits after having accessed shared queues  in two different structures . Two UOW descriptors  need to be written for list structure , and two UOW descriptors  need to be written for structure  for the UOW, the four keys (in sequence) are:\n\n","The first byte of the key identifies the list structure . The TRQSes  and TROPs  in the eUOWD  all reference the same list structure . XXXXXXXXXXXXXXXX represents the unit of work ID. The next three bytes are always binary zero. The final four bytes are a sequence number component. For structure  and  above, there is part  of  and part  of . Information in the first eUOWD  written for a structure  indicates how many parts (eUOWDs) were written for the unit of work. Recovery processing can then determine if only a partial set of eUOWDs  were written for a UOW\/Structure. This would occur when the shared queue manager  that is writing the eUOWDs  fails before they are all written.","The eUOWD list entry key field is mapped by a CSQEUOWK module .","Before a UOW descriptor  can be written, CSQEWUOW  first needs to determine how many 4K list entries are needed. This is so that it can initialize the \u2018number of list entries\u2019 field in the header of the first UOW descriptor .","It then flattens key information from the TRQSes  and TROPs  (as detailed in ) and then writes the UOW descriptor . If multiple UOW descriptors  need to be written, UOW descriptor sequence zero is written first, followed by UOW descriptor sequence , and so forth. The UOW descriptors  are in key sequence by numeric structure ID on the shared queue manager 's eUOWD list header.","If a unit of work has accessed only one structure  then the status of the unit of work is represented in the adjunct area of the first eUOWD written for a structure . The processing is different for a unit of work that has accessed multiple structures . The processing that is done in that case is discussed in \u201cMulti Structure Units of Work\u201d below. The next few sections assume that the UOW has accessed only one list structure .","Commit UOW Begin","This code writes the UOW descriptors . Control block structure maintained by CSQETHDP  persists (TRQSes  and TROPs ). eUOWD adjunct indicates begin commit. ETHR_STATE  indicates begin commit. Control then returns to the caller.","Commit UOW End","This code gets control from CSQESYN when it is told to CSQE_Commit_UOW. eUOWD adjunct indicates in commit. When the commit process is completed, there is another call to CSQEWUOW  from CSQESYN this time requesting CSQE_Delete_Admin_Table_Entries at which point the UOW descriptors  are deleted from the administrative structure.","Prepare UOW","This code writes the UOW descriptors . In the adjunct of the first UOW descriptor , the status indicated is \u2018in prepare\u2019. Control block structure maintained by CSQETHDP  persists (TRQSes  and TROPs ). ETHR_STATE  indicates begin commit. Control then returns to the caller.","Prepare to Commit","This code gets control when it CSQESYN is told to commit a UOW that has been previously prepared, hence the transition from prepared state to commit state. The adjunct area is changed to indicate that the UOW is in commit. The adjunct area is updated and control returns to CSQESYN, which then commits the UOW. When the commit process is completed, there is another call to CSQEWUOW  from CSQESYN this time requesting CSQE_Delete_Admin_Table_Entries at which point the UOW descriptors  are deleted from the administrative structure.","Prepare to Abort","This code gets control when it CSQESYN is told to abort a UOW that has been previously prepared, hence the transition from prepared state to abort state. The adjunct area is changed to indicate that the UOW is in abort. The adjunct area is updated and control returns to CSQESYN, which then aborts the UOW. When the abort process is completed, there is another call to CSQEWUOW  this time requesting CSQE_Delete_Admin_Table_Entries at which point the UOW descriptors  are deleted from the administrative structure.","Abort UOW","This code gets control from CSQESYN when it is told to CSQE_Abort_UOW. The adjunct area is changed to indicate that the UOW is in abort. The adjunct area is updated and control returns to CSQESYN, which then aborts the UOW. When the abort process is completed, there is another call to CSQEWUOW  this time requesting CSQE_Delete_Admin_Table_Entries at which point the UOW descriptors  are deleted from the administrative structure.","Delete Administrative Table Entries","This code simply deleted the UOW descriptors  from the administrative table for the now complete UOW. If more than one UOW descriptor  was written for the UOW, they are deleted in LIFO order.","Multi Structure Units of Work","A unit of work can access multiple application list structures . This occurs when the set of queues accessed by a unit of work do not all map to the same CF list structure . Consider the following example: Shared Queue (SQ) A maps to STR, SQ B maps to STR and SQ C maps to STR C. A unit of work opens SQ A, SQ B and SQ C and does a put to each shared queue .","When a unit of work reaches a syncpoint, eUOWDs  are written that detail the shared queues  accessed and the operations performed against those queues by the unit of work. This is performed by module CSQEWUOW . At least one eUOWD  is written for each structure  accessed by the unit of work. An eUOWD  is currently 4096 bytes in size. It may not be possible to represent all the queues and operations performed against queues in the structure  in 4096 bytes. In this case, additional eUOWDs  may be written in which case they are numbered part m of n.","Assume a UOW that accessed shared queues  across three list structures . Two eUOWDs  are required to represent the queues\/operations targeted to list structure . Pictorially we have what is shown in FIG. .","When a shared queue manager  fails, surviving peers are notified of the peer's failure on a structure by structure basis. Thus, CF Manager  performs recovery on a structure by structure basis.","Consider the following topology: three shared queue managers : SQM , SQM  and SQM . SQM  and SQM  are connected to structures Str , Str  and Str . SQM  is only connected to Str . When SQM  fails SQM  is informed about SQM 's connection failure to structures ,  and . SQM  is only informed of SQM 's connection failure to Str . In the case of SQM , it can recover structures ,  and  in parallel.","If more than one eUOWD  needs to be written, it is impossible to write them all in an atomic fashion. Using the example above, it would take four separate IXLLSTE operations to write the four eUOWDs . The shared queue manager  writing the eUOWDs  may fail part way through the process of writing the set of eUOWDs .","To support UOWs that access multiple CF list structures , the CF Manager  uses a construct called a \u2018multistructure unit-of-work summary entry\u2019 (MUSE) , as shown in FIG. .","The MUSE  is mapped by a CSQEMUSE module .","The key of a eUOWD  is structure number.uow ID . . . sequence number.","The key of a MUSE  is structure number=0.uowid.binary zeros. (Structure number zero is used because a structure number of zero is never assigned) Since the UOWid field contains the shared queue manager  identification and a time stamp, it is not possible for two MUSEs  to have the same entry key.","For a multistructure unit of work each eUOWD  points to the MUSE . Field eUOWD_Key_Of_Corresponding_Muse points to the corresponding MUSE  provided this is a multistructure unit of work. If this is not a multistructure unit of work then this field is set to X\u2018FFF . . . FF\u2019. This allows restart\/peer level recovery processing to determine how to recover the unit of work. The components of the MUSE key are defined in a CSQEPKEY module .","Processing in CSQEWUOW  when writing the eUOWDs :\n\n","The following scenarios assume the thread waiting eUOWDs  fails at certain points and then details what peer level recovery processing does. (Peer level recovery is contained in the set of modules  named CSQERWI*). These scenarios further assume that the UOW disposition is abort or commit. Begin commit and prepare scenarios are discussed in the next session.","Note: All updates to the MUSE  use version number comparison logic. The processing detailed below occurs in CF Manager 's Recover Work In Progress (RWIP) component. The checks that are described below are also done when a shared queue manager  recovers a failed shared queue manager  that was recovering another failed shared queue manager  (rolling recovery scenarios).\n\n","A unit of work marked \u2018begin commit\u2019 or \u2018prepare\u2019 can only be recovered by the shared queue manager  that wrote the eUOWDs . In the case of \u2018begin commit\u2019, the final resolution of the unit of work (which eventually will be either commit or abort) is deduced from the shared queue manager 's private log. In the case of \u2018prepare\u2019, the final disposition of the unit of work must wait until RESOLVE time.","If a MUSE  exists and its current disposition is either \u2018begin commit\u2019 or \u2018prepare\u2019, then a peer instance of the shared queue manager  cannot recover the eUOWD . When a shared queue manager  determines that an eUOWD  is in either one of these two states, it looks for the another eUOWD . The corresponding MUSE  is not deleted. It will be recovered when the owning shared queue manager  restarts.","Thread Processing","CSQETHDP  keeps track of the highest number structure  accessed by the unit of work. This is maintained in the eTHRD control block. This information is used when writing out the eUOWDs  to the administrative structure.","SyncPoint Operations","The messages  read and put by a unit of work are eventually aborted, committed or prepared, henceforth referred to as a syncpoint operation. For nonrecovery scenarios, this syncpoint processing is implemented in CSQESYN (CF Manager SyncPoint Services).","CSQESYN processes the thread block structure , which consists in part of a 255 entry array, one entry  for each structure  that the unit of work may access. The syncpoint operation accesses the thread block structure  to perform the syncpoint event.","Syncpointing is done on a sequential basis\u2014this means that if structure one was accessed it is processed first, then followed by structure , and so on.","Thread block structure  is processed by array entry , from array entry  to the highest structure  accessed by the unit of work. For example, if a unit of work accessed structures ,  and  then only the first eight array entries  are processed (rather than looking at all 255 array entries). CSQEHTDP is responsible for monitoring the highest structure  accessed by the unit of work.","While a particular embodiment has been shown and described, various modifications will be apparent to those skilled in the art. While the invention has particular application in a Parallel Sysplex environment, it is not limited to such an environment and may be used in other environments as well."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"P-00058","num":"00058"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00059","num":"00059"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00060","num":"00060"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00061","num":"00061"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00062","num":"00062"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00063","num":"00063"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00064","num":"00064"},"figref":"FIG. 7"},{"@attributes":{"id":"P-00065","num":"00065"},"figref":"FIG. 8A"},{"@attributes":{"id":"P-00066","num":"00066"},"figref":"FIG. 8B"},{"@attributes":{"id":"P-00067","num":"00067"},"figref":"FIG. 8C"},{"@attributes":{"id":"P-00068","num":"00068"},"figref":"FIG. 8D"},{"@attributes":{"id":"P-00069","num":"00069"},"figref":"FIG. 8E"},{"@attributes":{"id":"P-00070","num":"00070"},"figref":"FIG. 8F"},{"@attributes":{"id":"P-00071","num":"00071"},"figref":"FIG. 9"},{"@attributes":{"id":"P-00072","num":"00072"},"figref":"FIG. 10"},{"@attributes":{"id":"P-00073","num":"00073"},"figref":"FIG. 11"},{"@attributes":{"id":"P-00074","num":"00074"},"figref":"FIG. 12"},{"@attributes":{"id":"P-00075","num":"00075"},"figref":"FIG. 13A"},{"@attributes":{"id":"P-00076","num":"00076"},"figref":"FIG. 13B"},{"@attributes":{"id":"P-00077","num":"00077"},"figref":"FIG. 13C"},{"@attributes":{"id":"P-00078","num":"00078"},"figref":"FIG. 14"},{"@attributes":{"id":"P-00079","num":"00079"},"figref":"FIG. 15"},{"@attributes":{"id":"P-00080","num":"00080"},"figref":"FIGS. 16A-16C"},{"@attributes":{"id":"P-00081","num":"00081"},"figref":"FIG. 17"},{"@attributes":{"id":"P-00082","num":"00082"},"figref":"FIG. 18"},{"@attributes":{"id":"P-00083","num":"00083"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
