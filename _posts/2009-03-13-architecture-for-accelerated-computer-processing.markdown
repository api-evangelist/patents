---
title: Architecture for accelerated computer processing
abstract: A data processing system includes a host computer, an additional computer, an application module including a first executable code, a module for analyzing said first executable code and a module for generating a second executable code segmented notably into code blocks which are executed in a preferential manner on one of the two computers. The second executable code includes a sub-module for managing the distribution of the processing operations between the host computer and the additional computer and a sub-module for managing the additional computer as a virtual machine which executes the blocks allocated to the additional computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713545&OS=08713545&RS=08713545
owner: Silkan
number: 08713545
owner_city: Meudon
owner_country: FR
publication_date: 20090313
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a National Stage of International patent application PCT\/EP2009\/052968, filed on Mar. 13, 2009, which claims priority to foreign French patent application No. FR 08 01420, filed on Mar. 14, 2008, the disclosures of which are incorporated by reference in their entirety.","The invention relates to the field of computers. More particularly, the invention relates to computers that process intensive loads, which may involve computer systems dedicated to graphical applications or numerical calculation applications, for example.","The invention relates to the field of computers which have to process intensive loads. This may involve computer systems dedicated to graphical applications or numerical calculation applications, but it may also involve processors included in signal or data processing chains. Intensive computing machines may be of different types. In most cases, they comprise a plurality of processors among which the parts of an application will be distributed, while the processors share common memory areas. In SMP (Shared Memory MultiProcessor) architectures, the processing operations are distributed among at least two processors which share access to the same common memory. In Distributed Memory Multiprocessor architectures, the distribution of the processing operations will depend on the relative locations of the different processors and stored data, i.e. on the physical architecture and not only on the application. A different form of parallelism may result from processor command instruction sets. This occurs, for example, in the case of SIMD (Single Instruction, Multiple Data) processing operations, in support of which specific instruction sets have been added to the normal instructions. Different instruction sets are thus known, notably SSE (Streaming SIMD Extensions) or AltiVec (trademark registered by Apple, IBM and Freescale Semiconducteurs to designate an SIMD instruction set operating on 128-bit vectors). Acceleration techniques also exist which are based on the realization that a single processor may be perfectly adapted to some of the processing operations that a computer has to perform, whereas, for certain applications, it may require assistance in the form of an additional processor installed on an add-on accelerator card. In this case, the traditional architecture most often involves all of the specialized applications being executed on the add-on card processor. The host structure processor is then underutilized since it will only manage the input\/output from the additional processor. For given performance levels, this may result in the need to overdimension the add-on card processor, which will inevitably incur additional cost. The architecture is therefore not optimal.","The present invention solves this optimality problem by providing means for distributing the processing operations of applications having intensive computing requirements among the host processor(s) and the add-on card processor(s).","For this purpose, the present invention discloses a data processing system including a host computer, an additional computer, an application module comprising a first executable code, a module for analyzing said first executable code and a module for generating a second executable code segmented notably into code blocks which are executed in a preferential manner on one of the two computers, wherein said second executable code comprises a sub-module for managing the distribution of the processing operations between the host computer and the additional computer and a sub-module for managing the additional computer as a virtual machine which executes the blocks allocated to said additional computer.","Advantageously, the analysis module of said data processing system receives as input the first executable code of said application and supplies notably as output metadata comprising the input points of code blocks likely to constitute computing hotspots, the data structures used by said hotspots and the libraries of subroutines called by said first executable code.","Advantageously, the metadata at the output of the analysis module constitutes input of the module for generating the second executable code.","Advantageously, the metadata at the output of the analysis module are validated or modified when the second executable code is executed.","Advantageously, the second executable code is executed in a preferential manner in user mode on the host computer.","Advantageously, the second executable code uses specifically optimized functions installed on a driver which connects the additional computer to the host computer.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer is programmed to control the execution of the basic blocks on the host computer.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer is programmed to allow the second executable code to control the application for the execution on the additional computer of blocks chosen on the basis of parameterizable criteria and to regain control of the application at the end of the execution of each block.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer is programmed so that the blocks of the second executable code are copies of blocks of the first executable code, said blocks of the first executable code being saved in a cache memory.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer includes instructions to detect the most active code blocks.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer is programmed in such a way as to switch the execution of the application to the blocks of the first executable code in order to process exceptions.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer is programmed to make copies of the application context according to parameterizable rules.","Advantageously, the sub-module for managing the distribution of the processing operations between the host computer and the additional computer includes a sub-module for managing a cache memory for executing the application in which the selected data structures are stored to be called by the blocks executed on the additional computer.","Advantageously, the sub-module for managing the additional computer is programmed to execute libraries of subroutines corresponding to execution profiles and semantics defined for specific applications. Advantageously, a virtual machine corresponding to a specific application is dynamically loadable before the launch of said application by the environment.","Advantageously, one of the profiles defines the additional computer as a vector machine.","Advantageously, one of the profiles defines the additional computer as suitable for operating according to a flow computing model.","Advantageously, the sub-module for managing the additional computer includes a high-level programming interface for programming the libraries for each profile.","Advantageously, the sub-module for managing the additional computer includes a low-level programming interface for programming the second executable code.","The use of an architecture according to the invention also offers the advantage that it allows the cost\/performance ratio to be improved by an order of magnitude. Moreover, the system offers great versatility and can be optimized for different applications and hardware environments.","In the continuing description, the following expressions are used interchangeably:\n\n","A typical example of use of the architecture according to the invention will be the connection of an additional computer to a host computer. This computer may be a stationary or portable unit. A case such as this is shown in . The computer  may be used by an engineer to execute intensive computing loads. In an alternative use, it may also be used as a gaming terminal, either offline or online with an Internet connection. The host computer is the standard processor of the portable computer such as an Intel Pentium\u2122 or Core Duo\u2122 installed on the motherboard of the portable computer. It may of course be a computer which is possibly used as an application server or data server of a network of client terminals which are connected to it. It may also be a specialized Digital Signal Processor (DSP). The additional computer  may in turn be a processor identical to the host computer or an additional processor (DSP for graphical applications and applications which executes many DCT or FFT (Direct Cosine Transform or Fast Fourier Transform) functions. A certain number of circuits must be associated with the additional computer, such as RAM memory circuits and storage elements. Code elements enabling the operation of the computers in cooperative mode as provided for by the invention are installed in these memory circuits. The software system accompanying the appliance is integrated to form a distributed environment between the front-end and the appliance. This environment provides both a static offline analyzer and an optimizing runtime. The environment is possibly extendable by libraries intended to facilitate the programming via an Integrated Development Environment (IDE) for specific application developments. The interfaces provided with the software infrastructure are of different levels, enabling a more or less fine control of this infrastructure. In particular, a driver provides the connection between the two computers. Where appropriate, these elements may be installed via an FPGA or ASIC (Field Programmable Gate Array or Application Specific Integrated Circuit) for the purpose of obtaining higher levels of performance. The external computer, possibly increased with these additional circuits, will normally be integrated into a housing connected to the portable computer via a USB (Universal Serial Bus) or IEEE1384 port. The housing will have a specific power supply. In the case of an office computer or a server, the additional computer and its proximity electronics may be installed on a card which is added to one of the available slots in the computer housing. It can also be envisaged that the additional computing resource is shared among a plurality of computers interconnected via a local network or via an Internet protocol.","As shown in , the system includes a module  for analyzing the application code  before execution. This module works on the application code in binary. Its purpose is to prepare the metadata structures that facilitate the work of the modified executable code before execution. The modified executable code is designated by the expression \u201cruntime\u201d or \u201csecond executable code\u201d. The application code normally executed on the host computer is designated by the expression \u201cfirst executable code\u201d. The metadata are host structures for data produced by the application code analysis. The module for analyzing the application code has the following functionalities:\n\n","The analyzer generates a set of metadata which prepares the work of the offline translator. However, the offline analyzer does not in any case modify the executables: these metadata are maintained independently from the program for implementation by the second executable code. A joint file is created which contains all of the information extracted from the application. The parts of the code most likely to become execution hotspots are translated into an intermediate language based on the x86 binary. The generation of the parts of the program that are intended for an execution on the accelerator is substantially facilitated by this transformation.","If the source code is available, the introduction of annotations by a programmer guiding the production of metadata by the code analyzer is possible.","The executable code of the application is converted into a second executable code structured in blocks, the execution of which is controlled by an application supervision and optimization environment. This supervision environment may be supported in some cases by specific libraries allowing parallelization of the execution between the two computers and implementation thereof in a possibly speculative manner. The speculative execution is based in particular on an anticipation of the loop output values, normally allowing time-saving. The LAPACK or Linear Algebra Package library can be cited as an example of a specific library for scientific computing.","The second executable code is structured in blocks which are likely to be executed either on the host computer or on the additional computer. It is executed via an environment playing both the role of a hypervisor  which controls the execution of the application on the host computer and the role of a virtual machine  which executes code blocks on the additional computer. This second executable code is executed insofar as possible in user mode on the host computer and not in system mode, insofar as a transition from user mode to system mode resembles a system call. However, for certain functions, this second code is supported by a driver  which provides the connection of the additional computer. The processing operations are arranged in such a way that calls to the OS (Operating System) of the host computer are minimized.","The hypervisor  shown in  is a software module which provides for the distribution of processing operations among a plurality of computers. The hypervisor according to the invention provides for the execution of the blocks of the second executable on the host computer. It allows the environment to regain control of the application to ensure that certain carefully chosen blocks will be executed on the appliance. The blocks that are executed are copies of the active code blocks maintained in a cache. These copies are equipped with patches or pieces of executable code to provide them with the information enabling detection of the most active blocks. The execution under the control of the hypervisor may, if necessary, resume on an exact copy of the application code if the latter is capable of providing precise information on the status of the execution as may be necessary for the processing of exceptions in particular.","At the end of the execution of a block, control reverts to the hypervisor, in such a way as to permit the latter to control the choices in terms of application control flow. If necessary, the hypervisor provides the maintenance of a copy of the application context. In the case of a transfer of the control flow to the appliance, this indirection of the control flow takes the form of an emulation of a function call in the execution on the front-end. The hypervisor ensures the capture of the system calls, call backs, exceptions, and also the calls to the dynamic libraries in such as way as to provide for their execution, while allowing it subsequently to resume control.","The hypervisor manages the execution memory model for the application via a specific module . This module supplies the application with a data cache for the data structures that have been selected for allocation to the memory of the additional computer. The change in the control flow to the additional module therefore entails a synchronization of the modified pages to the memory of the module.",{"@attributes":{"id":"p-0041","num":"0048"},"figref":"FIG. 3","ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["Loader: provides for the initialization of the launch of an accelerated application;","Execution Engine: manages the control flow of the application threads;","Code Cache Manager: manages the copy of the code pages to be executed;","OS Layer Emulator: provides for the interface with the OS in such a way as to ensure that the Execution Engine does not lose control of the application;","Memory Manager: manages the allocation of the memory to the application heap;","Code Generator: dynamically generates the translated code for its execution on the additional computing module."]}}}},"A certain number of data structures allow the hypervisor to manage the application threads:\n\n","It is supplemented by a driver which is executed in system mode, the Appliance Architecture Driver (AAD) described below.","The accelerated application does not constitute an autonomous process, but is executed within the HRT process. All of the threads describing the application control flows are native threads created within the HRT process.","The loader replaces the system loader from the perspective of the application. It loads the different data relating to the executable of the application in the HRT.","The loader is responsible for creating the data structures in the HRT which the creation of a system-level new process would initialize. If an application is registered as eligible for acceleration, a pre-initialized structure is maintained in anticipation in such a way as to accelerate the launch of the executable.","The loader provides for the processing operations associated with the launch of the application process. It allocates the memory and loads the constituent elements of the process: context, image, etc. In the case of an implementation under Windows, the loader manages in particular the cases in which the executable is an MS-DOS, Win16 or POSIX executable, in order to be able to provide for the launch of the associated images.","After the end of the process initialization, the loader hands over to the Execution Engine.","The Execution Engine provides for the monitoring of the application thread control flow. It is responsible, in particular, for the switchover of the execution between the front-end and the appliance. The Code Cache Manager provides for the loading of the code pages which are to be executed by the application threads.","The Code Generator uses the metadata associated with the application code to select the blocks that will be executed on the appliance. Once these blocks have been selected, it is responsible for generating the virtual machine code that is required for the execution of the blocks on the appliance, then for transmitting them to the virtual machine using the Architecture Driver.","The OS Layer Emulator is responsible for emulating the interactions between the application threads and the system in order to avoid the loss of control of the application by the hypervisor.","The HRT process heap is the heap used by the Execution Engine. The heap corresponding to the different application threads is, for its part, allocated in the appliance memory. A Data Cache with the granularity of the page contains a copy of the pages accessed by the threads during execution on the front-end. From the perspective of the operating system, this Data Cache is a memory-mapped file. The Memory Manager creates a Data Cache structurization. The application code is consequently modified in anticipation.","The mechanism for managing the operating system memory naturally ensures the provision of a copy of the page concerned insofar as a datum is accessed by a thread on the front-end. The page absence is captured by the Execution Engine which transfers the request to the AAD.","Conversely, when control is transferred to the appliance, the Execution Engine ensures that all of the pages whose copies have been modified are recopied on the additional computer.","The Memory Manager is responsible for allocating the dynamic data in the application heap located on the additional computer.","L'AAD performs all of the low-level data transfers between the host computer and the additional computer.","The transfers between the two computers consist, on the one hand, of codes to be executed and, on the other hand, of data pages linked to the management of the heap.","The structure and function of the virtual machine implemented in the second executable code will now be described with reference to .","The code on the additional computing module is executed on a virtual machine consisting of an implementation on the specific circuit of the accelerator of a generic parallelism model. This virtual machine is supplemented by a set of libraries. A \u201cvirtual machine+libraries\u201d package defines a profile and corresponds to an execution semantic. The profiles may be specific to particular applications. A virtual machine is dynamically loadable before the launch of an application by the environment.","One of the parallelism models shown defines the additional computer as a vector machine, therefore having instructions on the data represented in the form of vectors. A flow computing model is also provided for, in which the data are supplied to cores in the form of data flows.","It is then possible to define modules directly using the high-level instruction set of the virtual machine and the Application Programming Interface (API). The assembly constitutes a high-level API for each profile, an API which may remain temporally stable to ensure the sustainability of the developments implemented. The developments on the profiles are carried out in a high-level language which is readily accessible to the person skilled in the art of programming.","The virtual machine and the libraries are themselves supported by a micro-coded runtime depending on the module hardware. The module integrates in particular specific memory management instructions with a specific hardware platform. This runtime is programmable by a low-level API which is not a priori exposed to the front-end system environment. It is provided as firmware which, by default, is not modifiable in a normal function of the appliance. However, new firmware may be loaded through modification of a flash memory.",{"@attributes":{"id":"p-0063","num":"0080"},"figref":"FIG. 5"},"The launching of the program is carried out in the runtime system environment which then loads the application executable. The first code blocks are copied in the code cache and the execution is transferred to the first block to be executed. At each end-of-block, control is transferred to the hypervisor so that it determines a possible transfer of the flow to the virtual machine. The hypervisor also regains control in the event of system calls or exceptions which occur during execution. If a flow transfer must be implemented to the virtual machine, the hypervisor emulates a function call by pushing the context of the front-end process and the return address onto the stack, and by transmitting a copy of this context to the virtual machine. The machine initializes itself by instantiating the context which has just been transmitted to it, and begins to execute the corresponding translated code. The virtual machine maintains information on memory pages modified during the operations implemented by the translated code.","At the end of the execution, the information collected on the memory modifications serves to invalidate the corresponding pages of the data cache. The modifications which the environment has undergone are also transmitted in such a way as to consequently modify the front-end process environment before it is restored. The virtual machine is stopped and the control flow is resumed by the hypervisor which relaunches the front-end process.","The description which has just been given of different embodiments of the invention does not limit the scope of said invention to said embodiments. Said scope is defined by the claims which follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be more readily understood and its different characteristics and advantages will become evident from the following description of a plurality of embodiments and its attached figures, in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
