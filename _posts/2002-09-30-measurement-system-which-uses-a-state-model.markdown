---
title: Measurement system which uses a state model
abstract: System and method for using a task state model to perform measurement tasks. The system includes a computer system, one or more measurement resources, and a task state model. Attributes for performing the measurement task are specified. The task is transitioned from an Initial state to a Deployed state, thereby compiling the attributes to primitive settings and deploying the primitive settings into a run-time for the measurement task. The task is transitioned from the Deployed state to an Executing state, thereby acquiring the measurement resources to perform the task, configuring the measurement resources with the primitive settings to perform the task, and executing the run-time to perform the measurement task using the measurement resources. One or more methods may be invoked which result in explicit state transitions, and which may include one or more implicit state transitions which may be programmatically performed before, during, or after the measurement task.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07089141&OS=07089141&RS=07089141
owner: National Instruments Corporation
number: 07089141
owner_city: Austin
owner_country: US
publication_date: 20020930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CONTINUATION DATA","FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Glossary of Terms"],"p":["This application is a continuation-in-part of U.S. application Ser. No. 10\/008,792 titled \u201cMeasurement System Software Architecture for Easily Creating High-Performance Measurement Applications\u201d filed Nov. 13, 2001, now U.S. Pat. No. 6,879,926 whose inventors were Geoffrey Schmit, Brent Schwan, Jonathan Brumley, Tom Makowski and Chris Bartz.","The present invention relates to the field of measurement and automation systems, and more particularly to a measurement system which uses a state model to provide improved flexibility and performance.","Scientists and engineers often use measurement or automation systems to perform a variety of functions, including measurement of a physical phenomena or unit under test (UUT), test and analysis of physical phenomena, simulation, hardware-in-the-loop testing, process monitoring and control, control of mechanical or electrical machinery, data logging, laboratory research, and analytical chemistry, to name a few examples.","A typical measurement system comprises a computer system with a measurement device or measurement hardware. The measurement device may be or include a computer-based instrument, a data acquisition device or board, a programmable logic device (PLD), a sensor, a smart sensor, an actuator, or other type of device for acquiring or generating data. The measurement device may be a card or board plugged into one of the I\/O slots of the computer system, or a card or board plugged into a chassis, or an external device. For example, in a common measurement system configuration, the measurement hardware is coupled to the computer system via other means such as through a VXI (VME eXtensions for Instrumentation) bus, a PXI (PCI eXtensions for Instrumentation) bus, a GPIB (General Purpose Interface Bus), a serial port, or parallel port of the computer system. Optionally, the measurement system includes signal conditioning devices which receive the field signals and condition the signals to be acquired. A measurement system may also typically include transducers, sensors, actuators or other detecting (or generating) means for providing \u201cfield\u201d electrical signals representing a process, physical phenomena, equipment being monitored or measured, etc. The field signals are provided to the measurement hardware.","The measurement hardware is configured and controlled by measurement software executing on the computer system. The measurement software for configuring and controlling the measurement system typically comprises two portions: the device interface or driver-level software and the application software, or the application. The driver-level software serves to interface the measurement hardware to the application. The driver-level software may be supplied by the manufacturer of the measurement hardware or by some other third party software vendor. An example of measurement or DAQ driver-level software is NI-DAQ from National Instruments Corporation. The application or client is typically developed by the user of the measurement system and is tailored to the particular function which the user intends the measurement system to perform. The measurement hardware manufacturer or third party software vendor sometimes supplies the application software for certain applications which are common, generic or straightforward.","Some comprehensive and complex measurement system architectures, for example, National Instruments\u201d NI-DAQ 6.9, have various drawbacks which limit the effectiveness and ease with which a measurement task may be specified, designed, and implemented. One performance related inadequacy of some current architectures is a lack of a state model for the system. The absence of a state model results in resources being reserved, programmed, and unreserved continuously, because no component or process is aware of what may have already been done. These unnecessary operations may result in a large number of kernel transitions, which can substantially affect performance, as is well known in the art.","Additionally, in prior art measurement systems which do utilize a state model, the state model is generally coupled to the status of measurement resources, i.e., hardware and\/or software, installed in the measurement system, and thus may substantially limit the flexibility and use of the measurement system when multiple measurement tasks are to be performed.","Therefore, it would be desirable to provide new systems and methods for specifying and performing measurement tasks.","Various embodiments of a system and method for using a state model to perform measurement tasks are presented. The system may include a computer system, including a processor and a memory medium coupled to the processor. The memory medium may store program instructions executable to perform a measurement task, such as data acquisition and\/or signal generation, and a state model which includes a plurality of states, each of which corresponds to a status of measurement resources used to perform the measurement task and\/or the measurement task itself. One or more measurement resources may be coupled to the computer system. The memory medium may include one or more graphical programs, e.g., National Instruments' LabVIEW graphical programs, which may implement various embodiments of the present invention. The program instructions may be executable to use transitions among the states to perform the measurement task using the one or more measurement resources. More specifically, the measurement system may operate to use the state model to perform various embodiments of the following method:","In one embodiment, input may be received specifying one or more attributes for performing the measurement task. The task may be transitioned from an Initial state to a Deployed state, thereby compiling the one or more attributes to one or more primitive settings, and deploying the one or more primitive settings into a run-time for the measurement task. The task may then be transitioned from the Deployed state to an Executing state, thereby acquiring one or more measurement resources to perform the measurement task, configuring the one or more measurement resources with the one or more primitive settings to perform the measurement task, and executing the run-time to perform the measurement task using the one or more measurement resources.","Input may then be received invoking termination of the measurement task. Alternatively, a stop node may be executed to invoke termination of the task. The task may then be transitioned from the Executing state to the Deployed state, thereby terminating operation of the measurement resources, un-configuring, and releasing the measurement resources. One or more of the attributes may then be modified, transitioning the task from the Deployed state to the Initial state.","In one embodiment, the plurality of states, e.g., Initial, Deployed, and Executing states, comprises a sequence of states. The method may include transitioning from a current state of the sequence of states to a non-contiguous target state of the sequence of states, where the transitioning includes programmatically transitioning from the current state through one or more intermediate states of the sequence of states to the noncontiguous target state. In other words, one or more implicit state transitions may be performed in transitioning from the current state to the target state. Note that as used herein, the terms \u201cprogrammatic\u201d and \u201cimplicit\u201d transitions mean that the transitions are determined and made without user input or user programming specifying the transitions. For example, if the user specifies or programs a read operation in the program, but when the read is to execute the task is not already in the correct state, the system may implicitly or programmatically transition the task to the correct state prior to executing the read, as opposed to the user having to specify or program the state transitions to bring the task to the correct state. In one embodiment, implicit or programmatic state transitions may not be apparent to the user. In other words, no indication may be given to the user that such transitions are occurring.","In one embodiment, the measurement task is represented by a software object that models the different aspects of performing the measurement task. More specifically, the measurement task may include a measurement task specification containing the one or more attributes which specify the measurement task, primitive settings which result from compiling the attributes into measurement resource-specific settings, and one or more measurement primitives which may be configured with the primitive settings, and which manage the measurement resources to perform the measurement task. For example, where the measurement resources include hardware and\/or software, the measurement primitives may include hardware primitives and\/or software primitives.","In other embodiments, other (equivalent) states may be used in the state model to perform the measurement task. For example, in one embodiment, the method may include receiving input specifying one or more attributes for performing the measurement task. The task may then be transitioned from an Unverified state to a Verified state, thereby compiling the one or more attributes to one or more primitive settings, and deploying the one or more primitive settings into a run-time for the measurement task. The task may then be transitioned from the Verified state to a Reserved state, thereby acquiring one or more measurement resources to perform the measurement task. Then, the method may transition the task from the Reserved state to a Committed state, thereby configuring the one or more measurement resources with the one or more primitive settings, where after being configured, the one or more resources are operable to perform the measurement task. Finally, the task may be transitioned from the Committed state to a Running state, thereby executing the run-time to perform the measurement task using the one or more measurement resources.","As described above, invoking termination of the measurement task may cause successive state transitions back through the states. For example, in response to terminating the measurement task, the method may transition the task from the Running state to the Committed state, thereby terminating operation of the one or more measurement resources, then transition the task from the Committed state to the Reserved state, thereby un-configuring the one or more measurement resources. The method may then transition the task from the Reserved state to the Verified state, thereby releasing the one or more measurement resources. Finally, one or more of the attributes may be modified, thereby transitioning the task from the Verified state to the Unverified state.","Some of the state transitions involved in performing the measurement task may be implicit, i.e., may be performed programmatically. For example, in one embodiment, the measurement task may be in a first state. User input may be received invoking a first operation that necessitates a transition from the first state to a second state of the plurality of states. For example, the task may be in an Initial state, e.g., in the Verified state, and the first operation may be a Read method which requires that the task be in the Running state. The method may then programmatically transition from the first task state (e.g., Verified) through one or more intermediate task states of the plurality of task states to the second task state (e.g., Running). Thus, following the example from above, the transitions from the Verified state, through the Reserved and Committed states (the intermediate states), to the Running state may be implicit. In other words, from the user's perspective, the task simply goes straight from the Verified state to performing the Read operation.","Similarly, the method may receive user input invoking a second operation that necessitates a transition from the second state to a first intermediate state of the one or more intermediate states. For example, the user input may invoke termination of the Read operation, e.g., by calling a Stop method, or by executing a Stop program node, which may necessitate a state transition from the Running state to the Committed state. The method may then programmatically transition from the second state (Running) through zero or more of the intermediate states to the first intermediate state (Committed), then programmatically transition from the first intermediate state (Committed) through zero or more others of the intermediate states to the first state (Verified). Thus, from the user's point of view, upon termination of the Read operation, the task returns to the original state, i.e., the Verified state, greatly simplifying the apparent operation of the measurement system in performing the measurement task. Thus, the system may provide one or more methods (e.g., Read, Write, etc.) which are each executable to invoke at least one of the one or more state transitions among the plurality of states to perform the measurement task. Additionally, in one embodiment, at least one of the methods may be executable to invoke a plurality of implicit state transitions, as described above. It should be noted that although the states Unverified, Verified, Running, and Committed, were used in the above example, any other states could also be used in the manner described. Thus, for example, the plurality of states may include at least a subset of Unverified, Verified, Deployed, Reserved, Committed, and Running, or their equivalents. In other words, the plurality of states may include one or more of the following state sequences: [Unverified, Verified, Reserved, Committed, Running], [Unverified, Verified, Deployed, Reserved, Committed, Running], [Unverified, Verified, Committed, Running], [Unverified, Verified, Reserved, Running], and [Unverified, Verified, Running]. It is noted that other collections of states are also contemplated for use in various embodiments of the present invention.","In one embodiment, the state model may comprise a task state model, i.e., a task-based state model, and the plurality of states may comprise a plurality of task states, each corresponding to a status of the task. A primary unique characteristic of the task-based state model is that the state model is not coupled to the state of the resources (e.g., devices), but instead is associated with a task.","The fact that the task state model relates specifically to aspects of the task as opposed to the measurement resources (i.e., hardware and\/or software used to perform the task) may allow multiple measurement tasks to be performed efficiently. More specifically, the method may provide an efficient way to perform multiple measurement tasks which use common measurement resources.","For example, in one embodiment, the method may include receiving input specifying a plurality of sets of attributes for performing a corresponding plurality of measurement tasks, where each of the measurement tasks is in a first task state (e.g., an Initial state, such as Unverified, where the first task state indicates that customer-definable attributes have not been compiled and deployed). A corresponding plurality of run-times may then be generated based on the sets of attributes, thereby transitioning each of the tasks to a second task state (e.g., a Deployed state, such as Verified, where the second task state indicates that the customer-definable attributes have been compiled to primitive settings, and that the primitive settings have been received by corresponding primitive supervisors). A first run-time of the plurality of run-times may then be executed to perform a first measurement task of the plurality of measurement tasks using the one or more common hardware resources, thereby transitioning the first measurement task to a third task state (e.g., an Executing state, such as Running, where the third task state indicates that the one or more common hardware resources have been reserved and configured by the primitive supervisors and are performing the measurement task). In other words, the first measurement task may be performed using the common or shared resources. The execution of the first run-time may then be terminated, thereby transitioning the first measurement task back to the second task state (Deployed, or Verified).","The method may then iteratively execute and terminate others of the plurality of run-times to perform one or more respective other measurement tasks of the plurality of measurement tasks using the one or more common hardware resources. In other words, once the plurality of run-times have been generated, generally the most expensive part of the measurement process, each of the run-times may be executed and terminated in succession, where each execution transitions the respective task from the Deployed state to the Executing state, and each termination transitions the task from the Executing state back to the Deployed state. In this way, the task-based state model may provide great flexibility and efficiency in the performance of multiple measurement tasks. It is noted that the same approach may be used to iteratively perform a single measurement task, in that the run-time for the task may be executed and terminated repeatedly, without having to re-verify the task each time. It is further noted that the order of operations in preparing the plurality of run-times may vary. For example, attributes for a first task may be specified, then the task may be transitioned from the Initial state (e.g., Unverified) to the Deployed state (e.g., Verified) to generate the corresponding run-time. Then, a second task may be specified, followed by generation of the second run-time, and so on.","Thus, in one embodiment, the method may include specifying a first one or more attributes for performing a first measurement task, where the first task in a first task state, compiling the first one or more attributes into first one or more primitive settings, and deploying the first one or more primitive settings into a first run-time, thereby transitioning the first task to a second task state. Then, the method may include specifying a second one or more attributes for performing a second measurement task, where after specifying the second one or more attributes, the second task is in the first task state, compiling the second one or more attributes into second one or more primitive settings, and deploying the second one or more primitive settings into a second run-time, thereby transitioning the second task to the second task state.","The method may then proceed by executing the first run-time to perform the first measurement task using the one or more common hardware resources, thereby transitioning the first measurement task to a third task state, then terminating execution of the first run-time, thereby transitioning the first measurement task to the second task state. After terminating the first task, the method may continue, executing the second run-time to perform the second measurement task using the one or more common hardware resources, thereby transitioning the second measurement task to the third task state, and terminating execution of the second run-time, thereby transitioning the second measurement task to the second task state. Of course, in other embodiments, more that two tasks may be processed in this manner. Additionally, in other embodiments, the execution\/termination steps may be performed iteratively, as described above.","In one embodiment, each of the plurality of task states may include one or more task sub-states, where each task sub-state comprises one or more state parameter values. For example, in one embodiment, each task state may include one or more tuples of state values, each tuple comprising: an attribute state, indicating a status for attributes in a measurement task specification which specifies the measurement task; a primitive settings state, indicating a status for parameter settings for measurement primitives which implement the measurement task specification, where the parameter settings are comprised in a run-time specification; and a run-time state, indicating a status for a run-time, where the run-time comprises a plurality of measurement primitives, and where each of the measurement primitives is operable to operate, communicate with, and\/or control a measurement resource in the measurement system to perform the measurement task in accordance with the parameter settings. The transitions (both explicit and implicit) among the task states may thus comprise transitions among the task sub-states of the task states.","In one embodiment, the attributes which specify the task (i.e., the attributes included in the measurement task specification) may include customer-definable attributes. In other words, the customer may provide or specify the one or more attributes used to generate the primitive settings. In one embodiment, the customer may provide the attributes using a measurement task specifier, i.e., an interface program which leads the user through the task specification process.","One of the key benefits of the using task sub-states within each task state is that the user can reconfigure the task without explicitly transitioning the task back to an initial (e.g., Unverified) task state before reconfiguring the task or without explicitly transitioning the task back to the current task state after reconfiguring the task. In other words, the user is not forced to make explicit state transitions and leave the current task state when they reconfigure the task between operations. This may be accomplished by programmatic transitions between the task sub-states within a single task state when the task is reconfigured. Additionally, programmatic transitions between the task sub-states may be performed as a result of a successive operation (after reconfiguring) that results in a transition to a different task state. It is noted that task sub-state transitions within a task sub-state may be performed after the initial task specification but prior to performance of the task, or, after an initial performance of the task and subsequent reconfiguring of the task.","Thus, in various embodiments, the present invention includes a state model for a measurement system which may substantially improve performance and flexibility of the measurement system. Additionally, the inclusion of the state model in the measurement system may increase the usability of the system for the user by facilitating both user-specified state transitions and implicit state transitions in the implementation of a measurement task.","Incorporation By Reference","U.S. application Ser. No. 10\/008,792 titled \u201cMeasurement System Software Architecture for Easily Creating High-Performance Measurement Applications\u201d filed Nov. 13, 2001, currently pending, whose inventors were Geoffrey Schmit, Brent Schwan, Jonathan Brumley, Tom Makowski and Chris Bartz is hereby incorporated by reference in its entirety as though fully and completely set forth herein.","U.S. patent application Ser. No. 10\/128,843 titled \u201cMeasurement System Graphical User Interface for Easily Configuring Measurement Applications\u201d, filed Apr. 24, 2002, currently pending, and whose inventors are Brian Johnson, John Breyer, and Joseph Albert Savage, is hereby incorporated by reference in its entirety as though fully and completely set forth herein.","FIGS. A and B\u2014Instrumentation and Industrial Automation Systems",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIGS. 1A and 1B","FIGS. 1A and 1B","FIGS. 1A and 1B"]},"As used herein, the term \u201cmeasurement system\u201d is intended to include an instrumentation system such as that shown in , an industrial automation system such as that shown in , or a modeling or simulation system involved with the design, validation or testing of a product involving \u201creal world I\/O\u201d, i.e., the acquisition or generation of data to\/from a model or simulation of a device or product being designed, validated or tested, such as hardware-in-the loop validation. The term \u201cmeasurement\u201d may include instrumentation measurement, data acquisitions, automation, control, and simulation.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1A","b":["100","100","102","102","102","150"]},"The host computer  may execute a program which interacts with or controls the one or more instruments. The one or more instruments may include a GPIB instrument  and associated GPIB interface card , a data acquisition board  and associated signal conditioning circuitry , a VXI instrument , a PXI instrument , a video device or camera  and associated image acquisition card , a motion control device  and associated motion control interface card , and\/or one or more computer based instrument cards , among other types of devices. Note that the computer based instrument card  may be a board or card with one or more FPGAs, one or more CPUs and memory, or various combinations of the two.","The GPIB instrument  may be coupled to the computer  via the GPIB interface card  provided by the computer . In a similar manner, the video device  may be coupled to the computer  via the image acquisition card , and the motion control device  may be coupled to the computer  through the motion control interface card . The data acquisition board  may be coupled to the computer , and may interface through signal conditioning circuitry  to the UUT. The signal conditioning circuitry  may comprise an SCXI (Signal Conditioning eXtensions for Instrumentation) chassis comprising one or more SCXI modules .","The GPIB card , the image acquisition card , the motion control interface card , and the DAQ card  are typically plugged in to an I\/O slot in the computer , such as a PCI bus slot, a PC Card slot, or an ISA, EISA or MicroChannel bus slot provided by the computer . However, these cards , ,  and  are shown external to computer  for illustrative purposes. These cards , , ,  may also connected to the computer  through a USB (Universal Serial Bus), IEEE 1394 or 1394.2 bus provided by the computer .","The VXI chassis or instrument  may be coupled to the computer  via a VXI bus, MXI bus, or other serial or parallel bus provided by the computer . The computer  may include VXI interface logic, such as a VXI, MXI or GPIB interface card (not shown), which interfaces to the VXI chassis . The PXI instrument may be coupled to the computer  through the computer's PXI bus. The PXI chassis may be coupled to the computer  via a MXI-3 bus.","A serial instrument (not shown) may also be coupled to the computer  through a serial port, such as an RS-232 port, USB (Universal Serial bus) or IEEE 1394 or 1394.2 bus, provided by the computer .","In typical instrumentation control systems an instrument of each interface type may not be present, and in fact many systems may only have one or more instruments of a single interface type, such as only GPIB instruments. The instruments are coupled to the unit under test (UUT) or process , or are coupled to receive field signals, typically generated by transducers. The system  may be used in a data acquisition and control application, in a test and measurement application, a process control application, a man-machine interface application, or a simulation application.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B"],"b":["160","160","100","1","160","102","102","102","150","102","160"]},"The one or more devices may include a data acquisition board  and associated signal conditioning circuitry , a PXI instrument , a video device  and associated image acquisition card , a motion control device  and associated motion control interface card , a FieldBus device  and associated FieldBus interface card , a PLC (Programmable Logic Controller) , a serial instrument  and associated serial interface card , or a distributed data acquisition system, such as the FieldPoint system available from National Instruments, among other types of devices.","The DAQ card , the PXI chassis , the video device  and image acquisition card , and the motion control device  and motion control interface card  may be coupled to the computer  as described above. The serial instrument  may be coupled to the computer  through a serial interface card , or through a serial port, such as an RS-232 port, provided by the computer . The PLC  may couple to the computer  through a serial port, Ethernet port, or a proprietary interface. The FieldBus interface card  may be comprised in the computer  and interfaces through a FieldBus network to one or more FieldBus devices. Each of the DAQ card , the serial card , the FieldBus card , the image acquisition card , and the motion control card  are typically plugged in to an I\/O slot in the computer  as described above. However, these cards , , , , and  are shown external to computer  for illustrative purposes. In typical industrial automation systems a device will not be present of each interface type, and in fact many systems may only have one or more devices of a single interface type, such as only PLCs. The devices are coupled to the device or process .","Referring again to , the computer system  and\/or one or more of the instruments or devices may include a memory medium (or memory mediums) on which software according to the present invention may be stored. The memory medium may store a development environment, such as National Instruments LabVIEW graphical development environment whereby measurement applications may be developed. Additionally, the memory medium may store one or more graphical programs which use a state model and one or more methods whose execution entails transitions between two or more states. In one embodiment, the memory medium may also store a measurement task specifier, an expert system, a plurality of experts, a run-time builder, and a plurality of measurement primitives, described in more detail below. Additionally, the memory medium(s) may store various products produced by or with these software components, such as a measurement task specification, a run-time specification, and a run-time, all of which are described in more detail in U.S. application Ser. No. 10\/008,792 titled \u201cMeasurement System Software Architecture for Easily Creating High-Performance Measurement Applications\u201d filed Nov. 13, 2001, which was incorporated by reference above. The memory medium(s) may also store configuration information for one or more of the above software programs.","The term \u201cmemory medium\u201d is intended to include an installation medium, e.g., a CD-ROM, floppy disks , or tape device; a computer system memory or random access memory such as DRAM, SRAM, EDO RAM, RRAM, etc.; or a non-volatile memory such as a magnetic media, e.g., a hard drive, or optical storage. The memory medium may comprise other types of memory as well, or combinations thereof. Various embodiments further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Suitable carrier media include a memory medium as described above, as well as signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as networks and\/or a wireless link.","In addition, the memory medium may be located in a first computer in which the shared library is stored or executed, or may be located in a second different computer which connects to the first computer over a network, such as the Internet. In the latter instance, the second computer provides the program instructions to the first computer for execution. Also, the computer system  may take various forms, including a personal computer system, mainframe computer system, workstation, network appliance, Internet appliance, personal digital assistant (PDA), television set-top box, instrument, or other device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having at least one processor which executes instructions from a memory medium.","In one embodiment, the software programs and software architecture as described herein may be designed for measurement systems, including data acquisition\/generation, analysis, and\/or display; automation systems; simulation systems; systems for controlling, modeling, or simulating instrumentation or industrial automation hardware; and systems for controlling, modeling or simulating systems or devices being designed, prototyped, validated or tested. However, it is noted that the present invention can be used for a plethora of applications and is not limited to instrumentation or industrial automation applications. In other words,  are exemplary only, and the software programs and software architecture may be used for any of various purposes and may be stored in and execute on any of various types of systems to perform any of various applications.","FIG. \u2014Computer System Block Diagram",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 2","FIGS. 1A and 1B","FIG. 2"],"b":["1","1"]},"The computer  includes at least one central processing unit or CPU  which is coupled to a processor or host bus . The CPU  may be any of various types, including a x86 processor, e.g., a Pentium class; a PowerPC processor; a CPU from the SPARC family of RISC processors; as well as others. Main memory  is coupled to the host bus  by means of memory controller . The main memory  may store one or more computer programs or libraries according to one embodiment of the present invention. The main memory  also stores operating system software as well as the software for operation of the computer system, as well known to those skilled in the art.","The host bus  is coupled to an expansion or input\/output bus  by means of a bus controller  or bus bridge logic. The expansion bus  is preferably the PCI (Peripheral Component Interconnect) expansion bus, although other bus types can be used. The expansion bus  includes slots for various devices such as the data acquisition board  (of FIG. A), a GPIB interface card  which provides a GPIB bus interface to the GPIB instrument  (of FIG. A), and a reconfigurable instrument . Note that as used herein, the term \u201creconfigurable instrument\u201d refers to an instrument with one or more of:","1) a processor and memory which is capable of being configured by a user or software program; and\/or","2) reconfigurable logic, such as an FPGA (Field Programmable Gate Array).","For more information on a reconfigurable instrument which includes an embedded processor and embedded memory, please see U.S. Pat. No. 6,173,438 which is hereby incorporated by reference in its entirety as though fully and completely set forth herein. For more information on a reconfigurable instrument which includes reconfigurable hardware, e.g., an FPGA, please see U.S. Pat. No. 6,219,628 which is hereby incorporated by reference in its entirety as though fully and completely set forth herein. The computer  may further comprise a video display subsystem  and hard drive  coupled to the expansion bus .","FIG. \u2014High Level Architecture of a Measurement System",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 3","b":["202","202","202","202"]},"As shown, the application  may communicate with a measurement driver . The measurement driver  may include a measurement driver application programming interface (API) . As shown, the application program A or B interfaces with the measurement driver API  in order to access capabilities of the measurement driver . In this measurement example, the software architecture may also include interchangeable virtual instrument (IVI) drivers  wherein the application program B may interface through IVI drivers , which interface with the measurement driver API , to interface with the measurement driver .","The measurement driver  may interface to the one or more various measurement devices , i.e., measurement resources, comprised in this system, including software and\/or hardware devices. The measurement devices  may comprise any of the various devices discussed above with respect to  or B and may comprise other devices not shown in  as desired. In one embodiment, at least one of the one or more measurement devices comprises a hardware measurement device. In another embodiment, at least one of the one or more measurement devices comprises a virtual measurement device.","In one embodiment, the present invention provides an improved system and method for performing tasks, such as measurement tasks, using a state model. The measurement driver  preferably includes various software programs that may implement and maintain a state model of one or more measurement tasks, allowing for improved control and flexibility in performing the measurement tasks, as described in detail below.","FIG. \u2014Measurement Driver Program Components",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 4","b":["400","212","212","730","750","406","780","408","212"]},"As  also illustrates, various of the measurement driver components may be operable to generate respective products which may be useable by other measurement driver components, by other software programs or systems, or by a user. More specifically, as shown in , in one embodiment, the measurement task specifier  may be operable to generate a measurement task specification . In one embodiment, the measurement task specification  may comprise software objects or data structures, such as C++ objects, containing one or more attributes which specify the measurement task. In one embodiment, the measurement task specifier  may be a measurement task wizard, i.e., a software program which leads the user through a measurement task specification process to create the measurement task specification . In another embodiment, the measurement task specifier  may take the form of a measurement task configuration tool, which is a software program invocable by the user under a development environment, such as the National Instruments LabVIEW environment or Measurement Studio programming development environment. In yet another embodiment, the measurement task specifier  may simply be an API through which the user makes calls to generate the task specification. Thus, in various embodiments, the measurement task specifier  may generate the measurement task specification  in response to user input.","As shown, the expert system  may use the measurement task specification  to generate a run-time specification . The expert system  may include a plurality of experts. The expert system  may include one or more experts for each of the measurement resource (device) types shown in , in addition to various other experts, including routing experts, streaming experts, and synchronization experts, among others. In one embodiment, the expert system  may operate to verify the measurement task specification, i.e., the one or more attributes specifying the measurement task.","In one embodiment, the run-time specification  may similarly comprise software objects or data structures, such as C++ objects, which may specify the run-time parameters for software and\/or hardware used to implement the specified measurement task. The run-time specification  may comprise parameter specifications for one or more measurement primitives  which correspond to rudimentary measurement tasks or operations. Said another way, the run-time specification  may comprise a collection of primitive settings, each of which may comprise a detailed and unambiguous \u201crecipe\u201d for a primitive. For example, primitive settings for a digitizer, such as a National Instruments E-Series digitizer, may include: Dither (Yes, No), Polarity (Bipolar, Uni-polar), Gain, Mode (Calibration, Differential, Non-Referenced Single-Ended, Referenced Single-Ended, Auxillary, Ghost), Generate Trigger (Yes, No), and Last Channel (Yes, No).","The run-time specification  may in turn be interpreted by the run-time builder  to generate a run-time , which may be executable to perform the specified measurement task. More specifically, the run-time  may be executable to configure the installed measurement resources, e.g., measurement devices and\/or software programs, to perform the measurement task, and to then perform the measurement task using the configured measurement resources, as described in detail below. The run-time may include a collection of measurement primitives, each of which may be operable to operate, communicate with, and\/or control a particular measurement resource. In other words, each primitive may serve as an active interface for the corresponding measurement resource. In one embodiment, one or more of the primitives may have a primitive supervisor which manages the primitive. In another embodiment, the primitive itself may include the primitive supervisor, and thus, may supervise or manage itself. In an embodiment where a measurement resource is a software program, i.e., a virtual device, the measurement primitive may actually be the virtual device. Thus, in one embodiment, the primitive supervisors are those objects which are responsible for receiving the primitive settings and managing the primitives, and the measurement primitives are those objects which are responsible for managing the measurement resources. In some cases, the primitive supervisor and the measurement primitive may be the same object, although it may be useful to separate the concepts in order to decouple their responsibilities.","A first primitive supervisor may be linked to a second primitive supervisor by retrieving a reference to the second supervisor, thereby allowing the first primitive supervisor to collaborate with the second primitive supervisor. Similarly, measurement primitives may be linked to allow collaboration between them. A first measurement primitive may retrieve a reference to a second measurement primitive, the retrieval often being negotiated by the respective primitive supervisors, after which the measurement primitives may collaborate in the performance of the measurement task.","For more information regarding the measurement system architecture described above, please see U.S. application Ser. No. 10\/008,792 titled \u201cMeasurement System Software Architecture for Easily Creating High-Performance Measurement Applications\u201d filed Nov. 13, 2001, whose inventors were Geoffrey Schmit, Brent Schwan, Jonathan Brumley, Tom Makowski and Chris Bartz which was incorporated by reference above.","FIG. \u2014Customer Task State Diagram",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 5"},"It should be noted that the task states shown are meant to be exemplary only, and are not intended to limit the number or types of task states used in the measurement system to any particular number or states. For example, in one embodiment, a minimum number of states defined by the task state model may include an Initial state, a Deployed state, and an Executing state (or their equivalents). In one embodiment, the Initial state may comprise an Unverified state, where one or more attributes, e.g., customer-definable attributes, for the measurement system configuration have been specified, but have not been verified, and so may include errors. The Deployed state (or its equivalent) may indicate that the customer-definable attributes have been compiled into primitive settings which are usable to configure one or more measurement resources to perform the task. Finally, the Executing state (or its equivalent) may indicate that the measurement resources have been reserved, configured with the primitive settings, and are performing the measurement task. Thus, in one embodiment, the measurement system may include a task state model to perform a measurement task, where the task state model includes a plurality of task states. The measurement system may be operable to receive input specifying the measurement task, and transition from a first state of the plurality of task states to a second state of the plurality of task states to perform the measurement task. In other embodiments, these basic states may be broken out into a number of states that represent the status of the task at a higher resolution. The state diagram of  illustrates such an embodiment.","As  shows, in this embodiment, the task states visible to the user or customer may include:","Unverified\u2014indicating that customer-definable attributes for the measurement system configuration have been specified, but have not been verified, and so may include errors, i.e., the task may not be valid;","Verified\u2014indicating that the customer-definable attributes for the measurement system configuration have been verified and compiled to primitive settings, i.e., the task is valid;","Reserved\u2014indicating that the measurement resources that will be used to perform the task have been exclusively acquired for the task, i.e., other tasks may not acquire these resources;","Committed\u2014indicating that the measurement resources that will be used to perform the task have been configured or programmed in accordance with the primitive settings, and are now prepared to perform the task; and","Running\u2014indicating that the configured measurement resources are performing the task.","As  also shows, each task state has well-defined transitions to adjacent task states. A transition may be initiated via methods such as, for example, set, get, reserve, unreserve, commit, uncommit, start, and stop, among others. It is noted that in a preferred embodiment, the task states comprise a linear sequence, i.e., there is a well-defined order of the task states such that transitions between two non-adjacent task states may entail transitioning through intervening task states. This constraint gives rise to the idea of implicit state transitions, described below with reference to FIGS.  and A-C.","It should be noted that in other embodiments, other sets of task states may be used by the state model. For example, one or more of the above-listed task states may be omitted or combined, resulting in state sequences such as (for example): [Unverified, Verified, Running], [Unverified, Verified, Reserved, Running], [Unverified, Verified, Committed, Running], and [Unverified, Verified, Deployed, Reserved, Committed, Running], among others. In other words, the task states may comprise a subset of [Unverified, Verified, Deployed, Reserved, Committed, and Running]. It is also noted that different state names may be used to denote these various states, i.e., as used herein, the particular states used are defined by function, not by any particular name.","As mentioned above, in one embodiment, the attributes which specify the task (i.e., the attributes included in the measurement task specification) may include customer-definable attributes. In other words, the customer may provide or specify the one or more attributes used to generate the primitive settings. In one embodiment, the customer may provide the attributes using a measurement task specifier, i.e., an interface program which leads the user through the task specification process. For further information regarding measurement task specifiers, please see U.S. patent application Ser. No. 10\/128,843 titled \u201cMeasurement System Graphical User Interface for Easily Configuring Measurement Applications\u201d, filed Apr. 24, 2002, and whose inventors are Brian Johnson, John Breyer, and Joseph Albert Savage, which was incorporated by reference above.","FIG. \u2014Implicit State Transitions",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 6","FIG. 5","FIG. 6"],"b":["602","510"]},"As  shows, if the task is in the Unverified state , then invocation of the read method  may lead to successive implicit transitions to Verified , Reserved , Committed , and finally, to Running . Similarly, if the task is in the Reserved state , then invocation of the read method  may lead to successive transitions to Committed , and to Running . As  also shows, if an abort transition  is invoked while the task is running, i.e., is in the Running state , the task may transition to the Verified state , implicitly transitioning through the Committed  and Reserved  states to do so.","It should be noted that other methods invoked by the user may involve other implicit state transitions. In other words, if a method's operation requires the task to be in a particular initial state, and the task is not in that state when the method is invoked, implicit transitions may be made from the current state, through any intervening states, to the appropriate initial state, after which the method may operate appropriately. The operation of the method may itself cause a state transition which may be effected after the implicit state transitions have been made. Additionally, in one embodiment, once the method operation is done, further implicit transitions may occur to take the task to a final state, e.g., back to the original \u201ccurrent\u201d state from which the method was originally invoked. It should be noted that in some embodiments, the state model may include one or more states which are not visible to the user, and the implicit state transitions may include transitions to, from, and\/or through these \u201chidden\u201d states.","Thus, various operations of the measurement system may include one or more transitions between user-visible (or accessible) task states, as well as one or more implicit state transitions which may not be apparent to the user. Further details of implicit state transitions are presented below with reference to .","FIGS. A-C\u2014Example Graphical Programs With Implicit State Transitions",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIGS. 7A-7C","FIG. 7A","FIG. 7A","FIG. 6"],"b":["510","510","502","510","502","504","504","506","506","508","508","510"]},"In one embodiment, once the read operation has been performed, the system may perform one or more implicit state transitions to return the task to a prior state. For example, the task may be transitioned to the original state of the system prior to execution of the read node, i.e., the task may be implicitly transitioned from Running , through Committed , Reserved , and Verified , to the Unverified state . In another embodiment, after the read operation has been performed, the task may be implicitly transitioned from Running , through Committed  and Reserved , to the Verified state . This may be a preferable \u201creturn\u201d state because no attributes have been modified, and so no verification process is required. Returning the task to the Verified state  leaves the task in a state which provides great flexibility and efficiency for subsequent performance of the task, in that the potentially expensive verification step may be omitted for future runs of the task.","Another important operation typically performed by a measurement system is writing data that is output by the measurement system. For example, in the graphical program of , a write node may be operable to write data to a device, e.g., to a signal generator. In many cases, the task must be in the Committed  or Running state  to perform the write operation because data that are written often must be transferred to a buffer on a hardware device. In other words, if the task is a signal generation task, then the signal generation hardware must receive a waveform prior to performing the signal generation. Transfer of the data (the waveform) may thus require that hardware be reserved and initialized. Therefore, if a request to write data is made and the task is in the Unverified , Verified , or Reserved  states, the task may be transitioned to the Committed state  implicitly. Once the task is committed, the write operation may be completed.","In some cases, a user may want the task to start the measurement system immediately after the write operation is complete. In other words, once the write operation has transferred the desired waveform to the signal generation hardware, the user may wish the system to automatically enter the Running state  so that the signal generation hardware may generate the signal based on the waveform. However, it may be difficult to know implicitly when a user desires this behavior. Therefore, in one embodiment, the write node may include an input parameter that allows the user to specify a transition to the Running state  (or any other state) once the write is complete.","In the graphical program shown in , invocation of the write operation may first cause an implicit transition to the Committed state , then, after the write operation is completed, an explicit transition to the Running state  may be performed based on the input parameter, indicated by the Boolean auto start input parameter coupled to the write node. Thus, execution of the write node may include the write node (or code associated with the write node) checking a value of the auto start parameter, and if the parameter so indicates, explicitly transitioning the task from Committed  to Running . Thus, the auto start parameter may cause an explicit post operative transition from the current state, i.e., the Committed state , to a target state, i.e., the Running state . In other embodiments, the input parameter may be used to specify a post-operation explicit state transition to any other state, as desired. It should be noted that in a case where the specified post operative target state is not adjacent to the current state, one or more implicit state transitions may be performed in transitioning the task from the current state to the target state. It is further noted that such transitions may be performed in conjunction with other functional nodes besides write nodes, e.g., read nodes, stop nodes, etc.","In one embodiment, users that are interested in the various task states can make transitions explicitly by using graphical programming nodes. For example, a transition from the Committed state  to the Running state  may be made by using a \u201cStart\u201d graphical programming node, as represented in the graphical program of  by a node labeled \u201cDAQmx Start.vi\u201d. Similarly, a transition from the Running state  to the Committed state  may be made using a \u201cStop\u201d graphical programming node, labeled \u201cDAQmx Stop.vi\u201d in FIG. C. In the embodiment shown, other state transitions may be made using a \u201cTask Control\u201d graphical programming node, labeled \u201cDAQmx Task Control.vi\u201d. For example, the Task Control node receives an input parameter specifying a transition of the task to the Committed state . Thus,  illustrates a graphical program that explicitly transitions the task to the Committed state  (via the Task Control node), then to the Running state  (via the Start node), where a read operation is performed, and back to the Committed state  (via the Stop node).","As mentioned above, when the graphical program begins execution, the task may be in an Initial state, e.g., the Unverified state , which may not be adjacent to (and prior to) the target state (Committed ). Thus, the explicit state transition to Committed  specified by the Task Control node may necessitate implicit transitions from Unverified , through Verified , to Reserved , before the explicit transition to Committed  may be performed. In other words, the node may implicitly or programmatically transition the task from it's current state to a suitable state for the node's operation, in this example, an explicit transition to the Committed state .","Similarly, when the Start node is executed, if the task is not in the state just prior to Running , one or more implicit transitions may be performed. However, it is noted that in this example, the Task Control node explicitly transitions the task to Committed  (which is the state just prior to the Running state , and thus, no implicit transitions are required for the Start node to execute.","In one embodiment, execution of the Stop node may result in a transition to the last explicit task state prior to the execution of the Start node. In the example shown in , where a read node is placed between the Start node and the Stop node, the prior state is the Committed state . Thus, execution of the Stop node may include, in addition to terminating operation of the relevant measurement resource(s), transitioning the task back to the Committed state . In the case where the prior state is not an adjacent state to the Running state , the transition from the Running state  to the prior state may include one or more implicit state transitions.","Thus, the execution of various graphical program nodes may perform or cause to be performed explicit state transitions, as well as one or more implicit task state transitions. Some of these implicit transitions may be affected by input parameters to the nodes specifying explicit state transitions for the task, where explicit transition between non-adjacent task states may include one or more implicit transitions through intervening task states.","Further benefits of implicit state transitions are presented below in the section titled \u201cBenefits of Implicit State Transitions\u201d.","FIG. \u2014Sub-states in the State Model","In one embodiment, the various task states, e.g., Unverified , Verified , Reserved , Committed , and Running  (or their equivalents), may comprise a number of sub-states which may indicate the status of components of the measurement task, and thus represent the task status at a higher resolution.  illustrates an embodiment of a state diagram in which the sub-states of each task state comprise tuples of state parameter values, where each tuple includes an attributes state, a primitive setting state, and a run-time state. This approach follows from the fact that in one embodiment, a measurement task may include one or more attributes, e.g., user-definable attributes, which specify the desired measurement task, one or more primitive settings based on the attributes, and one or more measurement primitives which provide a communication and control interface with respective measurement resources.","Said another way, each of the plurality of task states may include one or more task sub-states, where each task sub-state includes one or more state parameter values. In one embodiment, the state parameter values may include:","an attribute state, indicating a status for the attributes in a measurement task specification that specifies the measurement task;","a primitive settings state, indicating a status for primitive settings for measurement primitives, where the primitive settings are produced from the attributes and implement the measurement task specification, and where the primitive settings are included in a run-time specification; and","a run-time state, indicating a status for a run-time, where the run-time includes a plurality of the measurement primitives, each of which may be operable to operate, communicate with, and\/or control a measurement resource in the measurement system to perform the measurement task in accordance with the primitive settings.","In this embodiment, the transitions among task states described above may include transitions among the sub-states of the task states.","In various embodiments, the task sub-state parameter values may be defined to denote the status of the respective aspects of the measurement task, examples of which are presented below.","Examples of attribute states may include, but are not limited to:","unverified\u2014indicating that one or more of the specified attributes have not been verified and compiled to primitive settings; and","verified\u2014indicating that all of the specified attributes have been verified and compiled to primitive settings.","Examples of primitive settings states may include, but are not limited to:","not deployed\u2014indicating that at least one primitive setting has not been deployed in the run-time; and","deployed\u2014indicating that all of the primitive settings have been deployed in the run-time.","Examples of run-time states include, but are not limited to:","constructed\u2014indicating that measurement primitives (and\/or primitive supervisors) have been constructed, initialized with primitive settings, and linked with other primitive supervisors;","reserved\u2014indicating that measurement resources for performing the measurement task have been acquired, and optionally, that links to other hardware primitives have been resolved;","committed\u2014indicating that the configuration (i.e., the primitive settings) has been committed to hardware and the configured hardware is ready to run; and","running\u2014the configure hardware and software are actively operating in the system to perform the measurement task, e.g., acquiring or generating data.","For example, in the state diagram of , the Unverified state  includes sub-states denoted by the following tuples: (unverified-deployed-constructed)  and (unverified-notDeployed-constructed) , indicating the respective status of the attributes, the primitive settings, and the run-time, for the task in the Unverified state . As  also shows, the Verified state  includes sub-states denoted by the following tuples: (verified-deployed-constructed)  and (verified-notDeployed-constructed) .","Similarly, the Reserved state  includes a plurality of sub-states, namely, (unverified-notDeployed-reserved) , (verified-notDeployed-reserved) , (unverified-deployed-reserved) , and (verified-deployed-reserved) . As  shows, the Committed  and Running  states similarly include sub-states reflecting attribute\/primitive settings\/run-time status. It should be noted that the sub-state parameter values relate to specific task components, and should not be confused with similarly named task states, e.g., the \u201cReserved\u201d sub-state parameter and the Reserved task state .","As  shows, transitions between sub-states may be made by invoking various task, attribute, and run-time methods. Examples of task methods include start\/stop, commit\/uncommit, reserve\/unreserve, and verify, among others. Examples of attribute methods include set and get. It should be noted that transitions between sub-states belonging to different task states are the task state transitions described above, and that, as  shows, there may be multiple ways to transition between task states. For example, a task state transition from Committed  to Reserved  may be made by transitioning from the Committed sub-state (unverified-deployed-committed)  to the Reserved sub-state (unverified-deployed-reserved) , or alternatively, by transitioning from the Committed sub-state (verified-notDeployed-committed)  to the Reserved sub-state (verified-notDeployed-reserved) , as shown.","Note that when an attribute is modified, e.g., with an attribute::set( ), a transition may be made to a sub-state which includes the \u201cUnverified\u201d state parameter. Similarly, invocation of a verify method may result in a transition to a sub-state which includes the \u201cVerified\u201d state parameter. Execution of the run-time method iRuntime::deploy may result in a transition to a sub-state which includes the \u201cdeployed\u201d state parameter. Thus, the task, run-time, and attribute methods may each correspond to one or more sub-state transitions reflecting a new or changed status of a corresponding task component. Where such sub-state transitions span a task state boundary, a task state transition occurs.","One of the key benefits of the using task sub-states within each task state is that the user can reconfigure the task without explicitly transitioning the task back to an initial (e.g., Unverified) task state before reconfiguring the task or without explicitly transitioning the task back to the current task state after reconfiguring the task. In other words, the user is not forced to make explicit state transitions and leave the current task state when they reconfigure the task between operations. This may be accomplished by programmatic transitions between the task sub-states within a single task state when the task is reconfigured. Additionally, programmatic transitions between the task sub-states may be performed as a result of a successive operation (after reconfiguring) that results in a transition to a different task state. It is noted that task sub-state transitions within a task sub-state may be performed after the initial task specification but prior to performance of the task, or, after an initial performance of the task and subsequent reconfiguring of the task.","For example, if the user wishes to perform a sequence of operations with the same task, but make minor changes to the configuration of the task between operations, the following sequence of operations may be performed:","1. Configure the task. The task is in the initial, \u201cUnverified\u201d task state, e.g., ({unverified-notDeployed-constructed}).","2. Explicitly transition the task to the \u201cReserved\u201d task state, resulting in the task transitioning through the \u201cVerified\u201d task state to the \u201cReserved\u201d task state,","e.g., ({unverified-notDeployed-constructed}->{verified-notDeployed-constructed}->verified-deployed-constructed}->{verified-deployed-reserved}).","3. Execute the task to perform the first operation, resulting in the task transitioning to the \u201cRunning\u201d task state, performing the operation, and returning to the \u201cReserved\u201d task state,","e.g., ({verified-deployed-reserved}->{verified-deployed-committed}->{verified-deployed-running}->{verified-deployed-committed}->{verified-deployed-reserved}).","4. Reconfigure the task to prepare for the next operation to be performed by the task, e.g., by setting one or more attributes of the task. Note that from the user's perspective, the state of the task has not changed after this reconfiguration; the task is still in the \u201cReserved\u201d task state. However, internally, the task sub-state has changed,","e.g., ({verified-deployed-reserved}->{unverified-deployed-reserved}).","5. Execute the task to perform the second operation, again resulting in the task transitioning to the \u201cRunning\u201d task state, performing the operation, and returning to the \u201cReserved\u201d task state. From the user's perspective the task transitions through the same series of task states as when executing the first operation. However, internally, additional task sub-state transitions may occur to handle the reconfiguration of the task,","e.g., ({unverified-deployed-reserved}->{verified-notDeployed-reserved}->{verified-deployed-reserved}->{verified-deployed-committed}->{verified-deployed-running}-> {verified-deployed-committed}->{verified-deployed-reserved}).","In one embodiment, these additional task sub-state transitions may be optimized to only verify those attributes that are affected by the reconfiguration of the task. Additionally, they may be optimized to only re-deploy those primitive settings that have changed as a result of the reconfiguration of the task. These additional sub-state transitions may enable both high-performance reconfiguration of the task and improved usability for the user.","In one embodiment, the task states available to the measurement task comprise a state space, where each task state corresponds to a point or location in the state space. For example, in one embodiment, the task state space is a three-dimensional space organized along the axes: Expert Attributes, Expert Primitive Settings, and Run-Time, corresponding respectively to the state parameters described above. In this embodiment, points within the state space may be written as: (<Expert Attributes coord.>, <Expert Primitive Settings coord.>, <Run-Time coord.>). It is noted that while the state space is potentially large, in reality only a small number of states may actually be reachable.","FIGS. A and B\u2014Methods for Performing a Measurement Task",{"@attributes":{"id":"p-0132","num":"0131"},"figref":["FIGS. 9A and 9B","FIGS. 9A and 9B","FIGS. 9A and 9B","FIGS. 9A and 9B","FIG. 10","FIGS. 7A-7C","FIGS. 11A and 11B"]},{"@attributes":{"id":"p-0133","num":"0132"},"figref":["FIG. 9A","FIG. 9A"],"b":["902","502"]},"In , input may be received invoking a first operation or method which requires a transition of the task from the first task state to a second task state. For example, as described above with reference to , a read function may be invoked which requires the task to be in the Running state .","In response to the method invocation, the task may be programmatically transitioned from the first task state, through one or more intermediate task states, to the second task state, as indicated in . For example, in the case of the read invocation of , the task may be programmatically transitioned from the Unverified state , through the Verified , Reserved , and Committed  states, to the Reserved state , whereupon the read function may then operate to read data.","Is should be noted that although the above method is described using a task state model with task states, it is also contemplated that such implicit state transitions may be implemented in a measurement system which does not specifically utilize task states. In other words, the performance of implicit state transitions in a measurement system may be used in more traditional measurement systems which use state models based on the status of the measurement resources or other aspects of the system (as opposed to the task).","In one embodiment, prior to specifying the attributes for the measurement task, one or more measurement resources may be installed in the measurement system to perform the task. In other embodiments, the measurement resources may be installed after the attributes have been specified. Installation of the measurement resources may include connecting a measurement device to the computer system or installing a measurement card or board within a slot of the computer system. This may further comprise installing a measurement card or board in a slot of a chassis, such as a PXI chassis, which itself is coupled to the computer system and\/or which may contain a computer system comprised on a card within the chassis. In one embodiment, the measurement hardware may comprise a \u201creconfigurable measurement device\u201d which may be operable to be reconfigured \u201con the fly\u201d during a measurement task or operation. For example, the reconfigurable measurement device may include a processor and memory or an FPGA that may be reconfigured with different measurement programs or tasks. In other embodiments, installing the measurement resources may include installing one or more measurement programs on the computer system.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":["FIG. 9B","FIG. 9A","FIG. 9A"],"b":["902","504","502","9"]},"In , one or more attributes may be specified for performing the measurement task, e.g., in a measurement task specification, after which the task may be in a first state, e.g., in the Verified state  (although any other state may also be considered for use in the same way).","In , input may be received invoking a first operation or method which requires a transition of the task from the first state to a second state, e.g., a Read function which requires the task to be in the Running state . In one embodiment, the input may be provided by a user. In another embodiment, a Read node may be executed in the graphical program.","In response to the method invocation, the task may be programmatically transitioned from the first state, through one or more intermediate states, to the second state, as indicated in . For example, as described above, in the case of the read invocation of , the task may be programmatically transitioned from the Verified state , through the Reserved  and Committed  states, to the Running state , whereupon the Read function may then operate to read data, e.g., from a measurement resource, such as a DAQ device.","After transitioning the task to the second state, in  input may be received, e.g., from the user, invoking a second operation or method which requires a transition of the task from the second state to a first intermediate state of the one or more intermediate states. In other words, the operation requires the task to transition back to one of the intermediate states of .","Then, in , the task may be programmatically transitioned from the second state, through zero or more intermediate states, to the first intermediate state. For example, in the read example from above, in , the input may invoke a \u201cStop\u201d method to terminate the read operation. The Stop method may then terminate operations of the measurement resource, transitioning the task from the Running state  (or its equivalent) to the first intermediate state, e.g., to the Committed state .","Finally, in , the task may be programmatically transitioned from the first intermediate state, e.g., the Committed state , through zero or more other intermediate states, back to the first state. For example, in one embodiment, the task may be programmatically transitioned through the Reserved  state to the Verified state , which was the last explicit state of the task prior to the invocation of the initial operation (the Read method). In another embodiment, the first state (of ) may be the Unverified state  (as opposed to the Verified state ), and for reasons of efficiency, the final (programmatic or implicit) transition may be to the Verified state , in that transitions to the Unverified state  generally correspond to modifications in the task attributes, and since no attributes have been modified, transitioning to the Unverified state  may be unnecessary.","In another embodiment, the user may modify one or more of the attributes for the task, thereby transitioning the task back to the Unverified state . Subsequent performances of the measurement task may then necessitate transitioning back through the Verified state  before further measurement operations are performed.","Thus, in one embodiment, the method may operate to perform a first function or operation which may include one or more implicit state transitions, then to perform a second function, which may result in further implicit transitions of the task. More specifically, the implicit transitions may return the task to the original state (which may be any of the task states) from which the first operation was invoked. Thus, from the user's perspective, the system receives the user's method request(s), performs the requested function(s), and returns the task to the original state, and so the numerous state transitions described above may effectively be hidden from the user. In other words, when an explicit state transition is requested, e.g., through a graphical programming node, as many implicit state transitions as are necessary may be made to put the task into the requested state, and as a result, users do not have to think about the current state when requesting an explicit state transition.","As mentioned above, although the above method is described using a task state model with task states, it is also contemplated that such implicit (i.e., programmatic) state transitions may be implemented in a measurement system which does not specifically utilize task states. In other words, the use of implicit state transitions in a measurement system may be used in more traditional measurement systems which use state models based on the status of the measurement resources or other aspects of the measurement system (as opposed to the task itself). It should be noted that although the states Verified, Running, and Committed, were used in the above example, any other states could also be used in the manner described.","FIG. \u2014Using the Task State Model to Perform Multiple Measurement Tasks","One of the benefits of the task-based state model described herein is that applications which use the task-based state model may be higher performing than applications which use the state models of the prior art. A primary unique characteristic of the task-based state model is that the state model is not coupled to the state of the resources (e.g., devices). Instead, the state model is associated with a task. This characteristic enables a customer to create multiple tasks, each with its own state, that all utilize the same resources.","Consider the following use case: a customer develops a manufacturing test application that sequentially and repeatedly executes multiple tests (tasks). Each test may utilize the same resources as other tests.","When using state models of the prior art, the customer would have to develop an application that, each time before a test is performed, explicitly configures the resources for that test. This explicit reconfiguration would occur for every test every time the test sequence is repeated.","In contrast, when using the task-based state model described herein, the customer may develop a higher performing application which first configures all of the tests, e.g., by specifying the customer-definable attributes for each test and then transitioning the task associated with each of the tests to the Verified state , then executing each test as desired, without having to repeat the verification process. Thus, a primary benefit of basing the state model on the measurement task instead of on the measurement resources is that multiple tasks may be specified which share use of one or more measurement resources. In other words, basing the state model (i.e., the states) on the status of the task may allow the portions of the task which are not specifically dependent on the status of the relevant hardware to be maintained separately from the hardware. Significant efficiencies may be achieved using this approach in that most of the work or expense involved in preparing the tasks for execution, i.e., the verification process, may be performed up front. Then, the multiple tasks may be performed sequentially, and optionally iteratively, without having to repeat the verification process for each task performance.  is a flowchart of one embodiment of a method for using a task state model to perform multiple measurement tasks, such as, for example, the multiple manufacturing tests mentioned above.","As  shows, in , a plurality of sets of attributes may be specified for performing a corresponding plurality of measurement tasks, using one or more common measurement resources. Each of the plurality of measurement tasks may be in a first task state, e.g., in the Unverified state . In one embodiment, each of the sets of attributes may comprise a measurement task specification for the corresponding measurement task, as described above. In the manufacturing example from above, each measurement task may correspond to a respective manufacturing test.","Then, in , a corresponding plurality of run-times may be generated based on the plurality of sets of attributes, thereby transitioning each of the measurement tasks from the first state (e.g., Unverified ) to a second state, for example, to the Verified state . As mentioned above, each run-time may include a collection of measurement primitives, initialized with primitive settings derived from the attributes, and operable to manage corresponding measurement resources. Thus, in one embodiment, transitioning the measurement tasks from the Unverified state  to the Verified state  may include compiling the attributes to primitive settings, and initializing the corresponding measurement primitives with the primitive settings to produce the respective run-times for each measurement task, e.g., for each test in the manufacturing example above. In other words, the primitive settings for each measurement task may be deployed into a run-time for each task. It should be noted that at this stage, all of the specified measurement tasks have been prepared without regard to the status of installed hardware of the measurement system. Thus, at this point, before any test has been performed, the application has already created a task and corresponding run-time for each test. Each run-time contains the primitive settings specific to that test. The process of compiling the customer-definable attributes to primitive settings and deploying these primitive settings may be the most expensive operation from a performance perspective. With the task-based state model, these most expensive operations are performed only once; that is, when the manufacturing test system is initialized.","In , a first, or current, run-time of the plurality of run-times may be executed to perform a corresponding current measurement task of the plurality of measurement tasks, thereby transitioning the current task from the second state (e.g., the Verified state ) to a third state, e.g., the Running state . As described above, in one embodiment, transitioning from the Verified state  to the Running state  may include a number of intermediate task state transitions. For example, the task may first be transitioned from the Verified state  to the Reserved state , thereby acquiring the one or more measurement resources needed to perform the current measurement task. Then, the task may be transitioned from the Reserved state  to the Committed state , thereby configuring the one or more measurement resources with the corresponding one or more primitive settings. It is noted that the operation of performing each task is typically a very efficient operation. As the task associated with each test is transitioned to the Committed state , each measurement primitive may program its associated measurement resource with the specified primitive settings for that test. The measurement primitive preferably only programs those aspects of its associated resource that need to be changed for that test. After being configured the one or more resources may be operable to perform the current measurement task. Finally, the task may be transitioned from the Committed state  to the Running state , thereby executing the run-time to perform the measurement task using the one or more (common) measurement resources.","In , execution of the current run-time may be terminated, for example, by user invocation of a Stop method, or by execution of a Stop node, thereby transitioning the current task to the second state, e.g., the Verified state . Note that this transition may include implicit transitions through one or more intervening task states, as described above.","Then, as  shows, in , a determination may be made as to whether there are additional run-times to execute. If there are no more run-times to execute, then the method may terminate, as shown. If, on the other hand, there more run-times to execute, then as indicated in , a next run-time may be selected as the new current run-time, and the method may return to step , described above, where the new current run-time may be executed to perform another respective measurement task, thereby transitioning that task to the third state (the Running state ). The method may then proceed with step  as described above, iteratively executing and terminating execution of each run-time, thereby performing each of the plurality of measurement tasks in succession, where each task used the common one or more measurement resources to perform the desired measurement functions of that task.","It is noted that the approach described above may be used to iteratively perform a single task repeatedly, to iteratively cycle through a multitude of tasks, as described above, and\/or to perform any combination of prepared measurement tasks, as desired. Therefore, while a measurement task state model may manage hardware measurement resources that perform the specific measurement operations, it also contains and manages state information unrelated to the hardware measurement resources. Unlike prior art measurement state models, the measurement task state model is a software construct independent of the hardware measurement resources, and so, may simultaneously facilitate or manage multiple measurement tasks which utilize common measurement hardware resources, each of which may be in any one of a variety of task states. Thus, the separation of hardware-specific aspects of the measurement process from the task-specific aspects via use of a task-based state model may substantially improve efficiencies and flexibility of the measurement system.","FIGS. A and B\u2014Example Application and Benefits of the Task-Based State Model","As mentioned above, in prior art measurement systems, resources may be reserved, programmed, and unreserved continuously due to the fact that current state information of the system is unavailable to system processes and components. For example, in an experiment involving one prior art measurement system, an AI (Analog Input) Read One Scan task involved ten kernel transitions; calculating, verifying, and programming a scan list, timing, triggering, and dithering; calculating and verifying input limits multiple times; and checking accessories multiple times, for each read.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 11A"},"In contrast, in one embodiment of the present invention, a state model of the system may be defined and enforced, substantially eliminating unnecessary state transitions, and enabling customers to more finely control state transitions. For example, in one experiment, a single read task, e.g., an Acquire Single Voltage On Demand task, performed by one embodiment of the invention involved one kernel transition per read, and executed approximately twenty times faster than the prior art measurement system mentioned above.",{"@attributes":{"id":"p-0161","num":"0160"},"figref":"FIG. 11B"},"Benefits of Implicit State Transitions","As described above, the use of a task-based state model which allows explicit state transitions to be invoked by the user may provide a great deal of control over the measurement process, such as by an advanced user. However, another benefit of the task-based state model may be improved usability for the less-advanced user. In general, a potential downside to using a state model is that by giving the advanced user access to all state transitions with which he or she can develop higher performance applications, the less-advanced user may also be required to understand and properly utilize all of these state transitions, which may decrease the usability of the system. Some prior art systems have attempted to strike a balance between these two seemingly contradicting requirements, and as a result, have not provided the advanced user with access to all state transitions, while at the same time have decreased usability of the system for the less-advanced customer.","The task-based state model doesn't attempt to balance these two requirements; instead, it fulfills both requirements through the support of implicit state transitions. Implicit state transitions enable the less-advanced user to ignore those state transition in which he is not interested. From the user's perspective, the system behaves as if the ignored states do not exist.","In one embodiment, in order to preserve the usability of the system, it may be necessary that the implicit state transitions apply to both forward (e.g., Unverified\u2014>Verified->Reserved->Committed->Running) and backward state transitions (e.g., Running->Committed->Reserved->Verified->Unverified) in order to meet the expectations of the less-advanced user. That is, the system may implicitly transition through the required intermediate states to return the task to the last state to which the user explicitly transitioned. For example, if the system implicitly transitions from the \u201cVerified\u201d state to the \u201cRunning\u201d state when the user explicitly invoked the \u201cstart\u201d state transition and then, when the user explicitly invoked the \u201cstop\u201d state transition, the system only transitioned back to the \u201cCommitted\u201d state, the user may be confused since he did not expect the task to still be committed and reserved since he didn't explicitly commit and reserve the task. Instead, the user may expect that the task would be in the \u201cVerified\u201d state. The implicit state transitions in the backward direction to meet the user's expectations. Further examples of the benefits of implicit state transitions are presented below.","In one example of the use of implicit state transitions, a user may configure a task and then immediately read samples. When the user explicitly invokes the read operation, the task may implicitly transition through the \u201cVerified\u201d, \u201cReserved\u201d, and \u201cCommitted\u201d states to the \u201cRunning\u201d state. The task may then invoke the read operation and wait for it to complete. When the read operation completes, the task may implicitly transition back through the \u201cCommitted\u201d and \u201cReserved\u201d states back to the \u201cVerified\u201d state. In this example the user didn't explicitly invoke any state transitions, and so they were able to completely ignore the state model.","In another example of the use of implicit state transitions, a user may configure a task, invoke the \u201cstart\u201d state transition, and then read samples. When the user explicitly invokes the \u201cstart\u201d state transition, the task may implicitly transition through the \u201cVerified\u201d, \u201cReserved\u201d, and \u201cCommitted\u201d states to the \u201cRunning\u201d state. When the user explicitly invokes the read operation, the task doesn't make any implicit state transitions since the task is already in the \u201cRunning\u201d state. When the user explicitly invokes the \u201cstop\u201d state transition, the task may implicitly transition back through the \u201cCommitted\u201d and \u201cReserved\u201d states back to the \u201cVerified\u201d state.","In yet another example the use of implicit state transitions, a user may configure a task, invoke the \u201ccommit\u201d state transition, and then repeatedly invoke the \u201cstart\u201d and \u201cstop\u201d state transitions. When the user explicitly invokes the \u201ccommit\u201d state transition, the task may implicitly transition through the \u201cVerified\u201d and \u201cReserved\u201d states to the \u201cCommitted\u201d state. When the user explicitly invokes the \u201cstart\u201d state transition, the task may transition to the \u201cRunning\u201d state. When the user invokes the \u201cstop\u201d state transition, the task only transitions back to the \u201cCommitted\u201d state. At this point, the user can again explicitly invoke the \u201cstart\u201d state transition. When the user finally explicitly invokes the \u201cuncommit\u201d state transition, the task may implicitly transition back through the \u201cReserved\u201d state to the \u201cVerified\u201d state.","Thus, various embodiments of the systems and methods disclosed herein may use a task-based state model in a measurement system to more efficiently and flexibly perform measurement tasks. Additionally, the measurement system may utilize implicit state transitions in a state model to increase the usability of the measurement system in performing measurement tasks.",{"@attributes":{"id":"p-0169","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["actuator\u2014device used to convert from one phenomenon to another. Typically, the user will need to use an actuator to convert the phenomenon generated by a device to a more useful phenomenon.","application program\u2014a software program which is executable to perform one or more functions, e.g., a software program that is executable to perform one or more specified measurement tasks.","channel\u2014hardware and software resources used to make a measurement or a generation. Hardware resources of a channel include I\/O connector resources and internal resources such as filters, ADC, counters, and the like. Software resources of a channel include scaling, analysis, transfer, and the like. Experts may choose the optimal attribute settings for a channel based on the task specification.","compile\u2014the act of the measurements expert system solving a problem, effectively transforming a measurement task specification into a complete run-time specification. The term \u201ccompile\u201d also refers to converting a software program from source code into executable object code.","generation\u2014production of a phenomenon, or a process which produces a phenomenon.","measurement\u2014the retrieval of one or more characteristics of a phenomenon in order to produce a useful sample of information. For example, measurements may be performed by instruments or other types of devices which acquire real world data. Measurements may be performed for the purposes of simulation, hardware in the loop testing, validation, test, instrumentation, and manufacturing assembly, among other purposes.","measurement device\u2014a hardware or virtual device which is operable to perform a measurement on a phenomenon, a generation of a phenomenon, or a connection. Example measurement devices include any of the devices shown in .","measurement expert system\u2014a software program which may compile a measurement task specification into a run-time specification by selecting and invoking one or more experts.","measurement task\u2014a group of measurements, generations, and connections that share timing, synchronization, and control.","measurement task configuration tool\u2014a software program which may be used to configure measurement tasks; this may be a general purpose development tool or a specific tool; a type of a measurement task specifier, below.","measurement task specification\u2014a set of attributes that define a measurement task. These attributes may be attributes of the phenomena, measurements, generations, or timing that comprise a measurement and automation application. A collection of one or more related attributes. Conceptually, the contents of a task specification represent one task which a user would like to perform atomically. The measurements expert system uses measurements experts to compile a task specification into a populated run-time specification.","measurement task specifier\u2014a program which accepts user input and may be used to produce a measurement task specification for a given measurement task; similar to a task configuration tool, below. An example measurement task specifier is a measurement task configuration tool which may be invoked from a graphical or text-based development environment. Other examples of a measurement task specifier include a measurement task wizard, and a measurement task API. Specific examples of a measurement task specifier include LabVIEW, LabWindows\/CVI, DiaDem, DasyLab, Visual Basic, Visual C++, Delphi, Mathwork's Simulink, Agilent Vee, SoftWire, and other similar programming development environments.","measurements expert\u2014a type of expert designed to operate under arbitration of the Measurements Experts Library. The goal of a measurements expert is to compile a portion of a measurement task specification into a populated run-time specification.","phenomenon\u2014a detectable signal. Users make measurements on phenomena, or generate them. Sensors and actuators convert from one phenomenon to another.","primitive\u2014a single, cohesive object implementing a particular aspect of a measurement system. Primitive supervisors broker primitives. A run-time is composed of an aggregation of primitives.","primitive setting\u2014a collection of properties associated with a particular primitive. Primitive settings are configured by measurements experts, and interpreted by primitive supervisors.","primitive supervisor\u2014invoked by run-time builders, primitive supervisors interpret a specific primitive setting, using the contained properties to reserve an associated primitive.","resource\u2014a single, reservable element of the total means available for performing measurements in a measurement system. Examples of resources include a hardware counter, a RTSI line, or a fixed amount of CPU cycles.","run-time\u2014a collection or sequence of primitives in a specific environment implementing a measurement system. Run-times are built by run-time builders, and may be executed to perform a specific measurement task or operation. The term \u201crun-time\u201d may also refer to other forms of a software program that implement a measurement system.","run-time builder\u2014a software program which may analyze a run-time specification, reserve one or more primitives according to the run-time specification, and configure one or more primitives according to the run-time specification. Interprets a particular run-time specification and builds a run-time. Primitive brokering is delegated to primitive supervisors. The term \u201crun-time builder\u201d may also refer to a software program which may analyze a run-time specification and configure other types of software entities, such as by configuring other types of software program(s) or data structures according to the run-time specification.","run-time specification\u2014a set of parameters specifying hardware or software primitive configurations required for a specified measurement task. A collection of primitive settings populated by measurements experts. Run-time specifications are interpreted by run-time supervisors. The term \u201crun-time specification\u201d may also include a data structure or other representation of information that specifies a measurement task.","sensor\u2014device used to convert from one phenomenon type to another. Typically, the user will need to use a sensor to convert the phenomenon to a type the device can sample. Example sensors include thermocouples, pressure transducers, cameras, etc.","virtual measurement device\u2014a device which is implemented as a software program, or at least a portion of which is implemented as a software program."]}},"Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description of the preferred embodiment is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 2","FIGS. 1A and 1B"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 7A-7C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 9A and 9B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 11B"},"While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims."]},"DETDESC":[{},{}]}
