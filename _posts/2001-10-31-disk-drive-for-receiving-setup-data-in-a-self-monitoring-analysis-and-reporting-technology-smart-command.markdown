---
title: Disk drive for receiving setup data in a self monitoring analysis and reporting technology (SMART) command
abstract: A disk drive is disclosed for receiving a Self Monitoring Analysis and Reporting Technology (SMART) command from a host computer. The disk drive comprises a plurality of configuration parameters stored in a non-volatile manner for configuring at least one system when the disk drive is powered on. The SMART command comprises a command code comprising a predetermined value for identifying the command code as a SMART command and a sub command comprising one of a plurality of predetermine values identifying one of a plurality of SMART commands selected from the group consisting of enabling SMART diagnostics, reading diagnostic data, and transmitting setup data to the disk drive. The SMART command further comprises setup data for modifying the configuration parameters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06895500&OS=06895500&RS=06895500
owner: Western Digital Technologies, Inc.
number: 06895500
owner_city: Lake Forest
owner_country: US
publication_date: 20011031
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to disk drives. More particularly, the present invention relates to a disk drive for receiving setup data in a self monitoring analysis and reporting technology (SMART) command.","2. Description of the Prior Art","Conventional disk drives comprise a sector of configuration parameters used to configure the operating mode when powered on. The configuration parameters are used to configure, for example, the read\/write channel, the cache system, and the error recovery system. The configuration parameters are generally inaccessible from a host computer due to the limitations of its operating system, such as a Microsoft Windows operating system and associated drivers.","A utility has been disclosed for configuring a write-verify error recovery operation from the host computer. However, this utility can only be executed after the host computer is \u201cclean\u201d booted from a floppy disk so that the Microsoft Windows drivers are not installed. After running the utility to configure the write-verify operation, the host computer is rebooted into the Microsoft Windows operating system to resume normal operation.","Rebooting the host computer from a floppy in order to reconfigure a disk drive is undesirable since it precludes running the configuration utility from the more user friendly and familiar Microsoft Windows operating environment. In addition, it may be desirable to run the configuration utility from an Internet web page using an Internet browser program running under a Microsoft Windows operating environment. Still further, it may be desirable to reconfigure the disk drive on-the-fly relative to the type of application program running, or the type of data being manipulated. For example, it may be desirable to configure the error recovery system less stringently when storing Internet web pages in a browser's cache as opposed to storing more critical word processing or accounting documents.","There is, therefore, a need to reconfigure a disk drive in the field from a Microsoft Windows operating system without having to reboot the host computer.","The present invention may be regarded as a disk drive connectable to a host computer executing a computer program for sending a Self Monitoring Analysis and Reporting Technology (SMART) command to the disk drive. The disk drive comprises a disk, a head actuated radially over the disk, an error recovery system for detecting and correcting errors in user data read from the disk, and a cache system for caching user data received from the host computer and user data read from the disk. The disk drive further comprises a plurality of configuration parameters stored in a non-volatile manner for configuring at least one system when the disk drive is powered on, the at least one system selected from the group consisting of the cache system and the error recovery system. The disk drive comprises an interface for receiving the SMART command from the host computer. The SMART command comprises a command code comprising a predetermined value for identifying the command code as a SMART command and a sub command comprising one of a plurality of predetermine values identifying one of a plurality of SMART commands selected from the group consisting of enabling SMART diagnostics, reading diagnostic data, and transmitting setup data to the disk drive. The SMART command further comprises setup data for modifying the configuration parameters.","In one embodiment the disk drive further comprises a volatile semiconductor memory. When the disk drive is powered on, the configuration parameters are copied to the volatile semiconductor memory, and the setup data is used to modify the configuration parameters stored in the volatile semiconductor memory in order to configure the at least one system on-the-fly.","In one embodiment the error recovery system comprises a plurality of retry procedures responsive to the configuration parameters. In another embodiment, the error recovery system comprises an error correction code (ECC) system responsive to the configuration parameters. In yet another embodiment, the ECC system comprises a parity sector mode wherein the ECC system writes parity sectors to the disk, and the configuration parameters enable the parity sector mode.","In one embodiment, the disk drive comprises a write-verify system for verifying a write operation by verifying recoverability of written data, wherein the at least one system configured using the configuration parameters includes the write-verify system. In one embodiment, the configuration parameters enable the write-verify system.","In one embodiment the cache system comprises a semiconductor memory, and the cache system reserves a block of the semiconductor memory for caching data read from the disk during a read operation. The configuration parameters configure when the cache system releases the reserved block of semiconductor memory. In another embodiment, the configuration parameters configure a number of blocks reserved in the semiconductor memory for caching write data received from the host computer. In yet another embodiment, the disk comprises a plurality of tracks, where each track comprises a plurality of sectors. The configuration parameters configure a number of sectors read into the semiconductor memory during a read operation following a target sector of the read operation. In another embodiment, the configuration parameters configure a number of sectors read into the semiconductor memory during a read operation preceding a target sector of the read operation.","In one embodiment, the computer program executed by the host computer comprises a graphical user interface for generating the setup data in response to user input. In another embodiment, the computer program executed by the host computer is a user application program which generates the setup data independent of user input.","In one embodiment, the setup data is received over the Internet. An Internet web server downloads a web page to a computer connected to the disk drive. The computer displays the web page in an Internet browser program in response to user input, the web server transmits a SMART command to the disk drive via the Internet and the computer connected to the disk drive.","The present invention may also be regarded as a computer program embodied on a computer readable storage medium for use in a host computer. The computer program for configuring a disk drive by transmitting setup data in a Self Monitoring Analysis and Reporting Technology (SMART) command to the disk drive. The SMART command comprises a command code, a sub command, and a buffer. The disk drive comprises a disk, a head actuated radially over the disk, an error recovery system for detecting and correcting errors in user data read from the disk, and a cache system for caching user data received from the host computer and user data read from the disk. The disk drive further comprises a plurality of configuration parameters stored in a non-volatile manner for configuring at least one system when the disk drive is powered on, the at least one system selected from the group consisting of the cache system and the error recovery system. The computer program comprises code segments for assigning a value to the command code identifying the command code as a SMART command, assigning a value to the sub command identifying the sub command as a disk drive setup command, and assigning setup data to the buffer, the setup data for modifying the configuration parameters of the disk drive. The computer program further comprises a code segment for transmitting the SMART command to the disk drive.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["2","4","6","2","2","8","10","8","12","8","14","4","8","2","2","14","12","2","16","6","4","6","18","20","2","6","22"]},"In the embodiment of  the disk drive  comprises a disk controller  for implementing the various disk drive systems, including the error recovery system  and the cache system . A semiconductor memory  stores the configuration parameters for access by the disk controller . In one embodiment, the configuration parameters are stored in a reserved sector on the disk . When powered on, the disk drive  reads the configuration parameters from the disk  and stores the configuration parameters in the semiconductor memory . In one embodiment, the setup data  received in the SMART command modifies both the configuration parameters stored on the disk  as well as the configuration parameters stored in the semiconductor memory  so that the disk drive  is configured on-the-fly.","The disk drive  of  further comprises a spindle motor  for rotating the disk  and a voice coil motor (VCM)  for actuating the head  radially over the disk . A servo controller  generates the appropriate control signals applied to the spindle motor  and VCM  in response to commands received from the disk controller . During a write operation the disk controller  transmits user data received from the host computer  to a read\/write channel . The read\/write channel  performs appropriate encoding of the user data to generate write data  written to the disk . The write data  modulates the operation of a preamp  to generate a write signal applied to the head  in order to write magnetic transitions onto the surface of the disk . During a read operation, the head  detects the magnetic transitions representing the recorded data to generate a read signal which is amplified by the preamp  to generate a read signal  applied to the read\/write channel . The read\/write channel  demodulates the read signal  into user data transmitted to the host computer  via the disk controller  after correcting errors using the error recovery system . In the embodiment of  embedded servo data is recorded on the disk , demodulated by the read\/write channel , and used by the servo controller  to position the head  over the target data track.","The disk drive  communicates with the host computer  through a communication protocol referred to as the IDE protocol. The Microsoft Windows operating system comprises a low level \u201cport\u201d driver which communicates with the disk drive  through an IDEREGS data structure shown in FIG. D. There are only a limited number of IDE commands supported by disk drive manufactures as well as the Microsoft Windows operating systems. The standard IDE protocol provides no support for modifying the configuration parameters of a disk drive by a computer program running under a Microsoft Windows operating system. However, the standard IDE protocol does provide support for the Self Monitoring Analysis and Reporting Technology (SMART) which allows a computer program running under a Microsoft Windows operating system to configure a disk drive so that it will accumulate and report diagnostic information. In this manner, the host computer can evaluate the health of the disk drive and report impending failures to the user so that remedial measures can be taken before data is lost. Further details regarding the application programming interface (API) for the SMART protocol can be found in the \u201cWindows 95 and Windows NT SMART IOCTL API Specification\u201d version 01.02 which is incorporated herein by reference.","An IDE command of 0xB0 (inserted into the chComandReg field of the IDEREGS data structure of ) identifies the IDE command as a SMART command. A predetermined number of \u201csub commands\u201d have been defined for the SMART protocol (inserted into the chFeaturesReg field of the IDEREGS data structure of FIG. D), including a sub command for enabling\/disabling the SMART system within the disk drive, as well as a sub command to retrieve the diagnostic data from the disk drive. In one embodiment of the present invention, at least one of the sub commands is redefined by the disk drive  of  to allow the configuration parameters within the disk drive  to be modified by a computer program running under a Microsoft Windows operating system.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2A","b":["2","1"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["HDevice: Identifies the device. The CreateFile function returns this handle.","DwIoControlCode: Specifies the control code for the operation. This value identifies the specific operation to be performed and the type of device on which the operation is to be performed. The following values are defined for this driver:"]}},{"@attributes":{"id":"p-0030","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Meaning "]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DFP_GET_VERSION (0x00074080)","Gets the version and revision"]},{"entry":[{},"of the driver."]},{"entry":["DFP_SEND_DRIVE_COMMAND","Sends a generic command to a"]},{"entry":["(0x0007c084)","drive. Only used to send a"]},{"entry":[{},"command to the drive that sends"]},{"entry":[{},"data or no data is transferred."]},{"entry":["DFP_RECEIVE_DRIVE_DATA","Sends a command to the drive"]},{"entry":["(0x0007c088)","that returns data"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["PvInBuffer: Points to a buffer containing the data required to perform the operation. This parameter can be NULL if the dwIoControlCode parameter specifies an operation that does not require input data.","CbInBuffer: Specifies the size, in bytes, of the lpvInBuffer buffer.","LpvOutBuffer: Points to a buffer in which the operation's output data is returned. This parameter can be NULL if the dwIoControlCode parameter specifies an operation that does not produce output data.","CbOutBuffer: Specifies the size, in bytes, of the lpvOutBuffer buffer.","LpcbBytesReturned: Points to a 32-bit variable that receives the size, in bytes, of the data returned in the lpvOutBuffer buffer.","LpoOverlapped: Points to an OVERLAPPED structure. This parameter is ignored if the hDevice handle was opened without specifying the FILE_FLAG_OVERLAPPED flag. This parameter can be NULL if overlapped operation is not desired. OVERLAPPED (asynchronous) I\/O will not be used by this driver, so this parameter should be set to NULL.","Return Value: If the function succeeds, the return value is TRUE; otherwise, it is FALSE."]}},"Before a computer program can call the DeviceIoControl function of , a handle to the target driver must be obtained. An OpenSMART procedure is set forth in the attached source code appendix for obtaining a handle to the target driver. The OpenSMART procedure utilizes the CreateFile function provided by the Microsoft Windows operating system in order to create the handle to the driver. Once the handle is obtained, the target disk drive is enabled to receive SMART commands by transmitting the appropriate IDE command. A DoEnableSMART procedure is set forth in the source code appendix for enabling the disk drive to receive SMART commands.","Once the disk drive  has been enabled for SMART commands, the setup data for modifying the configuration parameters can be transmitted to the disk drive via a computer program running under a Microsoft Windows operating system. A DoModifyBlockKeySector is set forth in the source code appendix for transmitting the setup data to the disk drive via a SMART command. In this embodiment, the setup data is contained within a MODIFYBLOCK_KEYSECTOR data structure. The MODIFYBLOCK_KEYSECTOR data structure comprises 123 MODIFYBLOCK data structures which contain four bytes each as defined by the following table:",{"@attributes":{"id":"p-0033","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Bytes","Description "]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Action","2","Bits 0 to 9 - Offset from start of configuration data."]},{"entry":["code",{},"For the DRAM copy, this the start of the Config."]},{"entry":["and",{},"Sector memory table; for the media copy, the first"]},{"entry":["Word",{},"entry (\u201cserial number\u201d) after the 24-byte file header."]},{"entry":["Offset",{},"Bits 10 to 12 - Unused (must be zero)"]},{"entry":[{},{},"Bits 13 to 15 - Modify action code"]},{"entry":[{},{},"0 = No action, unused entry"]},{"entry":[{},{},"1 = Replace LS byte"]},{"entry":[{},{},"2 = Replace MS byte"]},{"entry":[{},{},"3 = Replace word (LS and MS bytes)"]},{"entry":[{},{},"4 = Set bit (ones in mask are set to one, zeros in mask"]},{"entry":[{},{},"are unchanged)"]},{"entry":[{},{},"5 = Clear bit (ones in mask are set to zero, zeros in"]},{"entry":[{},{},"mask are unchanged)"]},{"entry":[{},{},"6 to 7 = Undefined"]},{"entry":["LS byte","1","Least significant byte of data or mask"]},{"entry":["MS byte","1","Most significant byte of data or mask"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"A SENDCMDINPARAMS data structure shown in  is used to send input parameters to the disk drive , and a SENDCMDOUTPARAMS data structure shown in  is used to receive output parameters from the disk drive. The dwBufferSize field of the SENDCMDINPARAMS data structure is set to the size of the MODIFYBLOCK_KEYSECTOR data structure which is copied into the chBuffer[1] field. The irDriveRegs are configured appropriately, including to set the SMART sub command field chFeaturesReg to a value kchWriteLoggingSectorFeaturesRegister which in this embodiment is defined as 0\u00d7D6. The DeviceIoControl function of  is then called with the SENDCMDINARAMS data structure, including the MODIFYBLOCK_KEYSECTOR data structure which the disk drive  uses to modify the configuration parameters.","In one embodiment the error recovery system  comprises a plurality of retry procedures responsive to the configuration parameters. The computer program may configure the retry procedures in order to optimize the acceptable latency. For example, the computer program may configure the number of retries to perform before aborting a read operation.","In another embodiment, the error recovery system  comprises an error correction code (ECC) system responsive to the configuration parameters. The ECC system implements any suitable ECC code, such as the well known Reed-Solomon ECC code, wherein a number of redundancy bytes are generated for each data sector and stored with each data sector. The computer program may disable the retry procedures and\/or the ECC code for audio\/visual data in order to prevent the associated latency from interrupting the continuous transfer of a data stream.","In yet another embodiment, the ECC system comprises a parity sector mode wherein the ECC system writes parity sectors to the disk . A parity sector is generated by computing a parity over a predetermined number of data sectors and storing the parity sector with the data sectors. In this manner, if one of the data sectors is unrecoverable using the ECC code it can be reconstructed by combining the parity sector with the other data sectors. The computer program can enable the parity sector mode in order to increase the redundancy and associated protection for more critical data, such as accounting or word processing data.","In one embodiment, the disk drive  comprises a write-verify system for verifying a write operation by verifying recoverability of written data. For example, the disk drive may attempt to read a recently written data sector to verify the recoverability of the data sector before deleting the write data from the semiconductor memory . If the data sector is unrecoverable, the disk drive  may respond by rewriting the data sector, or relocating the data sector and marking the unrecoverable data sector as a defective sector. In one embodiment, the configuration parameters enable\/disable the write-verify system to configure the level of protection desired relative to the associated latency.","In one embodiment the cache system  reserves a block of the semiconductor memory  for caching data read from the disk  during a read operation. The configuration parameters configure when the cache system  releases the reserved block of semiconductor memory . In another embodiment, the configuration parameters configure a number of blocks reserved in the semiconductor memory  for caching write data received from the host computer . In yet another embodiment, the disk  comprises a plurality of tracks, where each track comprises a plurality of sectors. The configuration parameters configure a number of sectors read into the semiconductor memory  during a read operation following a target sector of the read operation. In another embodiment, the configuration parameters configure a number of sectors read into the semiconductor memory  during a read operation preceding a target sector of the read operation.","In one embodiment, the host computer  of  comprises a computer readable storage medium for storing a computer program. The computer program for configuring the disk drive  by transmitting setup data in a Self Monitoring Analysis and Reporting Technology (SMART) command  to the disk drive . The SMART command  comprises a command code , a sub command , and a buffer . The disk drive  comprises a disk , a head  actuated radially over the disk , an error recovery system  for detecting and correcting errors in user data read from the disk , and a cache system  for caching user data received from the host computer  and user data read from the disk . The disk drive  further comprises a plurality of configuration parameters stored in a non-volatile manner for configuring at least one system when the disk drive  is powered on, the at least one system selected from the group consisting of the cache system  and the error recovery system . The computer program comprises code segments for assigning a value to the command code  identifying the command code as a SMART command, assigning a value to the sub command  identifying the sub command as a disk drive setup command, and assigning setup data to the buffer , the setup data for modifying the configuration parameters of the disk drive . The computer program further comprises a code segment for transmitting the SMART command  to the disk drive .",{"@attributes":{"id":"p-0041","num":"0049"},"figref":"FIG. 3","b":["46","46","2","48","2","4","2","2","2","12","14","2","4","4","2","4","12","2"]},"The controls in the embodiment of  further comprise a plurality of check boxes  associated with various types of applications, such as word processing, page layout, image processing, CAD, Internet, data base, and multi-media. The user may configure the disk drive  by selecting the applications that will be run on the host computer . For example, if the user selects audio\/video applications, such as Internet and multi-media, then the configuration utility will configure the error recovery system  of the disk drive  to reduce the correction power and associated latency. If the user selects applications having more critical data, such as word processing and data base applications, the configuration utility will configure the error recovery system  to increase the correction power such as enabling the parity sector mode described above.","The drive setup window  of  also comprises a control  for manually configuring the correction power and associated latency of the error recovery system . The user can adjust the correction power for better or worse reliability by adjusting the tab  on a slide bar. The performance of the disk drive  decreases as the user increases the reliability and associated latency of the error recovery system . The drive setup window  comprises a bar graph  showing how the performance of the disk drive  is modified as the user manipulates the controls.",{"@attributes":{"id":"p-0044","num":"0052"},"figref":"FIG. 4","b":["58","60","58","62","58","46","46","58","60","60","62","2","58","2","60","62"]},"In one embodiment, the disk drive  is configured by a user application program running on the host computer . For example, a word processing or accounting program may configure the disk drive  to increase the correction power of the error recovery system . The configuration may take place when the application is launched, or the application may configure the disk drive  dynamically each time it performs an operation, such as a write operation. For example, each time an accounting program performs a write operation, it may first enable a parity mode of the disk drive  so that the data written is afforded additional protection. Once the write operation terminates, the accounting program may reconfigure the disk drive  to its state prior to the write operation. In this manner, each active user application program can dynamically configure the disk drive  to achieve the desired reliability, performance, or other configuration metric.",{"@attributes":{"id":"p-0046","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SOURCE CODE APPENDIX"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/\/=============================================="},{"entry":"\/\/ FILE: \u2003\u2003SMARTAPI.CPP"},{"entry":"\/\/ DESCRIPTION: \u2003\u2003This file contains functions that allow a"},{"entry":"\/\/ \u2003\u2003Windows application to transfer reserved area files,"},{"entry":"\/\/ \u2003\u2003and modify individual bits, bytes or words within the"},{"entry":"\/\/ \u2003\u2003config sector. This is accomplished by utilizing the"},{"entry":"\/\/ \u2003\u2003DeviceIOControl windows API function that calls the"},{"entry":"\/\/ \u2003\u2003device driver SMARTVSD.VXD. Because there is additional"},{"entry":"\/\/ \u2003\u2003functionality that is not WD specific (such as executing"},{"entry":"\/\/ \u2003\u2003a IDENTIFY DRIVE command), there are additional functions"},{"entry":"\/\/ \u2003\u2003added to provide functionality for as much of what"},{"entry":"\/\/ \u2003\u2003SMARTVSD.VXD provides as possible"},{"entry":"\/\/"},{"entry":"\/\/"},{"entry":"\/\/======================================================"},{"entry":"typedef struct_IDEREGS {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BYTE","chFeaturesReg;","\/\/ Used for specifying DFP \u201csub commands\u201d."]},{"entry":["\u2003BYTE","chSectorCountReg","\/\/ IDE sector count register"]},{"entry":["\u2003BYTE","chSectorNumberReg","\/\/ IDE sector number register"]},{"entry":["\u2003BYTE","chCylLowReg","\/\/ IDE low order cylinder value"]},{"entry":["\u2003BYTE","chCylHighReg","\/\/ IDE high order cylinder value"]},{"entry":["\u2003BYTE","chDriveHeadReg","\/\/ IDE drive\/head register"]},{"entry":["\u2003BYTE","chCommandReg;","\/\/ Actual IDE command. Checked for validity by driver."]},{"entry":["\u2003BYTE","chReserved;","\/\/ reserved for future use. Must be zero."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} IDEREGS. *PIDEREGS, *LPIDEREGS;"},{"entry":"typedef struct_SENDCMDINPARAMS {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003DWORD","dwBufferSize","\/\/ Size of bBuffer in bytes"]},{"entry":["\u2003IDEREGS","irDriveRegs;","\/\/ Structure with drive register values."]},{"entry":["\u2003BYTE","chDriveNumber;","\/\/ Physical drive number to send command to (0,1,2,3)."]},{"entry":["\u2003BYTE","chReserved[3];","\/\/ Reserved for future expansion."]},{"entry":["\u2003DWORD","dwReserved[4];","\/\/ Reserved for future expansion."]},{"entry":["\u2003BYTE","chBuffer[1];","\/\/ Buffer of arbitrary length in which to store the data to be written to drive."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SENDCMDINPARAMS, *PSENDCMDINPARAMS, *LPSENDCMDINPARAMS;"},{"entry":"typedef struct SendCmdOutParams {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003DWORD","dwBufferSize;"," \/\/ Size of bBuffer in bytes"]},{"entry":["\u2003DRIVERSTATUS","DriverStatus;","\/\/ Driver status structure."]},{"entry":["\u2003BYTE","chBuffer[1];","\/\/ Buffer of arbitrary length in which to store the data read from the drive."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003WORD","wActionCodeAndWordOffset;"]},{"entry":["\u2003BYTE","chLSDataByteOrMask;"]},{"entry":["\u2003BYTE","chMSDataByteOrMask;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} MODIFY_BLOCK, *PMODIFY_BLOCK;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003BYTE","chActionCode;"]},{"entry":["\u2003BYTE","chKeyFormat;"]},{"entry":["\u2003BYTE","chFileIDNumber;"]},{"entry":["\u2003BYTE","chAdditionalDataSectors;"]},{"entry":["\u2003CHAR","sSignature[12];"]},{"entry":["\u2003WORD","wModifyBlockCount;"]},{"entry":["\u2003MODIFY_BLOCK","aModifyBlock[123];"]},{"entry":["\u2003CHAR","chReserved;"]},{"entry":["\u2003BYTE","chChecksum;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} MODIFYBLOCK_KEYSECTOR, *PMODIFYBLOCK_KEYSECTOR;"},{"entry":"\/\/ These go inside the Task File for Write and Read Logging Sector Commands"},{"entry":"\/\/"},{"entry":"const BYTE kchWriteLoggingSectorFeaturesRegister = 0xD6;"},{"entry":"const BYTE kchReadLoggingSectorFeaturesRegister = 0xD5;"},{"entry":"const BYTE kchDoIdentifyFeaturesRegister = 0x00;"},{"entry":"const BYTE kchAnyKeySectorSectorCountRegister = 0x01;"},{"entry":"const BYTE kchGenericSmartSectorCountRegister = 0x01;"},{"entry":"const BYTE kchAnyKeySectorSectorNumberRegister = 0xBE;"},{"entry":"const BYTE kchGenericSmartSectorNumberRegister = 0x01;"},{"entry":"const BYTE kchReadOrWriteReservedArcaFileSectorNumberRegister = 0xBF;"},{"entry":"const BYTE kchAnyLoggingSectorCylLowRegister = 0x4F;"},{"entry":"const BYTE kchDoIdentifyCylLowRegister = 0;"},{"entry":"const BYTE kchDoIdentifyCylHighRegister = 0;"},{"entry":"const BYTE kchAnyLoggingSectorCylHighRegister = 0xC2;"},{"entry":"const BYTE kchAnyLoggingSectorCommandRegister = 0xB0;"},{"entry":"\/\/ These go inside the Key Sector Data area (512 bytes)"},{"entry":"\/\/"},{"entry":"const BYTE kchTransferMode = 0x81;"},{"entry":"const BYTE kchReadReservedKeySectorActionCode = 0x01;"},{"entry":"const BYTE kchWriteReservedKeySectorActionCode = 0x04;"},{"entry":"const BYTE kchModifyBlockKeySectorActionCode = 0x05;"},{"entry":"const BYTE kchModifyBlockKeySectorKeyFormat = 0x01;"},{"entry":"const BYTE kchModifyBlockFileIDNumber = 0x42;"},{"entry":"const BYTE ksReadReservedFileSignature[ ] = \u201cWDC^F$&p#\\\\i!\u201d; \/\/ Note one \\ is an escape for the other backslash"},{"entry":"const BYTE ksWriteReservedFileSignature[ ] = \u201cWDC^S#p*\/i$(\u201d;"},{"entry":"const BYTE ksModifyBlockSignature[ ] = \u201cWDC^M)s&!U:+\u201d;"},{"entry":"\/\/=============================================="},{"entry":"\/\/ Name; \u2003\u2003OpenSMART"},{"entry":"\/\/"},{"entry":"\/\/ Description: This function will perform operating system dependent"},{"entry":"\/\/ \u2003\u2003calls that open a handle to the SMART API. This handle"},{"entry":"\/\/ \u2003\u2003is used by nearly every function in the file to"},{"entry":"\/\/ \u2003\u2003access SMART API pass-through calls. Note when the"},{"entry":"\/\/ \u2003\u2003caller of this function cause a handle to be opened,"},{"entry":"\/\/ \u2003\u2003some function on the call stack must eventually call"},{"entry":"\/\/ \u2003\u2003CloseHanlle."},{"entry":"\/\/"},{"entry":"\/\/=============================================="},{"entry":"HANDLE OpenSMART( \u2003\/\/ return the result of CreateFile"},{"entry":"\u2003VOID) \u2003\u2003\/\/ VOID parameter"},{"entry":"{"},{"entry":"\u2003HANDLE \u2003\u2003hSMARTIOCTL = 0;"},{"entry":"#ifdef WINDOWS9X"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Version Windows 95 OSR2, Windows 98"]},{"entry":[{},"hSMARTIOCTL = CreateFile(\u201c\\\\\\\\.\\\\SMARTVSD\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0,"]},{"entry":[{},"0,"]},{"entry":[{},"0,"]},{"entry":[{},"CREATE_NEW,"]},{"entry":[{},"0,"]},{"entry":[{},"0);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"#else"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Windows NT, Windows 2000"]},{"entry":[{},"hSMARTIOCTL = CreateFile(\u201c\\\\\\\\.\\\\PhysicalDrive0\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"GENERIC_READ | GENERIC_WRITE,"]},{"entry":[{},"FILE_SHARE_READ|FILE_SHARE_WRITE,"]},{"entry":[{},"NULL,"]},{"entry":[{},"OPEN_EXISTING,"]},{"entry":[{},"0,"]},{"entry":[{},"NULL);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"#endif"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return hSMARTIOCTL;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/=============================================="},{"entry":"\/\/ Name: \u2003\u2003DoEnableSMART"},{"entry":"\/\/"},{"entry":"\/\/ Description: This function will enable the target drive to accept"},{"entry":"\/\/ \u2003\u2003SMART commands."},{"entry":"\/\/"},{"entry":"\/\/=============================================="},{"entry":"BOOL DoEnableSMART( \u2003\u2003\/\/ return the result of DeviceIOControl"},{"entry":"\u2003HANDLE hSMARTIOCTL, \u2003\u2003\/\/ Handle returned from previous call to OpenSMART,"},{"entry":"\u2003PSENDCMDINPARAMS pSCIP, \u2003\u2003\/\/ Structure that describes command details"},{"entry":"\u2003PSENDCMDOUTPARAMS pSCOP, \u2003\u2003\/\/ Structure that DeviceIOControl fills with results"},{"entry":"\u2003BYTE chDriveNum, \u2003\u2003\/\/ DriveNum = 0 through 3"},{"entry":"\u2003PDWORD pdwBytesReturned) \u2002\/\/ Number of Bytes Returned From DeviceIOControl"},{"entry":"{"},{"entry":"\u2003BOOL bRetVal = TRUE; \/\/ assume success for case where DO_IO_CONTROL is not defined"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Set up data structures for Enable SMART Command."},{"entry":"\u2003\/\/"},{"entry":"\u2003pSCIP\u2212>dwBufferSize = 0."},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chFeaturesReg = SMART_ENABLE_SMART_OPERATIONS;"},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chSectorCountReg = kchGenericSmartSectorCountRegister;"},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chSectorNumberReg = kchGenericSmartSectorNumberRegister;"},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chCylLowReg = kchAnyLoggingSectorCylLowRegister;"},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chCylHighReg = kchAnyLoggingSectorCylHighRegister;"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Compute the drive number."},{"entry":"\u2003\/\/"},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chDriveHeadReg = kchAnyLoggingSectorDriveHeadObsoleteBits | ((chDriveNum & 1) << 4);"},{"entry":"\u2003pSCIP\u2212>irDriveRegs.chCommandReg = kchAnyLoggingSectorCommandRegister;"},{"entry":"\u2003PSCIP\u2212>chDriveNumber = chDriveNum;"},{"entry":"\u2003#if defined(DO_IO_CONTROL)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bRetVal = (DeviceIoControl(hSMARTIOCTL, DFP_SEND_DRIVE_COMMAND,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(LPVOID)pSCIP, sizeof(SENDCMDINPARAMS) \u2212 1,"]},{"entry":[{},"(LYVOID)pSCOP, sizeof(SENDCMDOUTPARAMS) \u2212 1,"]},{"entry":[{},"pdwBytesReturned, NULL) );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003#endif"},{"entry":"\u2003return bRetVal;"},{"entry":"}"},{"entry":"\/\/=============================================="},{"entry":"\/\/ Name: \u2003\u2003DoModifyBlockKeySector"},{"entry":"\/\/"},{"entry":"\/\/ Description: This function writes a sector that allows you to set"},{"entry":"\/\/ \u2003\u2003the value of a byte, word, or bit in the config"},{"entry":"\/\/ \u2003\u2003sector. You can specify 123 such \u201cmodifications\u201d"},{"entry":"\/\/ \u2003\u2003by setting up Modify Block data within the key sector."},{"entry":"\/\/ \u2003\u2003Note that you cannot change the first 24"},{"entry":"\/\/ \u2003\u2003bytes of the config sector with this command. Also"},{"entry":"\/\/ \u2003\u2003note that although there are components of the"},{"entry":"\/\/ \u2003\u2003SMART firmware that support two sectors of modify"},{"entry":"\/\/ \u2003\u2003block data, WD Firmware Engineering (see Mark Vallis)"},{"entry":"\/\/ \u2003\u2003has determined that we only need to implement one"},{"entry":"\/\/ \u2003\u2003sectors worth of modify block data."},{"entry":"\/\/ \u2003\u2003This function performs the write"},{"entry":"\/\/ \u2003\u2003by calling the DeviceIOControl function that in turn"},{"entry":"\/\/ \u2003\u2003calls the SMARTVSD.VXD (or equivalent) driver. The"},{"entry":"\/\/ \u2003\u2003key sector data that is written in a buffer that is"},{"entry":"\/\/ \u2003\u2003part of the PSENDCMDINPARAMS structure. As a result,"},{"entry":"\/\/ \u2003\u2003the data MUST be adjacent in memory with the"},{"entry":"\/\/ \u2003\u2003rest of the PSENDCMDINPARAMS structure. Note that"},{"entry":"\/\/ \u2003\u2003the caller of this function MUST allocate extra space"},{"entry":"\/\/ \u2003\u2003for the data written in thc PSENDCMDINPARAMS"},{"entry":"\/\/ \u2003\u2003structure before calling this function."},{"entry":"\/\/=============================================="}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BOOL DoModifyBlockKeySector(","\/\/ return the result of DeviceIOControl"]},{"entry":["\u2003HANDLE hSMARTIOCTL,","\/\/ Handle returned from previous call to OpenSMART"]},{"entry":["\u2003PSENDCMDINPARAMS pSCIP,","\/\/ Structure that describes command details (including task file input AND output)"]},{"entry":["\u2003PSENDCMDOUTPARAMS pSCOP,","\u2003\/\/ Structure that DeviceIOControl fills with results, also contains read buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003BYTE chDriveNum,","\/\/ DriveNum = 0 through 3"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003PMODIFY_BLOCK pModifyBlock,"," \u2003\/\/ Array of MODIFY_BLOCK structs that the key sector will be filled with"]},{"entry":["\u2003WORD wNumModifyBlocks,","\/\/ Number of Valid MODIFY_BLOCKS in the previous parameter"]},{"entry":["\u2003PDWORD pdwBytesReturned)","\/\/ Number of Bytes Returned From DeviceIOControl"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"BOOL bRetVal = 1;"},{"entry":"\/\/ Note: The first backslash if for the escape character on ksReadReservedFileSignature"},{"entry":"\/\/"},{"entry":"\/\/ Point to the KeySector part of the KeyCmd"},{"entry":"\/\/"},{"entry":"MODIFYBLOCK_KEYSECTOR \u2003KeySector,"},{"entry":"memset((void*) &KeySector, 0, sizeof(KeySector));"},{"entry":"\/\/"},{"entry":"\/\/ Set up data structurcs for DFP_SEND_DRIVE_COMMAND command."},{"entry":"\/\/"},{"entry":"pSCIP\u2212>dwBufferSize = kwKEY_SECTOR_BUFFER_SIZE; \/\/ \u2212 sizeof(SENDCMDINPARAMS) + 1;"},{"entry":"\/\/ Note that when DeviceIOControl has returned these input paramters are"},{"entry":"\/\/ filled with output values from the drive."},{"entry":"\/\/"},{"entry":"pSCIP\u2212>irDriveRegs.chFeaturesReg = kchWriteLoggingSectorFeaturesRegister;"},{"entry":"pSCIP\u2212>irDriveRegs.chSectorCountReg = kchAnyKeySectorSectorCountRegister;"},{"entry":"pSCIP\u2212>irDriveRegs.chSectorNumberReg = kchAnyKeySectorSectorNumberRegister,"},{"entry":"pSCIP\u2212>irDriveRegs.chCylLowReg = kchAnyLoggingSectorCylLowRegister;"},{"entry":"pSCIP\u2212>irDriveRegs.chCylHighReg = kchAnyLoggingSectorCylHighRegister;"},{"entry":"pSCIP\u2212>irDriveRegs.chDriveHeadReg = kchAnyLoggingSectorDriveHeadObsoleteBits | ((chDriveNum & 1) << 4);"},{"entry":"pSCIP\u2212>irDriveRegs.chCommandReg = kchAnyLoggingSectorCommandRegister;"},{"entry":"pSCIP\u2212>chDriveNumber = chDriveNum;"},{"entry":"KeySector.chActionCode = kchModifyBlockKeySectorActionCode;"},{"entry":"KeySector.chKeyFormat = kchModifyBlockKeySectorKeyFormat;"},{"entry":"KeySector.chFileIDNumber = kchModifyBlockFileIDNumber;"},{"entry":"memcpy(KeySector.sSignature, ksModifyBlockSignature, 12);"},{"entry":"KeySector.chAdditionalDataSectors = 0;"},{"entry":"KeySector.wModifyBlockCount = wNumModifyBlocks;"},{"entry":"\/\/ Copy the ModifyBlock data into the KeySector"},{"entry":"\/\/"},{"entry":"memcpy(KeySector.aModifyBlock, pModifyBlock, wNumModifyBlocks * sizeof(MODIFY_BLOCK));"},{"entry":"\/\/ Copy the KeySector into the packet buffer"},{"entry":"\/\/"},{"entry":"memcpy(pSCIP\u2212>chBuffer, &KeySector, kwKEY_SECTOR_BUFFER_SIZE);"},{"entry":"memset(pSCOP, 0x00, sizeof(SENDCMDOUTPARAMS));"},{"entry":"#if defined(DO_IO_CONTROL)"},{"entry":"\u2003bRetVal = (DeviceIoControl(hSMARTIOCTL, DFP_SEND_DRIVE_COMMAND,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(LPVOID)pSCIP, sizeof(SENDCMDINPARAMS) + kwKEY_SECTOR_BUFFER_SIZE \u2212 1,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(LPVOID)pSCOP, sizeof(SENDCMDOUTPARAMS) \u2212 1,"]},{"entry":[{},"pdwBytesReturned, NULL) );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#endif"},{"entry":"\u2003return bRetVal;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2A","b":"1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2B","b":"2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2C","b":"2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
