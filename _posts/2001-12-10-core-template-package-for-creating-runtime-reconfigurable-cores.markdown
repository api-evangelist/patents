---
title: Core template package for creating run-time reconfigurable cores
abstract: A method and apparatus for creating run-time reconfigurable cores using a core template package. The core template package provides an object-oriented application programming interface for specifying run-time reconfigurable (RTR) electronic circuit designs in a RTR application program. A run-time parameterizable (RTP) core library includes a plurality of predefined RTP core classes that implement selected functions in an electronic circuit design when invoked from an RTR application program. An RTP core template package includes a plurality of template classes. Each template class has a predefined set of method interfaces and fields. The RTP core template package further includes an RTP core template class that includes methods for building, connecting and traversing a hierarchy of RTP core objects based on the template classes and the predefined RTP core classes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07143418&OS=07143418&RS=07143418
owner: Xilinx, Inc.
number: 07143418
owner_city: San Jose
owner_country: US
publication_date: 20011210
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["GOVERNMENT CONTRACT","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The U.S. Government has a paid-up license in this invention and the right in limited circumstances to require the patent owner to license others on reasonable terms as provided for by the terms of DABT63-99-3-0004 awarded by DARPA.","The present invention generally relates to run-time reconfigurable computing, and more particularly to tools for creating run-time reconfigurable applications.","Field programmable gate arrays (FPGAs), first introduced by Xilinx in 1985, are becoming increasingly popular devices for use in electronics systems. For example, communications systems employ FPGAs in large measure for their re-programmability. In general, the use of FPGAs continues to grow at a rapid rate because they permit relatively short design cycles, reduce costs through logic consolidation, and offer flexibility in their re-programmability.","The field of reconfigurable computing is advancing steadily, using FPGAs as the basis for high-performance reconfigurable systems. Run-Time Reconfigurable (RTR) systems distinguish themselves by performing circuit logic and routing customization at run-time. RTR systems using FPGAs are expected to result in systems that require less hardware, less software, and fewer input\/output resources than traditional FPGA-based systems. However, scarcity of software that supports RTR is believed to be one reason that RTR has been outpaced by research in other areas of reconfigurable computing.","Current tools for developing an RTR application are perceived as requiring a great deal of knowledge relative to the architecture of the hardware device to which the RTR application is targeted. For example, one tool provides methods for manipulating a configuration bitstream for programming various resources of a programmable logic device. Forcing a designer to think of a design at too low a level complicates matters for the designer.","A system and method that address the aforementioned problems, as well as other related problems, are therefore desirable.","In various embodiments, the invention provides a method and apparatus for creating run-time reconfigurable cores using a core template package. The core template package provides an object-oriented application programming interface for specifying run-time reconfigurable (RTR) electronic circuit designs in a RTR application program. A run-time parameterizable (RTP) core library includes a plurality of predefined RTP core classes that implement selected functions in an electronic circuit design when invoked from an RTR application program. An RTP core template package includes a plurality of template classes. Each template class has a predefined set of method interfaces and fields. The RTP core template package further includes an RTP core template class that includes methods for building, connecting and traversing a hierarchy of RTP core objects based on the template classes and the predefined RTP core classes.","It will be appreciated that various other embodiments are set forth in the Detailed Description and Claims which follow.","Various embodiments of the present invention are described in terms of Java-based abstract classes and the JBits environment from Xilinx. Those skilled in the art will appreciate that the invention could be implemented in other programming languages, applied to programmable logic devices (PLDs) other than FPGAs, and\/or adapted to a variety of applications.","The invention insulates a hardware designer from the details of the lower-level modules that are used to generate a configuration bitstream, while providing a hierarchical, class-based interface for developing a hardware design. In one embodiment, the high-level interface is an object-oriented programming language, such as Java. For an application involving both hardware and software components, the invention presents the opportunity to develop both components in the programming language. This presents benefits in terms of managing the development process and sharing code.","Design of a circuit implemented in an FPGA using a reconfigurable logic coprocessor in some environments requires a combination of two distinct design paths, as shown in . The first and perhaps most significant portion of the effort involves circuit design using traditional CAD tools. The design path for these CAD tools typically comprises entering a design  using a schematic editor or hardware description language (HDL), using a netlister  to generate a netlist  for the design, importing this netlist into an FPGA placement and routing tool , which finally generates a bitstream file  of configuration data used to configure the FPGA .","Once the configuration data has been produced, the next task is to provide software to interface the processor to the FPGA. The user enters user code , which is then compiled using compiler  to produce executable code . The instructions in executable code  are then used by the processor to communicate with the configured FPGA . It is also known to use executable code  to control the configuration of FPGA  with bitstream file . This series of tasks is usually completely decoupled from the task of designing the circuit and hence can be difficult and error-prone.","In addition to the problems of interfacing the hardware and software in this environment, there is also the problem of design cycle time. Any change to the circuit design requires a complete pass through the hardware design tool chain (\u2013 in ). This process is time consuming, with the place and route portion of the chain typically taking several hours to complete.","Finally, this approach provides no support for runtime reconfiguration. The traditional hardware design tools provide support almost exclusively for static design. It is difficult to imagine constructs to support runtime reconfiguration in environments based on schematic or HDL design entry.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":["200","202","200","204","204","200","202","204"]},"Core library  is a collection of macrocell or \u201ccore\u201d generators that are implemented as Java classes. The cores are generally run-time parameterizable (RTP) and relocatable within a device. Examples of cores include counters, adders, multipliers, constant adders, constant multipliers, flip-flops and other standard logic and computation functions.","Bit-level interface  includes an application program interface that allows the user application program  to manipulate configurable resources of programmable logic device . The bit-level interface also includes a set of functions, one or more of which are invoked when the user application program  references the application program interface. The set of functions in the bit-level interface manipulate selected ones of programming bits , based on the type of programmable logic device. For example, some of the functions in the set may be programmed for certain devices in the XC4000 family of FPGAs from Xilinx, Inc., and others of the functions may programmed for other devices in the Virtex\u2122 FPGA family. Bit-level interface software is generally understood by those skilled in the art. For example, bit-level interface software has been provided with the JBits software from Xilinx.","The programming bits are stored in a storage element (not shown). For example, suitable storage media include magnetic, optical, electronic, or various combinations thereof that are readable and writable.","While core library , user application , and bit-level interface  are written in Java in the example embodiment, it will be appreciated that many other languages would also be suitable.","Hardware interface  includes a portable layer of software and accompanying hardware to couple application program  to programmable logic device . For example, hardware interface  may be the Xilinx Hardware Interface (XHWIF) which is available from Xilinx.","Processor  is coupled to programmable logic device  via hardware interface . The functional requirements of system  dictate the particular style and capabilities of processor . For example, some applications may call for a RISC based processor while others may call for a CISC. Various ones of special purpose or general purpose processors from manufacturers such as Intel, Sun Microsystems, Motorola, IBM, AMD and others may be suitable.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["302","304","306","304","302","302"]},"The RTP core template package provides standard design abstractions such as hierarchical modules with ports connected by nets and buses. The package suits both static core implementation and run-time core reconfiguration. There is also support for multiple core outputs formats, for example, a bitstream, netlist, and graphical views of the core structure.","The core template package also supports different granularities, for example CLB, slice and logic element (i.e. half-slice), and other configurable elements. In addition, the core template packages supports relative and absolute placement offsets, non-numeric placement relations, sourceless and inverting nets, IP protection, and subcore re-implementation. These capabilities are provided without a dichotomy between a hierarchical logical view, for example, as in the static design flow using hardware description languages, and a flat physical view of the design. For example, an object of the port class is initially a purely logical object to support a hierarchical design. A port object acquires physical significance by assigning one or more pin values. Flattening the design is not required, since packing and placement occurs hierarchically. The net class provides the router with a physical view of the connections. Low level implementation errors (such as a ConfigurationException or RouteException) are abstracted with a CoreException, which gives the error context in terms of the logical design hierarchy.","The core template package also provides an API for designing cores using, for example, the JBits System Developers Kit from Xilinx. JBits allows direct manipulation of an FPGA configuration bitstream, and provides low-level control over physical resources such as LUTs, multiplexers and interconnects. However, most designers prefer to work at a higher level of abstraction. To this end, the CoreTemplate package provides support for defining a hierarchy of modules with ports that are connected by nets and buses. This permits low-level JBits calls to be encapsulated in leaf-level modules or a library of primitives.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4","b":["302","404","406","408","410","412","414","416","418","420","422","424"]},"RTP core class  is an abstract class defining methods and fields for all levels in a hierarchical design. All cores are required to have an instance name that is passed to a superclass constructor. The subcores of a core should have distinct instance names. The constructors of the RTP core class define the core's ports, height, width, height granularity and width granularity. An implements method calls addChild( ) and defines internal signals. The addChild( ) method creates a parent child relationship between the RTP core object and another object. A parent core assigns the relative offsets of its subcores with respect to the parent's origin, and the application assigns an offset to the top-level core.","The RTP core class serves as a template for dynamically parameterizable and relocatable cores. This core is implemented as an abstract Java class, and is not useful by itself. It is only used as a template to create library core objects. Adhering to the format of this core template will ensure that core objects are consistent, work together, and will be supported in future releases.","The creation of an RTP core object proceeds as follows. The constructor defines the core's external characteristics, which are the ports, the height and width granularity, and the height and width. Constructors must invoke the methods setHeightGran(calcHeightGran( )), setWidthGran(calcWidthGran( )), setHeight(calcHeight( )) and setWidth(calcWidth( )). The calcHeightGran( ), calcWidthGran( ), calcHeight( ) and calcWidth( ) (\u201ccalc\u201d) methods should be static. Parameters that determine the core's granularity attributes and dimensions should be passed to the constructor and to the corresponding calc methods. A core having a fixed granularity or size will not have any arguments passed to the corresponding calc methods. Parameters that cannot be processed until the core is implemented (e.g. LUT contents) are passed to the implements method. Optional ports can be defined after the constructor is called, but this must be completed before the implement( ) method is called.","The setHeightGran( ) method sets the height granularity of the object, and the setWidthGran( ) method sets the width granularity. The setHeight( ) method defines the height of the core object using the value returned from calcHeight( ) method, and the setwidth( ) method defines the width of the core object using the value returned from calcWidth ( ).","The implement( ) method instantiates a subcore in three steps. First, the subcore's constructor is called. Next, addChild(subcore) is called, and the subcore's relative offset is defined, or addChild(subcore, Place) is called which also assigns the offset. Finally, subcore.implement( ) is called. Thus, there is only a single pass over the hierarchy, and it is the same pass that builds the hierarchy. Core construction occurs top-down, and core implementation proceeds bottom-up.","The connect( ) method in bitstream class  invokes the router to implement a net or bus signal, and should be called only once for the net or bus. This should be done at the highest level in the hierarchy where the net or bus is defined, and only after the net or bus is physically defined (i.e. all of the net or bus pins are assigned through all levels of the hierarchy). Otherwise, a RouteException occurs. Subcores connected to the net or bus must be placed and implemented before calling Bitstream.connect( ), because routing is not deferred.","An object of the port class (a \u201cport\u201d)  equates a signal (net or bus) that is external to a core with a signal that is internal to the core. Ports have a direction and width, where the port width is inferred by the width of the external signal, the width of the internal signal, or the number of internal pins. A WidthMismatchException is thrown if these width indicators disagree.","Ports are associated with an RTP core. Initially, the port is a logical object with a name, direction and a width of 0. The ports of a core should have unique names, although this is not enforced. A port acquires physical significance by assigning pin sets to the port, where the number of pin sets should match the width of the port.","If both the internal and external signals are non-null, then these two signals must have the same width or else a WidthMismatchException is thrown. Note that a port can connect a net with a bus of width . If both the internal signal and external signal are null, then the port is not being used and may be ignored.","The connect( ) method in bitstream class  will throw an exception if a port's internal signal is null and the external signal is non-null and the port has no pins, or the internal signal is non-null and the external signal is null. In these situations, it is unknown whether the disconnect is intentional or unintentional. Net.NoConnect can be used to explicitly designate that a signal of a port is to be left unconnected.","An object of the pin class (a \u201cpin\u201d)  associates one or more physical resources with a port. Primitive cores define internal pins for their ports, rather than internal signals. An example of a pin is a LUT input.","An object of the net class (a \u201cnet\u201d)  is a named set of source and sink ports within the scope of a single RTPCore. The implementation is time and space optimized for common cases such as single driver and single fanout nets. Nets may have an inversion (\u201cbubble\u201d) attribute.","An object of the bus class (a \u201cbus\u201d)  is an indexed multiset of nets that are within the scope of a single RTP core object.","An object of the granularity class  identifies the horizontal or vertical granularity of a coordinate. Supported granularities include, for example, CLB, slice and logic element (i.e. the top or bottom half of a slice). This allows fine-grained cores to be defined and placed without wasting CLB resources.","Different granularities are provided because a single granularity is not suitable for all cores. Granularity is similar to data alignment requirements in a microprocessor architecture. CLB granularity is comparable to aligning on a word boundary, slice granularity corresponds to half word alignment (e.g., in Virtex FPGAs), and logic element granularity is akin to byte alignment.","An object of the offset class  identifies the relative or absolute position of cores that use CLB resources, and represents the horizontal and vertical coordinates of the lower left corner of the core's bounding box. Offsets are in terms of CLB coordinates, optional slice coordinate within the CLB, and an optional logic element (i.e. LUT\/FF pair) coordinate within the slice.","Horizontal and vertical offsets are initially undefined, and both must be set. When all horizontal offsets are undefined, calling setHorOffset( ) for one of the granularities sets the horizontal offsets for the other granularities to 0. When all vertical offsets are undefined, calling setVerOffset( ) for one of the granularities sets the vertical offsets for the other granularities to 0.","If either of the operands of an addition or subtraction are undefined, the result will be undefined. The client does not have to ensure that a slice or logic element coordinate is in range after a set, add or subtract operation, because normalization is automatic.","Modifying a vertical logic element offset progresses to the next slice within the current carry chain. Getting or setting a horizontal logic element offset or vertical slice offset will produce an UndefinedGranException.","An object of the place class  provides an optional alternative to calculating offsets, and applies user-defined position relations to the sequence of subcores (e.g. addChild(subcore, Place.ABOVE_PREV_ALIGN_LEFT)). Cores with different granularities may be freely mixed. Without this class, an RTP core must compute and assign horizontal and vertical offsets to each subcore. This code is tedious, opaque and error-prone, especially when subcores have different granularities. The place class abstracts this away by applying user-defined position relations to the sequence of subcores (e.g. addChild(subcore, Place.ABOVE_PREV_ALIGN_LEFT)). Most of the floorplans used in structured datapaths can be succinctly and completely specified in this way. This class requires that RTPCore constructors define the height and width of the core.","The position of the first child core can be in the LOWER_LEFT, UPPER_LEFT, LOWER_RIGHT or UPPER_RIGHT corner of the parent core's bounding box. The position of a subsequent child core and its horizontal or vertical alignment is with respect to the position of the previous child core, or the collection of all previous child cores. For example, the first child core could be placed in the LOWER_LEFT, and subsequent child cores could be placed ABOVE_PREV_ALIGN_LEFT. This creates a column of child cores that grows upwards and is aligned on the left side. In order to fold the column to the right in a zigzag arrangement, a core could be added RIGHTOF_ALL_PREV_ALIGN_TOP. A non-zigzagged folding would be accomplished by adding a core with the directive RIGHTOF_ALL_PREV_ALIGN_BOTTOM.","An object of the bitstream class  encapsulates all calls to the JBits and JRoute APIs. This insulates the core from maintaining JBits and JRoute references, and from administering concurrent netlist file generation.","An object of the core output class  defines what is to be produced by the top-level RTP core object, for example a bitstream or netlist files. More than one output may be produced at the same time.","An object of the core exception class  encapsulates any exception thrown inside an RTP core object, which avoids the need for passing every type of exception up through the calling chain. The original exception is recorded and may be queried.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5"},"In a first stage (block ), the granularity and dimensions of the core are calculated. Every core should define the following four static methods:","public static int calcHeight(PARAMETERS)","public static int calcWidth(PARAMETERS)","public static int calcHeightGran(PARAMETERS)","public static int calcWidthGran(PARAMETERS)","Static methods allow the dimensions and granularity to be determined without first instantiating a core. This facilitates interactive core specialization. Any core parameters that affect the dimensions or granularity should be passed to the calc methods. By doing so, parameters that affect the core's footprint are clearly identified. Cores with fixed size and\/or granularity will not have calc method parameters.","Calculating a core's granularity is explained by way of the following example in which a register is defined with fixed CLB granularities.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/**"]},{"entry":[{},"* Compute and return the vertical granularity of"]},{"entry":[{},"a Register core."]},{"entry":[{},"*\/"]},{"entry":[{},"public static int calcHeightGran( ) {"]},{"entry":[{},"\u2003\u2003return Gran.CLB;"]},{"entry":[{},"}"]},{"entry":[{},"\/**"]},{"entry":[{},"* Compute and return the horizontal granularity of a"]},{"entry":[{},"Register core."]},{"entry":[{},"*\/"]},{"entry":[{},"\u2002public static int calcWidthGran( ) {"]},{"entry":[{},"\u2003\u2003\u2003return Gran.CLB;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In calculating the dimensions of the core, it is assumed that the Register core has a fixed width of 1, where the units are given by the width granularity (i.e. CLB). The height of the core (in CLB units) is equal to the width of the data bus divided by 4.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/**"]},{"entry":[{},"* Compute and return the height of a Register"]},{"entry":[{},"core."]},{"entry":[{},"*"]},{"entry":[{},"* @param busWidth the width of the data input"]},{"entry":[{},"and output ports"]},{"entry":[{},"*\/"]},{"entry":[{},"public static int calcHeight(int busWidth) {"]},{"entry":[{},"\u2003\u2003return (busWidth \/ 4);"]},{"entry":[{},"}"]},{"entry":[{},"\/**"]},{"entry":[{},"* Compute and return the width of a Register core."]},{"entry":[{},"*\/"]},{"entry":[{},"public static int calcWidth( ) {"]},{"entry":[{},"\u2003\u2003return 1;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The second stage of designing a core using the core template package is to define the external characteristics of the core (block ). By convention, an RTP core constructor defines the core's ports, height, width, height granularity and width granularity. Any core parameters which affect the dimensions or granularity should be passed to the constructor. External signals connected to the ports are also generally passed as parameters. If this results in a large number of constructor arguments, then ports may be defined after the constructor is called but before calling the implement( ) method. Alternatively, a CoreParameters object may be used to encapsulate the parameters.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/** Create an instance of a Register core."]},{"entry":[{},"*"]},{"entry":[{},"@param name the name assigned to this Register"]},{"entry":[{},"instance"]},{"entry":[{},"@param busWidth the width of the register, which must"]},{"entry":[{},"be a multiple of 4"]},{"entry":[{},"@param clk the external net to be connected to the"]},{"entry":[{},"CLK port"]},{"entry":[{},"@param din the external bus to be connected to the"]},{"entry":[{},"DIN port"]},{"entry":[{},"@param dout the external bus to be connected to the"]},{"entry":[{},"DOUT port"]},{"entry":[{},"@exception CoreException if busWidth is not a"]},{"entry":[{},"multiple of 4"]},{"entry":[{},"*\/"]},{"entry":[{},"public Register(String instanceName, int busWidth,"]},{"entry":[{},"Net clk, Bus din, Bus dout) throws CoreException {"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Setting the external characteristics include assigning an instance name to the core, checking and storing parameters, setting the dimensions and granularity, and creating ports and connecting external signals. Assigning an instance name to the core is done with an explicit call to the superclass constructor. For example:","super(instanceName);","Checking and storing parameters is performed with the private checkParameters methods. For example:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"try","{"]},{"entry":[{},{},"checkParameters(busWidth);"]},{"entry":[{},"}","catch (CoreParameterException cpe) {"]},{"entry":[{},{},"throw new CoreException(cpe);"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"this.busWidth = busWidth;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Setting the dimensions and granularity of a core is performed by calling the calc methods:","setHeightGran(calcHeightGran( ));","setWidthGran(calcWidthGran( ));","setHeight(calcHeight(busWidth));","setWidth(calcWidth( ));","The generic calc methods will compute the dimensions of any Register instance, while the set methods fix the dimensions of a particular Register instance.","Creating ports and connecting external signals to the ports is performed by defining a field for each port. Internal nets or pins are connected to the port by the implement( ) method. Fields are generally not needed for internal and external signals, since the ports already maintain references to these signals. For example:","clkPort=newInputPort(\u201cCLK\u201d, clk);","dinPort=newInputPort(\u201cDIN\u201d, din);","doutPort=newOutputPort(\u201cDOUT\u201d, dout);","The third stage of defining a core using the core template package is implementing the core (block ). A core C may be implemented only after it has been placed by the core or an application that called C's constructor. C is placed either with placement relations from the place class, or by assigning to C's relative offset. Finally, the implement( ) method is called. For example:",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/**"]},{"entry":[{},"* Implement this Register instance."]},{"entry":[{},"*"]},{"entry":[{},"* @exception CoreException if anything goes awry"]},{"entry":[{},"*\/"]},{"entry":[{},"public final void implement( ) throws CoreException {"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The implement( ) method creates internal signals and connects the signals to ports, and then instantiates and places the primitives. When creating internal signals and making port connections, each port of a non-primitive core defines an internal signal that must match the width of the external signal. For example:","Net clk=newNet(\u201cclk\u201d);","Bus din=newBus(\u201cdin\u201d, busWidth);","Bus dout=newBus(\u201cdout\u201d, busWidth);","clkPort.setIntSig(clk);","dinPort.setIntSig(din);","doutPort.setIntSig(dout);","Continuing with the Register example, the next stage of the implement( ) method instantiates an \u201cFD\u201d primitive for each bit in the data bus. The FD primitives are connected to the internal signals and added as subcores of the Register. Using placement directives, the FDs are packed into a vertical column of CLBs. Finally, each FD is implemented, as illustrated in the example code below:",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for","(int i = 0; i < busWidth; i++) {"]},{"entry":[{},{},"\u2002FD fd = new FD(\u201cfd\u201d + i, FD.FD, clk,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003din.getNet(i), dout.getNet(i));"]},{"entry":[{},{},"\u2002if (i == 0)"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003addChild(fd, Place.LOWER_LEFT);"]},{"entry":[{},{},"\u2002else if ((i % 2) == 0)"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003addChild(fd,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003Place.ABOVE_ALL_PREV_ALIGN_LEFT);"]},{"entry":[{},{},"\u2002else"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003addChild(fd,"]},{"entry":[{},{},"\u2003\u2003\u2003\u2003Place.RIGHTOF_PREV_ALIGN_BOTTOM);"]},{"entry":[{},{},"\u2002fd.implement( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The present invention is believed to be applicable to a variety of systems for run-time reconfiguration of PLDs and has been found to be particularly applicable and beneficial with respect to FPGAs. Other aspects and embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and illustrated embodiments be considered as examples only, with a true scope and spirit of the invention being indicated by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various aspects and advantages of the invention will become apparent upon review of the following detailed description and upon reference to the drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
