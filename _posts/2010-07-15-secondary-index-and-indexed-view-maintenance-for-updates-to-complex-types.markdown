---
title: Secondary index and indexed view maintenance for updates to complex types
abstract: Pursuant to receipt of a data modification command or statement, such as an Update command, it is determined which fields in a data structure, such as a UDT, computed column, indexed view, or index, for example, will be changed as a result of the command. Only those fields that are affected by the command will be changed. Thus, changes are propagated to only to those dependent data structures whose content is being modified. Tree representations are used to facilitate the determination as to whether a subfield in a hierarchy is changed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07933913&OS=07933913&RS=07933913
owner: Microsoft Corporation
number: 07933913
owner_city: Redmond
owner_country: US
publication_date: 20100715
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED CASES","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","Exemplary Computing Environment","Exemplary Embodiments","CONCLUSION"],"p":["The instant application is a divisional application of U.S. application Ser. No. 10\/891,220 filed Jul. 14, 2004, entitled \u201cImproving Secondary Index and Indexed View Maintenance for Updates to Complex Types\u201d which is incorporated by reference herein in its entirety.","The present invention relates generally to the field of information storage and retrieval, and, more particularly, to query optimization and management.","Traditional approaches to the organization of information in computer systems have centered on the use of file-folder-and-directory-based systems (\u201cfile systems\u201d) to organize files into directory hierarchies of folders based on an abstraction of the physical organization of the storage medium used to store the files. Typically, storable data has been organized into files, folders, and directories at the operating system level. These files generally include the file hierarchy itself (the \u201cdirectory\u201d) embodied in a special file maintained by the file system. This directory, in turn, maintains a list of entries corresponding to all of the other files in the directory and the nodal location of such files in the hierarchy (herein referred to as the folders). Such has been the state of the art for approximately forty years.","However, while providing a reasonable representation of information residing in the computer's physical storage system, a file system is nevertheless an abstraction of that physical storage system, and therefore utilization of the files requires a level of interpretation between what the user manipulates (units having context, features, and relationships to other units) and what the operating system provides (files, folders, and directories). Consequently, users (applications and\/or end-users) have no choice but to force units of information into a file system structure even when doing so is inefficient, inconsistent, or otherwise undesirable. Because most existing file systems utilize a nested folder metaphor for organizing files and folders, as the number of files increases, the effort necessary to maintain an organization scheme that is flexible and efficient becomes quite daunting.","Several unsuccessful attempts to address the shortcomings of file systems have been made in the past. Some of these previous attempts have involved the use of content addressable memory to provide a mechanism whereby data could be accessed by content rather than by physical address. However, these efforts have proven unsuccessful because, while content addressable memory has proven useful for small-scale use by devices such as caches and memory management units, large-scale use for devices such as physical storage media has not yet been possible for a variety of reasons, and thus such a solution simply does not exist. Other attempts using object-oriented database (OODB) systems have been made, but these attempts, while featuring strong database characteristics and good non-file representations, were not effective in handling file representations and could not replicate the speed, efficiency, and simplicity of the file-and-folder-based hierarchical structure at the hardware\/software interface system level.","Newly developed storage systems, such as \u201cWinFS\u201d (described further below) store the directory of the files as table(s) in a database. Each file is represented by a row in a base table, and file system operations, such as \u201cenumerate all files in a directory\u201d, are satisfied using queries against the database engine. Thus, efficiently performing basic operations against the store involves efficiently optimizing database queries.","In such storage systems, the concept of a file is extended to that of an \u201cobject\u201d. Metadata about the file is stored in a managed CLR (common language runtime) object with a schema (defined in the storage system) to represent the allowable descriptive data for that object. For example, a picture would have a representative CLR object that would store data such as its resolution, time it was taken, and location information. This object model supports data inheritance. With data inheritance, it is possible to derive a type from another and add new fields. For example, a sub-class of the picture could be created, such as \u201cDriversLicensePicture\u201d. Such a sub-class would contain extra information, such as a Driver's License ID field.","In these newly developed storage systems, such as WinFS, the exposed schemas are mapped to tables through a translation layer. Users only see a series of views of the data instead of operating on the base tables. While the exact design of this mapping is not significant, it serves as the glue between the WinFS API and the underlying storage format. Users do not control or see this mapping directly.","The WinFS store also exposes the concept of querying objects based on their type, as opposed to their file name as in earlier conventional file systems. Type-based queries can search for an exact type or any type that derives from a given type. This latter form is called hierarchical matching, and it is expected to be a common WinFS operation. WinFS also supports searching by file.","WinFS's schema model poses some new challenges to the query processor. User-defined types, or UDTs, are used extensively, and it is common to retrieve all UDTs from a table based on the UDT type. Furthermore, WinFS uses UDT inheritance, and it is also a requirement to retrieve all elements of a given type and also any subtype from a table. Multiple tables exist, each containing a different number of UDTs, types, type topology, and UDT distribution within that topology. Additionally, searching operations may go beyond those operations seen in traditional relational database systems to include, for example, searching of XML documents or performing searches over all fields in an object. These properties make it difficult to make accurate cardinality and cost estimates, and also make it difficult to efficiently retrieve values based on type\/subtype hierarchy.","Materialized views (also referred to herein as indexed views) have been a subject of database research for over a decade. The basic idea is to materialize, or store, the result of some query, then use such computed result when similar queries are submitted to the database. For example, it may be desirable to store the result of sales per day, for example, and use the result (this materialized view) in the future to answer several related queries, such as sales in a given month or total sales in the year.","For additional flexibility, applications should not need to be aware that certain views exist, or are materialized. The query processor should identify matches between user queries and existing pre-computed results (materialized views), and use such results when applicable. This is known as the view utilization problem: Given a user query written over base tables, as well as a collection of materialized views, which materialized views can be used to answer such query? And the cost-based variant of the question: Which of those materialized views should be used?","Materialized views are similar to indices, in that they should be part of the physical design of the database and their primary purpose is to improve performance. The logical design of the database, and correctness of applications should be independent of the presence or absence of materialized views. As with indices, materialized views can introduce dramatic improvements in query performance.","Query optimizers are normally structured such that there is an initial simplification stage, followed by exploration of alternatives and cost-based selection of an execution plan, as shown in .","During the simplification\/normalization stage , some changes are made on the original query Q, such as pushing selections down, or rewriting a subquery as a join, when possible. These modifications are aimed at obtaining a \u201cbetter\u201d query. Typically, there is no detailed cost estimation at this stage, and a single \u201cbetter\u201d query Q\u2032 is produced as the result.","The second stage  (exploration and cost-based selection) in optimization is directed to generating multiple alternatives, and using a detailed cost model to select the alternative with the cheapest estimated execution cost. Two conventional architectures for the exploration stage are bottom-up, dynamic programming join enumeration, and transformation-driven generation of alternatives. Both architectures set up a table of alternatives, as is well known, which compactly encodes the various possibilities for each sub-expression of a query.","The SQL query language provides a user with the ability to query (and modify) tabular data stored using the relational data model. The relational data model dictates that each cell in a table (a column of a row) is a single scalar (or atomic) value. The structured query language (SQL) is an American National Standards Institute (ANSI) standard used to communicate with a relational database. SQL statements are used to perform tasks such as update data or retrieve data from a relational database. Although many database systems use SQL, many of them also have their own additional proprietary extensions that are usually only used on their system. However, the standard SQL commands such as \u201cSelect\u201d, \u201cInsert\u201d, \u201cUpdate\u201d, \u201cDelete\u201d, \u201cCreate\u201d, and \u201cDrop\u201d can be used to accomplish many things that one desires to do with a relational database and are believed to be well known to those skilled in the database art.","The SQL Server database management system (DBMS) supports secondary indexes and indexed views built over tables, to speed up certain kinds of data retrieval operations. A secondary index is a data structure organized like a tree, which contains a subset of the columns belonging to the table. An indexed view is the pre-computed result of a query stored into a derived table, which can have secondary indexes as well. Secondary indexes and indexed views are referred to as data structures dependent on the table. Other kinds of dependent objects exist, such as constraints.","When an Insert, Update, or Delete statement is processed, the DBMS has to propagate the change from the table to the dependent structures, so that they are always kept consistent which each other. This allows subsequent data retrieval queries to return the same data independently on whether they access the table, a secondary index, or an indexed view. Thus, whenever modifications are made to the table, they must be made to the secondary indexes and indexed views, as well. The cost of making changes is proportional to the number of places where the change has to be made. While Insert and Delete operations need to be propagated to all the secondary indexes and indexed views, Update statement processing is conventionally optimized to propagate the change only to the data structures that carry columns being modified by the statement. For example, if a secondary index only contains the column C1 of a table T, an update to the C2 column will not be propagated to the index, because its content will be unchanged.","Both secondary indexes and indexed views can be built in SQL Server over both regular table columns and scalar expressions over table columns. For example, it is possible to build a secondary index over the sum of the C1 and C2 columns. Conventionally, whenever an Update statement affects one or more of the columns participating in a scalar expression, the expression will be assumed to be changing, and the change will be propagated to all the dependent data structures that carry this expression.","Support for complex data types has been added to SQL Server through UDTs. The syntax of the SQL Update statement allows granular updates to subfields of a UDT, along with the ability to overwrite an entire column with a new value. However, by using the traditional technique described above for scalar expressions, a granular update to a UDT would be assumed to affect all the data structures dependent on any of its subfields, and thus changes are propagated to dependent data structures whose content might not be modified by the update. This technique is inefficient and expensive. In other words, conventionally, granular updates to UDT columns are assumed to affect all its subfields, thereby degrading performance in the presence of many dependent access paths.","For example, in the prior art, for an Update, it is assumed that if any of the terms in the expression are being changed, then the entire expression is being changed. For example, in the computed column PERSON.ADDRESS.ZIP, when any of PERSON's subfields are updated, it is assumed that the address and zip also change, so the computed column is always updated. This is a very conservative approach, and not desirable.","In view of the foregoing, there is a need for systems and methods that overcome the limitations and drawbacks of the prior art.","The following summary provides an overview of various aspects of the invention. It is not intended to provide an exhaustive description of all of the important aspects of the invention, nor to define the scope of the invention. Rather, this summary is intended to serve as an introduction to the detailed description and figures that follow.","Pursuant to receipt of a data modification command or statement, such as an Update command, it is determined which fields in a data structure, such as a user-defined type (UDT), computed column, indexed view, or index, for example, will be changed as a result of the command. Only those fields that are affected by the command will be changed. Thus, changes are propagated to only to those dependent data structures whose content is being modified. Tree representations are used to facilitate the determination as to whether a subfield in a hierarchy is changed.","Exemplary embodiments include a method of processing a data modification statement, comprising receiving a data modification statement, determining which fields of a data structure are affected by the data modification statement, and modifying a query plan in response to the fields of the data structure that are affected by the data modification statement.","According to aspects of the invention, a tree representation for the data modification statement is determined, along with operator trees representing the expressions of the secondary structures related to the involved tables. Both trees are compared to determine which secondary structures are affected by the data modification statement.","Another exemplary embodiment is directed to a system for processing a data modification statement, comprising a front end that receives a data modification statement, and a query optimizer that determines which fields of a data structure are affected by the data modification statement, and modifies a query plan responsive to the fields of the data structure that are affected by the data modification statement.","According to aspects of the invention, the front end comprises a parser and algebrizer that transforms the textual representation of the data modification statement into tree nodes. The front end may be adapted to determine a tree representation for the data modification statement and for the expressions of secondary structures. The query optimizer may be adapted to determine which secondary structures are affected by the data modification statement by comparing the tree representation for the secondary structures and the tree representation for the data modification statement.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments that proceeds with reference to the accompanying drawings.","The subject matter is described with specificity to meet statutory requirements. However, the description itself is not intended to limit the scope of this patent. Rather, the inventors have contemplated that the claimed subject matter might also be embodied in other ways, to include different steps or combinations of steps similar to the ones described in this document, in conjunction with other present or future technologies. Moreover, although the term \u201cstep\u201d may be used herein to connote different elements of methods employed, the term should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.","Numerous embodiments of the present invention may execute on a computer.  and the following discussion are intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Although not required, the invention will be described in the general context of computer executable instructions, such as program modules, being executed by a computer, such as a client workstation or a server. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types.","An \u201cobject\u201d is a unit of storable information accessible to a hardware\/software interface system that has a basic set of properties that are commonly supported across all objects exposed to an end-user by the hardware\/software interface system shell. Objects also have properties and relationships that are commonly supported across all types including features that allow new properties and relationships to be introduced. A complex structured type consists of a set of fields, properties, and methods. Each field or property can be one of a scalar type, a complex structure type itself, or of a multiset in which each element is a complex structured type.","Those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including handheld devices, multiprocessor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","As shown in , an exemplary general purpose computing system includes a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start up, is stored in ROM .","The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the personal computer .","Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs) and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers. The exemplary system of  also includes a host adapter , Small Computer System Interface (SCSI) bus , and an external storage device  connected to the SCSI bus .","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","While it is envisioned that numerous embodiments of the present invention are particularly well-suited for computerized systems, nothing in this document is intended to limit the invention to such embodiments. On the contrary, as used herein the term \u201ccomputer system\u201d is intended to encompass any and all devices comprising press buttons, or capable of determining button presses, or the equivalents of button presses, regardless of whether such devices are electronic, mechanical, logical, or virtual in nature.","As illustrated in the block diagram of , a computer system  can be roughly divided into three component groups: the hardware component , the operating system component , and the applications programs component .","In certain computer systems , and referring back to , the hardware  may comprise the central processing unit (CPU) , the memory (both ROM  and RAM ), the basic input\/output system (BIOS) , and various input\/output (I\/O) devices such as a keyboard , a mouse , a monitor , and\/or a printer (not shown), among other things. The hardware component  comprises the basic resources for the computer system .","The applications programs component  comprises various software programs including but not limited to compilers, database systems, word processors, business programs, videogames, and so forth. Application programs provide the means by which computer resources are utilized to solve problems, provide solutions, and process data for various users (e.g., machines, other computer systems, and\/or end-users).","The operating system component  comprises the operating system itself and its shell and kernel. An operating system (OS) is a special program that acts as an intermediary between application programs and computer hardware, and the purpose of an operating system is to provide an environment in which a user can execute application programs. The goal of any operating system is to make the computer system convenient to use, as well as utilize the computer hardware in an efficient manner.","The operating system is generally loaded into a computer system at startup and thereafter manages all of the application programs (or simply \u201capplications\u201d) in the computer system. The application programs interact with the operating system by requesting services via an application program interface (API). Some application programs enable end-users to interact with the operating system via a user interface such as a command language or a graphical user interface (GUI).","An operating system traditionally performs a variety of services for applications. In a multitasking operating system where multiple programs may be running at the same time, the operating system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The operating system also manages the sharing of internal memory among multiple applications, and handles input and output to and from attached hardware devices. The operating system also sends messages to each application (and, in certain cases, to the end-user) regarding the status of operations and any errors that may have occurred.","An operating system's shell is the interactive end-user interface to an operating system. A shell is the outer layer of an operating system that is directly accessible by application programs and even directly by end-users. In contrast to a shell, the kernel is an operating system's innermost layer that interacts directly with the hardware components.","As well understood by those of skill in the relevant art, \u201cfiles\u201d are entities of information (including but not limited to the operating system itself, as well as application programs, data sets, and so forth) that are capable of being manipulated as discrete (storable and retrievable) entities by an operating system. In modern operating systems, files are the basic units of storable information (e.g., data, programs, and so forth) that are manipulated by the operating system, and groups of files are organized in \u201cfolders\u201d.","A storage platform for organizing, searching, and sharing data that can be used with the present invention is designed to be the store for all types of data. Referring to , a storage platform  in accordance with the present invention comprises a data store  implemented on a database engine . In one embodiment, the database engine comprises a relational database engine with object relational extensions. In one embodiment, the relational database engine  comprises the Microsoft SQL Server relational database engine.","The data store  implements a data model  that supports the organization, searching, sharing, synchronization, and security of data. Specific types of data are described in schemas, such as schemas ,  and the storage platform  provides tools  for deploying those schemas as well as for extending those schemas.","A change tracking mechanism  implemented within the data store  provides the ability to track changes to the data store. The data store  also provides security capabilities  and a promotion\/demotion capability . The data store  also provides a set of application programming interfaces  to expose the capabilities of the data store  to other storage platform components and application programs (e.g., application programs , , and ) that utilize the storage platform.","The storage platform of the present invention still further comprises an application programming interface (API) , which enables application programs, such as application programs , , and , to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas. The storage platform API  may be used by application programs in combination with other APIs, such as the OLE DB API  and the Microsoft Windows Win32 API .","The storage platform  of the present invention may provide a variety of services  to application programs, including a synchronization service  that facilitates the sharing of data among users or systems. For example, the synchronization service  may enable interoperability with other data stores  having the same format as data store , as well as access to data stores having other formats. The storage platform  also provides file system capabilities that allow interoperability of the data store  with existing file systems, such as the Windows NTFS file system . A SQL store  may also be provided.","In at least some embodiments, the storage platform  may also provide application programs with additional capabilities for enabling data to be acted upon and for enabling interaction with other systems. These capabilities may be embodied in the form of additional services , such as an Info Agent service  and a notification service , as well as in the form of other utilities .","In at least some embodiments, the storage platform is embodied in, or forms an integral part of, the hardware\/software interface system of a computer system. For example, and without limitation, the storage platform of the present invention may be embodied in, or form an integral part of, an operating system, a virtual machine manager (VMM), a Common Language Runtime (CLR) or its functional equivalent, or a Java Virtual Machine (JVM) or its functional equivalent, or other such software components in the place of or in addition to the operating system in a computer system. The purpose of a hardware\/software interface system is to provide an environment in which a user can execute application programs.","Through its common storage foundation, and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers, and enterprises. It offers a rich and extensible programming surface area that not only makes available the capabilities inherent in its data model, but also embraces and extends the existing file system and database access methods.","In the description herein, and in various ones of the figures, the storage platform  of the present invention may be referred to as \u201cWinFS.\u201d However, use of this name to refer to the storage platform is solely for convenience of description and is not intended to be limiting in any way.","The data store  of the storage platform  of the present invention implements a data model that supports the organization, searching, sharing, synchronization, and security of data that resides in the store. The data model provides a mechanism for declaring objects and object extensions and for establishing relationships between objects and for organizing and categorizing objects.","The relational database engine , which in one embodiment comprises the Microsoft SQL Server engine, supports built-in scalar types. Built-in scalar types are \u201cnative\u201d and \u201csimple\u201d. They are native in the sense that the user cannot define their own types and they are simple in that they cannot encapsulate a complex structure. User-defined types (\u201cUDTs\u201d) provide a mechanism for type extensibility above and beyond the native scalar type system by enabling users to extend the type system by defining complex, structured types. Once defined by a user, a UDT can be used anywhere in the type system that a built-in scalar type might be used.","The storage platform schemas are mapped to UDT classes in the database engine store. Data store objects are mapped to UDT classes deriving from the Base.Item type. Extensions are also mapped to UDT classes and make use of inheritance. The root Extension type is Base.Extension, from which all Extension types are derived.","A UDT is a CLR class\u2014it has state (i.e., data fields) and behavior (i.e., routines). UDTs are defined using any of the managed languages\u2014C#, VB.NET, etc. UDT methods and operators can be invoked in T-SQL against an instance of that type. A UDT can be the type of a column in a row, the type of a parameter of a routine in T-SQL, or the type of a variable in T-SQL, for example.","The present invention is directed to optimizing granular updates to UDTs or other data structures in the presence of indexes or indexed views over scalar expressions that represent their subfields. Exemplary optimization comprises detecting if such indexes or indexed views over UDT subfields are affected by a data modification statement (e.g., an Update command), and changes are propagated only to the dependent data structures whose content is being modified. Aspects of the invention involve detecting the presence of scalar expressions representing a subfield or subfields of a UDT inside an index or indexed view definition or any other kind of dependent object, matching such expressions against the representation of the granular update being run, and determining whether the data structure needs to be maintained or not.","Pursuant to receipt of a data modification command or statement, such as an Update command, it is determined which fields in a data structure, such as a UDT, computed column, indexed view, or index, for example, will be changed as a result of the command. An Update command is used in the description of the exemplary embodiments described herein, but it is contemplated that other types of data modification commands or statements may be used. Only those fields that are affected by the command will be changed. Thus, changes are propagated to only to those dependent data structures whose content is being modified. Tree representations are used to facilitate the determination as to whether a subfield in a hierarchy is changed.","For example, a computed column has a representation in tree form. This tree representation is obtained, along with a tree representation of the data modification statement or command. The two tree representations are compared to determine if the computed column should be updated.","Similarly, indexed views (stored pre-computed query results) can be used in accordance with the present invention.  shows a flow diagram of an exemplary method of processing a data modification statement in accordance with the present invention. At step , a data modification statement is received, along with a textual representation of the indexed view (which may be received or determined separately). An operator tree (i.e., a relational tree) that defines the indexed view (or whatever field of the data structure is being considered) is then determined, at step . At step , a tree representation for the data modification statement is determined. For each of the relational operators in the tree determined at step , its child scalar expressions are obtained, and compared to the update tree from step  to determine if the fields of the data structure being considered are being updated, at step . If so, the query plan is modified accordingly, at step . If the fields of the data structure being considered are not to be changed or otherwise modified by the data modification command or statement, then no change is made to the related portion of the query plan, at step .","In particular, a query processor walks the tree representation of the update, trying to match subfields used in the index expressions with those being updated. If a match is found, the corresponding index expression is considered to be changed and a query execution plan will be generated that propagates the update to the index. Because only the subfields that are being changed or updated by the data modification command are considered, the runtime (disk access) is thus more efficient. Examples are provided with respect to .","Database management systems (DBMS) allow modification of existing table rows through Update statements or other data modification commands. For example, a user may specify, via a command statement, the table to update (called the target table), the columns to modify and their respective new value(s), and qualify the rows to be updated through a Where clause, which is similar to that in a Select statement.","An example of an Update statement is \u201cUpdate T set A=5 Where B=10\u201d, which means that for each row in table T where column B is 10, column A has to be set to 5. A flow diagram of exemplary steps involved when receiving this statement in this example is shown in . At step , the table T is read. A filter is applied to the table at step  to determine which column B's are \u201c10\u201d. At step , the column A's corresponding to the \u201c10\u201d column B's are \u201cupdated\u201d to be set equal to \u201c5\u201d.","The updating during step  uses an update query plan compiled by a query optimizer, described further below. The update query plan compiled by the query optimizer guarantees the preservation of data integrity after its execution. This is achieved by a proper instrumentation of the plan, with actions falling in two categories, either validating a constraint or maintaining a dependent data structure so that its content remains consistent with the target table. DBMSs allow redundant duplication of data in secondary data structures, to allow faster processing of certain categories of queries. Maintaining consistency between the base table and its dependent secondary structures allows subsequent data retrieval queries to receive the same results, independently from the data source that is chosen to implement the operation.","An Update statement can hence be seen as firing actions that were not explicitly described in the original syntax, but that are implicitly used in order to preserve data integrity. These actions are performed at step . Typical implicit actions are: secondary index maintenance; indexed view maintenance; check and referential integrity constraint validation; cascading actions; full text notifications; and query notifications. In SQL Server, the implicit update actions are desirably performed after modifying the base table and in appropriate order.","In order to identify the desired implicit actions to include in the update query plan, the SQL Server query optimizer enumerates the various kinds of objects that have a dependency on the table being updated. For each object, it is determined if the object is affected by the statement. If this is the case, the plan is modified to include appropriate operators guaranteeing that its execution does not cause data corruption for the object. An object is considered to be affected by the statement only if referencing one or more of the columns being updated.","Avoiding maintenance of objects that do not reference columns or other data structure fields being updated is a compile-time optimization that avoids processing operations guaranteed to be unnecessary by the syntax of the statement. Such optimization is desirable in order to guarantee acceptable performance. The number of dependent objects can be very high, and some of the implicit actions used to maintain them can be extremely expensive.","Query processing in accordance with the present invention is implemented in the SQL Server DBMS through the interaction of the following exemplary components, as shown in : a front end (parser and algebrizer) , a query optimizer , a query execution component , and a storage engine . The front end  and query optimizer  perform at compile time, and the query execution component  and storage engine  perform during execution time.","A SQL command or data modification statement, such as Update, is received (e.g., as text from a user). The front end  receives the query statement in textual format, and converts it to a tree based representation describing at the logical level what the command is meant to do. In other words, a parser\/algebrizer transforms the textual representation of the user's commands into tree nodes. The parser provides an update operator that internally represents the update statements functionally (semantically). The algebrizer provides TARGET TABLE, COLUMNS, NEW VALUES, TYPE OF UPDATE, for example.","The query optimizer  explores the possible alternative ways of implementing the query statement, trying to choose the most efficient. The query optimizer  produces another tree that represents, at the physical level, the plan to implement the query statement. A query optimizer generates the physical plan, by transforming the tree and finding the structural (physical) implementation that should be performed to implement the functionality. The optimizer determines the secondary indexes that are to be maintained (i.e., partial update index maintenance). The optimizer enumerates the dependencies on the TABLE (dependencies include indexed views and secondary indexes, for example). For each dependent object, the type of dependency is determined, along with what it is based on (e.g., based on a column(s) or an expression(s), based on a subfield of a UDT.) If the dependency is based on a UDT expression that extracts a subfield, then the syntax of the command is taken and it is determined if the dependent object is being affected by the update or not.","The query plan comprises appropriately interconnected query execution operators, which function by processing the rows they receive from their inputs, and passing the output of such processing to the operator that follows. The combination of the first two phases is called compilation, and its output\u2014the query plan\u2014is saved to memory to be reused in case the same query is issued again in the future. Techniques like substituting constants with logical parameters in the query statement allow more frequent reuse of the same plan.","The query execution component  executes the query plan generated by the query optimizer , interacting with the storage engine , which is the component that ultimately stores and retrieves the data. The query execution component receives subtrees for index maintenance from the optimizer, and executes the physical tree built by the query optimizer. Execution is performed by a storage engine to modify the data that is stored in the indexes, so that individual fields are updated.","Query execution plans for implementing Update statements in SQL Server are split in two phases. The first part is read only, and responsible for determining which rows are to be updated. The second part consumes the rows provided by the first, and performs the actual data modification.","It is contemplated that the invention can be used with any type of dependency and can be extended, among the others, to constraints over columns. Constraints may be user defined during table generation (e.g., zip code is 5 digits).","When processing a regular Update statement, the SQL Server query processor enumerates all the access paths dependent on the target table, extracts the list of columns used inside these dependent access paths, and verifies whether any of them is present in the assignment list. If this is the case, the content of the access path is considered to be changing, and the query execution plan is modified accordingly. For example, given a table T with columns (C1, C2, C3), and an index over C1+C2, an update of the form \u201cUpdate T Set C1=2\u201d, will result in a query execution plan that propagates the changes to the index. The plan for the statement \u201cUpdate T Set C3=10\u201d will instead leave the index untouched, resulting in better performance at runtime.","This functionality is improved when the table contains one or more UDT type columns, with index expressions using subfields of these columns, for example. A granular update is represented in the SQL Server relational algebra as a tree of special-purpose scalar operators (referred to herein as \u201cUdtMultiUpdate\u201d and \u201cUdtPropertySetter\u201d). These operators are desirably behind the scenes and are not known to the user (the user is aware of \u201cUpdate\u201d, but not these operators). The UdtPropertySetter scalar operator is used to set the value of a certain subfield of a UDT column or subfield. The UdtMultiUpdate scalar operator is used to group together updates to subfields of a UDT column or subfield. It can be stacked in a recursive fashion to describe updates to subfields at different levels in the UDT column.","Accessing UDT subfields in index expressions is represented by a scalar algebra tree using the scalar operator \u201cUdtFunction\u201d, for example. This operator can also be stacked on top of itself to drill down into a UDT structure. The lowest node in such a tree is desirably an identifier node representing the UDT column and each UdtFunction node on top of that identifier node drills down one level in the UDT structure.","The examples below illustrate the use of both the UdtMultiUpdate\/UdtPropertySetter and the UdtFunction operators. As noted above, when processing such a granular update statement, the SQL Server query processor will walk the tree representation of the update, trying to match subfields used in the index expressions with those being updated. If it finds a match, the corresponding index expression is considered to be changed and a query execution plan will be generated that propagates the update to the index.","An example is directed to a multi-level UDT structure, and a table T has a column \u201cPerson\u201d of UDT type \u201cPerson\u201d. The Person type is defined as having the following structure:",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type Person"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int ssn; \/\/ Social security number."]},{"entry":[{},"int age; \/\/ Age."]},{"entry":[{},"string name; \/\/ Name."]},{"entry":[{},"type Address address; \/\/ Address. This is also a UDT type."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"type Address"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"string street; \/\/ Street."]},{"entry":[{},"string zip; \/\/ Zip code."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UPDATE T SET person.(age = 10,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"address.( street = \u20181 Microsoft Way\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"zip = 98007))"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"figref":["FIGS. 8 and 9","FIG. 8","FIG. 9"],"b":["800","810","910"]},"As can be seen from the trees in the example, the update tree  drills down into a UDT hierarchy, while the index expression trees ,  represent subfields of the UDT, with scalar nodes towards the bottom of the tree representing subfields higher in the hierarchy. This is why the exemplary tree matching technique walks the update tree in a top-down fashion but matches subfields in the index expressions from bottom to top. An exemplary technique starts from the top of the update tree  identifying that the UDT column being partially updated is \u2018person\u2019. For all the index expression trees , , it then looks at the bottom node, and tries to match this with Person. In this case, both index expressions match. Although the matching sequence of both index expression trees ,  are described together, it is noted that each index expression is considered separately to reduce the complexity of the method.","Because up to this point both index expressions might be changed by the Update, the higher tree nodes in the index expression (and lower tree nodes in the update tree ) are now processed. Thus, both the Address and SSN fields are matched against the child nodes of the top-level UdtMultiUpdate. In this example, only Address matches, and it can therefore be deduced that the first index (person.ssn) is not affected by this Update. The process continues for the second index, and Zip is then matched against the children of the UdtMultiUpdate(address) node. One of these children is UdtPropertySetter(zip), meaning the second index should be maintained.","Another example is directed to inheritance in a UDT. This example uses the table T set forth above, with an Address UDT and subtype of Address, USAddress, as shown:",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"type Address"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"string street; \/\/ Street."]},{"entry":[{},"string city; \/\/ City."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/ USAddress is a subclass of Address; it contains all the members of"},{"entry":"Address."},{"entry":"type USAddress : Address"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int zip; \/\/ Zip code."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Just like in any object-oriented programming language, the SQL Server UDT architecture allows for subtypes of a UDT type to be stored, updated, and queried over instead of that UDT \u2018base\u2019 type. This means that some of the Person instances may contain a USAddress instead of the base Address. The \u2018Treat\u2019 keyword is used to treat certain types as one of their subtypes.","Assume a user's query is:",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UPDATE T SET person.(age = 10,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"TREAT(address as USAddress).(street = \u20181 Microsoft Way\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"zip = 98007))"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An exemplary update scalar tree  is shown in . The matching technique described above is used in processing this example as well. Note that every field in a UDT desirably has an ordinal that is unique for the whole inheritance hierarchy of that UDT. In the example above, if street and city in Address have ordinal 1 and 2 respectively, then zip will have ordinal 3, thus avoiding conflicts between derived classes. Subfields in the update expression are matched up with subfields in the index expressions using their ordinal numbers. This technique also allows the use of Treat in the index expressions.","The various systems, methods, and techniques described herein may be implemented with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computer will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, a video recorder or the like, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to perform the functionality of the present invention.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same functions of the present invention without deviating therefrom. Therefore, the present invention should not be limited to any single embodiment, but rather construed in breadth and scope in accordance with the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIGS. 8","b":["9","10"]}]},"DETDESC":[{},{}]}
