---
title: Programming language extensions for processing data representation language objects and related applications
abstract: A system is provided for manipulating data representation language basedâ€”objects in a native programming language environment. In one embodiment, the system is used to map data objects of the data representation language to corresponding objects within the native programming language and vice versa. In one embodiment, the system is equipped to receive a mapping definition mapping selected elements of a data representation language, such as an XML data structure, to selected objects of a programming language, such as ECMAScript. The system is further equipped to determine whether the mapping definition comprises one or more definitional statements expressed with data representation language oriented language elements of a programming language. Further, the system is equipped to process the mapping definition statements comprising data representation language oriented language elements of the programming language, in accordance with syntactical and semantic definitions of the data representation language oriented language elements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06918107&OS=06918107&RS=06918107
owner: BEA Systems, Inc.
number: 06918107
owner_city: San Jose
owner_country: US
publication_date: 20020222
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Overview","Language Extensions","Example Applications","Scenario 1","Scenario 2","Scenario 3","Example Host Computer System","Conclusion and Epilogue"],"p":["This patent application is a continuation-in-part of non-provisional application Ser. No. 09\/898,898 filed on Jul. 02, 2001, now U.S. Pat. No. 6,754,884, and claims priority to provisional application No. 60\/302,892 also filed on Jul. 2, 2001.","1. Field of the Invention","The present invention relates to the field of programming languages. More specifically, the present invention relates to a method for manipulating data representation language based objects in a native programming language environment.","2. Background Information","XML is rapidly emerging as the de-facto standard for transmitting data structures between software applications and web services. While most software applications and web services are written in modern programming languages, such as Java or C++, none of these programming languages provide native support for representing and manipulating XML. Consequently, programmers are forced to develop or adopt external software packages for representing and manipulating XML within the context of their applications and web services.","In general, external software packages are not capable of providing the host language with native support for processing XML data. As such, they represent and manipulate XML in ways that are quite different than those provided by the host language for its native data types. Most often, external software packages represent XML data using a general purpose tree abstraction and provide a tree-based application programming interface (API) for navigating and manipulating the data (e.g., getParentNode( ), getChildNodes( ), removeChild( ), etc.). This method of accessing and manipulating data structures is cumbersome and time consuming compared to methods used for accessing and manipulating data structures native to the host programming language.","Therefore, a programming language that enables the manipulation of data representation language data structures such as XML with the same power and flexibility afforded native data structures is desirable.","In the following description, various aspects of the present invention will be described. However, it will be apparent to those skilled in the art that the present invention may be practiced with only some or all aspects of the present invention. For purposes of explanation, specific numbers, materials and configurations are set forth in order to provide a thorough understanding of the present invention. However, it will also be apparent to one skilled in the art that the present invention may be practiced without the specific details. In other instances, well known features are omitted or simplified in order not to obscure the present invention.","Concepts and terminology commonly used by those familiar with compiler and parser design are used herein. Those who are unfamiliar with the inner workings of compilers and parsers are referred to \u201cCompilers: Principals, Techniques and Tools\u201d by A. Aho, R. Sethi and J. Ullman published by Addison Wesley Publishing Company in November 1985 (ISBN 0201100886). In addition, basic familiarity by the reader with XML concepts and terminology, including XML, XML Schema, the Document Object Model (DOM), the XML Query Language and XPath is assumed. Those unfamiliar with these technologies are referred to the following World Wide Web Consortium (W3C) publications: Extensible Markup Language (XML) 1.0 (Second Edition), W3C Recommendation REC-XML-20001006, 6, Oct. 2000; Document Object Model (DOM) Level 1 Specification, W3C Recommendation REC-DOM-Level-1-19981001, 1, Oct. 1998; XQuery 1.0: An XML Query Language, W3C Working Draft WD-XQUERY-20021220 20, Dec. 2001; XML Path Language (XPath), W3C Recommendation REC-XPATH-19991116, 16, Nov. 1999; XML Schema Part 0: Primer, W3C Recommendation REC-XMLSCHEMA-0-20010502, 2, May 2001; XML Schema Part 1: Structures, W3C Recommendation REC-XMLSCHEMA-1-20010502, 2, May 2001; and XML Schema Part 2: Datatypes, W3C Recommendation REC-XMLSCHEMA-2-20010502 2, May 2001.","Parts of the description will be presented in terms of operations performed by a processor based device, using terms such as receiving, analyzing, determining, generating, and the like, consistent with the manner commonly employed by those skilled in the art to convey the substance of their work to others skilled in the art. As well understood by those skilled in the art, the quantities take the form of electrical, magnetic, or optical signals capable of being stored, transferred, combined, and otherwise manipulated through mechanical and electrical components of the processor based device; and the term processor include microprocessors, micro-controllers, digital signal processors, and the like, that are standalone, adjunct or embedded.","Various operations will be described as multiple discrete steps in turn, in a manner that is most helpful in understanding the present invention, however, the order of description should not be construed as to imply that these operations are necessarily order dependent. In particular, these operations need not be performed in the order of presentation. Further, the description repeatedly uses the phrase \u201cin one embodiment\u201d, which ordinarily does not refer to the same embodiment, although it may.","The present invention includes the provision of functional descriptions in the form of programming language extensions to facilitate flexible manipulation of data representation language structures such as XML objects in a native programming environment. The language extensions include a native XML data type and a collection of operations that enable programmers to navigate and manipulate XML objects in much the same way native language objects are navigated and manipulated. Accordingly, the present invention provides a mechanism for manipulating both XML and native language objects, that is particularly well suited for the increasingly ubiquitous problem of mapping XML objects into and out of software applications and web services written in modern programming languages.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","104","105","102","100","104","105","100","102","104","106","106"]},"For the illustrated embodiment, interpreter\/compiler  includes an application programming interface (API) (not shown), through which programming statements formed using language extensions of the present invention may be programmatically submitted for compilation by a variety of application-specific processes. For example, in accordance with one embodiment of the present invention, a web server application makes calls to mapping services  upon the receipt of XML documents in order to map XML document objects as e.g., internal Java classes for additional processing by the web server. Such application-specific processes may be co-resident with mapping services  on the same \u201chost\u201d system (not shown) as mapping services , or located remote from the \u201chost\u201d system and communicate with mapping services  using conventional cross system communication techniques.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["104","104","102","202","105","104","204","206","105","102","104","208","104","210","212","104","104"]},"As described above, conventional programming languages do not provide sufficient functionality when it comes to interoperability and translation between XML documents and programming language objects. Therefore, in accordance with the teachings of the present invention, XML-oriented language extensions for use in association with a programming language, such as Java, C++, ECMAScript, and so forth, are provided and will now be described. To avoid confusion, the following language extensions are described in relation to ECMAScript, however, the applicability of the present invention should not be read as being limited solely to ECMAScript.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIGS. 3A-3E","FIG. 3A"],"b":["300","300","105","104","104"]},"Language extension  illustrates an assignment made between a structured expression including XML syntax and an XML-typed variable. For example, in line (A) an XML-typed variable \u201cp\u201d is assigned an XML structure representing a person element including both name and age elements (e.g. \u2018John\u2019 and \u201825\u2019, respectively). Although the expression in line (A) includes an explicit XML-type indicator (as described above), variables initialized using expressions containing XML syntax do not require such explicit XML-type declarations when used in loosely typed languages. In one embodiment, the \u201c<\u201d symbol, which is used in all XML tag definitions, is further utilized in the present invention as a unary operator to indicate to the interpreter\/compiler that the expression to follow is to be treated as a string and parsed as an XML expression. In one embodiment, the operand of the \u201c<\u201d operator is the entire XML literal up to and including the matching end tag. Accordingly, since the unary operator \u201c<\u201d triggers a result in a value of type XML, it is not necessary for variables of loosely typed languages being assigned XML literals to be explicitly declared as type XML. For example, lines (B)-(E) illustrate an XML-type variable \u201ce\u201d that has been implicitly declared as type XML based upon the content of the expression.","Language extension  illustrates that, in accordance with the teachings of the present invention, portions of an XML literal can be determined dynamically through the use of embedded expressions. In the illustrated embodiment, the mapping services of the present invention dynamically resolve portions of XML literals containing embedded ECMAScript expressions. In one embodiment, interpreter\/compiler  is equipped to recognize a set of curly braces (e.g., \u201c{. . . }\u201d) as an embedded expression operator having higher precedence than the unary operator \u201c<\u201d (described above). However, it should be noted that operators other than \u201c{ }\u201d may be utilized as an embedded expression operator without departing from the spirit and scope of the invention. In any event, if parser  identifies that the embedded expression operator is present within an expression, the operand indicated by the embedded expression operator is passed to interpreter\/compiler  for evaluation, with the resulting return value being coerced (described below) to a string. Thereafter, string concatenation is used to insert the return value between the XML literals preceding and following the embedded expression. Once all the embedded expressions have been evaluated and their results inserted within the XML literal, the presence of the unary operator \u201c<\u201d causes interpreter\/compiler  to convert the resulting string to an XML type.","Language extension  of  illustrates the principle of type coercion practiced by interpreter\/compiler . In accordance with one embodiment of the invention, any value of type string that occurs where parser  expects a value of type XML is automatically converted to the XML data type by parsing the contents of the string as XML data. Prior to the conversion, the string value can be constructed and manipulated using string arithmetic without regard for XML constraints such as well-formedness. For example, in line (D), an XML type variable \u201cemployees\u201d is assigned the result of multiple string concatenations. More specifically, the variable \u201ctagName\u201d of type string is concatenated with two other string values (e.g., \u201c<\u201d and \u201c>\u201d) to form XML open and close tags. The resulting tags are again treated as strings and concatenated with the values of variables John and Sue, which are also treated as strings notwithstanding the fact that they represent XML expressions (e.g. as illustrated in lines (A) and (B)). The string value resulting from the concatenations is then coerced back into an XML value due to the explicit \u201cXML\u201d data type declaration.","Additionally, string values are also automatically coerced into XML values in other contexts where XML is expected. For example, string values passed to functions expecting XML parameters and string values embedded within XML literals will similarly be converted into XML. Accordingly, line (E) yields the same result as line (D). As with other type coercions, interpreter\/compiler  uses the symbol table to determine whether the \u2018type\u2019 of a particular value matches that of it's target variable, function parameter, etc. When a string value is provided where an XML value is expected, the compiler employs an XML parser to perform the conversion. When an XML value is expected and the value provided is neither XML nor a string, the compiler attempts to convert the value to a string (e.g., with Java's Object.toString( ) method), then parses the resulting string as XML.","Language extension  illustrates how child elements may be accessed and\/or assigned in accordance with one embodiment of the present invention. As shown in the illustrated embodiment, once a variable contains an XML value, the child elements of the XML variable may be accessed and\/or assigned using a predefined operator such as a period\/dot (\u201c.\u201d) (hereinafter \u201cdot operator\u201d). The dot operator examines all of the child elements of its left operand and returns in order, those elements with names that match the right operand. This may result in zero or more elements being returned. In one embodiment, if the designated child element is a leaf node (i.e. does not contain any child elements itself), then the content of that child element is returned. However, if the designated child element is not a leaf node, then the designated child element complete with all of its descendants is returned (see e.g. (D)). Additionally, it is possible for the left operand of a dot operator to be a list of elements instead of a single element (e.g., consider when two or more dots are used in succession). In this case, the dot operator iterates over the list examining the children of each element in order. This treatment intentionally blurs the distinction between a single element and lists of elements to simplify the programmer's task.","Language extension , illustrates that attributes of an XML element may be accessed and assigned using an \u201cattribute\u201d operator. The attribute operator examines all of the attributes of its left operand and returns the value of the one whose name matches its right operand. In one embodiment, the attribute operator is represented by the \u2018.@\u2019 symbol. For example, in line (A), the value associated with the \u2018id\u2019 attribute for one of at least two employees is retrieved and assigned to an \u2018empid\u2019 variable of type integer, while in line (B), the \u2018id\u2019 attribute of the fourth employee is set to \u201810\u2019.","In accordance with one embodiment of the invention, elements referenced by IDREF or IDREFS attributes (e.g., indicated by an appropriate declaration in an XML Schema or Document Type Declaration (DTD)) are made accessible as if they were immediate child elements of the attribute. For example, given the structure illustrated in line (A), the expression shown in line (B) would cause all boss id's to be returned, while the expression shown in line (C) would cause the names of all the bosses to be returned, and the expression shown in line (D) would cause the ages of all the bosses to be returned. In one embodiment, if the left operand of the dot operator (i.e. \u201c.\u201d) is an IDREF or IDREFS attribute, the dot operator will retrieve the value(s) of the left operand, search the document for elements containing an ID attribute (e.g., indicated by an appropriate declaration in an XML Schema or DTD) whose value is equivalent to one of the values of the left operand, and return a list of zero or more matching elements. In one embodiment, interpreter\/compiler  may maintain an efficient mapping associating each ID value in the document with the node it identifies to avoid repeatedly searching the document for ID attributes with matching values.","In addition to providing direct access to the immediate child elements of an XML value, the language extensions of the present invention provide direct access to all descendents (i.e., children, grandchildren, great grandchildren, etc.) of an XML value (see e.g., language extension  of FIG. C). In one embodiment the \u201cdouble dot\u201d (e.g. \u2018..\u2019) operator examines all of the descendent elements of its left operand and returns those with names that match its right operand in document order. When the left operand is a list of elements, the \u201c..\u201d operator iterates over the list examining the descendents of each element in order. For example, the expression of line (E) will cause the employee names (e.g. \u2018Joe\u2019 and \u2018Sue\u2019) defined in lines (A)-(D) to be returned.","Language extension  illustrates an indexing property of the present invention, whereby given a list of child elements, a predefined indexing operator can be utilized to identify an individual child element within the list. In one embodiment, this is accomplished by extending interpreter\/compiler  to provide automatic type coercion between the host language's array type and XML NodeLists. In one embodiment, a set of square brackets \u201c[ ]\u201d is used as the indexing operator. The indexing operator essentially selects a single element from its left operand based on its ordinal position within the list (i.e. as indicated by the indexing operator). The left operand may represent a list of elements, or a single element. In the event the operand represents a single element, it will be treated as a list having a size equal to one.","The present invention also provides for iterating over lists of child elements as illustrated e.g. by language extension . In one embodiment, iterating over lists of child elements is accomplished using the native methods used to iterate over arrays in the host programming language. For example, as illustrated in lines (A)-(B), the expression \u201ce..name\u201d returns a list of elements, and the \u201cfor\u201d statement steps through the list in order. For each element in the list, the \u201cfor\u201d statement assigns the variable \u201cn\u201d to the element and proceeds to print the element preceded by the text \u201cEmployee name:\u201d. Alternatively, the length of a list of child elements may be determined using the methods available in the host programming language to determine the length of an array. For example, in the statement on line (C)), the length of the list of child elements is determined by accessing the implicit \u201clength\u201d property (e.g., \u201c.length\u201d) used by the host ECMAScript language for determining the length of arrays. Accordingly, lines (C)-(D) produce the same result as produced by lines (A)-(B).","Language extension  of  illustrates filtering with predicates, in accordance with one embodiment of the invention. When selecting a collection of elements, it is possible to filter the resulting collection such that only elements for which the provided filtering predicate are determined to be true will be returned. In one embodiment, filter predicates are enclosed within parentheses following a \u201c.\u201d (i.e. dot) operator. For example, the expression illustrated in line (A) of , returns employee elements having the name \u201cJohn\u201d, whereas line (B) returns the name associated with the employee element having an ID equal to \u201c1\u201d. Line (C) illustrates the use of a predicate composed of a Boolean operator with two sub-expressions. In the illustrated example, employee elements with an ID equal to a first value (e.g. \u201c0\u201d) OR a second value (e.g. \u201c1\u201d) are returned. In practice, other Boolean operators such as AND, and NOT can also be used. Likewise, although the illustrated filtering predicates test only for equivalence, in accordance with one embodiment, all standard comparison operators such as \u201c<\u201d, \u201c\u2266\u201d, \u201c>\u201d, \u201c\u2267\u201d, and \u201c!\u201d can be used in filtering a collection of elements. For example, the expression \u201cemp=e..employee.(@id<2).name\u201d could be used to return employee elements having an ID value less than 2. In one embodiment, a predicate can contain any expression that produces a Boolean value when evaluated in the context of the left operand of the filtering predicate.","In one embodiment of the present invention, interpreter\/compiler  is equipped to recognize a dot operator followed by a set of parentheses (e.g., \u201c.( )\u201d) as a filtering predicate operator, indicating that a filtering predicate is to be employed. When recognized, the filtering predicate operator returns a list of zero or more elements from the left operand for which the test condition stipulated inside the parentheses is true. The filtering predicate operator iterates through the list of elements in its left operand and applies the test located inside the parentheses to each element. If the test succeeds (i.e. returns a value of true), the element is added to the list of elements returned. It should be noted that lines (C) and (D) are semantically equivalent.","Language extension  illustrates a further aspect of the present invention whereby anonymous elements can be used to represent document fragments. In accordance with the illustrated embodiment, document fragments are represented as a collection of elements embedded in an unnamed or anonymous parent element. This notation is convenient in cases such as when the developer wishes to replace the entire contents of an element (e.g. child elements of the subject parent element) in one operation rather than performing several independent operations. For example, line (B) illustrates how the contents of one element (i.e. the content of employee[1] and all child elements) can be replaced using a single document fragment. More specifically, by using the anonymous element concept of the present invention, the lines of code indicated by (C) may beneficially be replaced by the single line of code indicated by line (B). In one embodiment of the present invention, interpreter\/compiler  is equipped to allow the outermost parent element of an XML literal to remain unnamed (which would otherwise not be syntactically allowed). The interpreter\/compiler creates an XML document fragment to represent the contents of the unnamed element. Operations between anonymous elements and named elements affect only the children of the named elements, not the elements themselves. For example, the expression in line (B) replaces all of the children of the second employee element, but does not change the name or attributes of the employee element itself.","The language extensions of the present invention further include a mechanism for writing reusable functions in programming languages other than the host programming language when those languages are deemed to be better suited than the host programming language for performing a particular task. In one embodiment, an API is defined to extend the host programming language with parsers and expression evaluators for one or more other languages. In one embodiment, the API includes a language lookup table to associate language keywords with a specific external parser and expression evaluator for the respective language, a standard set of objects for passing the name and body of a function to a language parser, and a standard set of objects for passing the function name and parameters into the expression evaluator and returning the result of the expression from the expression evaluator.","In one embodiment of the invention, as shown e.g. in , a \u201clanguage\u201d token is introduced into the host programming language to facilitate use of reusable functions in programming languages other than the host programming language. Each time a parser, such as e.g. parser , encounters a function declaration preceded by the \u201clanguage\u201d token, the parser annotates the function's entry in the host language's symbol table with an appropriate language keyword (e.g., XPATH, XQUERY, etc.), finds the appropriate language parser using the language lookup table, and invokes the parser while passing the name and body of the function as parameters. This allows the parser to generate an efficient parsed representation of the function and store it under the associated function name. Thereafter, each time the host programming language expression evaluator encounters a function invocation, the parser determines the correct language by looking in the annotated symbol table, finding the appropriate expression evaluator by using the language lookup table, and invoking the expression evaluator using the API described above to provide the function name and parameters.","The language extensions of the present invention also define a mechanism for creating and enforcing restricted sub-types of the XML data type using a data type description language, such as XML Schema. In one embodiment, this is accomplished using the host programming language's construct for importing external data types. For example, in ECMAScript or Java, this is accomplished using the \u201cimport\u201d statement. In this example, an external XML Schema file is used to describe a class of XML objects in the same way an external Java class file is used to describe a class of Java objects. Importing an XML Schema file creates a collection of new data types for manipulating XML values conforming to the constraints defined in the Schema file. Each of these types is a restricted form of the general XML type with the XML Schema file defining the nature and extent of these restrictions. Interpreter\/compiler  enforces these restrictions through a combination of compile-time and run-time checks for each operation.","For example, a \u201ccar.xsd\u201d file may contain an XML Schema describing XML documents with the following structure:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<car vin=\u201d . . . \u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<make> . . . <\/make>"]},{"entry":[{},"<model> . . . <\/model>"]},{"entry":[{},"<color> . . . <\/color>"]},{"entry":[{},"<engine>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<size> . . . <\/size>"]},{"entry":[{},"<cylinders> . . . <\/cylinders>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/engine>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/car>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"This Schema could be imported to create a new XML datatype called \u201ccar\u201d using the \u201cimport car.xsd\u201d statement, while the statement \u201ccar mycar\u201d might create a new variable called \u201cmycar\u201d of type \u201ccar\u201d including mandatory elements and default values specified by the \u201ccar.xsd\u201d file. Thereafter, the newly created \u201cmycar\u201d variable may be manipulated and assigned values using native programming language constructs and the XML operators described by the current invention. For example, the following statements could all be used to assign values to the various members of the \u201cmycar\u201d variable:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mycar.car.@vin = \u201d123456\u201d;"]},{"entry":[{},"mycar.car.make = \u201cFord\u201d;"]},{"entry":[{},"mycar.car.model = \u201cMustang\u201d;"]},{"entry":[{},"mycar.car.color = \u201cRed\u201d;"]},{"entry":[{},"mycar.car.engine.size = 2.2;"]},{"entry":[{},"mycar.car.engine.cylinders = 6;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, interpreter\/compiler  (including parser ) is augmented with calls to validation algorithms for each type of Schema constraint. Accordingly, in the above example, the statement \u201cmycar.car.doors=4;\u201d would return a compile-time error as \u201cdoors\u201d is an invalid element name based upon the imported car Schema. Similarly, in the above example, the statement \u201cemycar.car.engine.cylinders=\u2018yes\u2019;\u201d would return an error if the XML Schema file \u201ccar.xsd\u201d specified that \u201ccylinders\u201d must contain an integer. In one embodiment, runtime validation may be deferred until explicitly requested using the validate( ) function built into the XML data types (e.g. \u201cmycar.validate( )\u201d).","Various functional descriptions in the form of programming language extensions have been described above that facilitate flexible manipulation of XML objects in a native programming environment. The language extensions include a native XML data type and a collection of operations that enable programmers to navigate and manipulate XML objects in much the same way native language objects are navigated and manipulated. Thus in accordance with the teachings of the present invention, programmers are able to navigate and manipulate XML objects using familiar constructs of the native programming language, while availing themselves to the flexibility and extensibility afforded by XML. More specifically, in accordance with one embodiment of the invention, by integrating a native XML type into a given programming language such as Java, XML-based member functions for performing common operations within a native programming and\/or scripting language can be made available. For example, the table of  illustrates various built-in XML member functions that can be made available to native programming languages through the use of the language extensions of the present invention.","As alluded to above, the language extensions of the present invention are particularly well-suited for use in mapping objects from a data representation language to corresponding objects of a programming language, and vice versa. Such a language mapping may be desirable in situations where, for example, a system having an internal operating environment based upon a programming language such as Java, is required to exchange data with other systems using a data representation language such as XML.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 4","b":["405","110","415","402","402","405","410","415","410","405","415","402"]},"Assume, for example, that service provider  has developed a new web service for generating interactive geographic maps that highlight various points of interest on behalf of client . To take advantage of this service offered by service provider , client  transmits a list of points of interest to service provider  via network . In response, service provider  generates one or more interactive geographic maps, which display selectable representations of the points of interest provided by client . Service provider  then returns one or more URL(s) pointing to the geographic map(s) to client , which in turn utilizes the URL(s) to display the geographic map(s) to end users . Each time a geographic map is presented to end users  by client , end users  may select one or more of the points, which are then returned to service provider . Service provider  then transmits the selected points back to the client  for any further processing client  wishes to perform.","The nature of the processing client  may perform is determined by client  and depends e.g. upon the context in which the service provider's services are utilized. For example, client  may represent a real estate agency that uses the points to display demographic data and property locations to end users , a weather service that uses the points to graphically display temperatures and weather phenomenon the weather service has gathered, a product manufacturer that uses the points to graphically display store locations, and so forth.","Each such incarnation of client  may utilize their own pre-defined XML format for transmitting such points of interest. For example, the weather community may have agreed on a format for transmitting information about weather phenomenon, the real estate community may have agreed on a format for transmitting information about homes, and product manufactures may have agreed on a format for transmitting store locations. Example 1 shows an XML format used e.g. by the product manufacturing community for transmitting the locations of stores that carry their products:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"EXAMPLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<available-at>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<store>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<name>The Electronics Store<\/name>"]},{"entry":[{},"<address>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<street>23 Transistor Dr.<\/street>"]},{"entry":[{},"<city>Circuit<\/city>"]},{"entry":[{},"<state>WA<\/state>"]},{"entry":[{},"<zip>12345<\/zip>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/address>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/store>"]},{"entry":[{},"<store> . . . <\/store>"]},{"entry":[{},"<store> . . . <\/store>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/available-at>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Internally, however, service provider  represents points of interest as an array of points, each defined by the Java class shown below in Example 2:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"EXAMPLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public class Point {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"String label;","\/\/ text to display next to point"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"LatitudeLongitude location;\/\/ location of point on map"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In order to make it easy for a broad range of client communities to access their service, service provider  would like to be able to accept data in a wide variety of XML formats (i.e. such as the one shown in Example 1), and then have that data automatically mapped into analogous data structures within the native programming language of service provider .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIGS. 5A-5B","FIG. 4","FIG. 5A"],"b":["405","410","405","410","405","5"]},"Reference is now drawn to  within which the \u201cFromXML\u201d function is illustrated. Assume, for example, a new client is in the process of transmitting location data to service provider  in the form of an XML document containing the structure shown in Example 1. Upon receiving the data, service provider  initiates a function call to \u201cFromXML\u201d. Among items to note within the function, statement  uses the \u201cdouble dot\u201d operator (described above), in addition to the \u201c.length\u201d instruction to navigate through the received XML structure and allocate one new point object for each XML address provided. Next, for each address provided in the XML data, a display label and point location are determined based upon the internal data constraints of service provider  (as shown in Example 2). In statement , the \u201cavailableat..address\u201d returns a list of address elements, which in turn are iteratively assigned to the variable \u201ca\u201d. Next, the name of each store is determined using the parent( ) function built into the XML data type followed by the dot operator. In addition, the street address, city, state, and zip within which that store is located, is determined using the dot operator. As is illustrated by statements , strings returned by the direct access of descendent address elements are concatenated together to form the point label. Additionally, address information, including street, city, state, and zip information, is used in a LatitudeLongitude function (not shown) that computes a map location given an input address.","In , a \u201cToXML\u201d function is illustrated for use in converting ECMAScript based point locations into the XML elements shown in Example 1. To begin, the root node \u201c<available-at >\u201d is constructed by statement  using an XML literal. Next, statements  use ECMAScript's \u201cString.split( )\u201d function to parse the display label to determine a store name, street address, city, state and zip for each point. Finally, statements  create a store element for each point using XML literals with embedded ECMAScript expressions. Each store element is appended to the root node from statement  using the built-in appendChild( ) function.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIGS. 7A-C","FIGS. 5A and 5B"]},"In Example 1, an XML format was described that was used by a product manufacturing community for transmitting the locations of stores that carry their products. In Example 3 below, the XML format of Example 1 has been extended to indicate whether or not each store stocks the particular manufacturer's products.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"EXAMPLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<available-at>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<store>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<name>The Electronics Store<\/name>"]},{"entry":[{},"<stock-item>yes<\/stock-item>"]},{"entry":[{},"<address>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<street>23 Transistor Dr.<\/street>"]},{"entry":[{},"<city>Circuit<\/city>"]},{"entry":[{},"<state>WA<\/state>"]},{"entry":[{},"<zip>12345<\/zip>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/address>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/store>"]},{"entry":[{},"<store> . . . <\/store>"]},{"entry":[{},"<store> . . . <\/store>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/available-at>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIGS. 8A-8B","FIG. 8"]},"Reference is now drawn to , which illustrates the revised \u201cFromXML\u201d function. Statement  imports a new XML data type called \u201cAvailableAt\u201d described by the XML Schema file \u201cAvailableAt.xsd\u201d. Statement  declares that the first parameter passed to the \u201cFromXML\u201d function is of type \u201cAvailableAt\u201d. If it is not of type \u201cAvailableAt\u201d, interpreter\/compiler  generates an error. In addition, interpreter\/compiler  verifies that each operation performed on the first parameter to function \u201cFromXML\u201d is allowed by the constraints specified in AvailableAt.xsd. In Statement , the expression \u201cavailableat..store\u201d generates a list of elements containing all descendent elements of the variable \u201cavailableat\u201d named \u201cstore\u201d. The expression \u2018(stock-item==\u201cyes\u201d)\u2019 uses a filtering predicate to select from that list, only the elements containing a child element named \u201cstock-item\u201d with the value \u201cyes\u201d. Then the expression \u201caddress\u201d iterates over the resulting list of elements, selecting child elements named \u201caddress\u201d. The \u201cfor\u201d statement iterates over the resulting list of \u201caddress\u201d elements, assigning each one to the variable \u201ca\u201d, which is used to construct a point object. Interpreter\/compiler  verifies that each of these operations is allowable and consistent with the AvailableAt XML data type defined in the file \u201cAvailableAt.xsd\u201d.  illustrates the revised \u201cToXML\u201d function. Statement  declares the first parameter passed to the \u201cToXML\u201d function is of type \u201cAvailableAt\u201d. If it is not of type \u201cAvailableAt\u201d, interpreter\/compiler  generates an error. In addition, interpreter\/compiler  verifies that each operation performed on the first parameter to function \u201cToXML\u201d is allowed by the constraints specified in AvailableAt.xsd. Statement  uses the \u201cvalidate\u201d function to explicitly verify the value of \u201cavailableat\u201d conforms to the data type specified in \u201cAvailableAt.xsd\u201d at run-time and generates a list of errors if it does not. The \u201cvalidate\u201d function is useful when values are constructed dynamically using information not available to the compiler, such as user input or data read from external sources. In one embodiment, interpreter\/compiler  may insert implicit calls to validate( ) into the generated code.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 9","FIG. 9"]},{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"EXAMPLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<states>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<state>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<abbreviation>WA<\/abbreviation>"]},{"entry":[{},"<stores>10<\/stores>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<state>"]},{"entry":[{},"<state>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<abbreviation>CA<\/abbreviation>"]},{"entry":[{},"<stores>30<\/stores>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/state>"]},{"entry":[{},"<state> . . . <\/state>"]},{"entry":[{},"<state> . . . <\/state>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/states>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Referring now to , statement  uses the \u201clanguage\u201d token to define a function written in the XQuery language called \u201cgetstates\u201d that accepts a single parameter of XML data type \u201cAvailableAt\u201d. Statements  show the body of the function, which generates a list of states containing stores that carry the product in the format show above. Statement  invokes the function \u201cgetStates\u201d and stores the result in the XML variable \u201cstates\u201d. Statements  iterate over the resulting list of states, generating a point object for each one.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 6","b":["100","104","600","602","604","600","606","608","610","612","604","606","606","610","602","612"]},"Thus, it can be seen from the above descriptions, novel data representation language extensions to a programming language have been described. The novel scheme is particularly useful for mapping data objects between a programming language and a data representation language. While the present invention has been described referencing the illustrated and above enumerated embodiments, the present invention is not limited to these described embodiments. Numerous modification and alterations may be made, consistent with the scope of the present invention as set forth in the claims to follow. Thus, the above-described embodiments are merely illustrative, and not restrictive on the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The present invention will be described by way of exemplary embodiments, but not limitations, illustrated in the accompanying drawings in which like references denote similar elements, and in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2","b":"104"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A-3F"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 5A-5B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6","b":"104"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 7A-C"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 8A-B","FIGS. 5A-5B"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
