---
title: Version adaptation interface for integration of different virtual machines
abstract: A system and method for integrating different virtual machines (“VMs”). A first VM is loaded into an Application Server (“AS”) instance. The first VM includes standard features accessible through a standard native interface. A second VM is loaded into the AS instance including the standard features and extended features. The standard features provided by the second VM are accessed by native platform entities through a standardized native interface. The extended features provided by the second VM are accessed by the native platform entities through an adaptation interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07562349&OS=07562349&RS=07562349
owner: SAP AG
number: 07562349
owner_city: Waldorf
owner_country: DE
publication_date: 20050425
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to virtual machines, and in particular but not exclusively, relates to an adaptation interface for integrating different versions of JAVA virtual machines.","Alone, JAVA applications cannot access libraries and applications in other languages, since the JAVA language does not contain integrated external device support. The JAVA Native Interface (\u201cJNI\u201d) is a standardized native programming interface, which enables JAVA code that is interpreted within a JAVA virtual machine (\u201cJVM\u201d) to interoperate with applications and libraries written in native languages, such as C, C++, assembly, and the like. The JNI is developed, supported, and fully document by Sun Microsystems, Inc. and defined by the JNI Specification (e.g., JNI Specification, Version 1.1, May 1997).","As illustrated in , the JNI serves as the glue between JAVA applications\/methods and native applications\/methods, enabling an application to operate in both a native language realm and a JAVA language realm. The JNI provides an interface for native methods or applications to create, inspect, and update JAVA objects, call JAVA methods, catch and throw exceptions from a native method and have these exceptions handled in the JAVA application, load JAVA classes and obtain class information, and perform runtime type checking. Correspondingly, JAVA applications may use the JNI to call C routines, use C++ classes, call assembly routines, and the like. A JAVA programmer may need or want to use the JNI in scenarios where the standard JAVA class libraries do not support the platform-dependent features needed by an application, a library is already written in another language and the JAVA programmer wishes to make it accessible to JAVA code without rewriting the library, or the JAVA programmer may wish to implement a small portion of time-critical code in a lower-level language such as Assembly.","While the JNI is a standardized, uniform, well-thought-out interface, it is a fixed interface, which declares a fixed set of functions for interacting between native and JAVA applications. Accordingly, it does not support the ability to add functions to access proprietary, unique, or specialty enhancements of a proprietary JVM.","A system and method for integrating different virtual machines (\u201cVMs\u201d) is described. A first VM is loaded into an Application Server (\u201cAS\u201d) instance. The first VM includes standard features accessible through a standard native interface. A second VM is loaded into the AS instance including the standard features and extended features. The standard features provided by the second VM are accessed by native platform entities through a standardized native interface. The extended features provided by the second VM are accessed by the native platform entities through an adaptation interface.","In one embodiment, when a first native request is received from native platform entities directed to the first VM to execute one of the extended features not supported by the first VM at the adaptation interface, then the adaptation interface responds to the first native request with an indication that the one of the extended function is not available, if the adaptation interface determines that none of the standard features supported by the first VM is an acceptable alternative to the requested one of the extended features.","In one embodiment, the adaptation interface invokes one of the standard features within the first VM in response to receiving the first native request to execute one of the extended features, if the adaptation interface determines that one of the standard features is an acceptable alternative to the requested one of the extended features.","Embodiments of the invention may include all or some of the above described attributes. The above attributes can be implemented using a computer program, a method, a system or apparatus, or any combination of computer programs, methods, or systems. These and other details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2","b":["100","105","100","105","110","115","120"]},"In one embodiment, VM  is a JAVA VM (\u201cJVM\u201d), which interprets JAVA programs by converting them from an intermediate interpreted language (e.g., JAVA bytecode) into a native machine language, which is then executed by the underlying native platform. JAVA programs may be interpreted and executed by VM  to provide the business, presentation, and integration logic necessary to process work requests received at AS instance  and implement the functionality provided by an application server. Native wrapper process  provide the runtime environment for VM  to operate. In an embodiment where VM  is a JVM compliant with a JAVA  Platform, Standard Edition (\u201cJ2SE\u201d) standard, native wrapper process  is often referred to as \u201cJLaunch.\u201d Native wrapper process  is native machine code (e.g., compiled C++) executed and managed by an operating system (\u201cOS\u201d) of the underlying platform. Once native wrapper process  is launched, native wrapper process  establishes VM  within itself. Although two VMs  are illustrated within AS instance , it should be appreciated that AS instance  may include any number of native wrapper processes  each supporting a VM .","SNI  and adaptation interface  both provide a native interface for code interpreted within VM  to interoperate with native platform entities  written in native languages, such as C, C++, assembly, and the like, executed outside of VM . Native platform entities  may include native applications, native libraries, and native methods written and compiled to execute directly on the native platform executing AS instance . Native platform entities  may reside within native wrapper process  (as illustrated) and execute on the same native platform as AS instance . However, embodiments of the invention are not limited to adaptation interface  communicating only with native platform entities residing within native wrapper process , but rather may be extended to communicate\/access other native platform entities external to native wrapper process  or even external to AS instance , which may reside on a distinct native platform, such as another server or client node communicatively coupled to AS instance .","SNI  represents a standardized native interface for providing access to standardized features  of VMs . SNI  may represent various known standardized native interfaces such as the JAVA Native Interface (\u201cJNI\u201d) developed and supported by Sun Microsystems, Inc. or the Raw Native Interface (\u201cRNI\u201d) developed and supported by Microsoft, Inc. In contrast, adaptation interface  is an abstraction layer including a variety of interface functions for accessing extended features  of VM . Adaptation interface  imparts AS instances  with the ability to support different versions of VM  having different available features. For example, VM  may be a legacy VM only supporting standard features  and not capable of implementing extended features  or VM  may be an enhanced VM capable of supporting both standard features  and extended features . Extended features  may be proprietary features instrumented into VM  and therefore not supported or accessible via SNI . Adaptation interface  allows software designers to develop proprietary VMs with extended features  without waiting for a standardized native interface to mature to support access to extended features  or without having to submit the newly developed extended features  to a standards committee responsible for maintaining SNI .","In one embodiment, adaptation interface  provides additional functionality for mapping requests from native platform entities  to perform a task requiring operation of a feature not supported by a particular VM  to a lesser supported feature of the particular VM . In other words, in some embodiments, adaptation interface  is capable of accepting a request directed at legacy VM to perform one of enhanced features , and either respond with a \u201cfeature not supported\u201d indication or execute a \u201cbest effort\u201d response by mapping the native request to one of standard features .","Although  illustrates one enhanced VM operating within AS instance , it should be appreciated that any number of legacy and\/or enhanced VMs may operate within AS instance . Furthermore, each enhanced VM may include the same set of extended features , each include unique extended features , each include various different versions of extended features , and\/or each include any number of extended features  (from one to many). Furthermore, although VM  is illustrated as including one instance of SNI  and one instance of adaptation interface , it should be appreciated that various other combinations may be implemented. For example, multiple VMs  may either link to a single shared instance of adaptation layer , be linked to their own instances of adaptation layer , or even link to multiple instances of adaptation layer . In one embodiment, each native platform entity  links to its own instance of adaptation interface  for accessing VM . In one embodiment, each native thread links to its own instance of adaptation layer .","Extended features  may include modified standard features , proprietary features, newly developed features not yet supported by SNI , or any feature included within VM  otherwise not supported by SNI . In one embodiment, extended features  are JAVA methods coded to execute specialized tasks. In other embodiments, extended features  include any function or functionality instrumented into or executable by VM  for interoperation with native platform entities .","For example, extended features  included within an enhanced VM by the assignee of the instant patent application include internal VM heap monitoring methods, VM garbage collecting monitoring methods, internal VM stack dumping methods, and the like. These monitoring features enable multiple VMs  to individually collect monitoring data about their internal operation (e.g., heap statistics, garbage collecting statistics, client session information, and the like). The monitoring data may then be published to a shared monitoring memory location external to each of the multiple VMs . Adaptation interface  may include various monitoring interface functions to facilitate extraction of the monitoring data from within each VM  during operation of each VM  and publish the monitoring data into the shared monitoring memory maintained within a native platform data structure. Subsequently or in concert, the shared monitoring memory may be accessible by a remote monitoring agent to supervise operation of the multiple VMs . In one embodiment, the remote monitoring agent may be a native platform entity external to AS instance  which accesses extended features , including VM monitoring features described above, via adaptation interface .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["300","105","100"]},"In a process block , native wrapper process  loads dynamically link library (\u201cDLL\u201d)  from a non-volatile storage medium (e.g., database, file system, etc.) into system memory of the underlying native platform. DLL  is a library which contains the files necessary to setup and operate VM . DLL  my represent a single library, which contains the code for both legacy VM and enhanced VMs or a plurality of libraries each containing code associated with different VMs . Each VM  loads DLL , or a portion thereof, into its own address space.","Once DLL  is loaded into the system memory, native wrapper process  will proceed to load VM  into itself. In an embodiment where SNI  represents the JNI, native wrapper process  looks up an entry point of a Create_JavaVM( ) function within the JNI (process block ). The Create_JavaVM( ) function is part of the invocation application programming interface (\u201cAPI\u201d) of the JNI. The Create_JavaVM( ) function loads and initializes a JVM and returns a pointer or handle to the JNI interface pointer. In a UNIX based native platform, the entry point to the Create_JavaVM( ) function may be obtain by execution of the DLSym( ) function. In a Windows based native platform, the entry point to the Create_JavaVM( ) function may be obtained by execution of the Get_Proc_Address( ) function.","In a process block , native wrapper process  prepares arguments for loading and initializing standard features . In one embodiment, the arguments prepared by native wrapper process  are stored in a \u201cbootstrap.properties\u201d file. In a decision block , if native wrapper process  is about to load an enhanced VM (decision block ), as opposed to a legacy VM (the embodiment of  illustrates native wrapper process  loading an enhanced VM), then startup process  continues to a process block . In process block , native wrapper process  prepares additional arguments for initializing and enabling extended features  of the enhanced VM.","In a process block , native wrapper process  calls the Create_JavaVM( ) function and passes the arguments prepared in process blocks  and  therewith. In a process block , the Create_JavaVM( ) function loads the enhanced VM from DLL  into native wrapper process  and further initializes the enhanced VM with the prepared arguments. The arguments prepared in process block  are used to initialize standard features  while the arguments prepared in process block  are used to initialized extended features .","In one embodiment, once VM  is loaded into native wrapper process , an INIT function (not illustrated) within native wrapper process  is invoked to setup adaptation interface  and link adaptation layer  with VM . Although startup process  was illustrated using the JNI to setup a JVM, it should be appreciated that startup process  is only intended as an example. Other startup processes may be implemented in connection with embodiments of the invention to setup and initialize other types of VMs using other types of standardized native interfaces.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 4","FIG. 4"],"b":["120","105","120","410","140","105","125","410","135","115","120","415","140","420","415","125","120","115","425","135","430","425","125","120"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5","FIG. 4"],"b":["500","140","105","120","500"]},"In a process block , a native request (e.g., one of native requests  or ) is received by AS instance . In one embodiment, the native request may be a first request in a native session of interactions between a native platform entity and AS instance . In this case, the native request may be assigned to VM , among a plurality of VMs loaded within AS instance , to implement the native request. In one embodiment, the native request may not be a first request and therefore designate a particular one of VMs  with which a native session is already established.","In decision block , if the native request is a request that only requires execution of one of standard features  (e.g., one of native requests ), then process  continues to a process block . In process block , SNI  makes a function call into the designated one of VMs  to execute one or more of standard features . In a process block , the designated one of VMs  returns a response to SNI . Finally, in a process block , SNI  forwards the response (e.g., one of responses ) to the particular native platform entity  that generated the native request.","Returning to decision block , if the native request is a request to execute one of extended features  (e.g., one of native requests ), then process  continues to a decision block . In decision block , adaptation interface  determines whether VM  designated by the native request supports the extended feature  requested by the native request. If the designated VM  does indeed support the requested extended feature , then adaptation interface  makes a function call into the designated VM  to invoke the requested extended feature  (process block ). Once the invoked extended feature  has completed operation, it may callback to adaptation interface  with a response, which is then forwarded by adaptation interface  as a response  to the requesting one of native platform entities  or . As illustrated in the embodiment of , adaptation interface  may include an interface function  corresponding to each extended feature .","When interoperation with a particular extended feature  within VM  is desired by a native platform entity, then the native platform entity can access the particular extended feature  via its corresponding interface function  within adaptation interface . Accordingly, adaptation interface  enables developers to add new functionality and features to proprietary and\/or evolving VMs as desired, and provide native access to these newly added features by addition of a new interface function  within adaptation interface . Furthermore, adaptation interface  enables AS instance  to load different versions of VMs at different times. Adaptation interface  may even be modified to support different versions of VMs having different extended features  simultaneously within AS instance . For example, as illustrated in , VM  supports extended features (A, B, C, and D) and standard features ; however, other VMs may be loaded which support other extended features and standard features.","Returning to decision block , if the particular extended feature  requested is not supported by the particular VM  designated by the native request and an alternative standard feature  or alternative extended feature  is also not supported (decision block ), then process  continues to a process block . In process block , adaptation interface  responds to the native request with an indication that the feature is not supported or the native request failed.","Returning to decision block , if the extended feature  is not supported, but adaptation interface  determines that an acceptable alternative feature is supported by the one of VMs  designated by the native request, then process  continues to a process block . In process block , adaptation interface  maps the native request to an alternative feature that is supported by the designated VM . The alternative feature is invoked by adaptation interface  calling into the designated VM  and a \u201cbest effort\u201d response returned (process block ). As described above, adaptation interface  forwards the best effort response to the requesting one of native platform entities  (process block ). Accordingly, in one embodiment, adaptation interface  includes logic to receive a native request, determine whether the native request is supported by the designated VM , and if not, determine whether an alternative feature capable of at least partially responding to the native request is supported by the designated VM , and finally diverting the native request to be serviced by the alternative feature.","In one embodiment, a best effort response may include mapping a native request to perform an unsupported extended feature  to a supported standard feature . For example,  illustrates that VM  does not support extended feature (E); however, interface function (E) of adaptation interface  may determine that one of standard features  is an adequate, though perhaps lesser, feature capable of generating at least a partial response to the native request. In one embodiment, a best effort response may include mapping a native request to perform an unsupported extended feature  to another supported extended feature . In one embodiment, a best effort response may include mapping a native request to perform an unsupported extended feature  to multiple standard features  or to a combination of supported standard and extended features  and .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","b":["600","600","605","607","610","605","615","100","620","622","625","627","630"]},"AS instances  may be web application servers, such as Web AS by SAP, .NET by Microsoft, or the like. Each AS instance  may include one or more VMs  to execute JAVA programs and service work requests . It should be appreciated that various components of AS instances  have been excluded from  for the sake of clarity and so as not to obscure the invention. In one embodiment, VMs  may be compliant with the J2SE standard. In one embodiment, VMs  may be compliant with the .NET framework from Microsoft. Each AS instance  may even include VMs  compliant with both the J2SE standard and the .NET framework.","Web dispatcher  implements a load-balancing mechanism distributing work requests  from client nodes  among server nodes  within cluster . For example, web dispatcher  may implement a round-robin load-balancing mechanism or the like. Web dispatcher  may be one of server nodes  having the task of dispatching work requests  among server nodes  of cluster  or a stand alone hardware node. Work requests  are processed by server nodes  and may subsequently be provided to database node . Database node  offers up the requested data to server nodes , which in turn process and format the results for display on client nodes . Each AS instance  may further include its own dispatcher mechanism to distribute work requests  assigned to it among its individual VMs .","JAVA programs executed by VMs  within AS instances  may collectively provide the logic for implementing various sub-layers (e.g., business layer, integration layer, presentation layer, etc.) of AS instances . For example, the JAVA programs may be servlets providing server-side logic to generate graphical user interfaces (\u201cGUIs\u201d) on clients nodes  and may further include JavaServer Page (\u201cJSP\u201d) extensions for providing dynamic content within the GUI. The JAVA programs may further include business applications providing the business logic of an Enterprise JavaBean (\u201cEJB\u201d), and on client nodes  may be applets providing client side logic, and the like.","As discussed above, one or more native entities  may reside within each AS instance  within a file system or the like on each server node . Some Native entities may reside external to each AS instance  on each server node , database node , or even on client nodes , web dispatcher , or message server . Before loading DLL  into system memory of each server node , DLL  may be distributed having a copy saved on each server node  or centrally loaded on database node .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7","b":["700","100","120","300","500","610","615","620","625","700","705","710","715","720","725","730","700"]},"The elements of processing system  are interconnected as follows. Processor(s)  is communicatively coupled to system memory , NV memory , DSU , and communication link , via chipset  to send and to receive instructions or data thereto\/therefrom. In one embodiment, NV memory  is a flash memory device. In other embodiments, NV memory  includes any one of read only memory (\u201cROM\u201d), programmable ROM, erasable programmable ROM, electrically erasable programmable ROM, or the like. In one embodiment, system memory  includes random access memory (\u201cRAM\u201d), such as dynamic RAM (\u201cDRAM\u201d), synchronous DRAM, (\u201cSDRAM\u201d), double data rate SDRAM (\u201cDDR SDRAM\u201d) static RAM (\u201cSRAM\u201d), and the like. DSU  represents any storage device for software data, applications, and\/or operating systems, but will most typically be a nonvolatile storage device. DSU  may optionally include one or more of an integrated drive electronic (\u201cIDE\u201d) hard disk, an enhanced IDE (\u201cEIDE\u201d) hard disk, a redundant array of independent disks (\u201cRAID\u201d), a small computer system interface (\u201cSCSI\u201d) hard disk, and the like. Although DSU  is illustrated as internal to processing system , DSU  may be externally coupled to processing system . Communication link  may couple processing system  to a network such that processing system  may communicate over the network with one or more other computers. Communication link  may include a modem, an Ethernet card, a Gigabit Ethernet card, Universal Serial Bus (\u201cUSB\u201d) port, a wireless network interface card, a fiber optic interface, or the like.","It should be appreciated that various other elements of processing system  have been excluded from  and this discussion for the purposes of clarity. For example, processing system  may further include a graphics card, additional DSUs, other persistent data storage devices (e.g., tape drive), and the like. Chipset  may also include a system bus and various other data buses for interconnecting subcomponents, such as a memory controller hub and an input\/output (\u201cI\/O\u201d) controller hub, as well as, include data buses (e.g., peripheral component interconnect bus) for connecting peripheral devices to chipset . Correspondingly, processing system  may operate without one or more of the elements illustrated. For example, processing system  need not include DSU .","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Processes  and  explained above are described in terms of computer software and hardware. The techniques described may constitute machine-executable instructions embodied within a machine (e.g., computer) readable medium, that when executed by a machine will cause the machine to perform the operations described. Additionally, processes  and  may be embodied within hardware, such as an application specific integrated circuit (\u201cASIC\u201d) or the like. The order in which some or all of the process blocks appear in processes  and  should not be deemed limiting. Rather, one of ordinary skill in the art having the benefit of the present disclosure will understand that some of the process blocks may be executed in a variety of orders not illustrated.","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. In some examples above, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring certain aspects. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification and the claims. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
