---
title: Register window flattening logic for dependency checking among instructions
abstract: A technique for flattening architectural register windows into flattened space depending on a current window pointer to a register window is provided. The technique involves converting an n-bit value of a particular register in a register window to an x-bit value dependent on the current window pointer, where x is greater than n, and where the x-bit value is used for register dependency checking among a plurality of instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07080237&OS=07080237&RS=07080237
owner: Sun Microsystems, Inc.
number: 07080237
owner_city: Santa Clara
owner_country: US
publication_date: 20020524
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["A typical computer system includes at least a microprocessor and some form of memory. The microprocessor has, among other components, arithmetic, logic, and control circuitry that interpret and execute instructions necessary for the operation and use of the computer system.  shows a typical computer system  having a microprocessor , memory , integrated circuits  that have various functionalities, and communication paths , i.e., buses and signals, that are necessary for the transfer of data among the aforementioned components of the computer system .","A microprocessor, such as the one shown in , typically includes an integer unit and a floating point-unit, each with its own registers. This organization allows for implementations with concurrency between integer and floating-point instruction execution. Typically, the integer unit contains general-purpose registers and controls the overall operation of the microprocessor. The integer unit executes the integer arithmetic instructions and computes memory addresses for loads and stores. The integer unit also maintains the program counter and controls instruction execution for the floating-point unit.","In an exemplary implementation of an integer unit, the integer unit may contain 64 to 528 general-purpose 64-bit r registers (an r register is an integer register and is also known in the art as a \u201cgeneral-purpose register\u201d or \u201cworking register\u201d). They are partitioned into 8 global registers, 8 alternate global registers, plus an implementation-dependent number of 16-register sets. As shown in Table 1, a \u201cregister window\u201d consists of the current 8 in registers, 8 local registers, and 8 out registers.",{"@attributes":{"id":"p-0005","num":"0004"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Window Addressing"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Windowed Register","r Register"]},{"entry":[{},"Address","Address"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"in[0]\u2013in[7]","r[24]\u2013r[31]"]},{"entry":[{},"local[0]\u2013local[7]","r[16]\u2013r[23]"]},{"entry":[{},"out[0]\u2013out[7]","\u2002r[8]\u2013r[15]"]},{"entry":[{},"global[0]\u2013global[7]","r[0]\u2013r[7]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["0","7","0","7","0"]},"At any time, an instruction may access the 8 global registers and a 24-register window into the r registers. A register window comprises the 8 in and 8 local registers of a particular register set together with the 8 in registers of an adjacent register set, which are addressable from the current window as out registers.","As an example of register windowing,  shows a 5 register window architecture . As those skilled in the art will understand, although  shows a 5 register window scheme, the number of windows or register sets is implementation-dependent. The total number of r registers in a given implementation is 8 (for the global registers), plus 8 (for the alternate global registers), plus the number of sets multiplied by 16 registers\/set.","A current window into the r registers is given by the current window pointer (CWP) register. The CWP is decremented by a RESTORE\/RETURN instruction and is incremented by a SAVE\/STORE instruction. Window overflow is detected via a CANSAVE register and window underflow is detected via a CANRESTORE register. More specifically, the CANSAVE register contains the number of register windows following CWP that are not in use and are available to be allocated by a SAVE instruction. The CANRESTORE register contains the number of register windows preceding CWP that are in use by the current program and can be restored via the RESTORE instruction.","Additionally, state registers OTHERWIN and CLEANWIN may be used in some register window schemes. The OTHERWIN register contains the count of register windows that will be spilled\/filled using a particular set of trap vectors. When all of the register windows fill and another register window is saved, a register window overflow, or \u201cspill\u201d occurs, in which case some number of registers are saved to the program stack. Alternatively, when restoring a register window that is not already in a register window, a register window underflow, or \u201cfill\u201d occurs, in which case some number of register windows are restored from the program stack. In some implementations, the OTHERWIN register may be used to split the register windows among different address spaces and handle spill\/fill traps using separate spill\/fill vectors. The CLEANWIN register counts the number of registers that are \u201cclean\u201d with respect to the current program. That is, register windows that contain only zeroes, valid addresses, or valid data from that program are counted. Registers in these windows need not be cleaned before they are used. The count includes the register windows that can be restored (the value in the CANRESTORE register) and the register windows following CWP that can be used without cleaning.","As discussed above, each window shares its ins with one adjacent window and its outs with another. The outs of the CWP\u22121 window are addressable as the ins of the current window, and the outs in the current window are the ins of the CWP+1 window. The locals are unique to each window. When one function, or subroutine, calls another, the callee may choose to execute a SAVE instruction. This instruction increments CWP, shifting the register window upward. The caller's out registers then become the callee's in registers, and the callee gets a new set of local and out registers for its own use. Only the CWP changes because the registers and return address do not need to be stored on a stack. The CALL instruction automatically saves its own address in, for example, out register , which becomes in register  if CWP is incremented. Therefore, the callee may access the return address whether or not it has decremented CWP.","An r register with address o, where 8\u2266o\u226615, refers to exactly the same register as address (o+16) does after the CWP is incremented by 1. Likewise, a register with address I, where 24\u2266o\u226631, refers to exactly the same register as address (o\u221216) does after the CWP is decremented by 1. For a high level view of register dependency in a register window implementation, refer to , which shows a circular stack  of windowed r registers for an implementation using an 8 register window scheme.","According to one aspect of the present invention, a method for processing a plurality of instructions in a computer system comprises: flattening an n-bit value of a first register in a register window into an x-bit value, where x is greater than n, and where the x-bit value corresponds to the first register; flattening a p-bit value of a second register in the register window into a q-bit value, where q is greater than p, and where the q-bit value corresponds to the second register; and checking a register dependency among the plurality of instructions using the x-bit value and the q-bit value.","According to another aspect, a method for processing a plurality of instructions in a computer system comprises: a step for flattening an n-bit value of a first register in a register window into an x-bit value, where x is greater than n, and where the x-bit value corresponds to the first register; a step for flattening a p-bit value of a second register in the register window into a q-bit value, where q is greater than p, and where the q-bit value corresponds to the second register; and a step for register dependency checking among the plurality of instructions using the x-bit value and the q-bit value.","According to another aspect, a computer system comprises: a processor; a memory; and instructions, residing in the processor and executable on the processor, for flattening an n-bit value of a register in a register window into an x-bit value, where x is greater than n, and where the x-bit value corresponds to the register.","According to another aspect, a computer-readable medium having recorded therein instructions executable by processing, where the instructions are for: flattening an n-bit value of a first register in a register window into an x-bit value, where x is greater than n, and where the x-bit value corresponds to the first register; flattening a p-bit value of a second register in the register window into a q-bit value, where q is greater than p, and where the q-bit value corresponds to the second register; and register dependency checking among the plurality of instructions using the x-bit value and the q-bit value.","According to another aspect, an integrated circuit comprises: a register having an n-bit value, where the register is part of a register window; and circuitry that converts the n-bit value to an x-bit value dependent on the n-bit value and a current window pointer to the register window, where x is greater than n.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","In some microprocessor implementations, register dependency checking among instructions becomes difficult because of register windowing. In other words, in implementations using register windows, checking for dependencies among instructions is adversely affected by the interrelationship of particular registers in the register window scheme. To facilitate improved register dependency checking, embodiments of the present invention relate to architectural registers within an instruction that are flattened into flattened space before register dependency checking occurs.","Particularly, the present invention uses a working copy of the CWP to facilitate the flattening, where the flattening is conducted using flattener logic implemented with logic gates. The CWP is implementation specific and when incremented, allows a subroutine to make use of a new set of registers. CWP gets incremented\/decremented by SAVE\/RESTORE\/RETURN instructions. When a subroutine wants to make use a new set of registers, the subroutine inserts a SAVE instruction within its code.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 4","FIG. 4"],"b":"40"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIGS. 5","FIGS. 5"],"i":["a ","b ","a ","b "],"b":["5","5"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIGS. 6","FIGS. 6","FIG. 6","FIG. 6","FIG. 6","FIG. 6"],"i":["a, ","b, ","c ","a, ","b, ","c ","a, ","c ","b, ","c "],"b":["6","6","6","6","41","42","43","44","45","46","47","48","49","50"]},"In a multiplexor  outputs based on a value of a global field in a processor state register. For example, if the interrupt global registers are being used in a particular register windowing scheme, select IG to multiplexor  is enabled. Selects GG (for global registers), AG (for alternate global registers), and MG (for memory global registers) to multiplexor  are similarly used. Select inputs to multiplexors , , , , and  are received from the circuit shown in Similarly, select inputs to multiplexors , , and  are also received from the circuit shown in Multiplexors , , , , , , , and  output to an output multiplexor  that receives select inputs from the circuit shown in The output multiplexor  outputs a 7-bit flattened value that is used to address I. Accordingly, because a 5-bit architectural register, such as I, has its own 7-bit flattened space, register dependency checking among instructions is made more efficient.","Those skilled in the art will note that by using the flattener logic shown in and an 5-bit value of a register is flattened, i.e., converted, into an 7-bit value. In other embodiments, using similar logic, an n-bit value of a register may be flattened into an x-bit value, where x is greater than n. Thus, the register flattening principles presented in the present invention may be applied to various register architectures.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIGS. 7","FIGS. 6","FIGS. 7"],"i":["a, ","b, ","c ","a, ","b, ","c ","a, ","b, ","c, "],"b":["7","7","6","6","7","7"]},"Further, those skilled in the art will appreciate that the flattened space formed by the flattener logic is used by a register dependency checker to check for dependencies among instructions. Thus, the dependency checking becomes simpler and more efficient without being adversely affected by register dependencies present in register windowing implementation.","In one or more embodiments of the present invention, a computer program (i.e., a computer readable medium) or software tool may be used to flatten register space using logic similar to that described above with reference to and For example, instead of the flattening logic existing in hardware, the same logic may be implemented in software, where a computer program or other software tool interfaces with one or more registers of a register window.","Advantages of the present invention may include one or more of the following. In some embodiments, the ability to flatten register values of registers in a register window facilitates the simplification of instruction verification.","In some embodiments, because flattening logic is used to flatten address space associated with a register, dependency checking on one or more instructions using that register is simplified.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 5","i":["a ","b "],"b":"5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 6","i":["a, ","b, ","c "],"b":["6","6"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 7","FIGS. 6"],"i":["a","b","c ","a","b","c. "],"b":["7","7","6","6"]}]},"DETDESC":[{},{}]}
