---
title: Facilitating event notification through use of an inverse mapping structure for subset determination
abstract: One embodiment of the present invention provides a system that performs event notification in a distributed computing system. During operation, the system receives an event that was generated at a node in the distributed computing system, wherein the event includes a set of name/value pairs associated with the event. Next, the system compares the event against a set of client event registrations to determine a set of clients to be notified of the event, wherein each client event registration identifies a client and a target set of name/value pairs, wherein the client is to be notified of the event if the target set of name/value pairs matches a subset of the set of name/value pairs associated with the event. Finally, the system sends a notification of the event to the set of clients to be notified of the event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07111305&OS=07111305&RS=07111305
owner: SUN Microsystems, Inc.
number: 07111305
owner_city: Santa Clara
owner_country: US
publication_date: 20021126
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of a pending U.S. non-provisional patent application by inventors Ashutosh Tripathi, Andrew L. Hisgen and Nicholas A. Solter, entitled, \u201cMethod and Apparatus for Providing a Highly Available Distributed Event Notification Mechanism,\u201d having Ser. No. 10\/285,176, and filing date Oct. 31, 2002. This application hereby claims priority under 35 U.S.C. 517 120 to the above-listed patent application.","1. Field of the Invention","The present invention relates to the design of distributed computing systems. More specifically, the present invention relates to a method and an apparatus that uses an inverse mapping structure for subset determination to facilitate event notification in a distributed computing system.","2. Related Art","Distributed computing systems presently make it possible to develop distributed applications that can harness the computational power of multiple computing nodes in performing a computational task. This can greatly increase the speed with which the computational task can be performed. However, it is often hard to coordinate computational activities between application components running on different computing nodes within the distributed computing system.","In order to operate properly, distributed applications must somehow keep track of the state of application components in order to coordinate interactions between the application components. This can involve periodically exchanging \u201cheartbeat\u201d messages or other information between application components to keep track of which application components are functioning properly.","Some distributed operating systems presently keep track of this type of information for purposes of coordinating interactions between operating system components running on different computing nodes. However, these distributed operating systems only use this information in performing specific operating system functions. They do not make the information available to distributed applications or other clients.","Hence, in many situations, a distributed application has to keep track of this information on its own. Note that the additional work involved in keeping track of this information is largely wasted because the distributed operating system already keeps track of the information. Moreover, the task of keeping track of this information generates additional network traffic, which can impede communications between nodes in the distributed computing system.","Hence, what is needed is a method and an apparatus that enables a distributed application to be notified of events that occur on different computing nodes within a distributed computing system without requiring the distributed application to perform the event monitoring operations.","One problem in performing event notification is to rapidly determine which clients are to be notified of an incoming event. The naive approach is to compare the incoming event against each of the client registrations, wherein a given client registration identifies specific events that an associated client has registered to be notified of. Note that this may require an incoming event to be compared against every client registration in the system, which can potentially be very slow.","Hence what is needed is a method and an apparatus for rapidly determine which clients are to be notified of a specific incoming event.","One embodiment of the present invention provides a system that performs event notification in a distributed computing system. During operation, the system receives an event that was generated at a node in the distributed computing system, wherein the event includes a set of name\/value pairs associated with the event. Next, the system compares the event against a set of client event registrations to determine a set of clients to be notified of the event, wherein each client event registration identifies a client and a target set of name\/value pairs, wherein the client is to be notified of the event if the target set of name\/value pairs matches a subset of the set of name\/value pairs associated with the event. Finally, the system sends a notification of the event to the set of clients to be notified of the event.","In a variation on this embodiment, comparing the event against the set of client event registrations involves performing a subset determination operation to identify which client event registrations match a subset of the set of name\/value pairs associated with the event.","In a further variation, for each name\/value pair associated with the incoming event, performing the subset determination operation involves looking up an entry in a hash table for the name\/value pair. This entry identifies which client event registrations contain matching name\/value pairs. The system also increments a counter for each client event registration that contains a matching name\/value pair. If the counter for a given client event registration equals the number of name\/value pairs in the client event registration, the system adds the associated client to the set of clients to be notified of the event. Note that the counters are reset after each incoming event is processed.","In a variation on this embodiment, prior to receiving the event, the system initializes the hash table. This is accomplished by looking up a hash table entry for each name\/value pair in each client event registration, which may involve creating hash table entries for the name\/value pairs, if necessary. It also involves updating the hash table entry to point to a counter for the associated client event registration. In this way, a subsequent hash table lookup for an event can increment counters for client event registrations that contain matching name\/value pairs.","In a variation on this embodiment, comparing the event against the set of client event registrations additionally involves comparing a class and a subclass associated with the event against a class and a subclass associated with each client event registration.","In a variation on this embodiment, clients can include applications or application components running within the distributed computing system. They can also include applications or application components running outside of the distributed computing system.","In a variation on this embodiment, the events can include cluster membership events, such as a node joining the cluster or a node leaving the cluster. The events can also include events related to applications, such as a state change for an application (or an application component), or a state change for a group of related applications. Note that a state change for an application (or application component) can include: the application entering an on-line state; the application entering an off-line state; the application entering a degraded state, wherein the application is not functioning efficiently; and the application entering a faulted state, wherein the application is not functioning. The events can also include state changes related to monitoring applications or other system components, such as \u201cmonitoring started\u201d and \u201cmonitoring stopped.\u201d","The following description is presented to enable any person skilled in the art to make and use the invention, and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus, the present invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","The data structures and code described in this detailed description are typically stored on a computer readable storage medium, which may be any device or medium that can store code and\/or data for use by a computer system. This includes, but is not limited to, magnetic and optical storage devices such as disk drives, magnetic tape, CDs (compact discs) and DVDs (digital versatile discs or digital video discs), and computer instruction signals embodied in a transmission medium (with or without a carrier wave upon which the signals are modulated). For example, the transmission medium may include a communications network, such as the Internet.","Distributed Computing System",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","121","123","101","120","120","120","121","122"]},"Highly available server  can generally include any collection of computational nodes including a mechanism for servicing requests from a client for computational and\/or data storage resources. Moreover, highly available server  is configured so that it can continue to operate even if a node within highly available server  fails. This can be accomplished using a failover model, wherein if an instance of an application fails, a new instance is automatically started, possibly on a different node within the distributed computing system.","In the embodiment illustrated in , highly available server  includes a number of computing nodes \u2013 coupled together through a cluster network . Computing nodes \u2013 can generally include any type of computer system, including, but not limited to, a computer system based on a microprocessor, a mainframe computer, a digital signal processor, a portable computing device, a personal organizer, a device controller, and a computational engine within an appliance. Cluster network  can generally include any type of wire or wireless communication channel capable of coupling together computing nodes. This includes, but is not limited to, a local area network, a wide area network, or a combination of networks.","Computing nodes \u2013 host a number of application components \u2013, which communicate with each other to service requests from clients \u2013. Note that application components can include any type of application (or portion of an application) that can execute on computing nodes \u2013. During operation, resources within computing nodes \u2013 provide a distributed event notification mechanism that can be used by application components \u2013 to coordinate interactions between application components \u2013. This distributed event notification mechanism is described in more detail below with reference to .","Note that although the present invention is described in the context of a highly available server , including multiple computing nodes \u2013, the present invention is not meant to be limited to such a system. In general, the present invention can be applied to any type of computing system with multiple computing nodes and is not meant to be limited to the specific highly available server  illustrated in .","Computing Node",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["106","106","206","204","206","106","109"]},"In one embodiment of the present invention, cluster OS  supports failover operations to provide high availability for applications running on computing nodes \u2013. In this embodiment, cluster OS  ensures that state information for an application is propagated to persistent storage. In this way, if the application fails, a new instance of the application can be automatically started by retrieving the state information from persistent storage. Note that the new instance of the application can be started on either the same computing node or a different computing node. Moreover, the failover operation generally takes place without significantly interrupting ongoing operations associated with the application.","Cluster OS provides an event application programming interface (API) that can be used by application components \u2013 to receive event notifications. More specifically, event API  enables application components: to register to be notified of events; to post events; and to and to receive notifications for events as is described below with reference to .","Event Forwarding Components",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["106","109","101","302","305","302","305","106","109"]},"Computing node  also contains a highly available event forwarder (HA-EF) , which is responsible for forwarding specific events to clients that desire to be notified of the specific events. HA-EF  does this by receiving an event from IEF  on computing node  and then looking up the event in a cluster database  to determine which clients desire to be notified of the event. HA-EF  then forwards the event to any clients, such as client , that desire to be notified of the event.","Note that client  can be located within computing nodes \u2013. For example, an application component  on computing node  can be notified of a change in state of an application component  on computing node . Client  can alternatively be located at a remote client. For example, an application on client  can be notified of state changes to a group of related application components ,  and  running on computing nodes, ,  and , respectively.","Note that HA-EF  is \u201chighly available.\u201d This means that if HA-EF  fails, a new instance of HA-EF  is automatically restarted, possibly on a different computing node. Note that HA-EF  can be restarted using client registration information stored within cluster database . In one embodiment of the present invention, when a new instance of HA-EF  is restarted, the new instance asks for a snapshot of the event information from all of the other nodes.","Also note that cluster database  is a fault-tolerant distributed database that is stored in non-volatile storage associated with computing nodes \u2013. In this way, the event registration information will not be lost if one of the computing nodes \u2013 fails.","Registration Process",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 3"],"b":["308","306","402","306","306","308","308"]},"Events in the list can include any type of events that can be detected within computing nodes \u2013. For example, the events can include cluster membership events, such as a node joining the cluster or a node leaving the cluster. The events can also involve applications. For example, the events can include: a state change for an application (or an application component) running within the distributed computing system, or a state change for a group of related applications running within the distributed computing system.","Note that a state change for an application (or application component) can include: the application entering an on-line state; the application entering an off-line state; the application entering a degraded state, wherein the application is not functioning efficiently; and the application entering a faulted state, wherein the application is not functioning. The events can also include state changes related to monitoring applications or other system components, such as \u201cmonitoring started\u201d and \u201cmonitoring stopped.\u201d Also note that the present invention is not limited to the types of events listed above. In general, any other type of event associated with a computing node, such as timer expiring or an interrupt occurring, can give rise to a notification.","Upon receiving the registration request, HA-EF  records the callback address of client  and the list of events in cluster database  (step ). HA-EF  then responds \u201csuccess\u201d to client  and the registration process is complete (step ). After registering for an event, client  can simply disconnect and does not need to maintain any connections to the cluster. When an event of interest subsequently arrives, HA-EF  initiates a connection to client  to deliver the event. Thus, client  does not need to do any maintenance, except for maintaining an open listening socket.","Event Forwarding Process",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5","b":["106","109","106","502"]},"Next, a local IEF  on computing node  receives the event and forwards the event to the other IEFs \u2013 located on the other computing nodes \u2013 (step ). In one embodiment of the present invention, the event is added to the sysevent queue in the delivered nodes, which allows the event to be treated as if it was generated locally (except that it is not again forwarded to other nodes).","Next, HA-EF  receives the event and looks up an associated list of clients in cluster database . This lookup can involve any type of lookup structure that can efficiently lookup a set of interested clients for a specific event. HA-EF  then forwards the event to all of the clients in the list (step ). This completes the event notification process.","Note that the event notification process facilitates the development of distributed applications because it allows application components running on different computing nodes to be informed of state changes in related application components without having to exchange heartbeat messages or other status information between the application components.","Also note that in many applications, it is important to guarantee a total ordering of events. Hence if events are missed, it is advantageous for subsequent events to indicate the total state of the system, so that clients are not left with an incorrect view of the event ordering.","Data Structure for the Event Lookup Process","In one embodiment of the present invention, the event lookup process described in step  above involves an inverse mapping operation that attempts to match an incoming event with a set of client event registrations. More specifically, each incoming event specifies a class and a sub-class for the event and a set of name\/value pairs associated with the event. The lookup process matches the incoming event with client event registrations that contain the same class and subclass and a subset of the name\/value pairs associated with the event.","For example, a given incoming event may be associated with class=\u201ccluster,\u201d subclass=\u201cresource group state\u201d and a number of name\/value pairs: {resource group name=\u201cfoo\u201d}; {node=\u201cnode\u201d}; and {state=\u201conline\u201d}. This incoming event will match any client event registration with the same class and subclass and that contains a matching subset of the name\/value pairs in the incoming event. (Note that it is possible for a client event registration to specify no name\/value pairs, in which case any event with the same class and sub-class will match the client event registration.)",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6","b":"602"},"For example, hash table  includes entry , which is associated with class, subclass and name\/value pair  (nv). Hash table  also includes entry , which is associated with class , subclass  and name\/value pair  (nv). Hash table  additionally includes entry , which is associated with class , subclass  and name\/value pair  (nv).","Each hash table entry (,  and ) points to linked list of pointers which point to corresponding event data structures. For example, entry  in hash table  is associated with a linked list containing pointers ,  and , which point to event data structures , event data structure  and event data structure , respectively. Entry  in hash table  similarly points to a linked list containing pointers  and , which point to event data structure  and event data structure , respectively. Finally, entry  in hash table  points to a linked list containing a single pointer , which points to event data structure .","Event data structures \u2013 represent specific client event registrations. For example, in , a client associated with client data structure  is registered to be notified of event and event, which are associated with event data structure  and event data structure , respectively. Event data structure  and event data structure  contain back pointers  and , which point to client data structure , and client data structure  points to a list containing event data structure  and event data structure .","Similarly, a client associated with client data structure  is registered to be notified of event, wherein event is associated with event data structure . To keep track of these associations, event data structure  contains a back pointer , which points to client data structure , and client data structure  points to a list containing event data structure . Note that client data structures  and  are part of a list of clients .","Each event is associated with a number of properties. In particular, event is associated with class, subclass and name\/value pair  (nv). To keep track of this association, entry  in hash table  is associated with a pointer , which references counter  within event data structure . This allows a subsequent lookup into entry  to increment counter . Event data structure  also contains a total , which specifies the number of name\/value pairs associated with the event. In this case, total  is set to \u201cone\u201d because event data structure  is only associated with a single name\/value pair.","Whenever counter  is incremented, the resulting value is compared against total . If the resulting value matches total , the associated client is placed in notification list , so that the associated client will subsequently be notified of the event.","Event  is similarly associated with class, subclass and nv. However, event is also associated with name\/value pair  (nv). Hence, counter  within event data structure  is referenced by pointer  through entry  in hash table , and is also referenced by pointer  through entry  in hash table . Note that total  within event data structure  is set to the value \u201ctwo\u201d because event data structure  is associated with two name\/value pairs, nv and nv.","Finally event is associated with class, subclass, nv, nv and name\/value pair  (nv). Hence, counter  within event data structure  is referenced by: pointer  through entry  in hash table ; pointer  through entry ; and pointer  through entry . Note that total  within event data structure  is set to the value \u201cthree\u201d because event data structure  is associated with three name\/value pairs, nv, nv and nv.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6","b":"640"},"Process of Initializing Event Lookup Data Structures",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 7","FIG. 6","FIG. 6"],"b":["702","621","704","1","616","706"]},"Next, for each name\/value pair specified in the client event registration, the system creates a hash key. For example, in , the hash key for entry  in hash table  is created from class, subclass and name\/value pair. The system uses this hash key to perform a lookup in hash table . Note that this lookup may involve creating a hash table entry for the hash key if an entry does not exist. Next, the system adds a pointer from the hash table entry to the event data structure so that subsequent lookups using the same hash key can increment a counter in the event data structure (step ).","Note that the client event registrations may be received over time as they are generated at the client computer systems during systems operation. In this case, each additional client event registrations is used to incrementally update the lookup structure.","Note that subsequent lookup operations involving the above-described data structures do not require any time-consuming string comparison operations; only fast hash table lookups and pointer lookups are required.","Operations Involved in the Event Lookup Process",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 8","b":["802","804","806","808"]},"Next, the system follows an event pointer in the hash table entry to locate an event data structure (step ), and then increments a counter in the event data structure (step ). The system also places a reference to the counter in visited list , so that the counter can be reset after the event is processed. If a value in the counter equals the total number of name\/value pairs associated with the event data structure, the system adds the associated client to notification list  so that the client will be notified of the event (step ). Steps ,  and  are repeated for each event pointer in the hash table entry.","Next, if there are more name\/value pair associated with the event, the system returns to step  to process the next name\/value pair for the event. Otherwise, the system resets all of the counters in visited list  (step ). The system also sends event notifications to all clients in visited list  and resets visited list . At this point, the system is ready to process the next event.","Example Lookup","For the exemplary set of client event registrations illustrated in , suppose an incoming event has the following properties, class, subclass, name=value and name=value. Since there are two name\/value pairs (name=value and name=value) for this event, there are two possible hash keys (class:subclass:name=value) and (class:subclass:name=value). (In , note that \u201cNV\u201d represents name=value, \u201cNV\u201d represents name=value, and \u201cNV\u201d represents name=value.)","The system first performs a lookup based on the first hash key which returns entry  from hash table . Entry  points to events \u2013. Next, the system increments counters for events \u2013 so that they contain the number one. Event, which is associated with event data structure , only requires one match, so the associated client is placed on notification list . Event and event, which are associated with event data structures  and event data structure , respectively, require more than one match, so clients for event and event are not placed on notification list  yet.","Next, the system performs a second lookup based on the second hash key. This second lookup returns entry  from hash table , which points to event data structures  and event data structure . The system then increments counters  and  for event data structure  and event data structure  so that they contain the number two. Event only requires two matches, so the associated client is placed on notification list . However, event requires three matches, so the associated client for event is not put into notification list .","At this point, the lookup is complete, and the system sends notifications to the clients in notification list  and then clears notification list . The system refers to visited list  to clear all of the counters that have been incremented.","The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly, many modifications and variations will be apparent to practitioners skilled in the art. Additionally, the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
