---
title: Design, decoding and optimized implementation of SECDED codes over GF(q)
abstract: A plurality of columns for a check matrix that implements a distance d linear error correcting code are populated by providing a set of vectors from which to populate the columns, and applying to the set of vectors a filter operation that reduces the set by eliminating therefrom all vectors that would, if used to populate the columns, prevent the check matrix from satisfying a column-wise linear independence requirement associated with check matrices of distance d linear codes. One of the vectors from the reduced set may then be selected to populate one of the columns. The filtering and selecting repeats iteratively until either all of the columns are populated or the number of currently unpopulated columns exceeds the number of vectors in the reduced set. Columns for the check matrix may be processed to reduce the amount of logic needed to implement the check matrix in circuit logic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08756484&OS=08756484&RS=08756484
owner: Micron Technology, Inc.
number: 08756484
owner_city: Boise
owner_country: US
publication_date: 20130917
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","STATEMENT OF GOVERNMENT INTEREST","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is a divisional application of U.S. Non-Provisional application Ser. No. 13\/116,976, Design, Decoding and Optimized Implementation of SECDED Codes over GF(q), by H. Lee Ward et al., filed May 26, 2011 (allowed Jun. 21, 2013), which is incorporated herein by reference.","This invention was developed under Contract DE-AC04-94AL85000 between Sandia Corporation and the U.S. Department of Energy. The U.S. Government has certain rights in this invention.","The present work relates generally to linear block codes and, more particularly, to single error correcting, double error detecting (SECDED) codes over GF(q).","SECDED codes play a pivotal role in data transfer\/communication applications. One example is data storage applications. Advances in memory technology have provided the capability of storing increasingly large amounts of data in individual memory packages (or modules). This makes it possible to store\/retrieve from a single memory module data that previously was stored\/retrieved by accessing multiple modules, providing improvements in performance, power consumption, and scalability. When accessing a single module, it is advantageous to address effectively errors that have a single cause. For example, if several I\/O terminals of a module provide respective I\/O paths, a failed transmitter driving one of the terminals may be used multiple times per memory access. The bits transferred via any given terminal in a single burst may be considered to be a data symbol. If the terminal transfers data in 4-bit bursts, for example, then the symbol size is four bits. A sixteen-byte transfer might be accomplished by transferring a 4-bit burst (i.e., one symbol) on each of 32 terminals of the memory module. Within knowable limits, a SECDED code that appends four parity check symbols of four bits each is capable of correcting any error in a single data symbol (and detecting errors in two data symbols). Thus, errors repeatedly caused by a single failed transmitter associated with a single terminal may be corrected.","The aforementioned example SECDED code has a Hamming distance of at least four, in terms of symbols. This is a specific example of a linear [n, k, d]code over a general alphabet GF(q), with n=36 (data+parity check) symbols, k=32 data symbols, code distance d=4, and symbol alphabet size q=16 (2with 4 bits\/symbol), that is, a [36, 32, 4]code.","One approach to construct an [n, k, d]code is a random search of parity check matrices in GF(q). Considering the aforementioned example of a [36, 32, 4]code, there are 15 x 36 different single symbol errors, while the syndrome from the four symbol parity has 65536 possibilities. It thus appears that a random search would likely yield a code. Nevertheless, testing as many as 15 x 2H matrices obtained via random search has failed to yield a [36, 32, 4]code.","Another approach is to construct a [35, 32, 3]code, and extend it with a single parity check to a [36, 32, 4]code. Since GCD(35,16)=1, construction of a BCH code with n=35 and d=3 may be considered. BCH codes provide a minimum distance guarantee that is determined by the generator polynomial. However, investigation of BCH codes with n=35 and q=16 reveals that the most efficient BCH codes with d=3 are [35, 31, 3]codes, which cannot be extended to a [36, 32, 4]code.","Another approach is the use of an existing bound, such as the Gilbert-Varshamov (GV) bound, that indicates feasible codes. However, for the code distance d=4, the GV bound indicates that only k=27.5 is achievable.","Another approach is constructing a [36, 32, 4]code as four simultaneous [36, 32, 4]codes, or two simultaneous [36, 32, 4]codes. However, a [36, 32, 4]code does not exist because it violates the Hamming bound. Although a linear [36, 32, 4]code would not violate the Hamming bound, it has been found that [36, 32, 4]codes do not exist.","It is desirable in view of the foregoing to provide for the construction of distance d linear codes more efficiently than by random searching.","The present work provides for non-deterministically generating the parity check matrix for a linear [n, k, d]code over a general alphabet GF(q). The search space is organized as a tree, and the search can terminate in one of two states, one if it has taken an unsuccessful path and run out of search space, another if it has found a suitable parity check matrix. Also provided is a simple decoder for linear SECDED codes, with an efficient parallel implementation. The present work further provides for generating, from an input parity check matrix, another parity check matrix whose corresponding code has the same distance as that of the input matrix, is a subcode of the input matrix, and requires the minimum number of logical AND gates among all subcodes that encode the same set of symbols.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 1"],"b":["10","11","19","11","17"]},"In the retrieval path , the parity check symbols at  are exclusive-ORed (XORed) at  with the parity check symbols that were stored (and are now retrieved) with the data symbols. The result of the XOR operation at  is the syndrome, which is decoded by a syndrome decoder . The syndrome decoder , which uses information from entries in the matrix H, produces information  which may be used by an error corrector, together with the retrieved data symbols, to correct single symbol errors and output correspondingly corrected data. The syndrome decoder  also produces information  which indicates detection of errors in two (and often more) symbols.","The above-described operations performed by the check symbol generator , the syndrome decoder  and the error corrector  are generally known in the art. Thus, in some embodiments, these components operate in accordance with conventional techniques. However, with respect to the parity check matrix H used by the check symbol generator  and the syndrome decoder , the present work provides improved techniques for non-deterministically generating this matrix H for a linear SECDED code. The present work exploits the known relationship between the code distance of a linear code and the requirement that there must be linear independence of the column vectors of the parity check matrix for the code. More specifically, if H is the parity check matrix of a linear code C, then the code C has distance d if and only if any non-trivial linear combination of d\u22121 column vectors of H is not zero. (Column vectors may also be referred to herein simply as columns, or vectors.) A parity check matrix H is described in standard form as\n\n],\n\nwhere A is a matrix describing the parity checks, I is the identity matrix concatenated with A to form H, k is the number of data symbols transferred, and r is the number of parity check symbols generated for the k data symbols. The aforementioned property that no non-trivial linear combination of d\u22121 column vectors of H results in zero is referred to herein as \u201cd\u22121 linear independence\u201d, and the columns of H are said to be \u201cd\u22121 linearly independent.\u201d\n","Considering the aforementioned example using 4-bit symbols, this provides sixteen (2) available values for a symbol. That is, the size of the symbol alphabet, referred to herein as q, is q=16. As shown generally in , the present work provides an A matrix generator  that receives as input the aforementioned parameters q, d, r, and k, and produces a matrix A in such a manner that A, and thus H, exhibits the aforementioned d\u22121 linear independence property. The parameters d and r are related as d\u2266r+1 to avoid violation of the singleton bound. The check symbol generator  of  uses information from the symbol entries in the matrix H to generate the check symbols, and the syndrome decoder  uses information from the symbol entries in matrix H to decode the syndrome.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["20","31","31","31"],"sub":["rxk ","1","r","i","i ","i\u22121 ","i ","i\u22121","i\u22121 ","i ","i\u22121 ","i","i","i+1","i+1","i+1 ","i+2"],"sup":["r ","4 "]},"The iterative filter  is shown in more detail in . The filter  includes a first linear combination filter , a second linear combination filter , and a concatenation buffer  coupled for bidirectional communication with the second linear combination filter . The first linear combination filter  is an initializing filter that performs an initial vector elimination operation with respect to P, to produce an initial subset of P, namely P. The second linear combination filter  performs iterative filtering operations, beginning with the initial Presult produced by the first linear combination filter . For each iteration i that it performs (i=0, 1, 2, . . . ), the filter  selects from P(the current subset of P) a column vector for A, and applies the aforementioned vector elimination processing to Pto produce from Pa set Pfor the next iteration, i+1. The vector selected from P(when i=0) is stored in the column 0 (COL 0) entry of the concatenation buffer , the vector selected from P(when i=1) is stored in the column 1 (COL 1) entry, and so on. The concatenation buffer  is used in this fashion to construct the A matrix by successive concatenation of its columns.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 5","FIG. 4","FIG. 5"],"b":["41","51","52","53","53"]},{"@attributes":{"id":"p-0031","num":"0030"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"l","mo":"=","mn":"1"},{"mi":"d","mo":"-","mn":"2"}]},"mo":"\u2062","mrow":{"msub":[{"mi":["a","l"]},{"mi":["y","l"]}],"mo":"\u2062"}},"mo":","}}},"br":{},"sub":["l ","l ","0 "],"b":["53","55","53","54","55","55","53","54","56"]},"Noting that a column vector is d\u22121 linearly dependent with columns of I if and only if that vector has at least d\u22122 zeros, some embodiments form the set Pby simply eliminating from P all vectors that contain at least d\u22122 zeros. Consider, for example, the aforementioned scenario where each element of each column vector contains four bits. Each column vector wherein all four bits of at least d\u22122 elements are zero is eliminated from P, and the result is P.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 6","FIG. 4","FIG. 6","FIG. 6","FIG. 5","FIG. 5","FIG. 4"],"b":["42","43","60","61","52","55","62","62","43"],"sub":["i","i ","0 ","0 ","i ","i+1","i ","0","0 "]},"At , if the iteration index i=k\u22121, then all columns of A have been populated, and the matrix is complete. Otherwise, another vector is selected from Pat . The test shown at  is applied to the selected vector. The test  is whether the selected vector is of the form",{"@attributes":{"id":"p-0035","num":"0034"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"msub":{"mi":"a","mn":"1"},"mo":"\u2062","mi":"x"},{"munderover":{"mo":"\u2211","mrow":[{"mi":"l","mo":"=","mn":"2"},{"mi":"d","mo":"-","mn":"2"}]},"mo":"\u2062","mrow":{"msub":[{"mi":["a","l"]},{"mi":["y","l"]}],"mo":"\u2062"}}],"mo":"+"},"mo":","}}},"br":{},"sub":["1 ","l ","l ","i","i ","i ","i ","i+1 ","i"],"b":["65","67","65","66","67","67","64","66","65","66","68"]},"Thereafter, a test is performed at  to determine whether Pcontains enough vectors to populate the currently unpopulated columns of A. In the test , |P| denotes the number of vectors in P, and q is the size of the symbol alphabet. For each vector x that is yet to be concatenated to A at , at least the q\u22121 non-zero multiples of that vector will be eliminated at , so the maximum number of vectors still available for concatenation to A is bounded by |P|\/q\u22121. There are at this point i+1 columns already populated in A, with k\u2212i\u22121 columns remaining to be populated. The test  determines whether the maximum number of available vectors is less than the number of unpopulated columns of A. If not, then the iteration index is updated at , and operations return to  to begin the next iteration. Otherwise, the test  determines that there are not enough vectors in Pto complete the construction of A, so the current attempt to generate A fails.","The operations shown in  constitute only expository examples of how Pmay be formed from P. Various embodiments use various techniques. For example, in some embodiments, the technique used to form Pfrom Pis tailored to the size of the code and the data processing resources available. Some embodiments use a hash table to represent all qavailable vectors, with each vector indexing an entry in the table. The entries are in binary format, and are all initially set to the same binary value (e.g., 1). Elimination of a vector is represented by setting the corresponding entry to the other binary value (e.g., 0). For a given vector x, all vectors having the form specified at  in  are computed, and these computed vectors are used to index the hash table in parallel and write 0s to the corresponding entries, thereby forming P. The next vector x is selected from only those vectors whose corresponding table entry is 1.","In contrast to the above-described techniques of the present work, conventional approaches use a random code search when attempting to find an [n, k, d]code that is not a member of the currently known block codes or their modifications. The smaller the ratio of the total number of check matrices for [n, k, d]codes to the total number of k x r matrices, the less likely is the success of a random search technique. The present work provides a more systematic search for check matrices and is significantly more efficient than a random search in finding [n, k, d]codes if these codes are rare. Although the time needed to verify the d\u22121 linear independence of a column increases with successive iterations in the present work, the number of acceptable columns decreases with successive iterations. This makes it progressively more likely to choose columns that are acceptable as the time needed to verify column acceptability progressively increases. Also, because candidate columns may be identified as not acceptable while the matrix is being built, the present work determines relatively early if a matrix under construction will not work.","As an example, a random brute force search, using fifteen 2.27 GHz, 8 GByte processors for two weeks, has failed to produce a linear [36, 32, 4]code. (Relaxing the check symbol requirement to r=5, or the distance requirement to d=3, has been found to enable random brute force searching to produce the respectively associated [37, 32, 4]and [36, 32, 3]codes in about an hour.) In contrast, the techniques of the present work have produced a linear [36, 32, 4]code in under a minute using a single processor. A linear [68, 64, 4]code has also been produced according to the present work.","In some embodiments, the syndrome decoder  in  implements a simple decoding technique for linear SECDED codes that allows for a parallel implementation. The decoding technique (which may be generalized for use with larger distance codes) is based on the fact that the syndrome resulting from 12 (also ), designated as s, is a linear combination of columns of H. That is, if h(i), i=1, . . . , n are the columns of H (where n=k+r), and e=[e, . . . , e]is the error vector, then",{"@attributes":{"id":"p-0041","num":"0040"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"s","mo":"=","mrow":{"mi":"He","mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"msub":{"mi":["e","i"]},"mo":"\u2062","mrow":{"mi":"h","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}}}}},"br":[{},{},{}],"in-line-formulae":[{},{}],"i":["h","i","siff\u2203e\u03b5GF","q","s=eh","i"],"b":["71","73"],"figref":"FIG. 7","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["If hw(s)=0, where hw(s) is the Hamming weight of s, do nothing;","Else determine whether h(i)|s for i\u03b5{1, . . . , n}. If so, then the ith symbol is in error and the error is e=s\/h(i);","Else declare a multiple symbol error."]}}}},"Some embodiments achieve improved computational efficiency by assuming that H is in standard form, H=[AI], and that errors in the parity check symbols will not be corrected. As shown at - in , decoding under these assumptions is performed as follows:\n\n","Given s, h\u03b5GF(q), evaluating whether the condition h(i)|s is satisfied is equivalent to satisfying the following conditions, where i and j are symbol indices of the syndrome s and the column h(i)\n\n=0=0\n\nand\n\n\u2200\u22600 require ()=()\n\nFor purposes of evaluating the foregoing conditions, the multiplicative inverses of the possible non-zero symbol values in H (e.g., (h)and (h)) may be pre-computed. For example, in the aforementioned case of 4-bit symbols, each symbol value of each column may be represented as a single hexadecimal digit. The respective multiplicative inverses for the hexadecimal digits 1, 2, . . . , E, F are: 1 9 E D B 7 6 F 2 C 5 A 4 3 8.\n","Applying the conditions defined above to the symbols of an example column vector h=[4 F 0 3]in a four-row (r=4) H matrix, it can be seen that the h(i)|s condition is satisfied for a given syndrome s if\n\n=0\n\nand\n\n4=8=3\n\nwhere s, s, sand sare the syndrome symbols.\n\nIn some embodiments, pre-computed multiplicative inverses are stored, and the syndrome decoder  of  multiplies the appropriate multiplicative inverse values by the appropriate syndrome symbols in parallel to facilitate determining (e.g., at  in  in ) whether the h(i)|s condition is satisfied.  diagrammatically illustrates a corresponding portion of the syndrome decoder  according to example embodiments of the present work. The appropriate multiplicative inverses are provided in parallel from storage  based on the column content of the H matrix. Parallel multiplication logic  multiplies the appropriate stored inverses and the appropriate syndrome symbols in parallel, producing parallel results  that are compared at  (to determine whether the are equal) in support of the determination as to whether the h(i)|s condition is satisfied.\n","For a systematic [k+r, k, d]linear code with parity check matrix in standard form H=[A|r, and input x=[x. . . x], the check symbol generator  computes the parity check symbols as follows",{"@attributes":{"id":"p-0046","num":"0051"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"y","mn":"1"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":["y","r"]}}}]}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"k"},"mo":"\u2062","mrow":{"msub":{"mi":["x","i"]},"mo":"\u2062","mrow":{"mrow":{"mi":"h","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},"mo":"."}}}],"mo":"="}}},"br":{},"sup":["m","m","\u22121"],"b":["11","13"]},"Some embodiments produce a check matrix Hhaving r rows and k+r columns, and then use that matrix to produce another check matrix {tilde over (H)}having r rows and k+r columns. The columns of {tilde over (H)}have the same degree of linear independence as the columns of H(i.e., both matrices have the same code distance). It may be assumed without loss of generality that the matrix His in standard form. The matrix {tilde over (H)}is also in standard form. It is known in the art to form a matrix such as {tilde over (H)}by selecting its k+r columns from the k+r columns of a matrix such as H. However, example embodiments of the present work suitably process the columns of Hto permit the columns of {tilde over (H)}to be selected such that {tilde over (H)}has the lowest weight among all kxr sub-matrices that could be chosen from Hand have the same code distance as H.","As shown in , in some embodiments, the first k columns of {tilde over (H)}are determined based on Has follows:","At ,","For each column vector h(i), i=1, . . . , kof H,\n\n","In some embodiments, the matrix H used in the processing of  is produced by an A matrix generator (see  in ) that is similar to the A matrix generator  of , and generates the A matrix columns in the manner described relative to . However, the A matrix generator  produces A with kcolumns, and implements a corresponding concatenation buffer of width k(not explicitly shown in ), thereby permitting formation of the desired matrix H. As also shown in , data processing logic  produces {tilde over (H)}from H, for example, in the manner described relative to . The matrix {tilde over (H)}may then be used by the check symbol generator  and syndrome decoder  of .","Although example embodiments of the present work are described above in detail, this does not limit the scope of the present work, which can be practiced in a variety of embodiments."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 11","FIG. 1"]}]},"DETDESC":[{},{}]}
