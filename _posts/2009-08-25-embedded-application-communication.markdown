---
title: Embedded application communication
abstract: Methods, systems, and apparatus, including computer programs encoded on a computer storage medium, for embedded application communication. In one aspect, a method includes providing a first Application Programming Interface (API) in the host application, where the first API is configured to interact with a virtual machine object model of the virtual machine to allow the host application to set and get properties of one or more first class instances residing in a virtual machine memory space, and to invoke methods on the first class instances, and providing a second API in the virtual machine configured to interact with a host application object model in the host application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09141450&OS=09141450&RS=09141450
owner: Adobe Systems Incorporated
number: 09141450
owner_city: San Jose
owner_country: US
publication_date: 20090825
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Object-oriented programming (OOP) is a programming paradigm that uses \u201cobjects\u201d\u2014data structures comprising properties and methods\u2014and their interactions to design applications and computer programs. Programming techniques may include features such as information hiding, data abstraction, encapsulation, modularity, polymorphism, and inheritance. An object-oriented program or application may be viewed as a collection of cooperating objects wherein each object is capable of receiving messages, processing data, and sending messages to other objects.","In general, one aspect of the subject matter described in this specification can be embodied in a method that includes a method for providing a first Application Programming Interface (API) in the host application, the host application, where the first API is configured to interact with a virtual machine object model of the virtual machine to allow the host application to set and get properties of one or more first class instances residing in a virtual machine memory space, and to invoke methods on the first class instances; providing a second API in the virtual machine configured to interact with a host application object model in the host application to allow the virtual machine to set and get properties of one or more second class instances residing in a different host application memory space, and to invoke methods on the second class instances; and wherein the first and second APIs do not alter the format of data retrieved from the host and virtual machine application memory spaces. Other embodiments of this aspect include corresponding systems, apparatus, and computer program products.","These and other embodiments can optionally include one or more of the following features. The first API and the second API can be each configured to provide access to a respective name space that encompasses class names in the virtual machine model and the host object model, respectively. An object model can specify how class instances are stored in a memory space and semantic properties of the class instances. The application object model can be different from the virtual machine object model. The first API and the second API can be configured to create class instances in the virtual machine and the host application, respectively, corresponding to class instances in the virtual machine and host application, respectively. The created class instance has a same class name as a corresponding class. The first API can be used to invoke a method on a class instance in the virtual machine from the host application or using the second API to invoke a method on a class instance in the host application from the virtual machine. The first API can be further configured to allow the host application to control the lifespan of a class instance in the virtual machine. The second API can be further configured to allow the virtual machine to send events to the host application and wherein the first API is further configured to allow the host application to receive events from the virtual machine.","In general, another aspect of the subject matter described in this specification can be embodied in a system comprising a computer-readable storage device including a computer program product; one or more processors configured to interact with the storage device and execute the program product to perform operations comprising: providing a first Application Programming Interface (API) in the host application, the host application, where the first API is configured to interact with a virtual machine object model of the virtual machine to allow the host application to set and get properties of one or more first class instances residing in a virtual machine memory space, and to invoke methods on the first class instances; providing a second API in the virtual machine configured to interact with a host application object model in the host application to allow the virtual machine to set and get properties of one or more second class instances residing in a different host application memory space, and to invoke methods on the second class instances; and wherein the first and second APIs do not alter the format of data retrieved from the host and virtual machine application memory spaces. Other embodiments of this aspect include corresponding systems, apparatus, and computer program products.","These and other embodiments can optionally include one or more of the following features. The first API and the second API can be each configured to provide access to a respective name space that encompasses class names in the virtual machine model and the host object model, respectively. An object model can specify how class instances are stored in a memory space and semantic properties of the class instances. The application object model can be different from the virtual machine object model. The first API and the second API can be configured to create class instances in the virtual machine and the host application, respectively, corresponding to class instances in the virtual machine and host application, respectively. The first API can be used to invoke a method on a class instance in the virtual machine from the host application or using the second API to invoke a method on a class instance in the host application from the virtual machine. The first API can be further configured to allow the host application to control the lifespan of a class instance in the virtual machine.","In general, another aspect of the subject matter described in this specification can be embodied in a computer program product, encoded on a computer-readable storage device, operable to cause data processing apparatus to perform operations comprising: providing a first Application Programming Interface (API) in the host application, the host application, where the first API is configured to interact with a virtual machine object model of the virtual machine to allow the host application to set and get properties of one or more first class instances residing in a virtual machine memory space, and to invoke methods on the first class instances; providing a second API in the virtual machine configured to interact with a host application object model in the host application to allow the virtual machine to set and get properties of one or more second class instances residing in a different host application memory space, and to invoke methods on the second class instances; and wherein the first API and the second API are configured to create class instances in the virtual machine and the host application, respectively, corresponding to class instances in the virtual machine and host application, respectively. Other embodiments of this aspect include corresponding systems, apparatus, and computer program products.","These and other embodiments can optionally include one or more of the following features. The first API and the second API can be each configured to provide access to a respective name space that encompasses class names in the virtual machine model and the host object model, respectively. The application object model can be different from the virtual machine object model. The first API can be used to invoke a method on a class instance in the virtual machine from the host application or using the second API to invoke a method on a class instance in the host application from the virtual machine. The second API can be further configured to allow the virtual machine to send events to the host application and wherein the first API is further configured to allow the host application to receive events from the virtual machine.","Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. Host and embedded applications can create and access objects in the other, including invoking methods on the objects. Events raised in the embedded application can be caught by the host application, and vice versa. Data in a virtual machine memory space or a host application memory space has a format that does not change when the data is transferred between the host application and the virtual machine which allows for fast data transfers.","The host application and embedded application can each implement code that accesses functionality on \u201cthe other side of the fence\u201d as if that functionality were natively written on \u201ctheir own side of the fence.\u201d Although host and embedded applications easily access functionality in each other, they do so without entangling data or object lifetimes between themselves. That is, the lifetime of a host object and its associated embedded object are explicitly not linked to one another. As such, a host object can be deleted before, after, or at the same time as the associated embedded object. The host application determines which effect it wants on an object-by-object basis by the way it chooses to implement the callbacks listed later in the document. Lifetime independence, makes it significantly simpler for the host application and embedded application to work together because each side usually has very different models of object lifetime, and neither side is forced to use the lifetime model of the other and may, instead, use the lifetime model most convenient to itself.","The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.","In various implementations, a host application includes an embedded application that is configured to execute within the host application.  illustrates a graphic user interface (GUI)  for an example host application having an embedded application that is, in this example, a virtual machine. The GUI  represents the host application's primary GUI window that includes a viewing pane  which is an area of the primary GUI window that is used by the embedded application for displaying documents. There are other ways for a host and an embedded application to share the GUI , and one or both may not require a GUI. By way of illustration, an embedded application can execute as one or more threads within the process space of the host application. Other techniques for embedding an application are possible.","Generally speaking, an application is a computer program such as, for instance, a web browser or a word processor. An application includes data and instructions which are processed by a computing device in order to implement the application's functionality. An application can execute atop an operating system or it can execute directly on the underlying hardware of a computing device. By way of further illustration, an application such as a virtual machine can be capable of processing data and instructions of another application. An example of a virtual machine is the Adobe Flash Player (available from Adobe Systems Incorporated of San Jose, Calif.). The Flash Player can execute computer programs written in the ActionScript programming language.","Returning to , the example host application is a Portable Document Format (PDF) document viewer written in the C++ programming language that renders PDF documents for viewing. For example, user selection of the icon representing a PDF document will cause a corresponding document to be rendered in the viewing pane  of the embedded application. The embedded application in this example is an ActionScript virtual machine that itself executes a program that is capable of rendering PDF documents on behalf of the host application.","The host application can reference data in the embedded application, and vice versa. In various implementations, the referenced data can be application variables, memory addresses, metadata, instantiated classes (or \u201cobjects\u201d), or class data, for example. Other types of data are possible. In this illustration, the embedded application can reference a PDF document in order to render the document on behalf of the host application. For example, the PDF document represented by icon can be a document stored in the host application's memory as a C++ object. The embedded application can reference the host application's C++ object by creating an ActionScript object in the embedded application's memory that is associated with the host application's object. Function or method invocations made by the embedded application on the embedded application object are routed to the host application's object. Data that is returned by the host object's method invocation are passed from the host application to the embedded application. In this way, data stored in the host application objects can be accessed by the embedded application.","Similarly, the host application can access data in the embedded application. For example, when a PDF document is presented in the viewing pane , the host application can bookmark the location that was last displayed in the document. When that document is later shown in the viewing pane , it can be opened to the bookmarked position. For example, the embedded application can include an ActionScript object that represents the current page in the document that is being displayed. Before the host application loads a new document, the host application instantiates a C++ object that references the embedded application's ActionScript object. The host application can invoke a method on the host application object to retrieve the current page property from the embedded application's ActionScript object. The request is routed to the embedded application's object, and current page number is returned to the host application.","While the example host and embedded applications in  are illustrated having GUIs, they need not. Either the host or the embedded application, or both, can be a virtual machine. In further implementations, neither the host nor the embedded application are virtual machines.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","214","200","202","204","202","204","202","206","202","202","104","206","202","204","206"]},"The host application  includes an object model . Generally speaking, for a specific programming language, an object model defines compile-time and run-time behaviors for classes and objects such as, for example, inheritance, object instantiation, data hiding, data abstraction, method invocation, polymorphism, encapsulation, and the storage format of objects in memory (e.g., host object memory space ). An object model can be enforced at compile-time, run-time or both. At run-time an object model can include data and instructions that are invoked to implement the various behaviors.","By way of illustration, a base class for all geometric shapes can be defined according to a C++ object model  for the host application . Specific shapes can be created as subclasses of the shape base class. For example, a rectangle can be defined as a shape with two pairs of straight, parallel edges of the same length, for instance. A square can be defined as a rectangle where all four sides are the same length. In this way, a class hierarchy can be defined according to the object model  of the host application's programming language.","The host object memory space  comprises one or more sections of memory allocated for use by the host program . The host program  represents instructions that when executed by the computing device  implement functionality of the host application . The host object memory space  is used for storing objects for use by the host program . For example, objects  in memory space  represent three objects used by the host program .","The embedded application  (e.g., an ActionScript program executing in an ActionScript virtual machine) contains instructions  that when executed perform operations that can access the host application's object model  or memory space  by way of the API . In order to expose its object model  to the embedded application , the host application  registers a number of callback functions or methods in its API . The embedded application  uses these functions to access properties of, or create objects in, the host application memory space , or to invoke methods on objects in the host object memory space . In some implementations, the callback functions are those described in TABLE 1. Other callback functions are possible, however. A similar set of functions can be made available to the host application to access the object model  and memory space  of the embedded application .",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FUNCTION","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GetRootCallback","This callback returns the root object for the host"]},{"entry":[{},"application 206. The root object provides access to"]},{"entry":[{},"properties, methods and classes in the object model 208"]},{"entry":[{},"and objects 213 in memory space 212. By way of"]},{"entry":[{},"illustration, a root object would, for example, provide"]},{"entry":[{},"access to the host application 206's document or window"]},{"entry":[{},"objects (e.g., 102a, 104, 100)."]},{"entry":[{},"Return value:"]},{"entry":[{},"Memory address of root object"]},{"entry":["GetClassObjectCallBack","This callback retrieves an object in the host application's"]},{"entry":[{},"object model 208 to access static properties and methods of a"]},{"entry":[{},"class."]},{"entry":[{},"Argument:"]},{"entry":[{},"Class path (see below)"]},{"entry":[{},"Return value:"]},{"entry":[{},"A class object"]},{"entry":["CreateCallback","The embedded program 220 invokes this callback with a"]},{"entry":[{},"class path and constructor arguments to instantiate a host"]},{"entry":[{},"application 206 object in memory space 212. In some"]},{"entry":[{},"implementations, the callback returns an opaque"]},{"entry":[{},"reference to the memory object in host memory space"]},{"entry":[{},"212 which implements the constructed object."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Class path (see below)"]},{"entry":[{},"Constructor arguments"]},{"entry":[{},"Return value:"]},{"entry":[{},"Memory address of the instantiated class object"]},{"entry":["GetClassNameCallback","This callback retrieves the class name of an object in the"]},{"entry":[{},"host application memory space 212. The returned class"]},{"entry":[{},"name may either be a partially or fully qualified class"]},{"entry":[{},"path."]},{"entry":[{},"Argument:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Return value:"]},{"entry":[{},"Class path of the object (see below)"]},{"entry":["DisconnectCallback","The embedded application 214 can invoke this callback"]},{"entry":[{},"when an object in the embedded application 214's"]},{"entry":[{},"memory space 222 associated with the a host application"]},{"entry":[{},"206 object is garbage collected, deleted or otherwise"]},{"entry":[{},"becomes disconnected from the host application 206"]},{"entry":[{},"object. The host application 206 is free to react in any"]},{"entry":[{},"way; it could decrement a reference count for the host"]},{"entry":[{},"object, delete the host object, or keep the host object for"]},{"entry":[{},"later reuse, for instance."]},{"entry":[{},"Argument:"]},{"entry":[{},"Memory address of the object"]},{"entry":["GetPropertyFlagsCallback","This callback returns a set of property flags (e.g., read-"]},{"entry":[{},"only property, a read-write property, a callable method,"]},{"entry":[{},"or a combination of a property and a method) for an"]},{"entry":[{},"object in memory space 212."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property name"]},{"entry":[{},"Return value:"]},{"entry":[{},"A set of property flags"]},{"entry":["GetPropertyCallback","This callback retrieves the value of an object property."]},{"entry":[{},"The arguments to the callback include a reference to the"]},{"entry":[{},"host application 206 object and the name of the object's"]},{"entry":[{},"property."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property name"]},{"entry":[{},"Return value:"]},{"entry":[{},"Value of the property"]},{"entry":["SetPropertyCallback","This callback stores the value of an object property. The"]},{"entry":[{},"arguments to the callback include a reference to the host"]},{"entry":[{},"application 206 object, the name of the host object's"]},{"entry":[{},"property, and a new value for the property."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property name"]},{"entry":[{},"Value of the property"]},{"entry":["InvokeMethodCallback","This callback invokes a method on a host application 206"]},{"entry":[{},"object. The arguments to the callback include a reference"]},{"entry":[{},"to the host application 206 object, the name of the"]},{"entry":[{},"method to invoke, and method arguments, if any. If the"]},{"entry":[{},"method has return value(s), the return values are supplied"]},{"entry":[{},"in an array."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Method name"]},{"entry":[{},"Method arguments (if any)"]},{"entry":[{},"Return value:"]},{"entry":[{},"Method return values (if any)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Generally speaking, atoms are containers for data entities (e.g., function parameters and return values) that flow back and forth between the host application  and the embedded application  through the API's  and . In various implementations, an atom is represented as a 32-bit or 64-bit value. This value is large enough to contain either a pointer (e.g., a memory reference to an object or other data in memory space  or ), an integer, or a floating point value. Examples of atom types are listed in TABLE 2. Other atom types are possible. In some implementations, for the callbacks in TABLE 1, references to objects in memory space  and  are opaque void* pointers. These pointers can be passed between the objects in the host application  and the embedded application  as atoms without having to be de-referenced. In various implementations, storing data from a memory space (e.g.,  or ) in atoms does not result in the data changing its format. This allows for fast data transfers between the host and embedded applications because marshaling and de-marshaling (or encoding and decoding) of data is not performed by either API ( and ).",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"ATOM","DESCRIPTION"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String","An ordered collection of characters."]},{"entry":[{},"Boolean","True or False data."]},{"entry":[{},"Integer","A signed integer."]},{"entry":[{},"Double","Floating point value."]},{"entry":[{},"Special","Undefined, Null, or other special case values."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The embedded application  also includes an object model  which can be the same or similar to object model , or entirely different. The embedded application memory space  comprises one or more sections of memory allocated for use by the embedded application . The embedded program  represents instructions that when executed by the computing device  implement functionality of the embedded application . The memory space  is used for storing objects (e.g., ) for use by the embedded program .","The host application  contains instructions  that when executed perform operations that can access the embedded application's object model  or memory space . In order to expose its object model  to the host application , the embedded application  registers a number of functions or methods in its API . The host application  uses these functions to access properties of, or create objects in, the embedded application memory space , or to invoke methods on objects in the embedded application memory space . In some implementations, the functions are those described in TABLE 3. Other callback functions are possible, however.",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FUNCTION","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GetRoot","This function returns the root object for the embedded"]},{"entry":[{},"application 214. The root object provides access to"]},{"entry":[{},"properties, methods and classes in the object model 219"]},{"entry":[{},"and objects 223 in memory space 222. If the embedded"]},{"entry":[{},"application is a Flash virtual machine, for instance, the root object"]},{"entry":[{},"can be the Flash Player instance."]},{"entry":[{},"Return value:"]},{"entry":[{},"Memory address of a root object"]},{"entry":["GetClassObject","This function retrieves an object in the embedded"]},{"entry":[{},"application's object model 219 to access static properties"]},{"entry":[{},"and methods of a class."]},{"entry":[{},"Argument:"]},{"entry":[{},"Class path (see below)"]},{"entry":[{},"Return value:"]},{"entry":[{},"A class object"]},{"entry":["ObjectCreate","This function is invoked with a class path and constructor"]},{"entry":[{},"arguments to instantiate an embedded application 214"]},{"entry":[{},"object in memory space 222. In some implementations,"]},{"entry":[{},"the callback returns an opaque reference to the memory"]},{"entry":[{},"object in host memory space 222 which implements the constructed"]},{"entry":[{},"object."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Class path (see below)"]},{"entry":[{},"Constructor arguments"]},{"entry":[{},"Return value:"]},{"entry":[{},"Memory address of the instantiated class object"]},{"entry":["GetClassName","This function retrieves the class name of an object in the"]},{"entry":[{},"embedded application memory space 222. The returned"]},{"entry":[{},"class name may a partial or fully qualified class path."]},{"entry":[{},"Argument:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Return value:"]},{"entry":[{},"Class path (see below)"]},{"entry":["Lock","This function locks or unlocks an object in the embedded"]},{"entry":[{},"application memory space 222 to prevent or permit"]},{"entry":[{},"garbage collection or deletion."]},{"entry":[{},"Argument:"]},{"entry":[{},"Memory address of the object"]},{"entry":["GetPropertyFlags","This function returns a set of property flags (e.g., read-"]},{"entry":[{},"only property, a read-write property, a callable method,"]},{"entry":[{},"or a combination of a property and a method) for an"]},{"entry":[{},"object in memory space 222."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property name"]},{"entry":[{},"Return value:"]},{"entry":[{},"A set of property flags"]},{"entry":["GetProperty","This function retrieves the value of a property. The"]},{"entry":[{},"arguments to the function include a reference an object in"]},{"entry":[{},"memory space 222 and the name of the object's property."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property name"]},{"entry":[{},"Return value:"]},{"entry":[{},"Property value"]},{"entry":["PutProperty","This function stores the value of a property. The"]},{"entry":[{},"arguments to the function include a reference to the"]},{"entry":[{},"object in memory space 222, the name of the host"]},{"entry":[{},"object's property, and a new value for the property."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property value"]},{"entry":["DeleteProperty","This function deletes a value or method of an embedded"]},{"entry":[{},"application 214 object."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property name"]},{"entry":[{},"Return value:"]},{"entry":[{},"Boolean value indicating success or failure"]},{"entry":["InvokeMethod","This function invokes a method on an embedded"]},{"entry":[{},"application 214 object. The arguments to the function"]},{"entry":[{},"include a reference to the embedded application 214"]},{"entry":[{},"object, the name of the method to invoke, and method"]},{"entry":[{},"arguments (as atoms), if any. If the method has return"]},{"entry":[{},"value(s), the return values are supplied in an array of"]},{"entry":[{},"atoms. InvokeMethod takes as arguments a reference to"]},{"entry":[{},"the object and a property name."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Method name"]},{"entry":[{},"Method arguments"]},{"entry":[{},"Return value:"]},{"entry":[{},"Method return values (if any)"]},{"entry":["AddEventListener","This function registers a host application 206 event"]},{"entry":[{},"listener for events generated by an embedded application"]},{"entry":[{},"214 object. Particular event types can be specified (e.g.,"]},{"entry":[{},"object creation, object deletion, exception). Events are"]},{"entry":[{},"described in further detail below. Events generated by"]},{"entry":[{},"the object are provided to the host application 206 event"]},{"entry":[{},"listener for further processing by the host application"]},{"entry":[{},"206."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Event type"]},{"entry":["RemoveEventListener","This function removes a previously registered host"]},{"entry":[{},"application event listener."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Event type"]},{"entry":["Enumerate","This function is called once or repeatedly to enumerate"]},{"entry":[{},"the contents of an object in memory space 222."]},{"entry":[{},"Arguments:"]},{"entry":[{},"Memory address of the object"]},{"entry":[{},"Property identifier"]},{"entry":[{},"Return value:"]},{"entry":[{},"Property identifier of the next property"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In some implementations, the embedded application 's objects can dispatch event messages when they perform an action, change state, or are otherwise manipulated. These events can be captured by host application listeners that register with the object (AddEventListener) and listen for events. Listeners can listen for a particular type of event, or for any type of event. For example, an embedded application  object that represents a document can dispatch a \u201csaved\u201d or \u201cclosed\u201d event. A host application  object that is a file manager may register a listener specifying the \u201csaved\u201d event. When the embedded application  object dispatches a \u201csaved\u201d event, the host application listener performs an action such as updating a use log. When the \u201cclosed\u201d event is dispatched, the listener will ignore the event, as it is not the type specified.","Exception creation is a mechanism to respond to the execution of a program that indicates an error, an invalid action, or an unexpected event. For example, when a program attempts to read a file from disk that is not there, a FileNotFound exception can be created. This exception can be handled in a number of different ways, such as by alerting the user, selecting a file that does exist, or delaying for a time and attempting to read the file again later.","Exceptions created in the host application  can be transmitted to the embedded application , and vice versa. For example, if the embedded application  calls the InvokeMethodCallback function on a host application  object with a parameter that causes an exception in the host application , the host application  can return a value from the method indicating to the embedded application  that an exception occurred. Similarly, if the host application  calls the InvokeMethod function on an embedded application  object with a parameter that causes an exception in the embedded application , the embedded application  can return a value from the method indicating to the host application  that an exception occurred.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["214","300","219","214","302","300","304","302","304","219","306","304","306","304","302","219","302","304","306"]},"Each API ( and ) allows access to the class name space (the set of all class paths) of the embedded application  or the host application , respectively, for the creation and manipulation of class objects in that name space. API  allows the embedded application to have access to the class name space of the host application  and, likewise, API  allows the host application to have access to the class name space of the embedded application . In some implementations, the class name spaces are maintained in the object model (, ) of the respective application.","By way of illustration, in some implementations the GetClassName function described above in TABLE 3 in reference to API  returns class paths of classes in the embedded application 's object model  to the host application . Also in reference to API , the Get Root function returns an object that is instantiated from the root class of the class trie, such as the \u201cFlash\u201d class in this example. The root object can be used by the embedded application  or the host application  in order to traverse the class hierarchy  and discover the properties and methods of its classes.","The host application  example class hierarchy  is represented by the object model  of the host application . The root class  of the class hierarchy  is named the \u201ccom.adobe.appname\u201d class. The \u201cLayer\u201d class  or  is a child or subclass of the \u201ccom.adobe.appname\u201d class  and, as such, inherits properties and methods of the parent class  according to the object model . In some implementations, a class is identified by a fully or partially qualified class path, as described above.","By way of illustration, in some implementations the GetClassNameCallabck function described above in TABLE 2 in reference to API  returns class paths of classes in the host application 's object model  to the embedded application . Also in reference to API , the Get RootCallback function returns an object that is instantiated from the root class  of the class hierarchy , such as the \u201ccom.adobe.appname\u201d class in this example. The root object can be used by the host application  or the embedded application  in order to traverse the class hierarchy  and discover the properties and methods of its classes.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["306","214","206","212","214","216","206","216","212","212","408","410","206","214","222","214","206"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["500","206","214","502","218","219","222","504","216","208","212","506","218","222","508","216","212"]},"Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).","The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.","The term \u201cdata processing apparatus\u201d encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, a personal computer system, desktop computer, laptop, notebook, netbook computer, mainframe computer system, handheld computer, workstation, network computer, application server, storage device, a consumer electronics device such as a camera, camcorder, set top box, mobile device, video game console, handheld video game device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device or multiple ones, or combinations, of the foregoing The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.","A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program can, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.","Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.","An electronic document (which for brevity will simply be referred to as a document) can, but need not, correspond to a file. A document can be stored in a portion of a file that holds other documents, in a single file dedicated to the document in question, or in multiple coordinated files.","While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what can be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features can be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination can be directed to a subcombination or variation of a subcombination.","Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing can be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.","Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing can be advantageous."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
