---
title: Apparatus and method for UPnP device code generation using XML
abstract: An apparatus and method for UPnP device code generation using XML are described. The method includes receiving a UPnP device description document from a device developer. Once received, one or more service control class files are generated, including one or more service control stub-methods. Next, the service control class files are received, including updated service control stub-methods. The updated stub-methods are modified by the device developer in order to respond to actions received by a UPnP device described by the UPnP device description document. Finally, the service control class files and the updated service control stub-methods, along with a device class library and a UPnP SDK are compiled to generate a device executable for the UPnP device described by the UPnP device description document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07017148&OS=07017148&RS=07017148
owner: Intel Corporation
number: 07017148
owner_city: Santa Clara
owner_country: US
publication_date: 20010710
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION","ALTERNATE EMBODIMENTS"],"p":["The invention relates generally to the field of universal plug and play devices. More particularly, the invention relates to a method and apparatus for UPnP device code generation using XML.","The advent of Device Plug and Play (PnP) has revolutionized device integration within an operating system. Device PnP capability within an operating system makes it a great deal easier to setup, configure, and add peripherals to a PC. Universal Plug and Play (UPnP) extends device PnP capability to an entire network. Accordingly, a UPnP network enables discovery and control of devices within the UPnP network. The devices include networked devices and services, such as network-attached printers, Internet gateways, and consumer electronics equipment.","However, UPnP is more than just a simple extension of the Plug and Play peripheral model. UPnP is designed to support zero-configuration, \u201cinvisible\u201d networking, and automatic discovery for a breadth of device categories from a wide range of vendors. Utilizing UPnP, a device can dynamically join a network, obtain an IP (Internet protocol) address, convey its capabilities, and learn about the presence and capabilities of other devices. These dynamic capabilities occur automatically, thereby truly enabling zero configuration networks. Consequently, devices within a UPnP network can communicate with each other directly to enable peer to peer networking.","The varieties of device types that can benefit from a UPnP enabled network are large and include intelligent appliances, wireless devices, and PCs of all form factors. In fact, the scope of UPnP is large enough to encompass many existing, as well as new and exciting scenarios. These new and exciting scenarios include home automation, printing and imaging, audio\/video entertainment, kitchen appliances, automobile networks, and proximity networks in public venues. Moreover, UPnP uses standard TCP\/IP (TransmissionControlProtocol\/IP) and Internet protocols. Accordingly, UPnP device capabilities can be seamlessly fit into existing networks. Furthermore, using these standardized protocols allows UPnP to benefit from a wealth of experience and knowledge, and makes interoperability an inherent feature.","UPnP is a distributed, open network architecture, defined by the protocols used. As a result, UPnP is independent of any particular operating system, programming language, or physical medium (just like the Internet). In addition, UPnP does not specify the APIs (application programming interfaces) applications will use. As a result, operating system vendors are allowed to create the APIs that will meet their customer needs. Unfortunately an easy and quick solution for expediting the device development process does not exist.","Accordingly, UPnP device development requires a thorough understanding of UPnP, a UPnP development kit, such as Intel's UPnP SDK (software development kit), as well as XML (extensible mark-up language). In addition, the device developer is forced to repeatedly write similar code for each device implementation, with little variation. As a result, each new device requires fresh design and implementation work from scratch. Besides this, the developer has to write the code to parse XML, perform parameter conversion, handle callbacks, manage an event table, generate responses, map services, etc. Furthermore, testing time and resources are duplicated for each new device implementation. These problems become serious in a project that is time critical and requires quick deployment.","Therefore, there remains a need to overcome one or more of the limitations in the above-described existing.","A method and apparatus for UPnP device code generation using XML are described. The method includes receiving a universal plug and play (UPnP) device description document from a device developer. Once received, one or more service control class files are generated, which include one or more service control stub-methods. Next, the service control class files are received, including updated service control stub-methods. The updated stub-methods are modified by the device developer in order to respond to actions received by a UPnP device described by the UPnP device description document. Finally, the service control class files and the updated service control stub-methods, along with a device class library and a UPnP software developing kit (SDK) are compiled to generate a device executable for the UPnP device described by the UPnP device description document.","In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In addition, the following description provides examples, and the accompanying drawings show various examples for the purposes of illustration. However, these examples should not be construed in a limiting sense as they are merely intended to provide examples of the present invention rather than to provide an exhaustive list of all possible implementations of the present invention.","In other instances, well-known structures and devices are shown in block diagram form in order to avoid obscuring the details of the present invention. In an embodiment, the methods of the present invention are embodied in machine-executable instructions. The instructions can be used to cause a general-purpose or special-purpose processor that is programmed with the instructions to perform the steps of the present invention. Alternatively, the steps of the present invention might be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.","The present invention may be provided as a computer program product which may include a machine or computer-readable medium having stored thereon instructions which may be used to program a computer (or other electronic devices) to perform a process according to the present invention. The computer-readable medium may include, but is not limited to, floppy diskettes, optical disks, Compact Disc, Read-Only Memory (CD-ROMs), and magneto-optical disks, Read-Only Memory (ROMs), Random Access Memory (RAMs), Erasable Programmable Read-Only Memory (EPROMs), Electrically Erasable Programmable Read-Only Memory (EEPROMs), magnetic or optical cards, flash memory, or the like.","Accordingly, the computer-readable medium includes any type of computer\/media\/machine-readable medium suitable for storing electronic instructions. Moreover, the present invention may also be downloaded as a computer program product. As such, the program may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client). The transfer of the program may be by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem, network connection or the like).","System","The present invention describes an apparatus and method for which a universal plug and play (UPnP) based device can be created from a UPnP device description document with significantly less effort than required by conventional UPnP-based device design. Referring now to , an apparatus  is composed of two modules: the universal device tool (UDT)  and the universal device class library (UDCL) . The UDT  provides a generic tool to generate UPnP-based device implementations. The UDT  provides separate class templates as output code (UDS) for each service listed in the UPnP device description document. The UDS output code  generated by the UDT  includes service control stub-methods , which are provided to a device developer .","As will be described in further detail below, the service control stub-methods  provide template code for responding to actions and events encountered by a UPnP device described by the UPnP device description document . Accordingly, once updated by a device developer , the updated stub-methods  are combined with the UDS output code  to form updated UDS output code , which can then be compiled and linked with the UDCL , as well as a UPnP software development kit (SDK)  in order to generate a device executable  for the UPnP device described by the device description document . Accordingly, the device executable  is designed to provide operating system (OS) independent UPnP service code.","Referring now to ,  further illustrates the UDT  in accordance with an embodiment of the present invention. As will be described in further detail below, the UDT  is an extensible mark-up language (XML) parser that takes, for example, an input XML file and generates one or more class files, such as for example C++ class files. The UDT output code  creates service-specific classes that include code to process UPnP events, parse XML packets, perform parameter conversion and also enable creating and sending response packets.","Referring again to , the UDT  includes a tool  (see CUdTool , ), which receives the device description document , which in one embodiment is a device-control protocol description document (DCP), including links to one or more service control protocol description files. Once received, the tool  parses the description file  in order to ascertain a root device and various embedded devices described by the description document . In addition, the tool also ascertains the services, the service identification codes and device identification codes (ID) of the various devices described by the document . Once determined, the tool  passes the determined device IDs, service IDs and relevant service control protocol description documents (SCPD) to the class generator  (see CClassGenerator , ). Accordingly, the class generator  takes the required parameters, such as the SCPD file , the device and service IDs, and creates a service-specific set of classes for all services found in the root device, as well as services for any embedded devices to generate the UDS output code .","Once the class generator has created the service class , details of the classes are passed to a class linker  (see CLinker , ). The class linker  keeps track of all service class files  generated for the device. As such, each time the class generator  generates a new class, the class linker  adds its information in its service list table. Finally, the class linker  generates a service linker class file  for the entire device. The service linker class keeps all details of each service class and its parent device. Moreover, the class generator  generates the code that creates the necessary device hierarchy for the root device. The root device is first generated by the service linker and is then registered with an event listener class, which, as described in further detail below, is part of the UDCL.","Referring now to ,  depicts a class hierarchy for the classes utilized by the UDT . In one embodiment, the UDT  is composed of four different classes. The CUtil  works as a base class for the remaining classes. In the embodiment described, common utility methods and data types utilized by the UDT  are abstracted into the CUtil class . A CUdTool class works as a main component of the UDT system  by driving the entire operation of UDS code generation . CUdTool  creates a class generator object for each service found in the device description document  and also passes the required parameters necessary for class generation.","Once the respective service class is generated by the class generator , the CUdTool  passes this class information to the class linker . In one embodiment the CUdTool  creates an instance of the CLinker class  in order to perform the functionality of the class linker . In contrast, the CUdTool  creates an instance of class generator for each service described by the UPnP device description document , which is destroyed once class generation of the respective service is complete. Accordingly, once service class generation is complete, the CLinker objects collects the relevant class information in its service table and creates the service linker class file (CServiceLinker) .","Referring now to ,  depicts a sample device description document . Although device description documents are generally provided in XML format, the document  is not depicted in XML format in order to avoid obscuring the details of the present invention. The device description document  describes a television (TV) device with various controls, as well as an embedded VCR devices. The device description document , once passed to the UDT , will generate the following sequences of operation, as depicted with reference to . As depicted with reference to , an instance of the CUdTool  will create a root directory for the UPnP device , which, in the embodiment described, is a TV device . Next, the CUdTool  will pass control service information , which results in the creation of a CClassGenerator . Next, the CClassGenerator  creates a service control class and corresponding header file . Next, the relevant class information  is provided to an instance of the CLinker class .","The service control class generation is repeated when the CUdTool  passes picture service control information  to the class generation , which results in generation of a new CClassGenerator . The new CClassGenerator creates service control class files for the picture service . Next, C-picture class information  is passed to the CLinker object . Finally, the CUdTool  creates a directory for embedded device VCR . Once generated, the CUdTool  passes control service information, which results in the generation of a new CClassGenerator . The CClassGenerator next creates control information service classes and corresponding header files . Once generated, CControl class information is passed back to the CLinker. Finally, the CLinker object  generates the service linker class file  and corresponding header file.","Accordingly, referring to ,  depicts UDS output code  and directory information generated by the process described with reference to  As illustrated, the directory information includes the root device , including corresponding service control class files and corresponding header files. In addition, the directory includes a sub-root directory for the embedded device VCR , as well as service control class files and corresponding header files. In addition, the CUdTool  may generate various declaration files, which are linked during compilation time.","Unfortunately, the UDS output code , as depicted in  now requires intervention by the device developer  in order to implement code within the service control stub-methods  in order to generate updated stub-methods , which are combined with the UDS output code  in order to generate a complete set of UDS output code , as depicted in . Accordingly, what follows is a service control stub-method generated for a calculator device implementing two methods of add and subtract, for example, as described with reference to . As such, in one embodiment, the UDS output code may include the following stub-methods:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"int Calculator::ADD(int Number1, int Number2)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Res = Number1 + Number2;\/\/SAMPLE CODE ADDED BY"]},{"entry":[{},"DEVELOPER"]},{"entry":[{},"\/\/Add Actual implementation code here. After adding the code"]},{"entry":[{},"\u2002remove the comment from the line below to send the response."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/OutEvt->SetResp(UpnpMakeResponse(\u201cRegisterAdapter\u201d,ServiceType,"},{"entry":"1,\u201cResult\u201d,ToString"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Res))));"]},{"entry":[{},"\/\/Because this function is not implemented so just returning error"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"!!!!!!!"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OutEvt->SetErr(\u201cThis action is not implemented yet !!!!!\u201d);"]},{"entry":[{},"return ERR_ACTION_NOT_IMPLEMENTED;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"int Calculator::Substract(int Number1, int Number2)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Res = Number1 - Number2;\/\/SAMPLE CODE ADDED BY"]},{"entry":[{},"DEVELOPER"]},{"entry":[{},"\/\/Add Actual implementation code here. After adding the code"]},{"entry":[{},"\u2002remove the comment from the line below to send the response."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/OutEvt->SetResp(UpnpMakeResponse(\u201cRegisterAdapter\u201d,ServiceType,"},{"entry":"1,\u201cResult\u201d,ToString"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Res))));"]},{"entry":[{},"\/\/Because this function is not implemented so just returning error"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"!!!!!!!"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OutEvt->SetErr(\u201cThis action is not implemented yet !!!!!\u201d);"]},{"entry":[{},"return ERR_ACTION_NOT_IMPLEMENTED;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As such, the service control stub-method indicates a place mark where the developer  should provide his code as indicated \u201cADD ACTUAL IMPLEMENTATION CODE HERE\u201d. Accordingly, the developer is only required to write the portion of code to handle the function or event, while code to handle the underlying UPnP functionality is automatically generated. As indicated above, the developer would add the following sample code \u201cRes=Number \u2212Number \u201d and remove the comment from \u201c\/\/OutEvt\u2212>SetResp . . . \u201d to send the response to the control point. Consequently, the amount and requirement of code provided by the developer will vary from application to application, but ideally, the developer will have to write only application-specific code without having to worry about the specific underlying details of UPnP, which are provided by the CUdTool . Once the developer has updated the stub-methods, the stub-methods can be compiled with a universal device class library  along with a UPnP SDK , which are now described.","Referring now to ,  depicts one embodiment of a class hierarchy  for the classes utilized by the universal device class library (UDCL) . The UDCL  provides a device class library that performs any UPnP-related activities, which are not performed by service control classes generated by the UDT . Accordingly, the UDS output service control classes  are compiled and linked with the UDCL , as well as the UPnP SDK, for example the Intel UPnP SDK to create a device executable . The device executable  provides UPnP functionality to the UPnP device described by the device description document  ().","As illustrated in , the UDCL  includes seven primary UPnP device utility classes. These UPnP device utility classes can, in one embodiment, be utilized by device developer to either initialize the UPnP device or extend its services. In this embodiment, the UDCL  is designed to work with code that is either generated by the UDT  or written by an independent device developer. Accordingly, the device executable  generated by combining the UCDL , the UDS output code , as well as the UPnP SDK  will create a root device and register it with the UDCL in order to receive events for services listed under the root device.","As illustrated, the UDCL includes the following classes: CList , CRootService , CDevice , CDeviceManager , CServiceManager , CEvent  and CEventListener , as depicted in . The CDeviceManager  manages a root device table (RDT) which stores instances of all root devices  registered with the UDCL . As such, the device manager  manages a device object tree (DOT) , as depicted in . In addition, the device manager  traverses through the DOT  and adds all embedded services in a service object table (SOT), which is managed by the CServiceManager class . In one embodiment, there are two categories of root devices that can be added into the root device table (RDT). A static root device sends advertisements and is searchable by a control point, while dynamic root devices are normally created on demand and do not send advertisements. In addition, the control point cannot search the dynamic root device.","As illustrated by , devices under a UDCL DOT  are structured as multiple tree nodes, which may contain other embedded devices  (-, . . . , -N) and services (, , ). On the other hand, services represent a leaf node in the UDCL DOT . As such, any device can be added or removed to\/from any other devices. In the same way, services can also be added or removed from any device. The CEventListener class  accepts a DOT, for example DOT , as a listener object, which is passed to the CDeviceManager  for registration. CDeviceManager  finds the attached service object by traversing this DOT object  and registers its entry into a service object table.","A service object table (not shown) is, in one embodiment, a service database that stores instances of service objects, along with their respective device identification and service identification. The CServiceManager class  manages the service object table. Services registered in the SOT will receive event or action requests from the CEventListener object . Accordingly, a device executable created in accordance with the teachings of the present invention will create devices and service objects which are arranged into a desired hierarchy, as described in the UPnP description document . Consequently, once the devices and services are arranged in the pre-determined hierarchy, a final device object tree (DOT) object  is created. This DOT object  will provide representation of the device description document, or DCP document , that is finally registered with the UPnP SDK .","As such, in the embodiment described, the registration function in the UDCL  requires a DOT object. Consequently, the first DOT object is passed in as a constructor and functions as a static device that sends advertisements and is searchable by a control point. It is possible to register more than one DOT object with the UDCL as a dynamic root device, but such root devices are not searchable. As a result, the dynamic nature of the devices and services enabled by the present invention allows the hierarchy of devices and services to be changed at any time. In other words, any device or services can either be added or removed from a device object tree . These features provide an added flexibility that can change the device behavior during run-time. However, services in the embodiment described are to be derived from the CRootService class  in order to be added into the device object tree.","In a further embodiment, the UPnP event listener class  performs UPnP initialization registration and event handling for the device application. As such, CEventListener class  registers its own call-back function with the UPnP SDK , which receives all action and events for the device. CEventListener  is derived from CDeviceManager , which manages all static and dynamic root device objects, while CDevice  represents a root device or its embedded device class. Any device (either a root device, or an embedded device of the root device tree) can be registered with a CEventListener . Accordingly, the UDCL  provides the flexibility to modify the Device Object Tree (DOT) and depending on the application specific needs, the device developer either can register the complete DOT object or a portion of the devices within DOT object.","As described herein, a device with root device properties is referred to as a device object tree (DOT), which can be added to the root device table. In this embodiment, CRootService  works as a base class for all services generated by the UDT . CRootService  also implements operating system dependent data conversion routines and assists the UDT  in generating the operating system independent code for the service control classes . In addition, service classes derived from CRootService  require implementation of virtual callback methods declared in CRootService . CRootService  also stores information related to the service control classes in addition to the device identification and service identification of each respective class.","Finally, CEvent  is used as an object parameter to retrieve the response or error string back to the CEventListener class . In one embodiment, receiving an event from the client causes CEvent to create an object of the CEvent class and pass it as a parameter to the service callback function of CEventListener . Accordingly, the respective service control method executes a respective action in response to the event and sets the appropriate response or error string in the CEvent object. As such response to action or events is automatically provided by the UDCL .","Referring now to ,  depicts an embodiment illustrating response to events detected by the CEventListener class . As depicted, all UPnP related actions or events are dispatched to the CEventListener object  (Event listener ). Once received, the action or event  is passed along with any received parameters to its local callback function for execution. In addition, a new CEvent object  is also passed with each client request, which assists in transporting the application response back to the UDCL . In one embodiment, a CServiceManager (Device manager ) assists in finding the actual service object within the service object table (SOT)  based on the device ID and service ID. Once the correct service instance is found, its callback function is executed to complete processing in response to the received action or event. Based on the responsibilities of different modules, here is a grouping of tasks that are accomplished by individual modules or callback functions in one embodiment of the present invention:","Device Manager","Manages the root device table.\n\n","Service Manager\n\n","EventListener\n\n","Local Callback (EventListener)\n\n","Service Callback for Action\n\n","Method for Action\n\n","Service Callback for Subscription (No separate method for subscription)\n\n","Referring now to ,  depicts one embodiment of a device executable  including a device object tree  which includes a hierarchy of embedded devices and services. The executable  further includes a service object table  including the various services, as well as the event listener  and UPnP SDK . In addition, in the embodiment described, the control point  includes a universal control point class library (UCPCL) , the UPnP SDK  and the control point . As such, the CServiceLinker class  generated by the UDT  creates instances of services and devices during run-time.","Accordingly, once executed, these service objects are finally inserted into the device to create a desired hierarchy, as described by the UPnP device description document . As described above, each service is derived from CRootService , which includes three virtual callback methods, one for each action, subscription and state variable events. When the CEventListener  receives a UPnP event, it looks for the service callback that can accomplish this request or respond to the received event. CServiceManager  helps the CEventListener class in finding the correct service object within the service object table . Response to events is further illustrated with reference to .","Referring now to , an event flow diagram  is provided which illustrates response to events by an executed device executable generated in accordance with an embodiment of the present invention. CEventListener class  captures UPnP events on behalf of the services of a root device. Each time an action or event is received, an object of CEvent is created and passed back to the local callback function with any remaining parameters. The local callback function searches the SOT  and forwards the event or action packet to the appropriate service callback. Once the correct service object is discovered, the requested action and additional parameters are passed back to its callback function.","As described above, a callback function within the selected service object processes the respective action and looks for a method that can proceed with the current action. Each service implements a separate method for each action declared in their SCPDs . Accordingly, in the embodiment described, the responsibility of the local service callback is to parse the action string and separate out the parameters for any locally defined action methods. The abstracted parameters are then converted into their local type before being passed to the action method. Once converted, the locally defined service method then processes the action and sets any responses to the action within a CEvent object .","Referring now to ,  depicts an embodiment of an example of an organizer device  that includes three different services: calculator, clock and alarm. Service calculator contains four different actions: add, subtract, multiply and divide. As depicted, a control point is now interested in adding members remotely so he sends an Action Add to service calculator. Accordingly, the following steps are performed to create an organizer device.\n\n","In the embodiment described, it is assumed that service calculator clock and service alarm are derived from CRootService . Once these services are added under root device organizer, the root device can be registered with CEventListener  in order to receive events. As such, on the device side, CEventListener class  first receives the respective action request. This action is passed to the local callback function. Next, the service object table is searched to find the required service based on a received device ID and service ID . The CServiceManager  finds the service and returns its object through the CRootService parameter  as depicted at process block .","Once the required service is found, its callback function is called to process the action at process block , using the CServiceLinker . The calculator service callback functions then looks for the appropriate action method to execute in response to the incoming action. The service callback function parses this input XML and calls the appropriate action with locally converted parameters at process block . After the action is processed at block , the CEvent object  is set with the appropriate response string that is finally received by the control point at process block . In the case of an error during the action processing, the CEvent is set to return the appropriate error string.","Referring now to ,  depicts one embodiment of a UPnP device network . The UPnP device network  includes a control point  which searches the UTnP enabled devices (,  and ) and sends action and subscription requests to\/from the various devices. A UPnP enabled device  includes device executable -, generated in accordance with the embodiments of device executable  as illustrated in , which includes service-  and service- . An additional UPnP enabled device  includes device executable - (e.g., device executable  of ) including service  while UPnP enabled device  also includes a control point . In certain embodiments, the UPnP enabled device may include an internal control point, but this is not a requirement.","A final UPnP enabled device  includes root device , which includes embedded device , with service  and service . The root device also includes service . Each service generally includes a state table. However, conventional UPnP enabled devices require a control server and an event server in order to receive action events from the control point and respond to the action events using the control server. In contrast to conventional UPnP devices, control server and event server functionality are provided by the UPnP SDK  when the CEventListener class  registers with the UPnP SDK  to receive action and other requests.","Operation","Referring now to ,  depicts a method  for UPnP device code generation using XML, for example as depicted in . At process block , a UPnP device description document  is received from a device developer . In one embodiment, the UPnP device description document  is a device control protocol (DCP) description document, which includes links to one or more service control protocol description (SCPD) files . Once received, process block  is performed. At process block , a UDTool  generates one or more service control class files , including one or more service control stub-methods , which are collectively referred to as Universal Device Service (UDS) output code . At process block , the service control class files , including updated service control stub-methods as modified by device developer are received.","As described above, the device developer  is required to modify service control stub-methods  for each service listed within the device description document . As such, the device developer  will update the stub-methods  to generate updated stub-method  for responding to actions and events received by a UPnP device described by the UPnP device description document . Accordingly, the updated stub-methods , in addition to the service control class files , are recombined to form service control class file UDS output code . Finally, at process block , the service control class files and updated service control stub-methods , along with a device class library and a UPnP software developing kit (SDK) are compiled by compilation block  in order to generate a device executable  for the UPnP device.","Referring now to ,  depicts an additional method  for generation of the service control class files of process block  as depicted in . At process block , the UPnP device description document  is parsed to determine a root device including one or more services. In addition, the root device may include one or more embedded devices with each including one or more services. Each services of either the root device or the embedded devices is defined by a service control protocol description (SCPD) file. Once parsed, at process block , a tool  of the UDTool  generates a service control class file for each of the one or more services of the root device.","At process block , an embedded device from the one or more embedded devices of the root device is selected. Next, at process block , a service control class file for each of the one or more services of the selected embedded device is generated. At process block , process blocks  and  are repeated for each of the one or more embedded devices of the root device. Finally, once service control class files are generated for each of the services of the root device as well as each of the services of the embedded devices, process block  is performed. At process block , a class linker  generates a service linker class file based on each of the service control classes generated by the class generator . As described above, the service linker class file  enables linking of the service control classes during compilation at process block  to generate the device executable  in addition to cheating a DOT object at runtime.","Referring now to ,  depicts a block diagram illustrating a flow chart of an additional method  for generation of the service control class files for the root device at process block  , as depicted in . At process block , a service from the one or more services of the root device is selected. At process block , a class generator object is generated for the selected service of the root device. Next, at process block , an SCPD file  is passed to the class generator object, including a device ID of the root device and a service ID of the selected service. At process block , the class generator object  generates a service control class file based on the received SCPD file  and the service and device IDs. Next, at process block , the class generator object generates a header file corresponding to the generated service control class file. Once generated, at process block , the class generator object is destroyed. Finally, at process block , process blocks \u2013 are repeated for each of the one or more services of the root device.","Referring now to ,  depicts a flowchart illustrating an additional method  for generation of service control class files for a selected embedded device of process block , as depicted in . At process block , a service (embedded device service) from the one or more services of the selected embedded device is selected. At process , a class generator object is created for the selected embedded service device. Next, at process block , an SCPD file, including a device ID of the selected embedded device and a service ID of the selected service is passed to the class generator object.","Once the required parameters are received, process block  is performed. At process block , the class generator object generates a service control class file based on the received SCPD file, the service ID and the device ID and other parameters. At process block , the class generator object generates a header file corresponding to the generated service control class file. Once generated, at process block , the class generator object is destroyed. Finally, at process block , process blocks \u2013 are repeated for each of the one or more embedded device services of the selected embedded device.","Referring now to ,  depicts a flowchart illustrating an additional method  for generation of the service linker class file of process block , as depicted in . At process block , a class linker object is created by, for example, by the main class CDTool  (). At process block , class information regarding each generated service control class file is stored within a service table of the class linker object . At process block , the class object  generates the class linker file  based on the service table of the class linker object . Finally, at process block , the class linker object  is destroyed.","Referring now to ,  depicts a flowchart illustrating an additional method  for receipt of service control class files of process block , as depicted in . At process block , the UDTool  may display the one or more service control stub-methods  to the device developer . Next, at process block , the UDTool will receive code from the device developer for implementing the one or more service control stub-methods  in order to respond to actions and events received by the UPnP device. Finally, at process block , once the code is received, the UDTool  will store the received code within the one or more corresponding service control stub-methods in order to form the service control UDS output code .","However, in an alternative embodiment, once the UdTool  generates the service specific UDS class code , the role of UdTool  is over. In this embodiment, unmodified UDS output code  can be compiled and linked to create an executable for the device. Although the device can response to subscription, action and state variable requests, each action request returns a response as \u201cThis method is not implemented.\u201d Consequently, it is the responsibility of the developer to modify each stub-method  with code to send and implement a correct response. The device developer is required to write the implementation portion of the code, while the rest of the code, such as sending the action responses, event responses, etc., is automatically generated. In this embodiment, the UdTool generated UDS class code  is a text file that can be modified under any editor, and compiled and linked with any compiler depending on the type of code that UdTool  generated.","Referring now to ,  depicts a flowchart illustrating a method  for generating directory information and storing the UDS output code  generated by the UDTool . At process block , the UDTool  generates a root directory for the root device indicated in the device description document . Next, at process block , the UDTool  stores each of the one or more services of the root device within the root directory. Next, at process block , the UDTool  selects an embedded device from the one or more embedded devices of the root device. Once selected, at process block , the UDT  generates a stub-root directory for the selected embedded device. At process block , each of the one or more services of the selected embedded device are stored within the embedded device sub-root directory. Finally, at process block , process blocks \u2013 are repeated for each of the one or more embedded devices of the root device and any embedded device of each embedded device.","Referring now to ,  depicts a method  for execution of the device executable  in accordance with a further embodiment of the present invention as depicted in . At process block , the device executable  is executed. At process block , an instance of the root device, as well as each of the one or more services of the root device, is created. Next, at process block , an instance of each embedded device and each of the one or more services of the respective embedded device is created. Once created, process block  is performed. At process block , the root device and embedded devices, as well as the services of both the root device and the embedded devices, are organized within a device hierarchy based on the device description documents to form a DOT object, for example the DOT object  tree-based hierarchy as depicted with reference to .","Once the DOT object is created at process block , it is registered with CEventListener class  of the UDCL . If the registration is successful, each service listed in this DOT object is places into a SOT. In one embodiment, each device executable  creates a single object of the CEventListener class  that in turn creates a CDeviceManager object  and CServiceManager object . Accordingly, ServiceObject Table (SOT) is created and initialized with the creation of the CServiceManager object whereas a Root Device Table (RDT) is created with CDeviceManager. As such, the SOT keeps the instances of the root\/embedded device services whereas the RDT keeps track of all registered root devices. (It is possible to register more than one rood device with the UDCL ).","Accordingly, at process block , the DOT object is registered with the CEventListener class . As a result, a service object table (SOT) will list each service, a service identification code of the service and a device identification code corresponding to a parent device of the service. In addition, each service class instance is linked to a corresponding entry in the service object table . Consequently, each device within the DOT that is registered with the UDCL is enabled for receipt of events from one or more services of the respective device. Finally, at process block , the CEventListener class  is registered with the UPnP software development kit  in order to receive action\/event requests from one or more control points, which are provided to registered services of the DOT object.","Finally, referring now to ,  depicts an additional method  for responding to UPnP action events, for example as depicted with reference to . At process block , the root device and one or more embedded devices of the DOT object are registered with an event listener object . The event listener object is registered with the UPnP SDK  in order to receive action\/event request from one or more control points of the UPnP device. At process block , the event listener object  receives an action event request, for example, from a control point . At process block , the action  is passed to a local callback function of the event listener object . Next, at process block , a service object table (SOT)  of the root device DOT object  is searched to find a service object based on a device ID and service ID. Once the service object is found, process block  is performed.","At process block , once the service object is determined, the service object callback function looks for an appropriate action method for execution in response to the incoming action event . Next, at process block  the action method is executed by parsing an input XML file in order to perform the action method in response to the action request. Once executed, at process block , an event object is provided with a response string, which is eventually provided to the control point . Finally, process blocks \u2013 are repeated until the device executable  is shutdown.","Class Libraries","The following describes one embodiment of the various classes and class functions utilized by the present invention. However, those skilled in the art will appreciate that the present invention is not limited to the following classes and functions. In addition, the following does not provide an exhaustive list of classes and functions to perform the teachings of the present invention.",{"@attributes":{"id":"p-0094","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["METHODS","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"UDT Class Library"},{"entry":["GetScpdFileName","Retrieves service description file name (SCPD) from SCPD"]},{"entry":[{},"URL string."]},{"entry":["GetDeviceName","Extract the device type parameter from urn string."]},{"entry":["GetServiceName","Retrieves the service type parameter from urn string."]},{"entry":["GetNextUniqName","Creates a unique name string."]},{"entry":["RetrieveFileName","Separates out the filename from its path string."]},{"entry":["AddSrcFile","Creates a complete file name by adding the current working"]},{"entry":[{},"directory in to it."]},{"entry":["GetParentDir","Chops off the one level of leaf child directory from the path"]},{"entry":[{},"string."]},{"entry":["ProcessDeviceNode","It parses a device node and generates code for all the services"]},{"entry":[{},"declared in it."]},{"entry":["ProcessService","It parses the service node and generates service class files"]},{"entry":[{},"including service linking info."]},{"entry":["CreateMakefile","Creates makefile for the Linux build."]},{"entry":["SetProjectEnv","It setup a build environment for the generated source codes"]},{"entry":[{},"such as include, library project, etc."]},{"entry":["SetupDir","This method prepares a list of source file that will participate"]},{"entry":[{},"in device build."]},{"entry":["CreateDevice","This method parses the description document and sequences"]},{"entry":[{},"other method to create service class files and makefile"]},{"entry":[{},"required for the complete device."]},{"entry":["DevDescriptionFile","File name for device description document."]},{"entry":["SourceDir","Source directory name that contains all the input XML files."]},{"entry":["RootWorkingDir","Complete directory name, where UDT started."]},{"entry":["FileNameList","Source file list, generated by UdTool."]},{"entry":["NumFile","Count of source files in the FileNameList."]},{"entry":["LinkerObj","UdTool class passes the service information to this (CLinker)"]},{"entry":[{},"Class that finally generates ServiceLinker class."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CClassGenerator"},{"entry":["GetNodeValue","Retrieves the node value from description document."]},{"entry":["GetLocalVarType","Returns a local variable type for the XML defined"]},{"entry":[{},"variable type."]},{"entry":["GetParamType","Return a local parameter type for the action argument."]},{"entry":["GetParamConvFn","Returns the conversion function name. This is used"]},{"entry":[{},"for converting the action formal parameter to its local"]},{"entry":[{},"argument type."]},{"entry":["ParseVar","This method retrieves all the attribute value attached"]},{"entry":[{},"with the evented variable."]},{"entry":["ParseAction","It parses each action node and fills the action list."]},{"entry":["CreateActionList","Creates an action List."]},{"entry":["LocateIncDir","It converts the absolute directory path to a relative"]},{"entry":[{},"path."]},{"entry":["AddIncludeFileDecl","Adds include file declaration in the generated class"]},{"entry":[{},"file."]},{"entry":["AddClassDecl","Adds class declaration in the class header file."]},{"entry":["CreateHeaderFile","Generate header file"]},{"entry":["ImplementActionCallback","Generates code for callback function that processes all"]},{"entry":[{},"the incoming action for that service."]},{"entry":["ImplementSubscriptionCallback","Generates code for callback function that processes"]},{"entry":[{},"subscription request for that service."]},{"entry":["ImplementStateVarCallback","Generates code for callback function that processes"]},{"entry":[{},"state variable query request for that service."]},{"entry":["CreateImplementationFile","Generate implementation file (CPP file)."]},{"entry":["AddServiceDescription","Initializes this class (CClassGenerator) object with the"]},{"entry":[{},"given service info."]},{"entry":["GenerateServiceClass","Generates the complete service class including class"]},{"entry":[{},"file and its header file."]},{"entry":["ServiceClassName","Class name for this service class."]},{"entry":["SCPDFileName","SCPD file name for this service class."]},{"entry":["StateVarList","Evented variable list."]},{"entry":["NumStateVar","Number of state variable in the list."]},{"entry":["ActionList","List of action, where each action is defined as name"]},{"entry":[{},"of the action with its parameter list."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHODS","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CLinker"},{"entry":["GenerateLinkerDecl","Create header file for ServiceLinker class."]},{"entry":["GenerateLinkerImpl","Create implementation file for ServiceLinker class."]},{"entry":["AddService","Adds service information in the ServiceList."]},{"entry":["GenerateServiceLinker","Create ServiceLinker class file."]},{"entry":["ServiceList","Service Table."]},{"entry":["NewNumService","Number of services in the ServiceList."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CUtil"},{"entry":["GetDocNodeValue","Retrieves the value of node from UPnP document node."]},{"entry":["GetEleNodeValue","Retrieves the value of node from UPnP element node."]},{"entry":["GetPort","Extract port number from device description document."]},{"entry":["GetCurrentDirectory","The current working directory name for this process."]},{"entry":["ChangeDirToParentDir","Current working directory is set to its parent directory."]},{"entry":["SetCurrentDirectory","Process current working directory is changed to the value"]},{"entry":[{},"given in the input parameter."]},{"entry":["CreateDirectory","Creates a new directory inside the current working directory."]},{"entry":["CopyFile","Content of file source file is copied to the destination file."]},{"entry":["CopyDir","Content of source directory is copied to destination directory."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"UDCL CLASS LIBRARY"},{"entry":"CrootService"},{"entry":["UpnpMakeResponse","Creates an action response packet."]},{"entry":["GetDeviceId","Returns device UUID."]},{"entry":["GetServiceId","Returns service ID"]},{"entry":["GetServiceType","Returns Service Type."]},{"entry":["GetEvtUrl","Returns URL for subscription."]},{"entry":["GetScpd","Returns service description file name."]},{"entry":["GetCtrlUrl","Returns URL to send action."]},{"entry":["GetNodeValue","Retrieves the value of the node \u201cNodeName\u201d from"]},{"entry":[{},"description document."]},{"entry":["SendEvent","Send gena event to the subscribed client."]},{"entry":["itoa","Convert integer to string value."]},{"entry":["StrStr","Does string comparison after removing the space char"]},{"entry":[{},"from \u201cDestStr\u201d"]},{"entry":["ToUint","Convert string to unsigned int"]},{"entry":["ToUchar","Convert string to unsigned char"]},{"entry":["ToUshort","Convert string to unsigned short"]},{"entry":["ToInt","Convert string to integer"]},{"entry":["ToChar","Convert string to char"]},{"entry":["ToDouble","Convert string to double"]},{"entry":["ToShort","Convert string to short"]},{"entry":["ToFloat","Convert string to float"]},{"entry":["ToBool","Convert string to bool"]},{"entry":["ToString","Overloaded function that converts the different native"]},{"entry":[{},"data types to string."]},{"entry":["CloneVar","CloneVar is a similar function like ToString (\u2009) but it"]},{"entry":[{},"returns a new copy of string that contains the value of"]},{"entry":[{},"the input variable. This function is also overloaded to"]},{"entry":[{},"accept value as different data types."]},{"entry":["SetHandle","Sets the device handle"]},{"entry":["ServiceCallback","Interface callback function that will receive action"]},{"entry":[{},"request for ServiceLinker."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CEvent"},{"entry":["SetResp","After the service finishes executing the action, this"]},{"entry":[{},"method sets the action response in this class object. The"]},{"entry":[{},"same response packet is finally sent to the control"]},{"entry":[{},"point."]},{"entry":["SetStateVariable","Sets the value of queried state variable."]},{"entry":["GetStateVariable","Returns the value of queried state variable."]},{"entry":["GetResp","Retrieves the response of the action sent by service."]},{"entry":["SetErr","During action execution, service uses this function to"]},{"entry":[{},"return error."]},{"entry":["GetErr","Retrieves error of the last action execution."]},{"entry":["RespDoc","Stores the response of the action."]},{"entry":["StVar","Used to store the value of queried state variable."]},{"entry":["ErrStr","Stores error string of the last action execution."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHODS","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CDevice"},{"entry":["GetNextDevice","Returns the next child embedded device in the"]},{"entry":[{},"device tree."]},{"entry":["GetFirstService","Returns the first service from the device's"]},{"entry":[{},"service list."]},{"entry":["GetDeviceId","Returns device UUID."]},{"entry":["GetDeviceType","Returns device type."]},{"entry":["GetFriendlyName","Returns friendly name."]},{"entry":["GetManufacturer","Returns manufacturer information."]},{"entry":["GetManufacturerUrl","Returns manufacturer URL."]},{"entry":["GetModelDescription","Returns model description."]},{"entry":["GetModelName","Returns model name."]},{"entry":["GetModelNumber","Returns model number."]},{"entry":["GetModelUrl","Returns model URL."]},{"entry":["GetSerialNumber","Returns serial number."]},{"entry":["GetUpc","Returns Upc."]},{"entry":["ProcessDevice","Private method, process the device tree."]},{"entry":["GenerateDeviceDescription","Creates device description file (DCP)."]},{"entry":["InsertDevice","Insert embedded device."]},{"entry":["InsertService","Insert service."]},{"entry":["SetProperties","Set device properties by copying info from some"]},{"entry":[{},"other device."]},{"entry":["SetDeviceInfo","Set device Id and type information."]},{"entry":["DelistService","Just remove service from the device tree."]},{"entry":["RemoveService","Remove Service without deleting its object."]},{"entry":["DeleteService","Remove Service by deleting its object."]},{"entry":["DeviceCleanup","Delete all child sub-device and service."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CEventListener"},{"entry":["GetLocalHostname","Finds out the local IP address for default"]},{"entry":[{},"interface."]},{"entry":["GetPortNo","Retrieves Port number from device description"]},{"entry":[{},"document."]},{"entry":["GetNodeValue","Retrieves node value from XML document"]},{"entry":[{},"node."]},{"entry":["ServiceCallback","Common service callback for action handling."]},{"entry":["AcceptSubscription","Accepts subscription request for the subscribed"]},{"entry":[{},"client."]},{"entry":["MainCallback","This method receives every action and event"]},{"entry":[{},"that is sent for the any services of device. This"]},{"entry":[{},"is a listener callback function registered with"]},{"entry":[{},"Intel's UPnP SDK."]},{"entry":["GetService","Return instance of the service, identified by"]},{"entry":[{},"DevId and ServId."]},{"entry":["SetDescription","Sets description file name for the device."]},{"entry":["Listen","Start listening for the control point request"]},{"entry":[{},"(action or event)."]},{"entry":["ServiceManager","Stores instances of the service including device"]},{"entry":[{},"ID and service ID."]},{"entry":["DescDocName","Device description file name."]},{"entry":["DescDocPath","Location of Device description file."]},{"entry":["DevHandle","This variable stores the device handle, returned"]},{"entry":[{},"after the registration with UPnP SDK."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CDeviceManager"},{"entry":["AddDeviceInRDT","Adds a device in the Root Device Table (RDT)."]},{"entry":["RemoveDeviceFromRDT","Removes a device from the Root Device Table"]},{"entry":[{},"(RDT)."]},{"entry":["DevHandle","Device registration handle that we get after"]},{"entry":[{},"registration with UPnP SDK."]},{"entry":["DeviceList","List of all the root devices registered in UDCL."]},{"entry":["DescDocPath","Location of description document (DCP)."]},{"entry":["UpnpDeviceIp","The IP address on which device is listening for the"]},{"entry":[{},"client request."]},{"entry":["UpnpDevicePort","The port number on which device is listening for"]},{"entry":[{},"the client request."]},{"entry":["StartDevice","Start a new root device."]},{"entry":["StopDevice","Stop a registered root device."]},{"entry":["FindDevice","Find a device based on its device ID."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CServiceManager"},{"entry":["AddService","Adds a new service in its Service Object Table"]},{"entry":[{},"(SOT)."]},{"entry":["RemoveService","Remove a registered service from its Service"]},{"entry":[{},"Object Table (SOT)."]},{"entry":["AddDeviceInSOT","Takes a device object as a parameter and add all the"]},{"entry":[{},"service found in this device tree."]},{"entry":["RemoveDeviceFromSOT","Takes a device object as a parameter and removes"]},{"entry":[{},"all the service found in this device tree."]},{"entry":["FindService","Returns a registered service object based on the"]},{"entry":[{},"device Id and Service Id."]},{"entry":["ServiceList","List of registered services. It is also called Service"]},{"entry":[{},"Object Table."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"CList"},{"entry":["AddNode","Adds a new node in to the linked list."]},{"entry":["DeleteNode","Finds and deletes a node from the linked list."]},{"entry":["RemoveNode","Deletes a node and free the memory for its member"]},{"entry":[{},"data."]},{"entry":["NodeList","Head of the linked list."]},{"entry":["DeleteNextNode","Deletes a node, next to the input node."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["METHOD","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"Application Common class"},{"entry":"CServiceLinker"},{"entry":["CServiceLinker","Does initialization kind of job. Creates a root device"]},{"entry":[{},"and register it with the UDCL."]},{"entry":["~CServiceLinker","Un-registers the root device and shutdown the UDCL."]},{"entry":["CreateRootDevice","Creates an instance of a root device."]},{"entry":["DevHandle","Device handle returned after registration with UDCL."]},{"entry":["RootDev","Instances of root device stored in this member variable."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Several aspects of one implementation of an apparatus and method for providing UPnP device code generation have been described. However, various implementations of the UDTool and the UDCL provide numerous features including, complementing, supplementing, and\/or replacing the features described above. Features can be implemented as part of one or more class libraries or as part of a single class library in different implementations. In addition, the foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention. However, it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention.","In addition, although an embodiment described herein is directed to UPnP device code generation, it will be appreciated by those skilled in the art that the teaching of the present invention can be applied to other systems. In fact, systems for actions or event based responses are within the teachings of the present invention, without departing from the scope and spirit of the present invention. The embodiments described above were chosen and described in order to best explain the principles of the invention and its practical applications. These embodiment were chosen to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated.","It is to be understood that even though numerous characteristics and advantages of various embodiments of the present invention have been set forth in the foregoing description, together with details of the structure and function of various embodiments of the invention, this disclosure is illustrative only. In some cases, certain subassemblies are only described in detail with one such embodiment. Nevertheless, it is recognized and intended that such subassemblies may be used in other embodiments of the invention. Changes may be made in detail, especially matters of structure and management of parts within the principles of the present invention to the full extent indicated by the broad general meaning of the terms in which the appended claims are expressed.","The present invention provides many advantages over known techniques. The present invention includes the ability to provide a time and cost effective solution for developing UPnP devices. This process eliminates many stages of the software development cycle, and hence, effectively reduces the development time up to 75%. It also provides other hidden advantages, including uniform coding style, that will prove useful in understanding and maintaining the code. In addition, the present invention provides operating system independent code, which is tested and optimized. The universal device tool, as taught by the present invention, generates code on a pre-designed model of a UPnP device framework that eliminates a major portion of design time in a software development process. Most of the code generated by this tool is already tested. In addition, most of the UPnP core processing is performed by the universal device class library module, which is also tested and optimized. Accordingly, the present invention eliminates the cumbersome process resulting for traditional development of UPnP devices and allow the device developer to focus their attention on application-specific problems instead of worrying about UPnP.","Having disclosed exemplary embodiments and the best mode, modifications and variations may be made to the disclosed embodiments while remaining within the scope of the invention as defined by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4C","FIG. 4B"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
