---
title: Optimizing memory management of an application running on a virtual machine
abstract: A method, system and computer program product for optimizing memory usage of an application running on a virtual machine. A virtual machine memory block is pre-allocated and the average memory usage of the virtual machine is periodically computed using statistics collected from the virtual machine through an API. If the memory usage average becomes higher than a maximum threshold, then a recovery mode is entered by releasing the virtual machine memory block and forcing the running application to reduce its processing activity; optionally, a garbage collector cycle can be forced. If the computed memory usage average becomes lower than a minimum threshold value, which is lower than the maximum threshold value, then a normal mode is entered by re-allocating the virtual machine memory block and forcing the running application to resumes its normal processing activity. Optionally, when the virtual machine is idle, a deep garbage collection is forced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08886866&OS=08886866&RS=08886866
owner: International Business Machines Corporation
number: 08886866
owner_city: Armonk
owner_country: US
publication_date: 20111107
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority under 35 U.S.C. \u00a7119(a) from European Patent Application No. 10193128.5, filed on Nov. 30, 2010, the contents of which are incorporated herein by reference.","The present invention relates to applications executed in a virtual machine, such as an application developed in Java\u00ae (Java and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and\/or its affiliates) language and executing in a Java\u00ae virtual machine, and more particularly, to improving memory management of applications running in a virtual machine.","An application running in a virtual machine may encounter several kinds of severe conditions that may come from over use of computing resources, and, in particular, of memory. If the amount of memory used by an application exceeds the memory allocated to the virtual machine, or, if the virtual machine, or, if the system, hosting the virtual machine exceeds the available memory, this can result in an \u201cout of memory\u201d exception making the application or the virtual machine to crash. A crash may be detrimental for enterprise applications stopped during production hours or if the application in question manages and controls computing activity over multiple locations of the same enterprise. Some applications may be able to catch the \u201cout of memory\u201d exception event from the virtual machine and include code for recovery. Recovery code is very difficult to write because it depends upon when the event occurs and at which place in the application code. Furthermore, running recovery code upon an out of memory exception may require additional memory resources which may not be available to the application at this point.","Most techniques try to manage these situations by pre-allocating a certain amount of memory at the application start-up and releasing it when an out of memory condition occurs to allow the system to be able to accomplish a recovery action. The main drawback of such techniques is that they are reactive. The operation that gets interrupted because of the out of memory error may not be easily recoverable and may leave data inconsistencies if the recovery handler code is not \u201cnear\u201d enough to the code that threw the exception. Additionally, trying a recovery action after an out of memory error may be too late for certain kinds of applications.","A standard way to prevent out of memory exceptions is to use a garbage collection mechanism for detecting and freeing memory which is no longer in use. A garbage collector program (GC) running on a virtual machine which provides an application programming interface (API) to be monitored is activated each time a predefined percentage of memory is in use. Once activated, the garbage collector program reclaims memory no longer needed by a given application running on the virtual machine. One advantage is that the garbage collection relieves programmers from freeing allocated memory in the application code. One disadvantage of a garbage collector to be taken into account for optimizing memory usage of an application running on a virtual machine is that its execution adds an overhead that can affect the executing application. The garbage collection activity requires more CPU time than would have been required if the application explicitly itself freed unnecessary memory. Finally, garbage collection algorithms may be very sophisticated to avoid the drawbacks and may not only be able to free some memory space for one application but also be able to de-fragment the memory space for the virtual machine. The freeing of memory and de-fragmenting are different functions of the garbage collector which are both provided because de-fragmenting the memory is usually required for having larger blocks of free memory. De-fragmenting is not done in general at each garbage collector cycle but each time the garbage collector decides it is necessary.","Besides the out of memory exceptions, the memory leak condition for a virtual machine is detected, which is a loss of memory available over time. Detecting the memory leaks allow predicting when an out of memory exception is likely to occur. This solution can be used to test if the applications running on the virtual machine will correctly release memory after it has been used. Once again, the remedies to avoid memory leak or out of memory exceptions are just advising the administrator or stopping a process running on the virtual machine.","Finally, low memory conditions are generally very disruptive for the application functionality. Under low memory conditions, the application performances usually degrade a lot because of the increased garbage collector activity. When a virtual machine is running near its upper memory limit, most of the CPU time is spent on the garbage collector activity instead of application processing. So it should be avoided as much as possible to have an application running in such conditions.","Hence, memory usage of an application running on a virtual machine needs to be dynamically optimized while minimizing the drawbacks discussed above.","In one embodiment of the present invention, a method for optimizing memory usage of an application running on a virtual machine, the virtual machine providing a monitoring application programming interface (API) to communicate with the virtual machine and the virtual machine including a garbage collector, the method comprises self-allocating a virtual machine memory block. The method further comprises periodically collecting and storing virtual machine memory usage statistics. Additionally, the method comprises periodically computing an average virtual machine memory usage from the memory usage statistics in a time window. Furthermore, the method comprises entering into a recovery mode by releasing the virtual machine memory block and forcing the running application to reduce its processing activity in response to the computed virtual machine memory usage average becoming higher than a first threshold. In addition, the method comprises entering, by a processor, into a normal mode by re-self-allocating the virtual machine memory block and forcing the running application to resume its normal processing activity in response to the computed memory usage average becoming lower than a second threshold.","Other forms of the embodiment of the method described above are in a system and in a computer program product.","The foregoing has outlined rather generally the features and technical advantages of one or more embodiments of the present invention in order that the detailed description of the present invention that follows may be better understood. Additional features and advantages of the present invention will be described hereinafter which may form the subject of the claims of the present invention.","The principles of the present invention disclose a pro-active system that continuously monitors the available memory and the garbage collector activity for an application running on a virtual machine including a garbage collector function and providing an application programming interface (API) for computing resource monitoring. One advantage of the present invention is that the system not only detects that the virtual machine reaches a low memory condition but also takes appropriate corrective actions to prevent the system from reaching and exceeding its limits.","To achieve this goal, the principles of the present invention take advantage of the period when the virtual machine is \u201cidle\u201d to start garbage collection activity. Also, the system detects a low memory condition when the garbage collector activity is increasing for a certain amount of time while the available free memory is continuously decreasing under a certain threshold; it notifies the application, which initiates a set of activities aimed at reducing the overall processing activities upon receiving such notification. A \u201chedge technique\u201d is used by pre-allocating, at the application start-up, a certain amount of memory to be released and used in case a recovery action is required: when the application is notified of a low memory condition, the system releases the memory allocated at startup and forces a recovery action from the application. The system also notifies the application in case the available free memory comes back and re-exceeds a specified threshold. Upon receiving such notification, the application code resumes its normal activities and the system additionally, re-allocates the memory which was previously released.","By combining the release of memory allocated to the application at start-up time to the application activity reduction, the garbage collector will benefit of a larger amount of free memory to optionally de-fragment the system memory space and the application may execute the activity reduction with a larger amount of free memory, thus avoiding an out of memory exception.","Referring now to the drawings,  illustrates the system environment for optimizing the memory usage of a Java\u00ae application according to an embodiment of the present invention.  illustrates one common example of a virtual machine, which is a Java\u00ae virtual machine (JVM)  operating on a computer (discussed further below in connection with ). The JVM runtime  executes bytecodes, compiled Java language code, on said computer of a Java\u00ae language compiled application . Java\u00ae virtual machine  comprises a garbage collector (included, not represented in ) and provides an API for monitoring computing resources, and more particularly, memory and CPU as well as the activity of the garbage collector, which allow implementation of the application memory usage optimization.","The new components which are part of the embodiment of the present invention are computer programs respectively executing JVM computing resource monitoring (JVM monitoring agent ) and memory optimization (memory optimizer ). It is noted that these two components performing the memory optimization process can be located outside the virtual machine in a remote server and can be connected to the virtual machine through the network. Two pieces of code (, ) in the application are used to implement notifications by memory optimizer  and for reducing\/restoring the application activity in case of a notification of low memory by memory optimizer  as described hereunder in reference to the description of the next Figures.","It is noted that this illustration of the system environment comprises only one Java application: this is the most common pattern having one application running on a virtual machine. As a matter of fact, running more than one application on the same virtual machine may have several drawbacks in the context of fail over and tolerance. This architecture applies also particularly to the type of applications supporting no unexpected interruption as running in production mode in an enterprise or implementing, for instance, a constant management and control of systems over enterprise locations. These applications have been modified (, ) according to an embodiment of the present invention to support the memory management optimization.","By the way, because the garbage collector is part of the virtual machine and does not distinguish between the memory allocated by one application and by another one, when the memory is freed, it is done not at the level of one application but at the level of the entire virtual machine. More generally, the VM monitoring is made at the level of the entire virtual machine. Consequently, in the case where there is more than one application running on a virtual machine, the system to optimize memory management may be implemented but its effectiveness is reduced. For instance, all the applications running on JVM  may be enabled to interact with memory optimizer component : they will receive the low memory notifications and will take appropriate actions to reduce memory usage. One other option would be to enable only one set of applications for receiving notifications from memory optimizer .","JVM monitoring agent  collects the statistics () (e.g., garbage collector activity, memory, CPU usage, etc.) required by optimizer  (memory optimizer  gets the statistics ) for its internal processing. In the modern JVM runtimes, it may retrieve such data using the Java\u00ae Management Extensions (JMX) management interface that almost all the vendors provide. Memory optimizer  is the engine that analyzes and processes the data received from monitoring agent  and that, according to its configuration, decides about the corrective actions to be taken for maintaining the availability of the monitored application via notifications to the application () and releasing to JVM  of the pre-allocated memory block. Memory optimizer  can also force the garbage collector to execute a garbage collector cycle () when JVM  is idle to anticipate future use of the memory by the application. Forcing a garbage collector cycle in this circumstance is optional because it may be not necessary.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["200","200"]},"Referring to , in conjunction with , in step , a new Java\u00ae application for which the memory usage will be optimized according to one embodiment gets started along with memory optimizer engine  and JVM monitoring agent . As soon as memory optimizer engine  gets started, in step , it pre-allocates a certain configurable amount of memory to be used during the \u201crecovery\u201d phases. The size of the pre-allocated block of memory may be a configurable parameter of memory optimizer , the value depending on the particular application and system context. The parameter value may be decided by the system administrator upon his\/her experience of the computing environment.","In step , the application executes the code for requesting to be notified by memory optimizer engine  about \u201clow memory\u201d conditions: in one embodiment, the application registers a callback notification object to memory optimizer engine  to be notified. Callback is the typical way of sending notifications between two programs.","In step , the JVM monitoring engine , at regular time intervals, contacts the JVM using the JVM monitoring API to collect metrics about the available\/used memory, the JVM garbage collector activity and the process CPU usage; these data are periodically provided by JVM monitoring engine  to memory optimizer . There are many possibilities for implementing this process of collecting data as well known in the art. For instance, memory optimizer  at regular intervals may ask monitoring agent  to retrieve JVM metrics. Another possibility could be that monitoring agent , independently from memory optimizer , periodically gets the JVM parameters and send them back to optimizer  through a notification mechanism. Memory optimizer  when getting these statistics stores them in its internal historical repository. A separate thread into memory optimizer  at regular intervals, in general different from the time intervals used by JVM monitoring agent  to send the data, infers the resource utilization (e.g., memory, CPU and garbage collector (GC) activity) from a historical analysis of the memory and GC metrics: it calculates in step  the average values for those parameters using an evaluation window that starts from the current timestamp and goes back in time up to a pre-defined configurable limit, as discussed later herein in connection with the description of .","In step , a determination is made as to whether the JVM is in \u201cnormal mode.\u201d When the application stars running, the JVM is in normal mode. A JVM state indicator (a programming variable for instance) can be set by memory optimizer  to a certain value representing \u201cnormal mode.\u201d If the JVM is in \u201cnormal mode,\u201d then a determination is made in step  as to whether the memory usage exceeds a threshold. If memory optimizer  detects that the calculated average \u201cused\u201d memory exceeds a pre-defined threshold, Th, then, at this point, the JVM enters into a \u201crecovery mode\u201d in step . The JVM state indicator is set to \u201crecovery mode\u201d corresponding to a certain value.","It is noted that the average memory usage can also be satisfying and that no action is started if the calculated average \u201cused\u201d memory does not exceed the Th threshold; in this case, the process goes back to collecting and storing JVM metrics in step .","When switching to recovery mode in step , memory optimizer  releases the pre-allocated memory block in step  to the runtime environment; the memory optimizer  also triggers a notification in step  of low memory condition to the running application by means of the registered callback object. The process then goes back to collecting and storing JVM metrics in step .","Upon receiving the \u201clow memory\u201d condition notification, the application starts a set of \u201crecovery\u201d actions aimed at reducing its internal processing activities until the low memory condition get normalized.","Memory optimizer  has released the pre-allocated memory to JVM  to help the application to perform the activity reduction and to help the garbage collector action of freeing memory. Additionally, memory optimizer , as recovery action, may force a garbage collector cycle in JVM  if it appears necessary.","Referring to step , if JVM  is not operating in \u201cnormal mode,\u201d then JVM  is still in \u2018Recovery mode\u2019 (answer No to step ) and the efficiencies of the recovery actions are tested. In step , a determination is made as to whether the memory usage descended below a threshold, Th. If the memory usage is not below a threshold, Th, then, the process goes back to collecting and storing JVM metrics in step .","A certain number of measurement periods may be necessary, but when, after a certain number of loops, the average \u201cused\u201d memory finally descends below the alert threshold Th, then JVM  returns to \u201cnormal mode\u201d in step , where memory optimizer  sets the JVM state indicator to normal mode. In step , memory optimizer  re-allocates the memory block for preparing the next recovery in case a low memory condition occurs; it also sends a notification in step  to the running application that the mode is back to the normal situation. The use of the two thresholds implements a sort of hysteresis mechanism to avoid immediately reacting when small oscillations of the memory usage occur around the configured limit. The process then goes back to collecting and storing JVM metrics in step .","Upon receiving the notification that JVM  is now in normal mode, the application resumes its normal internal processing activities until the low memory condition gets normalized.","As already mentioned before, the application includes some code for supporting the optimization of memory usage which includes code for receiving notifications from memory optimizer component  and code for reacting at reception of the notifications by reducing the application activity (e.g., reading, writing computing may use a lot of memory) or restoring its expected normal processing upon reception of a notification that the mode has returned to a normal situation sent by memory optimizer component .","In some implementations, method  may include other and\/or additional steps that, for clarity, are not depicted. Further, in some implementations, method  may be executed in a different order presented and that the order presented in the discussion of  is illustrative. Additionally, in some implementations, certain steps in method  may be executed in a substantially simultaneous manner or may be omitted.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 3","FIG. 2"],"b":["300","200","300","100"]},"Referring to , in conjunction with , asynchronously from the previous activities, memory optimizer  periodically collects JVM metrics in step  (through JVM monitoring agent ) and computes in step  an average of the CPU usage and garbage collector activity of the JVM in an evaluation window. In step , a determination is made as to whether JVM  is idle.","If JVM  is not idle, then memory optimizer  periodically collects JVM metrics in step . If, however, JVM  is almost idle (i.e., no garbage collector activity and low CPU usage), then, in step , it triggers a preventive garbage collector cycle to free as much unused memory as possible when it is not detrimental to application activity. The time interval for the check of idle periods is different from the one used to check the low memory conditions and in general it is represented by a larger value (i.e., this kind of check is performed less frequently than the one to check the memory usage). This specific preventive memory cleaning is optional that is not required in all cases. It mainly depends on how the garbage collector system has been implemented in the virtual machine. The detection of an idle period (i.e., no garbage collector activity and low CPU usage) may be tuned through the use of a memory optimizer parameter by the system administrator.","Upon triggering the garbage collector cycle, memory optimizer  collects JVM metrics in step .","In some implementations, method  may include other and\/or additional steps that, for clarity, are not depicted. Further, in some implementations, method  may be executed in a different order presented and that the order presented in the discussion of  is illustrative. Additionally, in some implementations, certain steps in method  may be executed in a substantially simultaneous manner or may be omitted.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4","FIG. 4","FIG. 1","FIG. 4"],"b":["400","410","420","2","430","2","430","450","130","460","460","130","2","430","460"]},"The recovering action triggered by memory optimizer  in case a low memory condition is detected consists of notifying the running application which will reduce its activity to decrease its CPU consumption and memory usage; also memory optimizer  releases the pre-allocated memory block for its use by JVM  and particularly by the garbage collector of JVM . The release of memory helps the garbage collector and the application to more safely and efficiently complete their tasks during the memory peak periods. These recovery actions achieve two goals:\n\n","As an additional proactive action, the optimizer  may periodically force a garbage collector cycle. This is not strictly needed and in some cases may not be necessary. For example, good garbage collectors may directly do this activity by themselves, while other ones do not do this.","When, in a next evaluation window , memory optimizer  computes that the average memory usage for the Java\u00ae application is under an alert threshold Th , it notifies the application which returns to normal activity. Additionally, memory optimizer  re-allocates the block of memory previously released.","The Th memory usage alert threshold value  is lower than the Th low memory condition threshold value , where Th and Th are determined by the experience of the system administrator.","Not illustrated in , the preventive action of memory optimizer  to optimize memory usage is for forcing deep garbage collection cycle during low CPU activity.","It is noted that the applications which have their memory usage managed by the method of the present invention have code included to interface with memory optimizer  (callback is the most usual way to implement notification between programs) and code to reduce activity (CPU and memory usage) and code to re-establish normal activity.","Compared to the existing solutions in the field for optimizing memory usage of applications running on a virtual machine providing a monitoring API and including a garbage collector, this system is pro-active and adds the following new elements:\n\n",{"@attributes":{"id":"p-0054","num":"0058"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["500","500","501","502","503","501","504","503","503","504","504"]},"Referring again to , read-only memory (\u201cROM\u201d)  may be coupled to system bus  and include a basic input\/output system (\u201cBIOS\u201d) that controls certain basic functions of computer system . Random access memory (\u201cRAM\u201d)  and disk adapter  may also be coupled to system bus . It should be noted that software components including operating system  and application  may be loaded into RAM , which may be computer system's  main memory for execution. Disk adapter  may be an integrated drive electronics (\u201cIDE\u201d) adapter that communicates with a disk unit , e.g., disk drive.","Computer system  may further include a communications adapter  coupled to bus . Communications adapter  may interconnect bus  with an outside network (not shown) thereby allowing computer system  to communicate with other similar devices.","I\/O devices may also be connected to computer system  via a user interface adapter  and a display adapter . Keyboard , mouse  and speaker  may all be interconnected to bus  through user interface adapter . A display monitor  may be connected to system bus  by display adapter . In this manner, a user is capable of inputting to computer system  through keyboard  or mouse  and receiving output from computer system  via display  or speaker .","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or flash memory), a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the C programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described above with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the present invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the function\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the function\/acts specified in the flowchart and\/or block diagram block or blocks.","The descriptions of the various embodiments of the present invention have been presented for purposes of illustration, but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments, the practical application or technical improvement over technologies found in the marketplace, or to enable others of ordinary skill in the art to understand the embodiments disclosed herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
