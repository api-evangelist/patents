---
title: Pattern-based construction and extension of enterprise applications in a cloud computing environment
abstract: Methods, software programs and systems for extending and modifying software functionality, and, more particularly, for using one or more patterns for an enterprise software object to express desired functionality and configuration, and to generate the enterprise software object using the patterns, in an enterprise environment are disclosed. A method according to certain of these embodiments includes selecting one or more patterns from a number of patterns, where the one or more patterns are for an enterprise software object. The enterprise software object can then be generated. The enterprise software object is generated using the one or more patterns. Each of the patterns is configured to describe a solution within a corresponding one of a number of problem domains.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09535663&OS=09535663&RS=09535663
owner: Oracle International Corporation
number: 09535663
owner_city: Redwood Shores
owner_country: US
publication_date: 20110919
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Other Embodiments"],"p":["This application claims the benefit under 35 U.S.C. \u00a7119 (e) of U.S. Provisional Application No. 61\/384,086, filed Sep. 17, 2010, entitled \u201cPattern-Based Construction and Extension of Enterprise Applications in a Cloud Computing Environment,\u201d and naming Rahim Mohamed Yaseen, John Liang, Yunhee Choi and Xiaomei Zhang as inventors. The above-referenced application is hereby incorporated by reference herein, in its entirety and for all purposes.","The present invention relates to extending and modifying software functionality, and, more particularly, to using one or more patterns for an enterprise software object to express desired functionality and configuration, and to generate the enterprise software object using the patterns, in an enterprise environment.","Reductions in the cost of computing coupled with virtualization and large-scale utility computing have resulted in ubiquitous computing resources and network connectivity, which has, in turn, resulted in new computing paradigms (e.g., cloud computing). Such Internet-scale computing resources can reduce the cost of operations for many applications. Cloud computing further provides a foundation for collaborative applications and a target for mobile platforms. Cloud computing is based on a scalable server platform suitable for handling computing loads of highly interactive collaborative applications, such as social applications and cloud-based office applications.","As Internet-scale computing infrastructure becomes increasingly affordable to mass-paid services, cloud computing users will seek matching affordability in software resources. Cloud computing resources can provide platform-as-a-service (PaaS) products, including software and product development tools hosted within the cloud infrastructure. Alternatively, software-as-a-service (SaaS) cloud models include software products interacting with users through a front-end portal. In such environments, users will desire software functionality in an affordable price range. Such users may be, for example, business users with limited training and\/or experience in software programming, if any at all. Notwithstanding, the need remains for enterprise customers of cloud resources to be able to configure software in a manner appropriate to their needs.","Historically, creation of software has been approached from the perspective of the computer. Most software is expressed through use of general purpose programming language. Thus, programs are focused on what is required of the computer (e.g., execution details), rather than the problems that the software is developed to address. Addressing changes to the problem or desired solution is thus effected by modifying the program's code. But the general purpose programming languages used to write software are just that\u2014general\u2014and so were not created to clearly express a specific problem to be solved. This makes writing such software, as well as making subsequent modifications (e.g., to reflect changes in the problem addressed thereby), a difficult task.","The people most familiar with the problem to be solved are those who use the software in their particular problem domain. Domain experts are familiar with the issues, concepts, and definitions that need to be satisfied in the problem domain. On the other hand, software programmers have expertise in software creation and, with the domain experts, traditionally work to generate software. This division of labor and expertise inevitably leads to frustration in one or both parties, as changes in program specifications and the complexity of the problem domain are understood by the domain expert, but cause numerous rewrites and revisions on the part of the programmer. Similarly, misunderstandings on the part of the programmer regarding the description provided by the domain expert can lead to frustration on the part of the domain expert.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1A","b":["105","110","110","115","105","110","110"]},"In order to have software mirror the domain expert's intentions for the software, it is preferable to express the problem in domain terms. This necessarily requires a second step that takes the problem description made in domain terms and transforms that description to a software that a computer can execute, that is, program generation. While a programmer can write code in a fashion that uses terminology familiar to the domain problems addressed by the software, such programming can prove difficult in large systems, with a domain having a complex vocabulary, and in other such circumstances.","In light of the foregoing, and to accommodate user's need for enterprise-class cloud programming facilities, it is therefore desirable to provide such users with application development environments that are (1) simple enough to be used by users lacking extensive programming training and\/or experience, and (2) sufficiently easy to customize, both to match the skills of such users and allow for efficient customization. Further, such application development environments should allow application customization to be performed in a manner that does not interfere with other users' access to the cloud resources involved (e.g., the application(s) being customized).","In various embodiments of the present invention, disclosed are methods, software programs and systems for extending and modifying software functionality, and, more particularly, for using one or more patterns for an enterprise software object to express desired functionality and configuration, and to generate the enterprise software object using the patterns, in an enterprise environment. A method according to certain of these embodiments includes selecting one or more patterns from a number of patterns, where the one or more patterns are for an enterprise software object. The enterprise software object can then be generated. The enterprise software object is generated using the one or more patterns. Each of the patterns is configured to describe a solution within a corresponding one of a number of problem domains.","The foregoing is a summary and thus contains, by necessity, simplifications, generalizations and omission of detail; consequently those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects, inventive features, and advantages of the present invention, as defined solely by the claims, will become apparent in the non-limiting detailed description set forth below.","Embodiments of the present invention provide a method, apparatus and system to construct application patterns using a generalized mechanism and to use those patterns to generate new or modified software objects. Such systems employ fundamental primitives and related operations to assemble simple patterns into semantic-rich patterns. Instantiated patterns (e.g., objects) can then be added to existing applications, thereby modifying those applications for purposes specific to an enterprise, for example. Embodiments of the present invention can further allow untrained users to extend applications (e.g., SaaS applications) using the pre-assembled patterns. Embodiments of the present invention also provide configuration tools for adding new software components to existing applications by accessing a repository of such patterns. Such configuration tools permit a user to select one or more patterns for an enterprise software object from the repository, provide parameter values appropriate for a particular instantiation of the patterns, and then, using those instantiated patterns, generate the enterprise software object.","Intentional Programming",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1B","b":["110","120","125","115","125","120","115","125","115","125","120"]},"Different applications of generative techniques can differ as to how a domain-specific language for domain code  is defined, how the domain code is created, and how generator program  uses the domain code. Use of generator program  separates concerns of domain experts from those of a programmer. In a generative software environment, a domain expert  is responsible for maintaining domain code . Generator program  is created and maintained by programmer  and defines how the domain code input should be processed to get an intended implementation (e.g., executable code ). Generator program  represents implementation knowledge such as engineering design, algorithm choices, platforms and code patterns.","Previous implementations of generative programming environments suffer from practical application issues, such as defining the language of domain code , who defines and supports the domain-specific language and documentation, issues related to problems spanning more than one domain, and access of generator program  to domain code  through an application programming interface and the like. Further, previous solutions for domain-specific languages do not solve problems related to having users with minimal programming knowledge creating and modifying software components in an enterprise in a straightforward and efficient manner. These previous solutions continue to require learning of the domain-specific language and its syntax by a user. For example, one domain-specific language implementation requires the use of an \u201cintentional tree,\u201d which is primarily theoretical and does not provide any sort of useful or practical solution for an enterprise. Other such solutions require knowledge of how to assemble different functional blocks in order to ensure proper interaction and functionality.","Enterprise Programming in the Cloud","Today's enterprise\/cloud computing environments have removed users from direct control of the hardware on which software is executing, as well as control over the software itself. In the 1970's, technological breakthroughs significantly lowered cost of computing. Hardware innovations brought large scale computation into smaller footprints, such as a central processing unit implemented as a single integrated circuit inside a computer. The improvements in cost of computing also increased accessibility and availability of computing resources. Computer usage was no longer time-shared among a selected few. Widely available personal computing made mass adoption of computers a reality. While hardware became widely available, applications continued to be built by highly skilled programmers who were required to intimately understand the underlying platforms. During this period, cost of development for software was high compared with hardware cost. Applications were typically specialized, and so, targeted at trained professionals, focusing mostly on data management and process\/office automation.","In the early 1990's, Internet access and web browsers obviated the need, in at least come scenarios, for a user to install software on the user's individual personal computer. A wide range of customer-facing applications became available to end users simply by clicking on a URL. Further, languages such as Java lowered the cost of software development by eliminating tasks such as automatic memory management and software portability. Web applications brought other software advances such as commoditization of user interfaces (UIs) and application frameworks.","Among other advantages, features and functionalities, today's application frameworks typically offer two major components: metadata (describing a problem in a language dictated by the framework), and a runtime engine (which performs actual runtime execution based on the given metadata provided by the application developer). These web-based applications have further separated problem description and execution. Software, therefore, no longer needed to be fashioned to serve as a single, specialized execution unit. Acts of changing the problem description involves only a change to the metadata, with no impact on runtime execution code.","In this second wave of mass adoption of computing resources, software advances in browsers, Java and frameworks lower the cost of software relative to hardware. Nonetheless, application developers were still required to have a high level of expertise in order to leverage the full range of options and controls typically available in an application development environment (also referred to herein as an application development framework (ADF)).","A third wave of mass adoption of computing resources has started with breakthroughs in reductions to cost of computation. Coupled with technological innovations such as virtualization and continued experience in large-scale utility computing, cloud computing makes an abundance of computing resources and network connectivity affordable at Internet scales. This availability of computing resources reduces costs of operations for web applications. Such availability also provides a foundation for continued development of collaborative applications and mobile applications. These Internet-scale infrastructures have become affordable to masses of users as paid services. These users are also looking for matching affordability in software. This also applies to other types of on-demand services such as video-on-demand. Content, in the realm of cloud computing, is simply the program or application executed on utility resources.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2A","b":["210","220","1","225","1","230","1","210","240"],"i":["n","m","p"]},"A cloud can be private or public. Public clouds sell services to anyone that can access them, while private clouds are proprietary networks or data centers that supply hosted services to a limited number of users. Cloud service providers can use public cloud resources to create private clouds, resulting in virtual private clouds. In each case, the goal of cloud computing is to provide scalable access to computing resources and information technology services.","IaaS provides virtual server instances with unique network addresses and on-demand blocks of storage. An application programming interface (API) is provided for starting, stopping and accessing virtual service servers and storage. In an enterprise, IaaS cloud computing allows a company to pay for only as much capacity that is needed and to bring more capacity online as that capacity is needed.","PaaS in the cloud, an example of which is illustrated in  as a PaaS , provides a hosted set of software and product development tools. Developers can create applications on the provider's platform over the Internet. PaaS providers can deliver access to such services using, for example, APIs, website portals, gateway software installed on a customer's computer or the like.","In a SaaS architecture, the provider supplies a hardware infrastructure, software products and interacts with a user through a front-end portal. Provided services can include, for example, web-based email, inventory control, and database processing. Since the service provider hosts both the application and the data, an end user is free to use the service from anywhere.","As can be seen from the above descriptions of cloud computing, a cloud's resources (i.e., cloud resources) can be viewed as an abstraction of the physical computer resources. An end user typically has no control over either the hardware or the software, particularly in SaaS and PaaS environments. Since different enterprises using the same cloud resources can have different requirements for satisfying the needs of their particular enterprise, a mechanism is needed for users to modify the software they use in a manner appropriate to the enterprise in question. The generative software concepts discussed previously recognize this issue, but fail to provide a practical solution to providing tools capable of creating and modifying software resources such as those provided in a cloud computing environment. Further, because cloud resources are accessed by many users (who may well be associated with different enterprises), any tools used to modify software in a cloud computing environment cannot disrupt the provision of cloud resources to other users. Therefore, certain guarantees need to be provided to ensure functionality of the changes made to the software. That is, tools that enable users to modify software resources should be validated for use in the given cloud computing environment.","Patterns for the Description of User Intentions","In an enterprise, a domain expert may, for example, want to modify or create original or additional objects (e.g., business objects, data objects, user interface objects or the like). Frequently, performing such tasks includes performing at least some of the same (or similar) operations. Further, achieving the intended outcome (e.g., the existence of a new data object via its creation) may necessitate the creation of (or changes to) other objects\/categories (e.g., a new field in a user interface display). Sets of such commonly-recurring operations, performed to achieve the desired objective(s), are referred to herein as patterns. In one embodiment, such patterns include a pattern declaration (e.g., which, for configuration operations, expose essential configuration options) and a pattern definition (e.g., which encapsulates the details of software component generation (accessed, e.g., via a middleware API)). The use of patterns provides both simplicity (e.g., by hiding the complexities of programming from users) and adaptability (e.g., by encapsulating changes to applications, middleware and so on).","In embodiments of the present invention, a pattern describes a commonly occurring solution within a given problem domain. In addition, the pattern can specify the manner in which an instance (a concrete or tangible representation) of that solution (an abstract concept) can be created, and so described (e.g., the manner in which the recurring solution can be instantiated on a particular target platform). As will be appreciated in light of the present disclosure, the instantiation of such solutions (abstractions) comprehends the creation of a real instance or particular realization of the solution (e.g., as a template, such as a class of objects or a computer process). Such instantiation operations create instances of the corresponding solution(s) by, for example, defining a particular variation of an object within a class (representing the solution), giving the object a name, and storing the object in some physical place (e.g., storing the object in a computer-readable medium, such as a computer memory). As such, patterns can also provide a generalized mechanism for a domain expert to form (and express) an intent for desired modifications to such software.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 2B","FIG. 1B","FIG. 1B"],"b":["110","120","115","125","120"]},"Unlike , one or more patterns are made available to domain expert  (depicted in  as patterns , for example), in order to allow domain expert  to express their intent as to the generation of the desired domain code that will serve as the input to generator program  (e.g., domain code such as domain code  of ). Patterns  can be made available to domain expert  in the form of a repository of patterns (not depicted in ; however, as will be appreciated, patterns  of  could be stored in and selected from such a pattern repository, for example). Such a repository of patterns can be created for a particular domain or multiple domains, for example, by a pattern programmer . Pattern programmer  is typically an expert programmer who prepares patterns that are not solutions for a specific instance of a problem, but instead reflect a more general approach for solving a given class of problems. A pattern programmer such as pattern programmer  should understand sophisticated nuances of the solution that is to be captured in the pattern. The patterns should be well-formulated, including the requisite variances for the desired objects (e.g., differing user interface elements and differing looks of those elements).","Domain expert  selects one or more patterns from the repository containing patterns , and then makes the desired\/necessary modifications to (\u201cedits\u201d) elements of the pattern using, for example, a configurator . For example, various parameters may need to be defined to instantiate a pattern, and thus domain expert  will provide values for those various parameters. Alternatively, a pattern can have sub-patterns that can be selected, which can, in turn, have defined parameters. A set of rules associated with a pattern and sub-patterns can restrict pattern and parameter values selection. Through the existence of patterns and sub-patterns, a system such as that described herein is able to create increasingly complicated and capable patterns by using other (typically simpler) patterns as building blocks. In fact, it is very often the case that the patterns employed are of the more complex variety, and in addition to their greater functionality, their use provides a certain amount of abstraction that hides the complexity of the underlying patterns, thereby simplifying the use of these more complex patterns.","Configurator  then generates domain code  used as input to generator program . Embodiments of the present invention are not restricted to the configuration of blocks shown in . For example, functionality of configurator  and generator program  can be combined, resulting in a functional element having selected patterns and modifications by domain expert  as its inputs, and executable code  as its output.","The design of such patterns should also provide for their evolution over time, for example, taking into consideration the fact that the enterprise objects to which such patterns are to be applied may also change over time. In order to provide for such evolution, the generation of such patterns can employ one or more of the following pattern evolution techniques: aspect orientation, variantization, composition, interaction, and constraints, as discussed immediately below, and subsequently in greater detail","Each pattern can have different aspects that evolve or are implemented separately. For example, for a user interface pattern, there can be different aspects such as display, security, style and localization. Each aspect is independently translated or evolved. Further, variantization allows a pattern to be altered based on the situation. For example, a user interface pattern can look slightly different from one application to another. Alternatively, when a text field is added to a form, the text can be rendered as a text entry. But if the same text field is added to a read-only table, the text field is rendered as a simple string. One mechanism for implementing variantization is to have the pattern be metadata driven. That is, a pattern generates metadata for a target platform, but that pattern is also described by metadata (e.g., meta-metadata). The meta-metadata is variantized based on the specific situation.","A composition model for patterns allows a complex pattern to be assembled from a set of simpler patterns. Composition rules contain structural requirements in terms of assembling patterns. Interaction rules specify behavioral dependency of components within a pattern. Interaction is focused on describing interdependency of components that affect the runtime system. For example, a user interface component can cause a partial refresh of other components within a page. Finally, constraint rules specify restrictions or guidelines that are enforced during metadata generation. Constraints can be governed based on restriction of the target platform or preferred best practices, and can adhere the composition and interaction rules to the restrictions and guidelines. For example, a user interface best practice may require that a table does not contain any text area component.","A cloud programming model according to embodiments of the present invention thus implements a programming paradigm and principles that allow \u201cself-service programmers\u201d to create and modify software using intentional programming techniques. The need for such programming paradigm is evident from the fact that, while such users may be experts in their area of expertise, they have minimal or no training in computer programming. For example, such a user could be a salesperson, who is also a part-time system administrator. As noted earlier, existing paradigms fail to address the problem of simplifying the programming experience. In fact, the myriad technologies available heretofore have only made the work of computer programming even more challenging. As software has become more complex, the programming code written for actual business logic has remained proportionally small, in comparison with the effort required to learn an application framework.","An advantage of a cloud programming model according to embodiments of the present invention is the simplification of the programming experience for new programmers. This includes various precepts that are directed to addressing the needs of such programmers in a cloud-based computing environment. Fundamentally, such a programming environment needs to be able to address intention instead of translation. The programming environment should focus on allowing for the description of the desired outcome, rather than the manner in which the problem's solution is or will be implemented in a particular framework\/environment. Preferably, the user should be able to specify (describe) the given intention through a business-centric user interface (UI), rather than an integrated design environment or the like. Such a business-centric UI is structured to assist the user with describing the problem, instead of managing programming tasks. In other words, such a user does not write a program in a classical sense (although the result of capturing the user's intentions still constitutes a \u201cprogram,\u201d in a logical sense).","Further, the vocabulary and notation used for describing the intention(s) should be closely aligned with the problem domain. In a classical sense, the vocabulary and notation often constitute the syntax. The syntax, in this sense, should be adapted to the problem domain, rather than relying on a programmer to translate intention into a program with a fixed syntax (e.g., a general programming language). Such a vocabulary and notation should be adaptable (e.g., for use in addressing new requirements). Since a focus of a programming environment according to embodiments of the present invention is to capture user intention, the capability of the program (syntax) should support evolution to address new and changing requirements.","Preferable also is the ability of the programming environment to be executed on existing software and hardware infrastructure (e.g., middleware runtime, database infrastructure, servers, and so on), without modification thereof (e.g., without the need for a new dedicated runtime engine). In other words, the use and implementation of a cloud programming model according to embodiments of the present invention provides the advantage of marked simplification of the programming model, in comparison to classical approaches. For example, in terms of a middleware platform, such an approach is not intended as simply a re-invention of that middleware platform, but is instead directed to the seamless, automatic translation of user intention into a target metadata\/language that can then be executed by the middleware platform.","Thus, a programming environment according to embodiments of the present invention should provide for the direct and simple correlation between the intention and the \u201ceffect\u201d of the intention's translation. In the preceding example, the \u201ceffect\u201d of a translation is therefore not the middleware artifacts being generated, but instead the (desired) observable behavior in an application created or modified by the user. For example, if the user intention is to create a new page for a custom entity, the effect of the translation is a new page in the application, where the page is rendered with a certain look-and-feel and layout. In providing such an environment, the user should be exposed to as little of the system's internal implementation details as possible (preferably, in fact, the user should be completely isolated from such details). In the preceding example, this means that the user would have no knowledge of the middleware metadata or runtime (nor need for any such knowledge), for example. The middleware would thus be able to evolve over time, changing from release-to-release, without any resulting alterations being observable by the user.","Design of a Cloud Programming Model Using Intentional Programming","The following passages describe an example of an implementation of a cloud programming model supporting \u201cself-service\u201d programming, according to embodiments of the present invention, which embodies the aforementioned principles. Moreover, in providing such functionality, a programming environment, such as that described herein, is also able to achieve goals related to extensibility, particularly with regard to the aforementioned self-service programming concepts. For example, such an extensible cloud programming environment provides a generalized mechanism by which such self-service programmers can construct and\/or modify software components, in order to build the desired software application(s) (e.g., a customer relationship management (CRM) application). Thus, such a programming environment allows the development of the fundamental primitives and operations that are needed to assemble simple components into semantic-rich components (referred to herein as component composition). A simple example of component composition is the assembling of a set of user interface elements (e.g., for text input) into a form, based on a set of specific layout restrictions and requirements. An extensible cloud programming environment, such as that described herein, also allows the adoption of a component composition technology for on-demand software applications (e.g., a CRM SaaS application), in order to allow untrained users (self-service programmers) to extend the application (e.g., CRM SaaS application) using pre-configured components.","The example design presented below can be broken down into four major pieces. The first comprehends a language that captures intention of the programmer (referred to herein as the aforementioned \u201cself-service programmer\u201d). Next is a forward-translation implementation, which converts intent into an executable (e.g., a middleware executable). Another part of such a programming environment is a reverse-translation implementation, which is designed to convert an executable into an intent (e.g., the conversion of a middleware executable into an intent). The last of these four pieces is a configuration user interface (e.g., in a CRM environment, a business-centric configuration UI) that is designed to guide the programmer in specifying their intent without the need for, nor knowledge of, any programming details.","Intent Specification","The purpose of intent specification in a programming environment according to embodiments of the present invention is to allow a self-service programmer to focus on the desired outcome, rather than the manner in which the step-by-step process of carrying out instructions is to proceed within the given computer system(s). Furthermore, such a language can be adapted and modified with relative ease. Such an approach allows the specification of each intention as a command. Each command identifies an action or actions that the programmer intends to have the computer system(s) carry out. A command also can carry a set of user properties that further provides specifics regarding the action to be performed.","Such a command differs from a traditional programming instruction in several respects. Among these differences is the fact that such a command operates at a higher level of abstraction, and addresses the programmer's intention and requirements, while lacking the ability to definitely direct the given computer system(s) to perform a specific instruction in the instruction set(s) of the computer system(s). By marked contrast, a traditional programming instruction (e.g., an instruction in a computer system's instruction set, such as a single machine instruction) exists at the other end of the spectrum, and as such, is tailored to the requirements of the computing device.","Forward-Translation","Forward-translation gives effect to the self-service programmer's intent by providing the system for which the programming is intended (e.g., the aforementioned middleware platform) with direction as to the operations to be performed, based on the commands received from the self-service programmer, which embody that intent. In embodiments of the present invention, a unit of translation is encapsulated within a conceptual (i.e., logical) construct referred to herein as a pattern, which describes a (predefined) solution within a particular problem domain. In addition, such a pattern can be designed to carry a specification of the manner in which a recurring solution for a particular target platform is to be \u201cmaterialized\u201d (e.g., instantiated). When a command is invoked, one or more patterns are thus materialized. During materialization in the example middleware system, for example, the translation generates the requisite metadata for the given target platform to implement the desired solution. It will be appreciated that, in light of the present disclosure, the patterns described herein can be re-used any number of times (with or without being reconfigured in any given iteration).","In supporting forward-translation, it is desirable to provide support for the earlier-mentioned concept of pattern evolution. Such functionality ensures that the patterns thus materialized can be easily and efficiently evolved, in response to changes in requirements. Several techniques are described herein that provide the requisite functionality, and include:\n\n","Reverse-Translation","In reverse-translation (also referred to herein as \u201creflection\u201d), a programming environment according to embodiments of the present invention recognizes one or more patterns from existing constructs (e.g., existing middleware metadata). Reverse-translation thus provides for the revision and migration of such constructs through the abstraction provided by patterns (i.e., pattern abstraction). In the example of middleware metadata, such pattern abstraction means that middleware metadata can be generated in a manner that facilitates its revision and migration. (It should be understood that, as used herein, the term \u201cfacilitate\u201d is intended to convey that the functionality or structure discussed is helpful in assisting the given system or process in accomplishing the stated result, and not that the functionality or structure in question is required to accomplish that result, or mandatory in any way.) In a programming environment according to embodiments of the present invention, such reverse-translation can be achieved, for example, through the use of a rules-based pattern recognizer.","Application-Centric Configuration User Interface","An application-centric configuration user interface according to embodiments of the present invention acts a front-end application (e.g., web application) that enables the self-service programmer to describe their intent as a configuration task, without the need for any actual programming. As the programmer navigates through this user interface, their intent is captured. Commands can then be issued to initiate the materialization of the pattern. The result of such pattern materialization is the generation of programmatic constructs (e.g., the generation of generated middleware metadata). In the example, immediate feedback regarding the generated middleware metadata can be presented to the programmer through the UI by way of reverse-translation. Unlike a conventional middleware integrated design environment, a UI according to embodiments of the present invention can be used to trigger the translation of a simple user intent into complicated programmatic constructs. A conventional middleware integrated design environment, by contrast, fails to provide such functionality, and therefore, presents itself as a mere programming tool.","Enterprise Software Object Generation",{"@attributes":{"id":"p-0083","num":"0087"},"figref":["FIG. 3","FIG. 3"],"b":"310"},"From a plurality of patterns made available to the selected domain, a pattern is selected by a user (step ). Selection of an appropriate pattern is made based upon the nature of the object desired to be created or modified and the nature of the problem to be solved. If the selected pattern is not compatible with previously selected patterns (step ), then the selected pattern can be rejected (step ). A compatibility determination can be made, for example, by consulting one or more rules associated with previously selected patterns. As described above, compositional rules and interaction rules affect relationships between patterns. These rules can be associated with the patterns when they are generated, or subsequently added as new patterns are placed within the pattern repository and conflicts between patterns are discovered. If the selected pattern has been rejected, a user is given the opportunity to select a different pattern (step ). If the selected pattern is not rejected, a user is then given the opportunity to select additional patterns (step ).","Once a user has selected all the patterns that are desired for creation or modification of an enterprise object, the user is prompted to provide values for parameters defined by the one or more selected patterns (e.g., variable values, field definitions, and the like) (step ). This process of pattern selection, rule confirmation, and parameter specification can be performed within, for example, a configurator such as configurator  of . As parameter values are provided, a determination is made as to whether the parameter values are consistent with the rules associated with the pattern and other patterns being instantiated (step ). If a parameter value is outside a range or specific value specified by a rule, for example, the parameter value is rejected (step ), and the user is given another opportunity to provide values acceptable, in light of the given rules.","Once parameter values, appropriate to the problem to be solved, have been entered for parameters associated with the selected patterns, an enterprise software object is generated by a generator program (e.g., generator program  of ), using the selected patterns (step ). For example, in the embodiment illustrated in , configurator  assembles the pattern specifications along with the specific values of the parameters to generate a domain code file along with appropriate metadata that serves as an input to generator program . Generator program  then generates executable \u201ccode\u201d (instructions) for the desired platform (e.g., executable code in the Java programming language, for a specific platform (e.g., the original Java 2 Platform, Enterprise Edition (J2EE), or the more recent Java Platform, Enterprise Edition 6 (Java EE 6)). Alternatively, where functionality of the configurator and the generator are combined, patterns, parameter values, and additional metadata can be used to directly generate executable code. Once the desired enterprise object has been generated, that object is then available to be executed on the appropriate platform (step ).","Generator program  can employ any one of a number of approaches to generate the requisite executable code. As will be appreciated in light of the present disclosure, and as previously observed, embodiments of the present invention employ a generative approach, as opposed to a component-based approach. In constructing software systems using either approach, there is a distinction between the language employed and intention(s) captured thereby, and the executables (software) generated for the given implementation. As will also be appreciated, there is a clear distinction between these stages of software development. In a component-based approach, the language and resulting executable are closely interwoven with one another. Thus, using a component-based approach, a single intention (using a single language to express that intention through the hand-coding of the desired software) maps to a single implementation (as reflected in the single executable that results). By contrast, using a generative approach such as that described herein, a single language\/intention can yield a number of different executables\/implementations, depending on a variety of factors. This decoupling of language\/intention and resulting executable\/implementation, provided by approaches according to embodiments of the present invention, results in such approaches being able to provide great flexibility in the generation of such executables\/implementations. This is particularly true when the ability of such approaches to dynamically map intentions to executables is considered. For example, as the result of a process according to embodiments of the present invention, a single intention (e.g., to create a web page capable of displaying an object detail) may map to any one of a number of different implementations, based on the given country, industry, and so on.","Using the aforementioned example of generating executable code in the Java programming language, generator program  receives a number of patterns as input. Each of these patterns includes different aspects. Each such aspect will have a corresponding content provider. A content provider is responsible for generating and injecting the requisite metadata into the given object (e.g., a specific middleware component). Each content provider, in essence, behaves like a dedicated compiler, specific to the given aspect. As an example, when a component of a user interface is generated, one or more aspects may be involved. For example, two aspects that are typically so involved are a view aspect (e.g., for generating the presentation (the actual layout and so on)) and a security aspect (e.g., for generating the security policy for that user interface). In such a scenario, there are two corresponding content providers. The view content provider generates metadata for the page that conforms to the Java Server Faces (JSF) specification. The security content provider creates and injects security policy into the appropriate server. Such a security content provider can include, for example, a Lightweight Directory Access Protocol (LDAP) server, configured to authenticate and authorize access to an organized set of records (e.g., a database, repository, store or other such construct (any and all of which may, in fact, be one and the same)) by one or more network entities (e.g., one or more of clients  or servers ), as well as facilitating access to and maintenance of the distributed directory information services involved in providing such access, among other such supporting functions.","Patterns, in the manner noted, are an abstraction of commonly recurring implementations for a specific application. As noted above, these implementations can include look and feel, guidelines, standards, and the like. Patterns are configured to expose essential configuration options for enterprise objects, favoring convention over the configuration of the enterprise object. Due to their generalized nature, patterns are typically more enduring than the instances of the enterprise objects generated from a pattern.",{"@attributes":{"id":"p-0090","num":"0094"},"figref":["FIG. 4","FIG. 4"],"b":["410","270","270","270","270","270"]},"Once a pattern has been identified, the pattern can be associated with a \u201cPattern Kind,\u201d either new or old (step ). The main purpose of a Pattern Kind is to enforce uniformity among patterns of the same \u201ckind.\u201d A Pattern Kind can serve to specify common specifications and resources sharable among patterns of the same kind. Further, a Pattern Kind can specify an externalized contract for the pattern, including, for example, a list of aspects the pattern can have, common specifications and resources among patterns in the kind, a collection of properties for patterns in the kind, a collection of aspects for one or more sub-patterns, and lists of literals with their values for patterns in the kind. Patterns can belong to more than one Pattern Kind, if appropriate. When associating a pattern with a Pattern Kind, the pattern will adopt characteristics specified by the Pattern Kind, unless overwritten by values within the pattern, for parameters such as, for example, properties, aspects, variables, and the like.","Aspects for the pattern are also identified in creating the pattern (step ). As stated above, an aspect specifies requirements for instantiating a pattern. Aspects can include physical representations of a pattern in the target domain. For example, a user interface pattern may have one or more of the following aspects: view aspect, security aspect, display aspect, and binding aspect, among others. Typically, the first two aspects are mandatory, while the latter are typically optional. A display aspect specifies look and feel of the pattern. A binding aspect specifies how the pattern interacts with the underlying model. A display aspect and a binding aspect have their own physical representations (e.g., extensible markup language (XML) schemas).","For each aspect of a pattern, a content provider for the aspect is identified (step ). A content provider specifies how to generate the content for the particular representation. In one embodiment, a content provider is a Java class that controls how the content is being fabricated for a certain aspect. Content providers can generate the content using templates, which, in one embodiment, are XML documents containing partial implementations of the content. A template content provider can contain switching logic to determine which template to use depending on a situation. For example, if an input text pattern is being created and the target container is a table, the content provider can choose a template that wraps the input text user interface control under a column element.","In one embodiment of the present invention, the output of a content provider is a content object, which is a self-descriptive object that contains the generated content and additional information about the content such as implementation type, identifying implementations used for the content and an aspect in which the content is being generated for. Templates specify a pattern's content for a specific aspect. The content of a pattern represented in a template can include, for example, language-specific literals including textual fragments that are specific to the target representation, variables whose values can be substituted when the template is instantiated, sub-patterns included within a pattern, conditionals based on input properties and template parameters, and sub-templates embedded within the template. Once the content provider for an aspect is identified, a determination is made as to whether the last aspect has been identified (step ). If other aspects remain, such additional aspects are identified (step ), as the process loops through the remaining aspects of the pattern. If the last aspect has been identified, a generation context for the pattern is then identified (step ). A generation context is a set of resources available when the pattern is instantiated. These resources are accessible in the template as variables. The pattern and its associated metadata are then stored (e.g., in a pattern repository, accessible to privileged users) (step ).",{"@attributes":{"id":"p-0095","num":"0099"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["510","520","530","520","540","530","550","535","555","510","560"]},"A pattern can also be included in more than one Pattern Kind. Such a pattern adopts the defined characteristics of each Pattern Kind for which it is a member to the extent that those characteristics do not conflict with one another. In the event that a characteristic from each Pattern Kind is in conflict, the pattern can adopt just one of those characteristics. In one embodiment of the present invention, a pattern will adopt the characteristic of the last associated Pattern Kind.","Plan  provides steps that are to be fulfilled before, during, and after generation of intentions from patterns. The plan provides a set of directions for how inputs for parameters and the like are combined with the pattern. Thus, the plan provides directions to a generator program for the way parameters and patterns are linked together given the inputs provided to the configurator.","In one embodiment of the present invention, a repository of patterns is developed for use by enterprises accessing computer resources in a cloud environment. Patterns within the repository are vetted in a manner that guarantees that software generated from the patterns will not be disruptive to users of the cloud environment. Further, the pattern in the repository can be approved for use for specific problem domains, and be made accessible only to approved users of those problem domains. Thus, security can be in place so that only \u201cdomain experts\u201d having approval to generate new software within the domain can have access to patterns associated with that domain. Further, a domain expert of one domain may not have access to patterns associated with a different problem domain for which that use does not have privilege. Through the use of such a system, approved users can express intentions for desired software using patterns designed to facilitate expression of those intentions, and then provide those generated intentions to a software generator that outputs desired enterprise class objects, such as business objects, data objects, and user interfaces.","An Example Enterprise Server Architecture",{"@attributes":{"id":"p-0100","num":"0104"},"figref":["FIG. 6","FIG. 5"],"b":["610","620","660","665","630","620","610","620","620"]},"Servers  can be configured to support back-end and interactive processes for each client accessing the server. These processes are illustrated as one or more components  within each server. Servers such as servers  can support, for example, multi-process and multi-threaded components, and can execute components in background, batch, and interactive modes. A server component can also be executed on multiple ones of servers  simultaneously, in order to support an increased number of users and\/or larger batched workloads. Examples of component processes include, for example, mobile web client synchronization, operation of business logic for web clients, connectivity and access to database and file systems for clients, integration with legacy or third-party data (e.g., data not native to the enterprise system), automatic assignment of new accounts, opportunities, service requests, and other records, and work flow management. Embodiments of the search processes of the present invention can also be implemented to execute on one or more of servers  as components.","Servers  are coupled to a gateway server , illustrated as part of enterprise server . Gateway server  coordinates the operations of enterprise server  and servers . Such a gateway server can provide persistent storage of enterprise server configuration information, including, for example, definitions and assignments of component groups and components, operational parameters, and connectivity information. A gateway server can also serve as a registry for server and component availability information. For example, a server within enterprise server  (e.g., one of servers ) can notify gateway server  of availability. Connectivity information such as network addresses can be stored in a storage accessed by gateway server . If one of servers  shuts down or otherwise becomes unavailable, connectivity information related to that server can be cleared from gateway server .","Through their relationship in enterprise server , servers  and their components  are able to access one or more data sources (e.g., databases  and file systems ). Database  can store, for example, RDBMS client software and tables, indexes, and data related to all operations impacted by the enterprise system. Such database information can include, for example, customer information, market data, historical pricing information, current pricing information, contact information, and the like. Similarly, file system  can store data and physical files used by clients  and  and enterprise server . File system  can be a shared directory, or set of directories on different devices, which is network-accessible to all servers  in enterprise server . In order for a client to gain access to files in file system , a client can connect to an appropriate one of servers  to request file uploads or downloads. The server is then able to access file system  using, for example, a file system management component.","As stated above, embodiments of the processes of the present invention can be implemented to execute as components on one or more of servers . These servers can form or be part of a private or public cloud computing environment. An alternative embodiment provides a separate server accessible by the same or different web server.","Clients  and  provide access to enterprise server  for agents using the enterprise system. Clients communicate to enterprise server  through gateway server  either directly (e.g., client ) or via a web server  (e.g., clients ). A web server  provides a mechanism by which enterprise server  can respond to web-based requests (e.g., HTML, XML, and the like). Web clients  can include clients coupled to web server  via a local area network, metro area network, or wide area network and propagated over a variety of communications media, as discusses above. Further, web clients  can include mobile clients accessing web server  through wireless communications means. Users of clients  and web clients  can include, for example, sales agents, service agents, customer representatives, managers of the business entity, and the like. Users have access to all information accessible to enterprise server  in database , as controlled by a user's secured access rights.","Clients  and web clients  can be distributed throughout an enterprise and can include hundreds or thousands of such clients. Each such client can perform tasks related to either creating new records to be stored in, for example, database , modifying records in database , or searching for information stored in database .","An Example Implementation of an Intentional Programming Model in an Extensible Cloud Programming Environment",{"@attributes":{"id":"p-0108","num":"0112"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["700","700","705","705","710"]},"Plan  is typically determined, at least in part, based on a command  received by plan processing module , and which, for example, is received from a configurator . Configurator  is a configuration tool tailored to the needs of untrained users (e.g., self-service programmers), and allows such users to add new software components to an existing application, or modify the software components existing therein.","A plan (e.g., plan ) specifies one or more operations, typically in a sequence of some sort, to be performed in giving effect to the given command. In certain embodiments, each operation specified by a plan is carried out through an executor class.","For example, a command \u201cCreateAttribute\u201d might have a plan that specified the following operations:","1. Allocate an available attribute.","2. Identify the target metadata and artifact into which the pattern is to be injected.","3. Compose a pattern for the new attribute.","4. Inject the new pattern into the target metadata.","A further example of the operations, as well as the functionalities facilitated by a plan according to embodiments of the present invention is discussed in greater detail in connection with .","Upon receipt of command , plan processing module  refers to mapping information (e.g., a command registry (not shown)), which includes information mapping command  to plan  (and vice versa). It will be appreciated that a command can map to more than one plan, and conversely, more than one command can map to a given plan. Thus, relationships between commands and plans can be 1:N, 1:1, or N:1, as well as combinations thereof. Once plan  has been identified, the operations outlined by the plan are identified and, if possible and appropriate, carried out.","As will be appreciated in light of the present disclosure, a command such as command  is implemented as an XML fragment that contains configuration options that can be used in creating and injecting a pattern, in certain embodiments. Further, a set of such commands can be maintained in a command configuration file, for example. The foregoing command paradigm serves as the self-service programmer's primary interface to extensibility framework architecture . Preferably, a command according to embodiments of the present invention should be a generic and lightweight mechanism, in order to enable a caller (e.g., a configurator such as configurator , or the like) to generate and inject new patterns easily and efficiently.","In order to perform the operations necessary to creating and injecting a pattern (and so support the extensibility of the software components in question), extensibility framework architecture  provides a pattern manager , an artifact manager  and an injection resolver . In response to a pattern request , pattern manager  accesses a pattern repository . In certain embodiments, pattern repository  (also referred to herein as a component repository) is a collection of pre-built components available for application building. In addition, if necessary, one or more pattern composition operations can be performed. As noted elsewhere herein, pattern composition refers to the process of composing semantic-rich patterns from other (typically more basic) patterns. As described elsewhere herein, this ability to create more complex patterns by aggregating simpler patterns further enhances the extensible nature of extensibility framework architecture , and is discussed in greater detail in connection with .","Having identified (and\/or composed, as the case may be) one or more patterns that satisfy pattern request , pattern manager  returns the pattern(s) thus identified or composed (depicted in  as a pattern ). In the example depicted in , a sample user interface pattern  is presented as an example of such a pattern. Sample user interface pattern  includes display information  and binding information . Display information  can be implemented as a display template, and can include information specifying the look-and-feel of sample user interface pattern , for example. Binding information , similarly, can also employ a display template, and can include information specifying the manner in which sample user interface pattern  interacts with the given data model, for example. Examples of elements comparable to display information  and binding information  are provided in connection with .","Pattern manager , as part of providing pattern , may need to perform pattern composition. Pattern composition refers to the process of composing a more complex, semantic-rich pattern from more basic patterns. In the manner previously described, a pattern is a reusable building block that adheres to a specific semantics and use-cases. A pattern is similar to a component, but with at least one distinction: Typically, a component is built for a wide range of uses, while a pattern is typically built for a few specific use-cases. As such, a component typically provides a rich set of configurable options in adopting such usage scenarios. By distinction, a pattern has an inherent semantic that reduces its complexity in terms of configurability. The inherent semantic in a pattern can be signified through its structure, as well as its predefined behaviors, whereas these structures and behaviors are typically configurable in a component. It will be appreciated, however, as used herein, the term pattern is intended to convey the possibility of the use of a component (as is intuitively the case, given that a pattern is, for purposes of this disclosure, simply a component having an inherent semantic that simplifies its use, at the expense of reduced configurability).","As will be described further in connection with , a pattern can belong to one or more PatternKinds. Each PatternKind contributes to the externalized contract in using the given pattern. The externalized contract includes a set of properties that signify the configuration option(s) for the pattern. A pattern can have one or more aspects, with such each aspect satisfying a certain requirement in materializing the pattern. The pattern's PatternKind specifies the aspects that a pattern of that PatternKind can have. Each aspect, in turn, includes a content provider that provides the actual content for that aspect. A content provider can employ one or more templates in assembling the actual content. Such templates may specify a property, which is a configuration option used by the template. Typically, a property name is an alphanumeric string (preferably not case sensitive), and a default value can be specified with a property (e.g., a literal string). Another possible characteristic of a pattern is the annotation. An annotation gives semantic meaning to a pattern. For example, if the pattern is used for generating a detail table, then this information can be captured in the annotation. The annotation can be used later in generating artifacts for this pattern (e.g., as the pattern is created).","Another feature of extensibility framework architecture  depicted in  is artifact manager . Artifact manager , among other elements, includes a number of adapters (depicted in  as adapters ()-(N)). As depicted in , adapters ()-(N) allow artifact manager  to access various sources of programmatic constructs, such as metadata, artifacts and the like (examples of which are depicted in  as construct sources ()-(M)). As described in further detail subsequently, an artifact is an abstraction that imbues a piece of a runtime metadata with a meaning. Among other characteristics and capabilities, an artifact can provide the requisite abstraction to allow retrieval of properties from runtime metadata.","Alternatively, artifact manager  can be designed to access construct sources directly (thus making the aforementioned adapters optional). Artifact manager  can also be designed to access other information directly, such as various registries (an example of which is depicted in  as an artifact registry ). However, as depicted in  (and noted above), adapters ()-(N) interface artifact manager  not only to construct sources ()-(M), but also to an example of such construct sources, a metadata repository . As depicted therein, artifact manager  accesses metadata repository  via adapter (), and construct sources ()-(M) via adapters ()-(N). It will be appreciated that, while depicted as having 1:1 relationships, the adapters and construct sources employed may, in fact, also have one-to-many, many-to-one, or many-to-many relationships, and\/or some combination thereof, in a given implementation. In the scenario depicted in , however, it will be appreciated that each of adapters ()-(N) interfaces artifact manager  to a given construct source (i.e., metadata repository  or one of construct sources ()-(M)).","As will be appreciated in light of the present disclosure, artifact registry  maintains artifacts, as well as information associated therewith, available for use in extensibility framework architecture . As will be further appreciated in light of the present disclosure, the artifacts in artifact registry  will be configurable (i.e., customizable), in at least some regard, and so facilitate the injection process thereby. Similarly, metadata repository  maintains metadata associated with the artifacts (e.g., target metadata ). It will be understood that metadata repository  is merely an example of the various artifact repositories that can be made available to artifact manager , and further, that such artifact repositories support the functionalities made available to self-service programmers via an application development framework such as that described in connection with .","When artifact manager  receives an artifact request from plan processing module  (depicted in  as an artifact request ), artifact manager  accesses the data sources that are made available via the adapters (e.g., artifact registry  and metadata repository ), in order to identify, access and provide the requested information in response to artifact request  from plan processing module  (that being information including the requested artifact and associated metadata (depicted in  as target metadata )). Among other constructs included (or potentially included) in the various artifact registries available to artifact manager  in a given configuration are aggregations of artifacts. Certain aggregations of artifacts are referred to herein as partitions. A partition is a collection of the configuration artifacts (such as patterns and plans) that are specific to an application domain. In certain embodiments, a partition is identified by a filename and filesystem directory. Configuration files placed in a partition's filesystem directory will belong to that partition. The operation of artifact manager , as well as further associated elements and additional features thereof, is discussed in greater detail in connection with .","With the requested pattern (pattern ) and requisite metadata (target metadata ) now available, plan processing module  is able to proceed with the operations identified by plan , and provide the requested pattern and metadata to injection resolver . An injection resolver (also referred to herein as a pattern resolver), such as injection resolver , determines the pattern(s) to be generated, which, in turn, depend(s) on the inputs received thereby (e.g., pattern  and target metadata ). For example, based on the given command, one or more attribute types and the target artifact, a specific one of a number of patterns can be selected for injection.","More specifically, pattern injection refers to the process of injecting a pattern into existing artifacts (thereby allowing a self-service programmer to customize an artifact, for example), as well as creating new artifacts from the materialized pattern (thereby allowing a self-service programmer to create artifacts within the universe defined by the pattern's pattern programmer, for example). Thus, a pattern (e.g., pattern ) is injected into an artifact's runtime metadata (e.g., target metadata ). As noted elsewhere herein, runtime metadata refers to the metadata used in the software components of the runtime system. For example, in one implementation, the runtime metadata and resulting software components are a collection of software files (e.g., application development framework files) created for the application in question. In such an implementation, each piece of runtime metadata is referenced by a unique name. Thus, the content of the runtime metadata can be retrieved from a metadata repository (e.g., metadata repository ), using that runtime metadata's unique name.","As noted earlier, an artifact is an abstraction that imbues a piece of a runtime metadata with a meaning. In one implementation, an example of an artifact is a Frame. A Frame is a user interface artifact that corresponds to an area within a user interface page. A MasterRegion is a Frame that can be mapped to a FormLayout element within a page. A FormLayout element is a container for the fields to be displayed for the master object.","In such a scenario, an artifact would then carry the following information:\n\n","As noted above, the ApplyTo information indicates the context in which an artifact applies. For example, a Frame artifact is used for displaying the fields for an Entity (e.g., Opportunity). The context (Opportunity) gives additional meaning to this Frame artifact.","Further, an artifact can have multiple aspects, in a manner comparable, at least in concept, to that of a pattern. Each aspect captures the mapping between an artifact and the corresponding runtime metadata. An artifact aspect can include the following information, for example:\n\n","When injecting a pattern into an artifact's metadata, information regarding the point in the artifact's metadata at which the pattern is to be injected is typically needed, and is referred to herein as a pointcut. A pointcut specifies the insertion point of a pattern being injected into an artifact. It is noted here, however, that such need not be the case, as the automatic identification and location of pointcuts is within the scope of the present disclosure. Such automatic identification and location can be achieve though techniques such as the recognition of pattern in the runtime metadata, use of historical information as to where such patterns have been injected in the past, and other such automated techniques.","In one implementation, a pointcut can include, for example, the following information:\n\n","With regard to the Operator pointcut information, examples of pointcut operators thus identified include \u201cInsert,\u201d \u201cAfter,\u201d \u201cBefore\u201d and \u201cInsertSort.\u201d \u201cInsertSort\u201d instructs injection resolver  to insert the pattern in a relative position among existing elements in the runtime metadata. Each pointcut operator can be associated with a specific aspect. For example, for the aspect DisplayAspect, the \u201cInsertSort\u201d pointcut operator could be used, while for the aspect BindingAspect, the \u201cInsert\u201d pointcut operator might be employed.","In extensibility framework architecture , for a pattern to be injected into an artifact by injection resolver , the following pieces of information are needed:\n\n","In the implementation presented as extensibility framework architecture , the following operations are performed during injection:\n\n","As noted earlier, artifacts can also be generated in extensibility framework architecture . To perform artifact generation with a given pattern, a special pointcut is used to create the new artifact. In such a scenario, the given pattern needs to be properly annotated, such that the new artifact can be generated from the pattern's annotation.","Injection resolver  includes, among other elements thereof, a number of handlers (depicted in  as handlers ()-(N)). Handlers ()-(N) facilitate interactions between injection resolver  and various other system elements of extensibility framework architecture , and thereby provide the functionality needed to modify the software constructs being customized. For example, handler () allows injection resolver  to interact with a services session . Similarly, handler (N) allows injection resolver  to interact with the various software components  being modified. In supporting such functionality, handlers ()-(N) allow injection resolver , after having received target metadata  and pattern , to inject pattern  into target metadata  and provide the customized metadata to one or more of software components . In performing the foregoing operations and making the customized constructs available, plan processing module  communicates with a metadata service , for example, by providing notifications and other information to metadata service  (an example of which is depicted in  as a notification ). It will also be appreciated, however, that metadata service  can support the functions associated with plan processing module  directly, and so encompass the processing of plan .",{"@attributes":{"id":"p-0140","num":"0162"},"figref":["FIG. 8","FIG. 5","FIG. 8","FIG. 8"],"b":["800","800","800","810","820","830","840","850","810","820","810","820","820","810","820","830","830","840","840","850"]},"The primary function of a pattern kind (also referred to by its class name of PatternKind), such as pattern kind , is to enforce uniformity among patterns of the same \u201ckind.\u201d In that regard, a PatternKind serves two purposes:\n\n","Examples of PatternKind are UIPatternKind and DataPatternKind. A PatternKind can be derived from a parent ParentKind. For example, a TextUIPatternKind can be derived from UIPatternKind. A child PatternKind can inherit the resources of the parent PatternKind. In one implementation, the following characteristics can be specified in a PatternKind:\n\n","A pattern can belong one or more PatternKind. If a pattern has more than one PatternKind, then these PatternKinds are specified in a list, and the following rules apply in resolving conflicts between the PatternKinds:\n\n","An aspect specifies a certain requirement in materializing the given pattern. One such requirement can be the physical representations of a pattern in the target domain. A user interface pattern (e.g., sample user interface pattern ) may have two aspects, a Display Aspect (e.g., display information ) and a Binding Aspect (e.g., binding information ). The Display Aspect specifies the look-and-feel of the pattern. The Binding Aspect specifies the manner in which this pattern interacts with pattern data model . The Display Aspect and Binding Aspect each have their own physical representation (e.g., XML schema). Each aspect has its corresponding content provider to specify how to generate the content for the particular representation.","In certain implementations, a content provider such as content provider  is a Java class that controls the manner in which content is fabricated for a certain aspect. Typically, content provider  generates the requisite content using one or more templates. In such implementations, a template can be, for example, an XML document that contains the partial implementation of the content in question. Alternatively, content provider  can also generate the content programmatically.","A more specific example of a template is a template content provider. A template content provider is a content provider that generates content based on a template. A template content provider can contain switching logic, capable of determining which template to use, depending on the situation. For example, if an InputText pattern is being created and the target container is a table, the content provider can choose whether or not to use a template that wraps the InputText user interface control under a column element.","In certain embodiments, the output of a content provider is a content object. Such content objects are self-descriptive objects that contain not only the generated content, but also additional information about the content. As an example, a content object can contain the following information:\n\n","The implementation type identifies the implementations used for this content. For example, an implementation type can be \u201cDOM\u201d (indicating the document object model convention) for XML content. In such an implementation, the implementation type, if missing, is defaulted to the class name of the actual content.","A template is a specification of a pattern's content for a specific aspect. For example, a template can be used to specify XML-based content. Examples of the forms in which the content of a pattern can be represented in a template include:\n\n","Each template is essentially an extension of the constructs of the underlying target representation. In the case of an ADF, a user interface template (e.g., such as that which would be used with sample user interface pattern ) would contain specific layout and visual requirements for the application in question (e.g., a CRM application).","A template may also declare one or more parameters. Such parameters can be used as variables in the template's text. The template parameters are typically used when the template can be embedded in another template of the same aspect. The template parameters enhance the reusability of the template.","An example of a template with a variable and a condition appears below:",{"@attributes":{"id":"p-0153","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"InputTextDisplayTemplate"]},{"entry":[{},"<af:inputText ..."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rendered=\u201dtrue\u201d"]},{"entry":[{},"maximumLength=\u201d$$maximumLength$$\u201d"]},{"entry":[{},"#if test=\u201d$$required$$\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"required=\u201dtrue\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"required=\u201d$$pBindings$$\u201d.$$attributeName$$.required\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An example of a template with a sub-template appears below:",{"@attributes":{"id":"p-0155","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ColumnInputTextDisplayTemplate"]},{"entry":[{},"<af:column ..."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#expand template=\u201dInputTextDisplayTemplate\u201d"]},{"entry":[{},"pBinding=\u201drow.bindings\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As a pattern is materialized, its sub-patterns are expanded into concrete contents. As will be appreciated, in light of the present disclosure, several approaches can be used to include a sub-patterns in a parent pattern, including, for example:\n\n","When embedding a pattern within a template, the content provider checks to ensure that the implementation type of the embedded content is compatible with the containing template. When materializing a pattern, the context in which such operations are performed is typically needed. Such a context is referred to herein as a generation context. The generation context is the set of resources available when the pattern is materialized. These available resources are accessible in the template as variables.","A generation such as that just described can include, for example:\n\n","When materializing a pattern, it may also be desirable to provide for context binding. For example, when including a pattern inside a template, the parent's generation context can be bound to the sub-pattern. The property values of a sub-pattern can be bound from the parent, for example, in the following order:\n\n","When using polymorphic inclusion, a template context can be created for each object in the polymorphic collection. These object-level template contexts are bound after simple binding is done. Also, as will be appreciated, it is important that any cycles in the parent\/child relationships that may exist in more complex patterns when expanding those patterns be detected (e.g., in order to avoid a sub-pattern including its parent). Further, extensibility framework architecture  supports the use of a common namespace, which can be implemented, for example, as a common namespace file. Such a common namespace file can be specified such that a template can import the file, in order to specify the namespace (and namespace prefix) of the element(s) in the template.",{"@attributes":{"id":"p-0161","num":"0208"},"figref":["FIG. 9","FIG. 7"],"b":["900","720","700"]},"Among other functionalities provided by metadata management architecture  is metadata reflection (in the manner of the reverse-translation mentioned earlier herein). As noted earlier, an artifact is an abstraction that imbues a piece of a runtime metadata with a meaning, and can also provide information that allows properties to be retrieved from runtime metadata.  depicts various elements within extensibility framework architecture  that support metadata reflection.","Central to metadata management architecture  is an artifact manager , which is comparable, in at least certain of its features and functionalities, to artifact manager  of . Artifact manager  is designed to access both artifact information and metadata via facilities provides by metadata management architecture . Artifact manager  acts as the entry point from which other components within extensibility framework architecture  can retrieve information regarding a given artifact, such as an artifact description (described below). With respect to such artifacts, artifact manager  accesses an artifact registry , which, in turn, provides access to artifact registry storage  via an artifact registry adapter .","In response to this request, artifact registry storage  provides one or more artifact descriptions, depicted in  as artifact descriptions ()-(N), to artifact registry  via artifact registry adapter . Artifact descriptions ()-(N) can be implemented, for example, as a class that represents the information about an artifact. In fact, a list of artifacts can be obtained from artifact registry . Artifact registry , typically, maintains artifacts for only the runtime metadata that is extensible. Artifact registry  uses artifact registry adapter  to retrieve the requisite information (e.g., a list of artifacts) from its physical storage (i.e., artifact registry storage ). As will be appreciated, artifact registry , artifact registry adapter  and artifact registry storage  are comparable, in at least certain respects of their functionality, to artifact registry  of . The output of artifact registry  is a list of artifact descriptions (artifact descriptions ()-(N)). In certain embodiments, artifact descriptions ()-(N) contain only basic information about the artifacts (e.g., artifact name(s), artifact kind(s), artifact purpose(s) and the like).","Once artifact descriptions ()-(N) have been retrieved, artifact manager  proceeds with retrieving the requisite metadata for the injection process. Each artifact kind in artifact descriptions ()-(N) maps to a resource access profile (an example of which depicted in  as a resource access profile ). For each artifact description returned from artifact registry , then, the given artifact description's resource access profile (e.g., resource access profile ) is identified and used by a resource manager  in accessing the appropriate runtime metadata storage. It will be appreciated that, in light of the present disclosure, an artifact may be mapped to multiple resources, with each resource designed to manage a subset of the artifact's properties (e.g., label(s), validator(s) or other such properties).","For each resource, metadata management architecture  typically includes a corresponding resource adapter that is responsible for retrieving the properties from the resource's runtime storage (an example of which depicted in  as a resource adapter ), though other arrangements are within the scope of this disclosure (e.g., a resource adapter that supports multiple runtime metadata stores). A resource adapter such as resource adapter  returns an artifact's properties in the form of a resource description, on a per-artifact basis (an example of which is depicted in  as an artifact description ). In a manner comparable to that described with the other artifact descriptions of extensibility framework architecture , artifact description  can be implemented, for example, as a class that represents the information about an artifact. Resource adapter  accesses runtime metadata storage  to retrieve the desired runtime metadata (depicted in  as runtime metadata ). As will be appreciated, resource manager , resource adapter  and runtime metadata storage  are comparable, in at least certain respects of their functionality, to adapter () and metadata repository  of .","Artifact manager  then merges the resource descriptions received from the artifact registry (e.g., artifact descriptions ()-(N)) and resource manager  (e.g., artifact description ). The merged resource descriptions are now ready to be returned to the module of extensibility framework architecture  that invoked artifact manager  (e.g., plan processing module , metadata service , or other module of extensibility framework architecture  tasked with interfacing with artifact manager ). In the case in which a new artifact has been created, artifact manager  is also responsible for saving this artifact into artifact registry .","Resource manager  can also be employed to remove one or more artifacts from the runtime metadata (e.g., the runtime metadata in runtime metadata storage ). In certain embodiments, for example, an artifact stores a set of locators for each of its aspects. Each of these locators identifies where the artifact resides in the runtime metadata. For each such locator, the artifact kind is identified. Based on the artifact kind, a resource access file is obtained. As noted earlier, a resource adapter can be identified for each resource identified by the resource access file. This facilitates the identification of the resource adapter for the given resource. Once the resource adapter in questions has been identified thusly, a \u201cdelete\u201d operation can be invoked in the resource adapter using the corresponding locator. The resource adapter then executes the \u201cdelete\u201d operation on the underlying metadata storage (i.e., runtime metadata storage ). For example, using the metadata services example presented in , the resource adapter simply deletes the artifact in question.","In certain embodiments, a command log (not shown) may be maintained as part of metadata management architecture , or elsewhere within extensibility framework architecture . Such a command log maintains information regarding the creation, modification, and so on, performed for each artifact created, modified, etc., in extensibility framework architecture . In so doing, a history of these operations is kept, allowing a determination to be made as to the manner in which the affected artifacts are extended or otherwise altered. In the case of a system upgrade, such a command log allows an artifact to be regenerated based on the commands kept in the command log.",{"@attributes":{"id":"p-0170","num":"0217"},"figref":["FIG. 10","FIG. 7","FIG. 11"],"b":["700","1000","1000","705","1010","1020"]},{"@attributes":{"id":"p-0171","num":"0218"},"figref":"FIG. 11","b":["705","1100","1110","1120","1130","1110","1120","1140","1100","1140"]},{"@attributes":{"id":"p-0172","num":"0219"},"figref":["FIG. 12","FIGS. 10, 11 and 12","FIG. 12","FIG. 11","FIG. 12"],"b":["1200","1210","730","1220","736","1230","1240","1250","1260","1270"]},"The extensibility provided by an extensibility framework architecture such as extensibility framework architecture , in terms of runtime extensibility, provides several benefits, in the manner noted earlier herein. For example, a self-service programmer can extend and configure applications without having to write computer code. In certain implementations, such a programmer can make changes using a browser-based interface, which can, in turn, provide support to such users through the provision of wizards and flows. Further, the desired changes can be applied to the application without the need for restarting or re-deploying the application. Further still, such extensibility can be \u201cadditive and optional,\u201d being implemented only if doing so will enhance and augment the self-service programmer's use of the application.",{"@attributes":{"id":"p-0174","num":"0221"},"figref":["FIG. 13","FIG. 13","FIG. 7","FIG. 13"],"b":["700","1300","1300","1310","1315","1315","734","1315","1310","1315","1315","1320","1322","1324","1326","1328"]},"In turn, these adapters provide an interface between pattern  (and so generation layer ) and a number of application programming interfaces (API). As will be appreciated in light of the present disclosure, the adapters of generation layer  can provide access to a wide array of possible APIs. Among the possible APIs to which the adapters of generation layer  can provide access are those shown in extensibility framework implementation , which include an application development framework (ADF) API , a service-oriented architecture (SOA) API , a web API , a repository definition web service API  and a service policy API . In certain embodiments, ADF API  is used to support extensibility of user interfaces, data models, schema definitions (e.g., XML schema definitions), and other components of the given extensibility framework. Service policy API  also supports extensibility by facilitating functional grants.","Application development framework API , service-oriented architecture API  and web API  interface their corresponding adapters in generation layer  to a metadata services artifact repository . Metadata services artifact repository  stores a variety of artifacts, among them ADF artifacts, SOA artifacts, web artifacts, and the like. Metadata services artifact repository  is, for purposes of the present discussion, comparable to metadata repository  depicted in . It therefore follows that application development framework adapter , service-oriented architecture adapter , and web adapter  are comparable to various ones of adapters ()-(N) of . Pattern , via repository definition adapter  and repository definition web service API , interfaces to a repository definition store . Repository definition store , in turn, provides repository definitions for metadata services artifact repository . In certain implementations, repository definition store  includes repository definitions that define fact tables and dimension tables (described subsequently, e.g., in connection with ). Similarly, pattern  is provided with access, via service policy API , to a policy store  via services adapter  and service policy API . In certain implementations, policy store  can be accessed via service policy API  using the Lightweight Directory Access Protocol mentioned earlier, in order to facilitate the management of access to the policy records therein.",{"@attributes":{"id":"p-0177","num":"0224"},"figref":["FIG. 14A","FIG. 7","FIG. 14A","FIG. 7"],"b":["700","1400","1400","1410","700","700","1410","1412","1414","1416","1412","1400","1414","1400","1410","1416","1410","1410","1416","744","1340","1400"]},"In the manner depicted in , extensibility framework  interfaces with a configuration interface , which allows a self-service programmer (e.g., an administrator or other user) to customize software components using extensibility framework . In a manner comparable to that described earlier, extensibility framework  receives one or more commands from configuration interface  and, in turn, interacts with one of several interfaces in performing the operations specified by one or more plans identified in the command(s) received. To this end, extensibility framework  interfaces with an application development framework API , metadata services  and\/or a flex field API . Flex field API  facilitates the use of constructs such as extension columns and extension tables in implementations constructed in the manner of extensibility framework architecture implementation . Extensibility framework architecture implementation  provides access to metadata artifacts via a composer interface . Composer interface  provides an easy-to-use, declarative and programmable extensibility mechanism for customizing runtime editing to address, for example, end-user application requirements. Composer interface , which can be implemented as a browser-based platform, provides such functionality by providing access to metadata services  via a composer framework  and flex field API , while bypassing extensibility framework  and its components. Composer framework , in turn, provides a framework on which to build such customizable application pages.","Whether accessed using configuration interface  or composer interface , metadata services , in turn, provide access to a set of metadata artifacts (depicted in  as metadata artifacts ). Metadata artifacts  include base artifacts , as well as extended artifacts . Base artifacts  can include, for example, constructs such as view objects, pages, page fragments, task flows, page definitions, and the like. Extended artifacts  can include, for example, constructs such as composer artifacts, flex extended metadata, and the like. In addition to configuration interface  (which is intended for use by self-service programmers) and composer interface  (which is intended for use by programmers), programmers can also access metadata services  and metadata artifacts  directly using a development interface .","In order for an extensibility framework implementation to support the generation of customization according to embodiments of the present invention, as well as runtime generation, a number of functionalities can be provided. For example, the module or application to be customized should be compatible with the extensibility framework (e.g., with respect to certain of the examples herein, metadata should be used to define content). Further, it is preferable that content not be coded, but rather generated. Such metadata should also employ runtime APIs to facilitate extension and\/or the addition of content. Also, such metadata should use and\/or integrate with the development framework employed (e.g., ADF) as the basis for data\/objects. Such modules and applications preferably also read metadata at runtime without the need for server restart, and should define appropriate patterns for extensibility.","Further, and as will be appreciated from the present disclosure, various types of extensibility can be provided through extensibility framework implementation . For example, types of constructs which can be made customizable, in an extensibility framework implementation according to embodiments of the present invention, include entities, attributes and relationships, and user interfaces, for example. Using these constructs as an example, once one or more extensible entities have been designated, new top-level entities (e.g., a Lease) and new child entities (e.g., Opportunity Decision Issues) can be added. Once such entities are added, their attributes and relationships can be extended by adding new attributes, as well as creating new \u201cRelationships\u201d (which employ foreign key (FK)-based relationships) and new \u201cContext Links\u201d (which do not employ FK-based relationships). In light of the foregoing extensions, the associated extensible user interface can be extended by creating a work area landing page. In one embodiment, one landing page is created for each (customized) entity, for example. Once a landing page has been created, the new attributes are exposed in pre-designated user interface elements. For a new \u201cContext Link\u201d relationship, a tree node (a child of entity \u201cCustomer\u201d) is created, while for a new \u201cRelationship,\u201d a new sub-tab is created (though in this case, a parent entity page needs to be a sub-tab user interface).","Extensibility framework implementation  also supports other type of extensibility. Other extensibility types include extensible services, extensible workflow events, extensible analytics, and extensible import\/export. Operations involved in the extension of services include, for example, the addition of new attributes as elements in an entity's payload XML schema definition (XSD) and the creation of new payload XSD for the (customizable) entity. Extensible analytics provide functionality that includes, for example, providing custom attributes in existing reports, creating new reports using custom and standard entities, supporting drill-down and roll-up, and supporting group-by and aggregation operations. Support for extensible workflow events includes, for example, the creation of email notification, the updating of dependent fields, the creation of user tasks, and the sending of outbound services. Support for extensible import\/export operations includes, for example, providing custom attributes in existing import\/export operations and supporting import\/export for custom entities.","Further still, the various extensibility types in an extensibility framework implementation can be \u201cpre-seeded\u201d (i.e., pre-configured), and so provide pre-configured metadata artifacts (e.g., pre-configured middleware metadata artifacts). Such pre-configuration can be accomplished using a development interface such as development interface , and includes pre-configured artifacts for data extensibility, user interface extensibility, data security extensibility, functional security extensibility, business event extensibility, analytics extensibility, and web service extensibility, among other possible pre-configured artifacts.","With regard to data extensibility, pre-configured artifacts can include flex columns in the base table, entity object attributes for flex columns in base entity object, child extension tables on a per base parent table basis, a child entity object for each child extension table, providing an association between a parent entity object and a child entity object, providing a top-level extension table (e.g., on a per logical business area (LBA) basis), providing a top-level extension entity object for each extension table, and allowing a resource bundle override on a per application basis. With regard to user interface extensibility, a customizable unbound task flow is provided for adding new work area, as is an application menu for adding new menu items.","An entity object according to embodiments of the present invention is an extensibility framework component that represents a row in the specified data source and simplifies modifying its associated attributes. Importantly, it facilitates the encapsulation of domain business logic, which, in turn, helps to ensure that business policies and rules are validated in a consistent fashion. Entity objects support numerous declarative business logic features to enforce the validity of data. Such constructs not only provide for declarative validation, but also provide for additional custom application logic and business rules, thereby facilitating encapsulation of the requisite domain business logic into each entity object.","Entity objects thus support the implementation of a variety of conceptual features in an extensibility framework according to embodiments of the present invention. For example, an entity object is defined, at least in part, by specifying the database table, the rows of which the entity object represents. As such, a self-service programmer can create associations between such rows, in order to reflect relationships between entity objects (e.g., using a view link, as described subsequently). Further, at runtime, an entity object's database table row(s) (also referred to herein as entity row(s)) can be managed using an entity definition object corresponding to the given entity object. Each such entity row can be identified, for example, by a corresponding row key, for example. Further, such entity rows are retrieved and modified in the context of an application module (or more simply, an application) that provides the database transaction.","With regard to data security extensibility, a parameterized instance set is provided for top-level extension tables, as well as the granting of certain privileges to pre-defined roles. With regard to functional security extensibility, privileges can also be granted to pre-defined roles. Additionally, source code grants in Java authorization data can be provided to allow access to the service policy API (e.g., service policy API ). With regard to business events extensibility, the architecture can provide for the annotation of attributes in a given email template, for example. With regard to analytics extensibility, provision can be made for flex attributes in an entity object for a view object, and similarly, flex columns in the physical and logical tables of repository definition store  can be provided. In providing such analytics extensibility, however, the architecture should ensure that a given view object is a superset of the user interface view object attributes (e.g., by ensuring that the attribute names match). With regard to web service extensibility, extensibility can be provided in several ways, including, for example, the provision of a polymorphic view object (e.g., on a per base view object basis), for XSD generation. Web service extensibility can also be facilitated through the provision of view links, which link a base view object and a polymorphic view object. A top-level polymorphic view object (e.g., on a per LBA basis) can also be provided, in order to facilitate web service extensibility.","A view object, according to embodiments of the present invention, is an extensibility framework component that provides various features and advantages, including the encapsulation of one or more database queries (e.g., SQL queries), as well as simplifying working with the results thereof. Several types of view objects can be implemented in an extensibility framework according to embodiments of the present invention, including, for example, read-only view objects, entity-based view objects (to allow data updates to be performed), static data view objects (e.g., for data defined by the view object itself), and programmatically-populated view objects, among others. An entity-based view object (i.e., a view object based on an entity object) can be configured to support updatable rows, and so, such view objects can map their attributes to the attributes of one or more existing entity objects. Such a mapped entity object is saved as an entity usage in the view object's view object definition. In this way, entity-based view objects can cooperate with entity objects, and so provide for an updatable data model. The entity-based view object can then query just the data needed for the client-facing task, and rely on its mapped entity object(s) to validate and save changes made to its view rows Like the read-only view object, an entity-based view object provides for the encapsulation of one or more queries, can be linked into master-detail hierarchies, and can be used in the data model of applications.","Various embodiments of the present invention provide read-only view objects having unique runtime features. For example, in certain embodiments, view objects with no entity usage definition are read-only by default. Such read-only view objects therefore do not acquire entity-derived default values, do not reflect pending changes, and do not reflect updated reference information, among other such characteristics. In contrast to entity-based view objects, read-only view objects require a user to program a query using the applicable query language (e.g., SQL query language). Additionally, as an alternative to creating view objects that specify queries (e.g., a SQL statement) at design time, entity-mapped view objects can be created that dynamically generate queries (e.g., a SQL statements) at runtime.","Various embodiments of the present invention provide entity-based view objects having unique runtime features. For example, in certain embodiments, if a view object has one or more underlying entity usages, new rows can be created, and queried rows, modified or removed. An entity-based view object according to embodiments of the present invention coordinates with underlying entity objects to enforce business rules and to save changes to the database. In addition, entity-based view objects can also provide various capabilities that do not exist with read-only view objects. For example, changes in cached information (updates, inserts, deletes and so on) managed by an entity are persisted (i.e., survive) the view object's execution boundary. Further in this regard, changes made to relevant entity object attributes through other view objects in the same transaction are immediately reflected throughout those entity objects in the same transaction affected by such changes, and attribute values of new rows can be initialized to the values from the underlying entity object attributes. Further still, changes to foreign key (FK) attribute values result in reference information being updated. An updatable view object can be defined by referencing attributes from one or more entity objects, with view links defined based on underlying entity associations. It will be appreciated that such entity-based view objects are typically used in the context of the application facilitating the transaction.",{"@attributes":{"id":"p-0191","num":"0238"},"figref":["FIG. 14B","FIG. 14B"],"b":"1410"},{"@attributes":{"id":"p-0192","num":"0239"},"figref":["FIG. 14C","FIG. 14C"]},{"@attributes":{"id":"p-0193","num":"0240"},"figref":["FIG. 15","FIG. 15","FIG. 15","FIG. 15","FIG. 15"],"b":["1500","1510","1","230","1520","1","1501","1","1520","1"]},"As is further illustrated in , application database () is structured according to an extensible database schema . Extensible database schema  includes a base table , which, in turn, includes base columns  and flex columns . Extensible database schema  also includes a child extension table  for base table . Child extension table , in turn, includes system columns  and flex columns . Further still, extensible database schema  also includes a top-level entity extension table . Top-level entity extension table , in turn, includes system columns  and flex columns .","The foregoing description provides an example of the pre-configuration that can be effected in an extensibility framework database architecture according to embodiments of the present invention (e.g., via one or more of configuration interface , composer interface  or development interface ). In the example depicted in , flex columns  of base table  are depicted as being pre-configured. Also pre-configured are child extension table  (e.g., one child extension table per base table) and top-level entity extension table  (e.g., one top-level entity table per LBA).","In the manner noted throughout the present disclosure (and with regard to the extensibility types noted earlier), patterns can be employed to provide a variety of extensible features for each of the aforementioned extensibility types. For example, in the manner noted earlier with regard to data extensibility, pre-configured artifacts can include a child extension table, a top-level entity extension table, and\/or flex columns (e.g., in the base table, the child extension table, and\/or the top-level entity extension table). Patterns that provide such extensibility are presented in Table 1 as data model extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features. As noted in Table 1, a pattern such as a create custom attribute pattern uses flex columns in a base table, and generates, for example, an attribute in view object, a label, flex metadata and\/or the like. Table 1 also includes a create child entity pattern, which uses a child extension table (e.g., on a per base parent table basis) to generate, for example, a child entity view object, which can, in turn, can have its flex columns used to create new attributes (in a manner comparable to that just noted). Also included in Table 1 is a create top-level entity pattern, which uses a top-level extension table and a top-level extension entity object for the extension table to generate a top-level entity view object, flex metadata and\/or the like.",{"@attributes":{"id":"p-0197","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Model Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-configured",{}]},{"entry":["Pattern Name","Extensibility Elements","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Create custom attribute","Flex columns in a base table","Attribute in view object"]},{"entry":[{},"Entity object attributes for","Label in override resource bundle"]},{"entry":[{},"flex columns","Flex metadata"]},{"entry":[{},"Resource bundle override"]},{"entry":[{},"per application"]},{"entry":["Create custom pick list","Same as custom attribute","FK attribute in source view object"]},{"entry":["attribute",{},"Accessing target view object in the pick list"]},{"entry":["(supports, e.g., an M:1",{},"View access in source view object"]},{"entry":["relationship between",{},"List binding in source view object"]},{"entry":["source and target view",{},"View criteria in target view object"]},{"entry":["objects)",{},"Flex metadata"]},{"entry":["Create child entity","Child extension table per","Child entity view object"]},{"entry":[{},"base parent table","Master-detail relationship"]},{"entry":[{},"Child entity object for child","View link between parent and child"]},{"entry":[{},"extension table","view objects"]},{"entry":[{},"Association between parent","View link usage in application module"]},{"entry":[{},"and child entity objects","Flex metadata"]},{"entry":["Create top-level entity","Top-level extension table","Top-level entity view object"]},{"entry":[{},"per LBA","View usage in application module"]},{"entry":[{},"Top-level extension entity","Flex metadata"]},{"entry":[{},"object for extension"]},{"entry":[{},"table"]},{"entry":["Top-level extension table","Top-level extension table","Top-level extension table per LBA"]},{"entry":["per LBA","per LBA","Top-level extension entity object for"]},{"entry":["Top-level extension entity","Top-level extension entity","extension table"]},{"entry":["object for extension","object for extension"]},{"entry":["table","table"]},{"entry":["Create 1:M relationship","None","FK attribute in target view object"]},{"entry":["between source and",{},"Reference relationship"]},{"entry":["target view objects",{},"View link between source and target"]},{"entry":[{},{},"view objects"]},{"entry":[{},{},"View link access in target view object"]},{"entry":[{},{},"View link usage in application module"]},{"entry":[{},{},"Generate flex metadata"]},{"entry":["Create Saved Search","None","View criteria on the queried view object"]},{"entry":["Create context link","None","View criteria on the queried view object"]},{"entry":["(joined query -",{},"View usage specific for view criteria"]},{"entry":"relationship w\/o FK)"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"With regard to user interface extensibility, a customizable unbound task flow is provided for adding new work areas, as is an application menu for adding new menu items. Patterns that provide such extensibility are presented in Table 2 as user interface extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features.",{"@attributes":{"id":"p-0199","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"User Interface Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-configured",{}]},{"entry":[{},"Extensibility"]},{"entry":["Pattern Name","Element","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Create user interface","None","User interface component in page fragment"]},{"entry":["component for",{},"Attribute or tree binding in page definition"]},{"entry":"custom attribute"},{"entry":["Create sub-tab in object","None","New page fragment for displaying sub-tab content"]},{"entry":["detail page for",{},"Empty display table and entry form in page"]},{"entry":["displaying child",{},"fragment"]},{"entry":["entities, reference",{},"Binding and iterator in page definition"]},{"entry":["entities, context",{},"Page mapping in binding context file"]},{"entry":["link results",{},"Attributes to display in new page fragment"]},{"entry":["(creates one-page task",{},"User interface component in page fragment"]},{"entry":["flow as well as the",{},"Attribute or tree binding in page definition"]},{"entry":["corresponding",{},"Task flow definition to contain the new page"]},{"entry":["region to display",{},"fragment"]},{"entry":["the task flow)",{},"Region to display sub-tab content in object detail"]},{"entry":[{},{},"page"]},{"entry":[{},{},"Region in object detail page fragment"]},{"entry":[{},{},"Task flow executable in object detail page"]},{"entry":[{},{},"definition"]},{"entry":["Create workflow area","Customizable unbound","One-page task flow for"]},{"entry":["for top-level entity","task flow to","Overview page"]},{"entry":[{},"reference custom","(local search component, object"]},{"entry":[{},"landing page","summary table)"]},{"entry":[{},"Application menu to","Object detail page"]},{"entry":[{},"reference custom","Object create page"]},{"entry":[{},"work list menu per","Object edit page"]},{"entry":[{},"work area","Regional search"]},{"entry":[{},"Include pre-configured","Landing page"]},{"entry":[{},"application menu","Java server page and page definition"]},{"entry":[{},"into the root menu","Insert new landing page in unbound task"]},{"entry":[{},"of the web","flow"]},{"entry":[{},"application","Update menu structure"]},{"entry":[{},{},"Task list menu for launching work area task"]},{"entry":[{},{},"flows"]},{"entry":[{},{},"Include task list menu in pre-seeded"]},{"entry":[{},{},"application menu"]},{"entry":[{},{},"Insert menu item in navigator menu for"]},{"entry":[{},{},"landing page"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"With regard to data security extensibility, a parameterized instance set is provided for top-level extension tables, as well as the granting of certain privileges to pre-defined roles. Patterns that provide such extensibility are presented in Table 3 as data security extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features.",{"@attributes":{"id":"p-0201","num":"0248"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Security Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-configured",{}]},{"entry":["Pattern Name","Extensibility Elements","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Create custom attribute","None","None"]},{"entry":"Same security as"},{"entry":"containing entity"},{"entry":["Create child entity","None","None"]},{"entry":"Same security as parent"},{"entry":"row"},{"entry":["Create top-level entity","Parameterized instance set","Data grant by"]},{"entry":["For standard operations","for top-level extension table","passing in entity"]},{"entry":["(Query, Update, Delete)","Privileges granted to","type as instance"]},{"entry":[{},"pre-defined role","set parameter"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"With regard to functional security extensibility, privileges can also be granted to pre-defined roles. Patterns that provide such extensibility are presented in Table 4 as functional security extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features.",{"@attributes":{"id":"p-0203","num":"0250"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Functional Security Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-configured",{}]},{"entry":["Pattern Name","Extensibility Elements","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Create custom user","None","None"]},{"entry":"interface"},{"entry":"component"},{"entry":"same security as"},{"entry":"containing page"},{"entry":"fragment"},{"entry":["Create child entity","None","Expression to evaluate parent row"]},{"entry":["sub-tab",{},"privileges"]},{"entry":["use parent row",{},"Task flow parameters for passing parent"]},{"entry":["privileges to",{},"row privileges into sub-tab task flow"]},{"entry":"control standard"},{"entry":"user interface"},{"entry":"actions in sub-tab"},{"entry":"task flow"},{"entry":["Create work area","Privileges granted to pre-","Create permission set for generated user"]},{"entry":["generate privileges","defined role","interface artifacts"]},{"entry":["for user interface","Source code grant in Java","Region privilege for landing page"]},{"entry":["artifacts","authorization data for","Task flow privilege for each task flow"]},{"entry":["use entity row","accessing service policy","Permission set to group privileges"]},{"entry":["privileges to","API","Functional grant for permission set"]},{"entry":["control standard",{},"Use entity row privileges for standard"]},{"entry":["user interface",{},"actions"]},{"entry":["actions in work",{},"Expression to evaluate entity row"]},{"entry":["area task flows",{},"privileges"]},{"entry":[{},{},"Task flow parameters for passing entity"]},{"entry":[{},{},"row privileges into work area task"]},{"entry":[{},{},"flow"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0204","num":"0251"},"figref":["FIG. 16","FIG. 16"],"b":["1600","1600","1610","1620","1630","1610","1640","1640","1642","1644","1642","1644","1645","1644","1646","1648"]},"In ADF layer , application module  includes a variety of definitional constructs that facilitate the definition of view object schemas in web service definition layer , and employ an object definition language in doing so. These schema definitions (e.g., view object schema definitions), in turn, facilitate the generation of runtime constructs in web service runtime layer . Further, one or more view links (e.g., view link ) can be generated between parent and child view objects, such as the base and polymorphic view object definitions of  (base view object definition  and polymorphic view object definition ). As noted above, polymorphic view object definition  is shown in  as including custom attribute  and custom view link , which are examples of custom\/customizable features available to a self-service programmer using web service extensibility architecture . Further still, as will be appreciated in light of the present disclosure, these (and other) constructs of polymorphic view object definition  facilitate the polymorphic nature of polymorphic view object definition .","Web service definition layer  includes information in a web service definition language , such as a base view object schema definition . In turn, base view object schema definition  can include elements such as a polymorphic view object schema definition . As can be seen in , application module  is defined in web service definition layer  using web service definition language , via the relationships between base view object definition  and base view object schema definition , as well as between polymorphic view object  and polymorphic object schema definition .","In web service definition layer , the view object definitions from ADF layer  serve as the basis for the view object schema definitions defined in web service definition layer  and implemented in web service definition language  (e.g., base view object schema definition  and polymorphic object schema definition ). Base view object schema definition , including polymorphic object schema definition , serves as a basis for a service implementation in web service runtime layer . As will be appreciated in light of the present disclosure, base view object schema definition  and polymorphic object schema definition  are database schema that provide for extensibility constructs and functionalities such as those described in connection with extensible database schema  of . More specifically, such extensibility constructs (and their associated functionalities) include, for example, flex columns  of base table , child extension table  (and so flex columns ), and top-level entity extension table  (and so flex columns ).","As noted, base view object schema definition  (and so, polymorphic view object schema definition ) serve as the basis for a service implementation (an example of which is depicted in  as service implementation ), which is an element of web service runtime layer . In supporting extensibility, service implementation  takes as input a base view object service data object . Base view object service data object  includes a polymorphic view object service data object . Base view object service data object  and polymorphic view object service data object  provide extensibility constructs which define a universe within which a self-service programmer can create, modify and remove constructs and functionality as necessary, in order to achieve their intended results. Based on such inputs (e.g., schema definitions, data objects, their polymorphisms, and other such extensibility constructs and inputs), service implementation  produces, as output, a base view object row , which comprehends (or can comprehend) a polymorphic view object row . As will be appreciated, extensibility constructs such as those depicted in  facilitate the extensibility of view object rows such as base view object row  and polymorphic view object row .","As noted earlier herein, web service extensibility can be provided in a number of ways, including, for example, the provision of polymorphic view objects for XSD generation. Patterns that provide such extensibility are presented in Table 5 as web service extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features.",{"@attributes":{"id":"p-0210","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Web Service Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Pattern","Pre-configured",{}]},{"entry":["Name","Extensibility Elements","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Create","Polymorphic view object for","View object attribute in"]},{"entry":["custom","XSD generation","polymorphic view object"]},{"entry":["attribute","View link for base view object","XSD for polymorphic view"]},{"entry":[{},"to polymorphic view object","object"]},{"entry":["Create","Same as custom attribute","View link in polymorphic"]},{"entry":["child",{},"view object"]},{"entry":["entity",{},"XSD for polymorphic view"]},{"entry":[{},{},"object"]},{"entry":[{},{},"XSD for the child entity"]},{"entry":["Create","\u201cProxy\u201d polymorphic view","View link from proxy view"]},{"entry":["top-level","object for XSD generation","object to custom entity"]},{"entry":["entity","Web services description","view object"]},{"entry":[{},"language constructs and","XSD for the proxy view"]},{"entry":[{},"service implementation","object"]},{"entry":[{},{},"XSD for custom entity view"]},{"entry":[{},{},"object"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"With regard to business events extensibility, the architecture can provide for the annotation of attributes in a given email template, for example. Patterns that provide such extensibility are presented in Table 6 as business events extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features.",{"@attributes":{"id":"p-0212","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Business Event Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-configured",{}]},{"entry":["Pattern Name","Extensibility Elements","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Event","None","Event definition"]},{"entry":[{},{},"Event publication"]},{"entry":["Action - email","Annotate attributes available in","HTML email"]},{"entry":["notification","email template","template"]},{"entry":[{},"Email notification in process"]},{"entry":[{},"execution language process"]},{"entry":[{},"(e.g., one for all apps)"]},{"entry":["Action - field update","Field update in process","None"]},{"entry":[{},"execution language process"]},{"entry":[{},"(e.g., one for all apps)"]},{"entry":["Action - task","Task creation in process","None"]},{"entry":["creation","execution language process"]},{"entry":[{},"(e.g., one for all apps)"]},{"entry":["Action - outbound","Outbound web service in","None"]},{"entry":["web service","process execution language"]},{"entry":[{},"process (e.g., one for all"]},{"entry":[{},"apps)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0213","num":"0260"},"figref":"FIG. 17","b":["1700","1700","1710","1710","1530","1710"]},"Extensible analytics architecture  also includes an application development framework , which includes objects based on the structures of extensible database schema . Thus, extensible database schema  provides a universe in which a self-service programmer (using application development framework ) is able to define, create, modify and\/or delete a wide variety of extensible features using a simple, efficient and intention-based paradigm. Application development framework , in turn, produces the structures illustrated in  as a repository definition , based on the objects made available in application development framework  for use (e.g., extension) through extensible database schema .","As just noted, extensible database schema  includes elements comparable to those of database schema , as noted. Such elements are included, for example, in an application database structured according to extensible database schema . Extensible database schema  includes a customer base table , which, in turn, includes base columns  and flex columns . Extensible database schema  also includes a child extension table  for customer base table . Child extension table , in turn, includes system columns  and flex columns . Further still, extensible database schema  also includes a top-level entity extension table . Top-level entity extension table , in turn, includes system columns  and flex columns .","Based on extensible database schema , a self-service programmer is able to work with a variety of objects in application development framework , in order to generate a repository definition (e.g., repository definition ). Among such objects are, for example, a customer view object , a loan view object  and a collateral view object . These objects provide the requisite underpinnings for application development framework  to generate repository definition .","In the example illustrated in , repository definition  includes the results of customizing the aforementioned objects using one or more patterns. In the example depicted in , the artifacts thus generated include a loan dimension table  having one or more dimension columns . Repository definition  also includes a new fact table  having foreign key (FK) columns  and measures columns . As will be appreciated in light of the present disclosure, a foreign key is typically a primary key of an entity to which the foreign key is related. As will be further appreciated, in terms of a database environment (e.g., a relational database), a foreign key is used in conjunction with the attributes of a weak entity (i.e., an entity that cannot be uniquely identified by its attributes alone) to create a primary key. FK column  can, in turn, reference other dimension tables, for example, a data dimension table  and a collateral dimension table  (itself having one or more dimension columns ).","Table 7 presents a variety of analytic extensibility example use cases, which demonstrate the extension (extensibility operation) performed, the table type involved (e.g., in the examples presented in Table 7, a fact table or dimension table).",{"@attributes":{"id":"p-0219","num":"0266"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Analytic Extensibility Example Use Cases."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Extension","Table Type","Mapping","View Object"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Add new","Fact Table","New attributes go into existing","New attributes are added"]},{"entry":["attributes",{},"fact table as measures or as","to existing view"]},{"entry":[{},{},"dimension foreign keys","object for the"]},{"entry":[{},{},"(date)","underlying object"]},{"entry":[{},"Dimension Table","New attributes added to existing","New attributes are added"]},{"entry":[{},{},"dimension and are used as","to existing view"]},{"entry":[{},{},"display attributes","object for the"]},{"entry":[{},{},{},"underlying object"]},{"entry":["Add new child","Fact Table","Support creation of a new fact","Create new view object"]},{"entry":["object",{},"table using child as grain","for new fact"]},{"entry":[{},{},"level"]},{"entry":[{},"Dimension Table","Create new dimension table for","Create new view object"]},{"entry":[{},{},"child and allow other facts to","for new dimension."]},{"entry":[{},{},"join to this (e.g., parent fact","Add view links to"]},{"entry":[{},{},"table)","existing fact view"]},{"entry":[{},{},{},"objects"]},{"entry":["Add new top-","Fact Table","Support creation of a new fact","Create new view object"]},{"entry":["level object",{},"table using top-level object","for new fact"]},{"entry":[{},{},"as grain. This object can be"]},{"entry":[{},{},"the primary fact for a new"]},{"entry":[{},{},"star."]},{"entry":[{},"Dimension Table","Create new dimension table for","Create new view object"]},{"entry":[{},{},"top-level object and allow","for new dimension."]},{"entry":[{},{},"other facts to join to this (for","Add view links to"]},{"entry":[{},{},"related objects)","existing fact view"]},{"entry":[{},{},{},"objects"]},{"entry":["Add new","Fact Table","Support creation of a (new) new","Create new view object"]},{"entry":["relationship",{},"fact table using the related","for new Fact"]},{"entry":[{},{},"objects as grain level"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"In general terms, analytics extensibility can be provided in a number of ways, including the provision of flex attributes in an entity object, and similarly, flex columns in the physical and logical tables of the resulting repository definition store. Patterns that provide such extensibility are presented in Table 8 as analytics extensibility example patterns, which employ the pre-configured extensibility elements listed therein, and so can be used to generate a variety of such extensible features.",{"@attributes":{"id":"p-0221","num":"0268"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Analytic Extensibility Example Patterns."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-configured",{}]},{"entry":["Pattern Name","Extensibility Elements","Generates"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Add Custom","Flex attribute in entity","View object attributes"]},{"entry":["Attribute to","object for view object","in view object"]},{"entry":["\u201cReport Type\u201d","Flex columns in","Labels as session variables"]},{"entry":[{},"repository definition"]},{"entry":[{},"physical and"]},{"entry":[{},"logical tables"]},{"entry":["Create New","None","Fact and dimension view object"]},{"entry":["Report type",{},"Fact and dimension repository"]},{"entry":["using standard",{},"definition physical tables"]},{"entry":["and custom",{},"Physical column and table"]},{"entry":["entities",{},"Physical key"]},{"entry":[{},{},"Dimension repository definition"]},{"entry":[{},{},"logical tables"]},{"entry":[{},{},"Logical column and table"]},{"entry":[{},{},"Default dimension hierarchy"]},{"entry":[{},{},"Fact repository definition"]},{"entry":[{},{},"logical tables"]},{"entry":[{},{},"Logical column and table"]},{"entry":[{},{},"Measure definition"]},{"entry":[{},{},"Join with dimension table"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"An Example Computing and Network Environment","As shown above, the present invention can be implemented using a variety of computer systems and networks. An example of one such computing and network environment is described below with reference to .",{"@attributes":{"id":"p-0224","num":"0271"},"figref":"FIG. 18","b":["1810","620","650","660","665","1810","1812","1810","1814","1817","1818","1820","1822","1824","1826","1828","1830","1832","1833","1834","1837","1838","1835","1890","1835","1839","1840","1842","1846","1812","1828","1847","1812","1830","1848","1812"]},"Bus  allows data communication between central processor  and system memory , which may include read-only memory (ROM) or flash memory (neither shown), and random access memory (RAM) (not shown), as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded. The ROM or flash memory can contain, among other code, the Basic Input-Output system (BIOS) which controls basic hardware operation such as the interaction with peripheral components. Applications resident with computer system  are generally stored on and accessed via a computer-readable medium, such as a hard disk drive (e.g., fixed disk ), an optical drive (e.g., optical drive ), a floppy disk unit , or other storage medium.","Storage interface , as with the other storage interfaces of computer system , can connect to a standard computer-readable medium for storage and\/or retrieval of information, such as a fixed disk drive . Fixed disk drive  may be a part of computer system  or may be separate and accessed through other interface systems. Modem  may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider (ISP). Network interface  may provide a direct connection to a remote server via a direct network link to the Internet via a POP (point of presence). Network interface  may provide such connection using wireless techniques, including digital cellular telephone connection, Cellular Digital Packet Data (CDPD) connection, digital satellite data connection or the like.","Many other devices or subsystems (not shown) may be connected in a similar manner (e.g., document scanners, digital cameras and so on). Conversely, all of the devices shown in  need not be present to practice the present invention. The devices and subsystems can be interconnected in different ways from that shown in . The operation of a computer system such as that shown in  is readily known in the art and is not discussed in detail in this application. Code to implement the present invention can be stored in computer-readable storage media such as one or more of system memory , fixed disk , optical disk , or floppy disk . The operating system provided on computer system  may be MS-DOS\u00ae, MS-WINDOWS\u00ae, UNIX\u00ae, Linux\u00ae, or another known operating system.","Moreover, regarding the signals described herein, those skilled in the art will recognize that a signal can be directly transmitted from a first block to a second block, or a signal can be modified (e.g., amplified, attenuated, delayed, latched, buffered, inverted, filtered, or otherwise modified) between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next, other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and\/or functional aspect of the signal is transmitted between blocks. To some extent, a signal input at a second block can be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved (e.g., there will inevitably be some attenuation and delay). Therefore, as used herein, a second signal derived from a first signal includes the first signal or any modifications to the first signal, whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and\/or final functional aspect of the first signal.",{"@attributes":{"id":"p-0229","num":"0276"},"figref":"FIG. 19","b":["1900","1910","1920","1930","1940","1940","1910","1950","1940","1960","1","1940","1960","1","1940","1940","1970","1970","1980","1","1940","1940","1110","1120","1130","1150","1190","1970"]},"With reference to computer system , modem , network interface  or some other method can be used to provide connectivity from each of client computer systems ,  and  to network . Client systems ,  and  are able to access information on storage server A or B using, for example, a web browser or other client software (not shown). Such a client allows client systems ,  and  to access data hosted by storage server A or B or one of storage devices A()-(N), B()-(N), ()-(N) or intelligent storage array .  depicts the use of a network such as the Internet for exchanging data, but the present invention is not limited to the Internet or any particular network-based environment.","The present invention is well adapted to attain the advantages mentioned as well as others inherent therein. While the present invention has been depicted, described, and is defined by reference to particular embodiments of the invention, such references do not imply a limitation on the invention, and no such limitation is to be inferred. The invention is capable of considerable modification, alteration, and equivalents in form and function, as will occur to those ordinarily skilled in the pertinent arts. The depicted and described embodiments are examples only, and are not exhaustive of the scope of the invention.","The foregoing describes embodiments including components contained within other components (e.g., the various elements shown as components of computer system ). Such architectures are merely examples, and, in fact, many other architectures can be implemented which achieve the same functionality. In an abstract but still definite sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermediate components. Likewise, any two components so associated can also be viewed as being \u201coperably connected,\u201d or \u201coperably coupled,\u201d to each other to achieve the desired functionality.","The foregoing detailed description has set forth various embodiments of the present invention via the use of block diagrams, flowcharts, and examples. It will be understood by those within the art that each block diagram component, flowchart step, operation and\/or component illustrated by the use of examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or any combination thereof, including the specialized system illustrated in .","The present invention has been described in the context of fully functional computer systems; however, those skilled in the art will appreciate that the present invention is capable of being distributed as a program product in a variety of forms, and that the present invention applies equally regardless of the particular type of computer-readable media used to actually carry out the distribution. Examples of computer-readable media include computer-readable storage media, as well as media storage and distribution systems developed in the future.","The above-discussed embodiments can be implemented by software modules that perform one or more tasks associated with the embodiments. The software modules discussed herein may include script, batch, or other executable files. The software modules may be stored on a machine-readable or computer-readable storage media such as magnetic floppy disks, hard disks, semiconductor memory (e.g., RAM, ROM, and flash-type media), optical discs (e.g., CD-ROMs, CD-Rs, and DVDs), or other types of memory modules. A storage device used for storing firmware or hardware modules in accordance with an embodiment of the invention can also include a semiconductor-based memory, which may be permanently, removably or remotely coupled to a microprocessor\/memory system. Thus, the modules can be stored within a computer system memory to configure the computer system to perform the functions of the module. Other new and various types of computer-readable storage media may be used to store the modules discussed herein.","The above description is intended to be illustrative of the invention and should not be taken to be limiting. Other embodiments within the scope of the present invention are possible. Those skilled in the art will readily implement the steps necessary to provide the structures and the methods disclosed herein, and will understand that the process parameters and sequence of steps are given by way of example only and can be varied to achieve the desired structure as well as modifications that are within the scope of the invention. Variations and modifications of the embodiments disclosed herein can be made based on the description set forth herein, without departing from the scope of the invention.","Consequently, the invention is intended to be limited only by the scope of the appended claims, giving full cognizance to equivalents in all respects.","Although the invention has been described in connection with several embodiments, the invention is not intended to be limited to the specific forms set forth herein. On the contrary, it is intended to cover such alternatives, modifications, and equivalents as can be reasonably included within the scope of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 14C"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
