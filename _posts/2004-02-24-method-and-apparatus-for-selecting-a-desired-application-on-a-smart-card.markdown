---
title: Method and apparatus for selecting a desired application on a smart card
abstract: Where there are potentially two or more applications installed on a smart card, with each application having a stored application identifier (AID), a desired application may be selected by specifying a desired application in terms of multiple parameters, retrieving multiple parameters from a stored AID for an application on the smart card, and comparing the specified multiple parameters with the retrieved multiple parameters to determine whether there is a match.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07140549&OS=07140549&RS=07140549
owner: Sun Microsystems, Inc.
number: 07140549
owner_city: Santa Clara
owner_country: US
publication_date: 20040224
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Appendix A","Appendix B","Appendix C","Appendix D","Appendix E","Appendix F"],"p":["This application is related to the following:\n\n","The present invention relates to the field of computer science. More particularly, the present invention relates to selecting a desired application on a smart card.","Most people now have a collection of small plastic cards, representing various credit cards, store cards, identity cards, membership cards, and so on. Information about the card and its owner, such as account details and so on, is normally printed or embossed on the card, and may also be stored in some form of magnetic strip. Note that such cards are simply passive storage devices, and the information that they contain is fixed at card creation time.","In recent years, smart cards have also proliferated. These are similar in scale to traditional credit cards, but incorporate within their plastic cases a microelectronic memory and also (optionally) an embedded processor. It will be appreciated that the computational resources available within a smart card are extremely limited compared to those of a desktop workstation, or even a laptop or handheld device. One especially popular form of smart card is known as a Java Card. This is based on the Java platform developed by Sun Microsystems (\u201cJava\u201d and \u201cJava Card\u201d are trademarks of Sun Microsystems Inc). In such devices, a Java virtual machine (VM) is provided within the smart card to allow the execution of Java applets or applications. Particular advantages of being able to use the Java environment for smart card applications are the inherent security features of the Java environment, plus the ready availability of software development packages for the Java programming language. It is estimated that by the end of 2002 over 200 million Java cards had been shipped. More information about the Java Card smart card platform is available from the page: \/products\/javacard\/ at the web site: http:\/\/java.sun.com and from the site: http:\/\/www.javacardforum.org\/.","An Application Programming Interface (API) is defined for the Java Card platform. Applications written in the Java programming language invoke this API to access the Java Card run-time environment (JRE) and any native services. The Java Card API allows application portability, in that the same application can run on any smart card that supports the API. The Java Card API is compatible with international standards, in particular the ISO\/IEC 7816 family of standards.","Note that programs that run on smart cards may be referred to as either an application or as an applet. It will be appreciated that there is a clear distinction between a Java applet and a Java application in a desktop environment, in particular the absence of a main class from the former. However, this distinction does not apply in the smart card environment. Thus applets for use on a Java card platform are not the same as applets that run on a web browser. The term applet will generally be used herein to refer specifically to code, and the term application to refer to the higher level functionality provided by the applet code and associated data (unless the context requires otherwise).","The Java Card platform supports multiple applications on a single card. These may be separated by firewalls, in order to ensure that they do not interfere with one another. This is particularly of concern if the various applications are operated by different organizations, whose business relationships with the cardholder may be independent of one another.",{"@attributes":{"id":"p-0009","num":"0011"},"figref":"FIG. 1","b":["102","101","110","108"]},"Terminal  may be a handheld device, an adjunct to a desktop workstation, a dedicated card reader (analogous to an ATM) or any other suitable system. Furthermore, the communications between the smart card  and the terminal  may be by wired connection, such as some form of bus (e.g. USB), or by wireless link (e.g. radio or some other electromagnetic signal), depending on the particular devices concerned. In addition, the terminal  may be under the direct control of an operator  (such as for a handheld terminal), or alternatively terminal  may be automated (such as for an ATM).","Terminal  interacts with a back office  over any suitable form of network , such as the Internet, a local area network (LAN), a wide area network (WAN), and so on. Back office  may comprise multiple systems (not explicitly shown in ), such as a web server or portal attached to network , perhaps with an application server and\/or a database system behind. Note that the terminal  may be off-line until activated by a smart card , a card holder  or a terminal operator  to access a back office  over network .","In operation, the cardholder  typically places the card  into or adjacent to the terminal , thereby allowing the two to interact, e.g. to perform a debit operation from the card, in order to purchase some goods. This interaction will generally be referred to herein as a session, and typically involves the exchange of multiple messages between the smart card  and the terminal . A session can be regarded as comprising multiple transactions, where each transaction represents the completion of some portion of the overall session (e.g. a security authorization).","Associated with each applet on smart card  is an Application Identifier (AID). The AID is a byte string up to 16 bytes long, whose format is defined by International Standard ISO\/IEC 7816-5. Thus according to this standard, the first 5 bytes of the AID represent the registered application provider identifier (RID) and have a value allocated by ISO or one of its member bodies. The RID generally indicates the merchant or other entity involved with operating the applet, hereinafter referred to as the RID operator. The RID operator is generally responsible for the back office program , and is depicted as application\/RID operator  in . The last 11 bytes of the RID constitute the proprietary application identifier extension (PIX). The PIX is determined by the RID operator , and can be used to store a reference number or other information associated with the applet.",{"@attributes":{"id":"p-0014","num":"0016"},"figref":"FIG. 1A","b":["102","161","161"]},"International standard ISO\/IEC 7816-4 defines a procedure to allow a terminal to locate a desired application on a smart card, and this is illustrated at a high level in the flowchart of . The procedure starts when the smart card  is first inserted into the terminal . The terminal detects the insertion of the smart card (reference numeral ), and in response to such detection activates the smart card (reference numerals , ). This activation typically includes providing power to the smart card.","The terminal now sends a request using an application protocol data unit (ADPU)  to the smart card (reference numeral ). The ADPU identifies the application to be used in this session in terms of its AID. The request from the terminal is received by the smart card (reference numeral ), typically within an applet selector program that is running on the smart card  as part of a card executive layer. The applet selector is then responsible for locating and launching the application that matches the AID request from the terminal, i.e. the application that has the same AID as specified in the request (reference numerals  and ). The smart card also returns the AID for the matching application back to the terminal  (reference numerals  and ). (N.B. Reference numerals  and  are optional within the context of ISO\/IEC 7816-4, although commonly implemented).",{"@attributes":{"id":"p-0017","num":"0019"},"figref":"FIG. 1C","b":["110","110"]},"The processing of  commences as just described for , except that at reference numeral  the request from the terminal  to the smart card  comprises only a partial AID. Consequently, the smart card may identify multiple matching applications at reference numeral . The AIDs for these matching applications are then returned to the terminal  (reference numerals , ), in order to allow the terminal (or user) to select a specific desired application from those matching the partial AID. Thus the terminal now sends a request to the smart card to launch an applet (reference numeral ). This request specifies the particular applet to be launched on the smart card in terms of its complete AID (generally selected from the set of those received from the smart card at reference numeral ). The smart card duly responds to this request by launching the applet selected by the terminal (reference numeral ).","In fact, the skilled person will realize that although  represents an appropriate logical model for the use of partial AIDs, the actual implementation looks more like  (primarily for historical reasons). Thus current systems generally accommodate the matching and return of multiple matching AIDs by identifying only a single matching AID at a time. In particular, the applet having the AID that is first matched to the partial AID received from the terminal is launched, and the complete AID for this applet is returned to the terminal . The smart card then only supplies a next matching AID upon a subsequent specific request from the terminal. Nevertheless, it will be appreciated that multiple matching AIDs could be handled in other ways, such as by returning the complete set of multiple matching AIDs all at once in a single response to the terminal (as depicted in ).",{"@attributes":{"id":"p-0020","num":"0022"},"figref":"FIG. 2","b":["210","215","102"]},"The card is now ready for issue to a cardholder (reference numeral ), which typically involves an appropriate personalization process, as well as initialization of the Java environment, and starting the Java virtual machine on the card. The cardholder is thereafter able to use the card (reference numeral ), such as in the manner illustrated schematically in . Note that if the card was originally issued without any preloaded applications, then the cardholder may have to load an application prior to making substantive use of the card. In practice however, this situation is rather uncommon, since usually there is at least one preloaded application in order to motivate issuance of the card in the first place.","During the operational lifetime of the card, further application programs may potentially be installed onto the card (reference numeral ), for example if the cardholder signs up to new accounts or services. Conversely, applications may be removed from the card, perhaps because an account is closed.","The last operation shown in  is where the card is terminated (reference numeral ). This may occur, for example, because the card has a built-in expiry date or is surrendered by the user (perhaps if the user is moving to a new card issuer, or the card is physically damaged).","Although the Java Card environment does support multiple applications from different RID operators, nevertheless, in practice, the installed applications on a large majority of issued cards come from and are run by a single RID operator. In other words, applications from one RID operator are typically found on one card, and applications from another RID operator on a different card. Consequently, relatively little attention has been paid to the business and technical problems associated with the provision and utilization of multi-vendor smart cards.","Where there are potentially two or more applications installed on a smart card, with each application having a stored application identifier (AID), a desired application may be selected by specifying a desired application in terms of multiple parameters, retrieving multiple parameters from a stored AID for an application on the smart card, and comparing the specified multiple parameters with the retrieved multiple parameters to determine whether there is a match.","Embodiments of the present invention are described herein in the context of selecting a desired application on a smart card. Those of ordinary skill in the art will realize that the following detailed description of the present invention is illustrative only and is not intended to be in any way limiting. Other embodiments of the present invention will readily suggest themselves to such skilled persons having the benefit of this disclosure. Reference will now be made in detail to implementations of the present invention as illustrated in the accompanying drawings. The same reference indicators will be used throughout the drawings and the following detailed description to refer to the same or like parts.","In the interest of clarity, not all of the routine features of the implementations described herein are shown and described. It will, of course, be appreciated that in the development of any such actual implementation, numerous implementation-specific decisions must be made in order to achieve the developer's specific goals, such as compliance with application and business-related constraints, and that these specific goals will vary from one implementation to another and from one developer to another. Moreover, it will be appreciated that such a development effort might be complex and time-consuming, but would nevertheless be a routine undertaking of engineering for those of ordinary skill in the art having the benefit of this disclosure.","In accordance with one embodiment of the present invention, the components, process steps, and\/or data structures may be implemented using various types of operating systems (OS), computing platforms, firmware, computer programs, computer languages, and\/or general-purpose machines. The method can be run as a programmed process running on processing circuitry. The processing circuitry can take the form of numerous combinations of processors and operating systems, or a stand-alone device. The process can be implemented as instructions executed by such hardware, hardware alone, or any combination thereof. The software may be stored on a program storage device readable by a machine.","In addition, those of ordinary skill in the art will recognize that devices of a less general purpose nature, such as hardwired devices, field programmable logic devices (FPLDs), including field programmable gate arrays (FPGAs) and complex programmable logic devices (CPLDs), application specific integrated circuits (ASICs), or the like, may also be used without departing from the scope and spirit of the inventive concepts disclosed herein.","In accordance with one embodiment of the present invention, the method may be implemented on a data processing computer such as a personal computer, workstation computer, mainframe computer, or high performance server running an OS such as Solaris\u00ae available from Sun Microsystems, Inc. of Santa Clara, Calif., Microsoft\u00ae Windows\u00ae XP and Windows\u00ae 2000, available form Microsoft Corporation of Redmond, Wash., or various versions of the Unix operating system such as Linux available from a number of vendors. The method may also be implemented on a multiple-processor system, or in a computing environment including various peripherals such as input devices, output devices, displays, pointing devices, memories, storage devices, media interfaces for transferring data to and from the processor(s), and the like. In addition, such a computer system or computing environment may be networked locally, or over the Internet.","In the context of the present invention, the term \u201cnetwork\u201d comprises local area networks, wide area networks, the Internet, cable television systems, telephone systems, wireless telecommunications systems, fiber optic networks, ATM networks, frame relay networks, satellite communications systems, and the like. Such networks are well known in the art and consequently are not further described here.",{"@attributes":{"id":"p-0057","num":"0059"},"figref":"FIG. 3","b":["102","102"]},"Note that while smart card  is conveniently implemented in a plastic device similar in size and shape to a conventional credit card, in alternative embodiments it takes a variety of other portable formats, such as a ring, or a pendant, and so on. In other embodiments, smart card  comprises a token or similar device, such as for use in authentication. In addition, smart card  can be integrated into another electronic device. For example, in some embodiments smart card  comprises a Subscriber Identity Module (SIM) card for use in a GSM mobile telephone, or a Wireless Interface Module (WIM) for use in a device that supports the Wireless Application Protocol (WAP), or a Universal Subscriber Identity Module (USIM) card or a User Identity Module (UIM) for use in a 3rd Generation Partnership Project mobile telephone.","Smart card  can be regarded as having a layered structure, with hardware at the bottom. The hardware for a card comprises a CPU , a cryptographic facility , an input\/output unit  and memory (random access memory (RAM), read only memory (ROM), electrically erasable programmable read only memory (EEPROM)) . Running on the hardware platform is a card executive layer , usually an operating system (OS) particular to the specific hardware platform involved. The card executive layer comprises an applet selector , whose operation will be described in more detail below.","On top of the card executive layer is the Java Card runtime environment (JCRE), which comprises the Java Card virtual machine (VM) . Note that the Java Card VM itself is generally specific to the particular card executive layer , but then presents the standard Java Card API  to application software  running on the smart card .","The Java Card device  depicted in  has (by way of example) five loaded applets A, B, C, D and E. Each applet  comprises a card AID interpreter , which will be described in more detail below. The applets A, B, C, D and E generally extend (i.e. subclass) a base applet class  provided by the JCRE . Similarly, the AID interpreters A, B, C, D and E extend a base AID interpreter class , which is also provided by the JCRE . Note that one or more of applets A, B, C, D and E may be from different vendors. It will be appreciated having multiple applications from different vendors installed on a single card avoids the need for a user to have to carry around multiple cards, one for each vendor or application provider.","The applets  are arranged into three groups, separated from another by firewalls . Thus applets A and B are in firewall K, applet C is in firewall L, and applets D and E are in firewall M. Applets  can share data within a firewall , but not generally from one firewall to another. One motivation for having two or more applets within a single firewall is where one applet manages the code and classes of the other application(s) that are within the same firewall. It is expected that all the applets within a particular firewall are controlled by the same RID operator (i.e. they have the same RID).","It will be appreciated that applets  are static, in that all the code they use is already stored in smart card . In other words, applications do not download any code from terminal  or elsewhere except during initial applet installation, at which time all the applet code is loaded for storage onto smart card  as part of the applet installation process.","In existing systems, it is difficult for external programs, such as may be running on a terminal , to ascertain and confirm the firewall structure of an inserted smart card. In other words, it is difficult for the terminal to deduce the allocation of applets  to firewalls , such as depicted in . Nevertheless, such information may be useful for the terminal in knowing how to handle the card in question, for example, because an applet can only access data within its own firewall. Furthermore, when an applet is first installed onto the card, it is clearly important to determine the correct firewall for the applet, so that the applet is installed into the proper location.",{"@attributes":{"id":"p-0065","num":"0067"},"figref":"FIG. 4","b":["102","110","102","351","351","411","411","351","401","401","411","411","401","351","411","401"]},"In operation, the smart card  contacts a terminal , which contains one or more proxies (A, B). As shown in , there is a corresponding back office application A, B for each proxy. Note that in , there is a one-to-one correspondence between a proxy  in the terminal  and an applet  on smart card , although in other embodiments one proxy  may be associated with multiple applets . Each proxy comprises its own proxy AID interpreter  (again as described in more detail below).","If there is only a single proxy  installed on terminal , this can be set to trigger automatically when a card  is inserted into the terminal  (or otherwise engages with the terminal). Note that the proxy need not be terminated after each session with a card, but rather may only be suspended pending insertion of a new (potentially different) card. This helps to reduce proxy start-up time for the new card interacting with a terminal.",{"@attributes":{"id":"p-0068","num":"0070"},"figref":"FIG. 5","b":["401","401","501","351","502"]},{"@attributes":{"id":"p-0069","num":"0071"},"figref":"FIG. 5","b":["502","401","502","502","360","502","351","502"]},"It will be appreciated that in contrast to the high-level breakdown of the AID  into RID and PIX portions, which is specified by the ISO7816-5 standard, there is no such standardization of the subfields within the PIX portion . Accordingly, the sizes and layout shown in  for the Firewall ID portion A, the Applet ID portion B, and the Other portion C are illustrative only, and may vary from one applet to another. For example, in one embodiment the bytes allocated to a particular subfield are not contiguous. Thus the Applet ID B can be stored in two separate blocks, with bytes indicative of the Firewall ID A located in-between. Furthermore, one or more of these subfields can be omitted altogether if not required by a particular RID operator. All such variations are of course still constrained by total size of the PIX , which is limited to 11 bytes (or at least no greater than 11 bytes), in conformity with the international ISO\/IEC standard.","One motivation for storing the Firewall ID A within AID  is that although all applets in the same firewall are expected to relate to the same RID operator (i.e. have the same RID ), the converse is not true. In other words, applets having the same RID may be located in different firewalls. This might arise if the cardholder has more than one relationship with an RID operator, and these different relationships are to be kept independent. One common situation in which this may occur is where an organization (such as a bank) is responsible for both a general card management application, and also some particular application for account manipulation, e.g. cash withdrawal from an ATM. In this case, the general card management application is likely to have privileges that should not be extended to the specific application for account manipulation. Another possibility is where a contractor for a large supermarket may have identity information encoded in a card to allow them to access particular areas of the supermarket in a business capacity. At the same time, the contractor may also have a loyalty or reward program installed in their card for when they make personal purchases at the supermarket.",{"@attributes":{"id":"p-0072","num":"0074"},"figref":"FIGS. 5A","b":["5","5","5","401","351","411","411","411"]},"The internal implementation of the card AID interpreter  differs between the various embodiments shown in , B, C, and D. However, it will be appreciated that these differences are transparent to (i.e. hidden from) software that uses the card AID interpreter  to access the AID and its components (due to object encapsulation). Thus in all cases there is a common method signature for the card AID interpreter class . Nevertheless, differences in the internal implementation of the card AID interpreter  may have implications for performance, required storage capacity, and so on, as will now be discussed.","In the embodiments illustrated by , B, C, and D, the underlying AID byte string  itself is stored in one or more byte arrays, although any other appropriate form of storage primitive(s) could be used. A byte array is then accessed via a buffer object , which is a general purpose object that provides method calls for accessing and manipulating its byte array of stored data (i.e. in this case the AID). However, the buffer object  has no knowledge of the internal composition of the stored data, such as that the first portion of the AID byte array represents the RID , and the second portion of the AID byte array represents the PIX .","In the embodiment of , there is relatively little internal structure, and the card AID interpreter  calls the buffer object  directly in order to access the stored AID data. The card AID interpreter  therefore acts in effect as a wrapper for buffer object . In a variation on this configuration, the card AID interpreter  may be implemented as an extension of the buffer object . In either case, the AID interpreter  therefore has knowledge of the structure and coding of an AID , in order to be able to derive the various AID components from the full stored AID.",{"@attributes":{"id":"p-0076","num":"0078"},"figref":"FIG. 5B","b":["411","501","502","502","540","541","561","561","561","502","502","502","502","411","411","540","411","501","502","540","541"]},"It will be noted therefore that the embodiment of  does not store the AID byte string as a complete entity per se. Rather, the various components of the AID are stored separately (in different byte arrays). These components are then assembled in response to a call into the AID interpreter to dynamically generate the complete AID. (A more extensive use of dynamically generated AIDs will be described later in more detail).","The embodiment of  represents something of a hybrid between the embodiments of . Thus in the embodiment of , the AID subobjects (i.e. RID object , Firewall ID object , and Applet ID object ) all access a single buffer object , which is used to store the complete AID. This use of a common buffer for holding the AID generally permits a more compact storage than the three separate buffers shown in .","Note also that in the embodiment of , the card AID interpreter  itself is also able to communicate with buffer  directly, i.e. not through one of the subobjects. This helps to speed up operations involving the whole AID (i.e. it avoids having to reconstruct the AID from its various components).",{"@attributes":{"id":"p-0080","num":"0082"},"figref":"FIG. 5D","b":["541","542","541"]},"There are various trade-offs between speed, storage capacity, flexibility, and so on regarding the different embodiments of , B, C, and D. For example, the full subobject hierarchy of  provides a good logical representation of the AID structure, but may not offer the best performance levels.","Accordingly, it will be appreciated that the particular implementation adopted for card AID interpreter  in any given situation depends upon the circumstances in question. For example, one implementation may be selected if speed is of paramount concern compared to data and code storage capacity, while another embodiment may be selected if the relevant importance of performance and storage capacity is reversed. The skilled person will be aware of which embodiment to select for a given set of circumstances, and will also be aware of potential variations on the particular embodiments illustrated in , B, C, and D.","Returning now to the interaction between a smart card and a terminal, such as illustrated in , the provision of multiple (potentially unrelated) applications on a smart card makes it important that the correct application is selected and utilized for any particular session. Note that terminal  itself may be dedicated to a single type of application, or may instead support a range of applications.","In accordance with one embodiment of the invention, the interaction between a smart card and a terminal still follows in general terms the high-level pattern set out in . However, at a more detailed level, the procedure is significantly different, as illustrated in , which depicts processing in accordance with one embodiment of the invention.","The processing of  commences with the receipt at  by the smart card  of a request from the terminal . This request generally corresponds to that transmitted at reference numeral  in , except that the terminal  does not specify a single, complete (or partial) AID per se. Rather, the desired application is identified in terms of multiple parameters. These multiple parameters reflect the different components of the AID, for example as illustrated in .","It is now determined which application (if any) on the smart card is identified by the received parameters. This is achieved by comparing the received AID parameters against the AID parameters for the applications on the smart card, which as previously described can be accessed via the AID interpreter  for the corresponding applet. Accordingly, the AID interpreter  for each applet is located (), thereby permitting the above comparison to be performed (). Various mechanisms for performing this comparison are described in more detail below.","If the AID parameters from a particular applet match those received from the terminal (at reference numeral ), then the complete AID is obtained from the relevant applet (). This complete AID can then be returned to the terminal and the applet corresponding to the AID activated on the card (corresponding to reference numerals  and  in ).","If however the AID parameters from an applet on a card do not match those received from a terminal, then it is checked to see if there are any more applets to examine (). If so, the AID parameters for these further applets are retrieved and tested against the AID parameters received from the terminal. However, if all the applets have now been tested without a positive response at , the smart card now reports to the terminal that it cannot find a match to the requested application ().",{"@attributes":{"id":"p-0089","num":"0091"},"figref":["FIG. 6A","FIG. 6"],"b":["674","102","110"],"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":{"@attributes":{"id":"ul0002-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["(i) an RID ","(ii) a firewall identifier A; and","(iii) an applet identifier B.\n\nNote that although these parameters are logically separate, they in practice be conjoined into a single string in the request itself in order to facilitate transmission between the terminal  and the smart card  (this is discussed in more detail below).\n"]}}}},"In one embodiment, if the firewall identifier A specifies a firewall that is known to contain at most only a single application, then the applet identifier  can be omitted. Conversely, the firewall identifier A can be omitted in one embodiment, for example if the applet identifier B is known to be unique to that RID .","A request containing the above three parameters is therefore received on the smart card at  by the applet selector  (see ). The applet selector then has to find an application  on the card that matches these parameters (corresponding in general terms to reference numeral  of , or to reference numerals , , and  of ). Thus following receipt from terminal  of the request specifying the RID , Firewall ID A, and Applet ID B of the desired applet, the applet selector  calls each installed applet to try to match these three parameters. More particularly, a first applet is selected (), and the applet selector  calls this applet in order to obtain access to the card AID interpreter  within the applet ().","Once the card AID interpreter for the applet has been located, the applet selector  calls a match_RID( ) method (or such-like) on the card AID interpreter  (). In making the match_RID( ) call, the applet selector passes as a parameter the particular RID  that was received from the terminal\u2014i.e. the RID to be matched. The card AID interpreter  then tests the received RID against the locally stored RID for that applet (). The exact manner of performing this test will depend upon the method signature and internal implementation of the card AID interpreter , such as discussed above in relation to , B, C, and D.","After the card AID interpreter  has tested the RID received from the terminal against the RID for that applet, the match_RID( ) method call returns a positive or negative response as appropriate (). If this response is negative, then it is known that this applet cannot be the one desired by the terminal , since the RID does not match. Accordingly, in this case the applet selector  proceeds to select another applet  on the card to test ().","On the other hand, if an RID match is obtained at , the applet selector  next examines whether the Firewall ID received from the terminal matches the locally stored Firewall ID for the applet. This testing is again performed by making an appropriate call (e.g. match_FirewallID( )) from the applet selector to the card AID interpreter  (). If the card AID interpreter produces a negative response to the match_FirewallID( ) call, the Firewall ID received from the terminal does not match the Firewall ID stored in the applet. Accordingly, the applet in question cannot be the one desired by the terminal. The applet selector therefore again proceeds to select the next applet for investigation ().","Alternatively, if the testing of the Firewall ID at  results in a positive match, the applet selector  now examines whether the Applet ID received from the terminal matches the Applet ID stored within this applet (). Again, this is achieved by making an appropriate method call into the card AID interpreter  (). In response to this call, the card AID interpreter  tests the Applet ID received from the terminal against the Applet ID stored within the applet (). If this test yields a negative outcome, then the applet in question cannot be the one desired by the terminal, since the Applet ID does not match. Accordingly, the applet selector  again proceeds to select the next applet for consideration ().","On the other hand, if the test of Applet ID at  gives a positive result, then the desired applet been located, since the RID, Firewall ID and Applet ID must all match. In this case, the applet selector  calls the get_AID( ) method of the card AID interpreter . This call returns the complete AID for the matching applet (), which can then be passed back to the requesting terminal (corresponding to reference numeral  in ). In addition, the matching applet will also be launched on card  (corresponding to reference numeral  in ).","Note that it has been assumed so far that there is a single applet  on a card that matches the terminal request. However, this assumption may not necessarily hold. Thus if the application  requested by the terminal  is not present on the card , then no matching applets will be found. This situation is accommodated in the flowchart of  where a test is made at  to see if all the applets have been examined. If so, and there are no further applets to investigate on the card, the applet selector  has to send a negative report back to the terminal (), indicating that the requested application is not installed on the card. Depending on the particular terminal in question, this may terminate the session between the card and the terminal, or may lead the terminal to submit a request for a different application on the card (i.e. to specify a different set of RID , Firewall ID A, and Applet ID B parameters).","It is generally expected that the RID, Firewall ID and Applet ID reliably define a unique application, so that the situation of finding more than one matching applet on a card for a particular terminal request should not arise. However, in some embodiment, a more generic matching process can be utilized. For example, the terminal can be permitted to omit an applet ID from its request at . In this case, there may potentially be multiple matching applications (i.e. all the applications located within the specified firewall). One option would be to handle this situation similarly to the way in which existing systems handle a partial AID that matches multiple applications (i.e. by returning one match at a time for each terminal request). Another possibility is to modify the flowchart of  by proceeding from  (obtain whole AID) to . In this case, processing would always eventually arrive at , once the applet selector had investigated all the applets on the card. At this point the applet selector  can then return to the terminal the complete set of matching AID(s) that have been found, or report the absence of any match (as appropriate).",{"@attributes":{"id":"p-0099","num":"0104"},"figref":["FIG. 6B","FIG. 6A","FIG. 6A"],"b":["412","501","502","502","411"]},"The processing of  again starts when a terminal  sends a request containing the parameters identifying the desired application, and this request is then received by the smart card (). However, instead of the applet selector  now passing these parameters to the selected individual applets  (as in the embodiment of ), in this embodiment the applet selector  calls the card AID interpreter  for each selected applet in order to retrieve the corresponding parameters stored in that applet. Thus the applet selector retrieves the RID  for a selected applet from the card AID interpreter  at B, the Firewall ID A for the selected applet from card AID interpreter  at B, and the Applet ID B for the selected applet from card AID interpreter  at B. The retrieval of B can be regarded as being performed using a get_RID( ) call, in contrast to the match_RID( ) call used in the embodiment of .","After each parameter has been retrieved from the card AID interpreter , the Applet selector  tests the retrieved parameter against the corresponding parameter received in the request from the terminal. Thus applet selector  tests at  for a match of RID , at  for a match of Firewall ID A, and at  for a match of Applet ID B. If all three matches turn out positive, then the desired applet has been identified, and the applet selector can request the complete AID for this applet from the relevant card AID interpreter (). (Note that the applet selector  itself will not generally know how to form a complete AID from the three parameters it already has, nor will it know whether any additional information, such as Other C (see ), might be required for such a task). The applet selector can then return the complete AID back to the terminal that originally submitted the request (corresponding to reference numeral  in ).","It will be appreciated that there are many variations on the above approach. For example, rather than investigating the RID, the Firewall ID, and the Applet ID in turn, the card AID interpreter  can support a single combined method call to match (or retrieve) two or three of these identifiers at once. One example of this is shown in , which depicts processing in accordance with one embodiment of the invention. The flowchart of  is broadly similar to the flowchart of , except that the applet selector retrieves all three parameters, namely the RID, the Firewall ID and the Applet ID, in a single operation at C. These three retrieved parameters can then be matched against the parameters received from the terminal, in the same way as described for . Note that in one embodiment, the selector can retrieve the complete AID at C as well as the various AID components, in which case reference numeral  of  can subsequently be omitted.",{"@attributes":{"id":"p-0103","num":"0108"},"figref":["FIG. 6D","FIG. 6C","FIG. 6A","FIG. 6D"],"b":["411","682","412","411","411","501","502","502","682","411","684","688","692","411","411","412","696"]},"A further possible variation is that rather than the applet selector investigating the different applets on a card sequentially (i.e. one applet at a time), as in , the applet selector  instead investigates multiple (potentially all) applets at the same time. In other words, the processing of  (reference numerals  through to  in particular) is performed for each applet in parallel. This is illustrated in the flowchart of , which depicts processing in accordance with one embodiment of the invention. Note that the processing of  can be performed by any suitable parallel implementation of the flowcharts of , in which case the loop back via reference numeral  is clearly omitted. The applet selector  can then collate the results from each separate applet in order to determine overall whether a matching applet has been identified.","Although the embodiments of  through to E all perform the applet matching on the smart card , this matching can also be performed on terminal , as illustrated in the flowchart of , which depicts processing in accordance with another embodiment of the invention. The flowchart of  commences with the terminal requesting information about the applets on the card  (). In response, the terminal receives the RID , firewall ID A and applet ID B as well as the complete AID  for each applet on the card (). This allows the terminal to try to identify the desired applet, based on matching its RID , firewall ID A and applet ID B (). Once this applet has been identified, the terminal can now ask the applet selector  to launch or activate this applet by specifying the corresponding (complete) AID (). A further possibility is for the terminal itself to comprise a proxy AID interpreter , as described in more detail below.","It will be appreciated that selecting an application on the basis of the RID , Firewall ID A, and Applet ID B avoids a terminal  having to identify a desired application by its precise AID . This considerably enhances flexibility compared to existing implementations, in which a terminal has to provide a full or partial AID, and receives back the full AID for each matching application. In particular, it is now possible for the contents and format of an AID  to vary without compromising compatibility with the terminal , provided that the Firewall ID A and Applet ID B themselves are maintained constant.","There are several reasons why such variation in the contents and structure of an AID  may occur. For example, the PIX portion  of the AID can be used to store additional information (i.e. Other C, as shown in ) which is potentially variable. Such additional information can relate to the card itself, such as its remaining memory capacity. Another possibility is that this additional information relates to the card application corresponding to the AID in question. For example, the Other C portion can comprise a version number or configuration details for the application. According to one embodiment, the information in the Other C portion is used for application selection. According to another embodiment, the information in the Other C portion is used for further processing of the session.","The additional information stored in the Other C is normally not available to the terminal  (prior to interaction with card ). Consequently, the terminal does not know the entire AID for matching. However, using an approach such as illustrated in  though F, the terminal can still locate the desired application on the card by virtue of the application's RID, Firewall ID, and Applet ID, which the terminal does know in advance.","Of course, existing systems can potentially accommodate additional (variable) information in the AID by placing such information at the end of the AID, and then using a partial match on the prior (fixed) portion of the AID. However, this requires the terminal to know in advance the specific byte sequence for the partial AID. Furthermore, it also restricts the placement of any variable information to the end of the AID. In contrast, the approach described herein does not impose any restrictions as to where or how the Firewall ID A and the Applet ID B are stored within the PIX portion  of the AID. For example, they could be located at the end of the AID, after any other (potentially variable) information.","In one embodiment, the terminal and the AID interpreter apply a shared or common data representation to the Firewall ID and the Applet ID. This common data representation can correspond to a primitive data type (such as an integer), or to a complex data type (such as a 16-byte string). This shared representation is generally larger than the actual number of bytes allocated to each parameter inside the stored AID (which is of course limited to a maximum of 11 bytes corresponding to the size of the PIX portion  of the AID). Consequently, the AID interpreter  performs the appropriate size conversion between the internally stored Firewall ID (of say 3 bytes) and the external data representation of the Firewall ID (of say 16 bytes), and vice versa, as required.","Having a shared data representation for external manipulation of the Firewall ID A and\/or Applet ID B portions allows the internal storage of these parameters to be altered without impacting terminal compatibility. For example, a particular supplier (i.e. having a particular RID ) may have originally allocated a certain portion of the PIX  to the Firewall ID A and the remainder to the Applet ID B. However, it may subsequently transpire that there are a greater number of potential Firewall IDs than can be accommodated within the initially allocated portion. In this situation, the supplier may decide to increase the portion of the PIX  used to store the Firewall ID B. Since terminal  is only concerned with the external manifestation of these parameters, such modifications are quite transparent to the terminal. (In contrast, if the terminal  were matching a precise AID string, as in existing systems, the byte reallocation between the Firewall ID and the Applet ID is potentially problematic).","A further possibility is to divide the PIX portion at the bit (rather than byte) level, which helps to maximize utilization of this very limited coding space\u2014e.g. a single byte can be split across two or more fields. This then requires somewhat more complicated processing of the internal representation (i.e. within the AID interpreter), given the need to work with individual bits. However, if the common data representation is maintained at the byte level, external programs (such as running on terminal ) are shielded from the complexities of the internal bit operations.","It will be appreciated that if the internal data format within the AID interpreter is different from the common data representation, then operations involving getting (reading) or matching an AID component have to perform a conversion from internal to external format. The conversions for such reading or matching operations can be achieved in a straightforward manner by prepending the appropriate number of null bytes (e.g. 13 in the above case) in order to convert from an internal format into an external format.","Note that the situation is a little more complex in reverse, when going from the external representation to the internal representation. In these circumstances, the value supplied from the terminal will generally be longer (say 16 bytes) than the space available (say 3 bytes) within the AID byte array on the card (or other internal storage facility). If most of the bytes in the AID parameter passed from the terminal to the card are zero, they can be truncated to fit the parameter into the AID byte array. On the other hand, if a non-zero byte is to be truncated, then this generally represents an error situation, and should be flagged accordingly. However, the AID components in question (i.e. the Firewall ID portion A and the Applet ID portion B) are not normally updated after applet initialization, thereby avoiding difficulty in this respect.","In summary therefore, the present approach matches AID parameters (generally RID , Firewall ID A and Applet ID B) via an AID interpreter in order to identify a desired application on a card. The precise manner in which the AID and its components are encoded and stored onto card  is hidden behind the AID interpreter, and need not be known to the terminal . This then enables terminal  to use a relatively stable and straightforward interface to identify applications across a wide range of cards , preserving compatibility without unnecessarily constraining the contents of the AID itself. Consequently, the extra level of indirection, whereby the AID  contents are only accessed via AID interpreter , provides great flexibility as to how the AID  is utilized and updated.","Note that although  depict from the handling of an AID in terms of multiple (logical) components, it will be appreciated that from an implementation perspective the separation of these parameters can be less apparent. For example, in communications between the smart card  and the terminal , the parameters (i.e. RID , Firewall ID A and Applet ID B) can be combined into a single byte sequence for ease of transport and manipulation (e.g. as a data packet). This implies that in addition to a single common data representation for the parameters themselves, there can be a standard way of packing them into a single byte sequence or other appropriate transport format.","Likewise, although the different parameters are depicted in  as independent of one another, this need not necessarily be the case. For example, in some embodiments the firewall ID can in fact be defined as the concatenation of RID portion  and Firewall ID portion A. It will be appreciated that such an approach still allows a terminal or other software to distinguish between applications in different firewalls. Moreover, this hierarchy reflects the fact that each RID operator (as defined by RID ) defines its own set of firewalls, and so Firewall ID portion A can only be sensibly interpreted given its corresponding RID portion . An example of an implementation that adopts such a hierarchical structure is included in Appendix A.",{"@attributes":{"id":"p-0118","num":"0123"},"figref":["FIG. 7","FIG. 7","FIG. 5"],"b":["411","102","501","502","502","0","502"]},"The flowchart of  commences with the card AID interpreter  receiving a method call for the (complete) AID (). Such a call can arise during a session with a terminal, perhaps because the applet selector  wants to retrieve the AID for the matching application in order to return the AID to the terminal (as per reference numeral  of ). However, the card AID interpreter may have to provide a complete AID in other circumstances as well. One possibility is that a smart card is asked to provide a complete listing of AIDs for the applets installed on the card, either for applet selection purposes (as in ), or for more general card management operations. Another possibility is that if a transaction updates some portion of the AID to be stored on the card, then it can request a read-out of the AID at the end of the session, in order to confirm that the update has been correctly saved onto the card.","The AID interpreter responds to the request of reference numeral  by accessing the stored AID byte array (). The exact manner in which this is performed depends on the internal implementation of the AID interpreter, as discussed above in relation to , B, C, and D. For some applets, the byte array retrieved at this stage represents the complete AID (i.e. there is a negative outcome to the test of reference numeral ). In such cases, the card AID interpreter can immediately proceed to return the retrieved AID to the calling object (reference numeral , via reference numeral ). However, in other situations, the AID comprises a dynamic component, i.e. there is a positive outcome from reference numeral . (It will be appreciated that in an actual implementation of a card AID interpreter , the test of reference numeral  may be omitted; rather, the card AID interpreter is hard-wired to include, or not to include, dynamic data, as appropriate for the applet in question).","The dynamic component of the AID may represent, for example, a current balance for the card, the date of the last transaction of an application, or any other desired data. This dynamic data can, in principle, be stored within the card AID interpreter  itself, and so be directly accessible to the card AID interpreter. However, more generally the dynamic data is located separately from the card AID interpreter, which pulls in the dynamic data on-the-fly when it is required to generate a complete AID. For example, in some embodiments the dynamic data is held in general card data storage  (see ), which can be implemented in a portion of EEPROM  assigned to or accessible by the application in question.","If the AID does incorporate dynamic data, the next task is to assemble the complete AID from this dynamic data and the static data (). The exact manner of doing this depends upon how and where the dynamic data is stored.  illustrates one particular situation, where the card AID interpreter  calls the applet to which the card AID interpreter belongs to provide the dynamic data (). The applet responds by obtaining the dynamic data, for example by accessing one or more subobjects within the applet that are responsible for maintaining the dynamic data. Next, the applet returns this dynamic data to the card AID interpreter, for example by using a call-back mechanism (). When the AID interpreter  has obtained the desired information, it generates a composite or final AID by combining the stored and dynamic components as appropriate (). The newly generated AID can then be returned () in response to the original request at reference numeral .","It will be appreciated that there are many other possible implementations of reference numeral  apart from that shown in . For example, in some embodiments the card AID interpreter itself maintains the dynamic AID component, in which case it would not need to contact the applet for this information. Alternatively, the applet may (upon prompting) write the dynamic component directly into the low-level AID storage facility. In this situation, reference numeral  is postponed until after , whereupon the card AID interpreter  would, in effect, retrieve a complete and already updated AID. Other possible implementations will be apparent to the skilled person.","An example of the dynamic data that can be handled by the processing of  is a credit balance controlled by a purse object. The purse object may perhaps store two parameters in card data , the first representing the amount of money deposited onto the card, and the second the amount of money spent from the card. The difference between these two amounts then gives the current balance, and it may be this figure (the balance) that is to be incorporated into the AID. In this situation, the purse object responds to the call of reference numeral  by calculating the current balance (i.e. by subtracting the amount spent from the amount deposited), and then returning the balance to the card AID interpreter for incorporation into the AID. Note that in this implementation, not only is the AID assembled dynamically, but it also incorporates data that does not normally exist per se on the card (rather, the dynamic data that is incorporated into the AID is derived from other data values that are present on the card).","It will be appreciated that there is a wide range of possibilities for dynamic data to be included in an AID. For example, the dynamic data can reflect the date and\/or time of last use of the application, the location of the terminal of last use, or any other desired application or card property. This then gives considerable flexibility in terms of how the card, and in particular the AID, is used.","Note that the dynamically inserted data is not necessarily subject to change during the lifetime of the card or application. In some embodiments this data can instead represent a fixed (or relatively fixed) property, such as the remaining memory capacity of the card, the version number of an applet, etc. One advantage of storing details of this (potentially fixed) property or state outside the card AID interpreter  is where the same data is to be utilized by multiple applications. For example, the AID may be constructed to comprise an indication of which encryption facilities are present on the card, since this may impact the type of operations that a terminal can perform with the card. However, since these encryption facilities are common to all applications on the card, it is convenient for the relevant indication to be stored in a single, centralized location (such as in card data ).","In these circumstances, the card AID interpreters for the various applications on the card  can use the procedure of  to retrieve this centralized indication of encryption facilities as dynamic state information. The retrieved information can then be incorporated into the AID for the respective applications, as and when required by the AID interpreters . It will be appreciated that storing a single copy of data (in this case the indication of encryption facilities) in a shared resource, such as data block , where it can then be accessed by multiple applications on the card, is generally more efficient than encoding the data separately into the AID for each application on the card.","Another benefit of storing dynamic data outside the card AID interpreter  is that the card AID interpreter itself does not need to know how to access, manipulate or format the dynamic data. Rather, this can be left to those objects that primarily interact with the dynamic data (and possibly update it). This then allows a higher degree of generality for the card AID interpreter  itself.","Thus in one embodiment the card AID interpreter knows whether or not the AID comprises dynamic data, and if there is such dynamic data, how to obtain it (e.g. which method to call on the applet) and how to incorporate it into the AID byte string (perhaps to insert the dynamic data as Other C in bytes \u2013). However, the card AID interpreter does not need to have any further understanding of or interaction with the dynamic data.","For example, if the smart card stores two values, one representing amount placed on the card, the other amount spent (as suggested above), then in general the card AID interpreter  does not calculate the balance itself. Rather, the card AID interpreter calls its applet for the dynamic data to incorporate into the AID, and receives back the balance (already calculated) in response. The applet itself can obtain the balance by calling an appropriate method on the object responsible for maintaining the two data values in question (such as a purse object). This object then performs the necessary subtraction in order to produce and return the current balance to the card AID interpreter. The same object would also generally be responsible for suitably formatting the dynamic data for inclusion in the AID. For example, where the balance details are maintained in the purse object as real numbers (or possibly integers), the result can be converted into a byte string before return to the card AID interpreter for compatibility with the rest of the AID.","As described above, the presence of the AID interpreter  on smart card  relieves the terminal  of having to utilize the AID  directly in order to locate a desired application. Nevertheless there are other situations where the terminal  itself does want to be able to access and interpret the AID . For example, there may be other information encoded into an AID  passed to the terminal  that the terminal desires to use during the session, such as the Other portion C (see ).","This situation is addressed by the procedure of .  which illustrates processing performed at a terminal  during a session with a smart card  after preliminary interactions between the terminal  and the card , such as card activation (see ), have been completed, in accordance with one embodiment of the invention. The flowchart of  commences with the terminal specifying a desired matching application (). This operation corresponds in general terms to reference numeral  of . In the particular implementation shown, the request for a matching application is performed using multiple parameters, such as RID , Firewall ID A, and Applet ID B. These parameters allow the smart card to identify a matching application, as described above in relation to . The smart card then returns the AID for the matching application, which is duly received by the terminal (reference numeral , see also reference numeral  of ).","Having received the AID from the card, the terminal has to interpret the AID in order to complete the desired user interaction. However, maintaining knowledge of the AID structure within the terminal itself can be problematic, particularly where the terminal  supports multiple applications from a variety of suppliers. Furthermore, as described above, a matching application can now be identified on the basis of certain parameters, such as Firewall ID and Applet ID, rather than requiring the terminal to store a complete AID string for this purpose. Having therefore avoided the terminal initially needing full knowledge of the AID on the card for application selection, it is also desirable to prevent the terminal having to maintain a detailed understanding of the AID format for subsequent interaction with the application. This then allows a terminal to be generic as possible, and avoids having to update terminal software whenever there is a change in AID structure (or conversely, permits changes in AID structure without compromising compatibility with the installed base of terminals).","Nevertheless, a terminal always knows from international standard ISO\/IEC 7816-5 that the first five bytes of an AID represent the associated RID . Accordingly, once the terminal has received the incoming AID from the smart card , it is able to retrieve this RID portion  by extracting the first five bytes of the received AID ().","In accordance with the procedure of , the terminal now uses this RID portion  to obtain some form of network resource identifier (). This network resource identifier represents a Uniform Resource Locator (URL) on the Internet (or similar intranet or extranet). Alternatively, it may represent any other suitable type of network address or resource specifier, etc. There are a variety of possible mechanisms by which such a URL may be acquired from the extracted RID portion . For example, the terminal may maintain a lookup table that maps from RID portion  to specific URL. Alternatively, the terminal may follow some algorithm to convert from the RID to a URL. A further possibility is that some hybrid of the above two approaches is adopted, such as using the lookup table as the first option, and then forming a URL directly if there is no entry in the lookup table for that particular RID.","If reference numeral  involves forming a URL directly from the RID, then some mechanism is provided (such as a constructor method) for converting from the RID byte string into a URL. Thus the RID byte string can first be represented in hexadecimal form, which is then transformed into a corresponding text string for incorporation into a URL. Alternative methods for deriving a network resource identifier from the RID byte sequence can also be employed, such as using one or more bytes directly to specify an IP address of a URL (this can be done by using the \u201c%\u201d character, followed by two hexadecimal characters to specify an octet).","Note that any initial mapping of the AID into a URL by the terminal is non-semantic, in that the terminal converts the AID byte sequence into a URL via some mechanism such as the hexadecimal transformation discussed earlier. However, this mapping process is not expected to recognize or interpret any components of the AID (other than perhaps the RID, whose position within the AID is predefined by standard).","Once the network resource identifier has been derived from the RID; terminal  now sends a request to the URL or other address corresponding to the RID  (). In due course, the terminal receives back over the network a response comprising some form of material relevant to the AID (), which is then used to support further activities in the session (). It will be appreciated that the manner of this use depends upon the nature of the downloaded material (e.g. whether it is code, data or a network service address, etc.). One particular situation, where the downloaded material comprises an AID interpreter for use on the terminal , will be discussed in more detail below.","Returning to reference numeral , the RID can be used to define the domain name portion of a URL. In other embodiments, the RID can be provided in effect as an http parameter associated with the domain. One embodiment involving the former option is illustrated in , which provides more detail for . Thus in , the network resource identifier represents a URL which is derived from the RID by performing a lookup in a table or database, etc. (reference numeral A, corresponding to reference numeral  in ). The table or database is maintained locally on the terminal. The terminal then downloads code and\/or data as required from this URL (reference numeral A, which can be regarded as corresponding to both reference numerals  and  in ).","In some embodiments, the URL initially derived from the RID  comprises a guide or indicator to one or more sites from which further material can be accessed. For example, the URL initially obtained at  can provide a link to a further web site where the material is located (perhaps using the http redirect mechanism). The terminal then follows this link (or chain of links) in order to retrieve the relevant material. An example of this is where the terminal forms a URL comprising a generic portion, representing perhaps a constant Web site (and page), and an RID-dependent portion, comprising the RID in hexadecimal form. The RID-dependent portion is therefore presented in effect as an entry field associated with the generic page (analogous to encoding a search term into a URL for a search engine). This can then be used to determine the address of further material.","Such an embodiment is illustrated in the flowchart of , which again provides more detail for . Thus in , the RID received from the card is appended as a search parameter to a predetermined first URL stored locally on the terminal (reference numeral B, corresponding to reference numeral  in ). This then forms a search request which is sent to the first URL (reference numeral B, corresponding to reference numeral  in ). In response to this request, the terminal receives a second URL (reference numeral A, corresponding to reference numeral  in ). The terminal now downloads code and\/or data from this second URL for use in the session with the card (reference numeral B, corresponding to reference numeral  in ).","There is a very wide range of material that can potentially be obtained by the terminal at reference numeral  in . For example, in the embodiment of , the material initially downloaded for use in the session is in fact the second URL, which then directs the terminal to another location from which additional material can be obtained. In another embodiment illustrated in , the downloaded material comprises a data mapping, representing the structure of the AID  used by that organization (reference numeral C, corresponding to reference numeral  in ). The terminal can then use this mapping in order to extract desired information (such as a current balance) from the AID supplied from the smart card (reference numeral C, corresponding to reference numeral  in ). Note that there can be multiple such mappings for a single organization (as specified by the RID), with the particular mapping to be used dependent on some other data encoded into the PIX portion of the AID. In one such embodiment, the terminal receives over the network a full set of possible mappings for that RID, and then selects an appropriate mapping from this set based on the particular AID that it obtained from the smart card. In another embodiment, illustrated in , the terminal incorporates the full AID into the initial network request of reference numeral D (corresponding to reference numeral  in ). The web server receives this request () and uses the complete AID to select the material to supply back to the terminal (reference numeral ), downloading only the material (e.g. a mapping) appropriate to that particular AID (), which is received by the terminal in due course (reference numeral D, corresponding to reference numeral  of ).","In other embodiments, the material received by the terminal over the network comprises code (potentially in addition to other forms of material). There are a variety of possible code components in the supplied material, such as a user interface for the terminal to use with the cardholder, or a proxy AID interpreter  (see ) to allow the terminal  to decode the AID received from the smart card. In an alternative embodiment, the code downloaded is responsible for actual processing of application data during the session with the card (i.e. forming part of proxy code ). It will be appreciated that two or more of these code components can be downloaded in any given session.","The code can be provided to the terminal in a variety of forms, such as raw class files or as Java Archive (JAR) files or packages, each containing (compressed) Java code plus manifest. The downloaded code can then indicate further classes or packages that may need to be retrieved from over the network in order for the application to run. A further possibility is that the terminal receives a Java Application Descriptor (JAD) file. This is an XML file that comprises one or more URLs specifying where the relevant application code is located, as well as the location of any data associated with the application. The XML file can further comprise one or more descriptors relating to the application. The terminal can then download the code and data in accordance with the information provided in the JAD file.","Other types of material that can be downloaded over the network in response to the request from the terminal include multimedia data, such as a logo image to be utilized for the user session on a terminal screen; some form of contractual documentation associated with the session\u2014perhaps a user license or agreement; and some form of authorization or verification, such as a third party certificate guaranteeing the bona fide nature of a merchant involved with the session.","The material can also comprise a further network resource identifier representing a location, such as a portal, where a desired service can be obtained. Such a service may be the download of some product (e.g. music), some on-line purchase facility (e.g. for buying aircraft tickets), some data service (e.g. the supply of recent financial results), and so on. This further network resource identifier can also represent a site at which documentation relating to the commercial transaction (such as contractual details) is located. It will be appreciated that in many circumstances, the terminal is specialized for a particular application\u2014e.g. the terminal may comprise a facility to print aircraft tickets, or to burn music downloaded from the network onto a customer CD. The nature of the terminal will then determine the range and nature of application processing available to a customer at the terminal.","Note that the terminal can download multiple different items for a single smart card session. For example, from the initially derived network resource identifier (at reference numeral ), the terminal may obtain a set of further URLs specifying locations of various types of material relevant to the session (code, contractual terms, payment service location, etc).","It will also be appreciated that in some situations certain material available from a URL may in fact already be present on the terminal. For example, some Java packages from a specified URL may have previously been downloaded (for example as JAR files) and installed onto the terminal, perhaps to process an earlier session with a different card. In these circumstances, it will not normally be necessary to repeat the download (unless perhaps an expiry date for the material has passed). More generally, the terminal may already have available the material corresponding to the network resource identifier generated at , either because the material is cached or mirrored locally, or because the identified resource happens to be located on the terminal itself. The material can then be accessed locally at reference numerals  and  without having to download over the network.",{"@attributes":{"id":"p-0149","num":"0154"},"figref":["FIG. 8E","FIG. 8E","FIG. 8E","FIG. 8"],"b":"8033"},"As mentioned above, the terminal can use more than just the RID portion  of the AID in the processing of . For example, if the network resource identifier is generated at  by having the RID as an entry field or input parameter for a URL request, then the PIX portion can be provided likewise as an input parameter in the URL request. The web server can then utilize the PIX portion in determining the response that is provided back to the terminal (see reference numeral  of ). For example, the web server may determine the type of application associated with the AID (based perhaps on the Applet ID in the PIX portion), and then provide code back to the terminal that is appropriate for interacting with this particular application.","In some embodiments, the web-site or other network location performs some semantic interpretation of the AID obtained from the smart card by the terminal, so that the response back to the terminal incorporates data extracted from the AID (such as a current balance on the card, or other such state information included in the AID). This provides one mechanism to avoid the terminal itself having to be able to decode or interpret the AID byte string. Such an embodiment is illustrated in the flowchart of , which generally corresponds to that of , except that at F, the server interprets the received AID in order to extract relevant information. This extracted information can then be returned to the terminal (F) for further processing in the session.","Note that the processing of  following reference numeral  (receipt of the AID from the smart card ) is generally independent of the exact mechanism or circumstances whereby this AID is obtained. For example, the AID may be received following the operations described in relation to  or C (i.e. without the use of multiple parameters to specify a matching application on the smart card). In addition, the processing of  (from reference numeral  onwards) might also be performed if a terminal receives an AID from a smart card not as part of the initial selection of a matching application, but rather at some subsequent stage of the session between the card  and the terminal .",{"@attributes":{"id":"p-0153","num":"0158"},"figref":["FIG. 9","FIG. 8"],"b":["8040","9010","501","9020","9030"]},"Once the first server has determined the identity of the second server, the first server now in effect forwards the incoming request to the second server (). It is assumed that the second server is associated with the particular organization corresponding to the relevant RID. In other words, an organization having the RID in question maintains a web site on the second server. This web site is responsible for receiving and processing AID strings belonging to that organization (i.e. having an RID portion corresponding to that organization).","The AID string from the terminal is therefore received at the second server from the first server (), and decoded using an appropriate AID interpreter or other mechanism. (It is assumed that the organization knows how to decode its own AID strings). Using the information obtained from the decoded AID, the second server now identifies a Java Application Descriptor (JAD) file () to be used by the terminal in processing the smart card. The JAD file is generally retrieved from a stored set of such files, but might also be built dynamically in response to the terminal request.","According to one embodiment, the identified JAD file comprises a URL or other reference indicating the location of an AID interpreter. The terminal can then use this reference to download code for decoding and processing the AID itself. The JAD file can also contain any other appropriate information, code references, descriptors, etc that may be required or useful for the session.","The second server now places the JAD file at a network-accessible location, and returns a URL for this location to the first server (). The first server duly receives the URL (), and in turn forwards the URL back to the terminal (). This URL therefore allows the terminal to retrieve the JAD file constructed by the second server, and then to download any code that it references.","Note that there are several possible variations on the processing of . For example, instead of initially returning a URL for the JAD file from the second server to the terminal (via the first terminal), in other embodiments the JAD file itself can be transmitted along this route. A further potential variation is that at  the first server returns to the terminal the URL of the second server. In this approach, the terminal itself is then responsible for communicating directly with the second server, rather than using the first terminal as an intermediary. If so desired, this can be implemented in a straightforward manner by using the http re-direct mechanism.",{"@attributes":{"id":"p-0159","num":"0164"},"figref":["FIG. 10","FIGS. 8 and 9","FIG. 6"],"b":["351","102","401","411","110","401","351","110"]},"Within terminal , the AID  is split into its two main constituents, namely RID  and PIX . The former portion (i.e. RID ) is used to key into a lookup table , which contains a mapping of RID to URL. Based on the RID extracted from AID , a corresponding URL  can then be determined from the lookup table . This URL corresponds (in this particular situation) to a download site  for code to be used in processing the session involving card . A request  for such code is therefore sent to the download site . Note that this request may incorporate the full AID string received from the card. This AID string (or portions of it) can then be used by the download site to identify particular code of relevance for this session.","In response to the code request , a code package  for interpreting the AID  is returned over network  to terminal . This code package is then installed into terminal  to form a proxy AID interpreter . The newly installed code allows the proxy AID interpreter  to retrieve and interpret the data encoded in PIX  portion of AID , thereby permitting the terminal to continue processing the session with the card .","Proxy AID interpreter  on the terminal  comprises code that is analogous to or shared with AID interpreter  on the card, and may potentially be a superset (subclass) of the card AID interpreter . Note that proxy AID interpreter  is generally not only able to extract a firewall and applet identifier from PIX , but it is also able to access any other pertinent information that may be encoded into the PIX . (This additional information might relate to the state of the application on the card, such as described above in relation to ).",{"@attributes":{"id":"p-0163","num":"0168"},"figref":["FIG. 11","FIG. 10"],"b":["110","810","110","862","805","351","862"]},"The portal site  responds to the incoming query  by providing in return the URL A of the code download site . In the particular embodiment of , portal site obtains this URL from database  using the received AID or at least a portion of it, such as the RID, as an index into the database . The code download URL A is therefore received back at terminal  from portal site .","The terminal now generates a code download request  directed to the received code download URL. Note that the terminal  may potentially comprise the AID in this code download request . The code download request  is received at code download site , which returns code  corresponding to the particular URL of the request. One use of this code download mechanism is to allow the terminal  to install its own proxy AID interpreter , for use during the session with applet , as described above in relation to .","Note that the code downloaded from site  to terminal  may be dependent upon the AID (if any) included in code download request . For example, the AID might contain membership details for the cardholder. The code  for download can then be selected so as to only offer services appropriate to the particular class of membership of the cardholder (as determined from the AID).","It will be appreciated that it is generally easier to maintain a single network-accessible database  of RID to URL mappings, such as depicted in , than to have separate mappings  stored in each terminal, such as depicted in . On the other hand, the approach of  is generally faster than that of , given the reduced number of network requests involved. One compromise therefore is to adopt a hybrid approach, in which lookup table  represents in effect a local cache of data from code URL database . In such an embodiment, terminal  first attempts to find the location of code download site  using lookup table . According to one embodiment, this table stores the mappings for recently processed RIDs. However, if no entry for the RID in question is found in the lookup table, the terminal then contacts portal site  to derive the location of code download site  from database  (which is assumed to be much larger and more complete than lookup table ). Any mapping information obtained in this manner from the code URL database  may be added into the lookup table  for future use (depending on the particular cache occupancy strategy deployed).","It will be appreciated that the ability to download onto a terminal  a proxy AID interpreter  that is specific to the particular AID of the inserted card  complements the initial AID matching procedure described above (see e.g. ). Thus the provision of card AID interpreter  on the card , and the use of Applet ID and Firewall ID (rather than the AID byte string itself) to specify a desired applet , allows a terminal to obtain the AID of the desired applet without needing to know (initially) the specifics of the AID itself.","Similarly, rather than having to preinstall appropriate AID processing software on all terminals, the AID obtained from the card can then be used by the terminal to identify and acquire a proxy AID interpreter  that is able to parse and manipulate the AID in question. According to one embodiment, the appropriate proxy AID interpreter  is downloaded over a network onto the terminal in order to complete the relevant session with the card . Accordingly, the dynamic provision of a proxy AID interpreter to a terminal helps to allow the PIX portion  of an AID to be used for more complex and varied tasks, which may perhaps be modified over time, without compromising compatibility at the set of terminals already present in the field.","Note that there are many potential variations on the embodiments of . For example, a default structure may be defined for AID . Terminal  then has preinstalled a proxy AID interpreter  that is able to parse and extract information from an AID conforming to this default structure. In this case, there may be no need to derive a network resource identifier from an RID in this AID. For example, in the embodiment of , lookup table  may instead indicate that the default proxy AID interpreter is to be used (perhaps by simply having a null entry for that RID). This can be regarded as analogous to the processing of .","On the other hand, in the embodiment of , the RID to URL mapping (box A) may still be performed, but the response from the portal site  then indicates that the default proxy AID interpreter is to be used. In this case there is no need for the terminal to send a subsequent code download request , assuming that the default proxy AID interpreter is already installed on the terminal.","A further possibility is that the terminal attempts to use the default AID interpreter  if it is unable to find any other suitable code for this session, for example because there is no entry for the RID in the lookup table  or the portal site  (depending on the particular embodiment) or because a network connection is currently unavailable. Alternatively, the lack of a positive indication of which proxy AID interpreter for the terminal to use for a given AID (default or otherwise) might be taken as an error, possibly causing the terminal to abort the session.",{"@attributes":{"id":"p-0173","num":"0178"},"figref":["FIG. 11A","FIG. 8","FIGS. 8 and 11"],"b":["1110","8020","1120","1130","1140","1150","1155","1120","1140","1160","1140"]},"It will be appreciated that even for those cases where there is a specific proxy AID interpreter to use for a particular AID string, this will frequently be formed as a modification of the default proxy AID interpreter. For example, code obtained from a location such as code download site  can comprise a plug-in for the default proxy AID interpreter, or may be utilized via any other suitable mechanism. Alternatively, the downloaded code may subclass portions of the default proxy AID interpreter in order to provide more specific functionality in certain areas.","One implication of the ability to acquire a proxy AID interpreter  within the terminal  itself is that this now offers the possibility of performing the initial AID matching in the terminal  (in contrast to the AID matching performed on the smart card , such as illustrated above in ). One embodiment of the invention which supports such processing is illustrated in the flowchart of , which commences in the same general manner as the flowchart of . In other words, the terminal detects insertion of the card (), and consequently activates the card (reference numerals , ).","At this point however, rather than specifying a desired application in terms of RID, Firewall ID, and Applet ID (corresponding to reference numeral  of ), instead the terminal requests the applet selector  to provide it with the full set of AIDs for the card\u2014i.e. the AID for each available applet  on the card (). The applet selector receives this request (), and according to one embodiment, uses a get_AID( ) method call on the card AID interpreter  of each application installed on the card in order to retrieve the AID for that application (). The precise manner in which the get_AID( ) call is implemented will depend upon the internal details of the card AID interpreter  in question (as discussed above in relation to , B, C, and D). Note that prior to making the get_AID( ) call for an application, the applet selector may first have to call the applet itself in order to locate the card AID interpreter  for that particular applet (analogous to reference numeral  of ). Note also that the AIDs for different applications may be collected in parallel, or one after another, or via any other suitable strategy.","The AIDs for the card applications are now returned from the card  to the terminal  (reference numerals , ), where the RID is extracted from each AID (). This RID then allows the terminal to identify and to acquire (if necessary) a proxy AID interpreter  to be used in processing the corresponding AID (). Note that the same procedure can be used here to obtain the appropriate proxy AID interpreter  as described above in relation to . (It will be appreciated that there may be a different proxy AID interpreter  to download for each application  on card ).","Once the terminal has the appropriate proxy AID interpreter for an AID, it can now decode that AID to determine the Firewall ID and Applet ID encoded into the AID. This then allows the terminal to perform the matching of RID, Firewall ID and Applet ID in order to identify a desired application for use in this particular session (). The proxy AID interpreter  can adopt the same procedure to identify a matching application as described above in relation to card AID interpreter  on the card itself (see ). After this matching has been completed, the terminal notifies the card (reference numeral , see also ) of the applet that matches the above parameters (RID, Firewall ID and Applet ID). According to one embodiment, this is achieved by returning the (complete) AID of the desired matching application from the terminal  to the smart card . This then allows the card to launch the specified matching applet (reference numeral , see also  again).","One advantage of performing parameter matching on the terminal instead of on the card is that resources (memory, processing power, etc) are much more readily available on the terminal than on the card. On the other hand, there is the potential as mentioned above of having to download multiple AID proxy interpreters onto the terminal, one for each applet on the card, which may be relatively time-consuming. In practice however, the number of proxy AID interpreters to download can be significantly reduced by looking at the RID  obtained by the terminal at . If this RID matches the RID of the application desired by the terminal, then the terminal proceeds to obtain a proxy AID interpreter  for the associated AID. However, if the extracted RID does not match the RID of the application desired by the terminal, then there is no need to download the corresponding proxy AID interpreter , since this application cannot represent the desired application. Consequently, reference numeral  need only be performed with respect to those AIDs that contain a matching RID, thereby greatly reducing the number of proxy AID interpreters to be downloaded to the terminal.","This situation is depicted in , which illustrates in more detail some of the processing of . (The dotted box in  corresponds to the box of the same number in ). According to one embodiment, the procedure of  is performed in respect of each AID byte string received by the terminal  from the card .","The procedure of  commences with the extraction of the RID from the AID (), as previously discussed in relation to . A test is now performed to see if the RID for this received AID matches the RID of the desired application (). If not, then it is known that it is not desired to activate the applet on the card from which this AID has been received, and so the AID can be discarded, or other appropriate action taken ().","Assuming however that there is an RID match, the terminal now has to determine which proxy AID interpreter to use for the AID (), whereupon the relevant proxy AID interpreter is identified and installed onto the terminal () (if it is not already present). Note that the identification and installation of the desired proxy AID interpreter is generally driven off the RID, as described above in relation to . The proxy AID interpreter  is now initialized with the corresponding AID string from the smart card  (), which then allows it to proceed with the parameter matching of reference numeral .",{"@attributes":{"id":"p-0183","num":"0188"},"figref":["FIG. 13","FIG. 6","FIG. 12","FIG. 13","FIG. 6"],"b":["162","164","172","501","502","502","1345","1354","1356","411"]},"(Note that for clarity the AID and the RID are treated separately here, with two distinct calls being made to obtain them. However, it will be appreciated that since the RID is encoded in a fixed position within the AID, these two can be handled by a single operation. In other words, there is no particular need to make a get_RID( ) call, but rather the RID can be obtained as and when required from the first five bytes of the retrieved AID).","The applet selector now returns the set of parameters for each applet back to the terminal (reference numerals  and ). The terminal matches the parameters received from the card against the parameters for the desired application (). Note that because this matching is being performed using parameters supplied from the card, rather than the terminal itself having to derive the parameters from the AID string (as in the procedure of ), there is no need at this stage for the terminal to have the relevant proxy AID interpreter(s)  installed or downloaded.","In one embodiment, the terminal  has just a single application to match. Once this (single) application has been identified at , processing can now proceed to , where the terminal instructs the card to launch this applet (for example by providing its full AID), with the card then responding accordingly ().","The proxy AID interpreter  corresponding to the selected applet may be pre-installed on the terminal. This is particularly likely if the terminal  only supports a single application, since in this case only one proxy AID interpreter  will generally be needed, but may also apply if the terminal supports multiple applications. In alternative embodiments, the terminal downloads the proxy AID interpreter  for the matching application either before, during, or after reference numeral . (The download of the AID interpreter is not shown in , but can be as illustrated with respect to  or , and the subsequent installation and initialization of ).","It will be appreciated that the precise timing of any such download of a proxy AID interpreter  to terminal  is based at least in part on the particular selected application. For example, the AID string may contain some data value that affects the start-up or operation of the applet on the card at . In these circumstances therefore, the proxy AID interpreter  should be available on terminal  to decode this data value before the terminal can send the appropriate applet launch command to the card at .","In the embodiment shown in , multiple applications may be matched at . For example, in one embodiment the terminal tries to identify all those applications that are present on the card that the terminal could potentially interact with (i.e. conduct a commercial transaction with). Accordingly, if there is a first set of applications installed on the card, and a second set of applications supported by the terminal, then at  the terminal identifies the intersection of these two sets (such as by looking for matching parameters, namely RID, Firewall ID, and applet ID).","The terminal now presents a choice or listing of these matching applications to a user, for example as a menu on a touch screen (). This enables the holder of a multi-function card  who is acting with a multi-function terminal to select the particular application to be used for this session (), again perhaps by using a touch-sensitive screen at a kiosk terminal. (More generally, the user would select the desired type of service or operation, and the terminal would then invoke the application corresponding to this form of service). The terminal now informs the card of the application that has been selected by the user (), allowing the card to launch this application accordingly, as previously described ().","It is also possible for the procedure of  to be modified in order to provide an opportunity for a user to select a desired application. In this case reference numeral  could represent a determination of those applications mutually supported by both the terminal and the card, with the user then selecting one of these applications. The terminal then informs the card of which application to launch, as described above in relation to  (reference numerals  and ).","However, such a procedure would generally involve the terminal downloading multiple proxy AID interpreters  in order to allow parameters (Firewall ID, etc) to be extracted from the various AIDs received from the applications on card  (as per reference numeral  of ). In contrast, download of the proxy AID interpreters  to the terminal  can be deferred in the procedure of  until after the user has selected a desired application (). At this stage, there is only a single proxy AID interpreter  to download. (This download is not shown in , but may occur before, during or after the launch of the selected applet).","In some circumstances, it may be that the presentation of options to a user () is dependent on information encoded into the AID (other than the RID, Firewall ID and Applet ID components received from the smart card itself). For example, an AID may incorporate an expiry date encoded into Other portion C, after which the associated application is no longer available to the user. For this type of situation, one possibility is to download the proxy AID interpreter  for the application (such as by using the method of ) prior to presenting the user with the set of available options (i.e. before reference numeral ). This then allows data from the various AIDs to be decoded by the respective proxy AID interpreters, and used to tailor suitably the options presented to the user at . For example, if an application expiry date has passed, the corresponding application can then be omitted from the list of applications presented to the user.","It will be noted that such an approach again requires potentially multiple AID interpreters to be downloaded to terminal . This can be avoided by having the additional information (such as an expiry date) accessed and decoded by the card AID interpreter . As previously described, the card AID interpreter  generally knows how to unpack such additional components of the AID, even if it does not know what the additional components represent or how to process them.","For example, at , the card AID interpreter  may obtain not only the RID, Firewall ID and Applet ID, but also an expiry date encoded into the AID. (From the perspective of the card AID interpreter , the expiry date is generally simply an additional piece of abstract data encoded into the Other portion C of the AID ). This expiry date can then be supplied by the card to the terminal at , along with the RID, Firewall ID and Applet ID. The terminal can then use this additional parameter as appropriate in further processing (for example, in making a decision as to whether or not the corresponding application is available for the cardholder to use). Note that such processing does not necessarily compromise the generality of the terminal, since the terminal does not need to know how the additional information (e.g. the expiry date) is encoded into the AID itself. (The terminal may already know that the parameter exists, and how to interpret the parameter, in order to be able to interact properly with the application).","Another implication of the provision of multi-function terminals, i.e. terminals supporting a number of applications, is that each application has its own associated proxy  and associated back office program  (see ). Thus if a terminal supports only a single type of card application, then the proxy for this application can automatically be invoked on terminal  in response to the insertion or activation of card . Indeed, the proxy may only be sleeping or suspended between sessions with different cards.","On the other hand, if the terminal supports multiple applications, there may be a different proxy for each application. In this case, where the cardholder is able user to select the particular application to be used with the inserted card (such as discussed above in relation to ), then the terminal needs to ensure that the correct proxy is invoked to handle the user selected application.","In these circumstances, the terminal can be provided with a program (not shown in ) analogous to the applet selector program, which is used to determine the appropriate proxy to handle any given card session. In the embodiment of , this selector program is responsible for the interaction with the card through to receipt of the user selection of the desired application (). At this point, the selector program can then launch the proxy corresponding to the user selection. The proxy  can then download the corresponding proxy AID interpreter (if not already present), as well as launching the selected application on the card (reference numerals  and ).",{"@attributes":{"id":"p-0199","num":"0204"},"figref":["FIG. 13A","FIG. 12","FIG. 13A","FIGS. 8 and 9"],"b":["110","811","102","110","1330"]},"Once the terminal has identified the correct proxy  for use with the relevant application, this proxy is installed into the terminal (), unless it is already present. Thus the proxy code can be obtained over a network, in the same manner as the proxy AID interpreter code  (see ). The proxy code can now be initialized with the proxy AID interpreter code that has already been downloaded (), which in turn can be initialized with the AID received from the application (such as at reference numerals  or ). This leads to the general configuration of , whereby substantive processing of the user session can commence.","As already discussed, the approach described herein permits a more flexible and powerful use of an AID  on a smart card . One further mechanism for exploiting this increased flexibility is to use the AID to store information concerning the initial configuration of an application at load time.",{"@attributes":{"id":"p-0202","num":"0207"},"figref":["FIG. 14","FIG. 14"],"b":["351","102","1010","102","1020","1030","1040","1050"]},{"@attributes":{"id":"p-0203","num":"0208"},"figref":["FIG. 15","FIG. 14","FIG. 15","FIG. 14"]},"Thus as part of the instantiation process of reference numeral , the card AID interpreter  is created (including the AID object hierarchy such as shown in , B, C or D). According to one embodiment, this is achieved by calling appropriate methods (such as a factory method) on the applet being installed in order to instantiate the card AID interpreter  ().","The configuration program now generates the actual AID value to be stored into the card as part of the initialization (reference numeral  in ). (There is some flexibility in the timing of reference numeral , for example, in some embodiments the creation of the AID may precede the creation of the card AID interpreter at ). The newly created AID value can be used to encode various configuration data relating to the application that is being installed. Examples of configuration data that may be stored in the AID in this manner include: an indication of the physical and\/or software capabilities of the card (e.g. memory capacity, and whether a certain format of digital signatures is supported, the version number of an installed application, etc); general parameters governing card behavior, such as passwords and key lengths; and parameters relating to more application-specific properties, such as the maximum amount of money that may be stored in a purse object, or the maximum payment amount that may be made using the card without requiring a Personal Identification Number (PIN). It will be appreciated that multiple items of various configuration data can be incorporated into a single AID, subject to the available space limitations (in particular the 11 byte limit on the PIX portion of the AID).","Once the AID for the card and the program being installed has been generated by the configuration program, this is now passed to the card AID interpreter  (). In particular, a store_AID( ) method (or similar) is called on the card AID interpreter, and this is passed the AID string that was generated at . The card AID interpreter then acts to save the newly received AID string onto the card. The manner in which this is accomplished will depend upon the internal implementation of the card AID interpreter and how the AID is to be stored (such as depicted in , B, C and D). For example, in one embodiment the AID string is ultimately saved as a single byte array (as in ), or may be distributed into multiple components, each associated with a different AID subobject (as in ).","According to one embodiment, a security procedure associated with storing the AID, to ensure that a duly saved AID is not subsequently corrupted (either deliberately or accidentally) by an inappropriate repeat call of this facility. For example, some form of password can be required to use the store_AID( ) command, or alternatively the store_AID( ) command is perhaps only enabled at applet installation time.","Once the AID has been stored onto the card , the AID can then be accessed during subsequent configuration of the applet in order to derive the configuration information encoded into the AID (). According to one embodiment, the AID is accessed by making an appropriate call on the card AID interpreter . In one embodiment, this involves making a get_AID( ) method call on the AID interpreter, such as previously described, and then extracting the desired configuration information from the AID string. However, this generally requires the applet itself (or other configuration facility) to be able to decode the configuration information encoded into the AID. Thus in another embodiment, the card AID interpreter  itself decodes the configuration information stored in the AID string. Accordingly, in this embodiment the card AID interpreter  supports one or more method calls that provide specific access to configuration information from the AID string.","For example, the card AID interpreter  can support a get_AIDConfiguration( ) method call, which returns the full set of configuration data from the AID string, appropriately organized into a data structure or such-like. Alternatively, the card AID interpreter  can include a subobject which provides access to such data. It is also possible that the card AID interpreter  supports calls to access individual components of configuration data stored in the AID, e.g. a get_CardMemory( ) to retrieve the memory capacity on the card, although this tends to lead to a rather more complicated method signature for the card AID interpreter.","Once configuration data has been retrieved from the AID in this manner, this configuration data can then be used to control the particular software and data configuration adopted for the applet (). Examples of configuration data that can be stored into the AID include parameters that determine the characteristics of cryptographic algorithms used on the card (e.g. number of bits); memory usage (e.g. the number of bytes of card memory allocated to the application); the version number of various software support modules on the card; and so on. Making this information available to an applet via its AID helps to ensure that the installed applet conforms to properties of the smart card in question concerned (for example, the applet does not try to use more memory than is allocated to it on the card).","The above procedure therefore allows information about the card and the applet instance in the card environment to be encoded into the AID. This information can then be used to control the particular configuration of the applet as it is being installed. It will be appreciated that this provides a convenient software mechanism for optimizing the application configuration for the relevant environment, without having to depart from a relatively conventional or standardized loading procedure. In other words, rather than having to customize the installation process itself, any special configuration details can be encoded into the AID. The AID information can be used to control the precise configuration adopted without further external intervention, so that the applet instance is matched to the particular card on which the applet is installed, with different applet code or configurations being installed on different cards.","Attached to the present description is a set of Appendices. These provide documentation relating to one implementation of certain components described herein. Various features are detailed that are not necessarily relevant to the invention itself (although they are typical of a complete implementation). Nevertheless, the Appendices provide the skilled person with a general indication at the code level as to how an implementation may be developed.","Appendix A describes a card AID interpreter (corresponding for example to card AID interpreter  in ). Note that in this implementation, the Firewall ID A (see ) is stored in byte 6 of the AID, and the Applet ID B is stored in byte 7 of the AID. An Owner ID is then formed as the composite of the RID  and the Firewall ID A, while the Applet ID is (re)defined as the composite of the Owner ID and the Applet ID B. Applet selection can then be performed using the Applet ID (only), since this incorporates the RID , the Firewall ID A and the Applet ID B of . Note that from a logical perspective however, the selection is still utilizing these three parameters, which can be regarded as encoded into the (redefined) Applet ID.","With the particular byte allocations described in Appendix A, the RID, Owner ID and the Applet ID correspond to the first five, six and seven bytes respectively of the AID. However, in other implementations they may be encoded differently into the AID (except of course for the RID, whose location is governed by the ISO standard).","Appendices B, C, D and E describe four classes nested within the AID interpreter that respectively manage the various components of the AID, such as the RID portion, the Owner portion, and so on. This is somewhat analogous to the embodiment illustrated in .","Appendix F describes a proxy AID interpreter (corresponding for example to proxy AID interpreter  in ). Note that there is a predefined list of attributes that might potentially be encoded into an AID (and hence need interpreting). Attributes that are not supported by a particular card are set to null. Additional attributes may be supported by suitably extending the class of Appendix F.","Provided below is a summary of selected embodiments of the present invention.","According to one embodiment of the invention, a method for selecting a desired application on a smart card is provided. There are potentially two or more applications installed on the smart card, with each application having a stored application identifier (AID). The method comprises specifying a desired application in terms of multiple parameters, and retrieving multiple parameters from a stored AID for an application on the smart card. This then allows the specified multiple parameters to be compared with the retrieved multiple parameters to determine whether or not there is a match.","Existing implementations are based on selecting an application using a single parameter, namely a partial or complete AID. However, this lacks flexibility, in that the terminal must know the particular AID stored on the card in order to make a match. In contrast, the use of multiple parameters allows a matching process that is more aligned with the logical approach for selecting an application. This reduces the complexity of terminal management, and also enhances flexibility.","In many implementations, the multiple parameters do not occupy the full space of the AID. This therefore allows additional information to be encoded into the AID, beyond that used purely for application matching purposes (such as a date and\/or location of last use of the smart card). Note that the location of any such additional (non-matching) information is flexible, and can, in principle, be anywhere within the PIX portion of the AID. (In contrast, the use of a partial AID for application selection forces any non-matching information to be located at the end of the AID).","In one embodiment, the multiple parameters comprise a registered application provider identifier (RID), a firewall identifier, and an applet identifier. More particularly a smart card may be separated into one or more firewalls, with each application installed on the smart card being contained within one of the firewalls. One of the multiple parameters is therefore indicative of the firewall in which the desired application is contained, while another of the parameters comprises an applet ID that identifies an application within a firewall. It will be appreciated that while the RID represents a predefined first portion of the AID, the one or more remaining parameters may be distributed anywhere (and any how) within the predetermined second (PIX) portion of the AID.","Note that the above three parameters provide a logical set of criteria for selecting an application, compared to the more artificial approach of treating the AID as a single (or partial) byte sequence for matching. Nevertheless, in other circumstances or implementations, a different number of parameters may be used for the matching. For example, the firewall ID may be omitted for selection purposes if the applet ID is unique to a particular RID across all firewalls. Alternatively, a reduced number of parameters may be used to pick out a certain subset of applications (which can be difficult with simple AID matching). For example, it may be desired to locate all applets within a given firewall. This could be done by selecting on RID and firewall, but not on applet ID.","Note also that a given set of multiple parameters (such as RID, firewall ID and applet ID) may be combined or concatenated into one single data structure for matching purposes as an implementation convenience. However, this data structure should be regarded as logically comprising multiple parameters, since it may be assembled from different locations in the AID (rather than a contiguous block), and each of the parameters has individual significance.","In one embodiment, after a smart card is brought into communication with a terminal, the terminal transmits a request to the smart card specifying a desired application (or applications) in terms of the multiple parameters. This causes the smart card to select an application as described above. The smart card then returns to the terminal a response to the request. The response includes the AIDs of those applications whose retrieved parameters match the specified parameters.","In one particular implementation, the request from the terminal is received by an applet selector on the smart card. This causes the applet selector to call a method on an AID interpreter associated with each application on the smart card. The AID interpreters then retrieve the multiple parameters for their associated application. The retrieved parameters can then be returned to the applet selector for comparison with the parameters received from the terminal. Alternatively, the applet selector may forward the received parameters to the various AID interpreters, which can perform the comparison themselves, notifying the applet selector if any match is found.","In another embodiment, the application selection is performed on the terminal rather than on the smart card. In this approach, the interaction between the terminal and the smart card commences with the terminal transmitting a request to the smart card for information about the applications installed on the smart card. In some cases, the smart card may retrieve the multiple parameters from the AID of each application on the card, and then transmit these parameters to the terminal (optionally in conjunction with the full AID). The terminal then determines a desired application by matching against each set of multiple parameters. This allows the terminal to launch the desired application by returning the full AID for this application to the smart card.","Alternatively, in response to the initial request, the smart card may simply supply the set of full AIDs for the applications on the smart card. In these circumstances, it is the responsibility of the terminal to break down the AIDs into the multiple parameters. The terminal therefore has to identify the appropriate AID interpreter for performing this task. The desired AID interpreter(s) may already be available on the terminal, for example as a result of interactions with previous smart cards, and\/or may be downloaded over a network in response to the received AID(s). In one particular embodiment, the terminal identifies the desired AID interpreter based on the RID portion of the relevant AID, and then downloads the AID interpreter from an address which is dependent upon the RID. (N.B. The terminal can always access the RID, since its location within the AID is predefined and the same for all applications).","Another embodiment of the invention provides a smart card having multiple applications installed thereon. Each application includes a stored application identifier (AID) and an AID interpreter. The AID interpreter is used to retrieve and parse the stored AID into multiple parameters for identifying the application.","Another embodiment of the invention provides a terminal for use with a smart card having multiple applications installed thereon. Each application includes an application identifier (AID) and an AID interpreter. The AID interpreter is operable to retrieve and parse the AID into multiple parameters for identifying the application. The terminal includes at least one set of multiple parameters for identifying a desired application on the smart cart, and a communications interface for exchanging messages with the smart card. The parameters on the card can therefore be compared with the parameters in the terminal, by using the communications interface to send the card parameters to the terminal (or vice versa).","In accordance with another embodiment of the invention there is provided a computer program product comprising instructions on a medium. The instructions when loaded into a machine cause the machine to select a desired application on a smart card, where there are potentially two or more applications installed on the smart card, with each application having a stored application identifier (AID). The selection is performed by specifying a desired application in terms of multiple parameters and retrieving multiple parameters from a stored AID for an application on the smart card. The specified multiple parameters can then be compared with the retrieved multiple parameters in order to determine whether or not there is a match.","Note that a computer program product may comprise program instructions stored on a removable storage medium, for example an optical (CD ROM, DVD, etc) or magnetic (floppy disk, tape, etc) device. Such a medium can then be introduced into a computer system in order to transfer the program instructions to the system. Alternatively, the program instructions may be transferred to the computer system by download via a transmission signal medium over a network, for example, a local area network (LAN), the Internet, and so on. According to one embodiment, the transferred program instructions are stored on a hard disk of a computer system, and loaded for use into random access memory (RAM) for execution by a system processor.","It will be appreciated that the apparatus and computer program product embodiments of the invention will generally benefit from the same particular features described above as the method embodiments of the invention.","While embodiments and applications of this invention have been shown and described, it would be apparent to those skilled in the art having the benefit of this disclosure that many more modifications than mentioned above are possible without departing from the inventive concepts herein. The invention, therefore, is not to be restricted except in the spirit of the appended claims.","Class AID",{"@attributes":{"id":"p-0234","num":"0239"},"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"21.51mm","wi":"33.27mm","file":"US07140549-20061128-C00001.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"Readable, java.io.Serializable","Direct Known Subclasses:","SunAIDEncoding\n\n","A representation of the Application Identifier with support for a Java Card standardized encoding of additional data in the PIX field. This class and the complementary interpreter class provide a key functionality for generic support of card application management and application interoperability in the Java Card application framework. This class explicitly provides enhanced support for the selection of Java Card Applets by the terminal using a partial AID.","In particular this class provides support for the following distinct data elements associated with the Applet which are encoded in the ISO standardized AID byte [ ] representation (see below for the default encoding scheme):\n\n","In this design each applet provides its own derived class with appropriate implementations of the abstract methods. The OwnerID is different from the RID as according to ISO rules an organization can only obtain a single RID. But, the card issuer may also be the provider of an applet on the card but may want to specify different owners for the loading Applet (function) and the other applet. And also, the issuer may want to distinguish ownership of library packages from both the loading applet and the other applet. Similarly, the AppletID is different from the OwnerID, as the same owner may have more than one collaborating applet, where each applet is specified by the owner as selectable separately.","Encoding and Interpretation","The encoding and interpretation of the data elements actually contained in an AID may in general be specific to the application provider (registered entity). However, this class provides a default encoding for the first, non optional, data elements contained in the PIX as described below. The encoding of optional data elements in the PIX field is not defined, and must be specified in a sub class of this class when such optional data is required. This class provides the framework for such optional data to be used. The in-card interpretation of the optional instance data, and possible use of this data for install-time configuration is not specified here. However, an abstract class is provided as a basis for the representation in the card of such configuration information.","Interpreting the AID information in a terminal may be accomplished by using the interpreter instance. Typically, a sub class of the AIDInterpreter class will be used to represent any of the optional data elements. The AID interpreter may be provided to the terminal via a provisioning mechanism that uses the unique value of the RID in any given AID. Interpreting the data encoded in the AID by that class might involve retrieving data from the world wide web.","Applet Selection, Firewall and Ownership","The AID class provides explicit support for selection of applets by partial AID with the implementation of the methods #matchId ( ), #matchOwner ( ) and #matchRID ( ). The mechanism provided by these methods addresses the issue of partial matching which has been left underspecified in version 2.1 of the Java Card technology specifications.","An implementation of the Select Applet command may use these methods by examining all Applets in a card in a sequence of increasingly less specific matches. First the applets are tested for a matching applet identifier, using the matchId ( ). If no Applet has been identified the applets are tested for a match on the owner ID using matchOwner ( ). And finally, if that does not identify a single Applet, all Applets are tested for a match on the RID using matchRID ( ). This three stage matching algorithm provides full functional backward compatibility with Applets that are implemented with the javacard.framework.AID class (version 2.1).","Encoding","The AID class provides a default encoding of the AID in a sequence of maximally 16 bytes. The encoding follows the following rules (see the diagram):\n\n","In order to use either version data, configuration data or applet state data a sub class of this class must be defined that overrides the relevant methods, getVersion ( ), getConfiguration ( ) and readStateBytes ( ), respectively.","The default encoding of the data elements defined by the AID java class is summarized in the following table.",{"@attributes":{"id":"p-0247","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"16"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"10","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"11","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"12","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"13","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"14","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"15","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"16","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"16","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["RID","PIX"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["OwnerID",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AppletID","AF","Optional Data Elements"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":"AF = Application Function ID"}]}}]}},"br":{}},"The specification of the class supports enhanced interoperability in application selection and card management with a set of reserved encoding constants and corresponding standard decoding methods. This allows card applications to identify specific common roles in the card by examining the AID of applications. In the default encoding of the OwnerId and the Application ID the values 0x00 and 0xFF have been specified for this purpose. The default encoding implemented in this class uses these constants, implementations of alternative encoding schemes may use different values. The meaning of the special values can be asserted with:","OwnerId.#isIssuer ( )","This applet is controlled by the card issuer. It may be the applet management Applet, or an other card management related applet. The default coding value is 0XFF.","OwnerId.#isNotControled ( )","This applet is not actively controlled by its owner as may be specified by its AID. It may be an applet that contains personal data related to and entered by the cardholder. The default coding value is 0X00.","AppletId.#isManager ( )","This Applet is the card's applet management Applet or a delegated management Applet. The Application Management Applet must be owned by the card issuer. The default coding value is 0XFF.","AppletId.#isInformation ( )","This applet provides information, e.g. pertaining to the cardholder. In addition to returning true in this method a cardholder data applet may indicate itself as not being controlled. The default coding value is 0X00.","Alternative encoding, e.g. to allow more space for optional data elements may be provided by overriding the relevant methods in this class. Any coding scheme should fully support the non optional data elements and their specific function codes.","Implementation Design","The class is implemented as wrapper around a data representation as a byte [ ]. Accessor methods and inner classes are specified to access and represent the types of the data elements that may be represented by an instance of the class. The implementation choice for the byte [ ] data representation is intended to improve the speed of retrieval of an AID. This retrieval may happen after the chip is reset when a list of all AIDs in the card may be assembled. Also, this data representation greatly simplifies the implementation of different encoding rules in possible subclasses.","The implementation of the classes to represent the component data elements similarly is as wrappers around byte [ ]. In the implementation instances of these classes share their data representation with their parent AID instance. With some increase in code complexity this design may be advantageous in speed and storage requirements. Security in the use of the AID is also enhanced, in that after the value of an instance has been committed to the non volatile card memory during Applet installation the information in it is never changed over the lifetime of an Applet. The implementation of and its component data type classes as a wrapper leverages the functionality provided by Buffer class that implements a generic wrapper around a byte [ ]. The Buffer is actually used as the base class for all these classes and supports the access to a shared byte [ ]. The shared byte [ ] holds the single constant data representation of the instance in the card memory. These data component types completely encapsulate the actual encoding and expose only the required semantic functionality.","The types defined for the data elements are:\n\n","The classes for the AID component data elements also implement the Readable interface (via the base class ReadableBuffer) to facilitate retrieval as ISO files.","The class is an extension of the class and provides source code compatibility with existing applet implementations. Functionally, however, this class supersedes its base class completely.","Java Card Converter Issues","The class implements the Serializable interface to support full card emulation with persistent in-card state. The implementation also provides methods to parse and produce a human readable form of the AID. These methods utilize in their implementation classes that are not part of the JCRE (StringTokenizer). With these features the implementation assumes the Java Card convertor to silently remove the interface and the non-convertible methods from the converted in-card class definition.","Note","This class, com.sun.smartcard., extends the javacard.framework. class only to provide backward compatibility with existing card platform implementations, functionally this class replaces the original base class completely.",{"@attributes":{"id":"p-0262","num":"0288"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Nested Class Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Static class","AID.AppletId"]},{"entry":[{},"\u2003\u2003Represent the unique reference to an Applet"]},{"entry":[{},"\u2003\u2003that is contained in an ."]},{"entry":["Static class","AID.ConfigurationData"]},{"entry":[{},"\u2003\u2003Represent the Applet instance configuration"]},{"entry":[{},"\u2003\u2003data that may be contained in an ."]},{"entry":["Static class","AID.OwnerId"]},{"entry":[{},"\u2003\u2003Represent the owner of an Applet instance"]},{"entry":[{},"\u2003\u2003that is contained in an ."]},{"entry":["Static class","AID.RID"]},{"entry":[{},"\u2003\u2003Represent the RID (Registered ID) part of an AID."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0263","num":"0289"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private","data"]},{"entry":[{},"byte[ ]","\u2003\u2003The data representation of an AID is a byte[ ]."]},{"entry":[{},"private","SIZE"]},{"entry":[{},"static short","\u2003\u2003The size of an AID is fixed."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0264","num":"0290"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructor Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["protected","AID( )"]},{"entry":[{},"\u2003\u2003Create an Empty AID."]},{"entry":[{},"AID(AID.RID rid)"]},{"entry":[{},"\u2003\u2003Create an AID with a specific RID encoding."]},{"entry":[{},"AID(byte[ ] encoding)"]},{"entry":[{},"\u2003\u2003Create an AID from a specific full length encoding."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0265","num":"0291"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(package private)","getAppletId( )"]},{"entry":["AID.AppletId","\u2003\u2003Get the AppletId part from an AID."]},{"entry":["Protected","getAssignedRID( )"]},{"entry":["AID.RID","\u2003\u2003Obtain the RID assigned to a card issuer or an application"]},{"entry":[{},"provider."]},{"entry":["AID.Configuration","getConfiguration( )"]},{"entry":["ionData","\u2003\u2003Obtain the configuration data part from the AID."]},{"entry":["byte","getFunctionCode( )"]},{"entry":[{},"\u2003\u2003Obtain a descriptor of the function of the applet conforming to"]},{"entry":[{},"ISO\/IEC 14443 This method uses the default encoding, with the one"]},{"entry":[{},"byte code immediately following the AID.AppletId."]},{"entry":["(package private)","getOwnerId( )"]},{"entry":["AID.OwnerId","\u2003\u2003Get the OwnerId part from an AID."]},{"entry":["(package private)","getRID( )"]},{"entry":["AID.RID","\u2003\u2003Get the RID part from an AID."]},{"entry":["short","getVersion( )"]},{"entry":[{},"\u2003\u2003Obtain a descriptor value indicative of the version of the applet"]},{"entry":[{},"code."]},{"entry":["boolean","matchId(byte[ ] encoding, short offset)"]},{"entry":[{},"\u2003\u2003Compare the AID with a given encoding as used when the Applet"]},{"entry":[{},"instance that holds the AID is considered for \u201cselection by AID\u201d."]},{"entry":["boolean","matchOwner(byte[ ] encoding, short offset)"]},{"entry":[{},"\u2003\u2003Compare the AID with a given encoding as used when the"]},{"entry":[{},"Applet instance that holds the AID is considered for \u201cselection by"]},{"entry":[{},"AID\u201d."]},{"entry":["boolean","matchRID(byte[ ] encoding, short offset)"]},{"entry":[{},"\u2003\u2003Compare the AID with a given encoding as used when the"]},{"entry":[{},"Applet instance that holds the AID is considered for \u201cselection by"]},{"entry":[{},"AID\u201d."]},{"entry":["static AID","parse(java.lang.String data)"]},{"entry":[{},"\u2003\u2003Interpret a comma separated list of numbers in a string as an"]},{"entry":[{},"AID."]},{"entry":["short","read(byte[ ]  buffer, short offset, short dataskip,"]},{"entry":[{},"short length)"]},{"entry":[{},"\u2003\u2003Append a serialized representation of the AID to a given byte[ ]."]},{"entry":["protected short","readStateBytes(byte[ ] result, short off, short length)"]},{"entry":[{},"\u2003\u2003Append the byte[ ] representation of the current Applet State to"]},{"entry":[{},"the AID's linear representation."]},{"entry":["protected void","setdata(byte[ ] data)"]},{"entry":[{},"\u2003\u2003Set the data representation for this AID to the specified array of"]},{"entry":[{},"bytes."]},{"entry":["java.lang.String","toString( )"]},{"entry":[{},"\u2003\u2003Represent the AID as a string of up to 16 hexadecimal integers."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{},{},{},{}],"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["private static final","short SIZE"]}},"The size of an AID is fixed.","data",{"@attributes":{"id":"p-0267","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["private byte [ ]","data"]}},"The data representation of an AID is a byte [ ]. This representation storage is shared by all the data elements that are encoded in it.","Constructor Detail","AID","protected","AID ( )","Create an Empty AID. This constructor is for use in subclasses; subclasses constructed with this constructor need to use the set data ( ) to initialize it properly. This definition allows the use of anonymous inner classes in the implementation of a specific Applet subclass to implement an AID. In this way the implementation of the readStateBytes ( ) method can be done with direct access to relevant state objects.","AID",{"@attributes":{"id":"p-0272","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":"public AID (AID.RID rid)"}},"Create an AID with a specific RID encoding.","AID",{"@attributes":{"id":"p-0274","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":["public","AID (byte [ ] encoding)"]}},"Create an AID from a specific full length encoding. An encoding longer than 16 bytes is silently truncated, an encoding shorter than 5 bytes is an error.","Method Detail","parse",{"@attributes":{"id":"p-0276","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":["public static AID","parse(java.lang.String data)"]}},"Interpret a comma separated list of numbers in a string as an AID.","Note","This method uses classes that are not part of the JCRE and as a consequence will be skipped by the Java Card converter when building the in-card definition of the class. As a consequence none of the in-card methods can refer to this method.","toString",{"@attributes":{"id":"p-0279","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["public","java.lang.String toString ( )"]}},"Represent the AID as a string of up to 16 hexadecimal integers.","Overrides:","toString in class java.lang.Object","setdata",{"@attributes":{"id":"p-0283","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["protected","final void setdata(byte [ ] data)"]}},"Set the data representation for this AID to the specified array of bytes.","getRID",{"@attributes":{"id":"p-0285","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":["final AID.RID","getRID ( )"]}},"Get the RID part from an AID.","Returns:\n\n","Obtain the RID assigned to a card issuer or an application provider. This method is intended for use in the constructor of a subclass of the to assure consistency of the data received with the representation specific to the sub class. To be used as intended this method should return the constant instance of a {link RID} class that is initialized with the RID prefix of AIDs that are decoded by the subclass.","Returns:\n\n","Get the OwnerId part from an AID.","Returns:\n\n","Get the AppletID part from an AID.","Returns:\n\n","Obtain a descriptor of the function of the applet conforming to ISO\/IEC 14443 This method uses the default encoding, with the one byte code immediately following the AID.AppletId.","Returns:\n\n","Obtain a descriptor value indicative of the version of the applet code. The default encoding does not include a version number; by default this method returns 0.","Returns:\n\n","Obtain the configuration data part from the AID. During applet instantiation this data may be used to initialize the applet instance configuration. In addition, this object may include configuration data relevant to instance specific security initialization.","readStateBytes",{"@attributes":{"id":"p-0299","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["protected short","readStateBytes (byte [ ] result,","short off,","short length)"]}},"Append the byte [ ] representation of the current Applet State to the AID's linear representation.","The default implementation does nothing. Applets that want to transfer dynamic state information in the AID can do so by overriding this method with an implementation that calls the appropriate (public, package) methods in the Applet subclass.","The method signature is compatible with File.Readable.read ( ).","read",{"@attributes":{"id":"p-0303","num":"0000"},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":["public short","read (byte [ ] buffer,\n    \n    ","short dataskip,","short length)"]}},"Append a serialized representation of the to a given byte [ ]. This method may be used to use a READ BINARY COMMAND to access the value of the AID.","This implementation is based on the default JavaCard AID encoding rules and its result is obtained by appending the results of the inherited read ( ) for AppletId getVersion ( ) and getConfiguration ( ), respectively, to the specified byte [ ]. When a subclass is used to implement an alternative encoding this method may need to be overridden.","The signature of this method is specified by the core version of the Readable interface method and its implementation utilizes the similar lesser OO interface for its AppletId and Configuration components. A more sophisticated design could utilize the Readable.WithStream.read(com.sun.smartcard.util.Stream.Writer) method which has a more OO signature.","WARNING:","This implementation is incomplete as it does not provide error and parameter checking; it is provided as example, e.g. of the use of the Readable interface.","Specified by:","read in interface Readable","Parameters:","dataskip-***Ignored***","matchId",{"@attributes":{"id":"p-0313","num":"0000"},"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":["public final boolean","matchId(byte [ ] encoding,","short offset)"]}},"Compare the with a given encoding as used when the Applet instance that holds the is considered for \u201cselection by AID\u201d. The comparison is restricted to the data included in the AppletID. If no applet is found with a match using this method, the list of applets will be searched again for a match using the matchOwner(byte [ ], short) method.","Note:","While the default encoding as provided by this class performs the comparison on a prefix of the byte [ ], alternate encoding schemes, may be implemented by a sub class which could involve possible discontinuous segments of the encoding. When such alternative encoding is used the partial matching may actually require a full, 16 byte data representation to be presented as the argument to this method. In the default encoding only a prefix that contains the applet ID is needed.","The actual matching is performed by the Buffer.match(byte [ ], short) method.","The input parameters include an offset to facilitate matching of the against the raw content of the APDU buffer.","Parameters:","encoding\u2014a byte [ ] containing a possible encoding of an ","offset\u2014the offset in the specified byte [ ] where the actual encoding starts in the encoding","Returns:","true iff the appletID part of this matches the specified encoding.","matchOwner",{"@attributes":{"id":"p-0324","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["public final boolean","matchOwner(byte [ ] encoding, short offset)"]}},"Compare the AID with a given encoding as used when the Applet instance that holds the is considered for \u201cselection by AID\u201d. The comparison is restricted to the data included in the OwnerID; this method is typically called when no Applet instance is found that matches on the AppletID. If no applet is found with a match using this method, the list of applets will be searched again for a match using the matchRID(byte [ ], short)","Note:","While the default encoding as provided by this class performs the comparison on a prefix of the byte [ ], alternate encoding schemes, may be implemented by a sub class which could involve possible discontinuous segments of the encoding. When such alternative encoding is used the partial matching may actually require a full, 16 byte data representation to be presented as the argument to this method.","The actual matching is performed by the Buffer.match(byte [ ], short) method.","The input parameters include an offset to facilitate matching of the against the raw content of the APDU buffer.","Parameters: encoding\u2014a byte [ ] containing a possible encoding of an AID.\n\n","Compare the AID with a given encoding as used when the Applet instance that holds the is considered for \u201cselection by AID\u201d. The comparison is restricted to the data included in the RID part; this method is typically called when no Applet is found that matches on the Owner ID. If no Applet is found with a match using this method, then no applets in the card exist that match the given ID and the select by AID command will return a failure.","The actual matching is performed by the Buffer.match(byte [ ], short) method.","The input parameters include an offset to facilitate matching of the against the raw content of the APDU buffer.","Note:","While the default encoding as provided by this class performs the comparison on a prefix of the byte [ ], alternate encoding schemes, may be implemented by a sub class which could involve possible discontinuous segments of the encoding. When such encoding is used partial matching may require a full, 16 byte encoding to be presented as the argument to this method.","Parameters:\n\n","Returns:\n\n","Class AID.RID",{"@attributes":{"id":"p-0338","num":"0409"},"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"39.88mm","wi":"57.74mm","file":"US07140549-20061128-C00002.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"Readable","Enclosing class:","AID\n\n","This class is a wrapper around a serialized data representation, which may be shared with the parent AID.","A generic wrapper class for byte [ ], ReadableBuffer is used as a base class.","Nested Class Summary","Nested classes inherited from class com.sun.smartcard.util.Readable","Readable.WithStream","Field Summary","Fields inherited from class com.sun.smartcard.util.Bytes",{"@attributes":{"id":"p-0343","num":"0417"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructor Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Private","AID.RID( )"]},{"entry":[{},"\u2003\u2003Construct an empty instance, for exclusive use by the"]},{"entry":[{},"\u2003\u2003AID class."]},{"entry":[{},"AID.RID(byte[ ] encoding)"]},{"entry":[{},"\u2003\u2003Construct an instance with a given data representation."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0344","num":"0418"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["protected","getData( )"]},{"entry":["byte[ ]","\u2003\u2003Share the data with the enclosing class."]},{"entry":["short","getLength( )"]},{"entry":[{},"\u2003\u2003Get the length of the data in the byte array for a RID (5)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{},{},{},{},{},{},{},{}],"ul":{"@attributes":{"id":"ul0041","list-style":"none"},"li":"public AID.RID(byte [ ] encoding)"}},"Construct an instance with a given data representation.","AID.RID",{"@attributes":{"id":"p-0346","num":"0000"},"ul":{"@attributes":{"id":"ul0042","list-style":"none"},"li":"private AID.RID ( )"}},"Construct an empty instance, for exclusive use by the AID class.","Method Detail","getLength",{"@attributes":{"id":"p-0348","num":"0000"},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":"public final short getLength ( )"}},"Get the length of the data in the byte array for a RID (5). The size of the RID is defined in ISO\/IEC 7816-5","Overrides:\n\n","Share the data with the enclosing class.\n\n","Class AID.OwnerId",{"@attributes":{"id":"p-0352","num":"0433"},"chemistry":{"@attributes":{"id":"CHEM-US-00003","num":"00003"},"img":{"@attributes":{"id":"EMI-C00003","he":"39.88mm","wi":"59.35mm","file":"US07140549-20061128-C00003.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"Readable","Enclosing class:","AID\n\n","Represent the owner of an Applet instance that is contained in an . The owner of data in a Java Card Memory specifies the firewall that controls access to data.","This class is a wrapper around a serialized data representation, which may be shared with the parent AID. A generic wrapper class for byte [ ], ReadableBuffer is used as a base class.","Nested Class Summary","Nested classes inherited from class com.sun.smartcard.util.Readable","Readable.WithStream","Field Summary","Fields inherited from class com.sun.smartcard.util.Bytes",{"@attributes":{"id":"p-0357","num":"0440"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructor Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["private","AID.OwnerId( )"]},{"entry":[{},"\u2003\u2003Construct an empty instance, for exclusive use by the AID"]},{"entry":[{},"\u2003\u2003class as wrapper on a shared data representation."]},{"entry":[{},"AID.OwnerId(byte[ ] code)"]},{"entry":[{},"\u2003\u2003Construct an instance as wrapper on the specified"]},{"entry":[{},"\u2003\u2003data representation."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0358","num":"0441"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["short","getLength( )"]},{"entry":[{},"\u2003\u2003Get the length of the data in the byte array for the Owner"]},{"entry":[{},"\u2003\u2003part of the AID."]},{"entry":["(package","getRID( )"]},{"entry":["private)","\u2003\u2003Get the RID part from the OwnerID."]},{"entry":"AID.RID"},{"entry":["boolean","isIssuer( )"]},{"entry":[{},"\u2003\u2003Test for Card Issuer reserved value encoding."]},{"entry":["boolean","isNotControled( )"]},{"entry":[{},"\u2003\u2003Test for \u201cnot owner controlled\u201d reserved value encoding."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{},{},{},{},{},{},{},{}],"ul":{"@attributes":{"id":"ul0048","list-style":"none"},"li":"public AID.OwnerId(byte [ ] code)"}},"Construct an instance as wrapper on the specified data representation. This constructor is implemented by the constructor of the ReadableBuffer with the same signature.","AID.OwnerId",{"@attributes":{"id":"p-0360","num":"0000"},"ul":{"@attributes":{"id":"ul0049","list-style":"none"},"li":"private AID.OwnerId ( )"}},"Construct an empty instance, for exclusive use by the class as wrapper on a shared data representation.","Method Detail","getLength","public short getLength ( )","Get the length of the data in the byte array for the Owner part of the AID. This method implements the default encoding rules, with the OwnerId being a one byte extension of the RID and therefore returns the value six.","Overrides:","getLength in class Bytes","Returns:","6","getRID",{"@attributes":{"id":"p-0366","num":"0000"},"ul":{"@attributes":{"id":"ul0050","list-style":"none"},"li":"final AID.RID getRID ( )"}},"Get the RID part from the OwnerID.","isIssuer",{"@attributes":{"id":"p-0368","num":"0000"},"ul":{"@attributes":{"id":"ul0051","list-style":"none"},"li":"public final boolean isIssuer ( )"}},"Test for Card Issuer reserved value encoding.","isNotControled",{"@attributes":{"id":"p-0370","num":"0000"},"ul":{"@attributes":{"id":"ul0052","list-style":"none"},"li":"public final boolean isNotControled ( )"}},"Test for \u201cnot owner controlled\u201d reserved value encoding.","Class AID.AppletId",{"@attributes":{"id":"p-0372","num":"0456"},"chemistry":{"@attributes":{"id":"CHEM-US-00004","num":"00004"},"img":{"@attributes":{"id":"EMI-C00004","he":"39.88mm","wi":"59.35mm","file":"US07140549-20061128-C00004.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"Readable","Enclosing class:","AID\n\n","Represent the unique reference to an Applet that is contained in an . Guaranteeing the uniqueness of an applet ID is left to the owner of the applet. The default implementation uses one additional byte appended to the encoding of the Owner.","This class is a wrapper around a serialized data representation, which may be shared with the parent AID. A generic wrapper class for byte [ ], ReadableBuffer is used as a base class.","Nested Class Summary","Nested classes inherited from class com.sun.smartcard.util.Readable","Readable.WithStream","Field Summary","Fields inherited from class com.sun.smartcard.util.Bytes",{"@attributes":{"id":"p-0377","num":"0463"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructor Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["private","AID.AppletId( )"]},{"entry":[{},"\u2003\u2003Construct an empty instance, for exclusive use by the AID"]},{"entry":[{},"\u2003\u2003class."]},{"entry":[{},"AID.AppletId(byte[ ] code)"]},{"entry":[{},"\u2003\u2003Construct an instance with a given data representation."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0378","num":"0464"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["short","getLength( )"]},{"entry":[{},"\u2003\u2003Get the length of the data in the byte array for the"]},{"entry":[{},"AppletId component of the ."]},{"entry":["(package","getOwnerId( )"]},{"entry":["private)","\u2003\u2003Get the Owner Identifier contained"]},{"entry":["AID.OwnerId","\u2003\u2003in the applet identifier."]},{"entry":["boolean","isInformation( )"]},{"entry":[{},"\u2003\u2003Test for \u201cnot owner controlled\u201d reserved"]},{"entry":[{},"\u2003\u2003value encoding."]},{"entry":["boolean","isManager( )"]},{"entry":[{},"\u2003\u2003Test for Card Issuer reserved value encoding."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{},{},{},{},{},{},{},{}],"ul":{"@attributes":{"id":"ul0054","list-style":"none"},"li":"public AID.AppletId(byte [ ] code)"}},"Construct an instance with a given data representation.","AID.AppletId",{"@attributes":{"id":"p-0380","num":"0000"},"ul":{"@attributes":{"id":"ul0055","list-style":"none"},"li":"private AID.AppletId ( )"}},"Construct an empty instance, for exclusive use by the AID class.","Method Detail","getLength",{"@attributes":{"id":"p-0382","num":"0000"},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":"public short getLength ( )"}},"Get the length of the data in the byte array for the AppletId component of the . This method implements the default encoding rules, with the AppletId being a one byte extension of the OwnerID and therefore returns a value of seven.","Overrides:","getLength in class Bytes","Returns:","7","getOwnerId",{"@attributes":{"id":"p-0386","num":"0000"},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":"final AID.OwnerId getOwnerId ( )"}},"Get the Owner Identifier contained in the applet identifier.","isManager",{"@attributes":{"id":"p-0388","num":"0000"},"ul":{"@attributes":{"id":"ul0058","list-style":"none"},"li":"public final boolean isManager ( )"}},"Test for Card Issuer reserved value encoding.","isInformation",{"@attributes":{"id":"p-0390","num":"0000"},"ul":{"@attributes":{"id":"ul0059","list-style":"none"},"li":"public final boolean isInformation ( )"}},"Test for \u201cnot owner controlled\u201d reserved value encoding.","Class AID.ConfigurationData",{"@attributes":{"id":"p-0392","num":"0479"},"chemistry":{"@attributes":{"id":"CHEM-US-00005","num":"00005"},"img":{"@attributes":{"id":"EMI-C00005","he":"39.96mm","wi":"69.00mm","file":"US07140549-20061128-C00005.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"Readable","Direct Known Subclasses:","CardHolderDataApplet.CardHolderDataConfiguration","Enclosing class:","AID\n\n","Represent the Applet instance configuration data that may be contained in an . The configuration data, when present in an AID may be used when the Applet is instantiated to configure its components. For instance, the size of an array of object that represent a set of user data may be specified in the configuration. This class to be extended when a configuration is present on the encoding of an AID.","This class is a wrapper around a serialized data representation, which may be shared with the parent AID. A generic wrapper class for byte [ ], ReadableBuffer is used as a base class;","The current version of the implementation does not support configuration in the default encoding, however in a more mature version this might well be different.","Nested Class Summary","Nested classes inherited from class com.sun.smartcard.util.Readable","Readable.WithStream","Field Summary","Fields inherited from class com.sun.smartcard.util.Bytes",{"@attributes":{"id":"p-0399","num":"0488"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructor Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"protected","AID.ConfigurationData( )"]},{"entry":[{},{},"\u2003\u2003Construct a default instance."]},{"entry":[{},{},"AID.ConfigurationData(byte[ ] code)"]},{"entry":[{},{},"\u2003\u2003Construct an instance as a wrapper around"]},{"entry":[{},{},"\u2003\u2003a given data representation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0400","num":"0489"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"short","getLength( )"]},{"entry":[{},{},"\u2003\u2003Specify the length of the data (byte[ ])"]},{"entry":[{},{},"\u2003\u2003that represents the configuration data."]},{"entry":[{},"short","getPrefixSkip( )"]},{"entry":[{},{},"\u2003\u2003Skip the initial portion of the AID encoding"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{},{},{},{},{},{},{},{},{}],"ul":{"@attributes":{"id":"ul0061","list-style":"none"},"li":"public AID.ConfigurationData (byte [ ] code)"}},"Construct an instance as a wrapper around a given data representation. This constructor is implemented by the constructor of the ReadableBuffer with the same signature. The data specified by the argument is not copied.","AID.Configuration.Data",{"@attributes":{"id":"p-0402","num":"0000"},"ul":{"@attributes":{"id":"ul0062","list-style":"none"},"li":"protected AID.ConfigurationData ( )"}},"Construct a default instance.","Method Detail","getLength",{"@attributes":{"id":"p-0404","num":"0000"},"ul":{"@attributes":{"id":"ul0063","list-style":"none"},"li":"public short getLength ( )"}},"Specify the length of the data (byte [ ]) that represents the configuration data. The default encoding does not contain any configuration data, so its length is 0.","Overrides:","getLength in class Bytes","getPrefixSkip",{"@attributes":{"id":"p-0407","num":"0000"},"ul":{"@attributes":{"id":"ul0064","list-style":"none"},"li":"public short getPrefixSkip ( )"}},"Skip the initial portion of the AID encoding. The value returned is in accordance with the default encoding and is equal to the length of the AppletID representation plus one byte for the function code.","Overrides:",{"@attributes":{"id":"p-0409","num":"0000"},"ul":{"@attributes":{"id":"ul0065","list-style":"none"},"li":"getPrefixSkip in class Buffer\n\nReturns:\n"}},"the offset in the data representation where the configuration data can be found.","Class AIDInterpreter",{"@attributes":{"id":"p-0411","num":"0501"},"chemistry":{"@attributes":{"id":"CHEM-US-00006","num":"00006"},"img":{"@attributes":{"id":"EMI-C00006","he":"11.26mm","wi":"38.86mm","file":"US07140549-20061128-C00006.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"java.lang.Cloneable\n\n","Provide access to the data describing an Applet as specified by the AID. This class is intended for use in terminals, to provide detailed information about an applet in a card. Applet information is partially encoded in the AID data string read from the card; additional data regarding the Applet may be embedded in a sub class derived from this class or in part retrieved on the internet for instance using references embedded in the sub class implementation. The attributes defined for this class provide explicit support for internationalization of the terminal code.","Together with the in-card companion class com.sun.smarcard.AID this class is a key component in providing generic application management support for the Java Card platform. The class provides support for the dynamic configuration of card terminals.","The definition of sub classes of this class, their class files, may be stored at web-accessible repositories. A class naming scheme is implemented in this class that is based on the internationally registered identifier (RID) that is included in each AID encoding. A factory method is provided to instantiate a class based on a specific RID using this naming scheme. The class definition register may be maintained by an international organization like Java Card Forum.","By default the data describing the applet and its in-terminal components is made available by this class as a Java attribute list. Each attribute consist of an attribute name and attribute value both attribute parts being a Java String. Sub classes may define additional, e.g method call based, access to part of the data.","The following types of properties are specified here:\n\n","The following attribute names are defined by this class. This class actually supports a basic set of attributes; a sub-class may implement support for additional attributes. Attributes that are not supported have a value of null.","Owner","The name of the organizational or business unit that is responsible for the Applet.","Owner.code","The hexadecimal representation of the encoding of the ownerID.","Owner.URL","A URL referring to a description of the organizational or business unit that is responsible for the Applet.","Owner.Logo","A URL referring to an image characterizing the organizational or business unit that is responsible for the Applet.","Owner.BackOfficeURI","A URI referring to the back office (application management system) operated by the Applet owner to manage the use of the Applet in the card.","Applet.Function.DescriptionURL","A web page describing the function of the applet in a default langauge.","Applet.Function","A brief description of the Applet function in a default langauge.","Applet.Function.+lang+","A brief description of the Applet function in the language specified by +lang+ (encoded as ISO language identifiers).","Applet.CAPFile.URL","A URL specifying the name of the file containing the downloadable code for the applet.","Applet.Title","A summary description of the Applet.","Applet.Title.+lang+","A summary description of the Applet in the language specified by +lang+.","Applet.Proxy.Count","The number of application proxies that may be used to interact with the applet. Each proxy may be offering a different set of functions.","Applet.Proxy.Title.+count+","A summary description of the application proxy.","Applet.Proxy.Title.+count+.+lang+","A summary description of the application proxy in the language specified by +lang+.","Applet.Proxy.CardApplicationServiceAPI.+count+","The class name of the Java interface that specifies the functional interface of the specific application proxy.","Applet.Proxy.Class.+count+","The class name of a specific application proxy.","Applet.Proxy.Jar.+count+","The URL of a jar file that contains the proxy java class and supporting classes for a specific application proxy.","Applet.Function.Code","The hex representation of the one byte Applet function code as defined in ISO\/IEC 14344.","Applet.Function.ProxyClass","A Java class name of the specific class that can be used to communicate optimally with the applet and its backoffice. This class in general wil be provided by the Application Provider; instantiating the class in a terminal may be subject to commercial agreements.","Applet.Function.ProxyClass.GenericInterface","A Java class name of the specific interface that may be used to communicate with the applet to obtain the shared functionality as defined by the Function code.","Applet.Function.ProxyClass.GenericInterface.Implementation","A Java class name of an implementation of the generic interface that may be used to communicate with the applet to obtain the shared functionality as defined by the Function code. The instantiation of this class in the terminal should be possible without commercial restrictions.","Applet.Version","The decimal representation of the version in a \u201cmajor.minor\u201d notation. This is 0.0 if not supported by the AID.","RID","The name of the legal entity that has obtained the RID.","RID.code","The hexadecimal representation of the RID","RID.URL","A URL referring to a description of the legal entity that has obtained the RID.","PIX","The hexadecimal representation of the PIX.",{"@attributes":{"id":"p-0445","num":"0541"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["private AID","aid"]},{"entry":[{},"\u2003\u2003The AID being interpreted."]},{"entry":["Static java.lang.","AID_CLASS_NAME_PREFIX"]},{"entry":"String"},{"entry":["Static java.lang.","AID_INTERPRETER_PACKAGE_PATH"]},{"entry":["String[ ]","\u2003\u2003The name of a JavaCard special package for"]},{"entry":[{},"Issuer specific versions of this class."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0446","num":"0542"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Constructor Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AIDInterpreter( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0447","num":"0543"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Method Summary"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["protected static AID","getAID(AID.RID rid)"]},{"entry":[{},"\u2003\u2003Get an instance of an AID sub class as appropriate for the"]},{"entry":[{},"applet."]},{"entry":["protected","getAIDPackageList( )"]},{"entry":["static java.lang.String[ ]","\u2003\u2003Get a list of all the package names that may contain the"]},{"entry":[{},"definition of an appropriate AIDInterpreter class definition."]},{"entry":["java.lang.String[ ]","getAppletStateDataPropertyNames( )"]},{"entry":[{},"\u2003\u2003Obtain the attribute names for applet data that may be"]},{"entry":[{},"included in the AID."]},{"entry":["java.lang.String","GetAppletString(short stringreference)"]},{"entry":[{},"\u2003\u2003Obtain a string that has been removed from the applet code"]},{"entry":[{},"by the conversion to Java Card ByteCode."]},{"entry":["java.util.Properties","GetAsProperties( )"]},{"entry":[{},"\u2003\u2003Interpret the content of an AID as a list of name value"]},{"entry":[{},"pairs."]},{"entry":["AIDInterpreter","GetCardEncodingInterpreter(byte[ ] encoding)"]},{"entry":[{},"\u2003\u2003Clone the interpreter initialized with the encoding of a"]},{"entry":[{},"compatible AID as may be obtained from the card."]},{"entry":["java.lang.String[ ]","GetConfigurationPropertyNames( )"]},{"entry":[{},"\u2003\u2003Obtain the list of attribute names that describe the values"]},{"entry":[{},"that may be present in the configuration part of the AID."]},{"entry":["(package private)","makeOne(AID.RID rid)"]},{"entry":["static AIDInterpreter","\u2003\u2003Create an instance of a derived class for the AID"]},{"entry":[{},"Interpreter, as defined by the specified RID."]},{"entry":["static AIDInterpreter","makeOne(byte[ ] encoding)"]},{"entry":[{},"\u2003\u2003Create an instance of the AID that fits a specified AID"]},{"entry":[{},"encoding."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{},{}],"ul":{"@attributes":{"id":"ul0069","list-style":"none"},"li":"public static final java.lang.String [ ] AID_INTERPRETER_PACKAGE_PATH"}},"The name of a JavaCard special package for Issuer specific versions of this class.","AID_CLASS_NAME_PREFIX",{"@attributes":{"id":"p-0449","num":"0000"},"ul":{"@attributes":{"id":"ul0070","list-style":"none"},"li":["public static final java.lang.String AID_CLASS_NAME_PREFIX\n\naid\n","private AID aid"]}},"The AID being interpreted.","Constructor Detail","AIDInterpreter\n\n","Create an instance of a derived class for the AID Interpreter, as defined by the specified RID.","The interpreter classes are located in a Java package with the special name \u201cjavacard.aidinterpreters\u201d.","Note:","This method is never called inside the card.","getAIDPackageList",{"@attributes":{"id":"p-0456","num":"0000"},"ul":{"@attributes":{"id":"ul0072","list-style":"none"},"li":"protected static java.lang.String [ ] getAIDPackageList ( )"}},"Get a list of all the package names that may contain the definition of an appropriate AIDInterpreter class definition.","makeOne",{"@attributes":{"id":"p-0458","num":"0000"},"ul":{"@attributes":{"id":"ul0073","list-style":"none"},"li":"public static final AIDInterpreter makeOne(byte [ ] encoding)"}},"Create an instance of the AID that fits a specified AID encoding.\n\n","Get an instance of an AID sub class as appropriate for the applet. This class will be defined by the application provider as part of the applet code. Instances of this specific class will both be used in the card and outside it, as is demonstrated by the interpreter class.","getCardEncodinglnterpreter",{"@attributes":{"id":"p-0461","num":"0000"},"ul":{"@attributes":{"id":"ul0076","list-style":"none"},"li":"public AIDInterpreter getCardEncodinglnterpreter(byte [ ] encoding)"}},"Clone the interpreter initialized with the encoding of a compatible AID as may be obtained from the card. A compatible AID encoding matches the Applet ID.","Returns:\n\n","Interpret the content of an AID as a list of name value pairs. This method returns a properties object initialized with the properties available by interpreting the default AID encoding. Additional properties may be provided in a sub class, e.g by adding properties to the result of this function in the constructor.","getConfigurationPropertyNames",{"@attributes":{"id":"p-0465","num":"0000"},"ul":{"@attributes":{"id":"ul0079","list-style":"none"},"li":"public java.lang.String [ ] getConfigurationPropertyNames ( )"}},"Obtain the list of attribute names that describe the values that may be present in the configuration part of the AID. This method is for out of card use, providing interoperable interpretation of the result in terminals. This method uses the default encoding.\n\n","public java.lang.String [ ] getAppletStateDataPropertyNames ( )","Obtain the attribute names for applet data that may be included in the AID. By default this method does nothing and returns null. A sub class that is intended to interpret an AID that contains optional state data in the encoding of the AID should override this method.","getAppletString",{"@attributes":{"id":"p-0469","num":"0000"},"ul":{"@attributes":{"id":"ul0081","list-style":"none"},"li":"public java.lang.String getAppletString(short stringreference)"}},"Obtain a string that has been removed from the applet code by the conversion to Java Card ByteCode. This method allows the limited support of the Java String class in Java Card applet code whereby the strings embedded in the code are replaced by a numeric reference. The numeric reference may be returned to the terminal in a response and subsequently used as index into an array of strings that may be made available to the card terminal."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated into and constitute a part of this specification, illustrate one or more embodiments of the present invention and, together with the detailed description, serve to explain the principles and implementations of the invention.","In the drawings:",{"@attributes":{"id":"p-0027","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0030"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0029","num":"0031"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0030","num":"0032"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0031","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0032","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0037"},"figref":"FIGS. 5A","b":["5","5","5"]},{"@attributes":{"id":"p-0036","num":"0038"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0037","num":"0039"},"figref":["FIGS. 6A through 6E","FIG. 6"]},{"@attributes":{"id":"p-0038","num":"0040"},"figref":"FIG. 6F"},{"@attributes":{"id":"p-0039","num":"0041"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0042"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0041","num":"0043"},"figref":["FIGS. 8A through 8F","FIG. 8"]},{"@attributes":{"id":"p-0042","num":"0044"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0043","num":"0045"},"figref":"FIGS. 10 and 11"},{"@attributes":{"id":"p-0044","num":"0046"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0045","num":"0047"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0046","num":"0048"},"figref":["FIG. 12A","FIG. 12"]},{"@attributes":{"id":"p-0047","num":"0049"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0048","num":"0050"},"figref":"FIG. 13A"},{"@attributes":{"id":"p-0049","num":"0051"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0050","num":"0052"},"figref":["FIG. 15","FIG. 14"]}]},"DETDESC":[{},{}]}
