---
title: Method and apparatus for clustered SSL accelerator
abstract: Method and apparatus for clustered Secure Sockets Layer (SSL) acceleration where two or more SSL relays are connected in a cluster. Information is transferred between a first node (typically, the client) and one of the SSL relays where the transferred information is related to communication between the first node and a second node (typically, the server). The state information of an SSL connection between the first node and the one SSL relay is clustered. The clustering includes sharing the state information between the one SSL relay and each of the one or more SSL relays. Any of the SSL relays can take over all connections of another of the clustered SSL relays therefore, providing no interruption in the communication should any of the SSL relays fail.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07305450&OS=07305450&RS=07305450
owner: Nokia Corporation
number: 07305450
owner_city: Espoo
owner_country: FI
publication_date: 20020307
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Patent Application No. 60\/279,441, filed Mar. 29, 2001, the contents of which is incorporated by reference herein in its entirety.","1. Field of the Invention","This invention relates to Secure Socket Layer (SSL) information transfers, and more specifically to clustered SSL accelerators for information transfers.","2. Background Information","Secure Sockets Layer (SSL) and its successor Transport Layer Security (TLS) are the dominant approaches to web security. Both protocols provide a secure channel over which ordinary web traffic (Hyper Text Transfer Protocol (HTTP)) can be transmitted. HTTP over SSL (HTTPS) is widely used to protect confidential information in transit between a client and server.","However, SSL is dramatically more CPU intensive than ordinary TCP communication and the addition of SSL to unsecure web servers can create unacceptable performance consequences on the web server. The dominant performance cost is for the public key encryption algorithm (e.g., RSA) operation in the SSL handshake. One common approach to reducing this cost is to offload the RSA operations into a cryptographic co-processor that is installed on the server machine.","The co-processor approach has a number of disadvantages: (1) the server software must be co-processor aware; (2) the case must be open to insert the co-processor; and (3) it can be difficult to match the co-processor to the CPU such that neither is idle much of the time. Scaling problems may also arise because the speed at which the co-processor can handle the traffic may not match the speed at which the host CPU can handle it.","One response to the failing of the co-processor approach has been to create standalone cryptographic accelerators. These accelerators are network devices that reside between the client and server. They accept HTTPS connections from a client, decrypt them, and make HTTP connections to the web server. Examples of such devices include iPIVOT\/Intel's Netstructure accelerators, F5's BigIP accelerator, and Andes Network's Nonstop SSL products. One key advantage of standalone accelerators is that scaling is relatively simple, i.e., more than one box can be purchased allowing the traffic to be load balanced across the accelerators.","In conventional configurations, having multiple standalone accelerators may provide improved performance since if a given accelerator fails, other accelerators may be available to handle the load. However, these configurations only offer high availability in a bulk sense. All SSL connections terminated on a failing box are simply lost. A customer perceives this as an input\/output (I\/O) error of some kind. Although the remaining boxes are still available to handle future connections and the accelerators as a group remain available, there is no high availability at the connection level.","The present invention is related to a method for clustered Secure Sockets Layer (SSL) acceleration that includes: connecting at least two SSL relays in a cluster; transferring information between a first node, (e.g., a client), and one of the at least two SSL relays, the transferred information related to communication between the client node and a second node, (e.g., a server), and clustering (sharing among all nodes of the cluster) the state information of an SSL connection between the client and the one of the at least two SSL relays as well as the state information of a connection between the server and the one of the at least two SSL relays. Any of the at least two SSL relays can take over all connections of another of the at least two SSL relays, therefore, providing no interruption in the communication should any of the at least two SSL relays fail.","The present invention is also directed to a system for clustered Secure Sockets Layer (SSL) acceleration that includes a first node (e.g., client), at least two SSL relays connected in a cluster where the cluster is operatively connected to the client node, and a second node (e.g., server) operatively connected to the at least two clustered SSL relays. One of the at least two clustered SSL relays transfers information between the client and the server nodes. The state information of an SSL connection between the client and the one at least two SSL relays is shared across each at least two SSL relays. Any of the at least two SSL relays are capable of taking over all connections of another of the at least two SSL relays therefore providing no interruption in the transfer of information should any of the at least two SSL relays fail.","The present invention is further directed to an apparatus comprising a storage medium containing instructions stored therein. The instructions when executed cause a computing device to perform: connecting the computing device with at least one other computing device in a cluster; transferring information between a first node (e.g., client) and the computing device, where the transferred information is related to communication between the client and a second node (e.g., server); and clustering the state information of the connections between the computing device and the client and server nodes. Any of the computing devices can take over all connections of another computing device, therefore, providing no interruption in the communication with the client and server nodes should any of the computing devices fail.","The present invention is still further directed to an SSL relay. The SSL relay may be connected in a cluster of SSL relays. The SSL relay includes: a first interface for transferring information between a first node (e.g., client) and the SSL relay; a second interface for transferring information between a second node (e.g., server) and the SSL relay; a third interface for transferring information between SSL relays in the cluster; and a storage device. The state information of an SSL connection between the client and the SSL relay is shared across each SSL relay in the cluster. Any of the SSL relays in the cluster are capable of taking over all connections of another SSL relay in the cluster therefore providing no interruption in the transfer of information should any of the SSL relays in the cluster fail.","The particulars shown herein are by way of example and for purposes of illustrative discussion of the embodiments of the present invention. The description taken with the drawings make it apparent to those skilled in the art how the present invention may be embodied in practice.","Further, arrangements may be shown in block diagram form in order to avoid obscuring the invention, and also in view of the fact that specifics with respect to implementation of such block diagram arrangements is highly dependent upon the platform within which the present invention is to be implemented, i.e., specifics should be well within purview of one skilled in the art. Where specific details (e.g., circuits, flowcharts) are set forth in order to describe example embodiments of the invention, it should be apparent to one skilled in the art that the invention can be practiced without these specific details. Finally, it should be apparent that any combination of hard-wired circuitry and software instructions can be used to implement embodiments of the present invention, i.e., the present invention is not limited to any specific combination of hardware circuitry and software instructions.","Although example embodiments of the present invention may be described using an example system block diagram in an example host unit environment, practice of the invention is not limited thereto, i.e., the invention may be able to be practiced with other types of systems, and in other types of environments.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment.","The present invention relates to method and apparatus for clustered SSL accelerators that provide high availability for individual connections by sharing the state of each SSL connection across the entire cluster. If any node in the cluster fails, the rest of the nodes are able to take over all connections terminating on that node with no interruption in service.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["14","16","18","20","30","40","10","12"]},"The entire cluster behaves as if it were a single piece of hardware. However, each cluster member listens on the cluster IP address, therefore, seeing every packet addressed to the cluster. A cluster member may be maintaining one of two types of state information, a working resources state or a mirror state. If a member is handling a given TCP connection, the member may have various working resources allocated to it, e.g., sockets, memory buffers, etc. However, since any other member must be prepared to take over for that member at any given time, the other members must possess a mirrored state. A mirrored state is a passive state sufficient to recreate the working resources in order to handle the workload. Only the minimal amount of state to allow other members to reproduce the original state upon failover may be sent to each member. Further, each individual member may not need to be configured with all state information. Once a member is configured as part of the cluster, state information and other configuration information may be propagated automatically.","Therefore, according to the present invention, clustered machines may automatically propagate a connection state from the machine handling the connection to the rest of the machines in the cluster. If a member is handling traffic for a given connection, when the member fails, that IP packet may be dropped. However, when the packet is retransmitted, the member that is now handling the connection (i.e., new member) automatically processes it correctly. There may be some delay while waiting for the retransmission. This delay is all that may be seen by a client and server.","When a packet arrives destined for the cluster, the Internet Protocol (IP) stack on each cluster member automatically computes a hash function on the source address, source port, destination address, and destination port four-tuple. The function maps each packet into one of a small number of \u201cbuckets\u201d. If the resulting bucket is assigned to a particular member, then that member handles the packet. Otherwise, that member discards the packet. Note that since only the address pair is used to compute the bucket, all packets corresponding to a given TCP connection fall into the same bucket. One member of the cluster, a cluster master, may be responsible for assigning each bucket to some cluster member. Each member in a cluster may send out a stream of cluster \u201ckeepalives\u201d on both interfaces. If a sufficiently long time passes between keepalives (typically 250-500 ms) then the master declares the member dead and proceeds to reassign that member's workload to other cluster members.","The simpler case of clustering TCP will be illustrated to help understand the clustering of SSL that will be discussed later. A simple TCP relay will be illustrated that behaves the same way as the SSL relay but without the decryption function, thereby allowing illustration of a number of the important features of a clustered SSL relay while allowing us to ignore the additional complications introduced by SSL.","Most TCP stacks select port numbers for active opens using a counter. However, this may cause the relay-server connection to fall into a different bucket from the client-relay connection. Therefore, according to the present invention, the port number is carefully chosen so that the two connections fall into the same bucket. For illustration, assume that our relay accepts connections on port  and connects to the server on port . These are the same ports that would likely be used in an SSL relay.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2"},"In the case where the crash occurs before the update is received, when the mirror comes online it may have no knowledge of the socket. If it tries to initiate a new connection with the server, the server may respond with a RST because the initial sequence number (ISN) will be different. This can be overcome if the mirror uses the same ISN as the relay, i.e., the same ISN as the client used. Thus, when the first packet of data from the client arrives, the accept cycle will start over again cleanly. The ISN can be derived from the sequence number of the first packet from the client.","If the crash occurs after the update is received, then the mirror may come online with the appropriate mirrored state. It may resurrect the sockets connected to the client and the server. When the server retransmits its SYN\/ACK, the relay transmits the ACK immediately. Since the state update has already occurred, there is no need to do it again before transmitting it to the client.","The contents of a state update may be simply a version of the TCP protocol control block. The state is extracted from a socket and then a new socket is created with a given state. A state update may consist of portable versions of the connection to the client and the connection to the server.","The state of the client's socket is the state after receipt of the clients ACK. Regarding the server socket state, the server socket state may clustered as it would be after having ACKed the server's SYN\/ACK. Thus, if the socket has to be reinstantiated on a mirror, it may automatically have the new ACK state. Therefore, generally a state is clustered before network traffic is sent. This ensures that the mirror enters the new state before the network peer knows about it.","The TCP state elements that may require management are the sequence numbers. For each connection the sequence number that has been acknowledged (ACKed) and the next sequence number to transmit (snd_nxt) are known. Since data buffers are generally not clustered, it may be required that the next sequence number to receive (rcv_nxt) be equal to the ACK pointer, and that snd_nxt not be incremented until data is acknowledged by the peer. Thus, a given update may be specified by the four-tuple (client_rcv_nxt, client_snd_nxt, server_rcv_nxt, server_snd_nxt). Withholding the ACK until the cluster update has been received may require modification to the TCP stack. Further, the ACK pointer may need to be separated from the rcv_nxt value. A new element (rcv_appack) is added in the TCP. This value may be controlled by an application programming interface (API) call. In order to avoid potential problems by this modification, ACKs may need to be suppressed until the application allows them.","Further, a RST that may be generated after receipt of an ACK or an unknown connection may need to be suppressed for a short period of time after a failover. In the case where an ACK is received in advance of the snd_nxt value on the restored mirror, rights may need to be discarded until snd_nxt equals the new ACK value.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3"},"If the relay fails after clustering the state, the simplest possibility is that the client retransmits the data. However, this time the mirror's TCP state may already have its ACK pointer at S+d (where S is the state at the beginning of the transaction, and d is the size of the data in bytes) and, therefore, drops the data and sends an immediate ACK for S+d bytes. This may force waiting for the 500 ms TCP retransmit timer. It is more efficient for the mirror to send a single ACK when it comes online (to reduce latency).","Therefore, according to the present invention, for reducing cluster update size the client buffers the data by withholding the ACK until the data has been acknowledged by the server. Failovers, therefore, result in TCP retransmits. Device failures then appear like intermittent network lossage of the kind that TCP is already designed to handle. Moreover, to avoid possible problems, the SSL relay uses absolute (rather than relative) TCP sequence numbers and the value of each sequence number is maintained as it was last clustered.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4"},"Clustering secure sockets layer (SSL) encompasses roughly the same set of tasks as clustering TCP. However, SSL is unique in that: (1) an SSL handshake that involves interaction with the client needs to be clustered; (2) SSL data is structured in a record format whereas the data pushed over SSL is essentially freeform; (3) cryptographic keying material both on a global and a per connection basis need to be clustered; (4) the SSL session cache must be shared across the entire cluster; and (5) SSL has its own closure sequence on top of TCP.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5"},"A \u201cpre-ServerHello\u201d state may contain client and server random values and the chosen cipher suite. Further, every handshake update may contain the new TCP state, the current value of the SSL handshake hashes, and\/or the handshake to enter upon failover-in this case writing the ServerHello. If a failover occurs when the mirror is in this state, the mirror generates a new ServerHello using the clustered random value and containing an ACK of the ClientHello. The state may be clustered before generation of the messages. This reduces the latency inherent in these operations. However, the messages are not actually transmitted until the Update is ACKed. The messages may be queued and the queued emptied upon receipt of the ACK.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 6","FIG. 6"]},"It is possible that a client may send all three update messages at the same time. In this case, the process may be optimized by the relay detecting this and issuing one cluster update to the mirror instead of three.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 7","FIG. 8"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 9","FIG. 9"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 10"},"In order to encrypt or decrypt an SSL record, the sequence number, the encryption state, and the MAC key may be required. Of these, only the encryption state and the sequence number vary. Clustering the sequence number may be straight forward, but the encryption state may be less obvious. When the decipher is Data Encryption Standard (DES), 3DES or Advanced Encryption Standard (AES), the key and the current Cipher Block Chaining (CBC) residue may be clustered. With RC-4 encryption\/decryption algorithm, there are two options: (1) cluster the current key schedule, or (2) cluster the key and an offset into the stream. The second option may be more compact, but may also be excessively slow if failover occurs during a long transfer requiring the mirror to generate and discard megabytes of key stream. In SSL acceleration according to the present invention, the base state may be clustered every megabyte or so and in between transmit deltas. To avoid potential problems, the deltas may contain the offset from the beginning of the key stream. Thus, when an attempt to reconstitute the key stream occurs, this may be started from the last base update that has been received and then the key stream is advanced to the point in the delta.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 11"},"According to the present invention, in order to map server ACKs to state, a queue may be maintained for all records for which the plaintext has been written to the server but not yet ACKed. Whenever more data is ACKed by the server, the ACK pointer may be moved forward in this list the appropriate number of bytes. When a full record has been ACKed, it may be removed from the list and the new state clustered. Since multiple records may be decrypted before any of them are ACKed, each record in the queue may have its associated cipher state attached to it at the time it is decrypted. Thus, when a record is ACKed, the cipher state cluster is the one attached to the record. If multiple records are ACKed by a given server ACK, the state associated with the last one is clustered. If a failover occurs, the mirror may simply install its mirrored TCP.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 12"},"Partial ACKs occur infrequently since the records usually fit into the effective window. Partial ACKs are only allowed to occur when there is no unACKed data written to the server. The expectation is that when the previous record is ACKed the client will transmit the rest of the record currently being read, but unfortunately this expectation is not always fulfilled. Therefore, according to the present invention, whenever an ACK is sent to the client and a partially read record exists, a timer may be set for the round trip time (RTT) plus the packet interval time. This allows the ACK to arrive at the client and the client to send the next segment if it is going to. If it doesn't, a partial ACK may once again be performed.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 13"},"Three conditions may trigger closing the connection: a close from the client, a close from the server, or an error. Rather than attempt to know each of these conditions and cluster them, methods and apparatus according to the present invention may withhold ACKs for the messages that generate them. After a failover, it is expected that the retransmits may generate the same condition on the mirror. However, if the closing is from an error, methods and apparatus according to the present invention may cluster that the session is not to be resumed. Once the mirror receives that update, the mirror may remove the entry from the session cache.","It may be required to transmit an alert for all three of these conditions. If so, read callbacks may be disarmed so that no further attempts are made to read data. The alert may then be transmitted. Once the alert is ACKed, shutting down of the socket may proceed, which may be performed as was described for TCP clustering.","It is noted that the foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present invention. While the present invention has been described with reference to a preferred embodiment, it is understood that the words that have been used herein are words of description and illustration, rather than words of limitation. Changes may be made within the purview of the appended claims, as presently stated and as amended, without departing from the scope and spirit of the present invention in its aspects. Although the present invention has been described herein with reference to particular methods, materials, and embodiments, the present invention is not intended to be limited to the particulars disclosed herein, rather, the present invention extends to all functionally equivalent structures, methods and uses, such as are within the scope of the appended claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is further described in the detailed description which follows in reference to the noted plurality of drawings by way of non-limiting examples of embodiments of the present invention in which like reference numerals represent similar parts throughout the several views of the drawings and wherein:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
