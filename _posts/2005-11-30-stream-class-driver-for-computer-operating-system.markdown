---
title: Stream class driver for computer operating system
abstract: A stream class driver for use in a computer operating system functions together with a minidriver. The minidriver is associated with a particular design for an adapter, which is a hardware device that generates or receives streaming data. The stream class driver deals with common operating system tasks such as direct memory access, scatter/gather memory use and Plug n Play. The stream class driver is independent of the hardware design and can therefore function with any type of streaming device or external buses such as USB or IEEE 1394. the minidriver functionality is limited to only those functions required by the unique aspects of the hardware and for the minimum requirements of operation, thereby minimizing the complexity and burden of designing minidrivers for hardware devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444647&OS=07444647&RS=07444647
owner: Microsoft Corporation
number: 07444647
owner_city: Redmond
owner_country: US
publication_date: 20051130
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Appendix I","Appendix II","Appendix III","Appendix IV","Appendix V"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/950,911, filed Sep. 27, 2004 and entitled \u201cStream Class Diver for Computer Operating System\u201d, which is a continuation application of U.S. patent application Ser. No. 09\/819,085, now U.S. Pat. No. 6,845,508, filed Jul. 27, 2001, entitled \u201cStream Class Driver for Computer Operating System\u201d, which is a continuation of now abandoned, U.S. patent application Ser. No. 08\/994,674, filed Dec. 19, 1997 and entitled \u201cStream Class Driver for Computer Operating System\u201d, all of which are incorporated herein by reference.","1. The Field of the Invention","The present invention pertains in general to computer software operating systems, and more particular to a river for a class of devices which generate or receive streaming data.","2. The Relevant Technology","A rapidly growing area of interest in the field of computer technology is that of \u201cmultimedia\u201d. This term generally refers to the concurrent use of video and audio in a computer system for a wide range of applications including business and entertainment.","The primary applications which have led to the tremendous success of personal computers have been based on the power of these computers to process numbers in complex ways such as through spreadsheets, graphics, word processing and data bases. However, in such applications, the application program works with a discrete data file and typically works with only a small part of such a data file at any one time. Multimedia applications add a major new aspect to the processing of data by personal computer. This is the requirement to manage and process a continuous stream of data as opposed to discrete data files which are typically processed by an application program. The stream of data associated with a multimedia application is generally far too large to be loaded in memory, and in many cases the data is continuous with no predetermined end of the data. A further feature of multimedia streaming data is that it is sequential in nature and frequently is time dependent, that is, it must not only be processed in a specific sequential order, it must also be processed to produce precisely times sequential events.","An example of multimedia streaming data is the output which is produced by a DVD (Digital Versatile Disk) apparatus. The contemporary DVD apparatus produces data using the MPEG-2 video and audio format. This output actually comprises three separate data streams which are video, audio and subpicture. Each of these streams requires separate processing, but the results of the processing must be time synchronized and generated at a predetermined absolute rate to obtain the desired results. Video and audio signals must be properly synchronized and timed to generate a viable multimedia presentation.","A standardized computer platform, including hardware and software, must be able to work a large number of independently produced multimedia adapters, such as DVD players, video cameras, audio sources and ROM discs. Each of these products requires a separate, complex driver which functions to interface application programs through the computer operating system to the specific hardware in order to process the multimedia streaming data to produce continuous outputs. However, to accommodate the massive amounts of data and the extensive, complex processing of this data required for a successful multimedia application, the driver must be highly efficient, well designed and capable of performing a wide range of functions within the operating system and functions required by the application program. With the growing complexity of operating systems and the greater demands of application programs, it is very difficult for each independent producer of a hardware device, particularly for multimedia, to produce an efficient, current and effective driver for that product. Thus, there exists a need to reduce the burden of producing drivers for multimedia products.","In other areas of computer system operation, such as for pointing devices, for example, a mouse, it has been proposed to have a hardware independent driver associated with the operating system and have a hardware dependent driver provided by the hardware manufacturer for each particular device. See U.S. Pat. No. 5,465,364 entitled \u201cMethod and System for Providing Device Driver Support Which is Independent of Changeable Characteristics of Devices and Operating Systems.\u201d Pointing Devices, however, do not have the same problems that are encountered with multimedia applications. The data rate for pointing devices is extremely low, the data processing is not particularly complex and the pointing device is extremely low, the data processing is not particularly complex and the pointing device is generally a support aspect of an application program, in contrast to being an aspect that is a principle part of a multimedia application.","In view of the substantial problems encountered in the use of multimedia applications on personal computes, and the insatiable consumer demand for greater bandwidth and data processing sophistication, there is a need for a multimedia driver configuration which can efficiently handle the volume and complexity of streaming data while at the same time minimizing the burden and difficulty of driver design for the independent developers and manufacturers of multimedia products.","The present invention is a method of operation, and corresponding computer program units, for a stream class driver which is used in conjunction with a minidriver. The minidriver is associated with a hardware adapter which generates or receives streaming data. The operation of the stream class driver product begins with receiving of initialization data from the minidriver followed by registration of the initialization data for later use by the stream class driver. After registration, the stream class driver creates a device object for the adapter. The stream class driver then sends a command to the minidriver to initialize the adapter. Next, the stream class driver requests that the minidriver provide adapter stream information for all of the data streams handled by the adapter. The minidriver provides this information and the stream class driver registers the received adapter stream information. The stream class driver may then provide a command to the minidriver to turn off power to the adapter and then pages out the minidriver and subsequently awaits a data stream request.","Upon receipt of a data stream request, the stream class driver pages in the minidriver to active memory. A command is generated to the minidriver to turn on power to the adapter. The stream class driver provides a data stream open command and stream structure data to the minidriver as needed to open the data stream requested a by an application program. Next, the stream class driver provides a stream read or a stream write command to the minidriver. Properties and control information in a predefined data format related to the stream request are transmitted from the stream class driver to the minidriver. Upon receipt of a data stream termination command initiated by an application program, the stream class driver provides a stream close command to the minidriver. Finally, the stream class driver provides an uninitialization command to the minidriver for uninitializing the adapter.","In a further aspect of the present invention, the stream class driver can open additional data streams for either reading or writing streaming data concurrently with the first data stream.","The present invention includes a stream class driver for use in a computer operating system. The purpose of this stream class driver is to make the writing of hardware drivers (minidrivers) for streaming devices much simpler. The functions performed by the minidriver are limited to those functions which are unique or necessary for the associated hardware, while the stream class driver performs all of the functions which are not dependent upon the particular hardware implemented.","Terminology","The principal terms used in describing the functions, data structures, commands and other aspects of the present invention are defined as follows:","1. AC-3: An audio standard for delivering digital audio developed by Dolby Laboratories.","2. ActiveMovie: A cross-platform API developed by Microsoft Corporation for developers of multimedia applications that provide a user-mode connection and stream architecture to support high quality digital video, high fidelity audio, and special effects, now termed \u201cDirect Show.\u201d","3. Adapter: a hardware device for generating, handling or consuming streaming data.","4. API: Application Programming Interface\u2014A set of routines that an applications program uses to request and carry out lower-level services performed by a computer operating system.","5. CSA: Connection and Streaming Architecture\u2014A functional specification produced by Microsoft Corporation defining an architecture and interface for application programs using streaming data and synchronization tasks. This is kernel-mode streaming in WDM.","6. DLL: Dynamic Link Library\u2014An API routine that user mode applications access through ordinary procedure calls.","7. DMA: Direct Memory Access.","8. Driver: Kernel Mode used to either control a hardware device or to emulate a hardware device.","9. EISA: Extended Industry Standard Architecture, a 32-bit bus configuration developed as an extension of ISA.","10. Filter: An entity which performs a specified function and includes a collection of related connection points called pins.","11. GUID: Globally Unique Identifier. A quantity which is unique and includes a current date\/time and a sequence number and which is used to allow any party to create an identifier which will not overlap other identifiers similarly created.","12. IEEE 1394: A standardized serial bus for high speed data transfer.","13. IOCTL: I\/O control.","14. IRP: I\/O Request Packet\u2014Data structures that drivers use to communicate with each other.","15. IRQ: Interrupt Request\u2014A method by which a device can request to be serviced by the device's software driver.","16. ISA: Industry Standard Architecture\u2014legacy bus configuration for original personal computer design.","17. ISO: International Standards Organization.","18. ISR: Interrupt Service Routine.","19. Kernel Mode: The processor mode which allows full, unprotected access to the system. A driver or thread running in kernel mode has access to system memory and hardware.","20. Minidriver: A hardware specific DLL that uses a class driver to accomplish most actions through functional calls and provides only device-specific controls.","21. MPEG: Moving Pictures Expert Group\u2014A standard for compression and transmission of digital video.","22. PCI: Peripheral Component Interconnect\u2014A high-performance, 32-bit or 64-bit bus designed to be used with devices that have high bandwidth requirements such as the display subsystem.","23. Pin: A set of properties which describe a potential connection point to a filter.","24. PIO: Programmed input\/output, which is much like a complement to DMA.","25. Plug and Play (PnP): An enumerator standard for automatically detecting and recognizing installed hardware, as defined by Microsoft Corporation.","26. SRB: Stream Request Block.","27. USB: Universal Serial Bus\u2014A bidirectional, isochronous, dynamically attachable serial interface for adding peripheral devices such as game controllers, serial and parallel ports, and input device on a single bus.","28. User Mode: The nonprivileged processor Mode in which application code executes.","29. VxD: Virtual Device Driver\u2014A device driver that runs at the privileged ring 0 protected Mode of the microprocessor.","30. WDM:Windows 32 Driver Model\u2014a 32 bit driver model based on the Windows NT driver model that is designed to provide a common architecture of I\/O services and binary-compatible device drivers for both Windows NT and Windows operating system for specific classes of drivers.","31. Windows NT Driver Model: The layered device driver model used under the Windows NT operating system (see \u201cInside Windows NT\u201d by Helen Custer (Microsoft Press 1993)).","32. Windows NT: Refers to the Microsoft Corporation Windows NT Version 4.0 operating system, including any add-on capabilities and any later versions of the operating system.","Operational Description","The operating environment of the present invention is illustrated in . This drawing shows selected hardware and software within a personal computer system which is preferably a system using an Intel Corporation x86 microprocessor and a Microsoft Corporation operating system, such as Windows NT. The present invention is used within the illustrated environment for supporting a multimedia application, such as an application program . The present invention is directed to a stream class driver , which is preferably included within an operating system . The application program  interacts with the operating system  through an application programming interface (API) . The operating system  includes the conventional features and operating aspects, not illustrated, which are well-known in the industry. A system bus driver  is a part of the operating system  and is used to provide communication through a bus , such as PCI bus used with personal computers.","The upper edge of a stream class driver  of the present invention is accessed through a CSA interface , which is defined in \u201cWindows Driver Model Connection and Streaming Architecture Design Notes and Reference\u201d, published by Microsoft Corporation. This document, which is incorporated herein by reference, is a part of the \u201cMEMPHIS\u201d designated operating system documentation entitled Windows 98 Developer's Release Device Driver Kit (DDK).","CSA interface  is further defined in U.S. patent application Ser. No. 08\/825,957, filed Apr. 4, 1997, entitled \u201cMethod and Computer Program Product for Reducing Inter-Buffer Data Transfers Between Separate Processing Components\u201d, which is incorporated herein by reference.","The class driver  can be embodied in a computer readable medium such as magnetic disk, optical disk or magnetic tape.","The lower edge connection the stream class driver  is defined by a stream class driver\/minidriver interface , which is specified in detail herein and in the attached appendices.","A minidriver  communicates through the interface  with the stream class driver . Minidriver  is a unique design corresponding to the hardware adapter . The adapter  is preferably a device that generates or consumes steaming data, such as used in a multimedia application. An example of the adapter  is a DVD player which produced digital audio and video streams for a motion picture.","Minidriver  is a hardware-specific DLL that uses the class driver  to accomplish most actions through function calls, and provides only device-specific controls. The minidriver  registers each adapter, such as , with the class driver , and the class driver  creates a device object to represent each adapter  that it registered. This process is described in more detail below. Minidriver  uses the class driver's device object to make system calls.","The adapter  is connected to transmit and receive commands and to transmit and receive data through the bus . In a typical implementation, the application program  is a multimedia application that uses streaming data provided by the adapter  through the bus .","Operating system aspect  includes the minidriver , which is unique to the adapter , but when implemented with a particular computer system becomes a part of the operating system  of that computer.","The internal interface  between the class driver  and the minidriver  is primarily a set of function calls between these drivers. The class driver  controls the request flow, calling the minidriver  when access to the adapter  hardware is necessary. The class driver  is responsible for multiprocessor and interrupt synchronization. Once both the class driver  and the minidriver  are initialized, the minidriver  is passive and is called only by the class driver . Most of the function calls from the minidriver  to the class driver  are low-level service requests.","The detailed description for the specific embodiment of the present invention presented herein includes the description in the appendices that follow. These are:","Appendix I Stream Class Driver Functions (Stream Class Drive )","Appendix II Minidriver Functions (Minidriver )","Appendix III Stream Request Block (Interface  SRB)","Appendix IV SRB Command Codes for the Adapter (Interface  Device Code)","Appendix V Stream Specific Command Codes (Interface  Stream Command Code)","These appendices describe in detail the functions, data structures and commands for the interface .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 2","FIG. 2"],"b":["24","36","20","24","22","36"]},"The operating system  functional operation begins at a start point . Next, step  is performed to power up the system and perform the conventional self tests which are well known in the personal computer industry.","After the system has been powered up and the operating system initialization process is performed, step  is executed in which an enumerator, such as Plug n Play detects the attached adapter . When the adapter has been detected, the Plug n Play enumerator, in step , loads into memory the minidriver  for the detected adapter . In step , the Plug n Play initiates the minidriver  DriverEntry routine, as describe in Appendix II.","Further referring to , the next functional step carried out is performed by the minidriver  in step . In this step the minidriver  calls the class driver  function StreamClassRegisterAdapter. (See Appendix I) The minidriver  further collects and passes the data structure termed HW_INITIALIZATION_DATA. This data structure is described in detail in Appendix II.","From step , control is transferred to step , which is performed by the stream class driver . Within step , the initialization data provided in the HW_INITIZLIZATION_DATA structure is registered, that is, it is recorded in memory for use by the class driver . Next, in step , the stream class driver  creates a device object corresponding to the adapter . The minidriver  will not create a device object, but instead will share the class driver  device object as needed. Only one device object is created per adapter.","In step , the stream class driver  calls the minidriver  to initialize the adapter . This is done by calling the minidriver's function HWReceivePacket with the command SRB_INITIALIZE_DEVICE. (See Appendix IV).","In step , the minidriver  initializes the adapter  hardware by performing the required setup and loading in the adapter any code required for operation of the hardware.","In step , control is returned to the streaming class driver  which calls the minidriver  for stream information. This is done with the command SRB_GET_STREAM_INFO (Appendix IV), which is sent to the minidriver function HWReceivePacket.","Upon receipt of the SRB_GET_STREAM_INFO command, the minidriver  in step  builds a hardware stream descriptor for all streams that are supported by the adaptor . This information is returned to the class driver . In step , the streaming class driver  registers the hardware stream descriptor in memory for future use.","Next, in step , the stream class driver  generates a power off command which is transmitted to the minidriver  for the adapter . (See Appendix IV) In general, the operating system , with driver , will turn off power to the adapter  whenever it is not being used, especially for battery powered computers.","The minidriver  receives the power off command in step  and turns off power to the adapter . In many systems, particularly portable computer systems, the adapter  is a device which uses a relatively substantial amount of electrical power. By disabling the adapter  when not in use, system power will be conserved.","Control is returned to the stream class driver  in step  wherein the driver  pages out the minidriver  program so that it is no longer stored in active memory, thus freeing resources for use by the application program , operating system  or other active applications. The device object is preferably closed, by closing its file handle, prior to paging out the minidriver . Finally, the class driver  enters state  to wait for a stream request which requires use of the adapter .","Upon completion of the steps shown in , the computer system multimedia subsystem has been initialized and set to be ready to use the adapter  for streaming data when needed.","Referring to , there is shown a series of interrelated operations carried out by the operating system , class driver  and minidriver  after the multimedia subsystem has been initialized as shown in . These operations are carried out to initiate and terminate a data stream request. A stream request  is generated by the operating system  in response to the application program . The data stream request is provided to the stream class driver  which responds in step  to page in the minidriver . This step loads the minidriver  into active memory. If the device object has been closed, it is opened prior to paging in the minidriver. If the minidriver  has not been paged out, step  is not needed.","In step , the stream driver  sends a power on command to the minidriver  for the adapter . This command is received by the minidriver  and in step  it turns on power to the adapter  by transmitting appropriate commands to the adapter  through the bus . Steps  and  are not needed if power has not been terminated to the adapter .","In step , the driver  calls the minidriver function HWReceivePacket with the command SRB_OPEN_STREAM (Appendix IV) and further provides a data structure HW_STREAM_OBJECT. (See Appendix III) This data structure provides the information needed by the adapter  and minidriver  to service a stream command which will be received from the application program .","Upon receipt of the stream open command, the minidriver  performs step  to activate the adapter  and open the specified stream. For the described example wherein the adapter  is a DVD, the specified stream could be the video stream. For other streams, such as audio, a new stream request  would need to be generated through the operating system  by the application program .","When the step  has been confirmed, the class driver  sends either a stream read (SRB_READ_DATA) or a stream write (SRB_WRITE_DATA) command to the minidriver function ReceiveDataPacket, as specified in the HW_STREAM_OBJECT for the selected stream. The minidriver  receives and stores the read or write command at step .","In step , the class driver  sets properties and other control information for the selected stream by passing the appropriate stream request block (SRB) to the minidriver's ReceiveControlPacket function as specified in the HW_STREAM_OBJECT for the selected stream.","At step , the minidriver  sets the properties and control information received for the selected data stream so that the data stream transfer proceeds as requested by the application program . At this point, the minidriver  is responsible for the streaming data request until it notifies the class driver  that the request has been completed.","In state , the class driver  waits for receipt of a stream termination command while the streaming data transfer proceeds between adapter  and application program .","When the application program  has completed use of the specified data stream, a stream termination  command is generated by the operating system  and transferred to the class driver  at step . In this step, the stream class driver  calls the minidriver  and sends a stream close command, SRB_CLOSE_STREAM, to the minidriver's HWReceivePacket function. In response to this command, the minidriver  at step  closes the specified stream. The transfer of data for the current stream is completed at an end state . After step , the class driver  may, optionally, close the device object, page out the minidriver , and turn power off to the adapter .","When the operating system  detects at step  that the adapter  has been disabled by the user, physically removed, or the system is being shut down, control is transferred to the driver  at step  in which the driver  calls the minidriver  and sends an uninitialization command SRB_UNINITIALIZE_DEVICE. In step  the minidriver  performs the actions needed to uninitialize the adapt  . The actions required are dependent upon the particular design of the adapter , and will vary from one manufacturer to the next. After the adapter  has been uninitlized, the minidriver  operation terminates at the end state .","While a streaming data request is being processed, the streaming adapter  may generate interrupts. When an interrupt is detected, the class driver  will call the minidriver  interrupt service routine, as described in Appendix II. All of the minidriver  functions are synchronized with the adapter  ISR. This is done to make the minidriver  nonreentrant. Nonreentrancy is accomplished by masking off the IRQ of the adapter  (and all lower priority IRQs) when code is being executed in any of the minidriver  routines. When a thread is executing in the minidriver , no calls will be made to any other function within the minidriver , including the ISR. This nonreentrancy holds true even on multiprocessor systems, making the minidriver  very easy to write.","Due to routine synchronization and request serialization, the minidriver  is multiprocessor safe and nonreentrant for low-to-medium-end hardware. The processing described above has correct file operation synchronization. For example, stream and adapter  opens are correctly serialized without having the minidrver  implement mutexes, semaphores, or events. All low-level buffer management is handled by the class driver . This includes allocation of DMA adapter object, as necessary, mapping of buffers and building scatter\/gather list of for DMA, and locking and flushing buffers appropriately in DMA versus PIO cases. All IOCTL parameter validation is performed by the class driver . All requests are timed by the class driver  with a watchdog timer.","A particular advantage for the class driver  of the present invention is that it can work with a wide variety of streaming hardware devices such as MPEG, video capture, USB audio and video and IEEE 1394 audio and video.","In summary, a driver configuration for streaming data includes a stream class driver for performing system operations which are independent of the streaming data adapter and a minidriver which performs a minimum set of functions that are dependent upon the specific hardware design implemented for the adapter. As a result, the minidriver design is greatly simplified and can be more easily implemented for each of a large number of streaming class devices.","Although one embodiment of the invention has been illustrated in the accompanying drawings and described in the foregoing Detailed Description, it will be understood that the invention is not limited to the embodiment disclosed, but is capable of numerous rearrangements, modifications and substitutions without departing from the scope of the invention.","Stream Class Driver Functions","Each of the following functions can be called by the minidriver  at any time, except in the following instances:\n\n","The StreamClassScheduleTimer routine is used to schedule a timed callback.",{"@attributes":{"id":"p-0100","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID STREAMAPI StreamClassScheduleTimer("]},{"entry":[{},"\u2003\u2003IN PHW_STREAM_OBJECT StreamObject OPTIONAL,"]},{"entry":[{},"\u2003\u2003IN PVOID HwDeviceExtension,"]},{"entry":[{},"\u2003\u2003IN ULONG NumberOfMicroseconds,"]},{"entry":[{},"\u2003\u2003IN PHW_TIMER_ROUTINE TimerRoutine,"]},{"entry":[{},"\u2003\u2003IN PVOID Context"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"StreamObject","Optionally points to the stream object if the timer is to be scheduled for a stream.","HwDeviceExtension","Points to the minidriver's device extension.","NumberOfMicroseconds","Indicates the amount of time that should expire before the timer routine should be called.","TimerRoutine","Routine that is called (at high priority) when NumberOfMicroseconds has elapsed.","Context","Supplies the parameter to be passed into the timer routine function.","Return Values","None.","Comments","The TimerRoutine function called in the StreamClassScheduleTimer routine informs the class driver that the minidriver needs to be called back at a certain time in the future. This is a one-shot timer that must be rescheduled each time it is called. The format of the minidriver's timer procedure is as follows:",{"@attributes":{"id":"p-0113","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef VOID"},{"entry":"\u2003\u2003(STREAMAPI*PHW_TIMER_ROUTINE)( \/\/timer-callback routine"},{"entry":"\u2003\u2003IN PVOID Context"},{"entry":"\u2003\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Context","2. StreamClassRegisterAdapter","The StreamClassRegisterAdapter routine is called by the minidriver from its DriverEntry routine, the minidriver's initial entry point.",{"@attributes":{"id":"p-0116","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS StreamClassRegisterAdapter("]},{"entry":[{},"\u2003\u2003IN PVOID Argument1,"]},{"entry":[{},"\u2003\u2003IN PVOID Argument2,"]},{"entry":[{},"\u2003\u2003IN PHW_INITIALIZATION_DATA HwInitializationData"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Argument1","Contains the parameter value with which the operating system called the adapter minidriver's initialization routine. This parameter is the driver object.","Argument2","Contains the parameter value with which the operating system called the adapter minidriver's initialization routine.","HwInitializationData","Supplies the initialization parameters for the adapter minidriver. as previously defined.","3. StreamClassDeviceNotification","The StreamClassDeviceNotification routine notifies the stream class driver of device-specific status changes.",{"@attributes":{"id":"p-0124","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"VOID StreamClassDeviceNotification("},{"entry":"\u2003\u2003IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE"},{"entry":"\u2003\u2003Notification Type,"},{"entry":"\u2003\u2003IN PVOID HwDeviceExtension,"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"HwDeviceExtension","Points to the adapter minidriver's storage for adapter data.","Notification Type","Contains the type of notification.",{"@attributes":{"id":"p-0129","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE {"},{"entry":"\u2003\u2003ReadyForNextDeviceRequest,"},{"entry":"\u2003\u2003DeviceRequestComplete,"},{"entry":"\u2003\u2003DeviceNotificationMaximum"},{"entry":"}STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE,"},{"entry":"\u2003\u2003*PSTREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0130","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Notification","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ReadyForNextDeviceRequest","Indicates that the adapter minidriver"]},{"entry":[{},"is ready for another device request"]},{"entry":[{},"This notification should be sent after each"]},{"entry":[{},"HW_RECEIVE_DEVICE_SRB call, as"]},{"entry":[{},"soon as the adapter minidriver is ready"]},{"entry":[{},"for another request for the device. This"]},{"entry":[{},"notification has no effect if the"]},{"entry":[{},"TumOffSynchronization value is"]},{"entry":[{},"set to TRUE by the minidriver."]},{"entry":["DeviceRequestComplete","Indicates that the supplied device SRB has"]},{"entry":[{},"completed. After this notification, the"]},{"entry":[{},"class driver owns the request, so it"]},{"entry":[{},"should not be accessed by the adapter"]},{"entry":[{},"minidriver. The third parameter must"]},{"entry":[{},"be a pointer to an SRB. The status"]},{"entry":[{},"of the SRB should be set appropriately."]},{"entry":["DeviceNotificationMaximum","Indicates whether ordinal has exceeded"]},{"entry":[{},"maximum."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"None.","4. StreamClassStreamNotification","The StreamClassStreamNotification routine notifies the class driver of stream-specific status changes.",{"@attributes":{"id":"p-0133","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"VOID StreamClassStreamNotification("},{"entry":"\u2003\u2003IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE"},{"entry":"\u2003\u2003Notification Type,"},{"entry":"\u2003\u2003IN PHW_STREAM_OBJECT Stream Object"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Stream Object","Supplies the stream object.","Notification Type","Supplies the type of notification.",{"@attributes":{"id":"p-0138","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum _STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE {"},{"entry":"\u2003\u2003ReadyForNextStreamDataRequest,"},{"entry":"\u2003\u2003ReadyForNextStreamControlRequest,"},{"entry":"\u2003\u2003HardwareStarved,"},{"entry":"\u2003\u2003StreamRequestComplete,"},{"entry":"\u2003\u2003StreamNotificationMaximum"},{"entry":"} STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE,"},{"entry":"\u2003\u2003*PSTREAM_MINIDRIVER- STREAM_NOTIFICATION_TYPE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0139","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Notification","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ReadyForNextStreamDataRequest","Indicates that the adapter minidriver is"]},{"entry":[{},"ready for another control request for the"]},{"entry":[{},"stream specified by StreamObject. This"]},{"entry":[{},"notification should be sent after each"]},{"entry":[{},"HW_RECEIVE_STREAM_DATA_SRB"]},{"entry":[{},"call, as soon as the adapter minidriver is"]},{"entry":[{},"ready for another request for this data"]},{"entry":[{},"type. This notification has no effect if the"]},{"entry":[{},"TurnOffSynchronization Boolean is set by"]},{"entry":[{},"the minidriver."]},{"entry":["ReadyForNextStreamControl","Indicates that the adapter minidriver is"]},{"entry":["Request","ready for another control request for the"]},{"entry":[{},"stream specified by Stream Object. This"]},{"entry":[{},"notification should be sent after each"]},{"entry":[{},"DATA_RECEIVE_STREAM_CONTROL_SRB"]},{"entry":[{},"call, as soon as the adapter"]},{"entry":[{},"minidriver is ready for another request for"]},{"entry":[{},"this data type. This notification has no"]},{"entry":[{},"effect if the TurnOffSynchronization"]},{"entry":[{},"Boolean is set by the minidriver."]},{"entry":["HardwareStarved","Indicates to the class driver that the"]},{"entry":[{},"minidriver is starved for data for the"]},{"entry":[{},"specified data type."]},{"entry":["StreamRequestComplete","Indicates that the supplied stream SRB"]},{"entry":[{},"has completed. After this notification the"]},{"entry":[{},"class driver owns the request, so it must"]},{"entry":[{},"not be accessed by the adapter minidriver."]},{"entry":[{},"The third parameter must be a pointer to"]},{"entry":[{},"an SRB. The status of the SRB should be"]},{"entry":[{},"set appropriately."]},{"entry":["StreamNotificationMaximum","To be provided in a future draft."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"None.","5. StreamClassCallAtNewPriority","The StreamClassCallAtNewPriority routine is used to schedule a callback at a different priority.",{"@attributes":{"id":"p-0142","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID StreamClassCallAtNewPriority("]},{"entry":[{},"\u2003\u2003IN PHW_STREAM_OBJECT StreamObject OPTIONAL,"]},{"entry":[{},"\u2003\u2003IN PVOID HwDeviceExtension,"]},{"entry":[{},"\u2003\u2003IN STREAM_PRIORITY Priority,"]},{"entry":[{},"\u2003\u2003IN PHW_PRIORITY_ROUTINE PriorityRoutine,"]},{"entry":[{},"\u2003\u2003IN PVOID Context"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Stream Object","Optionally contains the stream object pointer if the priority callback is for a particular stream.","HwDeviceExtension","Contains the pointer to the minidriver's device extension.","Priority","Indicates the priority being requested. Definitions are as follows:",{"@attributes":{"id":"p-0149","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum _STREAM_PRIORITY {"]},{"entry":[{},"High,"]},{"entry":[{},"Dispatch,"]},{"entry":[{},"Low,"]},{"entry":[{},"LowToHigh"]},{"entry":[{},"} STREAM_PRIORITY, *PSTREAM_PRIORITY;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0150","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Priority","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"High","Priority at which the minidriver's functions"]},{"entry":[{},{},"are normally called. If the minidriver has"]},{"entry":[{},{},"scheduled a dispatch priority call and"]},{"entry":[{},{},"needs to return to high priority, this"]},{"entry":[{},{},"priority should be specified. For example,"]},{"entry":[{},{},"if the minidriver has disabled its adapter"]},{"entry":[{},{},"interrupts and scheduled a DispatchPriority"]},{"entry":[{},{},"event, the minidriver should schedule a"]},{"entry":[{},{},"HighPriority event from the"]},{"entry":[{},{},"DispatchPriority event, and re-enable card"]},{"entry":[{},{},"interrupts when the specified HighPriority"]},{"entry":[{},{},"entry point is called. Doing so will avoid"]},{"entry":[{},{},"reentrancy in the minidriver."]},{"entry":[{},"Dispatch","Used to specify if the additional processing"]},{"entry":[{},{},"will take less than 1 millisecond. The"]},{"entry":[{},{},"adapter should not interrupt after this"]},{"entry":[{},{},"notification call is made, so interrupts"]},{"entry":[{},{},"should be disabled on the card before"]},{"entry":[{},{},"specifying this call, or the minidriver's ISR"]},{"entry":[{},{},"will be re-entered."]},{"entry":[{},"Low","Used to specify if the additional processing"]},{"entry":[{},{},"will take more than 1 millisecond. The"]},{"entry":[{},{},"adapter should not interrupt after this"]},{"entry":[{},{},"notification call is made, so interrupts"]},{"entry":[{},{},"should be disabled on the card before"]},{"entry":[{},{},"specifying this call, or the minidriver's ISR"]},{"entry":[{},{},"will be re-entered. Additionally, any of the"]},{"entry":[{},{},"minidriver's request functions and any"]},{"entry":[{},{},"scheduled timers will reenter the"]},{"entry":[{},{},"minidriver when this priority is scheduled."]},{"entry":[{},{},"Note: If the minidriver has left"]},{"entry":[{},{},"synchronization enabled"]},{"entry":[{},{},"(NoSynchronization boolean NOT set) no"]},{"entry":[{},{},"stream class driver services can be called"]},{"entry":[{},{},"by a low priority thread except from"]},{"entry":[{},{},"StreamClassCaliAtNewPriority with"]},{"entry":[{},{},"LowToHigh."]},{"entry":[{},"LowToHigh","Used to allow a thread called at low"]},{"entry":[{},{},"priority to return to high priority, so other"]},{"entry":[{},{},"stream class driver services can be called."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"PriorityRoutine","Entry point within the mini driver to be called at the lower priority.","Context","Supplies the parameter to be passed into the priority routine function.","Return Values","None.","Comments","This PriorityRoutine function in the StreamClassCallAtNewPriority routine informs the class driver that the minidriver needs to be called back at a lower priority. Note that this function cannot be called if the minidriver has set the TurnOffSynchronization Boolean for the adapter. This service should be used if a significant number of processor instructions must be executed from ISR request, or other entry points in the minidriver. The format of the minidrivers priority callback routine is as follows:",{"@attributes":{"id":"p-0157","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef VOID"]},{"entry":[{},"\u2003\u2003(STREAMAPI *PHW_PRIORJTY _ROUTINE)("]},{"entry":[{},"\u2003\u2003IN PVOID Context"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The StreamClassGetPhysicalAddress routine is used to translate a virtual address into a physical address range that can be used directly by adapters through busmaster DMA.",{"@attributes":{"id":"p-0159","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"STREAM_PHYSICAL_ADDRESS StreamClassGetPhysicalAddress("},{"entry":"\u2003\u2003IN PVOID HwDeviceExtension,"},{"entry":"\u2003\u2003IN PHW_STREAM_REQUEST _BLOCK HwSRB OPTIONAL,"},{"entry":"\u2003\u2003IN PVOID VirtualAddress,"},{"entry":"\u2003\u2003IN STREAM_BUFFER_TYPE Type,"},{"entry":"\u2003\u2003OUT ULONG *Length"},{"entry":"\u2003\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"HwDeviceExtension","Points to the adapter minidriver's storage for adapter data.","HwSRB","(Optional) Supplies an SRB.","VirtualAddress","Supplies the virtual address to be translated. The SRB is required if the address came from the DataBuffer field of a STREAM_REQUEST_BLOCK.","Type","Indicates the type of buffer pointed to by VirtualAddress. Allowable types are listed as follows:",{"@attributes":{"id":"p-0168","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"PerRequestExtension"]},{"entry":[{},"DmaBuffer"]},{"entry":[{},"SRBDataBuffer"]},{"entry":[{},"} STREAM_BUFFER_TYPE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0169","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Buffer Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PerRequestExtension","Indicates the physical address of the SRB"]},{"entry":[{},{},"extension."]},{"entry":[{},"DmaBuffer","Indicates the physical address of the DMA"]},{"entry":[{},{},"buffer."]},{"entry":[{},"SRBDataBuffer","Indicates the physical address of the data"]},{"entry":[{},{},"buffer."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Length","Returns the length of the physical memory segment.","Return Values","The StreamClassGetPhysicalAddress routine returns the length, in bytes, of the physical memory segment.","Comments","The StreamClassGetPhysicalAddress routine can be used to build a scatter\/gather list for DMA data transfers that span physical data pages. The returned length indicates the length in bytes of the physical segment. Note that the length returned can be longer than the length of the data buffers specified in the SRB and that no locking, probing, mapping, or flushing of these physical addresses is necessary. All these operations are performed by the stream class.","An SRB is not required if the VirtualAddress is not of type PerRequestExtension. This function can only be called to translate an extension address if BusMasterDma is specified in HW_INITIALIZATION_DATA.","7. StreamClassAbortOutstandingRequests","The StreamClassAbortOutstandingRequests routine is used to abort all outstanding requests to a particular stream or the entire device. If the StreamObject parameter is not zero all outstanding requests to the specified stream should be aborted by the class driver. If the StreamObject parameter is zero all outstanding requests to the device and all streams should be aborted. The Status parameter indicates with what status each request should be aborted.",{"@attributes":{"id":"p-0176","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PVOID StreamClassAbortOutstandingRequests("]},{"entry":[{},"\u2003\u2003IN PVOID HwDeviceExtension,"]},{"entry":[{},"\u2003\u2003IN PHW_STREAM_OBJECT HwStreamObject,"]},{"entry":[{},"\u2003\u2003IN NTSTATUS Status"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"DeviceExtension","Points to the adapter minidriver's storage for adapter data.","HwStream Object","Points to the stream object.","Status","Indicates the status with which to abort each of the requests.","Comments","The class driver automatically sets a ReadyForNextStreamDataRequest, ReadyForNextStreamControlRequest, and\/or ReadyForNextDeviceRequest for each request it aborts, depending on the type of requests it aborted.","8. StreamClassQueryMasterClock","The StreamClassQueryMasterClock routine allows slave streams to read the current value of the master clock or the stream time.",{"@attributes":{"id":"p-0185","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"VOID StreamClassQueryMasterClock("},{"entry":"\u2003\u2003IN PHW_STREAM_OBJECT HwStreamObject,"},{"entry":"\u2003\u2003IN HANDLE MasterClockHandle,"},{"entry":"\u2003\u2003IN TIME_FUNCTION TimeFunction,"},{"entry":"\u2003\u2003IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine"},{"entry":"\u2003\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"HwStreamObject","Contains the pointer to the stream object for the stream.","MasterClockHandle","Contains the handle for the master clock that was passed to the minidriver through SRB_INDICATE_MASTER_CLOCK",{"@attributes":{"id":"p-0190","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TimeFunction"]},{"entry":[{},"\u2003\u2003\u2003\u2003Indicates which type of clock value to read:"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003typeder enum {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003TIME_GET_STREAM_TIME,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003TIME_READ_ONBOARD_CLOCK,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003TIME_SET_ONBOARD_CLOCK,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003} TIME_FUNCTION;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0191","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TIME_GET_STREAM_TIME","Returns the current PTS being"]},{"entry":[{},"processed by the master clock,"]},{"entry":[{},"in 100 ns units."]},{"entry":["TIME_READ_ONBOARD_CLOCK","Returns the current on-board"]},{"entry":[{},"clock value, in 100 ns units."]},{"entry":[{},"Used for rate matching tunable"]},{"entry":[{},"clocks. A minidriver that has"]},{"entry":[{},"a slave clock can read the"]},{"entry":[{},"time value of the master"]},{"entry":[{},"clock and tune or set the"]},{"entry":[{},"slave clock to this value."]},{"entry":["TIME_SET_ONBOARD_CLOCK","Causes the minidriver to set or"]},{"entry":[{},"tune the current value of the"]},{"entry":[{},"clock. The correct value for the"]},{"entry":[{},"clock is set in the Time field"]},{"entry":[{},"of the HW_TIME_CONTEXT"]},{"entry":[{},"structure, in 100 ns units."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"ClockCallbackRoutine","Pointer to the procedure within the minidriver to be called back when the requested time is retrieved from the master clock.","Return Values","None.","Comments","The prototype of the ClockCallbackRoutine routine is as follows:",{"@attributes":{"id":"p-0196","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef VOID"]},{"entry":[{},"(STREAMAPI * PHW_QUERY_CLOCK_ROUTINE)("]},{"entry":[{},"\/\/ query clock callback routine"]},{"entry":[{},"IN PHW- TIME_CONTEXT TimeContext"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Time Context","When this procedure is called by the stream class, the TimeContext field points to a  structure. The structure supplies the minidriver with the requested clock time.","9. StreamClassGetDmaBuffer","The StreamClassGetDmaBuffer routine provides the minidriver with a pointer to the DMA buffer to the mindriver, if the minidriver specified a DMA buffer size in the HW_INITIALIZATION_DATA structure.",{"@attributes":{"id":"p-0200","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PVOID StreamClassGetDmaBuffer("]},{"entry":[{},"\u2003\u2003IN PVOID HwDeviceExtension"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"HwDeviceExtension","Points to the minidriver's device extension.","Return Value","The StreamClassGetDmaBuffer routine returns a pointer to the DMA buffer.","10. StreamClassRegisterFilterWithNoKSPins","The StreamClassRegisterFilterWithNoKSPins routine is used to register filters with DirectShow that have no kernel streaming pins and therefore do not stream in kernel mode.",{"@attributes":{"id":"p-0206","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NTSTATUS StreamClassRegisterFilterWithNoKSPins("]},{"entry":[{},"IN PDEVICE_OBJECT Device Object,"]},{"entry":[{},"IN const GUID *InterfaceClassGUID,"]},{"entry":[{},"IN ULONG Pin Count,"]},{"entry":[{},"IN BOOL *PinDirection,"]},{"entry":[{},"IN OPTIONAL GUID *CategoryList"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"DeviceObject","Points to the device object.","InterfaceClassGUID","Contains the GUID representing the class to register.","PinCount","Contains the count of the number of pins on the filter","PinDirection","Contains an array of Boolean values indicating pin direction for each pin (length of the array is PinCount). Output pins are TRUE, input pins are FALSE.","MediumList","Contains an array of PKSMEDIUM_DATA. The length of the array is Pin Count.","CategoryList","Optionally contains an array of GUIDs indicating pin categories. The length of the array is PinCount.","Return Value","The StreamClassRegisterFilterWithNoKSPins routine returns NTSTATUS_SUCCESS if the registry key is created.","Comments","The StreamClassRegisterFilterWithNoKSPins routine is typically used for TvTuners, Crossbars, and similar components. On exit, a new binary registry key, FilterData, is created that contains the Mediums and optionally the Categories for each pin on the filter.","11. StreamClassGetNextEvent","The StreamClassGetNextEvent routine retrieves the first or next event from the event queue. If the CurrentEvent parameter is a NULL, then the routine will return the first event.",{"@attributes":{"id":"p-0222","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PKSEVENT _ENTRY StreamClassGetNextEvent("]},{"entry":[{},"IN PVOID HwDeviceExtension,"]},{"entry":[{},"IN PHW_STREAM_OBJECT HwStreamObject,"]},{"entry":[{},"IN OPTIONAL GUID * EventGuid,"]},{"entry":[{},"IN OPTIONAL ULONG EventItem,"]},{"entry":[{},"IN OPTIONAL PKSEVENT_ENTRY CurrentEvent"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"HwDeviceExtension","Points to the minidriver's device extension.","HwStreamObject","Points to the stream object for the stream.","EventGuid","Contains an optional GUID specifier that indicates the event to retrieve. A NULL value indicates a wildcard.","EventItem","Contains an optional item specifier that indicates the item within a set of events (as specified by the EventGuid member) to return. A value of \u22121 indicates a wildcard.","CurrentEvent","Points to an event previously returned by the StreamClassGetNextEvent routine. The routine will return the next event of the specified type following CurrentEvent in the queue. A NULL value indicates that the first event of the specified type is to be returned.","Return Value","The StreamClassGetNextEvent routine returns the first or next event of the specified type if successful, or NULL if no event is found.","12. StreamClassReadWriteConfig","The StreamClassReadWriteConfig routine returns or sets the configuration information from the parent from the device. The routine is commonly used to retrieve or set PCI information when the minidriver is controlling a PCI card. The routine must be called at Passive Level.","BOOLEAN STREAMAPI",{"@attributes":{"id":"p-0235","num":"0236"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"StreamClassReadWriteConfig("]},{"entry":[{},"IN PVOID HwDeviceExtension,"]},{"entry":[{},"IN BOOLEAN Read,"]},{"entry":[{},"IN PVOID Buffer,"]},{"entry":[{},"IN ULONG Offset,"]},{"entry":[{},"IN ULONG Length"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"HwDeviceExtension","Contains the device extension.","Read","Indicates if the action is a read or write. If set to TRUE, the configuration information is read. If set to FALSE, configuration information is written.","Buffer","Indicates the buffer to write the configuration information into, or from which to read the information. The buffer is normally a stack buffer (a local variable within the calling routine), or the information could be read directly into the HW device extension.","Offset","Indicates the offset within the configuration information to read or write.","Length","Indicates the length of the data to read or write.","Return Value","The StreamClassReadWriteConfig routine returns TRUE if the read or write was successful, or it returns FALSE if unsuccessful.","Comments","The StreamClassReadWriteConfig routine can only be called at Passive level. Drivers using stream class synchronization must use a callback from  to access this routine.","13. StreamClassQueryMasterClockSync","The StreamClassQueryMasterClockSync routine synchronously retrieves the current master clock time. This routine must be used at Dispatch or Passive level. If the caller is running at a raised IRQL (using stream class synchronization with a hardware interrupt), it should use the asynchronous version of this service () or use a callback from StreamClassCallAtNewPriority.",{"@attributes":{"id":"p-0249","num":"0250"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"VOID STREAMAPI"]},{"entry":[{},"\u2003StreamClassQueryMasterClockSync("]},{"entry":[{},"\u2003IN HANDLE MasterClockHandle,"]},{"entry":[{},"\u2003IN OUT PHW- TIME_CONTEXT TimeContext"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"MasterClockHandle","Contains the handle to the master clock.","Time Context","Points to a TimeContext structure, usually a stack or local variable.","Return Value","The StreamClassQueryMasterClockSync routine returns the time specified in the Function member of the TimeContext structure if successful or an error if it is unsuccessful.","Comments","For more information on querying the master clock, see .","14. SteamClassCompleteRequestAndMarkQueueReady",{"@attributes":{"id":"p-0256","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"The StreamClassCompleteRequestAndMarkQueueReady routine..."]},{"entry":[{},"StreamClassCompleteRequestAndMarkQueueReady("]},{"entry":[{},"IN PHW_STREAM_REQUEST_BLOCK Srb"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"SRB","Contains the","Return Value","The StreamClassCompleteRequest routine returns . . . if successful, or . . . if it is unsuccessful.","Minidriver Functions","The following functions are supplied by the minidriver  and are called by the class driver . All these routines, except for the completion and setup routine, run to completion and are executed serially. This means that no two of these routines execute at the same time with the same device extension. Because these routines are running at an elevated interrupt request level (potentially blocking other processors), they should execute as quickly as possible.","When the class driver  receives a request to be processed by the hardware adapter  associated with the minidriver , the class driver  calls the minidriver's setup routine. The setup routine may allocate memory necessary to process the request. The request is queued by the class driver . The class driver  then calls the minidriver's start  routine to begin the request processing. After this call, the minidriver  is responsible for the request until it notifies the class driver  that the request has completed.","As the request is processed, the adapter  will generate interrupts. When an interrupt is detected, the class driver  calls the associated minidriver's interrupt service routine (ISR). After the request has completed, the minidriver  notifies the class driver  of the completion.","Minidriver Initialization","Every kernel-mode driver, including minidrivers, has to expose a routine named . This routine initializes various driver data structures, including the key  structure, and prepares the environment for all the other driver components.","1. DriverEntry","The DriverEntry routine must do the following:\n\n","The minidriver allocates its stack and then initializes the other fields. All of the fields must be initialized. The DriverEntry should then call StreamClassRegisterAdapter. The adapter minidriver's initialization routine should return the status value returned by",{"@attributes":{"id":"p-0266","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"StreamClassRegisterAdapter. ULONG DriverEntry("]},{"entry":[{},"\u2003IN PVOID Argument1,"]},{"entry":[{},"\u2003IN PVOID Argument2"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Argument1","Supplies a context value with which the adapter minidriver should call StreamClassRegisterAdapter.","Argument2","Supplies a second context value with which the adapter minidriver should call StreamClassRegisterAdapter.","2. HW_INITIALIZATION_DATA","The HW_INITIALIZATION_DATA structure is the hardware initialization data structure. This structure is used in the DriverEntry routine, and is passed between minidriver initialization and stream class initialization.",{"@attributes":{"id":"p-0272","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct HW_INITIALIZATION_DATA {"]},{"entry":[{},"ULONG HwInitializationDataSize;"]},{"entry":[{},"PHW _INTERRUPT HwInterrupt;"]},{"entry":[{},"PHW_RECEIVE_DEVICE_SRB HwReceivePacket;"]},{"entry":[{},"PHW_CANCEL_SRB HwCancelPacket;"]},{"entry":[{},"PHW_REQUEST _TIMEOUT_HANDLER"]},{"entry":[{},"HwRequestTimeoutHandler;"]},{"entry":[{},"ULONG DeviceExtensionSize;"]},{"entry":[{},"ULONG PerRequestExtensionSize;"]},{"entry":[{},"ULONG PerStreamExtensionSize;"]},{"entry":[{},"ULONG FilterInstanceExtensionSize;"]},{"entry":[{},"BOOLEAN BusMasterDMA;"]},{"entry":[{},"BOOLEAN Dma24BitAddresses;"]},{"entry":[{},"ULONG BufferAlignment;"]},{"entry":[{},"BOOLEAN TumOffSynchronizatioo;"]},{"entry":[{},"ULONG DmaBufferSize;"]},{"entry":[{},"} HW_INITIALIZATION_DATA,"]},{"entry":[{},"*.PHW_INITIALIZATION_DATA;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Contains the size of the structure, in bytes, as reported by the size of function.","HwInterrupt","Points to the adapter minidriver's interrupt routine.","HwReceivePacket","Points to the adapter mini driver's receive device data packet routine. This is the entry point for receiving an SRB request from the stream class driver to the adapter.","HwCancelPacket","Points to the adapter minidriver's cancel packet routine. This routine is called when an outstanding stream or adapter-based request needs to be canceled. This routine is called only under extreme circumstances, such as when an upper layer is attempting to recover and data packets are considered lost.","HwRequestTimeoutHandler","Points to the adapter minidriver's request time-out handler. This routine is called when a stream or adapter-based packet times out. The time out is not necessarily an error, and it is up to the minidriver to determine what to do with the packet that times out.","DeviceExtensionSize","Contains the size in bytes required by the adapter minidriver for its device extension. This storage is used by the adapter minidriver to hold peradapter information. A pointer to this storage is supplied with every call to the adapter minidriver. This data is initialized to zero by the class driver.","PerRequestExtensionSize","Contains the number of bytes of extra workspace needed for each request by the minidriver.","PerStreamExtensionSize","Contains the number of bytes of extra workspace needed for each stream information structure by the minidriver.","FilterInstanceExtensionSize","Contains the number of bytes of workspace needed for each instance extension. Normally set to zero except for hardware that can support multiple instances of the reported streams on the same adapter.","BusMasterDMA","Indicates that the memory pointers passed to the minidriver may be used for direct Bus Master DMA access. If the minidriver uses a translation buffer (to ensure minimum DMA size or correct buffer alignment), this value should be set to FALSE.","Dma24BitAddresses","Indicates that the DMA engine can access only the lower 24 bits of the 32 bit address space. This should only be set to TRUE if the minidriver will be doing DMA directly to the buffer and not through a double-buffer scenario.","BufferAlignment","Specifies the alignment requirement of the buffers. For example, if the DMA engine requires the buffers to be quadword aligned, then four should be specified. Note that many data types such as DVD MPEG, will be either byte aligned or word aligned, so DMA hardware should be designed to support it.","TurnOffSynchronization","If this field is set to FALSE, the minidriver cannot be reentered. Therefore, if the minidriver uses a DISPATCH or lower priority callback routine, the minidriver must disable any interrupts that it might receive. If an interrupt controlled by the driver is received while code in the minidriver is running at DISPATCH or lower priority, the interrupt is lost. If an interrupt is received while at HIGH priority, it is queued until the currently executing code is finished.","If this field is set to TRUE, the minidriver must handle all multiprocessor reentrancy issues.","DmaBufferSize","Specifies the size of the single contiguous region of physical memory that the driver needs at hardware initialization time. The memory is returned to the driver when the driver makes the StreamClassGetDmaBuffer call. It is important to use as little physical buffer as possible here, as this is locked physical memory that is not available to the system, even when the streaming class minidriver is not in use.","Minidriver Routines Called by the Class Driver","The minidriver can contain routines that will 5e called by the class driver. The function prototypes are contained in the minidrivers header file. Following is a complete list of routines:","1. PHW_RECEIVE_DEVICE_SRB","The PHW_RECEIVE_DEVICE_SRB routine is the entry point for sending device-specific SRBs to the minidriver.",{"@attributes":{"id":"p-0290","num":"0293"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef VOID"]},{"entry":[{},"\u2003(STREAMAPI *PHW_RECEIVE_DEVICE_SRB)( \/\/"]},{"entry":[{},"\u2003HwReceivePacket routine"]},{"entry":[{},"\u2003IN PHW_STREAM_REQUEST_BLOCK SRB);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"SRB","Points to the SRB to be processed.","Return Values","None.","Comments","The PHW_RECEIVE_DEVICE_SRB routine is called when the initial device request is received and after each subsequent ReadyForNextDeviceRequest notification is received for this type. After this call, the adapter minidriver owns the request and is expected to complete it. The request should be completed asynchronously (through interrupt-based or timer-based polling) if the request could potentially take more than a few microseconds to complete. The mini driver should never poll ports waiting for a lengthy request to complete.","2. PHW_REQUEST_TIMEOUT_HANDLER","The PHW_REQUEST_TIMEOUT_HANDLER routine is called by the class driver when an SRB has timed out.",{"@attributes":{"id":"p-0296","num":"0299"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef VOID"},{"entry":"\u2003(STREAMAPI *PHW_REQUEST _TIMEOUT _HANDLER) ( \/\/"},{"entry":"\u2003HwRequestTimeoutHandler routine"},{"entry":"\u2003IN PHW_STREAM_REQUEST_BLOCK SRB"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"SRB","Paints to the SRB that has timed out.","Return Values","None.","Comments","The TimeoutCounter and TimeoutOriginal fields are used to time the request. The class driver will set both of these fields to a nonzero value before the request is received by the minidriver and will then begin counting down the TimeoutCounter field until it reaches zero. When it reaches zero, the minidriver's time-out handler will be called. If the minidriver queues a request for a long time, it should set the TimeoutCounter to zero to turn off the timer. Once the request is dequeued, it should set the TimeoutCounter field to the value in TimeoutOriginal.","When a request times out and the time-out handler is called, the minidriver should normally reset its hardware, abort this request, and issue a ReadyForNextStreamDataRequest, ReadyForNextStreamControlRequest, or ReadyForNextDeviceRequest, depending on the type of request. Alternatively, the minidriver may reset its hardware and call StreamClassAbortOutstandingRequests, which will abort all outstanding requests on a particular stream or device. Minidrivers that set the TurnOff Synchronization Boolean should first verify that the request is still in their queues before taking action upon it.","3. PHW_CANCEL_SRB","The PHW_CANCEL_SRB routine is usually called when the minidriver should normally abort a request with STATUS_CANCELLED. It should then issue a ReadyForNextStreamDataRequest, ReadyForNextStreamControlRequest, or ReadyForNextDeviceRequest, depending on the type of request. Minidrivers that set the TurnOff Synchronization Boolean will not receive this call. Alternately, StreamClassAbortAllRequests can be called to abort all requests on a specific stream or the device.",{"@attributes":{"id":"p-0303","num":"0306"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef VOID"},{"entry":"\u2003(STREAMAPI* PHW_CANCEL_SRB)( \/\/ HwCancelPacket routine"},{"entry":"\u2003IN PHW_STREAM_REQUEST_BLOCK SRB);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"SRB","Points to the SRB that is to be canceled.","Return Values","None.","4. PHW_INTERRUPT","The PHW_INTERRUPT routine is called when the adapter hardware generates an interrupt. This routine must clear the interrupt on the adapter before it returns.",{"@attributes":{"id":"p-0308","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef BOOLEAN"]},{"entry":[{},"\u2003(STREAMAPI* PHW_INTERRUPT) ( \/\/ HwInterrupt routine"]},{"entry":[{},"\u2003IN PVOID DeviceExtension"]},{"entry":[{},"\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"DeviceExtension","Supplies the adapter minidriver's storage for adapter data.","Return Values","The PHW_INTERRUPT routine returns FALSE if the adapter is not interrupting, or TRUE if the adapter is interrupting.","5. PHW_RESET ADAPTER","The PHW_RESET_ADAPTER routine is called by the class driver when it determines that the streaming adapter needs to be reset.",{"@attributes":{"id":"p-0314","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef BOOLEAN"},{"entry":"\u2003(STREAMAPI *PHW_RESET_ADAPTER)( \/\/ HwResetAdapter"},{"entry":"\u2003routine"},{"entry":"\u2003IN PVOID DeviceExtension"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"DeviceExtension","Supplies the adapter minidriver's storage for adapter data.","Return Values","The PHW_RESET_ADAPTER routine returns TRUE if the adapter was successfully reset, or FALSE if the reset attempt failed.","Comments","For multifunction cards, all functions should be reset on this call as appropriate. This function may be called even if the minidriver is not ready for another request.","Stream Object Routines","The following routines are used to access or change the stream object created when an SRB is requested:","1. PHW_RECEIVE_STREAM_DATA_SRB","The PHW_RECEIVE_STREAM_DATA_SRB routine is the entry point for receiving data transfer SRBs to an opened stream. The pointer to this routine is filled into the HW_STREAM_OBJECT structure during the SRB_OPEN_STREAM call.",{"@attributes":{"id":"p-0321","num":"0324"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef VOID"},{"entry":"\u2003(STREAMAPI *PHW_RECEIVE_STREAM_DATA_SRB) (\/\/"},{"entry":"\u2003HwReceiveDataPacket routine"},{"entry":"\u2003IN PHW_STREAM_REQUEST _BLOCK SRB"},{"entry":"\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"SRB","Points to the SRB to be processed.","Return Values","None.","Comments","A separate entry point in the HW_STREAM_OBJECT structure can be used for each stream if required by the minidriver. The PHW_RECEIVE_STREAM_DATA_SRB routine is called when the initial data request for an opened stream is received and after each subsequent ReadyForNextStreamDataRequest notification is received for this type.","After this call, the adapter minidriver owns the request and is expected to complete it. The request should be completed asynchronously (through interrupt-based or timer-based polling) if the request can potentially take more than a few microseconds to complete.","2. PHW_RECEIVE_STREAM_CONTROL_SRB","The PHW_RECEIVE_STREAM_CONTROL_SRB routine is the entry point for receiving nondata transfer (such as SRB_SET_DEVICE_STATE) SRBs to an opened stream. The pointer to this routine is filled into the HW_STREAM_OBJECT structure during the SRB_OPEN_STREAM call (defined later). A separate entry point can be used for each stream if desired by the minidriver.",{"@attributes":{"id":"p-0328","num":"0331"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef VOID"]},{"entry":[{},"\u2003(STREAMAPI *PHW_RECEIVE_STREAM_CONTROL_SRB)"]},{"entry":[{},"\u2003( \/\/ HwReceiveControl Packet routine"]},{"entry":[{},"\u2003IN PHW_STREAM_REQUEST _BLOCK SRB);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"SRB","Points to the SRB to be processed.","Return Values","None.","Comments","The PHW_RECEIVE_STREAM_CONTROL_SRB routine is called when the initial control request for an opened stream is received and after each subsequent ReadyForNextStreamControlRequest notification is received for this type. After this call, the adapter minidriver owns the request and is expected to complete it. The request should be completed asynchronously (through interrupt-based or timer-based polling) if the request could potentially take more than a few microseconds to complete. The minidriver should never poll ports waiting for a lengthy request to complete.","Streaming Header Information","The streaming header information is contained in several structures. The HW_STREAM_HEADER structure is the primary structure and is followed in memory by one or more HW_STREAM_INFORMATION structures. These structures then make up the HW_STREAM_DESCRIPTOR structure.","The following structures are used to report which stream types and properties are supported by the minidriver.\n\n","The HW_STREAM_HEADER structure reports which stream types and properties are supported by the minidriver. It is used in conjunction with the HW_STREAM_INFORMATION structure.",{"@attributes":{"id":"p-0336","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _HW_STREAM_HEADER {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003ULONG","NumberOfStreams;"]},{"entry":[{},"\u2003ULONG","SizeOfHwStreamInformation;"]},{"entry":[{},"\u2003ULONG","NumDevP ropArrayEntries;"]},{"entry":[{},"\u2003PKSPROPERTY _SET","DevicePropertiesArray;"]},{"entry":[{},"\u2003ULONG","NumDevEventArrayEntries;"]},{"entry":[{},"\u2003PKSEVENT _SET","DeviceEventsArray;"]},{"entry":[{},"\u2003PKSTOPOLOGY","Topology;"]},{"entry":[{},"\u2003PHW _EVENT_ROUTINE","DeviceEventRoutine"]},{"entry":[{},"\u2003ULONG","Reserved[2];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} \u2003HW_STREAM_HEADER, *PHW_STREAM_HEADER;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"Indicates the number of HW_STREAM_INFORMATION structures that follow the HW_STREAM-HEADER structure. The first of these packets is constructed by the mini driver immediately adjacent to the HW_STREAM_HEADER structure.","SizeOfHwStreaminformation","Indicates the size of the HW_STREAM_INFORMATION structure, which is filled in by the minidriver.","NumDevPropArrayEntries","Indicates the number of property sets supported by the device, which is the number of array entries specified by the pointer below. For more information on property sets, see Kernel Streaming Reference in the WDM DDK documentation.","DevicePropertiesArray","Points to the array of property sets supported by the stream.","NumDevEventArrayEntries","Indicates the number of event sets supported by the device itself.","DeviceEventsArray","Points to the array of device property sets.","Topology","Points to the topology structure. At a minimum, the categories information must be filled in with at least one category GUID. See the WDM Kernel Streaming documentation for more information on this structure.","DeviceEventRoutine","To be defined in a future version.","Reserved","Reserved. Do not use.","2. HW_STREAM_INFORMATION","The HW_STREAM_INFORMATION structure indicates what streams are supported. The stream represented by the first HW_STREAM_INFORMATION structure is designated Stream Zero.",{"@attributes":{"id":"p-0347","num":"0353"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _HW_STREAM_INFORMATION {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003ULONG","NumberOfPossibleInstances;"]},{"entry":["\u2003KSPIN_DATAFLOW","DataFlow;"]},{"entry":["\u2003BOOLEAN","DataAccessible;"]},{"entry":["\u2003ULONG","NumberOfFormatArrayEntries;"]},{"entry":["\u2003PKSDATAFORMAT*","StreamFormatsArray;"]},{"entry":["\u2003PVOID","ClassReserved[4];"]},{"entry":["\u2003ULONG","NumStreamPropArrayEntries;"]},{"entry":["\u2003PKSPROPERTY _SET","StreamPropertiesArray;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} HW_STREAM_INFORMATION,"},{"entry":"*.PHW_STREAM_INFORMATION;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Indicates the number of instances of this stream that are supported by the adapter. For example if this stream information is for an MPEG 2 PES video data stream and the minidriver supports two of them this value would be set to two.","DataFlow","Indicates the direction of data flow for this stream. Set to one of the following types:",{"@attributes":{"id":"p-0350","num":"0356"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum{"]},{"entry":[{},"\u2003KSPIN_DATAFLOW_IN = 1,"]},{"entry":[{},"\u2003KSPIN_DATAFLOW_OUT,"]},{"entry":[{},"\u2003KSPIN_DA T AFLOW_FULLDUPLEX"]},{"entry":[{},"\u2003} KSPIN_DATAFLOW, *PKSPIN_DATAFLOW;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Indicates whether the data is accessible by the class driver. The minidriver should be set to TRUE for any stream that accepts data from the class driver or can return data to the class driver. Streams such as an NTSC output that go to a monitor would not be accessible to the class driver, so the Boolean should be set to false.","NumberOfFormatArrayEntries","To be provided in a future draft.","StreamFormatsArray","Provides a pointer to the following variable length structure, which contains GUIDs specifying what type of data is represented by this stream.",{"@attributes":{"id":"p-0354","num":"0360"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct {"]},{"entry":[{},"\u2003GUID guidMajorFormat;"]},{"entry":[{},"\u2003GUID gutdSubFormat;"]},{"entry":[{},"\u2003GUID guidSpecifier;"]},{"entry":[{},"\u2003ULONG cbFormat;"]},{"entry":[{},"} KSDATAFORMAT, *PKSDATAFORMAT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0355","num":"0361"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"GUID","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"guidMajorFormat","Specifies the format of the data,"]},{"entry":[{},{},"such as VIDEO."]},{"entry":[{},"guidSubFormat","Specifies the subformat of the data,"]},{"entry":[{},{},"such as MPEG 2 PES."]},{"entry":[{},"guidSpecifier","Specifies specific parameters"]},{"entry":[{},{},"supported for the data."]},{"entry":[{},"cbFormat","Specifies the length of parameters"]},{"entry":[{},{},"as defined by the specifier GUID"]},{"entry":[{},{},"above."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"These fields must not be changed or examined by the minidriver.","NumStreamPropArrayEntries","Indicates the number of property array entries specified by the following pointer. See Kernel Mode Streaming Reference in the WDM DDK documentation for more information on property sets.","StreamPropertiesArray","Points to an array of property sets supported by the stream.","3. HW_TIME_CONTEXT","The HW_TIME_CONTEXT structure is defined as follows:",{"@attributes":{"id":"p-0360","num":"0366"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _HW_TIME_CONTEXT {"]},{"entry":[{},"\u2003struct _HW_DEVICE_EXTENSION *HwDeviceExtension;"]},{"entry":[{},"\u2003struct _HW_STREAM_OBJECT *HwStreamObject;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003TIME_FUNCTION","Function;"]},{"entry":[{},"\u2003ULONGLONG","Time;"]},{"entry":[{},"\u2003ULONGLONG","SystemTime;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} HW_TIME_CONTEXT, *PHW_TIME_CONTEXT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"Indicates what function is required. The following functions are defined. Note that each of the times returned must be in 100 ns units.",{"@attributes":{"id":"p-0362","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"\u2003TIME_GET_STREAM_TIME,"]},{"entry":[{},"\u2003TIME_READ_ONBOARD _CLOCK,"]},{"entry":[{},"\u2003TIME_SET_ONBOARD_CLOCK,"]},{"entry":[{},"\u2003} TIME_FUNCTION;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0363","num":"0369"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Function","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TIME_GET_STREAM_TIME","Indicates that the minidriver should"]},{"entry":[{},"return the current PTS being"]},{"entry":[{},"processed by the hardware for the"]},{"entry":[{},"master clock in the Time field of"]},{"entry":[{},"the HW_TIME_CONTEXT structure,"]},{"entry":[{},"in 100 ns units. The value is only passed in if the"]},{"entry":[{},"CanReturnStreamTime Boolean is"]},{"entry":[{},"set. The minidriver should also"]},{"entry":[{},"return the current system time"]},{"entry":[{},"(retrieved through KeQueryPerformanceCounter)"]},{"entry":[{},"in the SystemTime field of the"]},{"entry":[{},"HW_TIME_CONTEXT structure"]},{"entry":[{},"at the same time it reads the"]},{"entry":[{},"hardware's PTS value. This"]},{"entry":[{},"additional step allows the caller to"]},{"entry":[{},"correlate that on-board clock time"]},{"entry":[{},"to a certain system time."]},{"entry":["TIME_READ_ONBOARD_CLOCK","Indicates that the minidriver should"]},{"entry":[{},"return the current value of the"]},{"entry":[{},"master clock in the Time field of"]},{"entry":[{},"the HW_TIME_CONTEXT"]},{"entry":[{},"structure, in 100 ns units. This"]},{"entry":[{},"function will only be passed in if"]},{"entry":[{},"the CanReadOnboardClock"]},{"entry":[{},"Boolean below is set. The"]},{"entry":[{},"minidriver should also return the"]},{"entry":[{},"current system time (retrieved"]},{"entry":[{},"through KeQueryPerformanceCounter)"]},{"entry":[{},"in the SystemTime field of the"]},{"entry":[{},"HW_TIME_CONTEXT structure"]},{"entry":[{},"at the same time it reads the on-"]},{"entry":[{},"board clock value. This additional"]},{"entry":[{},"step allows the caller to correlate"]},{"entry":[{},"that on-board clock time to a"]},{"entry":[{},"certain system time. This function"]},{"entry":[{},"is used for rate-matching tunable"]},{"entry":[{},"clocks. A minidriver that has a"]},{"entry":[{},"slave clock can read the time value"]},{"entry":[{},"of the master clock, and tune or set"]},{"entry":[{},"the slave clock to this value."]},{"entry":["TIME_SET_ONBOARD_CLOCK","Indicates that the minidriver should"]},{"entry":[{},"set or tune the current value of the"]},{"entry":[{},"clock. The correct value for the"]},{"entry":[{},"clock is set in the Time field of the"]},{"entry":[{},"HW_TIME_CONTEXT structure,"]},{"entry":[{},"in 100 ns units. This function will"]},{"entry":[{},"only be passed in if the"]},{"entry":[{},"CanSetOnboardClock Boolean is"]},{"entry":[{},"set. The current system time"]},{"entry":[{},"(retrieved through"]},{"entry":[{},"KeQueryPerformanceCounter) is"]},{"entry":[{},"also set in the SystemTime field of"]},{"entry":[{},"the HW_TIME_CONTEXT"]},{"entry":[{},"structure at the same time it reads"]},{"entry":[{},"the on-board clock value. This"]},{"entry":[{},"additional step allows the"]},{"entry":[{},"minidriver to correlate that onboard"]},{"entry":[{},"clock time in the Time field to a"]},{"entry":[{},"certain system time."]},{"entry":"Time"},{"entry":"System Time"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Stream Request Block","This section describes the format of the SRB. The SRB contains information necessary for the minidriver  to process data and control requests. There are SRB commands specific to the driver  and adapter , and SRB commands specific to each stream supported by the adapter .","1. PORT_CONFIGURATION_INFORMATION","The PORT_CONFIGURATION_INFORMATION structure contains the configuration information necessary to initialize the adapter.",{"@attributes":{"id":"p-0366","num":"0372"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _PORT_CONFIGURATION_INFORMATION {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003ULONG","SizeOfThisPacket,"]},{"entry":[{},"\u2003PVOID","HwDeviceExtension;"]},{"entry":[{},"\u2003PDEVICE_OBJECT","ClassDeviceObject;"]},{"entry":[{},"\u2003PDEVICEOBJECT","PhysicalDeviceObject;"]},{"entry":[{},"\u2003ULONG","ystemloBusNumber,"]},{"entry":[{},"\u2003INTERFACE_TYPE","AdapterInterfaceType;"]},{"entry":[{},"\u2003ULONG","BusInterruptlevel;"]},{"entry":[{},"\u2003ULONG","BusInterruptVector,"]},{"entry":[{},"\u2003KINTERRUPT _MODE","InterruptMode;"]},{"entry":[{},"\u2003ULONG","DmaChannel;"]},{"entry":[{},"\u2003ULONG","NumberOfAccessRanges;"]},{"entry":[{},"\u2003PACCESS_RANGE","AccessRanges;"]},{"entry":[{},"\u2003ULONG","StreamDescriptorSize;"]},{"entry":[{},"\u2003PIRP","Irp;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} PORT_CONFIGURATION_INFORMATION,"]},{"entry":[{},"PPORT_CONFIGURATION_INFORMATION;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"Indicates the length of the PORT_CONFIGURATION_INFORMATION structure as returned by sizeof. Since this structure may grow in later releases, the adapter minidriver should check that the length is greater than or equal to the length expected. This field is always initialized.","HwDeviceExtension","Contains the adapter minidriver's adapter data storage. This storage is initialized to zero before this call is made.","ClassDeviceObject","Contains the device object associated with this adapter. The minidriver can save this pointer in its device extension if it needs to call system services.","PhysicalDeviceObject","The device object for the physical device and typically is not used by the minidriver.","SystemloBusNumber","Indicates that the system I\/O bus number on which the adapter resides. This number is zero for machines with only one I\/O bus. This field is always initialized by the class driver.","AdapterInterfaceType","Indicates the type of the bus being initialized, such as EISA or PCI. Supported types include:\n\n","Indicates the bus interrupt request level. This level corresponds to the IRQL on PCI, ISA, and MCA buses. The uninitialized value is zero.","BusInterruptVector","Indicates the bus vector returned by the adapter. This is used for systems that have I\/O buses that use interrupt vectors. For ISA, MCA, and EISA I\/O buses, this field is unused. The uninitialized value is zero.","InterruptMode","Indicates whether this adapter uses level or latched type interrupts. This value is always initialized.","DmaChannel","Indicates the DMA channel used by the adapter. The un initialized value is 0XFFFFFFFF. This field is normally only used for ISA DMA Bus master cards.","NumberOfAccessRanges","Indicates the number of elements in the AccessRanges array.","AccessRanges","Supplies a pointer to an array of ACCESS_RANGE structures. The number of elements is indicated by the NumberOfAccessRanges field. The driver should fill in each structure for the adapter. The uninitialized values for the structures are zero.","AccessRanges will be NULL if NumberOfAccessRanges is zero. See Comments for information on the structure used to define access ranges.","StreamDescriptorSize","Contains the size of the stream descriptor structure that is filled in by the minidriver in the SRB_GET_STREAM_INFO command (defined later in this document). The minidriver should fill in this size to be equal to the size of the HW_STREAM_HEADER Structure plus the sizes of each of the variable length HW_STREAM_INFORMATION structures needed by the minidriver.","Irp","Points to the PNP IRP for the start and typically is not used by the minidriver.","Comments","The ACCESS_RANGE structure is used to define access ranges for the AccessRanges value. These ranges indicate to the system which ports and memory address are being used by the card.",{"@attributes":{"id":"p-0383","num":"0401"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct_ACCESS_RANGE {"]},{"entry":[{},"\u2003STREAM_PHYSICAL_ADDRESS RangeStart;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003UIONG","RangeLength;"]},{"entry":[{},"\u2003BOOLEAN","RangeInMemory;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} ACCESS_RANGE, *PACCESS_RANGE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"Indicates the starting memory address or port number.","RangeLength","Indicates the length in bytes or number of ports of the range. This value should indicate the range actually decoded by the adapter.","RangeInMemory","Indicates the range is in memory, rather than in 110 space.","2. HW_STREAM_OBJECT","The HW_STREAM_OBJECT is the structure created when an SRB request is received.",{"@attributes":{"id":"p-0388","num":"0406"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef \u2003\u2003struct_HW_STREAM_OBJECT {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003ULONG","SizeOfThisPacket;"]},{"entry":[{},"\u2003LONG","StreamNumber,"]},{"entry":[{},"\u2003PVOID","HwStreamExtension;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003PHW_RECEIVE_STREAM_DATA_SRB ReceiveDataPacket;"]},{"entry":[{},"\u2003PHW _RECEIVE_STREAM_CONTROL_SRB"]},{"entry":[{},"\u2003ReceiveControlPacket;"]},{"entry":[{},"\u2003HW_CLOCL_OBJECT HwClockObject;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003BOOLEAN","Dma;"]},{"entry":[{},"\u2003BOOLEAN","Plo;"]},{"entry":[{},"\u2003PVOID","\u2003\u2003HwDeviceExtension;"]},{"entry":[{},"\u2003ULONG","\u2003\u2003StreamHeaderMediaSpecific;"]},{"entry":[{},"\u2003ULONG","\u2003\u2003StreamHeaderWorkspace;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} HW_STREAM_OBJECT. .PHW_STREAM_OBJECT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"Indicates the size of this packet Filled in by the stream class. The minidriver should verify that the size of the structure it expects is less than or equal to the value in this element.","StreamNumber","Indicates the number of the stream to be opened. The number corresponds with the location of the stream's HW_STREAM_INFORMATION structure in the information returned by SRB_GET_STREAM_INFO defined earlier.","HwStreamExtension","Points to the minidriver's stream extension workspace, and is zeroinitialized.","ReceiveDataPacket","The minidriver fills in the vector to its HW_RECEIVE_STREAM_DATA_SRB routine as defined in this document.","ReceiveControlPacket","The minidriver fills in the vector to its HW_RECEIVE_STREAM_CONTROL_SRB routine as defined in this document.","HwClockObject","The clock object, defined in this document, contains information required for data synchronization.","Dma","If set to TRUE, indicates the minidriver will use DMA to transfer data directly from the data packets for this stream type. If the device has to double-buffer data into a DMA buffer, but does not actually use DMA from or to the user buffers directly, this should be set to FALSE. Note that both the DMA and PIO values can be set, if necessary.","Pio","Indicates that the minidriver will use PIO to transfer data for this stream type. This means that the processor needs to touch some or all of the data in the data packets to transfer it to the device. Note that both the DMA and PIO values can be set, if necessary.","HwDeviceExtension","Points to the minidriver's device extension.","StreamHeaderMediaSpecific","Contains the size of media-specific, per-stream header expansion.","StreamHeaderWorkspace","Size of per-stream header workspace.","3. HW_STREAM_REQUEST_BLOCK","The HW_STREAM_REQUEST_BLOCK structure is the basis for all SRBs. The structure contains information necessary for the minidriver to process data and control requests. There are SRB commands specific to the adapter and commands specific to each stream supported by the adapter.",{"@attributes":{"id":"p-0401","num":"0419"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _HW_STREAM_REQUEST_BLOCK {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ULONG","SizeOfThisPacket;"]},{"entry":[{},"SRB_COMMAND","Command;"]},{"entry":[{},"NTSTATUS","Status;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PHW_STREAM_OBJECT","Stream Object;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PVOID","HwDeviceExtension;"]},{"entry":[{},"PVOID","SRBExtension;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"union - CommandData {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PKSSTREAM_HEADER","Data BufferArray,"]},{"entry":[{},"PHW_STREAM_DESCRIPTOR","StreamBuffer,"]},{"entry":[{},"KSSTATE","StreamState;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PSTREAM_TIME_REFERENCE","TimeReference;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PSTREAM_PROPERTY _DESCRIPTOR PropertyInfo;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PKSDATAFORMAT","OpenFormat;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"struct _PORT _CONAGURATION_INFORMATION *ConfigInfo;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HANDLE","MasterClockHandle;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DEVICE_POWER_STATE DeviceState;"]},{"entry":[{},"} CommandData;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ULONG","NumberOfBuffers;"]},{"entry":[{},"ULONG","TimeoutCounter,"]},{"entry":[{},"ULONG","TimeoutOriginal;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"struct _HW_STREAM_REQUEST_BLOCK *NextSRB;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PIRP","Irp;"]},{"entry":[{},"ULONG","Flags;"]},{"entry":[{},"PVOID","HwInstanceExtension;"]},{"entry":[{},"union {"]},{"entry":[{},"ULONG","NumberOfBytesToTransfer;"]},{"entry":[{},"ULONG","ActualBytesTransferred;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"};"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ULONG","Reserved;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PKSSCATTER_GATHER ScatterGatherBuffer"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ULONG","NumberOfPhysicalPages;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} HW _STREAM_REQUEST _BLOCK,"},{"entry":"*PHW _STREAM_REQUEST _BLOCK;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Contains the size of the SRB.","Command","Contains the SRB command to be performed. See SRB Commands defined in the following section.","Status","Contains the status of the completing SRB.","StreamObject","Pointer to the stream object for this request. Only valid for stream-specific requests.","HwDeviceExtension","Points to the minidriver's device extension.","SRBExtension","Pointer to the minidriver's per-request workspace. Not zero initialized.","CommandData","Command-specific data. The fields in Command Data are as follows.",{"@attributes":{"id":"p-0409","num":"0427"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Field","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DataBufferArray","Pointer to the data descriptor for"]},{"entry":[{},"SRB_READ_or SRB_WRITE_DATA."]},{"entry":["StreamBuffer","Pointer to the stream descriptor for"]},{"entry":[{},"SRB_GET_STREAM_INFO."]},{"entry":["StreamState","Pointer to the stream state for SRB_GET_or"]},{"entry":[{},"SRB_SET_DEVICE_STATE."]},{"entry":["TimeReference","Pointer to the time structure for"]},{"entry":[{},"SRB_GET_or"]},{"entry":[{},"SRB_SET_ONBOARD_CLOCK."]},{"entry":["PropertyInfo","Pointer to the property descriptor for"]},{"entry":[{},"SRB_GET_or SRB_SET_PROPERTY."]},{"entry":["OpenFormat","Pointer to the requested format for"]},{"entry":[{},"SRB_OPEN_STREAM and"]},{"entry":[{},"SRB_PROPOSE_DATA_FORMAT."]},{"entry":["ConfigInfo","Pointer to the"]},{"entry":[{},"PORT_CONFIGURATION_INFORMATION"]},{"entry":[{},"structure for"]},{"entry":[{},"SRB_INITIALIZE_DEVICE."]},{"entry":["MasterClockHandle","Indicates the master clock handle for"]},{"entry":[{},"SRB_OPEN_MASTER_CLOCK or"]},{"entry":[{},"SRB_INDICATE_MASTER_CLOCK."]},{"entry":["DeviceState","Indicates power state."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Indicates the number of KSSTREAM_HEADER elements pointed to by the DataBufferArray field.","TimeoutCounter","Indicates the number of seconds until the request is timed out by the class driver. The class driver sets both the TimeoutCounter and the TimeoutOriginal to nonzero values when the request is received by the minidriver, and then begins counting down the TimeoutCounter until it reaches zero. A setting of zero indicates that the request is not timed.","TimeoutOriginal","Indicates the original setting of TimeoutCounter in seconds.","NextSRB","Contains queue link field for the minidriver. Always set to zero by the class driver.","Irp","Paints to the original IRP for the request. Most minidrivers need not look at the IRP.","Flags","Contains flag definitions for the SRB. The following flags are provided.",{"@attributes":{"id":"p-0416","num":"0434"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Flag","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SRB_HW_FLAGS_STREAM_REQUEST","Indicates that request"]},{"entry":[{},"is for a stream, rather than"]},{"entry":[{},"for the device."]},{"entry":["SRB_HW_FLAGS_DATA_TRANSFER","Indicates that request is"]},{"entry":[{},"for data, rather than"]},{"entry":[{},"for control."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Points to the minidriver's instance extension, if applicable.","NumberOfBytesToTransfer","Indicates the total number of bytes to transfer for SRB_READ_DATA or SRB_WRITE_DATA.","ActualBytesTransferred","Indicates the actual number of bytes transferred.","ScatterGatherBuffer","Indicates a buffer pointing to an array of scatter-gather elements. This array of elements can be used by the minidriver to use DMA directly to or from host memory. Note that no locking, probing, mapping, or flushing of these physical addresses is necessary; all these operations are performed by the stream class. See the Comments section for information on the structure used for each element in the scatter-gather array.","NumberOfPhysicalPages","Contains the number of scatter-gather elements pointed to by the ScatterGatherBuffer pointer.","Comments","The fields PhysicalScatterGatherList and NumberOfPhysicalElements are filled in only if the minidriver has indicated DMA support in the STREAM_OBJECT structure.","Each element in the scatter-gather array has the following format:",{"@attributes":{"id":"p-0424","num":"0442"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct {"]},{"entry":[{},"\u2003PHYSICAL_ADDRESS PhysicalAddress;"]},{"entry":[{},"\u2003ULONG Length;"]},{"entry":[{},"} KSSCATTER_GATHER, *PKSSCATTER_GATHER;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Contains the physical address of this segment.","Length","Contains the length of the segment.",{"@attributes":{"id":"h-0142","num":"0000"},"u":"SRB Command Codes for the Adapter"},"SRB command codes are used in the HW_STREAM_REQUEST_BLOCK and are used to provide information to the class drivers. SRB commands can be either stream specific or device\/instance specific.","1. SRB_INITIALIZE_DEVICE","The SRB_INITIAIIZE_DEVICE command is sent by the class driver when an adapter needs to be initialized. The PORT_CONFIGURATION_INFORMATION structure, which contains parameters necessary to initialize the adapter, is passed in through the CommandData. ConfigInfo field of the SRB by the class driver.","The PORT_CONFIGURATION_INFORMATION structure is partially initialized by the class driver before the SRB_INITIALIZE_DEVICE function is called. The specific fields initialized depend on the adapter mini driver and the information available to the class driver. All uninitialized fields are set to a well-known value as defined in the following text. All relevant fields should be updated by the adapter minidriver.","The fields required to find and set up the adapter (IRQ, port address, and so on) must have been filled in by the class driver. If not, the minidriver should return with STATUS_NO_SUCH_DEVICE.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0432","num":"0450"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates that a host adapter was"]},{"entry":[{},"found and the configuration"]},{"entry":[{},"information was successfully"]},{"entry":[{},"determined."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a host adapter"]},{"entry":[{},"was found, but there was an error in"]},{"entry":[{},"obtaining the configuration"]},{"entry":[{},"information. If possible, such an"]},{"entry":[{},"error should be logged."]},{"entry":["STATUS_NO_SUCH_DEVICE","Indicates that the supplied"]},{"entry":[{},"configuration information was"]},{"entry":[{},"invalid."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_UNINITIALIZE_DEVICE command is sent by the class driver when the adapter needs to be uninitialized. The minidriver should deallocate any system resources it allocated, aside from those allocated through the class driver (such as the uncached extension, IRQs, and so on) that will be automatically deallocated by the class driver. The minidriver should permanently disable adapter interrupts on this call, if possible.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0435","num":"0453"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful"]},{"entry":[{},"completion of"]},{"entry":[{},"the command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the"]},{"entry":[{},"function is not"]},{"entry":[{},"supported by"]},{"entry":[{},"the minidriver."]},{"entry":["STATUS_ADAPTER_HARDWARE_ERROR","Indicates that the"]},{"entry":[{},"minidriver cannot"]},{"entry":[{},"uninitialize at this"]},{"entry":[{},"time."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_GET_STREAM_INFO command is sent by the class driver to retrieve information about the streams supported by the minidriver's hardware. When the minidriver receives this command, the minidriver builds the HW_STREAM_HEADER structure, followed by one or more HW_STREAM_INFORMATION structures, in the buffer provided by the class driver and pointed to by CommandData.StreamBuffer. The size of this buffer is indicated by the minidriver in the StreamDescriptorSize field in the PORT_CONFIGURATION_INFORMATION structure.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0438","num":"0456"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of"]},{"entry":[{},"the command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware failure"]},{"entry":[{},"occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_OPEN_STREAM command is sent by the class driver to open a stream. The stream to be opened is specified by the HW_STREAM_OBJECT, which is pointed to by the StreamObject field in the SRB. The CommandData.OpenFormat field may point to additional format information about the stream being opened.","When the minidriver receives the SRB_OPEN_STREAM command, the minidriver should determine if the specified stream is able to be opened at this time. If the stream can be opened, the HW_STREAM_OBJECT structure is updated by the minidriver, and STATUS_SUCCESS is returned. If the number of instances specified as stream are already opened, or the hardware resources to open this stream are otherwise unavailable, the minidriver should return an appropriate error status.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0442","num":"0460"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion"]},{"entry":[{},"of the command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_TOO_MANY_NODES","Indicates that there"]},{"entry":[{},"are not enough resources to"]},{"entry":[{},"open this stream."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_CLOSE_STREAM command is sent by the class driver to close a a previously opened stream. The stream to be closed is specified by the HW_STREAM_OBJECT structure referenced by the StreamObject field in the SRB. If the stream is successfully closed by the minidriver, STATUS_SUCCESS should be returned. Otherwise, an appropriate error status should be returned.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0445","num":"0463"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_OPEN_DEVICE_INSTANCE command is sent by the class driver to open an instance of the adapter. Most adapters do not support instancing, so the InstanceExtensionSize field in the HW_INITIALIZATION_DATA structure should be set to zero and should never receive this command.","If the minidriver supports device instancing, this command will be sent by the class driver each time a new instance of the adapter is opened. For example, a DSP decoder that can allocate n number of instances of the streams specified. The HwInstanceExtension field in the SRB should then be set to the minidriver's per-instance workspace by the class driver.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0449","num":"0467"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion"]},{"entry":[{},"of the command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_TOO_MANY_NODES","Indicates that there are not enough"]},{"entry":[{},"resources to open this stream."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_CLOSE_DEVICE_INSTANCE command is sent by the class driver to close a previously opened instance of the adapter.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0452","num":"0470"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_GET_DEVICE_PROPERTY command controls the changing of property values for the device. For more information on property sets, see Kernel Mode Streaming Reference in the WDM DDK Documentation.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0455","num":"0473"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_SET_DEVICE_PROPERTY command controls the changing of property values for the device. For more information on property sets, see Kernel-Mode Streaming Reference in the WDM DDK Documentation.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0458","num":"0476"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_CHANGE_POWER_STATE command is used to change the power state.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0461","num":"0479"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred and low power"]},{"entry":[{},"cannot be invoked."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_UNKNOWN_DEVICE_COMMAND command indicates that the IRP function is unknown to the class driver.","12. SRB_PAGING_OUT_DRIVER","The SRB_PAGING_OUT_DRIVER command indicates that the driver is to be paged out. It is only sent if enabled in the registry. Adapter interrupts should be disabled and a STATUS_SUCCESS should be returned.","13. SRB_GET_DATA_INTERSECTION","Information on the SRB_GET_DATA_INTERSECTION command is not now provided","Stream-Specific Command Codes","Stream-specific command codes are defined for a previously opened stream. The StreamObject field in the SRB specifies the stream on which to carry out the specified command.","The stream-specific SRB command codes, with underlying structures shown in the topic, are as follows:","1. SRB_READ_DATA","The SRB_READ_DATA command is issued to read one or more blocks of data to or from the specified stream.","The Command Data. DataBufferArray field points to one or more KSSTREAM_HEADER structures as defined in the following text.","The number of KSSTREAM_HEADER structures pointed to by the CommandData. DataBufferArray field is indicated by the NumberOfBuffers field in the SRB.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0471","num":"0489"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that the function is"]},{"entry":[{},"not supported by the minidriver."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_WRITE_DATA command is issued to write one or more blocks of data to or from the specified stream.","The CommandData.DataBufferArray field points to one or more KSSTREAM_HEADER structures as defined in the following text.","The number of KSSTREAM_HEADER structures pointed to by the CommandData.DataBufferArray field is indicated by the NumberOfBuffers field in the SRB.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0476","num":"0494"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_SET_STREAM_STATE command controls the state of the specified stream. The CommandData.StreamState field in the SRB is set by the class driver to one of the following states:",{"@attributes":{"id":"p-0478","num":"0496"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {"]},{"entry":[{},"\u2003KSSTATE_STOP,"]},{"entry":[{},"\u2003KSSTATE_PAUSE,"]},{"entry":[{},"\u2003KSSTATE_RUN"]},{"entry":[{},"} KSSTATE, *PKSSTATE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The minidriver should set the stream to the specified state and return STATUS_SUCCESS if successful. An appropriate error code should be returned if the operation fails.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0481","num":"0499"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_GET_STREAM_PROPERTY command controls the changing of property set values for the stream. For more information on property sets, see Kernel Mode Streaming Reference.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0484","num":"0502"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_SET_STREAM_PROPERTY command controls the changing of property set values for the stream. For more information on property sets, see Kernel Mode Streaming Reference.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0487","num":"0505"},"tables":{"@attributes":{"id":"TABLE-US-00067","num":"00067"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_OPEN_MASTER_CLOCK command indicates that the stream referenced by the stream object in the SRB has been chosen to be the master clock. The HwClockObject in the HW_STREAM_OBJECT must have been filled in correctly for a particular stream to be chosen as the master clock.","The CommandData.MasterClockHandle field points to the handle of the master clock, which the minidriver should retain.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0491","num":"0509"},"tables":{"@attributes":{"id":"TABLE-US-00068","num":"00068"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_CLOSE_MASTER_CLOCK command indicates that the stream referenced by the stream object in the SRB is no longer the master clock.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0494","num":"0512"},"tables":{"@attributes":{"id":"TABLE-US-00069","num":"00069"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_INDICATE_MASTER_CLOCK command gives the handle to the master clock to slave streams. If the handle is zero, this stream is treated as free running by the minidriver. Also, until the minidriver receives this function for a particular stream, the minidriver should assume that the stream is free running. The minidriver can use this handle to read the current master clock value using StreamClassQueryMasterClock, defined in this document. Note that if the handle passed into this function for a slave pin is the same as the handle passed into the minidriver through SRB_OPEN_MASTER_ClOCK, the minidriver can read the time from the master clock directly since it controls the master and the slave. This is not necessary, but is an optimization.","The CommandData. MasterClockHandle field points to the handle for the master clock, which the minidriver should retain. If this handle is zero, this indicates to the minidriver that this stream is now free running and cannot slave to a master clock.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0498","num":"0516"},"tables":{"@attributes":{"id":"TABLE-US-00070","num":"00070"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS_SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The SRB_PROPOSE_DATA_FORMAT command queries the minidriver to determine if the minidriver can change the format of a particular stream. If the minidriver is able to switch the stream to the specified format. STATUS_SUCCESS is returned. Note that this function only proposes a new format, but does not change it.","The CommandData.OpenFormat passes the format to validate.","If the minidriver is able to accept the new format, the class driver at some later time may send the minidriver a format change, which is indicated by an OptionsFlags flag in a KSSTREAM_HEADER structure.","Return Codes","The following codes are provided.",{"@attributes":{"id":"p-0503","num":"0521"},"tables":{"@attributes":{"id":"TABLE-US-00071","num":"00071"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS SUCCESS","Indicates successful completion of the"]},{"entry":[{},"command."]},{"entry":["STATUS_IO_DEVICE_ERROR","Indicates that the function is not"]},{"entry":[{},"supported by the minidriver."]},{"entry":["STATUS_NOT IMPLEMENTED","Indicates that the proposed format is"]},{"entry":[{},"not supported by the minidriver."]},{"entry":["STATUS_NOT SUPPORTED","Indicates that a hardware"]},{"entry":[{},"failure occurred."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Information to be provided in a future draft.","11. SRB_UNKNOWN_STREAM_COMMAND","The SRB_UNKNOWN_STREAM_COMMAND command indicates that the IRP function is unknown to the class driver. The function is then passed down the next driver in the stack.","12. SRB_PROPOSE STREAM_RATE","Information not now provided."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following description taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
