---
title: Method and system for versioned file system using structured data representations
abstract: A versioned file system comprises a set of structured data representations. At a first time, an interface creates and exports to a data store a first structured data representation corresponding to a first version of a local file system. The first structured data representation is an XML tree having a root element, one or more directory elements associated with the root element, and one or more file elements associated with a given directory element. Upon a change within the file system (e.g., file creation, file deletion, file modification, directory creation, directory deletion and directory modification), the interface creates and exports a second structured data representation corresponding to a second version of the file system. The second structured data representation differs from the first structured data representation up to and including the root element of the second structured data representation. The data store may comprise a cloud storage service provider.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08566362&OS=08566362&RS=08566362
owner: Nasuni Corporation
number: 08566362
owner_city: Natick
owner_country: US
publication_date: 20090611
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This application is based on Ser. No. 61\/146,978, filed Jan. 23, 2009.","This application includes subject matter that is protected by copyright.","1. Technical Field","This application relates generally to data storage.","2. Background of the Related Art","In data centers across the world data is growing at an alarming rate. With digitization of content the paperwork of the world is turning into data bits that must be saved, protected and managed. For example, businesses that once had thick physical files and cabinets full of paper now have terabytes of data increasing at a 50% compound annual growth rate (CAGR). What was once a single MRI image is now 5 gigabytes of data for a medical firm to store and protect. The explosive growth in data is felt at all levels from the consumers to the large enterprise. There are different types of data and the invention focuses specifically on the growth of unstructured files, considered to be about 60% of the overall data, as opposed to structured data such as that found in databases, block storage devices and the like.","Unstructured file data is typically stored in local file systems or on network attached file systems (NAS). NAS devices can be built from commercially or freely available software (for example, Windows Server 2003 and OpenFiler). NAS devices also can be provided in physical or virtual (i.e. a VMWare image) forms. NAS devices have flexibility in connecting to directly-attached and storage area network (SAN) attached storage to provide for their storage needs.","The storage industry also has the introduction and growth of storage service providers (SSPs). In recent years, scalable distributed storage devices using commodity hardware have been created by a number of companies. These systems provide a number of basic and advanced attributes including capacity scalability, self healing, performance scaling, duplicate elimination, simple interfaces, etc. Some of these systems were designed and intended for large enterprises to store their fixed-content (archive) information internally, but some of these systems are being connected to the Internet to provide generic storage services. For example, Amazon's S3 service is the leading service of this nature and is being used by many Web 2.0 companies to store and scale their data capacity needs without having to provide their own storage. Storage service providers are essentially utility companies for storage and bill their customers based on the amount of data stored within their service. Amazon's S3 service has been growing rapidly showing the demand for storage provided as a service.","It is also known in the prior art to provide backup services that replicate data to services provided by the Internet. These services use software installed on a client to send data to an Internet service in a proprietary format. These are special purpose SSPs. In addition to these backup offerings, some companies are now providing generic unstructured file services to allow data to be copied to the SSP. These services either provide direct access to the SSP or synchronize files to the SSP. Each one supports a single target SSP and is generally provided as a software application or software service within the computer operating system. Often, both these types of remote storage include provisions for versioning (keeping older copies) of the data and a method to access the data online as well as locally.","An interface between an existing local file system and a data store (e.g., a \u201cwrite-once\u201d store) provides a \u201cversioned\u201d file system. The state of the local file system at a given point in time can be determined using the versioned file system.","Preferably, the versioned file system comprises a set of structured data representations, such as XML. In a representative embodiment, at a first time, the interface creates and exports to the data store a first structured data representation corresponding to a first version of the local file system. The first structured data representation is an XML tree having a root element, one or more directory elements associated with the root element, and one or more file elements associated with a given directory element. Upon a change within the file system (e.g., file creation, file deletion, file modification, directory creation, directory deletion and directory modification), the interface creates and exports a second structured data representation corresponding to a second version of the file system. The second structured data representation differs from the first structured data representation up to and including the root element of the second structured data representation. Thus, the second structured data representation differs from the first structured data representation in one or more (but not necessarily all) parent elements with respect to the structured data element in which the change within the file system occurred. The interface continues to generate and export structured data representations to the data store, preferably at given \u201csnapshot\u201d times when changes within the file system have occurred. The data store comprises any type of back-end storage device, system or architecture. In one embodiment, the data store comprises one or more cloud storage service providers. As necessary, a given structured data representation is then used to retrieve an associated version of the file system. In this manner, the versioned file system only requires write-once behavior from the data store to preserve its complete state at any point-in-time. This solution circumvents the problem of a lack of reliable atomic object replacement in object repositories.","As noted above, the interface as described herein is not limited for use with a particular type of back-end data store. Indeed, when the interface is positioned in \u201cfront\u201d of a generic data store, the interface has the effect of turning that data store into a \u201cversioned file system\u201d (\u201cVFS\u201d). The VFS is a construct that is distinct from the interface itself, and the VFS continues to exist irrespective of the state or status of the interface (from which it may have been generated). The VFS can be accessed and managed separately from the back-end data store, or as a component of that data store.","The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","102","102","104","102"]},"As will also be seen below, the interface  provides for a file system that has complete data integrity to the cloud without requiring global locks. In particular, this solution circumvents the problem of a lack of reliable atomic object replacement in cloud-based object repositories.","The interface  as described herein is not limited for use with a particular type of back-end data store. Indeed, as will be seen, when the interface is positioned in \u201cfront\u201d of a data store, the interface has the effect of turning whatever is behind it into a \u201cversioned file system\u201d (\u201cVFS\u201d). The VFS is a construct that is distinct from the interface itself, and the VFS continues to exist irrespective of the state or status of the interface (from which it may have been generated). Moreover, the VFS is self-describing, and it can be accessed and managed separately from the back-end data store, or as a component of that data store. Thus, the VFS (comprising a set of structured data representations) is location-independent.","In one embodiment, the VFS resides within a single SSP although, as noted above, this is not a limitation. In another embodiment, a first portion of the VFS resides in a first SSP, while a second portion resides in a second SSP. Generalizing, any given VFS portion may reside in any given data store (regardless of type), and multiple VFS portions may reside across multiple data store(s). The VFS may reside in an \u201cinternal\u201d storage cloud (i.e. a storage system internal to an enterprise), an external storage cloud, or some combination thereof.","The interface  may be implemented as a machine. Thus, for example, typically the interface  is a rack-mounted server appliance comprising hardware and software. The hardware typically includes one or more processors that execute software in the form of program instructions that are otherwise stored in computer memory to comprise a \u201cspecial purpose\u201d machine for carrying out the functionality described herein. Alternatively, the interface is implemented as a virtual machine or appliance (e.g., via VMWare, or the like), as software executing in a server, or as software executing on the native hardware resources of the local file system. One of ordinary skill in the art will appreciate that the interface  serves to transform the data representing the local file system (a physical construct) into another form, namely, a versioned file system comprising a series of structured data representations that are useful to reconstruct the local file system to any point-in-time. Although not meant to be limiting, preferably each structured data representation is an XML document (or document fragment). As is well-known, extensible markup language (XML) facilitates the exchange of information in a tree structure. An XML document typically contains a single root element (or a root element that points to one or more other root elements). Each element has a name, a set of attributes, and a value consisting of character data, and a set of child elements. The interpretation of the information conveyed in an element is derived by evaluating its name, attributes, value and position in the document.","The interface  generates and exports to the write-once data store a series of structured data representations (e.g., XML documents) that together comprise the versioned file system. The data representations are stored in the data store. Preferably, the XML representations are encrypted before export to the data store. The transport may be performed using known techniques. In particular, REST (Representational State Transfer) is a lightweight XML-based protocol commonly used for exchanging structured data and type information on the Web. Another such protocol is Simple Object Access Protocol (SOAP). Using REST, SOAP, or some combination thereof, XML-based messages are exchanged over a computer network, normally using HTTP (Hypertext Transfer Protocol) or the like. Transport layer security mechanisms, such as HTTP over TLS (Transport Layer Security), may be used to secure messages between two adjacent nodes. An XML document and\/or a given element or object therein is addressable via a Uniform Resource Identifier (URI). Familiarity with these technologies and standards is presumed.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","202","200","206","202","204","208","210"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["306","300","308","302","310","304","312","314","316"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","402","402","404","406","400","402","404","408","406","410","412","408","410","414","412","416","418","418","420"]},"As noted above, the components of the interface shown in  may be distinct or integrated. Thus, the specific interface architecture shown in this drawing is merely illustrative and not meant to be taken by way of limitation.","The interface shown in  may be implemented as a standalone system, or as a managed service. In the latter case, the system executes in an end user (local file system) environment. A managed service provider provides the system (and the versioned file system service), preferably on a fee or subscription basis, and the data store (the cloud) typically is provided by one or more third party service providers. The versioned file system may have its own associated object-based data store, but this is not a requirement, as its main operation is to generate and manage the structured data representations that comprise the versioned file system. The cloud preferably is used just to store the structured data representations, preferably in a write-once manner, although the \u201cversioned file system\u201d as described herein may be used with any back-end data store.","As described above, the file system agent is capable of completely recovering from the cloud (or other store) the state of the native file system and providing immediate file system access (once FSA metadata is recovered). The FSA can also recover to any point-in-time for the whole file system, a directory and all its contents, a single file, or a piece of a file. These and other advantages are provided by the \u201cversioned file system\u201d of this disclosure, as it now described in more detail below.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 5","b":["500","502","504"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 6","FIG. 5"],"b":["502","602","600","604"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 6","FIG. 7","FIG. 8"],"b":["700","804","808"]},"Moreover, as noted, it is possible but not required that a new version be created at the time of the actual change in the local file system; typically, the new version is created after a \u201csnapshot\u201d of the local file system is taken, and a number of change events may occur during a given snapshot period.  illustrates this approach. As seen in this drawing, an FSA instance preferably aggregates all of the changes to the local file system in two ways: delta frames , and reference frames . The delta frames  control the number (and size) of the objects that need to be stored in cloud storage. As noted above, preferably every local file system event is recorded by the FSA instance as a change event . As noted, new inodes, directories and files trigger corresponding new entities (created by FSA) in the cloud; however, preferably modifications to existing structures create change events that are aggregated by FSA into a single new entity, the delta frame . A delta frame  starts with a new root that represents the current state of the file system. Preferably, the FSA instance compiles the delta frame information such that each of the new entry points (i.e. any modifications to the previous version) to c-nodes, directories and files are represented as new versions of the data structures plus pointers to the old structures. To reconstruct the current state of a local file system, an FSA client only has to walk a tree for any version to see all the correct items in the tree. Reference frames  are also compiled by FSA and contain an aggregation of the previous reference frame plus all the intervening delta frames.","A given reference frame  may be thought of as an entire copy with no references to previous versions, while a delta frame  may be thought of as including pointers to older versions. In other words, a delta frame logically is a combination of a current version and one or more prior versions. Each reference frame may be considered a complete file system from a tree-walk perspective. This means that a walk of the tree, by itself, is all that is required to restore the file system to its associated state or point-in-time (as represented by the tree). For storage purposes, it should also be appreciated that a delta frame only takes the space required for the difference from the previous version, whereas a reference frame takes up the space of the file system. If it is desired to collapse (delete) versions, the system may create an intact reference frame following a string of deleted delta frames.","When it is desired to reconstruct the file system to a point in time (or, more generally, a given state), it is only required to walk (use) a single structured data representation (a tree). In other words, one and only one VFS tree may be used to identify a prior state of the local file system. It is not required to jump across multiple trees for this purpose.","Frames preferably are stored in an event pipe . As will be seen, the event pipe is implemented in a structured data representation as a table of contents (TOC), although this is not a limitation. Preferably, this data structure is held both at the FSA instance and at CCS, as illustrated in . The event pipe (with its entry points into cloud storage) is then the primary means to access all files stored remotely. In particular, one of ordinary skill in the art will appreciate that this is a lightweight data structure that preferably contains only versions of root for the given volume. Although it is desired that CCS be highly available, preferably the \u201cwrites\u201d occur periodically in a transaction safe way as controlled by FSAs. The \u201creads\u201d are only necessary when an FSA copy has failed; therefore, CCS can be run using an ordinary (high-availability) database or file-based back-end. Preferably, the mix of delta and reference frames in the event pipe is chosen to balance storage and bandwidth utilization against a practical recovery time for FSA to create a new local file system instance. The composition of the event pipe can also be set according to a configurable policy. For instance, users may choose to keep only so many versions or versions dating back to a specific date. If desired, a rotation schedule can be specified at CCS such that, for instance, deltas are kept daily for a month and then rolled into a monthly reference frame.","The following section illustrates how the structured data representations are exported to the cloud and how the interface propagates changes to root as has been described generally above. In particular,  illustrates a simple directory tree being pushed to the cloud, and  illustrates the new version of that tree following several changes in the local file system. The original directory tree is described by the data structure in .","The following discussion refers to a set of structured data representations such as XML documents and document fragments. In these examples, the names used are merely representative, and they are merely object references that typically are not parsed by the system. As noted above, preferably the data structures shown in these examples are encrypted to the cloud, although the information is shown here in the clear for illustration purposes. The handle names typically have no relation to the actual file names or content. The handle names in the XML preferably are prefixed with a length component. Thus, an XML handle might be of the form \u201c16uni1262054964.dm\u201d while the corresponding cloud handle might be of the form \u201cuni262054964.dm\u201d. Also, for items other than the table of contents (TOC), the path and version elements in the XML are informative and need not be used by the system. The \u201cpath\u201d typically represents the originating path (in the local file system) when the item was last updated. The \u201cversion\u201d typically represents the version of root at the time the item was last updated. The table of contents (TOC) is a table at the head of every version; preferably, the TOC contains references to all versions.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIGS. 14-19","FIG. 11"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 14","FIG. 13"],"b":"1400"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 18"},"Thus, for example, consider the file \u201cIMG0989.jpg,\u201d which has a full path of \u201c\/people\/IMG-0989jpg.\u201d  illustrates the manifest for this file, which has a handle \u201cuni610714473.fm\u201d associated therewith. The file manifests point to file chunks. Thus, for example, the file \u201c\/people\/IMG0989.jpg\u201d is re-assembled by reading the file chunks and writing them to an output file \u201c\/people\/IMG0989.jpg\u201d at the identified offsets and lengths.","A file version may be comprised of new and old chunks. For instance, a version 2 of a file may have some chunks from version 1 and some from version 2, as in the above example. The FSA preferably implements chunking (with chunks at a configurable size) to obviate copying the entire file system each time a new version is created. A version may be purged as desired to reclaim storage provided the remaining versions do not depend on it.","The above structured data representations are exported to the cloud as a \u201cfirst structured data representation\u201d and they represent a first version of the local file system. Generalizing, the versioned file system thus is a set of structured data (e.g., XML) objects.","The handles are implemented in any convenient manner, e.g., random strings generated by each FSA instance, as strings that are provided by the data store (or the SSP that manages that data store), as strings that are generated in some convenient manner, such as through use of hash algorithms, or in any other convenient manner. All that is required of the handle is that, within the context of a particular FSA instance, it is unique. In this regard, it should be appreciated that some SSPs provide a user the ability to supply a name for an object to be stored, while other SSPs do not (and provide their own). Thus, the naming conventions should take into consideration these and other naming constraints.","Now, for exemplary purposes only, assume the following change events have occurred during the relevant snapshot period (e.g., every \u201cn\u201d minutes): a new file \u201cIMG0995_add.jpg\u201d is added to the \/people directory, and some bytes in the file \u201cIMG-0989jpg\u201d have been changed. It is now assumed that a snapshot has occurred.  illustrates the new version and its export to the cloud and in particular the changes that are propagated to root in the manner previously described. The details of this process are shown in .","Every snapshot at which anything (e.g., data or metadata) has changed anywhere in the tree preferably causes a new TOC to be created.  is the XML for the new TOC, which includes handle \u201cuni796353396.toc.\u201d Note that in the new TOC both versions of the entire file system are identified, namely: the original version (with the original root manifest pointer), and a new version (with a different root manifest version). The old TOC preferably does not include any value except as a fall-back in the event the new TOC is corrupted.","Thus, as illustrated in , a structured data representation may include an element (the TOC) that includes an entry per version pointing to a root manifest (directory entry) for each version. This means that at the top of the tree the system can see not only the current version of the tree but all prior versions as well. The TOC may become quite large, of course, so preferably it is implemented in a set of associated or linked structures that are referred to as \u201ctoclets,\u201d with the TOC pointing to one or more toclets as needed when the TOC gets above a certain configurable size.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 21"},"The XML for the new root directory chunk is shown in . This chunk includes a handle \u201cuni635353623.dc.\u201d The contents are similar to the prior version of this element except for the \u201c\/people\u201d entry for which there is new directory manifest.","The XML for the subdirectory manifest (for \u201c\/people\u201d) is shown in . This manifest has a handle \u201cuni717992117.dc\u201d and points to a single directory chunk.","That chunk is shown in  and it has a handle \u201cuni717992117.dc\u201d. When comparing  to the earlier version uni1208680209.dc), there are several changes: a new version (2), a new directory manifest and mode information for \u201c\/people\/IMG0898jpg,\u201d and a new directory entry for the new file \u201c\/people\/IMG0995jpg.\u201d",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 25","sub":"\u2014"},"As seen in this example, a first tree ( as shown in ) was written to the cloud. That tree was entirely represented starting with the root directory manifest for that initial version. The tree was then updated (, as shown in ), and it was again entirely represented starting with the root directory manifest for that new version. Reading either tree starting with the root directory manifest yields all the data for that version. The amount of space consumed in the cloud, however, is not twice the original capacity (of a single tree) as there are metadata (e.g., manifests, TOCs, chunks, etc.) in common between the two versions. Preferably, data is never deleted, overwritten or updated, and any version can be retrieved at any time given the latest TOC.","One of ordinary skill in the art will appreciate that the interface described herein provides a primary, local, but preferably non-resident application layer to interface the local file system to the data store. As has been described, the interface caches user data and file system metadata (organized in a unique manner) to the data store (e.g., one or more SSPs), preferably as a service. The metadata provides a level of indirection (from the data), and the VFS enables it to be stored separately from the data that it represents.","As noted above, XML is a preferred format for the structured data representation. XML is a subset of SGML (the Structured Generalized Markup Language). Thus, the structured data representation as used herein may be based on SGML, any variant or subset thereof, on a relational database model, or any other generic data model that provides a defined way to structure, describe, and interchange data.","While the above describes a particular order of operations performed by certain embodiments of the disclosed subject matter, it should be understood that such order is exemplary, as alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic.","While the disclosed subject matter has been described in the context of a method or process, the subject matter also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including an optical disk, a CD-ROM, and a magnetic-optical disk, a read-only memory (ROM), a random access memory (RAM), a magnetic or optical card, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. A computer-readable medium having instructions stored thereon to perform the interface functions is tangible.","A given implementation of the disclosed subject matter is software written in a given programming language that runs on a server on an Intel-based hardware platform running an operating system such as Linux. As noted above, the interface may be implemented as well as a virtual machine or appliance, or in any other tangible manner.","While given components of the system have been described separately, one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions, program sequences, code portions, and the like.","Having described our invention, what we now claim is as follows."],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIGS. 14-19","FIG. 11"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIGS. 20-25","FIG. 12"]}]},"DETDESC":[{},{}]}
