---
title: Predicting candidates using information sources
abstract: Embodiments are configured to provide one or more candidates based in part on an input. In an embodiment, a system includes a prediction engine which can be configured to provide one or more ranked candidates using one or more configurable data sources and/or candidate providers. Each data source can be configured to include a candidate provider to predict and return predicted candidates. The prediction engine can use a predicted candidate to rank and return a ranked candidate to a user interface, process, or other application. In one embodiment, a computing device can include and use a prediction engine which can use a customized ranking component to rank and return ranked candidates based in part on a query type. The customized ranking component can use predicted candidates provided by one or more data sources and/or candidate providers when making a ranking determination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07953692&OS=07953692&RS=07953692
owner: Microsoft Corporation
number: 07953692
owner_city: Redmond
owner_country: US
publication_date: 20071207
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["More and more people use computing devices, including handheld mobile devices, for business and personal uses. The size and portability of handheld mobile devices make them particularly attractive to users. However, the size of the input controls and display can adversely affect the user experience. For example, handheld devices tend to have small keypads, such as thumb keyboards or 12-key keypads. As a result, it can be more difficult and less efficient when entering inputs to a handheld device as compared to using a larger keyboard. Text prediction methods have been developed to try and reduce the amount of manual input required by application users, including handheld applications users. The text prediction methods are generally limited to specific prediction models and resources.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended as an aid in determining the scope of the claimed subject matter.","Embodiments are configured to provide one or more candidates based in part on an input. In an embodiment, a configurable system includes a prediction engine which can be configured to provide one or more ranked candidates using a number of data sources and\/or candidate providers. Each data source can be configured to include a candidate provider and a store for storing information. Candidate providers can be configured to receive input queries from the prediction engine and return predicted candidates to the prediction engine. The prediction engine can use the predicted candidates provided by a candidate provider to rank and return a ranked candidate to an input method or other user interface. Moreover, data sources, candidate providers, and other components can be added, removed, and\/or reconfigured according to a desired implementation. In one embodiment, a computing device can include and use a prediction engine having a customizable ranking component to rank and return ranked candidates to a user based in part on a query type. The prediction engine can use the ranking component to rank and order predicted candidates provided by one or more configurable data sources and\/or candidate providers.","These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of the invention as claimed.","Embodiments are configured to provide one or more candidates based in part on a user input or communication. In an embodiment, a system includes a prediction engine which can be configured to provide one or more candidates associated with a plurality of information sources. For example, the system can include and use text-based data sources, speech-based data sources, and\/or handwriting-based data sources, when providing candidates to a user based in part on an input or communication. Components of the system can be dynamically added, removed, configured, and\/or reconfigured, and at desired times. For example, users and applications can add, remove, configure, and reconfigure data sources, candidate providers, ranking components, etc.","Components of the system can be used with various input methods, including input method editors (IMEs) to predict text, handwriting systems to predict words based on handwritten inputs, and\/or voice systems to predict words based on vocalized inputs, but the system is not so limited. For example, the system can be configured to provide candidates while reducing a number of key presses, taps, and\/or handwriting strokes required as part of an input or other operation. The system can use multiple languages, input methods, ranking components, data sources, and\/or candidate providers. For example, certain input methods benefit by accessing data sources made available to disparate input methods without knowledge of where or how the data or data sources are provided. In one embodiment, the system can be configured with a customized ranking component or ranker, which can be tailored to include a particular ranking and\/or predictive functionality.","In an embodiment, a computing system includes a prediction engine having a ranking component that includes a ranking algorithm to rank one or more candidates based in part on an input query and one or more predicted candidates associated with one or more information sources. In one embodiment, an input query can be associated with one or more data sources and candidate providers which can be configured to provide one or more predicted candidates based on the input query and other factors. The one or more data sources can be configured to include one or more candidate providers and associated data stores to store prediction data and other information. Each candidate provider can be configured to predict candidates based on a prediction model or other predictive technique, such as an n-gram prediction model for example.","In another embodiment, a communication device can be configured to accept different user input types, such as handwritten input, speech input, typed input, or some other type of input. The communication device can include a prediction engine to provide one or more ranked candidates based in part on user input. The prediction engine can include a customizable ranker for ranking candidates and a manager for managing inputs and outputs.","In one embodiment, the ranker includes a ranking algorithm configured to provide a ranked candidate based in part on a confidence parameter and a candidate probability associated with a prediction by a candidate provider. The prediction engine can use data sources and candidate providers, including configurable data sources and candidate providers, associated with a particular input type and\/or those that are not necessarily associated with a particular input type when providing ranked candidates.","In one embodiment, a software application having executable instructions can be configured to provide one or more candidates based in part on a user input or communication. The application can include a prediction engine which can be incorporated with a mobile input platform. In one embodiment, the prediction engine can be configured to determine a word or phrase that a user is attempting to input to assist the user to input the information faster and with less effort. For example, the prediction engine can be used by various input method editors (IMEs) to provide text prediction, handwriting applications to provide improved handwriting accuracy and prediction, and voice dictation applications to improve vocalized recognition and correction accuracy. The application can be used with multiple data sources and candidate providers to provide one or more predicted candidates based in part on user input, such as typed input, spoken input, or handwritten input for example.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","100","100","100","100","100"]},"As shown in , the system  includes a prediction engine  that can be configured to predict one or more candidates based in part on user input. As described below, the prediction engine  can use information associated with multiple information sources when predicting candidates. In an embodiment, the prediction engine  can be included with a computing device, such as a smart device, or as part of an application. The prediction engine  can be used to predict one or more candidates in the context of an email communication, a text messaging communication, a word processing application, an inking application, a speech-based application, or some other communication or application. Once predicted, one or more of the predicted candidates can be provided to a user or application. For example, the prediction engine  can operate to predict words and phrases based on partially recognized handwritten input, partially recognized typed input, and\/or partially recognized speech input, wherein the predicted words and phrases can be displayed on a user device, such as a handheld communication device, laptop, desktop, or other computing device.","The system  can include an Input Method  or other user interface (UI) that can be used by a user to interact with the prediction engine . In one embodiment, the Input Method  can be configured to enable a user to input information according to a type of input method or language. For example, based on the configuration and functionality of the associated computing device, a user can use the Input Method  to type inputs, handwrite inputs, or provide spoken words as inputs, wherein the prediction engine  can use the input to predict one or more candidates. As used herein, a typing input method may also be referred to as an input method editor (IME).","With continuing reference to , the prediction engine  includes a ranking component  (hereinafter ranker ) and a managing component (hereinafter manager ). In one embodiment, the functionalities of the ranker  and manager  can be combined as a single component. As described further below, the ranker  can be configured to rank and order candidates associated with a plurality of information sources, such as data sources DS-DS(n). Users, input methods, and other applications can define a particular ranking functionality which may be registered with a prediction engine instance for a desired implementation. In one embodiment, the prediction engine  can include a plurality of ranking components that can be selectively used by a particular input method. For example, an input method can select a ranking component that best meets its needs based on a particular implementation. The manager  can operate to forward all prediction results from utilized data sources to a selected ranking component of the plurality of ranking components for making a ranking determination.","The manager  manages communication with various input methods, ranker , data sources, and\/or candidate providers. As described below, the data sources DS-DS(n) are registered so that the manager  can quickly determine which of the data sources DS-DS(n) are capable of processing a particular input query. An input query that defines the type of prediction results can be used by the manager  when determining which of the data sources DS-DS(n) or candidate providers should be used to process a particular query.","In an embodiment, an input query can contain a number of associated properties, including but not limited to: previous word primitives; undetermined input stream; input language or languages; input scope; input type; query type; candidate type; and\/or, a maximum number of candidate results. As used herein, previous word primitives refer to a prediction engine class object that contains a reading string and display string. The previous word primitives can be configured as a word separated list of word primitives that the user has entered and can be used by the prediction engine  for context to improve prediction accuracy. For example, if a previous word is \u201cMicrosoft\u201d and the current input is \u201cWi\u201d then the prediction engine  may suggest \u201cWindows\u201d over \u201cWill\u201d even if \u201cWill\u201d has a higher probability in the current language model.","An undetermined input stream can refer to index data which contains actual string data, wherein the string data can include any data type, such as byte, WORD, DWORD, etc. An input stream can refer to a data array logically. In one embodiment, the elements of a data array include: 1) offset data to input string; 2) offset data to display string; and, 3) some additional user defined information (e.g., language, data sources to use, candidate providers to user, ranking component to use, etc.). In one embodiment, the data in an input stream can be quantified by the input type and\/or query type.","The input language(s) refers to the language that prediction words should conform to. Input scope refers to how an input method can pass in the input scope of the input control to the prediction engine  to improve prediction accuracy. For example, an input scope can be used to notify the prediction engine  that a user is trying to enter a zip code, phone number, address, URL, email address, etc. Input type refers to a type of input associated with an undetermined input stream, which can include a particular language or input method. For example, a Japanese input method editor (IME) sends an input query with a single Hiragana undetermined match which is sent by the manager  to a Japanese data source that supports JPN Hiragana input. The Japanese data source returns potential candidates that match the Hiragana input.","Query type refers to a type of undetermined input stream. In one embodiment, the query type includes a prefix type or an exact match type. The prefix type refers to an undetermined string which includes one or more word prefix strings. For example, an IME may search for \u201cMic\u201d in the expectation to get candidate results back such as Microsoft, Microwave, Mickey, etc. For example, a 12-key input method might submit a prefix query with undetermined strings that match the key input of 12 like \u201cAD,AE,AF,BD,BE,BF,CD,CE,CF.\u201d The exact match refers to an undetermined string requested for ranking by an input method. For example, handwriting and voice-based input methods may request a ranking based on which of several possible words are the most probable based in part on a ranking and ordering determination.","Candidate type refers to a type of candidate that the prediction engine  can return. In one embodiment, there are four candidate types: primitive; word; phrase; and, sentence. A primitive candidate type refers to a reading string+display string pairing. In many languages, Chinese for example, the display of the reading of a word uses different characters from the display of a word. In Chinese, the reading string may be \u201cli\u201d while the display string is  In Chinese multiple display strings have the same reading string. \u201cli\u201d can also be  etc. In East Asian languages 1 or more characters are grouped together to make words. A word candidate type refers to multi-primitive candidates. A phrase candidate type refers to multi-word candidates. A sentence candidate type refers to sentence candidates. Maximum number of results refers to the maximum number of results to be returned based on a ranking determination.","Correspondingly, the manager  can process user input received from the Input Method  and communicate the request to one or more applicable data sources and\/or candidate providers based in part on the properties associated with the input query. For example, a user can use the Input Method  or some other input mechanism to provide a text input from a keyboard, recognized handwriting, or recognized speech input. In one embodiment, the manager  can direct requests to one or more of the data sources DS-DS(n) based on the input type or input method. The manager  can then collect the results, such as one or more predicted candidates from the one or more applicable data sources, which can be communicated to the ranker  for ranking, sorting, and\/or ordering. The manager  can then collect the results from the ranker  which can be communicated to the Input Method . For example, the manager  can communicate the ranked results to an IME being used by a user.","The data sources DS-DS(n) can be configured as disparate information repositories having associated candidate providing methods. For example, the data sources DS-DS(n) can be used to differentiate access points for various lexicon collections. As used herein, in linguistics, the lexicon of a language is its vocabulary, including its words and expressions. A lexicon collection can refer to a collection of words. In some cases, a lexicon collection can refer to dictionaries, language models, etc. A language model refers to collections of lexicons in a specific data-format that includes information about how the words are used in the language. Some language models can also include word frequency data.","The data sources DS-DS(n) can be configured to provide one or more candidates, whether by prediction or some other method, based in part on an input query or other input. For example, the manager  can communicate user input associated with a text messaging communication to one or more of the data sources DS-DS(n) which can operate to return predicted next words based on the context of the user communication. As described above, an input query can be configured as a data structure which provides information that can be used to determine a candidate, such as a word, that a user desires. For example, input queries can contain information like previous word primitives, a current or undetermined input stream, type of input language, contextual information to assist in narrowing the type of input desired, the query type to be performed, data sources to use for the query, etc.","As shown in , the data sources DS-DS(n) include associated candidate providers CP-CP(n) which receive input queries from the manager  and return candidate results (also referred to as predicted candidates) and other information to the manager . In an embodiment, one or more of the candidate providers can return predicted candidates, associated probabilities, and\/or a name of an associated data source. For example, a candidate provider can return a candidate and an associated probability based on word frequency, statistical data, n-gram model, etc. The data source name can be used to identify the data source which provided a particular candidate. The data source name can also be used by input methods or ranking algorithms to determine which data source is more accurate in specific situations, and used to change data source weights over time. In one embodiment, each candidate provider CP-CP(n) can be configured as an application programming interface (API) to operate between the manager  and a respective data source. Each candidate provider can include a prediction model for predicting candidates. For example, one candidate provider can be configured with an n-gram language model, whereas another candidate provider can be configured with a different probability model.","According to various configurations, different combinations of data sources DS-DS(n) can be used to obtain certain prediction results. In some cases, certain data sources can be more desirable based on an input type. The manager  can be used to associate certain confidence parameters to different data sources DS-DS(n). In one embodiment, the manager  can associate different weights with certain data sources DS-DS(n) which the ranker  can use when ranking candidates, as described further below. In an embodiment, the manager  can send an input query to applicable data sources based in part on the confidence parameter which can be associated with each data source. A confidence parameter can also be assigned to a candidate provider.","As shown in , the data sources DS-DS(n) also include respective stores ST-ST(n) to store data, such as words, metadata, and other information, for use by the candidate providers CP-CP(n) when providing candidates to the manager . Another candidate provider CP is shown without an associated store to accommodate implementations that use a programmatic solution rather than a defined data source. In another embodiment, a candidate provider can be used in conjunction with multiple data sources and associated stores. In certain embodiments, one or more of the data sources DS-DS(n) can be included with a respective computing device and\/or remotely accessed, dependent upon the particular computing and\/or prediction architecture. The data sources DS-DS(n) can be updated, modified, added, and\/or removed. In certain cases, a data source can be updated based on a user action associated with a candidate. For example, a user may select or skip a returned candidate, and the interaction information can be used to update one or more of the data sources DS-DS(n).","In an embodiment, each data source DS-DS(n) can include a unique architecture for predicting candidate(s), such as one or more words for example, based on a given input. For example, some data sources may use prefix matching to return all words that start with a given prefix; whereas, other data sources can use more advanced techniques to return words with different probability weights based in part on additional information that is associated with an input query. As an example, data source DS can be configured with a static word provider and a static word dictionary; data source DS can be configured with an input history provider and a input history store; data source DS can be configured with a used word provider and a used word store; data source DS can be configured with a handwriting-based word provider and associated store; DS can be configured with a speech-based word provider and associated data store; DS can be configured with a language-specific word provider and associated data store, etc. Additional examples of data sources DS-DS(n) include multiple dictionaries supporting multiple languages, URL lists, contacts, email address sources, and other data and information structures for storing and providing information. Moreover, data sources, including custom data sources, may be added to and\/or removed from the system  according to a desired implementation.","Disparate data sources and\/or candidate providers to be used for predicting candidates can be registered with an associated computing device, application, or method. In an embodiment, a number of registry keys can be used to register data sources, wherein the registry keys can be used to: store a list of all registered data sources; identify capabilities of the registered data sources; identify an associated weight of each registered data source; and, provide other custom information that may be of interest to applications, input methods, or users.","For example, a data sources registry hive can be defined as:","HKEY_LOCAL_MACHINE\\Software\\MicrosoftMTF\\DataSources\\","The data sources registry hive can include a new key defined by a name of a data source.","As an example, a static dictionary data source can use a key called HKEY_LOCAL_MACHINE\\Software\\MicrosoftMTF\\DataSources\\SDDS to identify the data source.","In one embodiment, the values in Table 1 below can be defined for each data source key.",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Type","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DataSourceName","String","A unique name for a data"]},{"entry":[{},{},"source."]},{"entry":["Languages","Multi-String","List of Language local IDs"]},{"entry":[{},{},"(LCID's) that a data source"]},{"entry":[{},{},"predicts results in."]},{"entry":["Candidate Type","DWORD","0 - Primitive (Candidate"]},{"entry":[{},{},"contains Single Primitive)"]},{"entry":[{},{},"1 - Word (Candidate"]},{"entry":[{},{},"contains Multi-Primitives)"]},{"entry":[{},{},"1 - Phrase (Candidate"]},{"entry":[{},{},"contains Multi-Primitives"]},{"entry":[{},{},"which forms a phrase)"]},{"entry":[{},{},"3 - Sentence (Candidate"]},{"entry":[{},{},"contains Multi-Primitives"]},{"entry":[{},{},"which forms a sentence)"]},{"entry":["DSWeight","DWORD","Default data source weight"]},{"entry":[{},{},"0-100"]},{"entry":["QueryType","DWORD","0 - Prefix"]},{"entry":[{},{},"1 - Exact Match"]},{"entry":[{},{},"2 - Regular Expression"]},{"entry":["Input Type","Multi-Word String","List of input types that"]},{"entry":[{},{},"match existing global"]},{"entry":[{},{},"unique identifiers (GUIDs)"]},{"entry":[{},{},"or (GUIDs) that a data"]},{"entry":[{},{},"source supports input for."]},{"entry":["Dynamic","DWORD","0 - Static (Default)"]},{"entry":[{},{},"1 - Dynamic"]},{"entry":[{},{},"Dynamic data sources can"]},{"entry":[{},{},"change over time."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"As shown in Table 1, a registry hive can also be used to define a default data source weight for each data source. The default weight for each applicable data source can be used when the manager  is initialized. Applications and input methods can change the weight of data sources within the prediction engine dynamically by calling a manager API described below. A default weight for a data source can be defined in the registry as a value between zero and 100. A value of zero indicates that a data source should be skipped by default, and a value of 100 indicates that a data source should get as much weight as possible. Correspondingly, weights can be adjusted according to values along the scale.","An initial weight of a data source can be defined as the default weight divided by the sum of all default weights (i.e., initial weight=default weight\/(sum of all default weights). In an embodiment, the manager  can be configured to calculate the actual weight of a data source at initialization by dividing the default weight by the sum of all the default weights. An API that provides access for applications and input methods to change weights can represent a weight of each data source as a number less than 1. If an application or input method attempts to set an invalid weight, it will be rejected and a default weight will be used. If the default weight defined in the registry key is greater than 100, 100 will be used as the weight. If the weight is defined as less than zero, zero will be used as the weight. For example, a messaging application may want to ensure that the candidate results that come from an application defined data source have more weight in the prediction results than candidates from a static dictionary. As another example, an input method may only want to predict words using a proprietary dictionary rather than using a static dictionary, so the proprietary dictionary weight can be set to a high value and the static dictionary weight can be set to zero.","In an embodiment, the manager  includes a manager interface which can be configured to communicate candidates to and from the ranker  and\/or one or more of the data sources DS-DS(n), configure the data sources DS-DS(n), and customize aspects of the prediction engine . Other interfaces used by the prediction engine  are described below.","In one embodiment, the manager interface can be configured as follows:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003interface IMtfPredictionManager : IUnknown {"},{"entry":"\u2003\u2003\/\/ Query Candidates"},{"entry":"\u2003\u2003\u2003HRESULT GetCandidates("},{"entry":"\u2003\u2003[in] IPredictionInputQuery *pInputQuery,"},{"entry":"\u2003\u2003[out] IEnumPredictionCandidate **ppEnumCandidate);"},{"entry":"\u2003\u2003\/*The Input method will call GetCandidates( ) passing the input query and it will"},{"entry":"get back a list of prediction candidates based on that input query. *\/"},{"entry":"\u2003\u2003\u2009\/\/ Data Source management"},{"entry":"\u2003\u2003\u2003HRESULT AddCustomDataSource("},{"entry":"\u2003\u2003[in] IPredictionDataSource *pDataSource,"},{"entry":"\u2003\u2003[out, retval] DWORD *pdwDataSourceID);"},{"entry":"\u2003\u2003\/* AddCustomDataSource provides an API that can used to add a Custom data"},{"entry":"source to the list of data sources that are used by the prediction engine. Note: All existing"},{"entry":"data sources will be read from the registry and initialized when the prediction engine is used."},{"entry":"*\/"},{"entry":"\u2003\u2003\u2003HRESULT RemoveCustomDataSource("},{"entry":"\u2003\u2003[in] DWORD dwDataSourceID);"},{"entry":"\u2003\u2003\/* RemoveCustomDataSource provides an interface that allows a specific custom"},{"entry":"data source to be removed from the list of data sources that are used for prediction. *\/"},{"entry":"\u2003\u2003\u2003HRESULT EnumDataSource("},{"entry":"\u2003\u2003[out, retval] IEnumPredictionDataSource **ppEnumDataSource);"},{"entry":"\u2003\u2003\/*EnumDataSource\u2003provides\u2003a\u2003way\u2003to\u2003enumerate\u2003data\u2003sources,\u2003such\u2003as"},{"entry":"enumerating all default data sources and all registered custom data sources. *\/"},{"entry":"\u2003\u2003HRESULT PurgeAllDataSources( );"},{"entry":"\u2003\u2003\/* PurgeAllDataSources removes all data sources from the prediction engine."},{"entry":"Data sources must be added or restored before prediction engine will provide candidate"},{"entry":"results again. *\/"},{"entry":"\u2003\u2003HRESULT RestoreDefaultDataSourceSet( );"},{"entry":"\u2003\u2003\/* RestoreDefaultDataSourceSet restores all data source information based on the"},{"entry":"data source information that is defined in the registry. \u2003After being called, the data source"},{"entry":"information should be the same as if the prediction engine were just initialized. *\/"},{"entry":"\u2003\u2003HRESULT RegisterCustomRanker("},{"entry":"\u2003\u2003[in] IPredictionCandidateRanker *pPredictionCandidateRanker);"},{"entry":"\u2003\u2003\/* RegisterCustomRanker provides customizability of ranker for prediction"},{"entry":"engine clients.\u2003Clients\u2003can\u2003use\u2003this\u2003interface\u2003to\u2003register\u2003custom\u2003ranker\u2003and\/or\u2003ranking"},{"entry":"algorithms. *\/"},{"entry":"\u2003\u2003HRESULT GetDefaultRanker("},{"entry":"\u2003\u2003[out] IPredictionCandidateRanker **ppPredictionCandidateRanker);"},{"entry":"\u2003\u2003\/* GetDefaultRanker returns pointer to instance of default ranker. This method is"},{"entry":"a utility method for custom ranker made by clients. Clients can utilize default ranker in their"},{"entry":"own ranker implementation. *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, an input query interface can be configured to manage an input query as follows:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\/\/ IMtfPredictionInputQuery interface"]},{"entry":[{},"\u2003\u2003\/\/------------------------------------------------"]},{"entry":[{},"\u2003\u2003\/\/ Data Container for Input Query."]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003interface IMtfPredictionInputQuery : IUnknown {"]},{"entry":[{},"\u2003\u2003\u2003HRESULT Initialize( );"]},{"entry":[{},"\u2003\u2003\u2003HRESULT SetInputStream([in] BYTE *pbStream,"]},{"entry":[{},"\u2003\u2003\u2003[in] DWORD cbStream);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT AddInputLanguage([in] BSTR bstr);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT ClearInputLanguage( );"]},{"entry":[{},"\u2003\u2003\u2003HRESULT AddInputScope([in] DWORD dw);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT ClearInputScope( );"]},{"entry":[{},"\u2003\u2003\u2003HRESULT AddInputType([in] GUID guid);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT ClearInputType( );"]},{"entry":[{},"\u2003\u2003\u2003HRESULT SetQueryType([in] DWORD dw);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT SetCandidateType([in] DWORD dw);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT SetMaxResults([in] DWORD dw);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT SetMaxWait([in] DWORD dw);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT AddPreviousPrimitive([in]"]},{"entry":[{},"IEnumPredictionCandidatePrimitive* pEnumPrimitive);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT ClearPreviousPrimitive( );"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, a ranker interface can be configured as follows:",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ IPredictionCandidateRanker interface"},{"entry":"\u2003\u2003\/\/------------------------------------------------"},{"entry":"\u2003\u2003\/\/ Ranker of Prediction Candidate"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IMtfPredictionCandidateRanker : IUnknown {"},{"entry":"\u2003\u2003\u2003HRESULT AddCandidates("},{"entry":"\u2003\u2003[in] IPredictionInputQuery *pInputQuery,"},{"entry":"\u2003\u2003[in, out] IEnumPredictionCandidate **ppEnumBaseCandidates,"},{"entry":"\u2003\u2003[in] IEnumPredictionCandidate **ppEnumAddedCandidates);"},{"entry":"\u2003\u2003\/* This method is called to add candidates from a data source to a"},{"entry":"base candidate list after candidate generation from each data source."},{"entry":"Ranker can implement incremental ranking by this method. *\/"},{"entry":"\u2003\u2003\u2003HRESULT RankCandidates("},{"entry":"\u2003\u2003[in] IPredictionInputQuery *pInputQuery,"},{"entry":"\u2003\u2003[in, out] IEnumPredictionCandidate **ppEnumCandidate);"},{"entry":"\u2003\u2003\/* This method is called once per query after all candidates are"},{"entry":"generated from add data source. Ranker can implement batch ranking"},{"entry":"by this method. And Custom Ranker can adjust candidate ranking based"},{"entry":"on Default Ranker output.*\/"},{"entry":"\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, a data source interface can be used to provide access to a data source by the manager  or some other component or application, and can be configured as follows:",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ IMtfPredictionDataSource interface"},{"entry":"\u2003\u2003\/\/------------------------------------------------"},{"entry":"\u2003\u2003\/\/ Data Source"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IMtfPredictionDataSource : IUnknown"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/Sync Query"},{"entry":"\u2003\u2003\u2003HRESULT GetCandidates("},{"entry":"\u2003\u2003[in] const IPredictionInputQuery *pInputQuery,"},{"entry":"\u2003\u2003[out, retval] IEnumPredictionCandidate **ppEnumCandidate);"},{"entry":"\u2003\u2003\u2003\/\/Query Properties"},{"entry":"\u2003\u2003\u2003HRESULT\u2003\u2003\u2003SetParameterMaximumCandidates([in]"},{"entry":"DWORD dwMaximumCandidates );"},{"entry":"\u2003\u2003\u2003HRESULT\u2003\u2003GetParameterMaximumCandidates([out,"},{"entry":"retval]\u2003DWORD pdwMaximumCandidates );"},{"entry":"\u2003\u2003\u2003\/\/DS Properties"},{"entry":"\u2003\u2003\u2003HRESULT GetSupportedLanguages([out, retval] BSTR *pbstr);"},{"entry":"\u2003\u2003\u2003HRESULT GetPersistency([out, reval] DWORD *pdwPersistency);"},{"entry":"\u2003\u2003\u2003HRESULT GetQueryType([out, reval] DWORD *pdwType);"},{"entry":"\u2003\u2003\u2003HRESULT\u2003GetInputScopes([out]\u2003DWORD\u2003**ppInputScope,"},{"entry":"[out]\u2003UINT *pcCount);"},{"entry":"\u2003\u2003\u2003HRESULT GetDataSourceWeight([out, retval] DWORD"},{"entry":"\u2003\u2003\u2003*pdwWeight);"},{"entry":"\u2003\u2003\u2003HRESULT SetDataSourceWeight([in] DWORD dwWeight);"},{"entry":"\u2003\u2003\u2003HRESULT EnableDataSource([in] BOOL fEnable);"},{"entry":"\u2003\u2003\u2003HRESULT GetID([out, retval] DWORD *pdwDataSourceID);"},{"entry":"\u2003\u2003\u2003HRESULT SetID([in] DWORD dwDataSourceID);"},{"entry":"\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, a prediction candidate primitive interface can be configured to access candidate primitives as follows:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ IPredictionCandidatePrimitive interface"},{"entry":"\/\/------------------------------------------------"},{"entry":"\/\/ Data Container for Prediction Candidate Primitive."},{"entry":"\/\/"},{"entry":"interface IMtfPredictionCandidatePrimitive : IUnknown {"},{"entry":"\u2003HRESULT GetDisplay([out, retval] BSTR* pbstrDisplay);"},{"entry":"\u2003HRESULT GetReading([out, retval] BSTR* pbstrReading);"},{"entry":"\u2003HRESULT GetUserDataPtr([out, retval] VARIANT* vpUserData);"},{"entry":"\u2003HRESULT GetUserDataSize([out, retval] DWORD*"},{"entry":"\u2003pdwUserDataSize);"},{"entry":"\u2003HRESULT GetProbability([out, retval] DWORD* pdwProbability);"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, a prediction candidate result interface can be configured to provide and\/or access prediction candidates as follows:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\/\/ IPredictionCandidate interface"]},{"entry":[{},"\u2003\u2003\/\/------------------------------------------------"]},{"entry":[{},"\u2003\u2003\/\/ Data Container for Prediction Candidate."]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003interface IMtfPredictionCandidate : IUnknown {"]},{"entry":[{},"\u2003\u2003\u2003HRESULT GetDisplay([out, retval] BSTR* pbstrDisplay);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT GetReading([out, retval] BSTR* pbstrReading);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT GetProbability([out, retval] DWORD*"]},{"entry":[{},"\u2003\u2003\u2003pdwProbability);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT EnumPrimitive([out, retval]"]},{"entry":[{},"IEnumPredictionCandidatePrimitive** ppEnumPrimitive);"]},{"entry":[{},"\u2003\u2003\u2003HRESULT GetDataSourceID([out, retval] DWORD*"]},{"entry":[{},"\u2003\u2003\u2003pdwDataSourceID);"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, an enumerator interface can be configured enumerate prediction candidate primitives as follows:",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ IEnumPredictionCandidatePrimitive interface"},{"entry":"\u2003\u2003\/\/------------------------------------------------"},{"entry":"\u2003\u2003\/\/ Enumerator of Data Source"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IEnumIMtfPredictionDataSource : IUnknown {"},{"entry":"\u2003\u2003\u2003HRESULT\u2003Next(\u2003[in]\u2003ULONG\u2003ulCount,\u2003[out]"},{"entry":"IPredictionDataSource **ppDataSource, [out] ULONG *pcFetched );"},{"entry":"\u2003\u2003\u2003HRESULT Skip( [in] ULONG ulCount );"},{"entry":"\u2003\u2003\u2003HRESULT Reset( void );"},{"entry":"\u2003\u2003\u2003HRESULT Clone( [out] IEnumPredictionDataSource **ppenum );"},{"entry":"\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, an enumerator prediction candidate primitive interface can be configured as follows:",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ IEnumPredictionCandidatePrimitive interface"},{"entry":"\u2003\u2003\/\/------------------------------------------------"},{"entry":"\u2003\u2003\/\/ Enumerator of Prediction Candidate Primitive"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IEnumIMtfPredictionCandidatePrimitive : IUnknown {"},{"entry":"\u2003\u2003\u2003HRESULT Next( [in] ULONG ulCount, [out]"},{"entry":"IPredictionCandidatePrimitive **ppPrimitive, [out] ULONG *pcFetched );"},{"entry":"\u2003\u2003\u2003HRESULT Skip( [in] ULONG ulCount );"},{"entry":"\u2003\u2003\u2003HRESULT Reset( void );"},{"entry":"\u2003\u2003\u2003HRESULT Clone( [out] IEnumPredictionCandidatePrimitive"},{"entry":"\u2003\u2003\u2003**ppenum );"},{"entry":"\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, an enumerator prediction candidate interface can be configured as follows:",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003interface IEnumIMtfPredictionCandidate : IUnknown {"},{"entry":"\u2003\u2003\u2003HRESULT Next( [in] ULONG ulCount, [out]"},{"entry":"IPredictionCandidate **ppCandidate, [out] ULONG *pcFetched );"},{"entry":"\u2003\u2003\u2003HRESULT Skip( [in] ULONG ulCount );"},{"entry":"\u2003\u2003\u2003HRESULT Reset( void );"},{"entry":"\u2003\u2003\u2003HRESULT Clone( [out] IEnumPredictionCandidate **ppenum );"},{"entry":"\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As described above, the manager  can use information provided in the input query to determine which of the data sources DS-DS(n) can be used to process the current input query. For example, based on the input type, the manager  can determine which of the data sources DS-DS(n) are most applicable to provide candidates. Once the manager  determines the applicable data sources DS-DS(n), the manager  sends the input query to each applicable data source. Each of the applicable data sources can then operate to process the input query and return any appropriate candidates to the manager . Thereafter, the manager  can collect and provide the candidates to the ranker  for further ranking, ordering, and\/or other operations.","The ranker  can rank the candidate results according to a ranking algorithm, but is not so limited. In an embodiment, the ranking algorithm can be configured to output a rank of a candidate using one or more candidate probabilities provided by one or more of the candidate providers and confidence parameters, such as data source weights for example, associated with the data sources DS-DS(n). For example, the ranking algorithm can be used to output a probability of a word by interpolating probabilities from one or more of the candidate providers. In one embodiment, the ranker  can be configured as a default ranker that ranks candidates using the following ranking algorithm:\n\n()=1\u00d7()+2\u00d7()+3\u00d7()+ . . . +()\u00d7()\u2003\u2003(1)\n","wherein,","P(w) is the output which corresponds to the probability of a given candidate;","s1 . . . s(n) correspond to weights of the data sources DS()-DS(n) used in the ranking determination; and,","f(w) . . . f(w) correspond to probabilities of candidates provided by the candidate providers CP-CP(n).","In an embodiment, a weight associated with a data source can be stored locally by using a one or more APIs. Applications and input methods can change the weighting of data sources by using the APIs. The manager  can also be configured to control the weighting of data sources. Once the manager  receives an input query, a data source weight can be read and the weighting information can be used by the ranker  to prioritize all candidate results for that particular input query. A data source weight only has to be read once when an input query is received. If the same string is matched by multiple data sources, the ranker  can operate to sum the probabilities associated with the string from each data source, and return only one instance of the string with the summed probabilities. After ranking using (1), the ranker  can operate to sort or order the ranked candidates according to the output of the ranking algorithm, and return the ordered results to the manager . Thereafter, the manager  can communicate the ordered results to the Input Method , application, method, or some other interface.","As described briefly above, the ranker  can be customized and\/or replaced with a different ranker and ranking algorithm according to a desired ranking functionality. For example, a user may want to use a customized ranking algorithm to rank candidates rather than using the ranking algorithm (1) based in part on a type of input method and statistical model. As one example, a custom ranker, such as QWERTY keyboard ranker, can be used to replace the ranking algorithm (1) used in a ranking determination. The QWERTY keyboard ranker can be configured to rank words higher if the associated language model probability is high and require at least 2 more key presses. As another example, a custom ranker, such as a 12-key phone keypad input ranker, can be used to replace the ranking algorithm (1) used in a ranking determination. The 12-key phone keypad input ranker can be configured to rank by giving preference to words that have the same number of characters as key presses. This is because input like  on a 12-key phone could be \u201ccar\u201d \u201cbar\u201d, or \u201ccap\u201d; but, if you try to predict ahead it could also be \u201cCarlton\u201d, \u201ccapital\u201d, \u201cBarcelona\u201d, etc. As described above, custom data sources and\/or candidate providers can also be included and used by the ranker  to rank and order candidates. Correspondingly, users, such as researches and developers for example, can create and test complicated statistical and learning algorithms on the data to optimize prediction results.","An illustrative example follows. For this example, assume that the manager  has identified three data sources (DS, DS, and DS) to use for providing candidates based on the type of input. The manager  has also assigned weights to each of the three data sources. The manager  has assigned a weight of: 0.70 to DS; 0.20 to DS; and, 0.10 to DS. As described above, weights can be assigned to various data sources based in part on an input query and\/or a confidence level or relevancy associated with each data source.","For this example, assume that a user has typed the input \u201cMicrosoft P\u201d using the Input Method . As described above, the user could also have handwritten or inked the input, or spoken the input into a speech recognition engine for example. Accordingly, the input query corresponding with the user input includes \u201cMicrosoft\u201d as a previous word primitive, and \u201cP\u201d as an undetermined input stream. The user or application has further specified that it only wants the top 4 results and the input language is English. The input query is then communicated to the manager .","The manager  can operate to identify any data sources that are currently registered to receive input queries that can handle the input query. After identifying the appropriate data source or sources, the manager  can forward the query to each currently registered data source. In this example, the manager  has identified DS, DS, and DS as being currently registered data sources that can handle the current input query. DST receives the input query from the manager  and finds that the \u201cP\u201d prefix matches 1000 words, but the \u201cP following \u201cMicrosoft\u201d only matches 3 candidates. Based on its findings DS, returns the following 3 candidates: \u201cPowerPoint\u201d having an associated probability of 0.50, \u201cProject\u201d having an associated probability of 0.30, and \u201cProject Studio\u201d having an associated probability of 0.20. DS also receives the input query from the manager  and finds that the \u201cP\u201d prefix matches 200 words, but the \u201cP following \u201cMicrosoft\u201d only matches 1 candidate: \u201cPhotoeditor\u201d having an associated probability of 1. DS also receives the input query from the manager  and finds that the \u201cP\u201d prefix matches 10 words, but the \u201cP following \u201cMicrosoft\u201d only matches 1 candidate: \u201cPrint\u201d having an associated probability of 1.","The manager  can then return the candidates to the ranker  can use the ranking algorithm (1) or a custom ranking algorithm to rank the returned candidates as shown in Table 2 below.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Data Source","Word","Word Probability"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DS 1","PowerPoint",".7 * .5 = 0.35"]},{"entry":[{},"DS 1","Project",".7 * .3 = 0.21"]},{"entry":[{},"DS 1","Project Studio",".7 * .2 = 0.14"]},{"entry":[{},"DS 2","PhotoEditor","\u2009.2 * 1 = 0.2"]},{"entry":[{},"DS 3","Print","\u2009.1 * 1 = 0.1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The ranker  then orders the results, and returns the top 4 results which can be displayed in the Input Method . The top 4 results are shown in Table 3 below.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Candidate Result","Rank","Word Probability"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PowerPoint","1","0.35"]},{"entry":[{},"Project","2","0.21"]},{"entry":[{},"PhotoEditor","3","0.2"]},{"entry":[{},"Project Studio","4","0.14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"As described above, the system  can be used to provide textual input prediction, handwriting input prediction, and\/or voice-based input prediction, but the system  is not so limited. For example, speech and handwriting recognition programs can use aspects of the system  to match ink data or voice sounds to words stored in a lexicon language model. A handwriting or speech recognition engine can calculate how closely the ink data or speech sound matches words since these programs can query all of the registered data sources of the system  to get access to lexicons that may not be not in their current language models. Accordingly, the handwriting and speech engines can call on all registered data sources to identify words that are not in their engines in order to make their engines more accurate.","As another example, aspects of the system  can be used to provide auto-complete solutions for handwriting. A handwriting engine can try to recognize each character as a user writes. After each character is recognized, the prediction engine  and registered data sources can be queried to get a list of prediction results to display in a prediction UI. If a user sees the word they were trying to handwrite they can then just tap on it saving pen strokes.","As further example, aspects of the system  can be used to correct speech and handwriting recognition errors. Handwriting and speech recognition programs can use the prediction engine  to generate queries containing different recognition results to determine a probability ranking for display in an associated UI or to determine if there are other high probability matches based on a prefix or regular expression.","As yet another example, components of the system  can be used in conjunction with speech and\/or handwriting recognition systems. These recognition systems can be configured to recognize n number of potential strings that match the handwriting (e.g., ink) or speech data. The strings can then be submitted to the prediction engine  as prefix or exact match queries against any installed data sources and\/or candidate providers. The results returned by the installed data sources and\/or candidate providers can be used by the prediction engine  to provide a ranked list of the most probable candidates. Handwriting and speech recognition systems can be configured to assign a probability and\/or weight to each recognized word based on how close the input matches the associated system model. The probability of the speech\/handwriting recognition systems can be combined with a candidate probability provided by the prediction engine  to determine a final probability ranking of each candidate to recognize the candidate having a combined highest probability.","The components of system  described above can be implemented as part of networked, distributed, or other computer-implemented environment. The system  can be employed in a variety of computing environments and applications. For example, the system  can used with computing devices having networking, security, and other communication components configured to provide communication functionality with other computing and\/or communication devices. Such computing devices include desktop computers, laptop computers, tablet computers, handheld devices (e.g. smart phone, ultra-mobile personal computer, etc.), and\/or other communication devices.","The embodiments described herein can be used with a number of applications, systems, and other devices and are not limited to any particular implementation or architecture. Moreover, certain components and functionalities can be implemented either in hardware or software. While certain embodiments include software implementations, they are not so limited and they encompass hardware, or mixed hardware\/software solutions. Also, while certain data structures, component features, and predictive functionality has been described herein, the embodiments are not so limited and can include more complex data structures, features, and other functionality. Accordingly, the embodiments and examples described herein are not intended to be limiting and other embodiments are available.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 2","FIG. 1"],"b":["200","100","102","106"]},"At , the manager  receives an input query associated with a user operation or communication. For example, a user may be emailing a friend by using a stylus to enter characters using a digitized keyboard, wherein the user input can be provided to the prediction engine  to predict a word, phrase, acronym, or other character string. As further example, a user may be dictating a message and dictated words can be provided to the prediction engine  to predict a word, phrase, acronym, or other character string. At , the manager  can match one or more of the data sources DS-DS(n) based in part on the input query and any configuration settings at . For example, the manager  may only match certain data sources based on the language requirements made by the user.","At , the manager  sends query data associated with the input query to the one or more matched data sources DS-DS(n). After predicting candidates, at  the manager  can receive or collect query results from the one or more data sources DS-DS(n). For example, the manager  can collect predicted candidates from a plurality of data sources, wherein each data source can return results, such as one or more predicted candidates, associated probabilities, and other information that can be used in ranking and ordering the results. At , the manager  sends the results to the ranker  for ranking and ordering.","Based in part on the ranker and\/or ranking algorithm, the query results can be ranked and ordered at . For example, as described above, ranker  and the ranking algorithm (1) can be used to output probabilities of given candidates based in part on data source weighting factors and probabilities of candidates provided by the one or more data sources DS-DS(n). As another example, if a user has registered a custom ranker and\/or ranking algorithm, a different resultant set of candidates can be ranked and ordered based in part of the particular ranker and\/or ranking algorithm. At , the manager  can operate to return the ranked and ordered results to the Input Method  or other application. While a certain order and number of operations are described with respect to , the order and number of operations can be changed according to a desired implementation.","Exemplary Operating Environment","Referring now to , the following discussion is intended to provide a brief, general description of a suitable computing environment in which embodiments of the invention may be implemented. While the invention will be described in the general context of program modules that execute in conjunction with program modules that run on an operating system on a personal computer, those skilled in the art will recognize that the invention may also be implemented in combination with other types of computer systems and program modules.","Generally, program modules include routines, programs, components, data structures, and other types of structures that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including handheld devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","Referring now to , an illustrative operating environment for embodiments of the invention will be described. As shown in , computer  comprises a general purpose desktop, laptop, handheld, tablet, or other type of computer capable of executing one or more application programs. The computer  includes at least one central processing unit  (\u201cCPU\u201d), a system memory , including a random access memory  (\u201cRAM\u201d), a read-only memory (\u201cROM\u201d) , a textual store , and a system bus  that couples the memory to the CPU . A basic input\/output system containing the basic routines that help to transfer information between elements within the computer, such as during startup, is stored in the ROM .","The computer  further includes a mass storage device  for storing an operating system , application programs, and other program modules. The mass storage device  is connected to the CPU  through a mass storage controller (not shown) connected to the bus . The mass storage device  and its associated computer-readable media provide non-volatile storage for the computer . Although the description of computer-readable media contained herein refers to a mass storage device, such as a hard disk or CD-ROM drive, it should be appreciated by those skilled in the art that computer-readable media can be any available media that can be accessed or utilized by the computer .","By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EPROM, EEPROM, flash memory or other solid state memory technology, CD-ROM, digital versatile disks (\u201cDVD\u201d), or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer .","According to various embodiments, the computer  may operate in a networked environment using logical connections to remote computers through a network , such as a local network, the Internet, etc. for example. The computer  may connect to the network  through a network interface unit  connected to the bus . It should be appreciated that the network interface unit  may also be utilized to connect to other types of networks and remote computing systems. The computer  may also include an input\/output controller  for receiving and processing input from a number of input types, including a keyboard, mouse, pen, stylus, finger, speech-based, and\/or other means. Other input means are available including combinations of various input means. Similarly, an input\/output controller  may provide output to a display, a printer, or other type of output device. Additionally, a touch screen can serve as an input and an output mechanism.","As mentioned briefly above, a number of program modules and data files may be stored in the mass storage device  and RAM  of the computer , including an operating system  suitable for controlling the operation of a networked personal computer, such as the WINDOWS operating systems from MICROSOFT CORPORATION of Redmond, Wash. for example. The mass storage device  and RAM  may also store one or more program modules. In particular, the mass storage device  and the RAM  may store other application programs, such as a word processing application , an inking application , e-mail application , drawing application, etc.","It should be appreciated that various embodiments of the present invention can be implemented (1) as a sequence of computer implemented acts or program modules running on a computing system and\/or (2) as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance requirements of the computing system implementing the invention. Accordingly, logical operations including related algorithms can be referred to variously as operations, structural devices, acts or modules. It will be recognized by one skilled in the art that these operations, structural devices, acts and modules may be implemented in software, firmware, special purpose digital logic, and any combination thereof without deviating from the spirit and scope of the present invention as recited within the claims set forth herein.","Although the invention has been described in connection with various exemplary embodiments, those of ordinary skill in the art will understand that many modifications can be made thereto within the scope of the claims that follow. Accordingly, it is not intended that the scope of the invention in any way be limited by the above description, but instead be determined entirely by reference to the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
