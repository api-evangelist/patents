---
title: Category-based name schemes in parsing frameworks
abstract: According to some embodiments, categories and an associated category graph may be determined for a parsing framework. Moreover, a type for the parsing framework may be defined, wherein at least one category is automatically created and inserted into the category graph for an implementation element of the defined type. Namespaces may be automatically defined for the categories based at least in part on inheritance relationships associated with the categories in the category graph.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08756252&OS=08756252&RS=08756252
owner: SAP AG
number: 08756252
owner_city: Walldorf
owner_country: DE
publication_date: 20081203
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Some embodiments of the present invention may relate to name schemes in a parsing framework. In particular, some embodiments may comprise systems and methods that provide category-based name schemes in a parsing framework and\/or that combine parameter and argument specification in text-based parsing frameworks.","Some tools use text-based descriptions to configure dedicated tool execution behaviors, including descriptions associated with command interpreters and\/or tools that use an abstract description of work to be done in connection with scheduled execution tasks. By way of example, a text-based description may be provided to describe a build process (and associated dependencies) to automate a software build procedure. Moreover, such descriptions may include a naming scheme and\/or multiple levels of elements (including, for example, elements that are nested within each other).","In some cases, a manual approach may be used to derive parsing for multiple levels of elements (e.g., parsing associated with a parameter name and\/or an argument type associated with an element). Note, however, that a manual approach in this environment may be inefficient. Moreover, the implementation may need to be sharable (e.g., existing implementations being adopted to newly created interfaces to achieve a desired result). Moreover, an initial implementation may need to be modifiable in a development context to be extended to support new arising interfaces.","Approaches that improve name schemes in a parsing framework could, therefore, be desirable. Moreover, it may advantageous to provide one or more systems and\/or methods to do so in an efficient and convenient manner.","Consider, for example, the Ant build tool which is implemented using the Java programming language. The Ant build tool may facilitate an automated software build process by using the Extensible Markup Language (\u201cXML\u201d) protocol to describe the build process and its dependencies. In particular, Ant uses an XML-based description file to describe the build steps that must be executed along with their interdependencies (e.g., it provides a description language to describe the execution sequence of actions).","The actions and arguments for those actions are described in XML, and the Ant tool parses the XML file to determine an execution order of necessary steps to complete a software build as appropriate. Moreover, several methods are provided within the framework to extend pre-defined execution elements (including actions and data types used as arguments for those actions). In the example of the Ant tool, two basic kinds of elements may be provided: \u201ctasks\u201d and \u201ctypes.\u201d","A \u201ctask\u201d element may describe an execution step that can be used to define statement sequences that will be executed under dedicated circumstances to achieve a dedicated goal. A \u201ctype\u201d element may a declare data structure that can be used as an argument for tasks (or for other types).","Note that extensibility may be permitted such that new tasks and types described by java classes can be added as appropriate. For example, it may be possible to add new tasks by providing a dedicated java class for the task and assigning it to a unique name in the context of a description file (and the name may be unique in a dedicated namespace for tasks). Also note that Ant is associated with different flavors of such types (e.g., regular data types or conditions) having similar basic behaviors. For each kind, there is a separate namespace created during the execution of the description file. Moreover, it may be possible to declare new types by providing a dedicated class and assigning it to a name in this namespace. The different namespaces may be used, for example, to allow the same names in different contexts (although the number of contexts may be pre-determined).","Consider now a \u201ctype\u201d extension mechanism. In contrast to tasks, instances of new types must be usable inside a task attribution (arguments to tasks) wherever the described data should be used regardless of the type of task. Thus, the implementation of the task may not know about all possible types. Moreover, it should be possible to allow the description of different implementations for a dedicated parameter according to its specified base type.","In java, for example, this may be handled via inheritance. The method to be called may describe an expected type, but the caller may pass any derived type (with potentially different implementations). This may be achieved in java by the separation of the interface of a type and its concrete implementation. That is, the task may describe the interface required by a java base class or interface and the parsing framework may provide an appropriate instance at runtime.","In the description, such a task argument description may be handled by nested elements:",{"@attributes":{"id":"p-0019","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<mytask myattr=\u201da\u201d>"]},{"entry":[{},"\u2003\u2003<myargument anotherattr=\u201db\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/myargument>"]},{"entry":[{},"<\/mytask>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"To avoid such a result, note that Ant distinguishes between general nested elements that can freely be defined by beans and so called types. Each type supports the assignment of an explicit identifier and the definition of an instance outside of task sequences (e.g., a way similar to global variables in a conventional programming language). Such an identifier may be used as kind of variable name:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<typedef name=\u201dmytype\u201d class=\u201d...\u201d\/>"]},{"entry":[{},"<mytype id=\u201dmytypeid\u201d ...>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/mytype>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Additionally, note that each type may support an indirection. When specifying an instance of the type it is possible to specify only a reference to an already existing instance using its identifier (instead of describing all the attributes and nested elements locally). A data type may be prepared to forward its Application Programming Interface (\u201cAPI\u201d) to a foreign object retrievable by the specified identifier. Note that such an approach may only work if the implementation class of the effective foreign object is identical to (or derived from) the implementation class of the specified data type.","This approach may now be used to support polymorphism. For example, if the type returned by the creation method supports such indirection, any globally defined type can be assigned by reference as long it uses this type as base class:",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<myelement ...>"]},{"entry":[{},"\u2003\u2003<mynested ref=\u201dmytypeid\u201d\/>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/myeleemnt>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0025","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public NestedType createMyNested( )"]},{"entry":[{},"{...}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Such use of the standard behavior of dedicated type objects to achieve polymorphism, however, has disadvantages. For example, the approach may only work with the previous definition of global instances of a type. Moreover, it may not be possible to define the desired data fully as a nested element at the location where it is used, if the data type implementation class of the effective data type is different from the one used to describe the parameter.","As another approach, a special kind of setter might be used instead of a creation method. In Ant, these may be associated with methods starting with the term \u201cadd.\u201d As with creation methods, the name of the nested element may be extracted from the method name, but in this case the object is not created by the method. Instead, the \u201ctype\u201d of the parameter is used to determine the implementation class and the instance is provided by the framework.","Note that with respect to polymorphism, there may be little or no difference with the use of a special kind of setter as compared to the creation method. That is, both approaches might only allow control of the initialization of the nested element. Note also that this may now be done prior to the hand-over to the surrounding bean (although in the Ant tool this may not be the standard case, and may require a special setter starting with \u201caddConfigured\u201d).","Thus, the name of the nested element would be used for two purposes: (i) the name of the parameter, and (ii) the name mapped to an implementation class. As a result, instead of specifying the name of the nested element at the method level, the name might be taken from global type definitions. That is, the local method may only specify the base type (java type) that is required by the implementation. The implementation class may then be determined by the framework using the global name assignments to implementation classes to map a name of a nested element to a bean (and the type may only be used to validate the implementation type). In this case, it may need to be assignment compatible with the specified argument type:",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<typedef name=\u201dmytype\u201d class=.\u201d...\u201d\/>"]},{"entry":[{},"<myelement ...>"]},{"entry":[{},"\u2003\u2003<mytype ...\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003<\/mytype>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/myelement>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the Ant tool, the add and addConfigured methods without a name suffix may be used for this. Such an approach provide for polymorphism, because the concrete implementation is specified as part of the nested element. Note, however, that the surrounding bean has now lost the control of the naming of the nested elements, and therefore is not able to distinguish between different purposes or intended parameters for which a nested element may be used.","Note that any of these approaches may have significant disadvantages. For example, there may be a trade-off between allowing polymorphism and separating purposes for nested elements. Moreover, there may be globally unique names for types that can be used in a polymorphic manner. The unfortunate result may be, for example, that separate global namespaces are introduced for dedicated kinds of elements. Note, however, in one such area the same name might appropriate in different contexts for different things.","Consider, for example, a designer who wants to provide a general mechanism to describe properties. The designer might start with a property type:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Property {"]},{"entry":[{},"\u2003\u2003public setName(String name) {...}"]},{"entry":[{},"\u2003\u2003public setValue{String name) {...}"]},{"entry":[{},"\u2003\u2003public String getName( ) {...}"]},{"entry":[{},"\u2003\u2003public getValue( ) {...}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Later the designer discovers that he or she additionally needs a property pattern that can be used to match property values. Therefore, the designer also defines a base type:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class PropertyTemplate {"]},{"entry":[{},"\u2003\u2003public setName(String name) {...}"]},{"entry":[{},"\u2003\u2003public boolean match{String value) {...}"]},{"entry":[{},"\u2003\u2003public String getName( ) {...}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class SimplePropertyTemplate extends PropertyTemplate {"]},{"entry":[{},"\u2003\u2003public setName(String name) {...}"]},{"entry":[{},"\u2003\u2003public boolean match{String value) {...}"]},{"entry":[{},"\u2003\u2003public setValue{String name) {...}"]},{"entry":[{},"\u2003\u2003public String getName( ) {...}"]},{"entry":[{},"\u2003\u2003public getValue( ) {...}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The designer may then want to select a type name for this, only to discover that the most useful name (\u201cproperty\u201d) is already taken by the mapping to the class Property. So the designer instead has to choose a less useful name, such as \u201csimplepropertytemplate.\u201d In both cases a data type is expected, so the coarse grained fixed namespaces provided by Any may not be used. But in parsing contexts requiring a Property, the name property should be mapped to a Property instance, and when a PropertyTemplate is requested, a mapping to a SimplePropertyTemplate would be useful.","As still another approach, interfaces might be used instead, in which case the designer might change the implementation of the initial Property class to also implement this interface. Even this approach, however, has significant disadvantages. Note, for example, that the implementation must be sharable (e.g., existing implementations being adopted to newly created interfaces to achieve a desired result). Moreover, an initial implementation may need to be modifiable in a development context to be extended to support new arising interfaces.","As a consequence, in modular environments it may be advantageous to choose the names for dedicated evaluation contexts described by the surrounding bean. This may be helpful because the surrounding bean describes the meaning for nested elements (and therefore for the interpretation of the names of XML tags).","To alleviate problems inherent in the prior art, some embodiments of the present invention introduce systems, methods, computer program code, and means to improve name schemes in a parsing framework. Note that many text-based descriptions used to configure behavior of dedicated tool execution (e.g., to automate a software build process) are associated with a single namespace. Moreover, the manual definition of explicit, separate namespaces for different pre-defined contexts may be impractical. Note that an evaluated context may be specified, for example, as base type extracted from the method parameter. The problem may be how to map this base type to a dedicated context out of an extensible set of contexts.","According to some embodiments, such contexts may be associated with distinguished base types. Those contexts may, for example, describe categories forming a net of super-categories and sub-categories analogous to the assignment compatibility among the associated base types. Each category may build a namespace that inherits the namespaces of its sub-categories, and a namespace may include all mappings of the namespaces of all appropriate sub-categories.","When defining a new type by assigning an implementation to a name, this implementation class may be assigned to all categories for which it is applicable. A category may be applicable, for example, if the implementation class is assignment compatible with the associated base type. Moreover, all those categories may get an entry for the assigned name. The type implementation will be available in all those categories with the same name, but the name may remain free with respect to other categories.","Thus, the relationships among categories (and therefore namespaces) may be automatically manageable according to the inheritance relationships of the associated classes. In addition, categories may be defined like types by an assigned class or interface.","Note that such a model may be independent of java or java classes. In general, there may be interface and implementation elements that provide a relation AssignmentCompatible that is used to calculate the sub-category relation, and each declared category may be associated with such an element. For example, a category C may be a sub-category of C if and only if the associated element of C is assignment compatible with the associated element of C.","Consider, by way of example only,  which illustrates a block diagram of a system  in accordance with some embodiments of the present invention. The system  might, for example, comprise a platform or engine that includes a processor , such as one or more INTEL\u00ae Pentium\u00ae processors, coupled to a communication device  configured to communicate via a communication network (not shown in ). The communication device  may be used to exchange information, for example, with one or more remote devices. Note that elements described herein as communicating with one another may be directly or indirectly capable of communicating over any number of different systems for transferring data, including but not limited to shared memory communication, a local area network, a wide area network, a telephone network, a cellular network, a fiber-optic network, a satellite network, an infrared network, a radio frequency network, and any other type of network that may be used to transmit information between devices. Moreover, communication between devices and\/or systems may proceed over any one or more transmission protocols that are or become known, such as Asynchronous Transfer Mode (ATM), Internet Protocol (IP), Hypertext Transfer Protocol (HTTP), and\/or Wireless Application Protocol (WAP).","The processor  is also in communication with an input device . The input device  may comprise, for example, a keyboard, a mouse, or computer media reader. Such an input device  may be used, for example, to enter information about an automated software build process. The processor  is also in communication with an output device . The output device  may comprise, for example, a display screen or printer. Such an output device  may be used, for example, to provide reports and\/or display information associated with an automated software build process.","The processor  is also in communication with a storage device . The storage device  may comprise any appropriate information storage device, including combinations of magnetic storage devices (e.g., hard disk drives), optical storage devices, and\/or semiconductor memory devices such as Random Access Memory (RAM) devices and Read Only Memory (ROM) devices.","The storage device  stores a program  for controlling the processor . The processor  performs instructions of the program , and thereby operates in accordance any embodiments of the present invention described herein. For example, the processor  may arrange for categories and an associated category graph may be determined for a parsing framework. Moreover, a type for the parsing framework may be defined, wherein at least one category is automatically created and inserted into the category graph for an implementation element of the defined type. Namespaces may be \u201cautomatically\u201d defined by the processor  for the categories based at least in part on inheritance relationships associated with the categories in the category graph. As used herein the term \u201cautomated\u201d indicates that at least some part of a step associated with a process or service is performed with little or no human intervention.","As used herein, information may be \u201creceived\u201d by or \u201ctransmitted\u201d to, for example: (i) the system  from other devices; or (ii) a software application or module within the system  from another software application, module, or any other source.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 2","FIG. 1"],"b":"100"},"At , categories may be defined with respect to a parsing framework. For example, a category graph (or tree) with associated namespaces may be extended and managed as appropriate. Note that such a category graph may be associated with a generic category \u201croot\u201d or super-category of all categories. The root category may, by definition, have an empty namespace (e.g., all added name mappings may be ignored). Moreover, when a new category is created, it may be inserted into the category graph as direct child of all categories in the graph that (i) are a super-category and (ii) do not have a child that is a super category of the new category. Moreover, all siblings of the newly inserted category, that are sub-categories of the newly inserted category, may be moved to be direct children of the newly inserted category.","According to some embodiments, each category may have an assigned namespace, and the namespace of a category may always contain all entries of all direct sub-categories (except the for the root category). Moreover, according to some embodiments, the mapping provided by the namespace may be unique. That is, there may not be two direct sub-categories of a category whose namespaces contain different mappings for the same name.","At , types may be defined in connection with the parsing framework. For example, new types may be added to the parsing environment as extensions. According to some embodiments, a type definition may be provided such that a category is created for the implementation element of a type declaration. This category may then be inserted into the category graph as appropriate (if not already present). Also note that a type declaration may be valid if the assigned name is not yet valid for all categories for which the implementation element is applicable. Note that, as a result, the categories might not be explicitly defined, but instead build up automatically according to the defined types.","At , a category may be requested for a given parameter interface element. For example, for a dedicated context given by the interface element of a parameter, the appropriate category may retrieved to identify the namespace to map a name given by the XML tag to an implementation. The parsing framework may then use the specification of interface or implementation elements with the required formal parameter. The category of this element may be inserted into the category tree (if not already) present yet. Note that each parameter type may therefore implicitly set up a separate category. The namespace of this category may be used to identify nested elements as arguments (and to map them to implementations). Further note that information might not be explicitly defined, but instead build up automatically (e.g., a category graph may be built up by parameter types used for parsing).","Note that an extensible parsing framework that allows adding and\/or identification of abstract types will typically use pre-defined namespaces to de-couple a consumer of abstract types and a provider of concrete types. As a consequence, names for concrete types share a common namespace and thus cannot be selected freely depending on usage contexts. According to some embodiments described herein, an extensible parsing framework is provided that allows adding and\/or identification of abstract types by automatically configured category-based namespaces. The categorization may be performed, for example, using java reflection. Such categorization may allow a de-coupling of consumers and providers of concrete types without the need for pre-defined global namespaces.","Such an embodiment may let the same implementation meet several categories and be available with the same name in all applicable contexts. Moreover, disjoint contexts may be represented by categories that feature automatically separate namespaces. In addition, there might be aggregative categories that join different super-categories (note that this may effectively lead to a joint namespace for the concerned super categories). Furthermore, according to some embodiments, the type compatibility for the parsing may be determined automatically from the assignment compatibility of the interface and implementation elements.","Consider, by way of example, an application using java class based categories that are described by java interfaces featuring multiple inheritance or simple base classes to build a category graph. Note that a dedicated-type implementation may include a java class with multiple category interfaces (or extend a single base class of a category) for which it is applicable. Consider, for example,  which is a category graph  illustrating associated interface inheritances in accordance with some embodiments of the invention. The graph includes a <root> element with various interfaces defined in a class hierarchy. For example, node \u201cIB\u201d of the graph  is associated with nodes \u201cIF_A\u201d and \u201cIG_BC\u201d as illustrated tin .","With respect to interfaces intentionally used as categories, there may be an explicit statement to define categories (as is the case in connection with types and tasks for the Ant tool). Such an approach may increase the understandability of the implementation, but may not be required because the systems may configure itself automatically according to the used parameter types. The explicit definition of categories also have an advantage in that potential name clashes might be detected when new types and categories are initially defined (and later when a parameter type is first used).","In addition to the category graph information , the storage device  of the system  illustrated in  may further store a type definition database . One example of such a database  that may be used in connection with the system  will now be described in detail with respect to . The illustration and accompanying descriptions of the databases presented herein are exemplary, and any number of other database arrangements could be employed besides those suggested by the figures.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 4","b":["400","402","404","406","402","404","406","400"]},"The type  may be, for example, an alphanumeric code associated with an extension that may be added to a parsing environment (e.g., \u201cType0\u201d or \u201cType1\u201d or \u201ccom.sap.Type0\u201d). The category  may represent one or more nodes from the graph  that will be implemented for that particular type . The implementation name  may, for example, represent a name assigned to that particular type and\/or category . For example, as illustrated in , \u201cType 2\u201d may implement node \u201cIH_ACD\u201d and be associated with an implementation name of \u201cT2.\u201d","Based on the category graph  and the information in the type definition database , namespaces usable for the parsing may be determined as appropriate. For example,  is a tabular view of a namespace database  in accordance with some embodiments of the present invention. The table includes entries associated with categories of a parsing framework. The table also defines fields , ,  for each of the entries. The fields specify: a category , a name , and an implementation . The information in the database  may be periodically created and updated based on information in the graph  and the type definition database .","The category  may be, for example, an alphanumeric code associated with one or more nodes in the graph  and may be based on, or otherwise associated with, the category  in the type definition database. For each category , the namespace database  may associate one or more names  and\/or implementations  that are usable for parsing. For example, in connection with category \u201cIB,\u201d the namespace database associates both the name \u201cT1\u201d (and implementation \u201cType1\u201d) and the name \u201cT3\u201d (and implementation \u201cType3\u201d) as being usable for parsing.","Thus, embodiments may provide automatically configured namespaces (e.g., instead of a fixed number of interpretation contexts). Such embodiments may, for example, be used in a test framework for processes to describe a structure of intended build results and\/or to compare them against actual results. For example, some embodiments may be associated with a transformation of an XML document to a document object model structure.","Note that in XML-base parsing frameworks, such as the Ant tool, it may only be possible to derive either a parameter name or an argument type from a java bean to map an XML-based description to a bean graph. As a result, a designer may need to manually address this limitation. According to some embodiments described herein, both kinds of information may be combined to automatically parse multiple levels of nested XML elements without the need of an explicit, manually implemented work around.","Note that with respect to polymorphism, two kinds of information may be required: (i) a name for a nested element, and (ii) a name for an argument. For example, a name for a nested element that can be used to determine the implementation (according the applicable namespace to map names to implementations) may be needed. This name may chosen by the designer or developer of the description\/script according to the type definitions and his or her needs. Similarly, a name for an argument describing the purpose of the argument in the scope of the requesting object (that will receive the parsed object) may be needed. Note that the same technical parameter type (for example, a path-like type in Ant) may be used to describe values for totally different purposes (for example a compilation class path and source path). As a result, an argument category is typically not sufficient to specify the full purpose of usage of the argument.","In the Ant tool, an argument is described by a nested XML tag. Either (i) a name derived from a java method name is chosen to enforce a dedicated name to specify the parameter, or (ii) the argument type is used to find an implementation according to the tag name and the used namespace for implementation mappings. Note that both kinds of information cannot be described at the same time (and by the same XML element), such as by the name of the XML tag.","According to some embodiments of the present invention, the two kinds of information may be combined and determined during reflection of the class of the hosting object to use both: (i) a name of the parameter determined by the method name, and (ii) a category for the implementation type mapping according to any of the embodiments described herein at the same time. Such an automatic mechanism of the parsing framework may comprise, for example, using two nested element levels (e.g., instead of one).",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 6","b":["602","604"]},"For example, an additional setter may be used that specifies both a name and a base type. The name may be used to specify a parameter tag name and the type may be used to provide the base type for the implementation selection of the argument with an additional nested element:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void addArgumentMyPurpose{BaseType value) {...}"]},{"entry":[{},"public void addArgumentMyOtherPurpose{BaseType value) {...}"]},{"entry":[{},"<typedef name=\u201dmytype\u201d class=.\u201d...\u201d\/>"]},{"entry":[{},"<myelement ...>"]},{"entry":[{},"\u2003\u2003<mypurpose>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<mytype ...>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/mytype>"]},{"entry":[{},"\u2003\u2003<\/mypurpose>"]},{"entry":[{},"\u2003\u2003<myotherpurpose>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<mytype ...>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/mytype>"]},{"entry":[{},"\u2003\u2003<\/myotherpurpose>"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"<\/myeleemnt>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Note that two pieces of information may be required: the name of the parameter the argument should be used for and the data type used as argument value. Thus, two nesting tag levels may be used. The first one may be for the parameter name and the second one as the name of the data type to be used as argument value.","According to some approaches, this may be done using the Ant build tool and\/or by using a manually implemented additional bean to for the parsing of the additional element. In connection with some embodiments of the present invention, this may now be done automatically without the need for development work by a developer.","In some cases, another kind of method is used by reflection to extract the two kinds of information: (i) the name of the parameter from the method name (which in the above example is MyPurpose and MyOtherPurpose), and (ii) at the same time the parameter type is used to specify the category and the namespace for the data type of the required value. The parsing framework now uses both elements (in contrast to only one, as before) to automatically parse two nesting levels just described by evaluating one bean and one bean method.","Note that the same tag name, wherever it appears (e.g., as nested tag or somewhere else in the XML document) may refer to different namespaces and may therefore be resolved to different data types. The resolution and the determination of the namespace may be controlled by the bean used for parsing of this tag that is determined by the surrounding tag. For example:",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<some tag> --->","mapped to a (surrounding) bean, controlling the"]},{"entry":[{},{},"parsing of the nested tags"]},{"entry":[{},"\u2003\u2003\u2002<tag> --->","namespace determined by the surrounding"]},{"entry":[{},{},"bean"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2002<\/tag>"]},{"entry":[{},"<\/some tag>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The following illustrates various additional embodiments. These do not constitute a definition of all possible embodiments, and those skilled in the art will understand that many other embodiments are possible. Further, although the following embodiments are briefly described for clarity, those skilled in the art will understand how to make any changes, if necessary, to the above description to accommodate these and other embodiments and applications.","For example, although embodiments have been described as being used to implement XML described frameworks any other type of parsing framework may be associated with the present inventions. Moreover, although particular types of category graphs and namespaces have been described, embodiments may be associated with any other type of appropriate parsing framework.","Further, in some embodiments described herein a first extensible mark-up language tag is associated with a first namespace and a second extensible mark-up language tag, nested with respect to the first extensible mark-up language tag and having the same name as the first extensible mark-up language tag, is associated with a second namespace separate from the first namespace. Note, however, that embodiments are not restricted to nested elements only, For example, each parsing context described by a surrounding element may use another namespace for parsing, regardless of its location in the XML element graph.","The several embodiments described herein are solely for the purpose of illustration. Persons skilled in the art will recognize from this description other embodiments may be practiced with modifications and alterations limited only by the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
