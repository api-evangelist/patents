---
title: Application building
abstract: The described implementations relate to unified application building. In one implementation unified application building tools can include a unifying component model configured to communicate with a set of components that are supported by different frameworks. The unified application building tools can also include a unification engine configured to bind events between individual components in a unified manner that is independent of an individual framework upon which individual components are supported.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930879&OS=08930879&RS=08930879
owner: Microsoft Corporation
number: 08930879
owner_city: Redmond
owner_country: US
publication_date: 20090603
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The role of the computer continues to expand from desktop to notebook to netbook to personal digital assistant (PDA) to cell phones and smart appliances. With the expanding role of the computer comes increasing demand for applications, such as device specific applications and web-based applications. Providing a pleasing User Experience (UX) for these applications continues to be a challenging task. Two major factors in this difficulty are the way UX designers work within the software development process and the difficulty of building modern applications whose quality level (lack of bugs) is high enough to ship. For instance, it can be difficult to focus on creating a pleasing UX when most of the resources go into fixing bugs.","Building applications today is a complex, expensive, and risky process, involving several phases, such as user\/technology\/market research, user experience (UX) design, architectural design, specification, programming, localization, testing, bug fixing, etc. A potentially problematic path (and perhaps the most complex phase) is the programming\/testing\/bug fixing path. The UX design is typically done relatively early in the process and removed from the working code. When the UX design is complete, it is transferred to the developers so they can \u201cimplement it\u201d in the code. This means that although the UX design is created by the designer, it is then \u201cowned\u201d by the developer. There are several potential problems with this paradigm.","The first potential problem is that the UX design is subject to changes made by the developer. For instance, the developer may make changes in order to make the programming easier, to adjust the design to the programmer's opinion of what works best, and\/or to define what happens in cases not anticipated by the UX designer. Second, as the design becomes real and tested by users, it usually requires adjustment. This adjustment is either done directly by the developer (since he now \u201cowns\u201d the design), or by the UX designer in a design environment that is isolated from the working code and then the adjustment is then transferred (and owned) by the developer.","Another potential problem is that as the individual features in the UX come together to make a whole application, it is potentially difficult to make UX adjustments across the whole application (based on problems discovered by real-code testing by users). The present concepts relate to unifying application building tools that address the above mentioned (and\/or other) shortcomings of the existing paradigm.","The described implementations relate to unified application building. In one implementation unified application building tools can include a unifying component model configured to communicate with a set of components that are supported by different frameworks. The unified application building tools can also include a unification engine configured to bind events between individual components in a unified manner that is independent of an individual framework upon which individual components are supported.","The term unified application building tools may refer to device(s), system(s), computer-readable instructions (e.g., one or more computer-readable media having executable instructions), component(s), module(s), and\/or methods, among others, as permitted by the context above and throughout the document. In various instances, unified application building tools may be implemented as hardware, software, firmware, or combination thereof. The above listed examples are intended to provide a quick reference to aid the reader and are not intended to define the scope of the concepts described herein or the subject matter claimed.","Overview","This patent application relates to building applications using unifying application building tools. In some implementations, the unifying application building tools can generate a selectively-automatic integrated development environment (IDE) for application building. The selectively-automatic IDE can include a set of programs that can be run from a single user-interface to build an application. For example, the selectively-automatic IDE can offer a unified text editor, a unified compiler and a unified debugger, which can all be activated and function from a common menu, such as a toolbar.","Viewed from another perspective, some of the unifying application building tools can create a standardized or unifying component model for a user. The unifying application building tools can offer the user a set of user-specific components from which to build an application. The user can select some of the components to build the application. The user can also combine components to create new components to build the application.","The unifying component model can offer a unified way for the user to interact with components that is independent of a framework supporting individual components. Thus, the user can simply learn how to use the unifying component model rather than learning how to interact with various different component frameworks. Further, in some implementations, the standardized component model can enable components to work together regardless of their differing frameworks. The standardized component model can also allow user-selected components to work together with reduced (or potentially no) programming. In some implementations the unifying application building tools can utilize a new \u201cflow\u201d language to unify components and interactions between components.","First Example of Unifying Application Building",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIGS. 2-4"],"b":["100","100","102","102"]},"Block  can present a set of domain-specific components at a level of abstraction consistent with the domain. For instance, the user may want to work at a high level of abstraction or at a low level of abstraction. A high level of abstraction can be offered where many of the details regarding components and component interaction are handled automatically for the user. A low level abstraction environment can be offered to the user with increased granularity. Increased granularity exposes more details about the components, and their interactions to the user. Briefly, a higher level of abstraction can offer the user a shorter learning curve and a potentially shorter build time. In contrast, increased granularity can offer the user a higher degree of programmatic control but can be more time consuming. In some cases, a higher level of abstraction may be represented via a visual design(er) while a lower level of abstraction may be represented as corresponding programming text. One manifestation of block  is described below in relation to . Another example is described below relative to .","To summarize, the present implementation can allow the user to define a domain in which to build an application. The user can also define domain specific parameters, such as a level of abstraction that the user wants to work at; and\/or whether the user wants to work graphically or textually, etc. The unifying application building tool can facilitate the user in building the application based upon the user's selection(s).","First Example of a Unifying Application Building User-Interface",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIGS. 2-5","FIGS. 2-5"],"b":["1","2"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 3"],"b":["200","1","202","204","206","208","204"]},"The selectively automatic application builder can be thought of as being automatic in that it has the capability to perform many of the tedious programming functions, such as linking together components automatically for the user, and\/or providing unifying infrastructure, etc. However, the capabilities of the selectively automatic application builder can be applied at a level selected or defined by the user. For instance, the user can select to work at a very high level and the selectively automatic application builder can automatically handle all of the underlying tasks. Conversely, if the user selects to manually handle the programming details then the application builder only automatically handles any remaining tasks, such as providing the underlying unifying infrastructure.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["200","2","302","304","306","308"]},"The selectively automatic application builder  can allow the user to choose a level of abstraction for a selected domain. For instance, assume for discussion purposes, that the user is interested in building an architectural application and positions the cursor  over the architectural applications domain . Responsive to the cursor position, the selectively automatic application builder  can allow the user to select from multiple levels of abstraction as can be seen in .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4","b":["200","3","402","404","406","404"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 5","FIG. 4","FIGS. 11-21"],"b":["200","4","200","4","502","504","504","506","508","510","512","514"]},"Second Example of Unifying Application Building",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6","b":["100","1","100","1","602"]},"The process can create the set or components from any number of sources to create a library of components that may be useful to the user. For instance, the first set of components may be from a first source and utilize a first framework while the second set of components may be from a second source and utilizes and a second framework. One manifestation of block  is described below in relation to .","Block  can allow the user to interact with the components in a unified manner that is independent of both the first and second frameworks. This configuration can offer the user a wide selection of various components to utilize in building an application. Yet, the user's learning curve can be reduced since the user does not need to learn to interact with the different frameworks. One manifestation of block  is described below in relation to .","It is worth noting that the ability to be isolated from the particular framework can give the application the ability to run on different OS platforms. For instance, in some implementations, the application can be run on any OS platform that can support at least one of the frameworks that the unifying application building tool is built upon.","In summary, the unifying application building process can provide a generic manner for interaction with a set of components rather than relying on component-specific frameworks, such as the first framework or the second framework.","The order in which blocks  and  are described is not intended to be construed as a limitation, and any number of the described blocks can be combined in any order to implement the method or process, or an alternate method. Furthermore, the process can be implemented in any suitable hardware, software, firmware, or combination thereof, such that a computing device can implement the process. In one case, the process is stored on a computer-readable storage media as a set of instructions such that execution by a computing device causes the computing device to perform the process.","Second Example of a Unifying Application Building User-Interface",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 7","FIG. 8"],"b":["702","704","702","704","702","706","702","704","708","704","702","704"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 8-10","FIG. 7"],"b":["800","1","800","2","803","3","702","704","702","704","802","202","1","702","702","802","702","802","804"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 9","b":["800","2","702","902","804","202","1","904","702","706","702","706","702","904","702","202","1","904","802","802"]},"Further, some implementations can allow the user to select or customize what color picker he\/she wants to utilize. So for instance, if the user is familiar with, and\/or likes, color picker , then color picker  can be presented to the user regardless of which color component the user selects. One such example is illustrated in , which shows user-interface (). In this example, unifying application building tool () can provide the infrastructure to relay data between a user-selected color picker and the respective color component. In this case, assume that the user has previously specified that he\/she would like to use color picker . Also assume that the user selected color component  from component set . The unifying application building tool () can instantiate color component  in design space  with color picker  (rather than color picker  that is associated with color component ). The unifying application building tool () can supply underlying infrastructure or framework to allow the user's selections on color picker  to be properly received and understood by color component . Thus, the user can utilize his\/her color picker of choice with any available color component of the component set, without any requiring extra workload for the user.","For sake of brevity the above discussion uses the term \u201cuser\u201d in a generic fashion. However, the unifying application building tool () can dynamically adjust to suit the \u201cuser\u201d. For instance, early in the application building process, the user may be a \u201cdesign user\u201d. The unifying application building tool can allow the design user to select his\/her favorite color picker, say hypothetical \u201ccolor picker A\u201d. The unifying application building tool can then present the favorite color picker component to the design user for his\/her building activity.","At a subsequent date the \u201cdesign user\u201d could tell the unifying application building tool to replace all instances of \u201ccolor picker A\u201d with \u201ccolor picker B\u201d. For that point forward, the unifying application building tool can present color picker B for all color picking tasks and provides the underlying processes to support the change.","At a further point in time, such as when the build is complete, the design user could give way to the \u201cend user\u201d (i.e., the user running the completed app). The end user could tell the unifying application building tool to use \u201ccolor picker C\u201d for all color pickers in the application (or a set of applications). Alternatively or additionally, the unifying application building tool can allow the \u201cend user\u201d to take a \u201ccolor picker D\u201d that he\/she found in a first hypothetical application and use it in a second hypothetical application.","Further still, in some implementations, when a completed application is running on hypothetical platform xyz that does not support a specified framework-specific color picker, then the unifying application building tool could substitute another color picker (of equivalent functionality and API).","Of course this same sort of \u201cruntime reconfiguration\u201d could apply to other things. For instance, runtime reconfiguration can be applied to keyboard mappings. For example, consider a scenario where the end user tells unifying application building tool that all \u201cfile save\u201d operations in all of his\/her applications should be mapped to the \u201ccontrol S\u201d key combination). This can allow applications that are written by a wide variety of companies and developers to adapt to the specific background, knowledge, and preferences of the individual end-user.","In the above examples, the unifying interface supplied by the unifying application building tool () is described relative to how the user interacts with individual components. The unifying interface can also support other features that can be useful to the user. For instance, the unifying interface can allow debugging to be performed on the user's application (or portions) of the application regardless of the source of the components used in the application. In some configurations, visual debugging can be supported that allows the user to visually track the performance of the various components. So for instance, a visual representation can be created of the performance of individual components as well as another representation that shows the flow between components. In some cases, real-time dynamic representations of the debugging process can be presented on the user-interface for the user. Since the representations can reflect real-time dynamic changes as the debugging progresses, the representations may appear animated. As such, the real-time representations can be thought of as debugging animations.","To summarize, the unifying application building tool () can offer abstraction-level dependent visualization and animations of the application's components, (visualizing the data associated with the component interfaces (\u201cpins\u201d) as well as the interactions between components.","Third Example of a Unifying Application Building User-Interface",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIGS. 11-21","FIGS. 11-21","FIGS. 11-21"],"b":["1","2"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 11","b":["1100","1","1102","1104","1102","1106","1108","1110","1112","1114","1116","1106","1118","1110","1120","1122","1124","1118","1126","1128","1130","1120","1120"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 12","b":["1100","2","1202","1120","1204","1206","1208","1208"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 13","FIG. 12"],"b":["1100","3","1208","1104","1302","1208","1304","1","1306","1308","1310","1312","1314","1308","1314","1316","1308","1314","1318","1320","1308","1320","1102"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 14","b":["1100","4","1100","4","1402","1402"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 15","b":["1100","5","1204","1502","1104","1502","1","1504","1506","1508","1510","1512","1514","1502","1302","1516","1508","1518","1506"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 16","FIG. 17","FIGS. 18-19"],"b":["1100","6","1206","1120","1104","1602","1","1604","1608","1610","1612","1614","1610","1616","1514","1612","1702"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 18","FIG. 19"],"b":["1100","8","1100","8","1402","1802","1502","1802"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 19","b":["1100","9","1902","1802","1612","1514","1104","1110"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 20","b":["1100","10","2002","1110"]},"As mentioned previously,  relate to user-interfaces generated under the designer tab . In some implementations, the underlying selectively automatic application builder can write code that corresponds to the user selected components. The user can view the corresponding code during the application building process. Assume for purposes of explanation that the user wants to view the code that corresponds to the components shown in . The user can select the text tab  to view the corresponding text. Such a view is shown in .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 21","FIG. 20","FIG. 20","FIG. 20","FIG. 20"],"b":["1100","11","1108","2102","1104","2104","1304","2106","1502","2108","1602","2110","2112"]},"Any changes that the user makes to the code or text can be automatically reflected in the visual component representation (and vice-versa) by the underlying selectively automatic application builder. For instance, if the user makes changes to the text , the user can click on designer tab  to see the corresponding changes to the components in the design space. More detail regarding one way of implementing the text is described below under the heading \u201cFlow language details\u201d.","From one perspective, the designer tab  and the text tab  can be thought of as offering two different levels of application building abstraction to the user. For instance, if the user wants a higher level of abstraction, then the user can work in the designer tab. If the user comes to a point in the application build where he\/she wants more granularity (i.e., less abstraction), such as to have more precise control, then the user can switch to the text tab. The user can review and\/or change the text to his\/her satisfaction and then return to the designer tab if desired. In this case, a single user-input, in the form of a mouse click on either the designer tab  or the text tab , can allow the user to switch between the visual designer and textual representations. For the sake of brevity, only a few views are shown in the accompanying drawings. The skilled artisan should recognize that many other views are possible and effective with the present concepts. For example, there can be a 3rd \u201cUI\u201d view, where the design user sees the windows and controls as the end user would see them.","In summary, the above described user-interfaces can allow a single user to design and build an application at his\/her desired level of abstraction. The user-interfaces also present application building tools in a unified manner that is easier for the user to learn and interact with. The concepts presented in these examples can allow a single user to design and develop an application from start-to-finish and thereby avoid the shortcomings of traditional scenarios where the designer hands the project off to a developer who may or may not share the designer's vision. Stated another way, the present implementations can allow the developers to \u201chand off\u201d components to the designers. The designers can own the final working code UX.","Example of a Unifying Application Building Architecture",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 22","FIGS. 2-5"],"b":["2200","8","21","2200","2202","2202","2204","2206","2208","2200","2210","2212","2214","2216","2218","2220"]},"In this implementation, the selectively automatic IDE  includes a unifying visual designer , a unifying text editor , a unifying debugger , and a unifying compiler .","In this implementation, the technology frameworks  include one or more application program interfaces (APIs) . In this example, one API is represented at  between XNA and D3D. Another API is represented at  between Silverlight and AJAX. The skilled artisan should recognize other configurations. Also, in this implementation, hardware layer  includes storage  upon which computer-readable instructions can be stored and a processor(s)  for executing the computer-readable instructions.","The selectively automatic IDE  hosts unifying visual designer , unifying text editor , unifying debugger , and unifying compiler . Viewed from a different perspective, the unifying visual designer , unifying text editor , unifying debugger , and unifying compiler  support different features of the selectively automatic IDE  that can be utilized by the user in the application building process.","For purposes of explanation, a user can build an application utilizing the unifying visual designer . The selectively automatic IDE's unifying text editor  can generate a corresponding flow file  for the user's application. The unifying debugger can allow the user to view the progression of the application during execution. In some instance, the unifying debugger can provide a visual interpretation of the results produced by the application as it runs. Alternatively or additionally, the unifying debugger can show the progression from component to component as the program executes.","Flow file  is communicated from the selectively automatic IDE  to the unification engine . At run time, unification engine  runs the flow file  in light of flow language . Alternatively, the flow file can be compiled into a developer-oriented language like \u201cC++\u201d or \u201cC#\u201d. This can offer several potential benefits. For instance, the compiled flow file can offer faster code execution. The compiled flow file can be a \u201csealed\u201d deployment package (vs. deploying all the components\u2014needed for some situations). Further, developers can debug the application using their preferred language and toolsets. Finally, this configuration can offer a learning tool for teaching how high level system component usage works, in terms of underlying framework and languages.","Returning to the FIG., as the unification engine  runs the flow file , the unification engine consumes corresponding components from component library  via the standardized interface supplied by the unifying component model . As the unification engine  consumes components it can send instructions to API  in the technology framework  via the unifying component model . Viewed from another perspective, the unifying component model  can provide infrastructure to act as an interpreter between the unification engine  and APIs of the technology framework .","Unifying component model  can also allow the addition of different types of components to the component library . For discussion purposes, the component library can be thought of as an overall set that can include multiple sub-sets of components from different sources. An individual sub-set of components may rely on an underlying framework, such as a particular object model. When viewed in this manner, the unifying component model  can provide a unified object model and underlying infrastructure or framework that can interact with the different sub-sets and their object models as they are added to the component library .","The unifying infrastructure offered by the unifying component model  can allow other components of the architecture and\/or the user to interact with the components without knowledge about the components corresponding object model or framework. This configuration can result in reduced overhead for the end user when compared to existing configurations. For instance, in existing systems the user needs to learn the API for any library that he\/she wants to use in application building. For instance, Ajax may use one terminology and D3D or Silverlight another set of terminology. The present implementations can provide a common language that allows the user to use any tools in technology framework . For example, several different versions of a common language (for the same set of components) could be created cheaply to match the user's background and expertise level, using the unifying application building architecture's domain authoring tools.","The component library  can include visual D controls, 3D objects, data source components, data transform components, and data visualization components. In addition, 3rd party add-in component libraries such as (DLL's) can be defined, such as utilizing .NET classes. Lastly, components can be defined as custom components via unifying visual designer  and\/or unifying text editor .","Flow language  can be thought of as a way of defining components. Flow language can also define how components can be bound together to create new components and\/or applications. Details of one implementation are described below.","Flow Language Details","As introduced, some of the present concepts can be accomplished utilizing a \u201cflow\u201d language. The flow language can be utilized to build applications in \u201c.flow\u201d file format. Briefly, the \u201c.flow\u201d file can be used to persist the visual design of a user's application. The flow language can utilize categories to characterize components. The three categories are properties, methods, and events. Properties can be named values that effect how the component appears or behaves. Methods can be specific actions that the component can perform. Events can be thought of special messages that the component emits when certain conditions occur. Components can be controlled through instructions associated with these three categories.","A component can be given a \u201cclass name\u201d that can be used to identify a component within the component library. When the component is loaded into memory and ready to be used, it is called an \u201cinstance\u201d of the component. When the user creates an instance of a component the user gives it a \u201ccomponent name\u201d, for later referral. Multiple instances of a single component can be created, but each instance can be given a unique name.","Some implementations can use public methods but these implementations may not take parameters (they can use properties for this purpose) and they return their value through an \u201cOutput\u201d type property. The primary method of a component is usually named \u201cRun\u201d (or \u201cStart\u201d for asynchronous style components like animations).","Flow events can have two values associated with them. First, the \u201csender\u201d of the event (the object that triggered it). Second, the \u201cvalue\u201d of the event (data associated with the event). When an event is bound to a property and the event triggers, the property is set to the \u201cvalue\u201d data of the event.","The flow language can allow users to build applications by creating instances of predefined components, setting their properties, and building \u201cpipes\u201d that bind a \u201csource\u201d member to a \u201ctarget\u201d member. When a source member \u201cchanges\u201d, its data is sent thru the \u201cpipe\u201d to the associated target member.","Each line in a flow file can be one of these 4 types:\n\n","Below is a simple example of a ready-to-run flow file:",{"@attributes":{"id":"p-0079","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},";---- \u201ctest\u201d applet ----"]},{"entry":[{},"[Panel: mainPanel]"]},{"entry":[{},"Size = 100, 30"]},{"entry":[{},"Background = Yellow ;\u2003\u2003make it stand out"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The first line of the sample is a comment line (comments are ignored by the unification engine ). The second line of the sample is a blank line. The third line is a section line that creates a \u201cPanel\u201d object named \u201cmainPanel\u201d. The forth line is a property line that sets the \u201cSize\u201d property of \u201cmainpanel\u201d to the value \u201c100, 30\u201d. The fifth line is a property line that sets the \u201cBackground\u201d property of \u201cmainpanel\u201d to the color \u201cYellow\u201d. It also contains an \u201cend of line comment\u201d, denoted by the character.","Details Regarding Section Line","The syntax of a normal section line is:","\u201c[\u201d<class name> \u201c:\u201d<component name> \u201c]\u201d","where <class name> is the name of the component class (within the component library) to be created. The component can be defined in the component library, in an add-in library, or defined by a flow file (in the same directory as the current file, with the name of <class name>.flow). For example, a section could reference a class named \u201cfoo\u201d and the file \u201cfoo.flow\u201d would define the \u201cfoo\u201d class as a custom component.","The property lines appearing after a section line are called the section block. Some section blocks have special semantics including styles and states.","Style components can be thought of as \u201cproperty bags\u201d. The user can set any property and values on them and later apply all relevant property\/values to other components. The user can also specify an animation component when applying a style to an object to animate the value changes.","State components can apply their set of global property lines when they are loaded. A global property line is one in which the optional <component name> is specified.","Details Regarding Member Line","There can be five different forms of member lines including:",{"@attributes":{"id":"p-0088","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<property member> \u201c=\u201d <constant value>"]},{"entry":[{},"<source member>\u2003\u201c->\u201d <target member>"]},{"entry":[{},"<target member>\u2003\u201c<-\u201d <source member>"]},{"entry":[{},"<source member > \u201c\/>\u201d <target member>\u2003\u2003; remove the pipe"]},{"entry":[{},"<target member > \u201c<\/\u201d <source member>\u2003\u2003; remove the pipe"]},{"entry":[{},"<pin name>\u2003\u201c<->\u201d\u2003<target member>\u2003\u2003\u2003\u2003\u2003\u2003; create a"]},{"entry":[{},"\u201cPin\u201d binding from a name to a real property"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples of Member Lines:",{"@attributes":{"id":"p-0090","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003Size = 100, 30","; sets the \u201cSize\u201d property to the value"]},{"entry":"Width=100, Height=30,"},{"entry":["\u2003Clicked -> myMsg.Run","; binds the \u201cClicked\u201d event of the current"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"component to the \u201cRun\u201d method of \u201cmyMsg\u201d,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003Text <- mouse.Over","; binds the \u201cOver\u201d property of the mouse"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"object to current component\u2019s \u201cText\u201d property."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The first form, using the \u201c=\u201d operator, does a one-time assignment (at application load time, or state load time if the property line appears in a state block) of a constant value to the specified component property.","The second and third forms bind a source Property, Method, or Event of a component to a target Property Method, of another component. Meanings of each combination are outlined below:","Source Target Meaning",{"@attributes":{"id":"p-0094","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"P\u2003\u2003P\u2003\u2003\u2003\u2003when the source property changes, its value is"]},{"entry":[{},"assigned to the target property"]},{"entry":[{},"P\u2003\u2003M\u2003\u2003\u2003\u2003when the source property changes, the target"]},{"entry":[{},"method is called"]},{"entry":[{},"E\u2003\u2003P\u2003\u2003\u2003\u2003when the source event is triggered, its parameter"]},{"entry":[{},"value is assigned to the target property"]},{"entry":[{},"E\u2003\u2003M\u2003\u2003\u2003\u2003when the source event is triggered, the target"]},{"entry":[{},"method is called"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The syntax of a <property member> is:","[<component name> \u201c.\u201d]<property name>","The square brackets \u201c[ ]\u201d mean that the enclosed part is optional. When omitted, the name of the current component (defined by the most recent section line) is used. In the \u201cpins\u201d section block of property lines, <component name> is specified.","A <constant value> can be one of these values:",{"@attributes":{"id":"p-0099","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<component name>","(example: myButton)"]},{"entry":[{},"<quoted string>","(example: \u201chi there\u201d)"]},{"entry":[{},"<integer value>","(example: 32)"]},{"entry":[{},"<double value>","(example: \u200232.5)"]},{"entry":[{},"<Boolean value>","(example: true)"]},{"entry":[{},"<date time value>","(example: 12\/15\/2007)"]},{"entry":[{},"<enumeration value name>","(example: Easeln)"]},{"entry":[{},"<color name>","(example: LightBlue)"]},{"entry":[{},"<Point value>","(example: 3, 3)"]},{"entry":[{},"<Vector value>","(example: 13, 0)"]},{"entry":[{},"<Size value>","(example: 300, 200)"]},{"entry":[{},"<font family name>","(example: Tahoma)"]},{"entry":[{},"<font weight>","(example: Bold)"]},{"entry":[{},"<font style>","(example: Italic)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A <source member> is defined as:",{"@attributes":{"id":"p-0101","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[ <component name> \u201c.\u201d ] <property or event name> [ \u201c.\u201d"]},{"entry":[{},"<property name> ... ]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The square brackets \u201c[ ]\u201d mean that the elements are optional. So, in the simplest form, a <source member> is just the name of a property or event of the current component.","Optionally, if the property or event value is a component (and not a primitive value), the member name can be further qualified by a property name (which can be repeated as necessary to get to the final target value). For example:","Output.CustomerName->myText.Label","In the above example, the \u201cOutput\u201d event on the current component returns a record with several properties, one of them being \u201cCustomerName\u201d. This example binds that CustomerName field\/property to the Label property of myText. This means, when the \u201cRun\u201d method is called and returns a value, myText.Label is set the CustomerName property within that value.","A <target member> is defined as:","<component name> \u201c.\u201d<member name>.","The above flow language description can allow use of the flow language in the context of unifying application building and\/or or scenarios. The flow language can be easier to use than existing languages. Alternatively or additionally, functionalities can be described with flow language utilizing fewer characters of text than existing technologies.","Example of a System Configuration",{"@attributes":{"id":"p-0109","num":"0112"},"figref":"FIG. 23","b":["2300","2300","2302","1","2302","2","2302","3","2302","4","2302","5","2302","1","2304","1","2302","1","2304","1","2304","1","2302","1","2304","1","2304","1","2306","2302","1","2306"]},"In system , computing devices ()-() are shown communicatively coupled via a network , such as the Internet. In this case, computing device () can perform a client role and computing device () can perform a server role. A user of computing device () may want to build an application utilizing unifying application building techniques. As such, the user may install unified application building tools () on his\/her computing device (). Alternatively, the user may utilize unified application building tools () running on server computing device (). In still a further implementation, some of the functionality of the unifying application building techniques may be performed on the server computing device () and some of the functionality may be performed on client computing device () by installing a portion of the tools on each computing device.","Applications that are built utilizing unifying application building techniques can be utilized on the same or other computing devices. For instance, an application generated on computing devices () and\/or () can be loaded on, accessed from, and\/or run on computing devices () and\/or (). The term computing device, as used herein can apply to personal computers, other types of computers, such as Apple computers or UNIX computer. The term computing devices can also include netbooks, cell phones, smart phones, personal digital assistants (PDAs), cameras, headsets, media players, multifunction wristwatches, and smart appliances, among other ever-evolving types of devices.","Conclusion","Although techniques, methods, devices, systems, etc., pertaining to unified application building concepts are described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed methods, devices, systems, etc."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings illustrate implementations of the concepts conveyed in the present application. Features of the illustrated implementations can be more readily understood by reference to the following description taken in conjunction with the accompanying drawings. Like reference numbers in the various drawings are used wherever feasible to indicate like elements. Further, the left-most numeral of each reference number conveys the figure and associated discussion where the reference number is first introduced.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 2-5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 8-21"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
