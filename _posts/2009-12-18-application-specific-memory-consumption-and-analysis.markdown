---
title: Application specific memory consumption and analysis
abstract: Methods and systems are described that involve determining the memory consumption of a specific application. The memory analysis identifies the dynamic memory objects controlled by a particular application and the memory objects controlled by the framework running that application. A structured view of the memory objects of the framework with respect to the individual framework architecture is presented in combination with the application specific memory object graph. A resulting display, in the form of a dominator tree, allows detecting dependencies of the application to the framework and shows which part of the framework is responsible for keeping alive which part of the application. Moreover, the resulting structure shows memory consumption of a single element of the application including bound memory and object memory. Further, a user can identify the references and the dependencies among the memory objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08843526&OS=08843526&RS=08843526
owner: SAP AG
number: 08843526
owner_city: Walldorf
owner_country: DE
publication_date: 20091218
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to the software arts, and, more specifically, to methods and systems for application specific memory consumption and analysis.","In computing systems, memory analysis tools provide a user with the possibility to analyze memory shortages that source debuggers cannot detect. Moreover, they can help optimize long-term memory usage, thereby reducing Random Access Memory (RAM) requirements and ensuring that the system does not run out of memory for long periods after deployment. Even if a system appears to perform acceptably, a memory analysis tool can uncover hidden inefficiencies that when corrected, allow for substantial improvements in performance and memory usage. Sometimes it may be worthwhile to employ memory analysis tools, system profilers, and other system tracing tools throughout the entire development process. Not only will the user identify problems early (when the problems are much easier to correct), but this will also ensure that the system delivers all the features and performance that it is truly capable of supporting.","Memory analysis typically includes capturing memory-related events on the embedded target, importing that information into a development environment, and analyzing errors and areas that need optimization using a visualization tool.","Methods and systems are described that involve application specific memory consumption and analysis. In one embodiment, the method includes creating a set of new nodes representing a semantic tree structure to a memory object graph, wherein the semantic tree structure includes a hierarchical organization of elements and is an appropriate representation of the application framework with respect to memory consumption. A subset of memory objects is identified from a plurality of memory objects contained in the memory object graph. Further, the subset of memory objects is assigned to the set of new nodes in the memory object graph and thus a new semantic graph is generated including the semantic tree structure with the newly assigned subset of memory objects. Finally, the semantic graph is transformed into a dominator tree and the dominator tree is displayed in a user interface element.","In one embodiment, the system includes an application module, the application module including a set of elements, wherein the elements are organized in a semantic tree representing a hierarchical structure. The system also includes a memory object graph stored in a memory unit, wherein the memory object graph is expanded by adding a set of new nodes corresponding to the semantic tree. Further, the system includes a framework that runs the application, wherein the framework identifies a group of memory objects in the memory object graph and assigns the identified group of memory objects to the set of new nodes. The framework generates a semantic graph from the semantic tree and the assigned group of memory objects. Finally, a display unit shows the semantic graph as a dominator tree structure and provides memory consumption information.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for application specific memory consumption and analysis are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Memory analysis of applications could be a quite complex process. Since more and more applications are controlled by certain frameworks (for example, Web services applications may be controlled by corresponding Web services framework), a detailed memory analysis should cover memory objects controlled by the application itself and at the same time with a number of memory objects created by the underlying framework that runs this application. In an embodiment, the memory objects created by the underlying framework are separated from the memory objects used by the application. Further, a memory analysis tool may provide a structured view on the memory objects of the framework contained in a memory object graph, with respect to the architecture of each individual framework, in combination with the application specific memory objects structure. A resulting display provides a possibility for detecting all dependencies from the application to the framework and show which part of the framework is responsible for supporting which part of the given application.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["100","110","120","110","120","110","120","130","130","120","130","140","140","130"]},"Each layer in the hierarchical process  allocates memory from the layer below and provides memory to the layer above (when such layer exists). Usually, the entire amount of allocated memory is not provided to the next layer. Since memory allocation could be an expensive operation, frequent allocation requests should be avoided. Thus, a software layer may have algorithms implemented for a memory management sub-system with allocation strategy that satisfies frequent requests for a small amount of memory out of bigger chunks previously allocated. As memory is frequently freed and requested again, the memory management system has to search for appropriate chunks of memory. Often times, the recently freed chunk may not fit in the next request. This may lead to fragmentation of the managed memory. Further, a certain amount of memory may be needed for the administration in each software layer, which may depend on the amount of memory requested by the layer above. Thus, not all of the allocated memory may be provided to the next level. The memory assigned to each software layer of process  may be divided in two parts: used memory\u2014amount of memory that is used by the current software layer; and allocated memory\u2014amount of memory that is additionally allocated by the software layer located underneath the current layer due to own memory management algorithms, fragmentation, and alignment requirements.","The different software layers consume the memory via memory objects. Some of the memory objects are static, while others are dynamic. The static memory objects may include all global variables of all loaded programs in a system and all static attributes of all loaded classes of the programs. The dynamic memory objects include objects, of which instances can grow dynamically. For example, common objects such as class instances or strings, or specific objects such as anonymous data objects, internal tables, boxed components, etc. The anonymous data objects are dynamically (at runtime) created data objects such as simple fields, structures, internal tables, etc. An internal table is a dynamic array of a given line type including a structure with an arbitrary number of components, which can be simple types, structures, or again internal tables. Boxed components are implementations of structures, which can be used inside basic structures or classes; variables of boxed components point to structure values that can be shared. In an embodiment, the dynamic memory objects may have the following memory consumption values: object memory and bound memory. Object memory is the amount of memory that embraces the object itself, including all flat components (components with static size that can be stored in-place, no references to dynamic memory objects elsewhere) therein. For example, inside a class instance this is the sum of all flat attributes (or flat structures); inside an internal table this is the size of the sum of all flat components of the table line times the number of lines, The bound memory of an object is the object memory of the object itself plus the object memory of all objects bound to this object. The bound memory objects are those objects which are exclusively referenced (directly or indirectly) by a given memory object. Thus, the bound memory is that amount of memory that will be freed implicitly, if the given memory object is freed. For the object memory and bound memory consumption values, it is possible to distinguish which part of the value is used by the application and which part additionally contains the administrative data of the runtime framework for this particular memory object.","To analyze the memory consumption, the memory consumption values of the memory objects have to be calculated. However, calculating some of the memory consumption values may impose a performance penalty (i.e., it may not be possible to calculate the values frequently due to performance issues). This is due to the fact that the runtime framework of a system needs to walk through all memory objects, as part of a memory object graph, starting from the root memory object and continue to the referenced objects to determine the dependencies and calculate the memory consumption values of all memory objects. Depending on the number of memory objects involved and the complexity of the memory object graph, this procedure may take up to several seconds. Therefore, some memory consumption values are chosen for frequent and automatic determination of the current memory consumption, although they do not contain only application relevant memory, but may also contain kernel-internal administration data.","The number of memory objects, their dependencies and linkages may be needed to build the memory object graph. Some of the memory objects are dynamic\u2014they are created dynamically during runtime of an application. In an embodiment, the nodes of the memory object graph includes the different types of dynamic objects including, but not limited to: strings; internal tables; boxes (boxed components); class instances; and anonymous data objects. The nodes of the memory object graph are linked to each other by the nodes edges. The root nodes are kept alive (e.g., not being subjected to garbage collection) even if they are not referenced by any other memory objects. The memory object graph may be a complicated structure of nodes sometimes making it difficult to display the complete memory object graph on one screen. Some techniques display a part of the graph starting with one particular memory object, thus, this part of the graph would represent a tree of memory object dependencies; it can be displayed in both directions: referenced nodes (children) and referencing nodes (parents).","In an embodiment, the memory object graph may be transformed into a dominator tree. A dominator tree may be built on the basis of the memory object graph.  shows a set of examples of transforming a memory object graph into a dominator tree. The upper part of , including structures , , and , shows examples of memory object graphs. The lower part of , including structures , , and , shows examples of dominator trees corresponding to the graphs , , and  respectively. Each object in the dominator tree is responsible for keeping its children alive, thus it may also be called a \u201ckeep-alive\u201d tree. Further, in the dominator tree one object dominates a second object, if all paths from the roots to the second object run through the first object. For example, in dominator tree , object C  dominates objects F , G , and J .","Transforming an object graph into a dominator tree provides functionality such as: fast and easy calculation of the bound memory of an object by summing the object memory of all children nodes; fast and easy identification of any memory object by going through the tree, wherein the tree represents a compact version of the object graph. Further, the dominator tree provides: an easy way to find all depending memory objects (i.e., memory objects that are kept alive by one root object); easy identification of the root objects; easy identification of those memory objects, which are not essential anymore; and easy identification of those references to be deleted inside the application program to allow garbage collector to free the memory objects and thus lower the memory footprint of the application. The dominator trees can be used in memory consumption analysis for identification of memory consuming objects and the associated dominated objects therein. This could help to decide which objects can be deleted to save memory. Also, exact amount of memory to be saved could by provided by identification of the dominated memory objects, which will be deleted implicitly, if a specific memory object is deleted.","In an embodiment, memory consumption analysis includes providing information for the memory consumption of a specific application. The information may regard each entity (or a component) of an application and may include, but is not limited to: a list of depending memory objects; the sum of memory consumption of depending memory objects; and identification of the memory objects showing if an object belongs to the application or to the framework that runs the application.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3A"},"As an example, structure  represents a hierarchy containing a number of elements provided with application . In an embodiment, application  may be a Web modeling tool for user interfaces (e.g., view  and window ) that provides support when developing Web representation of business applications. The elements of the application may be reusable. Application  includes a number of elements including, but not limited to, a component interface  (e.g., for defining how a user can interact with an application), a view  (e.g., for describing the layout and behavior of a rectangular area of a user interface), a window  (e.g., for grouping together multiple views and view sets), and so on. Hierarchy  is a logical structure of nodes in the form of a semantic tree that represents the structural organization of the application  with respect to the specific framework running application . During runtime of the application , a memory object graph  is created containing runtime data for framework and application.","The memory object graph  contains all memory objects needed for the application  and for the underlying framework. During runtime, the semantic tree  is not explicitly given, but expresses implicitly the current status\/context of the framework running the application. When it comes to memory analysis, a memory analysis tool calls a framework specific functionality (framework call-back), which analyzes the current status\/context of the framework. This can be done either within a live analysis of a running application at a certain execution point or on the basis of an arbitrary memory snapshot after the execution. Live analysis may be done by debugging of the application. In this case, the application is stopped inside a debugger tool. The framework call-back is then implemented for the memory analysis tool inside the debugger and may use a debugger application programming interface (API) to analyze the status\/context. In another embodiment, the framework call-back can operate on a memory snapshot, which then needs to contain all the framework specific information for building the semantic tree. The framework call-back is in this case implemented inside a stand-alone memory analyzing tool, using another API dealing with the memory snapshot.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3B","b":["350","350","350","350","350"]},"Further, during status\/context analysis, the framework call-back checks the framework metadata to decide which memory objects from copied MOG B to be assigned to the nodes of the semantic tree . A semantic group of one or more memory objects can be assigned to a given semantic tree node. For example, the framework call-back identifies that memory objects , , and  are needed for node . The identification of the memory objects is framework-dependent, that is, the needed memory objects are selected based on the context of a given framework.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3C","b":["355","350","350","365","380","390","350"]},"The copied MOG B (and the original MOG ) may be a directed graph (a graph with edges that point in one direction) or an undirected graph. In a directed memory object graph, both directions for the edges of the identified memory objects (pointing from and to the identified memory objects) can be suspended. The framework call-back of a given application decides which edges of which direction to be suspended. In an embodiment, the direction of the edges pointing from the other memory objects in the original graph to the identified memory objects is suspended. In  memory objects ,  and  are identified by the framework call-back. Edges to memory objects  and  from other memory objects of the MOG B are suspended and memory object  is assigned directly to node  of the semantic tree. For example, the references from memory objects  and  to memory object  and  respectively, are suspended, while the references from memory objects  and  to memory objects  and  remain unsuspended. In an embodiment, just some of the identified memory objects are assigned; in alternative embodiment, all identified memory objects are assigned. The framework call-back functionality decides which of the identified memory objects , , and  to be directly dependent from the semantic tree nodes and which indirectly dependent (i.e., to be dependent from the directly dependent memory objects. For example, memory objects  depends directly from node  and memory objects  and  depend from memory object . After the assignment is performed for all nodes of the semantic tree, a new semantic graph is formed with the semantic tree nodes as root nodes and the memory objects as representatives of the original object graph  with suspended edges and new assigned edges to the semantic nodes.","In an embodiment, the new semantic graph is transformed into a dominator tree and all functions of the dominator tree can be used. The nodes of the semantic tree are integrated as root nodes of the dominator tree and the direct and indirect memory objects are organized as framework memory objects (e.g., memory objects that belong and are used by the underlying framework), dominating the rest of the memory objects from the memory object graph. Using the dominator tree, a user can easily identify how much memory consumption is associated with a specific node or calculate the bound memory of an object. For example, a user can identify: how much memory view  element of application  consumes; which dependent memory objects are used by the framework; which dependent memory objects are used by the application , and so on.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["405","410","412","415","420","425","430"]},"At block , the resulting semantic graph is transformed into a dominator tree structure. In an embodiment, the dominator tree is displayed in a user interface component, at block . The dominator tree shows the nodes of the tree corresponding to elements of application . Further, the dominator tree shows memory consumption for each particular element of the application . Since the complete tree is a dominator-like representation, the referenced memory objects are represented in a keep-alive tree as the lower tree levels may be unfolded. More levels can be unfolded to show the memory objects that belong to the application and the memory objects that belong to the framework. There may be memory objects lying on the same level as the root application node, those objects cannot be assigned to any single application element node below the root node, but are used by at least two of the application elements' nodes located on the same level. Further information may be provided regarding all references of the listed memory objects, including their bound memory (used and allocated) and the object memory (used and allocated).","Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable medium as instructions. The term \u201ccomputer readable medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer-readable media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","b":["500","500","505","555","500","540","555","510","515","510","515","505","515","500","525","530","500","525","530","500","535","500","550","550","500","545","500","520","560","560","560","550","560"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5","b":"500"}]},"DETDESC":[{},{}]}
