---
title: Pluggable authentication modules for telecommunications management network
abstract: A system and method for authenticating users over a network. At least one pluggable authentication module (PAM) is used to authenticate users of network services. Each PAM includes a client-side authentication library and a server-side authentication library which may each be implemented in accordance with a specification expressed in an interface definition language (IDL), wherein the IDL is operable to define interfaces across a plurality of platforms and programming languages. The client-side authentication library is implemented for a particular client platform and deployed on the client computer system to provide a client-side interface to retrieve and encrypt a user profile. The server-side authentication library is implemented for a particular server platform and deployed on the server computer system to provide a server-side interface to receive the encrypted user profile from the client-side authentication library and decrypt the user profile to authenticate the user for network services. The client-side authentication library may be shared by a plurality of management applications and the server-side authentication library may be shared by a plurality of gateway components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06950935&OS=06950935&RS=06950935
owner: Sun Microsystems, Inc.
number: 06950935
owner_city: Santa Clara
owner_country: US
publication_date: 20000421
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates generally to computer software. More particularly, the present invention relates to software for authenticating users of network resources.","2. Description of the Relevant Art","The field of network management involves the management of networked devices, often remotely. A computer network is a linked group of two or more computers. Generally, networks may be classified as Local-Area Networks (LANs) or Wide-Area Networks (WANs). In a LAN, the computers or devices are typically connected together within a \u201clocal\u201d area such as a home, office, or group of offices. In a WAN, the computers or devices are typically separated by a greater distance and are often connected via telephone\/communication lines, radio waves, or other suitable means of connection.","Networks are usually classified using three properties: topology, protocol, and architecture. Topology specifies the geometric arrangement of the network. Common topologies are bus, ring, and star configurations. A network's protocol specifies a common set of rules and\/or signals, such as Ethernet or Token Ring, which the networked devices use to communicate with each other. A network's architecture typically specifies one of the two major types of network architecture: peer-to-peer or client\/server. In a peer-to-peer networking configuration, there is no server, and computers simply connect with each other in a workgroup to share files, printers, services, and Internet access. Client\/server networks often include a domain controller to which all of the networked computers log on. This server may provide various services such as centrally routed Internet access, e-mail, file sharing, printer access, and security services.","Many types of devices may be managed over a network, such as printers, scanners, phone systems, copiers, and many other devices and appliances configured for network operation. Typically, such devices are managed via requests and events. A request is a message sent to a managed object. A request may be sent by a manager application to a managed object to query the object about a particular parameter associated with the object. A request may also be sent to a managed object to modify a parameter of the object. Alternately, an event is a message originating with a managed object. Events may be sent by managed objects to signal some change of state of the managed object, or to communicate information about the managed object. Managing such devices tends to require that the data types of each device's control parameters and signals be well defined. For example, a networked printer might have a Boolean status parameter which indicates whether the device is currently on or off and a control parameter which turns the printer on or off. A manager application may send a request to determine the on\/off status of the printer. Then, once the status is determined, say, to be off, a subsequent request may be sent to modify the control parameter to turn the printer on. The printer may also be capable of generating an alert signal indicating, for example, that the toner level is low. In this case, an event communicating that fact may be sent by the managed object (the printer) to the appropriate manager application.","The network management software should be able to read and write these data correctly in order to manage the device. To do this, information about the data is required. Such information is referred to as metadata, or \u201cdata about data.\u201d Metadata may typically describe what type of data (string, integer, Boolean, structure) an object has and how the data are formatted. Metadata is essential for understanding information related to managed devices, as well as information stored in data warehouses. Typically, network management software manages a given device by storing and manipulating a representation of its pertinent data as a software object, herein referred to as a \u201cmanaged object.\u201d This object is the virtual representation of the device on the network.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 1","FIG. 1"],"i":["a ","a","a","a","b","n","b","a","a","b","n"],"b":["156","151","152","153","154","155","108","150","170","160","150","170","171","171","171","160","170","108","150","108","160","161","161","161","160","170","160","150"]},"One TMN approach to managing objects over a network is the Simple Network Management Protocol (SNMP), a set of protocols for managing complex networks. SNMP works by sending messages, called protocol data units (PDUs), to different parts of a network. SNMP-compliant devices, called agents, store data about themselves in Management Information Bases (MIBs) and return this data to the SNMP requesters. The metadata used by SNMP to describe managed object data variables includes the variable title, the data type of the variable (e.g. integer, string), whether the variable is read-only or read-write, and the value of the variable. SNMP works over the TCP\/IP (Transport Control Protocol\/Internet Protocol) communication stack. SNMP also uses UDP over IP, and also may support TCP over IP. It is widely held, however, that SNMP was developed as a simple \u201cquick fix\u201d and was never intended to be a permanent solution to network management. Consequently, one problem with SNMP is that the information it specifies is neither detailed nor well-organized enough to adequately serve the expanding needs of modern networking.","Another example of a TMN network management protocol is the Common Management Information Protocol (CMIP). In the U.S. the CMIP protocol is primarily run over TCP\/IP, while in Europe it is generally run over the OSI (Open Systems Interconnection) communication stack and was designed to replace SNMP and address SNMP's shortcomings by providing a larger, more detailed network manager. Its basic design is similar to SNMP: Management requests, management responses, and notifications are employed to monitor a network. These correspond to SNMP's PDUs. CMIP, however, contains eleven types of messages, compared to SNMP's five types of PDUs.","In CMIP, variables are seen as complex and sophisticated data structures with many attributes. These include: variable attributes, which represent the variable's characteristics (e.g., its data type, whether it is writable); variable behaviors, or the actions of that variable that can be triggered; and notifications, or event reports generated by the variable whenever a specified event occurs (e.g., a terminal shutdown would cause a variable notification event).","As a comparison, SNMP only employs variable attributes and notifications, but not variable behaviors. One of the strongest features of the CMIP protocol is that its variables not only relay information to and from the terminal (as in SNMP), but they can also be used to perform tasks that would be impossible under SNMP. For instance, if a terminal on a network cannot reach its fileserver for a predetermined number of tries, then CMIP can notify the appropriate personnel of the event. With SNMP, a user would need to explicitly keep track of the number of unsuccessful attempts to reach the fileserver. CMIP thus results in a more efficient network management system, as less work is required by a user to keep updated on the status of the network.","A significant disadvantage of the CMIP protocol is that it requires more system resources than SNMP, often by a factor of ten. Thus, any move to CMIP from SNMP requires a dramatic upgrade in network resources. Another disadvantage with CMIP is that it is very difficult to program; the variable metadata includes so many different components that few programmers are generally able to use the variables to their full potential.","Both of the above protocols have been implemented in a number of programming languages, such as C, C++, and Java\u2122. However, network management software which takes advantage of SNMP or CMIP must be written specifically for the language of the protocol implementation. In other words, SNMP-based and CMIP-based network management software is dependent upon a particular programming language and protocol implementation.","GDMO (Guidelines for Definition of Managed Objects) is a standard for defining objects in a network in a consistent way. With a consistent \u201clanguage\u201d for describing such objects as workstations, LAN servers, and switches, programs can be written to control or sense the status of network elements throughout a network. GDMO prescribes how a network product manufacturer must describe the product formally so that others can write programs that recognize and deal with the product. Using GDMO with ASN, descriptions may be made of the class or classes of the object, how the object behaves, its attributes, and classes that it may inherit.","GDMO is part of the CMIP and also the guideline for defining network objects under TMN. The object definitions created using GDMO and related tools form a Management Information Base (MIB). GDMO uses Abstract Syntax Notation One (ASN) as the rules for syntax and attribute encoding when defining the objects. Abstract Syntax Notation One is a language that defines the way data is sent across dissimilar communication systems. ASN ensures that the data received is the same as the data transmitted by providing a common syntax for specifying application layer (e.g., program-to-program communications) protocols. Each communications system contains a similar ASN encoding\/decoding scheme written in the language used on that particular system. When one system wants to send data to another, the first system encodes the data into ASN, sends the data, and the second system receives and decodes the data using the decoder written in the language used on that system.","In response to the difficulties presented by SNMP and CMIP, the Object Management Group (OMG) and Joint Inter-Domain Management (JIDM) have defined Interface Definition Language (IDL) for network management, which is used to access object instance data and may be used across a plurality of programming languages and across a plurality of platforms. JIDM IDL allows programmers to write only one set of interfaces for a particular object across multiple programming languages, rather than having to write a new set of interfaces for each programming language.","A middleware standard used extensively in network management is the Common Object Request Broker Architecture (CORBA), which is provided by the Object Management Group (OMG). CORBA specifies a system that provides interoperability between objects in a heterogeneous, distributed environment and in a way transparent to the programmer. Its design is based on the OMG Object Model, which defines common object semantics for specifying the externally visible characteristics of objects in a standard and implementation-independent way. In this model, clients request services from objects (which will also be called servers) through a well-defined interface. This interface is specified in the OMG Interface Definition Language (IDL).","In CORBA, a client accesses an object by issuing a request to the object. The request is an event, and it carries information including an operation, the object reference of the service provider, and actual parameters, if any. The object reference is an object name that reliably defines an object.","A central component of CORBA is the Object Request Broker (ORB). The ORB encompasses the communication infrastructure necessary to identify and locate objects, handle connection management, and deliver data. In general, the ORB is not required to be a single component; it is simply defined by its interfaces. The basic functionality provided by the ORB includes passing the requests from clients to the object implementations on which they are invoked. The ORB acts as the middleware between clients and servers. In the CORBA model, a client can request a service without knowing anything about what servers are attached to the network. The various ORBs receive the requests, forward them to the appropriate servers, and then hand the results back to the client.","In CORBA, a client first looks up the object (server) it wants to communicate with. The ORB, as a result of the lookup operation, returns an object reference (a handle) of the server to the client. The client then uses the object reference to invoke operations on the object as a function call in the chosen programming language. The ORB intercepts the client request, collects the information about the operation and the request parameter values, encodes it in IIOP, and sends it to the object (server). The ORB on the object side (server) translates the request into a programming language specific function call on the server object. The server object then processes the request and returns a response, if any. The ORB intercepts the response, encodes the response and its parameters into IIOP, and sends it to the client. The ORB on the client side then returns the response to the client as the return value of the function call originally made as part of issuing the request.","In many cases, CORBA gateways to specific services may be developed to manage specific network traffic, such as requests and events. Typically, these gateways are designed as single-threaded programs. However, increasingly, the benefits of multi-threading are desired for applications and server programs related to network management.","Multi-Threaded Applications","A thread is an encapsulation of the flow of control in a program. Most programs are single-threaded; they only execute one path through their code at a time. Multi-threaded programs may have several threads running through different code paths simultaneously. Multi-threading typically means sharing a single CPU between multiple threads in a way designed to minimize the time required to switch threads. This is accomplished by sharing as much as possible of the program execution environment between the different threads so that very little state needs to be saved and restored when changing threads. Furthermore, if a computer has multiple CPUs and a program has multiple threads, multiple threads of the program may be run on separate CPUs concurrently. Thus multi-threading allows applications to scale with the number of CPUs, as well.","Multi-threading differs from multi-tasking in that threads share more of their environment with each other than do tasks under multi-tasking. Threads may be distinguished only by the value of their program counters and stack pointers while sharing a single address space and set of global variables. Often, there is very little protection of one thread from another, in contrast to multi-tasking. Multi-threading can thus be used for very fine-grained multi-tasking at the level of a few instructions and therefore can hide latency by keeping the processor busy after one thread issues a long-latency instruction on which subsequent instructions in that thread depend.","In a typical process in which multiple threads are used, zero or more threads may actually be running at any one time. This depends on the number of CPUs used by the computer on which the process is running, and also on how the threads system is implemented. A machine with n CPUs may run no more than n threads in parallel, but it may give the appearance of running many more than n threads simultaneously by sharing the CPUs among threads.","A context switch between two threads in a single process is considerably more efficient than a context switch between two processes. In addition, the fact that all data except for stack and registers are shared between threads makes them a natural vehicle for expressing tasks that may be broken down into subtasks that may be run cooperatively. Global variables and resources are shared between threads within the same process. Each thread has its own stack.","In many ways, the use of threads provides benefits over the use of processes in that threads are more efficient to create, switching between threads in the same process is much more efficient than switching processes, and there is easier sharing of resources between threads. Context switching among threads is very efficient in that there are no page or segment table manipulations, no flushing of the associative memory cache (when switching among threads sharing an address space), and no copying of data when exchanging messages among threads of the same address space.","As used herein, \u201cthread-safe\u201d refers to the property that a program may safely use or be used by multiple threads to avoid, for example, data inconsistencies, access collisions, coherency problems, and other errors. When multiple threads share resources, access to the resources should be synchronized to ensure thread-safety. One way this may be accomplished is through the use of a mutual exclusion (mutex) object. A mutual exclusion object allows multiple threads to synchronize access to shared resources. A mutex has two states: locked and unlocked. Once a mutex has been locked by a thread, other threads attempting to lock it will be blocked. When the locking thread unlocks (releases) the mutex, one of the blocked threads may acquire (lock) it and proceed. When managed object events and responses are delivered to a client manager application using multiple threads, synchronization and serialization of the event and response deliveries may become problematic in that the use of different threads to deliver sequential events may introduce chronological inconsistencies due to differing thread execution times. In other words, if a first event is sent using a first thread, and a subsequent second event is sent using a second thread, then depending upon the execution times of the two threads, the second event may actually be delivered prior to the first event.","The existing standards for TMN event management do not address the issue of access control to TMN events in a platform-independent interface. Currently, that is, mechanisms do not exist to readily manage which TMN manager applications have access to particular managed object events. In addition, clients are required to receive events only indirectly, by creating Common Management Information Service (CMIS) filters. These shortcomings may result in substantial loss of scalability and performance with regard to TMN object event management. Furthermore, the issues of client authentication, object-level access control, and security\/audit trails for TMN system usage are not addressed by existing standards. Finally, the existing standards do not allow the clients the option to choose the format in which to receive events.","Therefore, improved systems and methods for authenticating users over a network are desired.","The problems outlined above are in large part solved by various embodiments of systems and methods for authenticating users over a network as disclosed herein. At least one pluggable authentication module (PAM) may be used by a CORBA gateway component, such as a CORBA request gateway. In the case of the CORBA request gateway, the PAM may be used to authenticate management requests sent by one or more manager applications before they are sent to managed objects on a network. The term \u201cpluggable\u201d refers to the property that a client application may provide the terms under which a user may be authenticated to the gateway simply by providing the libraries necessary to execute the authentication scheme, thereby allowing the client to select which encryption and authentication schemes are employed to authenticate a user.","The PAM may include a client-side authentication library and a server-side authentication library. The client-side authentication library may be deployed on a client computer system and may provide a client-side interface which is operable to retrieve and encrypt a user profile associated with a user. The user profile which the client-side authentication library encrypts and sends to the server-side authentication library may include any information required to authenticate the user, such as the user name and a password. In various embodiments, the user profile may include encryption keys or other information useful for user authentication. The user profile may be entered by the user in whole or part and\/or retrieved from a storage device in whole or part prior to encryption.","The server-side authentication library may be deployed on a server computer system coupled to the client computer system through a computer network. The server-side authentication library may provide a server-side interface which is operable to receive the encrypted user profile from the client-side authentication library and decrypt the user profile to authenticate the user for one or more network services, such as a request gateway.","In one embodiment, the client-side library and the server-side library may be implemented in accordance with a specification expressed in an interface definition language (IDL) which is operable to define object interfaces across a plurality of platforms and across a plurality of programming languages. The client-side library may be implemented for the particular client platform corresponding to the client computer system in any programming language for which there is an IDL mapping, i.e., any programming language in which the IDL interface specification mentioned above may be implemented. The server-side library may he implemented for a particular server platform corresponding to the server computer system. In one embodiment, the server-side authentication library may be implemented in C++.","In one embodiment, the client-side authentication library and the server-side authentication library may be implemented as shared dynamic libraries, allowing the client-side authentication library to be shared by a plurality of management applications and the server-side authentication library to be shared by a plurality of gateway components.","In one embodiment, default versions of the client-side authentication library and the server-side authentication library may be provided so that the client user need not implement its own authentication scheme unless it specifically wishes to do so.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawing and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.",{"@attributes":{"id":"h-0006","num":"0000"},"figref":"FIG. 1","i":"b"},"Turning now to the drawings, is an illustration of a typical, general-purpose computer system  which is suitable for implementing various embodiments of the system and method for network management as disclosed herein. The computer system  includes at least one central processing unit (CPU) or processor . The CPU  is coupled to a memory  and a read-only memory (ROM) . The memory  is representative of various types of possible memory media: for example, hard disk storage, floppy disk storage, removable disk storage, or random access memory (RAM). The terms \u201cmemory,\u201d \u201cmemory medium,\u201d and \u201cstorage medium\u201d may include an installation medium, e.g., a CD-ROM or floppy disk, a computer system memory such as DRAM, SRAM, EDO RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive or optical storage. The memory medium may include other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network. In the latter instance, the second computer provides the program instructions to the first computer for execution.","As shown in , typically the memory  permits two-way access: it is readable and writable. The ROM , on the other hand, is readable but not writable. The memory  and\/or ROM  may store instructions and\/or data which implement all or part of the system and method described in detail herein, and the memory  and\/or ROM  may be utilized to install the instructions and\/or data. In various embodiments, the computer system  may take various forms, including a personal computer system, desktop computer, laptop computer, palmtop computer, mainframe computer system, workstation, network appliance, network computer, Internet appliance, personal digital assistant (PDA), embedded device, smart phone, television system, or other suitable device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having a processor which executes instructions from a memory medium,","The CPU  may be coupled to a network . The network  is representative of various types of possible networks: for example, a local area network (LAN), wide area network (WAN), or the Internet. The system and method for network management as disclosed herein may therefore be implemented on a plurality of heterogeneous or homogeneous networked computer systems  through one or more networks . The CPU  may acquire instructions and\/or data for implementing system and method for network management as disclosed herein over the network .","Through an input\/output bus , the CPU  may also coupled to one or more input\/output devices that may include, but are not limited to, video monitors or other displays, track balls, mice, keyboards, microphones, touch-sensitive displays, magnetic or paper tape readers, tablets, styluses, voice recognizers, handwriting recognizers, printers, plotters, scanners, and any other devices for input and\/or output. The CPU  may acquire instructions and\/or data for implementing the system and method for network management as disclosed herein through the input\/output bus .","The computer system  is operable to execute one or more computer programs. The computer programs may comprise operating system or other system software, application software, utility software, Java\u2122 applets, and\/or any other sequence of instructions. Typically, an operating system performs basic tasks such as recognizing input from the keyboard, sending output to the display screen, keeping track of files and directories on the disk, and controlling peripheral devices such as disk drives and printers. Application software runs on top of the operating system and provides additional functionality. Because applications take advantage of services offered by operating systems, and because operating systems differ in the services they offer and in the way they offer the services, an application must usually be designed to run on a particular operating system. The computer programs are stored in a memory medium or storage medium such as the memory  and\/or ROM , or they may be provided to the CPU  through the network  or I\/O bus .","In one embodiment, the computer programs executable by the computer system  may be implemented in an object-oriented programming language. In an object-oriented programming language, data and related methods can be grouped together or capsulated to form an entity known as an object. All objects in an object-oriented programming system belong to a class, which can be thought of as a category of like objects which describes the characteristics of those objects. Each object is created as an instance of the class by a program. The objects may therefore be said to have been instantiated from the class. The class sets out variables and methods for objects which belong to that class. The definition of the class does not itself create any objects. The class may define initial values for its variables, and it normally defines the methods associated with the class (i.e., includes the program code which is executed when a method is invoked.) The class may thereby provide all of the program code which will be used by objects in the class, hence maximizing re-use of code which is shared by objects in the class.","FIG. : CORBA Gateway",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 2","FIG. 2"],"b":["208","206","206","206","206","202","206","214","216","202","208","202","202","218"],"i":["a ","b"]},"In one embodiment, an enterprise manager  may be coupled to the CORBA gateway  via a proprietary or platform-dependent interface such as Portable Management Interface (PMI)  from Sun Microsystems, Inc. The enterprise manager  may include various enterprise management components such as a Management Information System (MIS), etc. Also coupled to the enterprise manager  via PMI  may be one or more PMI applications . PMI applications may include, for example, applications which provide access to event notification, subscription, and propagation services and access to object instance information. In one embodiment, the enterprise manager  may be Solstice Enterprise Manager (SEM) from Sun Microsystems, Inc., and examples of the one or more PMI applications  that use PMI to communicate with the SEM MIS may include SEM Viewer, SEM Alarm Manager, SEM Discovery, etc. In one embodiment, the CORBA gateway  may translate the CORBA manager requests  from IDL to PMI requests . Similarly, the CORBA gateway  may translate the enterprise manager PMI responses and PMI events  to IDL\/IIOP responses and events  which may be passed on through the CORBA ORB  to the manager applications  in the form of IDL responses and CORBA events .","Various embodiments of the CORBA Gateway  may include one or more components such as a Metadata Gateway, an Event Gateway (as shown in FIG. ), and a Request Gateway (as shown in FIG. ). The Metadata Gateway may provide manager applications  with metadata relating to the managed devices. The Metadata Gateway may employ a mapping system to translate managed object data and\/or metadata between various data formats, such as OMG IDL and a data description language such as Abstract Syntax Notation One (ASN).","FIG. : Event Subscriptions Through a CORBA Event Gateway",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 3","b":["302","208","302"]},"Furthermore, the approach improves performance and scalability by allowing event sinks to be distributed. Instead of having all clients receive their events from one event sink, the approach allows clients to receive events from different sinks, thereby providing load-balancing. In one embodiment, multiple instances of CORBA-enabled EDS sinks may be running in a single system, thereby allowing different CORBA clients to receive events from different CORBA-enabled EDS sinks. However, in a preferred embodiment CORBA clients are not aware of this multitude of CORBA-enabled EDS sinks because this feature is transparent to the clients.","Generally, the approach described below provides the capability to filter events according to criteria presented by client event subscriptions. In one embodiment, the events may be filtered to enforce policy-based access control on TMN events\/notifications, determining which CORBA client applications have access to which events. The filtering of events at the sink based upon client subscriptions decreases unnecessary network traffic in that events may be \u201cpushed\u201d to the client, rather than delivered upon client request or the client having to filter all requests itself. This is a substantial improvement over standard polling approaches. In addition, the approach may provide easy-to-use IDL APIs that allow CORBA clients to directly subscribe\/unsubscribe to events based on criteria such as object class, object instance, and event type. For example, a print manager application may subscribe to all events relating to the toner supply of laser printers of a particular make and model. The IDL APIs may allow clients to choose the format (e.g., text or ASN) in which the events are received, which is described in more detail in the section titled \u201cClient-Selected Format\u201d, below. The use of IDL may provide a platform-independent interface to deliver events generated by one or more managed objects to manager applications through the Event Gateway . Event subscriptions may be managed with services provided by an event port registry server, described below.","EventPortRegistry Server, EventPortFinder and EventPortFactory","As shown in , an EventPortRegistry Server , an Event Distribution System (EDS) , a Management Information System (MIS) , a Request Gateway , and one or more TMN Manager Applications  may be communicatively coupled to one another as appropriate, e.g., via Internet Inter-Object Protocol (IIOP) . The MIS  provides an interface through which requests and events may be communicated with managed objects on the network. Events originating with a managed object may be passed by the MIS  to the EDS Source , which routes the message to an EDS Sink , where event filtering may occur in accordance with client subscription specifications. The EDS Sink  may then determine which clients are to receive the event and route the event to the appropriate ports, which correspond to the subscribing clients. In this manner, events may be filtered at the sink level rather than on the client side, which greatly reduces network traffic.","In one embodiment, the EventPortRegistry Server  includes an EventPortFactory , an EventPortFinder , and an EventPortRegistry . The EventPortFactory , EventPortFinder , and EventPortRegistry  may be implemented as CORBA objects, and the Event Gateway  may provide public IDL interfaces for these objects. In one embodiment, the EventPortFinder  and EventPortFactory  CORBA objects are singleton objects for the entire system (e.g., one instance of an enterprise manager). CORBA client applications may receive their events through EventPort  objects, which are typically created one per CORBA client application .","In one embodiment, EventPortFactory  and EventPortFinder  server objects may be implemented in a separate stand-alone light-weight server. This server may act as an EventPortRegistry  (private CORBA object). The CORBA objects (factory and finder) may be designed as tie classes that forward their requests to EventPortRegistry . As mentioned above, the EventPortRegistry  may enable client managers to subscribe and unsubscribe to various events, based upon object class, object instance, and event type.","It should be noted that EventPortRegistry  may be a private CORBA object to be used for inter-process communication between EDS sinks  and the registry. For example, when the registry process starts up, it may create the EventPortRegistry  CORBA object with a well-known name, \u201cEventPortRegistry\u201d, registered with the CORBA NamingService under the name \u201cPrivate: <MIS>\u201d. Then, the server may proceed to create EventPortFinder  with the name, \u201cEventPortFinder\u201d under \u201c<MIS>\u201d node. Finally, the server may create the EventPortFactory  with the name, \u201cEventPortFactory\u201d under \u201c<MIS>\u201d node. The factory and the finder may simply use the registry to create or find EventPort . In one embodiment, users may choose the encoding or format of the event information field of events.","EventPortRegistry  may then validate a ProxyAgent object reference. In one embodiment, a ProxyAgent is an entity through which a manager  deals with a managed object. The ProxyAgent may provide IDL methods to allow registration for events by object class, name, or event type. If the validation succeeds, then the registry will proceed with creating the port. Otherwise, an appropriate exception may be raised. After the validation succeeds, the registry may check whether the port already exists, and if so, an exception may be raised. In other words, there should be a one-to-one mapping between EventPorts  and Application Entity Titles (AE-Titles) in the given domain. AE-Titles are from the TMN\/CCITT standards and are used to identify applications. For example, if one wants to talk to a given Event Gateway running on a given server, one could assign it an AE-Title \u201cEGW.\u201d Similarly, if one has a client application (or a manager application) that wants to listen or subscribe to events, it may assign itself an AE-Title so that Event Gateway  knows to whom to send any events when they occur. Finally, the registry may create an EventPort CORBA object .","Clients Registering for Events and EDS Sinks","In one embodiment, an Event Distribution Server (EDS)  which is coupled to the event port registry server  is configurable to listen for events generated by the one or more managed objects and to deliver the events to the one or more managers , depending upon the managers' event subscriptions and event access control.","As  shows, the EDS  may include an EDS Source  and one or more EDS Sinks . In one embodiment, a CORBA client  may listen for events by creating and registering EventPorts  and creating an Event Forwarding Discriminator (EFD). When the create request is processed by the CORBA Request Gateway  and sent to the MIS , the EFD may process this create request and send the AE-Title as a listener to one of the EDS Sinks . The EDS code will preferably take care of this automatically. The CORBA Request Gateway  ensures that it passes the user information in the create request. The AE-Title along with the user information and CMIS filter is passed to the EDS Sink  to make it an event listener. In one embodiment, the user information may be required to enforce access control on outgoing events. In one embodiment, each EDS Sink  may maintain an instance of CORBAEventDispatcher that will be responsible for actually dispatching CORBA events to CORBA clients .","When the EDS Sink  gets an event, it may retrieve the appropriate EventPort from the EventPortRegistry server and dispatch the event. Note that a CORBA client  may be served by any of the EDS sinks , and there may be more than one instance of EDS sink in the enterprise manager. Different CORBA clients may be served by different EDS sinks. In one embodiment, this is all done transparently by the existing EDS code.","FIG. : Dispatching CORBA Events to CORBA Clients",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 4","b":["206","302","402"]},"In , an EDS Source  receives the event through MIS . In one embodiment, the event may be transferred to the EDS Source  through PMI or another suitable interface, such as a platform-specific interface. The EDS Source  serves to collect all incoming events and route them to Sinks , which may act as filters to restrict the targets to which the events may be sent. In , the EDS Source  sends the event to an EDS Sink . In , the EDS Sink  may find the appropriate manager  for the event message. Because the EDS Sink  has the AE-Title associated with the client, it may query the EventPortRegistry to retrieve the corresponding event port through which to send the event. In , access control checks may be performed by comparing the client manager ID with access privilege information. This ensures that the client manager  is authorized to receive the event. That is, the gateway may authenticate access of the manager  to the event. In one embodiment, the authentication may involve the use of pluggable authentication modules, described below with reference to , , , and . In , the EDS Sink may then convert the event (as sent through PMI, for example) into a CORBA event, i.e., an event expressed in IDL. In , the EDS Sink may enqueue the event in a queue corresponding to the particular manager . This queue is required to ensure ordered delivery of events to the consumer. In particular, the delivery of events may occur in the order in which the events are generated. In , the EDS Sink may dispatch the event to the client .","Event Gateway Access Control","In one embodiment, the Event Gateway  may provide object-level access control between manager applications and managed objects. Therefore, manager application access to managed objects may be granted at the individual object level. That is, a given manager may be granted access to particular events while being prevented from interfacing with others. In one embodiment, the client manager  may first be authenticated to the Event Gateway  by username and password, or other validation information associated with the client manager , which may be represented in a user profile. In one embodiment, the authentication may involve the use of pluggable authentication modules, described below with reference to , , , and . Once the initial client authentication is accomplished, the client manager may be further authenticated for each event type at the individual object level. In other words, the Event Gateway  may check the client manager's privilege to receive events from a given managed object. In one embodiment, the client manager's user ID may be used to access subscription records to determine whether the client manager has access to a managed object associated with a particular event.","In one embodiment, this design uses thread pools to provide multiple threads delivering events to multiple consumers. If one consumer is slow in processing events, other consumers should not be adversely affected. This design allows the flexibility to assign scheduling priorities to different threads. The concurrency level of the thread pool can be configured for optimal concurrency levels (thought to be 5 or 10). Thread pools are discussed in greater detail with reference to the section below entitled \u201cManaging CORBA Events, Requests, and Replies with a Thread Pool.\u201d","FIG. : Deletion of EventPorts",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 5","FIGS. 12"],"b":["328","206","328","502","326","320","3","320","502","328","332","328","504","504","320","332","332","508","504","328","320","504","332","13","14","15"]},"Note that there may be instances when the client program may die or exit without destroying EventPorts . This may be intentional so that the client application  can come back up and continue with the old EventPort . In one embodiment, the only other valid signal to Event Gateway is when the event channel between the CORBA client and Event Gateway  is broken down, when EventPorts can be cleaned up.","FIG. : EDS Sink Initialization","An EDS sink may be initialized when a client event subscription specifics a set of filtering criteria not represented by a currently existing sink. In one embodiment, EDS sinks  may be initialized in the following manner. As shown in , when the EDS sink  starts, the main process may be running on the main thread , which is the thread on which PMI's recursive dispatch process () may be running. The existing initialization code may first be executed in . Before entering PMI's recursive dispatch process, the main process may spawn in  a new thread  to run the CORBA code. This new thread  may be a root CORBA thread (a child of the main thread). The root CORBA thread may then initialize the ORB in , establish communication channels with the EventPortRegistry server in , and then enter the ORB's infinite loop in . In one embodiment, a client may be subject to authentication by the event gateway before being allowed to initiate a new subscription specification, such as by a pluggable authentication module, discussed below with reference to , , , and .","FIG. : CORBA Request Gateway with MIS and Managed Devices",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 7","FIG. 7"],"b":["206","304","340","702","710","304","304","702","706","706","308","320","308","710"]},"Once a device  has received the requests, it may send responses back to the manager application . It does this by first sending the responses to the MIS , which passes the responses to the Request Gateway  in the form of PMI responses  via PMI . The Request Gateway may then translate the PMI responses  into platform-independent (e.g., IDL) replies , which are sent to the manager application  via IIOP . For example, if the request were a query for the on\/off status of a printer, the response may include the value of that status. In one embodiment, client manager applications  may be subject to authentication by the Request Gateway  before access to the Request Gateway services is allowed, as well as before each request is sent. Such authentication may be performed, for example, by a pluggable authentication module, discussed below with reference to , , , and .","FIG. : CORBA Request Gateway",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 8","FIG. 8"],"b":["304","208","304","302","308","304","206","340","308","320","3"]},"The Request Gateway  may be operable to accept the management requests  in IDL via IIOP , translate them into low-level PMI  requests , and send those PMI requests to a Management Information System (MIS) . MIS  may interface with managed objects on the network by passing requests to objects and receiving responses. When MIS  sends back the responses  to the Request Gateway , the Request Gateway  translates the responses  into IDL replies  and sends the replies  to the CORBA client manager application . As used herein, the term \u201cresponse\u201d is used to refer to the PMI responses  that MIS  sends to the Request Gateway , whereas the term \u201creply\u201d is used to refer to the IDL replies  that are sent to the CORBA client . The use of IDL\/CORBA as the interface between manager applications and managed objects provides a platform-independent approach to managing object-related requests.","Security\/Audit Trails","In one embodiment, the Request Gateway  may provide the Manager Applications  access to an MIS  service that provides security\/audit trails of TMN management\/object transactions. The Request Gateway  does this by providing a platform-independent way to turn on\/off the security\/audit trails via, e.g., request cmis_get\/cmis_set operations on the managed object, as well as providing user information in each request sent to the MIS. The security\/audit trail service provided by the MIS  may include a logging function which may be used to track event or request related traffic and save information such as which client sent the request\/event, when the request\/event occurred, and the nature of the request\/event, or any other information useful for security and auditing purposes. In one embodiment, the MIS  security\/audit service provides an \u201call or nothing\u201d capability, in that either all information for all traffic may be logged, or nothing is logged. In one embodiment, the Manager Applications  may be subject to authentication before being allowed access to the security\/audit trail service, such as by a pluggable authentication module, discussed below with reference to , , , and .","FIG. : Request Gateway Initialization",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 9","FIG. 9","FIGS. 12"],"b":["304","304","902","904","304","308","304","308","304","308","13","14","15"]},"In , the Request Gateway  may then spawn a new thread to run PMI's recursive dispatch in its own thread, referred to as the primary dispatcher thread . This design option may be employed because of the complexities and problems that may arise when the ORB and PMI loops are integrated into one loop. The individual loops may lose full functionality when they are merged, and the fact that ORB loops are multi-threaded may causes problem when the ORB loop integrated with the single-threaded PMI loop. Moreover, keeping the loops in separate threads may improve performance as CORBA requests and replies may be executed in parallel to the execution of PMI requests and responses. In the primary dispatcher thread , the PMI infinite loop is started in , and the recursive dispatch process is executed in .","After spawning the primary dispatcher thread , the Request Gateway  may post a callback to detect MIS disconnects. The Request Gateway  need not listen for managed object events because, for improved performance, it is only concerned with handling requests which originate with the manager applications  and the corresponding responses  from the managed objects. Next, in , the gateway initializes the ORB and, in , creates the ProxyAgentFinder CORBA object. In one embodiment, there may be only one instance of ProxyAgentFinder CORBA object per Request Gateway  instance, and each ProxyAgentFinder may be associated with only one instance of MIS . In one embodiment, these restrictions may be relaxed. To support multiple distributed gateways for a given MIS , there may be more than one Request Gateway  per MIS . After a ProxyAgentFinder object is created, it is registered with the CORBA Naming Service as \u201c<MIS>\u201d\/\u201c<RequestGateway Host>\u201d\/\u201cProxyAgentFinder\u201d. Any CORBA client wishing to connect to the Request Gateway  may first contact the CORBA Naming Service to get the ProxyAgentFinder CORBA object associated with the name \u201c<MIS>\u201d\/\u201cRequestGatewayHost\u201d\/\u201cProxyAgentFinder\u201d. The Request Gateway  may enter the ORB's infinite loop in .","Object-Level Access Control","In one embodiment, the Request Gateway  may provide object-level access control between manager applications and managed objects. Therefore, manager application access to managed objects may be granted at the individual object level. That is, a given manager may be granted access to particular objects while being prevented from interfacing with others. In one embodiment, a client manager application may be subject to authentication by the Request Gateway before being granted access to managed objects, such as by a pluggable authentication module, discussed below with reference to , , , and .","In one embodiment, object-level access control may be enforced by use of a Request Service Access Point (RequestSAP). RequestSAP may be a singleton object that may be shared by all ProxyAgents. A regular application Service Access Point (SAP) does not allow the insertion of the user name in the request message to enforce object-level access control, and therefore a request SAP is recommended to send PMI requests and receive PMI responses with appropriate object-level access control enforced. When a send request is invoked, the primary response callback may be installed. This is the callback that first gets invoked for any response from the MIS . The primary response callback may retrieve the response message and post a secondary response callback instead of processing the callback directly. The primary response callback does not invoke a reply because the reply may directly or indirectly invoke the recursive dispatch. If this happens, the recursive dispatch may end up in deep recursion, possibly causing the process stack size to overflow and dump core. Further details of the Request Gateway's object-level access control are given below with reference to client application authentication to the Request Gateway , described below.","Authentication of Client Applications to the Request Gateway","In one embodiment, user information may be included with each request sent to a managed object through the MIS . The MIS  may then use this information to determine whether the user has access to that particular object. In one embodiment, the MIS  may check the user ID against an authentication list or table which contains user\/object access information. In addition, client authentication may be performed upon client connection to the Request Gateway, described below.","Any CORBA client  wishing to connect to the Request Gateway  may first contact the CORBA Naming Service to get the ProxyAgentFinder CORBA object associated with the name \u201c<MIS>\u201d, \u201cProxyAgentFinder\u201d. Then the client  may invoke the ProxyAgentFinder domain access IDL method to connect to the Request Gateway . Note that the domain access method may also be used to retrieve existing connections for that client . The client  may pass a key to the Request Gateway. In one embodiment, this key may not have any significant functionality other than identifying whether the ProxyAgent should be for OSI or SNMP management. The client  may then fill in the appropriate criteria (which is a list of tuples <name, value>, where <name> is an IDL string, and<value>is CORBA::Any), described in the table below according to one embodiment.",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Criteria for ProxyAgents"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Criteria","Type of",{}]},{"entry":["Name","Value","Semantics"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["\u201cdomain","string","Value must be the name of the MIS that"]},{"entry":["title\u201d",{},"client wants to connect to. This criteria is"]},{"entry":[{},{},"MANDATORY"]},{"entry":["\u201cgateway","string","Value must be the name of the gate-"]},{"entry":["title\u201d",{},"way (typically a host name) that the client"]},{"entry":[{},{},"wants to connect to. The value defaults to"]},{"entry":[{},{},"some randomly assigned gateway,"]},{"entry":[{},{},"typically the gateway that is running"]},{"entry":[{},{},"on the MIS host. This criterion is"]},{"entry":[{},{},"OPTIONAL. This criterion allows gate-"]},{"entry":[{},{},"way instances to be distributed"]},{"entry":[{},{},"and is for future use."]},{"entry":["\u201ccontroller","JIDM::Proxy-","Value must be a CORBA object refer-"]},{"entry":["object\u201d","Agent-","ence of JIDM::ProxyAgentController"]},{"entry":[{},"Controller","object which is created by the manager"]},{"entry":[{},{},"(client) application. This criterion is"]},{"entry":[{},{},"OPTIONAL."]},{"entry":["\u201cuser","Any","Value is opaque. Its usage is described"]},{"entry":["profile\u201d",{},"below. Value is used to extract the"]},{"entry":[{},{},"username and password. This criterion is"]},{"entry":[{},{},"MANDATORY."]},{"entry":["\u201cmanager","String","Title used to denote the Manager (client)"]},{"entry":["title\u201d",{},"which requested access to the OSI"]},{"entry":[{},{},"managed object domain. This criterion is"]},{"entry":[{},{},"OPTIONAL."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, the related enterprise manager may be Solstice Enterprise Manager\u2122 (SEM) available from Sun Microsystems, Inc. To maintain the same access control features that exist in SEM, the criteria may require a username and password (in encrypted form). To enable the CORBA clients to send the password in encrypted form, a wrapper library (e.g., implemented in C++) may be provided which contains an encryption function similar to that currently used in PMI . The client may pass in CORBA \u2018any\u2019 which contains the user profile (opaque to the CORBA Gateway ). In one embodiment, a class library may be provided to allow pluggable authentications, described below with reference to , , , and . In this manner, the Request Gateway  may be operable to authenticate client managers. Note that because SEM does not support AE-Titles publicly for MIS , the approach may use a string that specifies the name of the MIS .","In one embodiment, a client application  may provide its own authentication interface in the form of a pluggable authentication module, described below with reference to , , , and . When the client  wants to create a Proxy Agent, it sends the user profile criteria in \u2018any\u2019 (which is recommended to be encrypted in whatever form the user chooses). The Request Gateway  may then invoke a decryption function to extract the user name and password from the encrypted user profile. The Request Gateway  may then use the standard login to authenticate the username and password. In one embodiment, the enterprise manager may provide a default C++ implementation of the above-mentioned wrapper library, which may be replaced by the client  with its own implementation.","The Request Gateway  may then send a create request for an application instance object. The create request may contain the client's username. This request may be used to subject the client  to object-level access control. To do this, the Request Gateway  may create a RequestSAP to send the request, as described above. If the creation succeeds, then the Request Gateway  may proceed to create a Proxy Agent CORBA object, store it in a proxy agent list, and return a reference to it to the client ; otherwise, an exception may be raised.","The Proxy Agent may store the key and criteria. When a destroy function is called on the Proxy Agent, a client-implemented Proxy Agent Controller may be contacted to determine whether the destruction may be allowed. If allowed, the Proxy Agent object may be destroyed, after which the Proxy Agent Controller object may be destroyed. The purpose of the Proxy Agent Controller is to notify the client application  when the Proxy Agent is about to be destroyed, as well as when destruction has occurred.","Client-Selected Format","As mentioned above, in some embodiments, the client  may choose the format in which to send and receive information such as events, requests, notifications, etc. To provide text based requests and replies, an extension IDL interface may be used. For example, a new IDL interface may be provided which extends ProxyAgent. The tie mechanism may be used to create the concrete version of the ProxyAgent object. The extensions may allow clients to send requests and receive replies using values in text form rather than in CORBA::Any (i.e., ASN <any>). The text form values may retain the same format as that of PMI.","The JIDM standard does not explicitly mandate the LDL format of events. In one embodiment, the following IDL may be used for event reports:",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct EventReport {"]},{"entry":[{},"\u2003string event_type;"]},{"entry":[{},"\u2003string object_class:"]},{"entry":[{},"\u2003string object_name;"]},{"entry":[{},"\u2003string event_time;"]},{"entry":[{},"\u2003any event_info;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that the CORBA-ASN generic data type <any> is used to store event information. For receiving event_info in a string format for text-based events, the following structure may be used:",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct EventReport {"]},{"entry":[{},"\u2003string event_type;"]},{"entry":[{},"\u2003string object_class:"]},{"entry":[{},"\u2003string object_name;"]},{"entry":[{},"\u2003string event_time;"]},{"entry":[{},"\u2003string event_info;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note the use of the <string> data type for storing the event information. The use of text format may greatly reduce the network traffic related to requests and responses. It should be noted that in other embodiments, various other data formats may be used to store event information.","Managing CORBA Events, Requests, and Replies with a Thread Pool","In one embodiment, the Event Gateway  and the Request Gateway  may be designed as multi-threaded systems. A mechanism may be provided to prevent any single client  from overloading the system, including denial of service attacks. A thread pool may be used to minimize thread creation and deletion inefficiencies. If a client sends an excessive number of requests to the system, the client may be assigned only one thread from the thread pool in order to preserve resources for other clients. In one embodiment, there may be one thread pool (reply thread pool) per Request Gateway . This reply thread pool may initially have a concurrency of 3. The thread pool may enhance the performance of sending replies to clients because the send reply method may be a blocking call. A thread pool may improve the response time to different CORBA clients  even in the presence of a few slow CORBA clients , in that the slow CORBA clients  may be isolated in their respective threads away from the other clients.","In one embodiment, each ProxyAgent instance may have a reply dispatcher, which may schedule replies to that particular client  in sequential order (the same order in which the client  issued the requests). In this way, message ordinality may be preserved. Similarly, the client  may receive replies for a given request before receiving any replies for any subsequent requests. One approach to preserving message order in a thread-safe manner is through the use of a synchronous task scheduler with the thread pool, described below.","FIG. : Synchronous Task Scheduler","To ensure ordered delivery of events or replies to the CORBA gateway clients in a multi-threaded environment using a thread pool, a synchronous task scheduler may be used. The primary utility of the synchronous task scheduler is that it leverages the efficiency and scalability of a thread pool while preserving the order of events, requests, and replies. There may be a synchronous task scheduler associated with each client manager to preserve the chronology of messages sent to each.","As  shows, the Request Gateway  and the Event Gateway  are communicatively coupled to a client manager application  via IIOP , as well as the MIS  via PMI . The Request Gateway  is operable to receive IDL requests  from the client manager , translate the IDL requests  to PMI requests  and deliver the PMI requests  to the MIS , through which various managed objects may be accessed. The Request Gateway is further operable to receive managed object PMI responses  from the MIS , translate the PMI responses  to IDL replies  and send the IDL replies  to the client manager . The Event Gateway  is operable to receive PMI events  from the MIS , translate the PMI events  to IDL events  and deliver the IDL events  to the client manager .","When messages are to be delivered serially to the client manager application , such messages may be scheduled by the synchronous task scheduler . The synchronous task scheduler may maintain an internal message list, and deliver one message at a time from that internal list. The synchronous task scheduler  may hold a reference to a thread pool and use that thread pool to deliver messages.","In one embodiment, the Event Gateway  may use task schedulers  to deliver managed object events serially to client managers, assigning a task scheduler  to each client manager connected to the Event Gateway . Similarly, the Request Gateway  may use task schedulers to serially deliver managed object replies (to requests sent by the client managers ) to the client managers , such that the replies are received by the client managers  in the same order the corresponding requests were sent. The Request Gateway  may also assign a task scheduler  to each client manager connected to the Request Gateway .","FIG. : Synchronous Task Scheduling With A Thread Pool",{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 11","b":["1102","1104"]},"In , the synchronous task scheduler completes the delivery of a prior message, if there is one. In one embodiment, when the synchronous task scheduler receives a message, it may determine if any prior message is currently being delivered. If no prior message is currently being delivered, the synchronous task scheduler may deliver the current message immediately, rather than enqueueing the message on the message list for later delivery.","In , the synchronous task scheduler dequeues the current message. Note that the use of a queue for the message list ensures that messages will be processed in the order in which they are received, because the queue is a first in, first out (FIFO) data structure.","Then, in , an available thread is assigned from the thread pool for delivery of the message. Finally, in , the scheduler may initiate delivery of the message, sending the message to the client manager application.","In one embodiment, when the synchronous task scheduler sends a message to the client manager, it may wait until it receives an acknowledgement of receipt from the client manager before dispatching the next message. This may be necessary because each sequential message may be delivered with a different thread, and because some threads may execute more rapidly than others, a first thread execution which is initiated before a second thread execution may actually finish after the second thread completes its execution. By restricting the messages of a particular scheduler to be delivered one at a time, the message chronology for a given client manager may be maintained.","FIG. : Pluggable Authentication Module",{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 12","b":["1200","1204","1208"]},"As shown in , the PAM  may include a client-side authentication library  and a server-side authentication library . The client-side authentication library  may be deployed on a client computer system . The client-side authentication library  may provide a client-side interface which is operable to retrieve and encrypt a user profile  associated with a user. The user profile  which the client-side authentication library  encrypts and sends to the server-side authentication library  may include any information required to authenticate the user, such as the user name and a password. In one embodiment, the user profile  may include a designation of a management information server (MIS) to which the user wishes to connect. In other embodiments, the user profile  may include encryption keys or other information useful for user authentication. The user profile  may be entered by the user in whole or part and\/or retrieved from a storage device in whole or part prior to encryption.","Also shown in , the server-side authentication library  may be deployed on a server computer system  coupled to the client computer system  through a computer network. The server-side authentication library  may provide a server-side interface which is operable to receive the encrypted user profile  from the client-side authentication library  and decrypt the user profile  to authenticate the user for one or more network services.","In one embodiment, the client-side library  is implemented in accordance with a specification expressed in an interface definition language (IDL). The interface definition language may be operable to define object interfaces across a plurality of platforms and across a plurality of programming languages. The client-side library  may also be implemented for the particular client platform corresponding to the client computer system . As used herein, a \u201cplatform\u201d includes a combination of a particular operating system, programming language, software development environment, and\/or set of computing hardware for which software may be developed. The server-side library  may also be implemented in accordance with the specification expressed in the interface definition language and implemented for a particular server platform corresponding to the server computer system .","In one embodiment, the IDL interface for authentication may include the following AuthenticationServer and AuthenticationClient classes:",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class AuthenticationServer {"]},{"entry":[{},"\u2003public:"]},{"entry":[{},"\u2003\u2003virtual CORBA::Boolean decrypt_user_profile("]},{"entry":[{},"\u2003\u2003\u2003const CORBA::Any& user_profile_blob,"]},{"entry":[{},"\u2003\u2003\u2003RWCString& user_name,"]},{"entry":[{},"\u2003\u2003\u2003RWCString& password"]},{"entry":[{},"\u2003\u2003) throw( ) = 0;"]},{"entry":[{},"};"]},{"entry":[{},"class AuthenticationClient {"]},{"entry":[{},"\u2003public:"]},{"entry":[{},"\u2003\u2003virtual CORBA::Any_ptr encrypt_user_profile("]},{"entry":[{},"\u2003\u2003\u2003const char* user_name,"]},{"entry":[{},"\u2003\u2003\u2003char* password,"]},{"entry":[{},"\u2003\u2003\u2003const char* key"]},{"entry":[{},"\u2003\u2003) throw( ) = 0;"]},{"entry":[{},"\u2003\u2003virtual CORBA::Any_ptr get_user_profile("]},{"entry":[{},"\u2003\u2003\u2003CosNaming::NamingContext_var root_nc,"]},{"entry":[{},"\u2003\u2003\u2003const char* key"]},{"entry":[{},"\u2003\u2003) throw( ) = 0;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the client-side authentication library  implements the AuthenticationClient class. For example, the client-side authentication library  may implement the AuthenticationClient class using NES DES encryption. In one embodiment, the server-side authentication library  implements the AuthenticationServer class. For example, the server-side authentication library  may implement the AuthenticationServer class using an SEM Authentication daemon to validate the DES-encrypted user identity.","In one embodiment, the server-side authentication library  may be implemented in C++. The client-side authentication library  may be implemented in any programming language for which there is an IDL mapping, i.e., any programming language in which the IDL interface specification mentioned above may be implemented.","In one embodiment, the client-side authentication library  and the server-side authentication library  may be implemented as shared dynamic libraries, allowing the client-side authentication library to be shared by a plurality of management applications and the server-side authentication library to be shared by a plurality of gateway components.","FIG. : Pluggable Authentication Modules",{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIG. 13","FIG. 13"],"b":["208","1202","1202","1204","1204","1206","1206","206","1208","206","208"]},"FIG. : Authentication Process",{"@attributes":{"id":"p-0127","num":"0126"},"figref":["FIG. 14","FIG. 14"],"b":["1402","1404"]},"As  indicates, a user profile may be encrypted by the client-side authentication library, as specified by the client-specified and implemented encryption scheme. Then, as indicated by , the server-side authentication library retrieves the encrypted user profile. At  the server-side authentication library then decrypts the user profile. With the resulting information, the authentication status of the user may be determined, as indicated in . In one embodiment, this process may be used to authenticate management requests for managed objects sent by manager applications.","The fact that the authentication system may be implemented as pluggable modules makes the system extremely flexible and extensible. In one embodiment, default versions of the client-side authentication library and the server-side authentication library may be provided so that the client user need not implement his own authentication scheme unless he specifically wishes to do so.","FIG. : CORBA Gateway With Pluggable Authentication System",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 15","FIG. 15"],"b":["208","1200","1502","206","208","206","1502","206","208","1200","206","208","3","7"]},"Various embodiments may further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Suitable carrier media may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network  and\/or a wireless link.","While the present invention has been described with reference to particular embodiments, it wilt be understood that the embodiments are illustrated and that the invention scope is not so limited. Any variations, modifications, additions and improvements to the embodiments described are possible. These variations, modifications, additions and improvements may fall within the scope of the invention as detailed within the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
