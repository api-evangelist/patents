---
title: Semantic analysis driven service creation within a multi-level business process
abstract: A multi-level business process interface associated with an incomplete Web service can be identified. The interface can be created within a user interface (UI) modeling tooling. The Web service can be associated with a business process. An interface specific metadata associated with the process interface can be determined. Service definitions for one or more existing Web service matching a portion of the interface specific metadata can be searched for semantically based on search depth parameters set by a user. A search result responsive to the searching can be returned. The search result can identify one or more existing Web services from a service registry.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098583&OS=09098583&RS=09098583
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09098583
owner_city: Armonk
owner_country: US
publication_date: 20111024
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to the field of Web service development and, more particularly, to semantic analysis driven service creation in a multi-level business process.","Web services are frequently associated with business processes which model necessary stages for achieving a business objective. The Web services can be an implementation of a business process, a portion of a business process, or multiple business processes. Existing Web services and are often used to create new services rapidly by leveraging software development practices such as software reuse. For example, two or more Web services can be combined into a single service which can provide greater functionality than the services individually.","Traditional Web service creation often requires manual searches for service definitions by using specific keywords to search for the definitions. The definitions can be retrieved from registries such as internal registry, an external registry, or cloud registry. Once retrieved service objects must be manually mapped to the service being created. This traditional process can be a time consuming endeavor and can also require industry specific knowledge to identify appropriate search keywords. That is, existing Web services can go unused due to difficulty in determining the service existence. For example, a service can be tagged with jargon keywords which can render the service difficult to find. Further, traditional approaches fail to permit searching low-level details (e.g., operations) of Web services and\/or business processes.","One aspect of the present invention can include a system, an apparatus, a computer program product, and a method for semantic analysis driven Web service creation. A multi-level business process within a computing environment can be identified. The interface can be created within a user interface (UI) modeling tooling. The Web service can be associated with a business process. An interface specific metadata associated with the process interface can be determined. Service definitions for one or more existing Web service matching a portion of the interface specific metadata can be searched for semantically. A search result responsive to the searching can be returned. The search result can identify one or more existing Web services from a service registry.","Another aspect of the present invention can include an apparatus, a computer program product, a method, and a system semantic analysis driven Web service creation. A tooling engine can be able to automatically generate Web service artifacts associated with an interface of an incomplete Web service. The interface can be associated with interface specific metadata. The incomplete Web service can be associated with a business process. A data store can be configured to persist a search result associated with a semantic search. The search result can identify at least one existing Web service matching a portion of the interface specific metadata.","The present disclosure is a solution for semantic analysis driven service creation in a multi-level business process. In the solution, a tooling engine can be utilized to assist in automatically generating necessary artifacts for completing the creation of a Web service. The engine can determine interface metadata from a user defined interface which can be used to perform a semantic search. The search can utilize automatically established keywords, tags, and\/or categories to identify existing services which can be utilized in creating the Web service. The tooling engine can return a ranked result set which can permit intelligent selection and generation of Web service artifacts. For example, the engine can automatically retrieve service objects, map relevant service objects, and generate an appropriate payload for validation of the Web service.","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction processing system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction processing system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing. Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions.","These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","200","300","100","101","110","140","170","100","102","102","109","103","170"]},"In define implementation , a business process  can be inputted into a tooling screen . Utilizing tooling screen , a process implementation  can be created. For example, the process implementation  can be a new Web service being created by a user. The process implementation  can include an interface definition . The interface definition  can be generated from user input received within tooling screen . For example, a developer can employ business process flowcharts to manually define an interface definition  for business process . The interface definition  can be an entity specifying the location of the implementation  (e.g., URL) and the operations the implementation exposes. In one instance, the interface definition  can be a Web Services Description Language (WSDL) document. In the instance, the definition  can include, but is not limited to, a binding, a port type, a message, a type, and the like. That is, interface definition  can specify requisite messages which can be used by the Web service associated with the process implementation.","In programmatic semantic search , the interface definition  can be conveyed to a semantic engine . Semantic engine  can utilize traditional and\/or proprietary techniques to establish an ontology . One or more search parameters  can be extracted from the ontology . In instances where an ontology  is not available, known external service directories can be queried to obtain metadata which can be utilized to generate an appropriate ontology. Search parameters  can be employed to aid in locating existing services which can be useful to building out implementation  functionality. Search parameters  can include, but is not limited to, a keyword, a tag, a category, and the like. In one embodiment, search parameters  can include user specified options including a search depth parameter, a search string, and the like. In the instance, search parameters can utilize traditional Boolean operations and search depth options to automatically improve search results. For example, a search depth parameter can be specified in a numerical value (e.g., depth=3) permitting a user to search for specific process operations matching user specified criteria. It should be appreciated that search depth parameters can be specified using traditional and\/or proprietary mechanisms. For example, the search depth parameter can be a search string keyword (e.g., depth: object). Search parameters  can be utilized by tooling engine  to perform query .","Query  can be conveyed to service directory  which can return a result set . Query  can include multiple search queries and\/or parameters for identifying an appropriate service. In one instance, query  can be a SPARQL Protocol and Resource Description Framework (RDF) Query Language Query (SPARQL). Query  can be fully customizable utilizing user established settings, automatically established settings, and the like. In one instance, service directory  can be an internal service directory maintained within the tooling engine . In another instance, service directory  can be an external service directory communicatively linked to engine . For example, directory  can be a cloud based service registry accessible to tooling engine . Result set  can be a semantic search data set including identification of services  which match query  (e.g., search parameters ). Result set  can be conveyed to engine  which can perform necessary actions to facilitate automated process implementation  assembly.","In service creation , result set  and metrics  can be utilized to create generated service . Engine  can employ metrics  to provide a ranked set  which can be an ordered instance of result set . For example, ranked set  can be a list of services  matching query  and\/or search parameters . Metrics  can be one or more data sets of measures associated with a Web service. Metrics  can include, but is not limited to performance metrics, software metrics, and the like. For example, a metric  can be a popularity of a Web service based on service usage during a one week period. In one instance, ranked set  can be automatically generated and mapping  can be produced. In another instance, ranked set  can be automatically generated and await approval from a user before mapping  is produced. Metrics  can be automatically and\/or manually conveyed to engine . For example, a user interface associated with tooling engine  can permit a developer to select specific metrics which can be used to aid in the creation of service .","One or more services  from ranked set  can be utilized to programmatically create mapping . Mapping  can be an artifact permitting association of service and\/or service objects to an interface definition (e.g., interface metadata). In one instance, mapping  can be an Extensible Markup Language (XML) document for associating relevant service objects to implementation . Mapping  can be employed by engine  to provide generated code . Generated code  can be an entity including one or more source code documents. For example, generated code  can be a JAVA 2 ENTERPRISE EDITION source code document. Generated code  can be employed to create validation payload .","Validation payload  can be an artifact for verifying the appropriate operation of code . Validation payload  can include unit testing artifacts which can automate code  testing. In one instance, code  can be modified based on outcome of validation testing. That is, code  can be automatically tailored to fit specific requirements. In one embodiment, validation can be manually approved to enable user control of the flow. In another embodiment, one or more rules can be established to enable automation of approval.","When validation of code  is complete, generated service  can be created. Service  can be a completely functional Web service based on interface definition . In one embodiment, service  can conform to a Representational State Transfer (REST) architecture. In another embodiment, service  can conform to a Service Oriented Architecture (SOA). Service  can be optionally deployed based on engine  settings. In one embodiment, service  can be published to a service directory (e.g., stage publish ).","In publish , engine  can publish service  to service directory . In one instance, a publish artifact can be conveyed to directory  to register service within a network. In one embodiment, publish artifact can be a WSDL document (e.g., interface definition ). Service directory  can update services  to include generated service  availability. In one instance, ontology and metric information associated with the service  can be published to service directory . In the instance, the published data can be export to external registries (e.g., cloud service directory).","Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. It should be appreciated that disclosure can utilize external resources (e.g., semantic engine ) to accomplish flow . It should be understood that stage  can be an optional phase of the disclosure. The flow  can be associated with traditional and\/or proprietary Web service frameworks including, but not limited to, IBM WEB TOOLS PLATFORM, Apache Axis, Spring Framework, Web Services Invocation Framework, and the like. In one instance, flow  can utilize Java Application Programming Interface (API) for XML Web Services (JAX-WS) technologies.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2","b":["200","200","100","300","200"]},"In step , a business process interface can be inputted within a Web service modeling tool. The business process can be manually and\/or automatically inputted into the modeling tool. In one embodiment, a business process artifact conforming to a Business Process Modeling Notation (BPMN) format can be inputted into the modeling tool. The modeling tool can be a software program able to receive interface definition details associated with a process implementation. In one instance, the modeling tool can be an assisted creation tool (e.g., wizard) within an integrated development environment (IDE). For example, modeling tool can be a Web service creation screen of an IBM ECLIPSE IDE.","In step , an interface metadata (e.g., Extensible Markup Language document) can be generated from the interface. In one instance, metadata can include metrics associated with the interface. In one instance, a \u201csummary\u201d Extensible Markup Language document can be created. In the instance, the document can include context information about the interface extracted from metadata entered by a user, a list of vocabulary extracted from the interface definition, and the like. In step , the definition can be conveyed to a semantic analysis engine. In step , the definition can be analyzed by the semantic analysis and a set of search parameters can be generated.","In step , the search parameters can be utilized to identify existing services which can be utilized in Web service creation. In step , if services exist, the method can continue to step , else proceed to step . If a matching service is found, the service interface information can be retrieved from an internal service directory (e.g., directory ). In one instance, service discovery can be performed utilizing Web Services Dynamic Discovery (WS-Discovery) communication protocol. When a matching service is not located, external registries can be queried for relevant artifacts. In step , the service can be built manually by an appropriate user. When a matching service is not located within external registries, the service can be defined manually. That is, the service can be new and user input via existing tooling is required to create the service. In one instance, a notification of service absence can be conveyed to one or more users. In the instance, tooling configuration can permit notification to be conveyed to an administrator, a developer, a development team, a project manager, and the like. For example, an email notification can be transmitted to a project team member when a service requires manual creation.","In step , existing services can be compiled into a ranked set. In one embodiment, the ranked set can include a score for each existing service identified. In the embodiment, the score can be automatically computed utilizing one or more rulesets. In one instance, the highest ranked service can be automatically selected to be utilized in the generation of the Web service. In step , appropriate artifacts can be selected from relevant services. In step , artifacts can be mapped to relevant interface objects. In step , generated service can be created based on mapping. In step , a verification payload can be generated. In step , validation services can be invoked to verify generated service. In one instance, one or more external services can be invoked to verify the generated service. In step , the service can be optionally published. In step , the method can end.","Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. Method  can be performed in parallel or serial. It should be appreciated that, method  can be performed in real-time or near real time. In one instance, method  can be triggered via a user interface functionality. For example, a file menu entry can permit assisted and targeted Web service development from an initial interface definition. It should be appreciated that method  can leverage semantic Web technologies to enable method to be enacted.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["300","300","100","200","300","320","348","340","352","343","340","344","300","390","300"]},"Business process management server  can be a hardware\/software entity permitting the processing of tooling engine . Server  can include, but is not limited to, business process design, process modeling, process handling, process monitoring, process optimization, process re-engineering, and the like. In one embodiment server  can be an IBM Business Process Choreography server. Server  can include multiple servers which can be geographically distributed throughout a network (e.g. network ). Server  can store artifacts - within one or more data stores associated with the server . It should be appreciated that artifacts - can be persisted for re-use enabling rapid development of similar Web services. For example, artifacts - can be associated with a Web service software project stored and\/or managed by server .","Tooling engine  can be a hardware\/software component for permitting automated generation of a Web service  from definition . Engine  can include, but is not limited to, interface analyzer , ranking component , mapper , code generator , validator , service directory , configuration setting , and the like. Engine  functionality can include interaction with a user interface, integration with existing tooling (e.g., tooling extension), and the like. For example, engine  can be a backend component of a Web Services Description Language (WSDL) Editor. In one embodiment, engine  can provide tooling extensions to existing tooling features enabling rapid Web service development. For example, tooling engine  can be a feature extension of a WEB TOOLS PLATFORM of an IBM ECLIPSE Integrated Development Environment (IDE).","Interface analyzer  can be a hardware\/software entity for examining definition . Analyzer  functionality can include definition validation (e.g., input validation), metadata collection, metadata analysis, and the like. Analyzer  can be automatically invoked during a process implementation activity. For example, when a software wizard for defining an interface is completed, the analyzer can examine the interface and collect metadata. Analyzer  can utilize traditional and\/or proprietary metadata collection techniques. Metadata can include, but is not limited to, a service name, a namespace, a mode, a policy, a security setting, a revision value, a status, a relationship value, and the like.","Ranking component  can be a hardware\/software element for creating ranked results . Component  functionality can include, but is not limited to, search parameter creation, semantic engine  communication, and the like. In one instance, the component can inspect the interface definition  and associated metadata to create appropriate Extensible Markup Language (XML) for semantic analysis to be performed (e.g., semantic query). In the instance, relevant services associated with the service directory  can be retrieved based on results from semantic engine query. In one embodiment, if more than one matching services are identified, the component can generate a score to rank matching services based on pre-defined metrics (e.g., metrics ). In another embodiment, interfaces which have no matching ontology, the component can attempt to query service directories from cloud service providers (e.g., registry ) based on results of the semantic engine . In the embodiment, if a match is determined, the component can import external interfaces and associated metadata into the service directory  and the result (e.g., ranked result ) can be updated to reflect the change.","Mapper  can be a hardware\/software component for automatically generating mapping . Mapper  functionality can include, but is not limited to, object retrieval, attribute determination, mapping validation, and the like. In one instance, mapper  can automatically map all elements between a user defined interface (e.g., interface ) and the selected service within ranked result . In one embodiment, when an interface or attribute cannot be matched, a user can be prompted to perform manual matching activities.","Code generator  can be a hardware\/software element for dynamically creating generated code . Generator  functionality can include, but is not limited to, mapping  processing, source code language selection, framework selection, and the like. Generator  can output traditional and\/or proprietary source code artifacts. Artifacts can conform to one or more computing languages including, but not limited to, JAVA, PHP Hypertext Processor (PHP), JAVASCRIPT, and the like. Generator  can yield appropriate executable code based on the output of mapper . For example, generator  can create an appropriate JAVA bean based mapping . Generator  can create a validation payload  which can be utilized by validator .","Validator  can be a hardware\/software entity for validating code . Validator  functionality can include, but is not limited to, code testing, validation notification, and the like. Validator  can dynamically validate code  utilizing payload  and\/or a manually created payload. In one embodiment, validator  can present the outcome of the validation within a user interface. In the embodiment, changes can be performed which can allow user feedback to control Web service  creation.","Service directory  can be a hardware\/software element for storing service metadata associated with services (e.g., services ). Directory  functionality can include, but is not limited to, metadata storage, importing capabilities, publishing capabilities, and the like. In one instance, directory  can be an IBM WEBSPHERE SERVICE REGISTRY AND REPOSITORY. In one embodiment, directory  can store interface definitions for known interfaces and associated metadata.","Configuration setting  can be one or more rulesets for establishing the behavior of engine . Setting  can include, but is not limited to, interface analyzer  options, ranking component  parameters, mapper  settings, code generator  options, validator  settings, service directory , and the like. Setting  can be automatically and\/or manually configured. For example, setting  can be presented within a user interface which can permit configuration changes to be propagated to engine .","Interface definition  can be associated with one or more messages that Web service  can perform. Messages can be grouped together into operations which can be specified by input and\/or output messages. In one instance, interface definition  can be an extension to an existing interface. Definition  can conform to an Extensible Markup Language format.","In one embodiment, search parameters  can be customized by a user prior to searching a service directory. For example, one or more search strings associated with the search parameters  can be presented within a user interface for editing purposes. In one instance, search parameters  can be presented within a search user interface. In the user interface, customizations including, but not limited to, keyword modification, query optimization, and the like can be performed.","Ranked result  can include one or more services identified by search parameters . Result  can include, service location, service information, service metadata, and the like. In one instance, ranked result  can be dynamically organized based on one or more criteria. Criteria can include, but is not limited to, version, author, rating, and the like.","Mapping  can include, but is not limited to, service information, interface information, service objects information, object metadata, and the like. In one instance, mapping  can include multiple services, multiple objects, and the like. For example, map entry  can link an Element A of a Service A to Web service . Mapping  can be persisted within a data store and can be dynamically updated when changes to services occur. For example, when services  are changed, mapping  can be automatically updated to reflect the change.","Generated code  can be associated with a source code file, an object file, a binary file (e.g., executable code), and the like. Code  can include, but is not limited to, a JAVA source code file, a C++ source code file, and the like. Code  can include traditional and\/or proprietary source code artifacts which can support compilation, builds, validation, deployment, and the like. In one embodiment, code  can be associated with a client based program. In the embodiment, code  can be a validation client which can be utilized to test Web service .","Validation payload  can be associated with code  which can include one or more data sets, algorithms, metadata and the like. In one instance, payload  can conform to a JAVA payload interface class. Payload  can be utilized to perform traditional and\/or non-traditional automated testing. Payload  can permit functional testing, load driven testing, data driven testing, and the like. Payload  can include one or more custom constraints, limitations, and the like.","Web service  can include one or more Application Programming Interface functionality. In one instance, service  can conform to Web 2.0 standards. Web service  can conform to one or more Web service specifications including, but not limited to, WS-Notification, WS-Policy, WS-MetadataExchange, Web Services Semantic (WSDL-S), Web Services Resource Framework, WS-Security, WS-ReliableMessaging, WS-BPEL, and the like.","Ontology  can be associated with one or more traditional and\/or proprietary ontology languages. Ontology languages can include, but is not limited to, Resource Description Framework (RDF), Ontology Web Language (OWL), and the like. Ontology  can conform to rules including, but not limited to, Semantic Web Rule Language (SWRL), Rule Interchange Format, and the like. Ontology  vocabulary can include, but is not limited to, Dublin Core, Semantically-Interlinked Online Communities, Description Of A Project (DOAP), and the like.","Semantic engine  can be a hardware\/software component able to generate an ontology  for an interface definition . Engine  can conform to traditional and\/or proprietary technologies. Engine  functionality can include metadata analysis, text analysis, and the like. In one embodiment, engine  can utilize service information from service directory  and\/or registry  to build an ontology . Engine  can include one or more semantic technologies. Engine  can be a networked computing element, distributed computing element and the like.","External registry  can be a communicatively linked Web services directory storing information about services . Registry  can be a traditional and\/or proprietary service directory. Registry  can be a cloud-based registry associated with one or more networks. For example, registry  can be a Universal Description, Discovery and Integration (UDDI) node within a cloud. Services  can be information associated with one or more Web services available within network . Services  can include public services, non-public services, and combinations thereof.","Network  can be an electrical and\/or computer network connecting one or more system  components. Network  can include, but is not limited to, twisted pair cabling, optical fiber, coaxial cable, and the like. Network  can include any combination of wired and\/or wireless components. Network  topologies can include, but is not limited to, bus, star, mesh, and the like. Network  types can include, but is not limited to, Local Area Network (LAN), Wide Area Network (WAN), VPN and the like. Network  can include, but is not limited to, an intranet, an internet, an extranet, and the like.","Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. System  can be one embodiment of the disclosure and should not be construed to limit the invention in any regard. Engine  can be a network element, distributed computing element, and the like. In one instance, system  can be a distributed computing environment. It should be appreciated that directory  and\/or registry  can be Universal Description, Discovery and Integration (UDDI) compliant elements. System  can utilize one or more traditional and\/or proprietary network communication protocols. Communication protocols can include, but is not limited to, Transport Control Protocol, Internet Protocol, User Datagram Protocol (UDP), Hypertext Transport Protocol, and the like.","The flowchart and block diagrams in the  illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be processed substantially concurrently, or the blocks may sometimes be processed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
