---
title: Processing structured data
abstract: The present invention provides a fast and efficient way of processing structured data by utilizing an intermediate file to store the structural information. The structured data may be processed into a Binary mask Format (BMF) file which may serve as a starting point for post-processing. A tree structure built on top of the BMF file may be constructed very quickly, and also takes up less space than a DOM tree. Additionally, BMF records may reside entirely in the memory and contain structural information, allowing SAX-like sequential data access.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761459&OS=07761459&RS=07761459
owner: XimpleWare, Inc.
number: 07761459
owner_city: Milpitas
owner_country: US
publication_date: 20061013
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 10\/272,077, filed Oct. 15, 2002 now U.S. Pat. No. 7,133,857, entitled \u201cPROCESSING STRUCTURED DATA,\u201d which is hereby incorporated by reference.","The present invention relates to the field of structured data files in computer systems. More specifically, the present invention relates to the processing of structured data in an efficient manner.","Structured data represents a large portion of the information accessed on the Internet and other computer networks. There are several reasons why structured data is so popular. American Standard Code for Information Interchange (ASCII) and its extensions, such as Unicode Transformation Formats UTF-8 and UTF-16 are among the most common standard encoding formats. Text encoding puts information into a format that is easily readable by a human, thus it is easy for programmers to develop and debug applications. Lastly, textual encoding is extensible and adding new information may be as simple as adding a new key-value pair.","Recently, Extensible Markup Language (XML) has been growing in popularity. XML is a markup language for documents containing structured information. Unlike its predecessor, Hypertext Markup Language (HTML), where tags are used to instruct a web browser how to render data, in XML the tags are designed to describe the data fields themselves. XML, therefore, provides a facility to define tags and the structural relationships between them. This allows a great deal of flexibility in defining markup languages to using information. Because XML is not designed to do anything other than describe what the data is, it serves as the perfect data interchange format.","XML, however, is not without its drawbacks. Compared with other data formats, XML can be very verbose. Processing an XML file can be very CPU and memory intensive, severely degrading overall application performance. Additionally, XML suffers many of the same problems that other software-based text-based processing methods have. Modern processors prefer binary data representations, particularly ones that fit the width of the registers, over text-based representations. Furthermore, the architecture of many general-purpose processors trades performance for programmability, thus making them ill-suited for text processing. Lastly, the efficient parsing of structured text, no matter the format, can present a challenge because of the added steps required to handle the structural elements.","Most current XML parsers are software-based solutions that follow either the Document Object Model (DOM) or Simple API for XML (SAX) technologies. DOM parsers convert an XML document into an in-memory hierarchical representation (known as a DOM tree), which can later be accessed and manipulated by programmers through a standard interface. SAX parsers, on the other hand, treat an XML document as a stream of characters. SAX is event-driven, meaning that the programmer specifies an event that may happen, and if that event occurs, SAX gets control and handles the situation.","In general, DOM and SAX are complementary, not competing, XML processing models, each with its own benefits and drawbacks. DOM programming is programmer-friendly, as the processing phase is separate from application logic. Additionally, because the data resides in the memory, repetitive access is fast and flexible. However, DOM requires that the entire document data structure, usually occupying 7-10 times the size of the original XML document, be loaded into the memory, thus making it impractical for large XML documents. SAX, on the other hand, can be efficient in parsing large XML documents (at least when only small amounts of information need to be processed at once), but it maintains little of the structural information of the XML data, putting more of a burden on programmers and resulting in code that is hardwired, bulky, and difficult to maintain.","What is needed is an application program interface (API) that combines the best attributes of both DOM and SAX parsing.","The present invention provides a fast and efficient way of processing structured data by utilizing an intermediate file to store the structural information. The structured data may be processed into a Binary mask Format (BMF) file which may serve as a starting point for post-processing. A tree structure built on top of the BMF file may be constructed very quickly, and also takes up less space than a DOM tree. Additionally, BMF records may reside entirely in the memory and contain structural information, allowing SAX-like sequential data access.","Embodiments of the present invention are described herein in the context of a system of computers, servers, and software. Those of ordinary skill in the art will realize that the following detailed description of the present invention is illustrative only and is not intended to be in any way limiting. Other embodiments of the present invention will readily suggest themselves to such skilled persons having the benefit of this disclosure. Reference will now be made in detail to implementations of the present invention as illustrated in the accompanying drawings. The same reference indicators will be used throughout the drawings and the following detailed description to refer to the same or like parts.","In the interest of clarity, not all of the routine features of the implementations described herein are shown and described. It will, of course, be appreciated that in the development of any such actual implementation, numerous implementation-specific decisions must be made in order to achieve the developer's specific goals, such as compliance with application- and business-related constraints, and that these specific goals will vary from one implementation to another and from one developer to another. Moreover, it will be appreciated that such a development effort might be complex and time-consuming, but would nevertheless be a routine undertaking of engineering for those of ordinary skill in the art having the benefit of this disclosure.","In accordance with the present invention, the components, process steps, and\/or data structures may be implemented using various types of operating systems, computing platforms, computer programs, and\/or general purpose machines. In addition, those of ordinary skill in the art will recognize that devices of a less general purpose nature, such as hardwired devices, field programmable gate arrays (FPGAs), application specific integrated circuits (ASICs), or the like, may also be used without departing from the scope and spirit of the inventive concepts disclosed herein.","For purposes of this disclosure, a structured data file is any file containing content as well as some information regarding the structural organization of the content. The present invention provides a fast and efficient way of processing structured data by utilizing an intermediate file to store the structural information. The structured data may be processed into a Binary mask Format (BMF) file which may serve as a starting point for post-processing. A tree structure built on top of the BMF file may be constructed very quickly, and also takes up less space than a DOM tree. Additionally, BMF records may reside entirely in the memory and contain structural information, allowing SAX-like sequential data access. However, while this document will describe advantages that the present invention provides over DOM or SAX, one of ordinary skill in the art will recognize that the present invention need not be limited to replacing DOM or SAX, and can be expanded to non-XML type processing.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","102","100","104","104"]},"The hardware may be designed such that it may quickly match multiple patterns against an incoming data stream.  is a block diagram illustrating an apparatus for efficiently processing structured data in accordance with an embodiment of the present invention. A text processor  may be the core of the accelerator. It may be composed of multiple Finite State Machines (FSMs) that process an incoming document in parallel. The output may be the BMF file. It also may set several result registers (not pictured). A PCI interface  may handle all handshaking between the hardware and a server PCI bus . A memory controller  may receive commands from the PCI interface  and convert the PCI address to on-board memory address space. It also may access the board memory accordingly. Configuration registers  may determine the configuration of the text processing pipeline and the organization of the memory controller . It may load default values from configuration ROM . Some of the values may be modified by software through the PCI interface . The Configuration ROM  may store the default setting of the text processor configuration. It also may store the configuration map of FPGAs.","A document buffer  may store the incoming document. This may be a Synchronous Dynamic Random Access Memory (SDRAM). Paging may be utilized if the incoming document is larger than the total buffer size. A BMF buffer  may store the output BMF files, together with several other text processor result register values. This may be a separate SDRAM, although in one embodiment of the present invention it may share a single SDRAM with the document buffer. A string cache  may buffer the incoming data to smooth out and speed up SDRAM access. A DMA engine  may grab the frame data from server main memory and send it back the BMF file.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["300","302","304","306","308","310"]},"The PCI target may sense a valid window to send data. Then the PCI master may assert the frame number to indicate the beginning of a read transaction . The PCI target holds the bus. The DMA engine may then transfer the BMF and result register data to main memory . When all the data is transferred, the PCI target interface may send an end signal to the device driver . The next document processing cycle may start again with a start signal from the device driver .","The output of the hardware is a BMF. In one embodiment of the present invention, the BMF defines a binary record format that is used to describe various fields in a structured data file. It can be viewed as a two-dimensional field of bits. Each piece of useful information in the structured data file may correspond to a record in the BMF file. A record may comprise a starting offset and length of a target string in the structured data file. It may also comprise the depth value, node type, and bit-wide flags. These will be discussed in more detail below. The total length of a record may be an integer multiple of a 32-bit word\u2014the width of the memory bus in most commercial architectures. Two record types may be defined: a full version of 12 bytes in length, and a compressed version of 8 bytes in length. The full version may be based on the assumption that both the string length and the starting offset are 32-bits wide, whereas the compressed version may assume a 16-bit field, which translates to a maximum length of 65536 bytes.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4","b":["400","402","404","406","408","410"]},"There are at least three types of possible BMF file modes: read-only mode, read-modify mode, and read-modify-add mode. In read-only mode, records representing various types of nodes may be placed sequentially into a BMF file, leaving no empty records. For example, a leaf-level element may be represented as a record for the starting tag, records (one of r property name and one property value) for n properties, and one record for the text for the element, and finally one record for an ending tag name. The presence of the ending tag record may be used for document validation.","The read-modify mode may be identical to read-only mode except each record allows for limited write-access, meaning content can be altered, but not added.","The read-modify-add mode allows complete write-access, which is done by embedding empty records into the file.","The record format may be picked to efficiently represent the necessary information of the original data structure. It may also be made less efficient on purpose to speed up downstream processing.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5","b":["500","502","504"]},{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Content Types and Corresponding Values"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Content",{},{}]},{"entry":"Type"},{"entry":["Value","Content name","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","Starting Tag","<>"]},{"entry":["1","Ending Tag","<\/>"]},{"entry":["2","Property Name","<example =\u201cthis\u201d>"]},{"entry":["3","Property Value","<example property2=\u201c\u201d>"]},{"entry":["4","Text","<example>"]},{"entry":[{},{},"<\/example>"]},{"entry":["5","Comment","<!- -  - ->"]},{"entry":["6","Processing Instruction","<?  ?>"]},{"entry":["7","Markup declaration I","<![[...<<<>>>...]]>"]},{"entry":[{},"name"]},{"entry":["8","Markup declaration I","<![CDATA[]>"]},{"entry":[{},"value"]},{"entry":["9","Markup declaration II","<! ...>"]},{"entry":[{},"name"]},{"entry":["10","Markup declaration II","<!ENTITY >"]},{"entry":[{},"value"]},{"entry":["11","Entity reference","&example.bib;"]},{"entry":["12","Property Name Value","<example >"]},{"entry":[{},"Pair"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"A modification indicator  may also be provided, which indicates whether or not the record has been modified. This is important because, as described above, if the record has been modified, then the offset field will contain the real pointer value, not a relative offset. An insertion indicator  may indicate that data was inserted in between two existing records. Once again, this is important in determining how to utilize the offset field. If the insertion indicator is set to 1, it indicates that the offset field contains a pointer to an external piece of memory, one that can be used to add child nodes to the current node. An end of document indicator  may indicate whether the tag is the last one in the document. This can be important because in some embodiments, ending tags may be ignored when encoding the BMF file in order to save space. Therefore, the last tag in the BMF file may not correspond to the last tag in the structured data file.","A current record in use field  may be used to indicate that a record has been deleted. If the field is set to 0, the record may be safely ignored because it has been deleted. A name space indicator  may indicate whether or not there is a name space within the token (which may be represented by an \u201c=\u201d sign). A reference bit  may indicate when there is an external reference, such as an \u201c&\u201d in a text string.","There may be one or more reserved bits , which are set aside for future uses. Lastly, a length field  may indicate the length of the content.","The BMF file, together with the original data in memory, completely describes the original data and its inherent data structure. Traversing the data structure may be easily accomplished using the BMF records. Higher level applications and processing are therefore facilitated by using the BMF. To make it easily accessible and readily integrated to higher level application and processing, device drivers and an application programming interface (API) may be built on top of the BMF.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6","b":["600","602","604","606","608"]},"At , a modification indicator for the piece of content may be stored in the BMF record, the modification indicator indicating if the BMF record has been modified and the modification indicator initially set to indicate that no modification has been made. At , an insertion indicator for the piece of content may be stored in the BMF record, the insertion indicator indicating if the BMF record has been inserted between two existing BMF records and the insertion indicator initially set to indicate that the BMF record has not been inserted between two existing BMF records. At , an end of document indicator for the piece of content may be stored in the BMF record, the end of document indicator indicating if the BMF record corresponds to a last piece of content in the structured data file. At , a current record in use field may be stored for the piece of content in the BMF record, the current record in use field indicating whether the piece of content has been deleted.","The following example may be used to illustrate an embodiment of the present invention. One of ordinary skill in the art will recognize that this is merely an example and should not be read to be limiting in any way. Suppose an XML file as follows:","<?xml version=\u201c1.0\u201d encoding=\u201cUS-ASCII\u201d?>","<benchmark:database xmlns:benchmark=\u201chttp:\/\/example.com\/xml\/benchmark\u201d>","<benchmark:person id=\u201c012345\u201d>","<benchmark:email name=\u201cName012345\u201d\/>","<!\u2014Edited with XML spy v4.2\u2014>","<benchmark:line1>L i n e 1 012345 012345<\/benchmark:line1>","<\/benchmark:person>","<\/benchmark:database>","An embodiment of the present invention may ignore ending tags and produce the following BMF file:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},{},"End of","Current",{},{},{},{}]},{"entry":["Starting",{},"Token","Modify","Insertion","Document","Record in","Name space"]},{"entry":["offset","Depth","type","indicator","Indicator","Indicator","use","indicator","Reference",{},"Length"]},{"entry":["32 bit","5 bit","4 bit","1 bit","1 bit","1 bit","1 bit","1 bit","indicator","unused","16 bit"]},{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2","0","6","0","0","0","1","0","0","0","38"]},{"entry":["42","0","0","0","0","0","1","1","0","0","18"]},{"entry":["61","0","2","0","0","0","1","1","0","0","14"]},{"entry":["78","0","3","0","0","0","1","0","0","0","35"]},{"entry":["116","1","0","0","0","0","1","1","0","0","16"]},{"entry":["133","1","2","0","0","0","1","0","0","0","2"]},{"entry":["137","1","3","0","0","0","1","0","0","0","6"]},{"entry":["147","2","0","0","0","0","1","1","0","0","15"]},{"entry":["163","2","2","0","0","0","1","0","0","0","4"]},{"entry":["169","2","3","0","0","0","1","0","0","0","10"]},{"entry":["185","1","5","0","0","0","1","0","0","0","25"]},{"entry":["218","2","0","0","0","0","1","1","0","0","15"]},{"entry":["234","2","4","0","0","0","1","0","0","0","23"]},{"entry":["0","0","0","0","0","1","1","0","0","0","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"35pt","align":"center"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["00000000000000000000000000000010","00000","0110","0","0","0","1","0","0","0","00100110"]},{"entry":["00000000000000000000000000101010","00000","0000","0","0","0","1","1","0","0","00010010"]},{"entry":["00000000000000000000000000111101","00000","0010","0","0","0","1","1","0","0","00001110"]},{"entry":["00000000000000000000000001001110","00001","0011","0","0","0","1","0","0","0","00100011"]},{"entry":["00000000000000000000000001110100","00001","0000","0","0","0","1","1","0","0","00010000"]},{"entry":["00000000000000000000000010000101","00001","0010","0","0","0","1","0","0","0","00000010"]},{"entry":["00000000000000000000000010001001","00010","0011","0","0","0","1","0","0","0","00000110"]},{"entry":["00000000000000000000000010010011","00010","0000","0","0","0","1","1","0","0","00001111"]},{"entry":["00000000000000000000000010100011","00010","0010","0","0","0","1","0","0","0","00000100"]},{"entry":["00000000000000000000000010101001","00001","0011","0","0","0","1","0","0","0","00001010"]},{"entry":["00000000000000000000000010111001","00010","0101","0","0","0","1","0","0","0","00011001"]},{"entry":["00000000000000000000000011011010","00010","0000","0","0","0","1","1","0","0","00001111"]},{"entry":["00000000000000000000000011101010","00010","0100","0","0","0","1","0","0","0","00010111"]},{"entry":["00000000000000000000000000000000","00000","0000","0","1","1","1","0","0","0","00000000"]},{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}]}}}}},"Currently, DOM (a W3C standard) is well-defined and the most widely used representation of XML's inherent hierarchy. DOM represents an XML document as a tree structure, with the elements, attributes, and text defined as nodes. A node may have a single parent node, sibling nodes and child nodes. For example, consider the following XML snippet:","<A>text<B attrName=\u201cval\u201d><C>text<\/C><C>text <\/C><\/B><B><\/B><B><\/B><\/A>","The node named \u201cB\u201d has a parent node named \u201cA.\u201d It also has two child nodes, respectively named \u201cC\u201d and \u201cC.\u201d The \u201cC\u201d node is the first child node as it appears before the \u201cC\u201d node in the XML text. The \u201cB\u201d node also has sibling nodes named \u201ctext\u201d, \u201cB\u201d and \u201cB\u201d respectively. The text node named \u201cText \u201d is the previous sibling of the node \u201cB.\u201d The \u201cB\u201d is the next sibling for \u201cB\u201d node as it appears before \u201cB\u201d node. By the same token, the \u201cB\u201d node is the next sibling node for \u201cB\u201d node. Also the first and only child of the \u201cC\u201d node is a text node named \u201ctext.\u201d","DOM treats attribute nodes differently. In the XML snippet shown above, the \u201cB\u201d node doesn't treat its attribute named \u201cattrName\u201d as its child.","Many DOM node types have their equivalent BMF types. For example, an element type in DOM corresponds to the starting tag. DOM, however, does not have a node type corresponding to BMF's ending tag type.","Since a BMF file completely describes the inherent structure in the data file as one can navigate the document by scanning across of BMF records and keeping track of their token types. And they don't need any additional descriptors to identify its siblings, children, or parent. The inclusion of ending tag as a type is important. DOM resorts to various pointers and complex data structures to maintain the hierarchical information of XML, and does not have a node type corresponding to ending tag. SAX returns ending tags of XML, but discards them by default. In contrast, a BMF file maintains the ending tag in memory as a record so the structure information of an XML file is unambiguous. Consider the following examples:","<a><b><\/b><b><\/b><\/a>","<a><b><b><\/b><\/b><\/a>","If the ending tags are missing, the corresponding BMF have identical record types","Starting tag for a","Starting tag for b","Starting tag for b","Without ending tags, it will be difficult to determine whether b is the sibling, or child, of b. With ending tags, one can clearly tell the relationship between b and b in the above examples.","In Example 1, the token types are:","Starting tag for a","Starting tag for b","Ending tag for b","Starting tag for b","Ending tag for b","Ending tag for a","In Example 2, the token types are:","Starting tag for a","Starting tag for b","Starting tag for b","Ending tag for b","Ending tag for b","Ending tag for a","To tell whether b is a sibling, or child, of b, one can calculate the depth value of each tags. In example 1, b and b both have the same depth value so they are siblings. In example 2, b and b have depth value of 1 and 2 respectively, so b is the child of b.","When the depth value is included in the BMF records, ending tags can be ignored to save space.","In some cases, it would be beneficial to have some additional way to speed up the traversal of document structure. For example, a BMF record can contain a 32-bit descriptor which contains the reference in various forms, such as the relative index value, absolute index value or memory address, of the next sibling or first child, but not both, as there is additional storage overhead for having such descriptors.","The reference to the next sibling makes it possible to jump to the next sibling without scanning the BMF records between the current record and its next sibling. The reference to the first child record makes it possible to jump to the first child without scanning the BMF records between the current record and first child record. Some of the other possible references a BMF record can have are parent, root, previous sibling, last child. It should be noted that the reference to a child node is actually a reference to a record corresponding to the child node, as the nodes are represented in the intermediate file as records. Likewise the reference to a next sibling node is actually a reference to a record corresponding to the next sibling node.","When a record does not have a sibling, it is convenient to use some constant value to denote the absence of the sibling. That constant value can be thought of as a special reference value. For example, a constant value of zero at the descriptor field could be interpreted as there is not sibling or child, depending on the actual usage of the descriptor.","One of ordinary skill in the art will recognize that the processes described herein can also be embodied in a program storage device tangibly embodying a set of computer instructions to perform the processes. Examples of such program storage devices include floppy disks, hard drives, and CD-ROMs.","While embodiments and applications of this invention have been shown and described, it would be apparent to those skilled in the art having the benefit of this disclosure that many more modifications than mentioned above are possible without departing from the inventive concepts herein. The invention, therefore, is not to be restricted except in the spirit of the appended claims."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF DESCRIPTION OF THE INVENTION","DETAILED DESCRIPTION","Example 1","Example 2"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated into and constitute a part of this specification, illustrate one or more embodiments of the present invention and, together with the detailed description, serve to explain the principles and implementations of the invention.","In the drawings:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
