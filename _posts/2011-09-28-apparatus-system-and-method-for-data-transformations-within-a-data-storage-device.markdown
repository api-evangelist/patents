---
title: Apparatus, system, and method for data transformations within a data storage device
abstract: Apparatuses, systems, and methods are disclosed for executing data transformations for a data storage device. A storage controller module controls a storage operation for a set of data within a data storage device. A transformation module determines to apply a data transformation to the set of data in response to a transformation indicator. A processing module applies the data transformation to the set of data internally on the data storage device prior to completing the storage operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09263102&OS=09263102&RS=09263102
owner: SanDisk Technologies, Inc.
number: 09263102
owner_city: Plano
owner_country: US
publication_date: 20110928
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims priority to U.S. Provisional Patent Application No. 61\/387,082 entitled \u201cAPPARATUS, SYSTEM, AND METHOD FOR DATA TRANSFORMATIONS WITHIN A DATA STORAGE DEVICE\u201d and filed on Sep. 28, 2010 for David Flynn, et al., which is incorporated herein by reference.","This invention relates to data storage and more particularly relates to transforming stored data.","Data storage devices typically access data in fixed sized data blocks. When a client is using data in a size smaller than a full data block, it must still access the full block. Providing access to data only in fixed sized blocks can be an inefficient use of system resources.","Transferring full data blocks when less than the full data blocks are being used increases traffic on data buses, which typically have limited bandwidth. Processing full data blocks can increase processing overhead for host devices and for clients using the data. Transferring and processing full data blocks when less than full data blocks are being used also consumes more host memory than would otherwise be used.","Even when a client is using full data blocks, processing large amounts of data can also be taxing on system resources. As data is processed, it is typically transferred on a data bus, stored in host memory, and processed using a host processor, all consuming resources of a host device.","Methods of the present invention are presented for executing data transformations for a data storage device. In one embodiment, a method includes initiating a block I\/O operation for a set of data within a data storage device. A method, in a further embodiment, includes determining to apply a data transformation to the set of data in response to a client request. In a certain embodiment, the client request defines the data transformation and includes a request to apply the data transformation. In another embodiment, a method includes applying the data transformation to the set of data in response to a determination that applying the data transformation satisfies an efficiency metric, and prior to completing the block I\/O operation.","Apparatuses are presented for executing data transformations for a data storage device. In one embodiment, a storage controller module is configured to control a block I\/O operation for a set of data within a data storage device. A transformation module, in one embodiment, is configured to determine to apply a data transformation to the set of data in response to a transformation indicator. In a certain embodiment, the transformation indicator is provided by a client request that identifies the block I\/O operation and the data transformation. A processing module, in a further embodiment, is configured to apply the data transformation to the set of data internally on the data storage device prior to completing the block I\/O operation in response to a determination that the data transformation is capable of being applied at a full data rate for a data pipeline configured to service the block I\/O operation within the data storage device.","Systems are presented for executing data transformations for a data storage device. In one embodiment, a system includes a solid-state data storage device. The solid-state data storage device, in one embodiment, is in communication with a host device over a communications bus. A storage controller module, in a further embodiment, controls a block I\/O operation for a set of data within the data storage device. A modification module, in another embodiment, determines to apply a data modification to the set of data in response to a client request that identifies the data modification. In certain embodiments, a processing module applies the data transformation to the set of data in response to a determination that applying the data modification satisfies an efficiency metric, and prior to completing the block I\/O operation.","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Many of the functional units described in this specification have been labeled as modules, in order to more particularly emphasize their implementation independence. For example, a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays, off-the-shelf semiconductors such as logic chips, transistors, or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays, programmable array logic, programmable logic devices or the like.","Modules may also be implemented in software for execution by various types of processors. An identified module of computer readable program code may, for instance, comprise one or more physical or logical blocks of computer instructions which may, for instance, be organized as an object, procedure, or function. Nevertheless, the executables of an identified module need not be physically located together, but may comprise disparate instructions stored in different locations which, when joined logically together, comprise the module and achieve the stated purpose for the module.","Indeed, a module of computer readable program code may be a single instruction, or many instructions, and may even be distributed over several different code segments, among different programs, and across several memory devices. Similarly, operational data may be identified and illustrated herein within modules, and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set, or may be distributed over different locations including over different storage devices, and may exist, at least partially, merely as electronic signals on a system or network. Where a module or portions of a module are implemented in software, the computer readable program code may be stored and\/or propagated on or in one or more computer readable medium(s).","The computer readable medium may be a tangible computer readable storage medium storing the computer readable program code. The computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, holographic, micromechanical, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing.","More specific examples of the computer readable medium may include but are not limited to a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), a portable compact disc read-only memory (CD-ROM), a digital versatile disc (DVD), an optical storage device, a magnetic storage device, a holographic storage medium, a micromechanical storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, and\/or store computer readable program code for use by and\/or in connection with an instruction execution system, apparatus, or device.","The computer readable medium may also be a computer readable signal medium. A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electrical, electro-magnetic, magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport computer readable program code for use by or in connection with an instruction execution system, apparatus, or device. Computer readable program code embodied on a computer readable signal medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, Radio Frequency (RF), or the like, or any suitable combination of the foregoing. In one embodiment, the computer readable medium may comprise a combination of one or more computer readable storage mediums and one or more computer readable signal mediums. For example, computer readable program code may be both propagated as an electro-magnetic signal through a fiber optic cable for execution by a processor and stored on RAM storage device for execution by the processor.","Computer readable program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The computer readable program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Reference throughout this specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d or similar language means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. Thus, appearances of the phrases \u201cin one embodiment,\u201d \u201cin an embodiment,\u201d and similar language throughout this specification may, but do not necessarily, all refer to the same embodiment, but mean \u201cone or more but not all embodiments\u201d unless expressly specified otherwise. The terms \u201cincluding,\u201d \u201ccomprising,\u201d \u201chaving,\u201d and variations thereof mean \u201cincluding but not limited to,\u201d unless expressly specified otherwise. An enumerated listing of items does not imply that any or all of the items are mutually exclusive, unless expressly specified otherwise. The terms \u201ca,\u201d \u201can,\u201d and \u201cthe\u201d also refer to \u201cone or more\u201d unless expressly specified otherwise.","Furthermore, the described features, structures, or characteristics of the embodiments may be combined in any suitable manner. In the following description, numerous specific details are provided, such as examples of programming, software modules, user selections, network transactions, database queries, database structures, hardware modules, hardware circuits, hardware chips, etc., to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize, however, that embodiments may be practiced without one or more of the specific details, or with other methods, components, materials, and so forth. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of an embodiment.","Aspects of the embodiments are described below with reference to schematic flowchart diagrams and\/or schematic block diagrams of methods, apparatuses, systems, and computer program products according to embodiments of the invention. It will be understood that each block of the schematic flowchart diagrams and\/or schematic block diagrams, and combinations of blocks in the schematic flowchart diagrams and\/or schematic block diagrams, can be implemented by computer readable program code. These computer readable program code may be provided to a processor of a general purpose computer, special purpose computer, sequencer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the schematic flowchart diagrams and\/or schematic block diagrams block or blocks.","The computer readable program code may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the schematic flowchart diagrams and\/or schematic block diagrams block or blocks.","The computer readable program code may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the program code which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The schematic flowchart diagrams and\/or schematic block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of apparatuses, systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the schematic flowchart diagrams and\/or schematic block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions of the program code for implementing the specified logical function(s).","It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the Figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. Other steps and methods may be conceived that are equivalent in function, logic, or effect to one or more blocks, or portions thereof, of the illustrated Figures.","Although various arrow types and line types may be employed in the flowchart and\/or block diagrams, they are understood not to limit the scope of the corresponding embodiments. Indeed, some arrows or other connectors may be used to indicate only the logical flow of the depicted embodiment. For instance, an arrow may indicate a waiting or monitoring period of unspecified duration between enumerated steps of the depicted embodiment. It will also be noted that each block of the block diagrams and\/or flowchart diagrams, and combinations of blocks in the block diagrams and\/or flowchart diagrams, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer readable program code.","Solid-State Storage System",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","114","116"]},"The system  includes at least one solid-state storage device . In another embodiment, the system  includes two or more solid-state storage devices . Each solid-state storage device  may include non-volatile, solid-state storage media , such as flash memory, nano random access memory (\u201cnano RAM or NRAM\u201d), nanocrystal wire-based memory, silicon-oxide based sub-10 nanometer process memory, graphene memory, Silicon-Oxide-Nitride-Oxide-Silicon (\u201cSONOS\u201d), Resistive random-access memory (\u201cRRAM\u201d), programmable metallization cell (\u201cPMC\u201d), conductive-bridging RAM (\u201cCBRAM\u201d), magneto-resistive RAM (\u201cMRAM\u201d), dynamic RAM (\u201cDRAM\u201d), phase change RAM (\u201cPRAM\u201d), etc. The solid-state storage device  is described in more detail with respect to . The solid-state storage device  is depicted in a computer  connected to a client  through a computer network .","In one embodiment, the solid-state storage device  is internal to the computer  and is connected using a system communications bus, such as a peripheral component interconnect express (\u201cPCI-e\u201d) bus, a Serial Advanced Technology Attachment (\u201cserial ATA\u201d) bus, or the like. In another embodiment, the solid-state storage device  is external to the computer  and is connected using an external communications bus, such as a universal serial bus (\u201cUSB\u201d) connection, an Institute of Electrical and Electronics Engineers (\u201cIEEE\u201d) 1394 bus (\u201cFireWire\u201d), or the like. In other embodiments, the solid-state storage device  is connected to the computer  using a peripheral component interconnect (\u201cPCI\u201d) express bus using external electrical or optical bus extension or bus networking solution such as Infiniband or PCI Express Advanced Switching (\u201cPCIe-AS\u201d), or the like. In certain embodiments, one or more peer hardware devices may be in communication with the computer  over the same communications bus, such as a graphics processing unit (\u201cGPU\u201d) on a PCI-e bus or the like.","In various embodiments, the solid-state storage device  may be in the form of a dual-inline memory module (\u201cDIMM\u201d), a daughter card, or a micro-module. In another embodiment, the solid-state storage device  is an element within a rack-mounted blade. In another embodiment, the solid-state storage device  is contained within a package that is integrated directly onto a higher level assembly (e.g. mother board, lap top, graphics processor). In another embodiment, individual components comprising the solid-state storage device  are integrated directly onto a higher level assembly without intermediate packaging.","The solid-state storage device  includes one or more solid-state storage controllers , each may include a write data pipeline  and a read data pipeline  and each includes a solid-state storage media , which are described in more detail below with respect to . The solid-state storage controller , in certain embodiments, comprises a solid-state storage controller module, that may comprise logic hardware of the data storage device  or a combination of both hardware of the data storage device  and a device driver executing on the computer .","The system  includes one or more computers  connected to the solid-state storage device . A computer  may be a host, a server, a storage controller of a storage area network (\u201cSAN\u201d), a workstation, a personal computer, a laptop computer, a handheld computer, a supercomputer, a computer cluster, a network switch, router, or appliance, a database or storage appliance, a data acquisition or data capture system, a diagnostic system, a test system, a robot, a portable electronic device, a wireless device, or the like. In another embodiment, a computer  may be a client and the solid-state storage device  operates autonomously to service data requests sent from the computer . In this embodiment, the computer  and solid-state storage device  may be connected using a computer network, system bus, or other communication means suitable for connection between a computer  and an autonomous solid-state storage device . The computer  is one embodiment of a host device for the solid-state storage device .","In one embodiment, the system  includes one or more clients  connected to one or more computers  through one or more computer networks . A client  may be a host, a server, a storage controller of a SAN, a workstation, a personal computer, a laptop computer, a handheld computer, a supercomputer, a computer cluster, a network switch, router, or appliance, a database or storage appliance, a data acquisition or data capture system, a diagnostic system, a test system, a robot, a portable electronic device, a wireless device, or the like. In another embodiment, the client  operates within the computer . The client  may be an application, a server, an applet, a thread, a driver, a database management system, a daemon, or the like. The computer network  may include the Internet, a wide area network (\u201cWAN\u201d), a metropolitan area network (\u201cMAN\u201d), a local area network (\u201cLAN\u201d), a token ring, a wireless network, a fiber channel network, a SAN, network attached storage (\u201cNAS\u201d), ESCON, or the like, or any combination of networks. The computer network  may also include a network from the IEEE 802 family of network technologies, such Ethernet, token ring, WiFi, WiMax, and the like.","The computer network  may include servers, switches, routers, cabling, radios, and other equipment used to facilitate networking computers  and clients . In one embodiment, the system  includes multiple computers  that communicate as peers over a computer network . In another embodiment, the system  includes multiple solid-state storage devices  that communicate as peers over a computer network . One of skill in the art will recognize other computer networks  comprising one or more computer networks  and related equipment with single or redundant connection between one or more clients  or other computer with one or more solid-state storage devices  or one or more solid-state storage devices  connected to one or more computers . In one embodiment, the system  includes two or more solid-state storage devices  connected through the computer network  to a client  without a computer .","Solid-State Storage Device",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","202","106","108","102","202","202","0","104","110"],"i":["a","n"]},"In the depicted embodiment, two solid-state controllers are shown: solid-state controller  and solid-state storage controller N , and each controls solid-state storage media -. In the depicted embodiment, solid-state storage controller  controls a data channel so that the attached solid-state storage media stores data. Solid-state storage controller N controls an index metadata channel associated with the stored data and the associated solid-state storage media stores index metadata. In an alternate embodiment, the solid-state storage device controller  includes a single solid-state controller with a single solid-state storage media . In another embodiment, there are a plurality of solid-state storage controllers -and associated solid-state storage media -. In one embodiment, one or more solid-state controllers --, coupled to their associated solid-state storage media --, control data while at least one solid-state storage controller , coupled to its associated solid-state storage media , controls index metadata.","In one embodiment, at least one solid-state controller  is field-programmable gate array (\u201cFPGA\u201d) and controller functions are programmed into the FPGA. In a particular embodiment, the FPGA is a Xilinx\u00ae FPGA. In another embodiment, the solid-state storage controller  comprises components specifically designed as a solid-state storage controller , such as an application-specific integrated circuit (\u201cASIC\u201d) or custom logic solution. Each solid-state storage controller  typically includes a write data pipeline  and a read data pipeline , which are describe further in relation to . In another embodiment, at least one solid-state storage controller  is made up of a combination FPGA, ASIC, and custom logic components.","Solid-State Storage","The solid-state storage media  is an array of non-volatile solid-state storage elements , , , arranged in banks , and accessed in parallel through a bi-directional storage input\/output (\u201cI\/O\u201d) bus . The storage I\/O bus , in one embodiment, is capable of unidirectional communication at any one time. For example, when data is being written to the solid-state storage media , data cannot be read from the solid-state storage media . In another embodiment, data can flow both directions simultaneously. However bi-directional, as used herein with respect to a data bus, refers to a data pathway that can have data flowing in only one direction at a time, but when data flowing one direction on the bi-directional data bus is stopped, data can flow in the opposite direction on the bi-directional data bus.","A solid-state storage element (e.g. SSS . ) is typically configured as a chip (a package of one or more dies) or a die on a circuit board. As depicted, a solid-state storage element (e.g. ) operates independently or semi-independently of other solid-state storage elements (e.g. ) even if these several elements are packaged together in a chip package, a stack of chip packages, or some other package element. As depicted, a row of solid-state storage elements , , is designated as a bank .","As depicted, there may be \u201cn\u201d banks -and \u201cm\u201d solid-state storage elements -, -, -per bank in an array of n\u00d7m solid-state storage elements , ,  in a solid-state storage media . Of course different embodiments may include different values for n and m. In one embodiment, the solid-state storage media includes twenty solid-state storage elements , ,  per bank  with eight banks . In one embodiment, the solid-state storage media includes twenty four solid-state storage elements , ,  per bank  with eight banks . In addition to the n\u00d7m storage elements , , , one or more additional columns (P) may also be addressed and operated in parallel with other solid-state storage elements , , for one or more rows. The added P columns in one embodiment, store parity data for the portions of an ECC chunk (i.e. an ECC codeword) that span m storage elements for a particular bank. In one embodiment, each solid-state storage element , ,  is comprised of single-level cell (\u201cSLC\u201d) devices. In another embodiment, each solid-state storage element , ,  is comprised of multi-level cell (\u201cMLC\u201d) devices.","In one embodiment, solid-state storage elements that share a common storage I\/O bus (e.g. , , ) are packaged together. In one embodiment, a solid-state storage element , ,  may have one or more dies per chip with one or more chips stacked vertically and each die may be accessed independently. In another embodiment, a solid-state storage element (e.g. SSS . ) may have one or more virtual dies per die and one or more dies per chip and one or more chips stacked vertically and each virtual die may be accessed independently. In another embodiment, a solid-state storage element SSS . may have one or more virtual dies per die and one or more dies per chip with some or all of the one or more dies stacked vertically and each virtual die may be accessed independently.","In one embodiment, two dies are stacked vertically with four stacks per group to form eight storage elements (e.g. SSS .-SSS .) -, each in a separate bank -. In another embodiment, 24 storage elements (e.g. SSS .-SSS .)  form a logical bank so that each of the eight logical banks has 24 storage elements (e.g. SSS.-SSS .) , , . Data is sent to the solid-state storage media  over the storage I\/O bus  to all storage elements of a particular group of storage elements (SSS .-SSS .) , , . The storage control bus is used to select a particular bank (e.g. Bank  ) so that the data received over the storage I\/O bus  connected to all banks  is written just to the selected bank ","In a one embodiment, the storage I\/O bus  is comprised of one or more independent I\/O buses (\u201cIIOBa-m\u201d comprising -, -) wherein the solid-state storage elements within each column share one of the independent I\/O buses that accesses each solid-state storage element , ,  in parallel so that all banks  are accessed simultaneously. For example, one channel of the storage I\/O bus  may access a first solid-state storage element , , of each bank -simultaneously. A second channel of the storage I\/O bus  may access a second solid-state storage element , , of each bank -simultaneously. Each row of solid-state storage element , , is accessed simultaneously. In one embodiment, where solid-state storage elements , ,  are multi-level (physically stacked), all physical levels of the solid-state storage elements , ,  are accessed simultaneously. As used herein, \u201csimultaneously\u201d also includes near simultaneous access where devices are accessed at slightly different intervals to avoid switching noise. Simultaneously is used in this context to be distinguished from a sequential or serial access wherein commands and\/or data are sent individually one after the other.","Typically, banks -are independently selected using the storage control bus . In one embodiment, a bank  is selected using a chip enable or chip select. Where both chip select and chip enable are available, the storage control bus  may select one level of a multi-level solid-state storage element , , . In other embodiments, other commands are used by the storage control bus  to individually select one level of a multi-level solid-state storage element , , . Solid-state storage elements , ,  may also be selected through a combination of control and of address information transmitted on storage I\/O bus  and the storage control bus .","In one embodiment, each solid-state storage element , ,  is partitioned into erase blocks and each erase block is partitioned into pages. An erase block on a solid-state storage element ,   may be called a physical erase block or \u201cPEB.\u201d A typical page is 2000 bytes (\u201c2 kB\u201d). In one example, a solid-state storage element (e.g. SSS .) includes two registers and can program two pages so that a two-register solid-state storage element , ,  has a capacity of 4 kB. A bank  of 20 solid-state storage elements , , would then have an 80 kB capacity of pages accessed with the same address going out the channels of the storage I\/O bus .","This group of pages in a bank  of solid-state storage elements , , of 80 kB may be called a logical page or virtual page. Similarly, an erase block of each storage element -of a bank may be grouped to form a logical erase block or a virtual erase block. In one embodiment, an erase block of pages within a solid-state storage element , ,  is erased when an erase command is received within a solid-state storage element , , . Whereas the size and number of erase blocks, pages, planes, or other logical and physical divisions within a solid-state storage element , ,  are expected to change over time with advancements in technology, it is to be expected that many embodiments consistent with new configurations are possible and are consistent with the general description herein.","Typically, when a packet is written to a particular location within a solid-state storage element , , , wherein the packet is intended to be written to a location within a particular page which is specific to a particular physical erase block of a particular storage element of a particular bank, a physical address is sent on the storage I\/O bus  and followed by the packet. The physical address contains enough information for the solid-state storage element , ,  to direct the packet to the designated location within the page. Since all storage elements in a column of storage elements (e.g. SSS .-SSS N. , , ) are accessed simultaneously by the appropriate bus within the storage I\/O bus , to reach the proper page and to avoid writing the data packet to similarly addressed pages in the column of storage elements (SSS .-SSS N. , , ), the bank that includes the solid-state storage element SSS . with the correct page where the data packet is to be written is simultaneously selected by the storage control bus .","Similarly, satisfying a read command on the storage I\/O bus  requires a simultaneous signal on the storage control bus  to select a single bank and the appropriate page within that bank . In one embodiment, a read command reads an entire page, and because there are multiple solid-state storage elements , , in parallel in a bank , an entire logical page is read with a read command. However, the read command may be broken into subcommands, as will be explained below with respect to bank interleave. A logical page may also be accessed in a write operation.","An erase block erase command may be sent out to erase an erase block over the storage I\/O bus  with a particular erase block address to erase a particular erase block. Typically, an erase block erase command may be sent over the parallel paths of the storage I\/O bus  to erase a logical erase block, each with a particular erase block address to erase a particular erase block. Simultaneously a particular bank (e.g. Bank  ) is selected over the storage control bus  to prevent erasure of similarly addressed erase blocks in all of the banks (Banks -N -). Alternatively, no particular bank (e.g. Bank  ) is selected over the storage control bus  to enable erasure of similarly addressed erase blocks in all of the banks (Banks -N -) simultaneously. Other commands may also be sent to a particular location using a combination of the storage I\/O bus  and the storage control bus . One of skill in the art will recognize other ways to select a particular storage location using the bi-directional storage I\/O bus  and the storage control bus .","In one embodiment, packets are written sequentially to the solid-state storage media . For example, packets are streamed to the storage write buffers of a bank of storage elements  and when the buffers are full, the packets are programmed to a designated logical page. Packets then refill the storage write buffers and, when full, the packets are written to the next logical page. The next logical page may be in the same bank or another bank (e.g. ). This process continues, logical page after logical page, typically until a logical erase block is filled. In another embodiment, the streaming may continue across logical erase block boundaries with the process continuing, logical erase block after logical erase block.","In a read, modify, write operation, data packets associated with requested data are located and read in a read operation. Data segments of the modified requested data that have been modified are not written to the location from which they are read. Instead, the modified data segments are again converted to data packets and then written sequentially to the next available location in the logical page currently being written. The index entries for the respective data packets are modified to point to the packets that contain the modified data segments. The entry or entries in the index for data packets associated with the same requested data that have not been modified will include pointers to original location of the unmodified data packets. Thus, if the original requested data is maintained, for example to maintain a previous version of the requested data, the original requested data will have pointers in the index to all data packets as originally written. The new requested data will have pointers in the index to some of the original data packets and pointers to the modified data packets in the logical page that is currently being written.","In a copy operation, the index includes an entry for the original requested data mapped to a number of packets stored in the solid-state storage media . When a copy is made, new copy of the requested data is created and a new entry is created in the index mapping the new copy of the requested data to the original packets. The new copy of the requested data is also written to the solid-state storage media  with its location mapped to the new entry in the index. The new copy of the requested data packets may be used to identify the packets within the original requested data that are referenced in case changes have been made in the original requested data that have not been propagated to the copy of the requested data and the index is lost or corrupted.","Beneficially, sequentially writing packets facilitates a more even use of the solid-state storage media  and allows the solid-storage device controller  to monitor storage hot spots and level usage of the various logical pages in the solid-state storage media . Sequentially writing packets also facilitates a powerful, efficient garbage collection system, which is described in detail below. One of skill in the art will recognize other benefits of sequential storage of data packets.","Solid-State Storage Device Controller","In various embodiments, the solid-state storage device controller  also includes a data bus , a local bus , a buffer controller , buffers -N -, a master controller , a direct memory access (\u201cDMA\u201d) controller , a memory controller , a dynamic memory array , a static random memory array , a management controller , a management bus , a bridge  to a system bus , and miscellaneous logic , which are described below. In other embodiments, the system bus  is coupled to one or more network interface cards (\u201cNICs\u201d) , some of which may include remote DMA (\u201cRDMA\u201d) controllers , one or more central processing unit (\u201cCPU\u201d) , one or more external memory controllers  and associated external memory arrays , one or more storage controllers , peer controllers , and application specific processors , which are described below. The components - connected to the system bus  may be located in the computer  or may be other devices.","Typically the solid-state storage controller(s)  communicate data to the solid-state storage media  over a storage I\/O bus . In a typical embodiment where the solid-state storage is arranged in banks  and each bank  includes multiple storage elements , , accessed in parallel, the storage I\/O bus  is an array of busses, one for each column of storage elements , ,  spanning the banks . As used herein, the term \u201cstorage I\/O bus\u201d may refer to one storage I\/O bus  or an array of data independent busses . In one embodiment, each storage I\/O bus  accessing a column of storage elements (e.g. , , ) may include a logical-to-physical mapping for storage divisions (e.g. erase blocks) accessed in a column of storage elements , , . This mapping (or bad block remapping) allows a logical address mapped to a physical address of a storage division to be remapped to a different storage division if the first storage division fails, partially fails, is inaccessible, or has some other problem.","Data may also be communicated to the solid-state storage controller(s)  from a requesting device  through the system bus , bridge , local bus , buffer(s) , and finally over a data bus . The data bus  typically is connected to one or more buffers -controlled with a buffer controller . The buffer controller  typically controls transfer of data from the local bus  to the buffers  and through the data bus  to the pipeline input buffer  and output buffer . The buffer controller  typically controls how data arriving from a requesting device can be temporarily stored in a buffer  and then transferred onto a data bus , or vice versa, to account for different clock domains, to prevent data collisions, etc. The buffer controller  typically works in conjunction with the master controller  to coordinate data flow. As data arrives, the data will arrive on the system bus , be transferred to the local bus  through a bridge .","Typically the data is transferred from the local bus  to one or more data buffers  as directed by the master controller  and the buffer controller . The data then flows out of the buffer(s)  to the data bus , through a solid-state controller , and on to the solid-state storage media  such as NAND flash or other storage media. In one embodiment, data and associated out-of-band metadata (\u201cmetadata\u201d) arriving with the data is communicated using one or more data channels comprising one or more solid-state storage controllers -- and associated solid-state storage media -- while at least one channel (solid-state storage controller , solid-state storage media ) is dedicated to in-band metadata, such as index information and other metadata generated internally to the solid-state storage device .","The local bus  is typically a bidirectional bus or set of busses that allows for communication of data and commands between devices internal to the solid-state storage device controller  and between devices internal to the solid-state storage device  and devices - connected to the system bus . The bridge  facilitates communication between the local bus  and system bus . One of skill in the art will recognize other embodiments such as ring structures or switched star configurations and functions of buses , , ,  and bridges .","The system bus  is typically a bus of a computer  or other device in which the solid-state storage device  is installed or connected. In one embodiment, the system bus  may be a PCI-e bus, a Serial Advanced Technology Attachment (\u201cserial ATA\u201d) bus, parallel ATA, or the like. In another embodiment, the system bus  is an external bus such as small computer system interface (\u201cSCSI\u201d), FireWire, Fiber Channel, USB, PCIe-AS, or the like. The solid-state storage device  may be packaged to fit internally to a device or as an externally connected device.","The solid-state storage device controller  includes a master controller  that controls higher-level functions within the solid-state storage device . The master controller , in various embodiments, controls data flow by interpreting object requests and other requests, directs creation of indexes to map object identifiers associated with data to physical locations of associated data, coordinating DMA requests, etc. Many of the functions described herein are controlled wholly or in part by the master controller .","In one embodiment, the master controller  uses embedded controller(s). In another embodiment, the master controller  uses local memory such as a dynamic memory array  (dynamic random access memory \u201cDRAM\u201d), a static memory array  (static random access memory \u201cSRAM\u201d), etc. In one embodiment, the local memory is controlled using the master controller . In another embodiment, the master controller  accesses the local memory via a memory controller . In another embodiment, the master controller  runs a Linux server and may support various common server interfaces, such as the World Wide Web, hyper-text markup language (\u201cHTML\u201d), etc. In another embodiment, the master controller  uses a nano-processor. The master controller  may be constructed using programmable or standard logic, or any combination of controller types listed above. One skilled in the art will recognize many embodiments for the master controller .","In one embodiment, where the storage device\/solid-state storage device controller  manages multiple data storage devices\/solid-state storage media -, the master controller  divides the work load among internal controllers, such as the solid-state storage controllers -. For example, the master controller  may divide an object to be written to the data storage devices (e.g. solid-state storage media -) so that a portion of the object is stored on each of the attached data storage devices. This feature is a performance enhancement allowing quicker storage and access to an object. In one embodiment, the master controller  is implemented using an FPGA. In another embodiment, the firmware within the master controller  may be updated through the management bus , the system bus  over a network connected to a NIC  or other device connected to the system bus .","In one embodiment, the master controller , which manages objects, emulates block storage such that a computer  or other device connected to the storage device\/solid-state storage device  views the storage device\/solid-state storage device  as a block storage device and sends data to specific physical addresses in the storage device\/solid-state storage device . The master controller  then divides up the blocks and stores the data blocks as it would objects. The master controller  then maps the blocks and physical address sent with the block to the actual locations determined by the master controller . The mapping is stored in the object index. Typically, for block emulation, a block device application program interface (\u201cAPI\u201d) is provided in a driver in the computer , client , or other device wishing to use the storage device\/solid-state storage device  as a block storage device.","In another embodiment, the master controller  coordinates with NIC controllers  and embedded RDMA controllers  to deliver just-in-time RDMA transfers of data and command sets. NIC controller  may be hidden behind a non-transparent port to enable the use of custom drivers. Also, a driver on a client  may have access to the computer network  through an I\/O memory driver using a standard stack API and operating in conjunction with NICs .","In one embodiment, the master controller  is also a redundant array of independent drive (\u201cRAID\u201d) controller. Where the data storage device\/solid-state storage device  is networked with one or more other data storage devices\/solid-state storage devices , the master controller  may be a RAID controller for single tier RAID, multi-tier RAID, progressive RAID, etc. The master controller  also allows some objects to be stored in a RAID array and other objects to be stored without RAID. In another embodiment, the master controller  may be a distributed RAID controller element. In another embodiment, the master controller  may comprise many RAID, distributed RAID, and other functions as described elsewhere. In one embodiment, the master controller  controls storage of data in a RAID-like structure where parity information is stored in one or more storage elements , ,  of a logical page where the parity information protects data stored in the other storage elements , ,  of the same logical page.","In one embodiment, the master controller  coordinates with single or redundant network managers (e.g. switches) to establish routing, to balance bandwidth utilization, failover, etc. In another embodiment, the master controller  coordinates with integrated application specific logic (via local bus ) and associated driver software. In another embodiment, the master controller  coordinates with attached application specific processors  or logic (via the external system bus ) and associated driver software. In another embodiment, the master controller  coordinates with remote application specific logic (via the computer network ) and associated driver software. In another embodiment, the master controller  coordinates with the local bus  or external bus attached hard disk drive (\u201cHDD\u201d) storage controller.","In one embodiment, the master controller  communicates with one or more storage controllers  where the storage device\/solid-state storage device  may appear as a storage device connected through a SCSI bus, Internet SCSI (\u201ciSCSI\u201d), fiber channel, etc. Meanwhile the storage device\/solid-state storage device  may autonomously manage objects and may appear as an object file system or distributed object file system. The master controller  may also be accessed by peer controllers  and\/or application specific processors .","In another embodiment, the master controller  coordinates with an autonomous integrated management controller to periodically validate FPGA code and\/or controller software, validate FPGA code while running (reset) and\/or validate controller software during power on (reset), support external reset requests, support reset requests due to watchdog timeouts, and support voltage, current, power, temperature, and other environmental measurements and setting of threshold interrupts. In another embodiment, the master controller  manages garbage collection to free erase blocks for reuse. In another embodiment, the master controller  manages wear leveling. In another embodiment, the master controller  allows the data storage device\/solid-state storage device  to be partitioned into multiple virtual devices and allows partition-based media encryption. In yet another embodiment, the master controller  supports a solid-state storage controller  with advanced, multi-bit ECC correction. One of skill in the art will recognize other features and functions of a master controller  in a storage controller , or more specifically in a solid-state storage device .","In one embodiment, the solid-state storage device controller  includes a memory controller  which controls a dynamic random memory array  and\/or a static random memory array . As stated above, the memory controller  may be independent or integrated with the master controller . The memory controller  typically controls volatile memory of some type, such as DRAM (dynamic random memory array ) and SRAM (static random memory array ). In other examples, the memory controller  also controls other memory types such as electrically erasable programmable read only memory (\u201cEEPROM\u201d), etc. In other embodiments, the memory controller  controls two or more memory types and the memory controller  may include more than one controller. Typically, the memory controller  controls as much SRAM  as is feasible and by DRAM  to supplement the SRAM .","In one embodiment, the object index is stored in memory ,  and then periodically off-loaded to a channel of the solid-state storage media or other non-volatile memory. One of skill in the art will recognize other uses and configurations of the memory controller , dynamic memory array , and static memory array .","In one embodiment, the solid-state storage device controller  includes a DMA controller  that controls DMA operations between the storage device\/solid-state storage device  and one or more external memory controllers  and associated external memory arrays  and CPUs . Note that the external memory controllers  and external memory arrays  are called external because they are external to the storage device\/solid-state storage device . In addition the DMA controller  may also control RDMA operations with requesting devices through a NIC  and associated RDMA controller .","In one embodiment, the solid-state storage device controller  includes a management controller  connected to a management bus . Typically the management controller  manages environmental metrics and status of the storage device\/solid-state storage device . The management controller  may monitor device temperature, fan speed, power supply settings, etc. over the management bus .","The management controller  may support the reading and programming of erasable programmable read only memory (\u201cEEPROM\u201d) for storage of FPGA code and controller software. Typically the management bus  is connected to the various components within the storage device\/solid-state storage device . The management controller  may communicate alerts, interrupts, etc. over the local bus  or may include a separate connection to a system bus  or other bus. In one embodiment the management bus  is an Inter-Integrated Circuit (\u201cI2C\u201d) bus. One of skill in the art will recognize other related functions and uses of a management controller  connected to components of the storage device\/solid-state storage device  by a management bus .","In one embodiment, the solid-state storage device controller  includes miscellaneous logic  that may be customized for a specific application. Typically where the solid-state device controller  or master controller  is\/are configured using a FPGA or other configurable controller, custom logic may be included based on a particular application, customer requirement, storage requirement, etc.","Data Pipeline",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 3","FIG. 2"],"b":["300","104","106","108","102","300","204","206","208","202","106","302","304","106","306","308","310","312","314","316","108","318","320","108","328","322","324","326","330","108","332","316","334","336","338","104","340","342","344","346","348","350","104","106","108","110","308","328"]},"Write Data Pipeline","The write data pipeline  includes a packetizer  that receives a data or metadata segment to be written to the solid-state storage, either directly or indirectly through another write data pipeline  stage, and creates one or more packets sized for the solid-state storage media . The data or metadata segment is typically part of a data structure such as an object, but may also include an entire data structure. In another embodiment, the data segment is part of a block of data, but may also include an entire block of data. Typically, a set of data such as a data structure is received from a computer such as the host device , or other computer or device and is transmitted to the solid-state storage device  in data segments streamed to the solid-state storage device  and\/or the host device . A data segment may also be known by another name, such as data parcel, but as referenced herein includes all or a portion of a data structure or data block.","Each data structure is stored as one or more packets. Each data structure may have one or more container packets. Each packet contains a header. The header may include a header type field. Type fields may include data, attribute, metadata, data segment delimiters (multi-packet), data structures, data linkages, and the like. The header may also include information regarding the size of the packet, such as the number of bytes of data included in the packet. The length of the packet may be established by the packet type. The header may include information that establishes the relationship of the packet to a data structure. An example might be the use of an offset in a data packet header to identify the location of the data segment within the data structure. One of skill in the art will recognize other information that may be included in a header added to data by a packetizer  and other information that may be added to a data packet.","Each packet includes a header and possibly data from the data or metadata segment. The header of each packet includes pertinent information to relate the packet to the data structure to which the packet belongs. For example, the header may include an object identifier or other data structure identifier and offset that indicate the data segment, object, data structure or data block from which the data packet was formed. The header may also include a logical address used by the storage bus controller  to store the packet. The header may also include information regarding the size of the packet, such as the number of bytes included in the packet. The header may also include a sequence number that identifies where the data segment belongs with respect to other packets within the data structure when reconstructing the data segment or data structure. The header may include a header type field. Type fields may include data, data structure attributes, metadata, data segment delimiters (multi-packet), data structure types, data structure linkages, and the like. One of skill in the art will recognize other information that may be included in a header added to data or metadata by a packetizer  and other information that may be added to a packet.","The write data pipeline  includes an ECC generator  that that generates one or more error-correcting codes (\u201cECC\u201d) for the one or more packets received from the packetizer . The ECC generator  typically uses an error correcting algorithm to generate ECC check bits which are stored with the one or more data packets. The ECC codes generated by the ECC generator  together with the one or more data packets associated with the ECC codes comprise an ECC chunk. The ECC data stored with the one or more data packets is used to detect and to correct errors introduced into the data through transmission and storage. In one embodiment, packets are streamed into the ECC generator  as un-encoded blocks of length N. A syndrome of length S is calculated, appended and output as an encoded block of length N+S. The value of N and S are dependent upon the characteristics of the algorithm which is selected to achieve specific performance, efficiency, and robustness metrics. In one embodiment, there is no fixed relationship between the ECC blocks and the packets; the packet may comprise more than one ECC block; the ECC block may comprise more than one packet; and a first packet may end anywhere within the ECC block and a second packet may begin after the end of the first packet within the same ECC block. In one embodiment, ECC algorithms are not dynamically modified. In one embodiment, the ECC data stored with the data packets is robust enough to correct errors in more than two bits.","Beneficially, using a robust ECC algorithm allowing more than single bit correction or even double bit correction allows the life of the solid-state storage media  to be extended. For example, if flash memory is used as the storage medium in the solid-state storage media , the flash memory may be written approximately 100,000 times without error per erase cycle. This usage limit may be extended using a robust ECC algorithm. Having the ECC generator  and corresponding ECC correction module  onboard the solid-state storage device , the solid-state storage device  can internally correct errors and has a longer useful life than if a less robust ECC algorithm is used, such as single bit correction. However, in other embodiments the ECC generator  may use a less robust algorithm and may correct single-bit or double-bit errors. In another embodiment, the solid-state storage device  may comprise less reliable storage such as multi-level cell (\u201cMLC\u201d) flash in order to increase capacity, which storage may not be sufficiently reliable without more robust ECC algorithms.","In one embodiment, the write pipeline  includes an input buffer  that receives a data segment to be written to the solid-state storage media  and stores the incoming data segments until the next stage of the write data pipeline , such as the packetizer  (or other stage for a more complex write data pipeline ) is ready to process the next data segment. The input buffer  typically allows for discrepancies between the rate data segments are received and processed by the write data pipeline  using an appropriately sized data buffer. The input buffer  also allows the data bus  to transfer data to the write data pipeline  at rates greater than can be sustained by the write data pipeline  in order to improve efficiency of operation of the data bus . Typically when the write data pipeline  does not include an input buffer , a buffering function is performed elsewhere, such as in the solid-state storage device , but outside the write data pipeline , in the host device , such as within a network interface card (\u201cNIC\u201d), or at another device, for example when using remote direct memory access (\u201cRDMA\u201d).","In another embodiment, the write data pipeline  also includes a write synchronization buffer  that buffers packets received from the ECC generator  prior to writing the packets to the solid-state storage media . The write synch buffer  is located at a boundary between a local clock domain and a solid-state storage clock domain and provides buffering to account for the clock domain differences. In other embodiments, synchronous solid-state storage media  may be used and synchronization buffers   may be eliminated.","In one embodiment, the write data pipeline  also includes a media encryption module  that receives the one or more packets from the packetizer , either directly or indirectly, and encrypts the one or more packets using an encryption key unique to the solid-state storage device  prior to sending the packets to the ECC generator . Typically, the entire packet is encrypted, including the headers. In another embodiment, headers are not encrypted. In this document, encryption key is understood to mean a secret encryption key that is managed externally from a solid-state storage controller .","The media encryption module  and corresponding media decryption module  provide a level of security for data stored in the solid-state storage media . For example, where data is encrypted with the media encryption module , if the solid-state storage media  is connected to a different solid-state storage controller , solid-state storage device , or server, the contents of the solid-state storage media  typically could not be read without use of the same encryption key used during the write of the data to the solid-state storage media  without significant effort.","In a typical embodiment, the solid-state storage device  does not store the encryption key in non-volatile storage and allows no external access to the encryption key. The encryption key is provided to the solid-state storage controller  during initialization. The solid-state storage device  may use and store a non-secret cryptographic nonce that is used in conjunction with an encryption key. A different nonce may be stored with every packet. Data segments may be split between multiple packets with unique nonces for the purpose of improving protection by the encryption algorithm.","The encryption key may be received from a host device , a server, key manager, or other device that manages the encryption key to be used by the solid-state storage controller . In another embodiment, the solid-state storage media  may have two or more partitions and the solid-state storage controller  behaves as though it was two or more solid-state storage controllers , each operating on a single partition within the solid-state storage media . In this embodiment, a unique media encryption key may be used with each partition.","In another embodiment, the write data pipeline  also includes an encryption module  that encrypts a data or metadata segment received from the input buffer , either directly or indirectly, prior sending the data segment to the packetizer , the data segment encrypted using an encryption key received in conjunction with the data segment. The encryption keys used by the encryption module  to encrypt data may not be common to all data stored within the solid-state storage device  but may vary on an per data structure basis and received in conjunction with receiving data segments as described below. For example, an encryption key for a data segment to be encrypted by the encryption module  may be received with the data segment or may be received as part of a command to write a data structure to which the data segment belongs. The solid-state storage device  may use and store a non-secret cryptographic nonce in each data structure packet that is used in conjunction with the encryption key. A different nonce may be stored with every packet. Data segments may be split between multiple packets with unique nonces for the purpose of improving protection by the encryption algorithm.","The encryption key may be received from a host device , a computer, key manager, or other device that holds the encryption key to be used to encrypt the data segment. In one embodiment, encryption keys are transferred to the solid-state storage controller  from one of a solid-state storage device , a computer, a host device , or other external agent which has the ability to execute industry standard methods to securely transfer and protect private and public keys.","In one embodiment, the encryption module  encrypts a first packet with a first encryption key received in conjunction with the packet and encrypts a second packet with a second encryption key received in conjunction with the second packet. In another embodiment, the encryption module  encrypts a first packet with a first encryption key received in conjunction with the packet and passes a second data packet on to the next stage without encryption. Beneficially, the encryption module  included in the write data pipeline  of the solid-state storage device  allows data structure-by-data structure or segment-by-segment data encryption without a single file system or other external system to keep track of the different encryption keys used to store corresponding data structures or data segments. Each requesting device  or related key manager independently manages encryption keys used to encrypt only the data structures or data segments sent by the requesting device .","In one embodiment, the encryption module  may encrypt the one or more packets using an encryption key unique to the solid-state storage device . The encryption module  may perform this media encryption independently, or in addition to the encryption described above. Typically, the entire packet is encrypted, including the headers. In another embodiment, headers are not encrypted. The media encryption by the encryption module  provides a level of security for data stored in the solid-state storage media . For example, where data is encrypted with media encryption unique to the specific solid-state storage device  if the solid-state storage media  is connected to a different solid-state storage controller , solid-state storage device , or host device , the contents of the solid-state storage media  typically could not be read without use of the same encryption key used during the write of the data to the solid-state storage media  without significant effort.","In another embodiment, the write data pipeline  includes a compression module  that compresses the data for metadata segment prior to sending the data segment to the packetizer . The compression module  typically compresses a data or metadata segment using a compression routine known to those of skill in the art to reduce the storage size of the segment. For example, if a data segment includes a string of 512 zeros, the compression module  may replace the 512 zeros with code or token indicating the 512 zeros where the code is much more compact than the space taken by the 512 zeros.","In one embodiment, the compression module  compresses a first segment with a first compression routine and passes along a second segment without compression. In another embodiment, the compression module  compresses a first segment with a first compression routine and compresses the second segment with a second compression routine. Having this flexibility within the solid-state storage device  is beneficial so that the host device  or other devices writing data to the solid-state storage device  may each specify a compression routine or so that one can specify a compression routine while another specifies no compression. Selection of compression routines may also be selected according to default settings on a per data structure type or data structure class basis. For example, a first data structure of a specific data structure may be able to override default compression routine settings and a second data structure of the same data structure class and data structure type may use the default compression routine and a third data structure of the same data structure class and data structure type may use no compression.","In one embodiment, the write data pipeline  includes a garbage collector bypass  that receives data segments from the read data pipeline  as part of a data bypass in a garbage collection system. A garbage collection system typically marks packets that are no longer valid, typically because the packet is marked for deletion or has been modified and the modified data is stored in a different location. At some point, the garbage collection system determines that a particular section of storage may be recovered. This determination may be due to a lack of available storage capacity, the percentage of data marked as invalid reaching a threshold, a consolidation of valid data, an error detection rate for that section of storage reaching a threshold, or improving performance based on data distribution, etc. Numerous factors may be considered by a garbage collection algorithm to determine when a section of storage is to be recovered.","Once a section of storage has been marked for recovery, valid packets in the section typically must be relocated. The garbage collector bypass  allows packets to be read into the read data pipeline  and then transferred directly to the write data pipeline  without being routed out of the solid-state storage controller . In one embodiment, the garbage collector bypass  is part of an autonomous garbage collector system that operates within the solid-state storage device . This allows the solid-state storage device  to manage data so that data is systematically spread throughout the solid-state storage media  to improve performance, data reliability and to avoid overuse and underuse of any one location or area of the solid-state storage media  and to lengthen the useful life of the solid-state storage media .","The garbage collector bypass  coordinates insertion of segments into the write data pipeline with other segments being written by a host device  or other devices. In the depicted embodiment, the garbage collector bypass  is before the packetizer  in the write data pipeline  and after the depacketizer  in the read data pipeline , but may also be located elsewhere in the read and write data pipelines , . The garbage collector bypass  may be used during a flush of the write pipeline  to fill the remainder of the virtual page in order to improve the efficiency of storage within the solid-state storage media  and thereby reduce the frequency of garbage collection.","In one embodiment, the write data pipeline  includes a write buffer  that buffers data for efficient write operations. Typically, the write buffer  includes enough capacity for packets to fill at least one virtual page in the solid-state storage media . This allows a write operation to send an entire page of data to the solid-state storage media  without interruption. By sizing the write buffer  of the write data pipeline  and buffers within the read data pipeline  to be the same capacity or larger than a storage write buffer within the solid-state storage media , writing and reading data is more efficient since a single write command may be crafted to send a full virtual page of data to the solid-state storage media  instead of multiple commands.","While the write buffer  is being filled, the solid-state storage media  may be used for other read operations. This is advantageous because other solid-state devices with a smaller write buffer or no write buffer may tie up the solid-state storage when data is written to a storage write buffer and data flowing into the storage write buffer stalls. Read operations will be blocked until the entire storage write buffer is filled and programmed. Another approach for systems without a write buffer or a small write buffer is to flush the storage write buffer that is not full in order to enable reads. Again this is inefficient because multiple write\/program cycles are required to fill a page.","For depicted embodiment with a write buffer  sized larger than a virtual page, a single write command, which includes numerous subcommands, can then be followed by a single program command to transfer the page of data from the storage write buffer in each solid-state storage element , ,  to the designated page within each solid-state storage element , , . This technique has the benefits of eliminating partial page programming, which is known to reduce data reliability and durability and freeing up the destination bank for reads and other commands while the buffer fills.","In one embodiment, the write buffer  is a ping-pong buffer where one side of the buffer is filled and then designated for transfer at an appropriate time while the other side of the ping-pong buffer is being filled. In another embodiment, the write buffer  includes a first-in first-out (\u201cFIFO\u201d) register with a capacity of more than a virtual page of data segments. One of skill in the art will recognize other write buffer  configurations that allow a virtual page of data to be stored prior to writing the data to the solid-state storage media .","In another embodiment, the write buffer  is sized smaller than a virtual page so that less than a page of information could be written to a storage write buffer in the solid-state storage media . In the embodiment, to prevent a stall in the write data pipeline  from holding up read operations, data is queued using the garbage collection system that needs to be moved from one location to another as part of the garbage collection process. In case of a data stall in the write data pipeline , the data can be fed through the garbage collector bypass  to the write buffer  and then on to the storage write buffer in the solid-state storage media  to fill the pages of a virtual page prior to programming the data. In this way a data stall in the write data pipeline  would not stall reading from the solid-state storage device .","In another embodiment, the write data pipeline  includes a write program module  with one or more user-definable functions within the write data pipeline . The write program module  allows a user to customize the write data pipeline . A user may customize the write data pipeline  based on a particular data requirement or application. Where the solid-state storage controller  is an FPGA, the user may program the write data pipeline  with custom commands and functions relatively easily. A user may also use the write program module  to include custom functions with an ASIC, however, customizing an ASIC may be more difficult than with an FPGA. The write program module  may include buffers and bypass mechanisms to allow a first data segment to execute in the write program module  while a second data segment may continue through the write data pipeline . In another embodiment, the write program module  may include a processor core that can be programmed through software.","Note that the write program module  is shown between the input buffer  and the compression module , however, the write program module  could be anywhere in the write data pipeline  and may be distributed among the various stages -. In addition, there may be multiple write program modules  distributed among the various states - that are programmed and operate independently. In addition, the order of the stages - may be altered. One of skill in the art will recognize workable alterations to the order of the stages - based on particular user requirements.","Read Data Pipeline","The read data pipeline  includes an ECC correction module  that determines if a data error exists in ECC blocks a requested packet received from the solid-state storage media  by using ECC stored with each ECC block of the requested packet. The ECC correction module  then corrects any errors in the requested packet if any error exists and the errors are correctable using the ECC. For example, if the ECC can detect an error in six bits but can only correct three bit errors, the ECC correction module  corrects ECC blocks of the requested packet with up to three bits in error. The ECC correction module  corrects the bits in error by changing the bits in error to the correct one or zero state so that the requested data packet is identical to when it was written to the solid-state storage media  and the ECC was generated for the packet.","If the ECC correction module  determines that the requested packets contains more bits in error than the ECC can correct, the ECC correction module  cannot correct the errors in the corrupted ECC blocks of the requested packet and sends an interrupt. In one embodiment, the ECC correction module  sends an interrupt with a message indicating that the requested packet is in error. The message may include information that the ECC correction module  cannot correct the errors or the inability of the ECC correction module  to correct the errors may be implied. In another embodiment, the ECC correction module  sends the corrupted ECC blocks of the requested packet with the interrupt and\/or the message.","In one embodiment, a corrupted ECC block or portion of a corrupted ECC block of the requested packet that cannot be corrected by the ECC correction module  is read by the master controller , corrected, and returned to the ECC correction module  for further processing by the read data pipeline . In one embodiment, a corrupted ECC block or portion of a corrupted ECC block of the requested packet is sent to the device requesting the data. The requesting device  may correct the ECC block or replace the data using another copy, such as a backup or mirror copy, and then may use the replacement data of the requested data packet or return it to the read data pipeline . The requesting device  may use header information in the requested packet in error to identify data required to replace the corrupted requested packet or to replace the data structure to which the packet belongs. In another embodiment, the solid-state storage controller  stores data using some type of RAID and is able to recover the corrupted data. In another embodiment, the ECC correction module  sends an interrupt and\/or message and the receiving device fails the read operation associated with the requested data packet. One of skill in the art will recognize other options and actions to be taken as a result of the ECC correction module  determining that one or more ECC blocks of the requested packet are corrupted and that the ECC correction module  cannot correct the errors.","The read data pipeline  includes a depacketizer  that receives ECC blocks of the requested packet from the ECC correction module , directly or indirectly, and checks and removes one or more packet headers. The depacketizer  may validate the packet headers by checking packet identifiers, data length, data location, etc. within the headers. In one embodiment, the header includes a hash code that can be used to validate that the packet delivered to the read data pipeline  is the requested packet. The depacketizer  also removes the headers from the requested packet added by the packetizer . The depacketizer  may directed to not operate on certain packets but pass these forward without modification. An example might be a container label that is requested during the course of a rebuild process where the header information is required for index reconstruction. Further examples include the transfer of packets of various types destined for use within the solid-state storage device . In another embodiment, the depacketizer  operation may be packet type dependent.","The read data pipeline  includes an alignment module  that receives data from the depacketizer  and removes unwanted data. In one embodiment, a read command sent to the solid-state storage media  retrieves a packet of data. A device requesting the data may not require all data within the retrieved packet and the alignment module  removes the unwanted data. If all data within a retrieved page is requested data, the alignment module  does not remove any data.","The alignment module  re-formats the data as data segments of a data structure in a form compatible with a device requesting the data segment prior to forwarding the data segment to the next stage. Typically, as data is processed by the read data pipeline , the size of data segments or packets changes at various stages. The alignment module  uses received data to format the data into data segments suitable to be sent to the requesting device  and joined to form a response. For example, data from a portion of a first data packet may be combined with data from a portion of a second data packet. If a data segment is larger than a data requested by the requesting device , the alignment module  may discard the unwanted data.","In one embodiment, the read data pipeline  includes a read synchronization buffer  that buffers one or more requested packets read from the solid-state storage media  prior to processing by the read data pipeline . The read synchronization buffer  is at the boundary between the solid-state storage clock domain and the local bus clock domain and provides buffering to account for the clock domain differences.","In another embodiment, the read data pipeline  includes an output buffer  that receives requested packets from the alignment module  and stores the packets prior to transmission to the requesting device . The output buffer  accounts for differences between when data segments are received from stages of the read data pipeline  and when the data segments are transmitted to other parts of the solid-state storage controller  or to the requesting device . The output buffer  also allows the data bus  to receive data from the read data pipeline  at rates greater than can be sustained by the read data pipeline  in order to improve efficiency of operation of the data bus .","In one embodiment, the read data pipeline  includes a media decryption module  that receives one or more encrypted requested packets from the ECC correction module  and decrypts the one or more requested packets using the encryption key unique to the solid-state storage device  prior to sending the one or more requested packets to the depacketizer . Typically the encryption key used to decrypt data by the media decryption module  is identical to the encryption key used by the media encryption module . In another embodiment, the solid-state storage media  may have two or more partitions and the solid-state storage controller  behaves as though it was two or more solid-state storage controllers  each operating on a single partition within the solid-state storage media . In this embodiment, a unique media encryption key may be used with each partition.","In another embodiment, the read data pipeline  includes a decryption module  that decrypts a data segment formatted by the depacketizer  prior to sending the data segment to the output buffer . The data segment may be decrypted using an encryption key received in conjunction with the read request that initiates retrieval of the requested packet received by the read synchronization buffer . The decryption module  may decrypt a first packet with an encryption key received in conjunction with the read request for the first packet and then may decrypt a second packet with a different encryption key or may pass the second packet on to the next stage of the read data pipeline  without decryption. When the packet was stored with a non-secret cryptographic nonce, the nonce is used in conjunction with an encryption key to decrypt the data packet. The encryption key may be received from a host device , a computer, key manager, or other device that manages the encryption key to be used by the solid-state storage controller .","In another embodiment, the read data pipeline  includes a decompression module  that decompresses a data segment formatted by the depacketizer . In one embodiment, the decompression module  uses compression information stored in one or both of the packet header and the container label to select a complementary routine to that used to compress the data by the compression module . In another embodiment, the decompression routine used by the decompression module  is dictated by the device requesting the data segment being decompressed. In another embodiment, the decompression module  selects a decompression routine according to default settings on a per data structure type or data structure class basis. A first packet of a first object may be able to override a default decompression routine and a second packet of a second data structure of the same data structure class and data structure type may use the default decompression routine and a third packet of a third data structure of the same data structure class and data structure type may use no decompression.","In another embodiment, the read data pipeline  includes a read program module  that includes one or more user-definable functions within the read data pipeline . The read program module  has similar characteristics to the write program module  and allows a user to provide custom functions to the read data pipeline . The read program module  may be located as shown in , may be located in another position within the read data pipeline , or may include multiple parts in multiple locations within the read data pipeline . Additionally, there may be multiple read program modules  within multiple locations within the read data pipeline  that operate independently. One of skill in the art will recognize other forms of a read program module  within a read data pipeline . As with the write data pipeline , the stages of the read data pipeline  may be rearranged and one of skill in the art will recognize other orders of stages within the read data pipeline .","The solid-state storage controller  includes control and status registers  and corresponding control queues . The control and status registers  and control queues  facilitate control and sequencing commands and subcommands associated with data processed in the write and read data pipelines , . For example, a data segment in the packetizer  may have one or more corresponding control commands or instructions in a control queue  associated with the ECC generator . As the data segment is packetized, some of the instructions or commands may be executed within the packetizer . Other commands or instructions may be passed to the next control queue  through the control and status registers  as the newly formed data packet created from the data segment is passed to the next stage.","Commands or instructions may be simultaneously loaded into the control queues  for a packet being forwarded to the write data pipeline  with each pipeline stage pulling the appropriate command or instruction as the respective packet is executed by that stage. Similarly, commands or instructions may be simultaneously loaded into the control queues  for a packet being requested from the read data pipeline  with each pipeline stage pulling the appropriate command or instruction as the respective packet is executed by that stage. One of skill in the art will recognize other features and functions of control and status registers  and control queues .","The solid-state storage controller  and or the solid-state storage device  may also include a bank interleave controller , a synchronization buffer , a storage bus controller , and a multiplexer (\u201cMUX\u201d) , which are described in relation to .","Bank Interleave",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 4","b":["400","344","104","344","340","210","212","350","348","346","344","402","404","406","408","410","412","414","416","214","110","418","420","422","348","424","430","426","428"],"i":["a","n","a","n","a","n","a","n ","a","n"]},"The bank interleave controller  directs one or more commands to two or more queues in the bank interleave controller  and coordinates among the banks  of the solid-state storage media  execution of the commands stored in the queues, such that a command of a first type executes on one bank while a command of a second type executes on a second bank . The one or more commands are separated by command type into the queues. Each bank  of the solid-state storage media  has a corresponding set of queues within the bank interleave controller  and each set of queues includes a queue for each command type.","The bank interleave controller  coordinates among the banks  of the solid-state storage media  execution of the commands stored in the queues. For example, a command of a first type executes on one bank while a command of a second type executes on a second bank . Typically the command types and queue types include read and write commands and queues , , but may also include other commands and queues that are storage media specific. For example, in the embodiment depicted in , erase and management queues ,  are included and would be appropriate for flash memory, NRAM, MRAM, DRAM, PRAM, SONOS, RRAM, PMC, CBRAM, racetrack memory, memristor memory, nanocrystal wire-based memory, silicon-oxide based sub-10 nanometer process memory, graphene memory, etc.","For other types of solid-state storage media , other types of commands and corresponding queues may be included without straying from the scope of the invention. The flexible nature of an FPGA solid-state storage controller  allows flexibility in storage media. If flash memory were changed to another solid-state storage type, the bank interleave controller , storage bus controller , and MUX  could be altered to accommodate the media type without significantly affecting the data pipelines ,  and other solid-state storage controller  functions.","In the embodiment depicted in , the bank interleave controller  includes, for each bank , a read queue  for reading data from the solid-state storage media , a write queue  for write commands to the solid-state storage media , an erase queue  for erasing an erase block in the solid-state storage, an a management queue  for management commands. The bank interleave controller  also includes corresponding read, write, erase, and management agents , , , . In another embodiment, the control and status registers  and control queues  or similar components queue commands for data sent to the banks  of the solid-state storage media  without a bank interleave controller .","The agents , , , , in one embodiment, direct commands of the appropriate type destined for a particular bank to the correct queue for the bank . For example, the read agent  may receive a read command for bank- and directs the read command to the bank- read queue . The write agent  may receive a write command to write data to a location in bank- of the solid-state storage media  and will then send the write command to the bank- write queue . Similarly, the erase agent  may receive an erase command to erase an erase block in bank- and will then pass the erase command to the bank- erase queue . The management agent  typically receives management commands, status requests, and the like, such as a reset command or a request to read a configuration register of a bank , such as bank- . The management agent  sends the management command to the bank- management queue ","The agents , , ,  typically also monitor status of the queues , , ,  and send status, interrupt, or other messages when the queues , , ,  are full, nearly full, non-functional, etc. In one embodiment, the agents , , ,  receive commands and generate corresponding sub-commands. In one embodiment, the agents , , ,  receive commands through the control & status registers  and generate corresponding sub-commands which are forwarded to the queues , , , . One of skill in the art will recognize other functions of the agents , , , .","The queues , , ,  typically receive commands and store the commands until required to be sent to the solid-state storage banks . In a typical embodiment, the queues , , ,  are first-in, first-out (\u201cFIFO\u201d) registers or a similar component that operates as a FIFO. In another embodiment, the queues , , ,  store commands in an order that matches data, order of importance, or other criteria.","The bank controllers  typically receive commands from the queues , , ,  and generate appropriate subcommands. For example, the bank- write queue may receive a command to write a page of data packets to bank- . The bank- controller may receive the write command at an appropriate time and may generate one or more write subcommands for each data packet stored in the write buffer  to be written to the page in bank- . For example, bank- controller may generate commands to validate the status of bank  and the solid-state storage array , select the appropriate location for writing one or more data packets, clear the input buffers within the solid-state storage memory array , transfer the one or more data packets to the input buffers, program the input buffers into the selected location, verify that the data was correctly programmed, and if program failures occur do one or more of interrupting the master controller , retrying the write to the same physical location, and retrying the write to a different physical location. Additionally, in conjunction with example write command, the storage bus controller  will cause the one or more commands to multiplied to each of the each of the storage I\/O buses -with the logical address of the command mapped to a first physical addresses for storage I\/O bus , and mapped to a second physical address for storage I\/O bus , and so forth as further described below.","Typically, bus arbiter  selects from among the bank controllers  and pulls subcommands from output queues within the bank controllers  and forwards these to the Storage Bus Controller  in a sequence that optimizes the performance of the banks . In another embodiment, the bus arbiter  may respond to a high level interrupt and modify the normal selection criteria. In another embodiment, the master controller  can control the bus arbiter  through the control and status registers . One of skill in the art will recognize other means by which the bus arbiter  may control and interleave the sequence of commands from the bank controllers  to the solid-state storage media .","The bus arbiter  typically coordinates selection of appropriate commands, and corresponding data when required for the command type, from the bank controllers  and sends the commands and data to the storage bus controller . The bus arbiter  typically also sends commands to the storage control bus  to select the appropriate bank . For the case of flash memory or other solid-state storage media  with an asynchronous, bi-directional serial storage I\/O bus , only one command (control information) or set of data can be transmitted at a time. For example, when write commands or data are being transmitted to the solid-state storage media  on the storage I\/O bus , read commands, data being read, erase commands, management commands, or other status commands cannot be transmitted on the storage I\/O bus . For example, when data is being read from the storage I\/O bus , data cannot be written to the solid-state storage media .","For example, during a write operation on bank- the bus arbiter  selects the bank- controller which may have a write command or a series of write sub-commands on the top of its queue which cause the storage bus controller  to execute the following sequence. The bus arbiter  forwards the write command to the storage bus controller , which sets up a write command by selecting bank- through the storage control bus , sending a command to clear the input buffers of the solid-state storage elements  associated with the bank- , and sending a command to validate the status of the solid-state storage elements , ,  associated with the bank- ","The storage bus controller  then transmits a write subcommand on the storage I\/O bus , which contains the physical addresses including the address of the logical erase block for each individual physical erase solid-stage storage element -as mapped from the logical erase block address. The storage bus controller  then muxes the write buffer  through the write sync buffer  to the storage I\/O bus  through the MUX  and streams write data to the appropriate page. When the page is full, then storage bus controller  causes the solid-state storage elements -associated with the bank- to program the input buffer to the memory cells within the solid-state storage elements -. Finally, the storage bus controller  validates the status to ensure that page was correctly programmed.","A read operation is similar to the write example above. During a read operation, typically the bus arbiter , or other component of the bank interleave controller , receives data and corresponding status information and sends the data to the read data pipeline  while sending the status information on to the control and status registers . Typically, a read data command forwarded from bus arbiter  to the storage bus controller  will cause the MUX  to gate the read data on storage I\/O bus  to the read data pipeline  and send status information to the appropriate control and status registers  through the status MUX .","The bus arbiter  coordinates the various command types and data access modes so that only an appropriate command type or corresponding data is on the bus at any given time. If the bus arbiter  has selected a write command, and write subcommands and corresponding data are being written to the solid-state storage media , the bus arbiter  will not allow other command types on the storage I\/O bus . Beneficially, the bus arbiter  uses timing information, such as predicted command execution times, along with status information received concerning bank  status to coordinate execution of the various commands on the bus with the goal of minimizing or eliminating idle time of the busses.","The master controller  through the bus arbiter  typically uses expected completion times of the commands stored in the queues , , , , along with status information, so that when the subcommands associated with a command are executing on one bank , other subcommands of other commands are executing on other banks -. When one command is fully executed on a bank , the bus arbiter  directs another command to the bank . The bus arbiter  may also coordinate commands stored in the queues , , ,  with other commands that are not stored in the queues , , , .","For example, an erase command may be sent out to erase a group of erase blocks within the solid-state storage media . An erase command may take 10 to 1000 times more time to execute than a write or a read command or 10 to 100 times more time to execute than a program command. For N banks , the bank interleave controller  may split the erase command into N commands, each to erase a virtual erase block of a bank . While bank- is executing an erase command, the bus arbiter  may select other commands for execution on the other banks -. The bus arbiter  may also work with other components, such as the storage bus controller , the master controller , etc., to coordinate command execution among the buses. Coordinating execution of commands using the bus arbiter , bank controllers , queues , , , , and agents , , ,  of the bank interleave controller  can dramatically increase performance over other solid-state storage systems without a bank interleave function.","In one embodiment, the solid-state controller  includes one bank interleave controller  that serves all of the storage elements , ,  of the solid-state storage media . In another embodiment, the solid-state controller  includes a bank interleave controller  for each column of storage elements -, -, -. For example, one bank interleave controller  serves one column of storage elements SSS .-SSS M. , , . . . , a second bank interleave controller  serves a second column of storage elements SSS .-SSS M. , , . . . etc.","Storage-Specific Components","The solid-state storage controller  includes a synchronization buffer  that buffers commands and status messages sent and received from the solid-state storage media . The synchronization buffer  is located at the boundary between the solid-state storage clock domain and the local bus clock domain and provides buffering to account for the clock domain differences. The synchronization buffer , write synchronization buffer , and read synchronization buffer  may be independent or may act together to buffer data, commands, status messages, etc. In one embodiment, the synchronization buffer  is located where there are the fewest number of signals crossing the clock domains. One skilled in the art will recognize that synchronization between clock domains may be arbitrarily moved to other locations within the solid-state storage device  in order to optimize some aspect of design implementation.","The solid-state storage controller  includes a storage bus controller  that interprets and translates commands for data sent to and read from the solid-state storage media  and status messages received from the solid-state storage media  based on the type of solid-state storage media . For example, the storage bus controller  may have different timing requirements for different types of storage, storage with different performance characteristics, storage from different manufacturers, etc. The storage bus controller  also sends control commands to the storage control bus .","In one embodiment, the solid-state storage controller  includes a MUX  that comprises an array of multiplexers -where each multiplexer is dedicated to a row in the solid-state storage array . For example, multiplexer is associated with solid-state storage elements , , . MUX  routes the data from the write data pipeline  and commands from the storage bus controller  to the solid-state storage media  via the storage I\/O bus  and routes data and status messages from the solid-state storage media  via the storage I\/O bus  to the read data pipeline  and the control and status registers  through the storage bus controller , synchronization buffer , and bank interleave controller .","In one embodiment, the solid-state storage controller  includes a MUX  for each column of solid-state storage elements (e.g. SSS . , SSS . , SSS N. ). A MUX  combines data from the write data pipeline  and commands sent to the solid-state storage  via the storage I\/O bus  and separates data to be processed by the read data pipeline  from commands. Packets stored in the write buffer  are directed on busses out of the write buffer  through a write synchronization buffer  for each column of solid-state storage elements (SSS .to SSS N.x , , ) to the MUX  for each column of solid-state storage elements (SSS .to SSS N.x , , ). The commands and read data are received by the MUXes  from the storage I\/O bus . The MUXes  also direct status messages to the storage bus controller .","The storage bus controller  includes a mapping module . The mapping module  maps a logical address of an erase block to one or more physical addresses of an erase block. For example, a solid-state storage  with an array of twenty storage elements (e.g. SSS . to SSS .M ) per bank may have a logical address for a particular erase block mapped to twenty physical addresses of the erase block, one physical address per storage element. Because the storage elements are accessed in parallel, erase blocks at the same position in each storage element in a column of storage elements , , will share a physical address. To select one erase block (e.g. in storage element SSS . ) instead of all erase blocks in the column (e.g. in storage elements SSS ., ., . . . N. , , ), one bank (in this case Bank  ) is selected.","This logical-to-physical mapping for erase blocks is beneficial because if one erase block becomes damaged or inaccessible, the mapping can be changed to map to another erase block. This mitigates the loss of losing an entire virtual erase block when one element's erase block is faulty. The remapping module  changes a mapping of a logical address of an erase block to one or more physical addresses of a virtual erase block (spread over the array of storage elements). For example, virtual erase block  may be mapped to erase block  of storage element SSS . , to erase block  of storage element SSS . , . . . , and to storage element .M , virtual erase block  may be mapped to erase block  of storage element SSS . , to erase block  of storage element SSS . , . . . , and to storage element .M , etc. Alternatively, virtual erase block  may be mapped to one erase block from each storage element in an array such that virtual erase block  includes erase block  of storage element SSS . to erase block  of storage element SSS . to storage element .M , and erase block  of storage element SSS . to erase block  of storage element SSS . , . . . , and to storage element .M , for each storage element in the array up to erase block  of storage element N.M ","If erase block  of a storage element SSS. is damaged, experiencing errors due to wear, etc., or cannot be used for some reason, the remapping module  could change the logical-to-physical mapping for the logical address that pointed to erase block  of virtual erase block . If a spare erase block (call it erase block ) of storage element SSS . is available and currently not mapped, the remapping module  could change the mapping of virtual erase block  to point to erase block  of storage element SSS . , while continuing to point to erase block  of storage element SSS . , erase block  of storage element SSS . (not shown) . . . , and to storage element .M . The mapping module  or remapping module  could map erase blocks in a prescribed order (virtual erase block  to erase block  of the storage elements, virtual erase block  to erase block  of the storage elements, etc.) or may map erase blocks of the storage elements , ,  in another order based on some other criteria.","In one embodiment, the erase blocks could be grouped by access time. Grouping by access time, meaning time to execute a command, such as programming (writing) data into pages of specific erase blocks, can level command completion so that a command executed across the erase blocks of a virtual erase block is not limited by the slowest erase block. In other embodiments, the erase blocks may be grouped by wear level, health, etc. One of skill in the art will recognize other factors to consider when mapping or remapping erase blocks.","In one embodiment, the storage bus controller  includes a status capture module  that receives status messages from the solid-state storage  and sends the status messages to the status MUX . In another embodiment, when the solid-state storage  is flash memory, the storage bus controller  includes a NAND bus controller . The NAND bus controller  directs commands from the read and write data pipelines ,  to the correct location in the solid-state storage , coordinates timing of command execution based on characteristics of the flash memory, etc. If the solid-state storage  is another solid-state storage type, the NAND bus controller  would be replaced by a bus controller specific to the storage type. One of skill in the art will recognize other functions of a NAND bus controller .","Data Transformations\/Predicate Offloading","Advantageously, certain embodiments of the solid-state storage device  are configured to apply a data transformation to data passing through the pipelines , .",{"@attributes":{"id":"p-0155","num":"0154"},"figref":["FIG. 5","FIG. 5","FIGS. 1 and 2","FIGS. 1 and 2"],"b":["502","502","114","114","502","102","502","514","502","504","230","110"]},"The solid-state storage controller module  includes a read data pipeline , a write data pipeline  and a transformation module . In the illustrated embodiment, the transformation module  is separate from the read data pipeline  and write data pipeline . In another embodiment, one or more features, functions, aspects or logic of the transformation module  is integrated into one or both of the read data pipeline  and write data pipeline . For example, different aspects of the transformation module  may be implemented using the write program module  and\/or read program module  described above in relation to .","The transformation module  serves to apply a condition, predicate, or data transformation to data passing between the client  and the solid-state storage media  by way of the write data pipeline  or read data pipeline . The transformation module  receives or otherwise identifies a transformation indicator indicating whether or not the transformation module  is to apply a data transformation to a set of data. A transformation indicator may be a dynamic indicator, such as a client request, or a static indicator, such as a predefined setting. A transformation indicator, such as a client request or predefined setting, may include a location identifier, an identifier of a data transformation, and an optional indicator of the return result requested. A client request is a command, setting, trigger, or other transformation indicator from a client , requesting that the transformation module  apply a data transformation  to a set of data.","One embodiment of a client request is a storage request from a client  that has a predefined transformation characteristic. For example, as described below, a storage request for a set of data that is smaller than a data block of the solid-state storage device  may trigger the transformation module  to apply a data transformation . In other embodiments, a storage request may include a flag, a marker, or other indicator triggering the transformation module  to apply a data transformation .","Another embodiment of a client request is a transformation request that a client  sends to the solid-state storage device  separate from a storage request. A client  may send client requests or other transformation information over an interface , as described below. In one embodiment, a client  sends a synchronous transformation request for each storage request, sending the synchronous transformation requests in the same data pipeline or interface  as the storage requests. As used herein, a synchronous transformation requests is a request for which the application of the transformation may be timed to be in sync with a flow of data through a data pipeline. In another embodiment, a client  may send an asynchronous transformation request for each storage request in a separate command pipeline or interface  from the storage requests. In a further embodiment, instead of sending a transformation request for each storage request, a client  may send a transformation request only for storage requests for data sets to which the transformation module  is to apply a data transformation . Alternatively, a client  may send a transformation request only for storage requests for data sets to which the transformation module  is not to apply a data transformation .","In certain embodiments, a transformation request may apply to multiple data sets or storage requests. For example, a client  may send a transformation request for a plurality of storage requests, such as storage requests of a certain type, a specified number of storage requests, or the like. Because the transformation request is persistent, the transformation module  applies a data transformation  for each storage request of the plurality of storage requests, without requiring a separate transformation request for each storage request. In another embodiment, a transformation request may be associated with a set of LBAs, and the transformation module  may apply a data transformation  to any set of data associated with the set of LBAs. In a further embodiment, a transformation request may be a global request for the solid-state storage device , and the transformation module  may apply a data transformation  to any data set written to or read from the entire solid-state storage device . A global transformation request, in certain embodiments, may not apply to system data, management data, or metadata of the solid-state storage device , but to user data\/workload data. Other transformation requests may toggle, change, or otherwise modify previous transformation requests.","As described above, in certain embodiments, a transformation indicator, such as a client request or predefined setting, may comprise a location identifier. The location identifier indicates where in the set of data received from the client , or set of data retrieved from the solid-state storage media , the transformation is to be applied to. In certain embodiments, the location identifier also identifies the quantity of data the transformation will be applied to. This quantity may be a fixed size (e.g. data stored in fixed size blocks\/sectors\/packets) or a variable size (e.g. objects in an object store). The location identifier may comprise a physical address of a single physical page or logical page in an array of non-volatile solid-state storage elements , , . The physical address may comprise an erase block address plus an offset. The offset may identify a particular physical page. The location identifier may comprise a logical block address of a block\/sector\/packet stored on the solid-state storage media .","The location identifier indicates where in a stream of data (read pipeline or write pipeline) the transformation module  is to begin applying the transformation. Where the size of the data blocks is fixed, or the location of subsequent data sets for the transformation module  is deterministic, the transformation module  may begin applying the data transformation for a predetermined number of data sets. In certain embodiments, the location identifier is sent by the client  along with a client request or storage request. In other embodiments, the location identifier is integrated with the data flowing through the pipelines , . For example, in one embodiment predefined markers, flags, or other indicators are sent with data to be stored on the media  and\/or stored with the data on the media . In another embodiment, data fields in a header or other metadata of a data set stored, or to be stored, on the media  serves as the location identifier.","For example, in one embodiment, a database management system (DBMS) client  may add a marker to the beginning or end of each row of data stored in a tablespace. These table spaces may be stored within one or more extents, which may in turn be stored within one or more files, which may be divided into one or more blocks that are then stored on the solid-state storage media . Consequently, the DBMS client  may submit a storage request for all data in a table. The storage request may include a data transformation  that keys off of the marker for a start of a row of data plus an offset. The marker that is stored with the data on the media  and an optional offset into the row may constitute the location identifier.","In certain embodiments, the solid-state storage device  services a plurality of storage requests simultaneously from a plurality of clients . Certain storage requests may include a request for the transformation module  to apply a data transformation  while others may not. Consequently, the solid-state storage controller module , in certain embodiments, is configured to coordinate the flow of data through the write data pipeline  and onto the media  and to coordinate the flow of data off of the media  and through the read data pipeline  with the storage requests such that the transformation module  applies the data transformation  to the correct set of data as that data passes through the corresponding pipeline , . This coordination process is referred to herein as synchronization. One embodiment for synchronizing application of a data transformation  with the correct set of data is illustrated and described in relation to . In certain embodiments, the transformation module  monitors the flow of data within the write data pipeline  and\/or the read data pipeline  to identify a set of data on which to apply a transformation. The transformation used by the transformation module  may comprise a predicate, a condition, and\/or a data transformation operation to be applied to a set of data. The transformation is the data transformation  described in more detail below.","The indicator of the return result requested identifies what type of result the transformation module  should return to the client . If the storage request is a read request combined with application of a data transformation , the return result may comprise a Boolean True or False to indicate if there was data on the media  that satisfied the predicate. Alternatively, the return result may comprise a count of sets of data on the media  that satisfied the predicate. Alternatively, the return result may comprise a count or a Boolean indicator as well as the sets of data on the media  that satisfied the predicate. Alternatively, or in addition, the return result may comprise the sets of data on the media  that satisfied the predicate as well as a count of sets of data that failed to satisfy the predicate. Returning the count of sets of data that failed to satisfy the predicate may provide an indication to the client  of the magnitude of filtering the transformation module  has provided.","The transformation module  applies one or more data transformations  to one or more data blocks or parts of data blocks passing through the solid-state storage device , or to particular data blocks passing through the solid-state storage device . The transformation module  may apply a data transformation  in response to an indicator from a client . Advantageously, the data transformation  applied to one or more data blocks passing through the solid-state storage device  reduces the quantity of data passing into, or out of, the solid-state storage device . In this manner, the data transformations  are performed as close to the solid-state storage media  as possible, while still maintaining high throughput, bandwidth, and data integrity.","In one embodiment, the solid-state storage controller module  is a field-programmable gate array (\u201cFPGA\u201d) and controller functions are programmed into the FPGA. In a particular embodiment, the FPGA is a Xilinx\u00ae FPGA. In certain embodiments, the FPGA is a Look Up Tables (\u201cLUTs\u201d) based FPGA. In another embodiment, the solid-state storage controller module  comprises components specifically designed as a solid-state storage controller module , such as an application-specific integrated circuit (\u201cASIC\u201d) or custom logic solution. In another embodiment, at least one solid-state storage controller module  is made up of a combination FPGA, ASIC, processors, and custom logic components either distinct or integrated with each other in different configurations. In another embodiment, the solid-state storage controller module  comprises a hybrid device comprising FPGA components integrated with general purpose processors (CPUs or GPUs, e.g. Performance Optimization with Enhanced RISC\u2014Performance Computing (PowerPC or PPC) processor) in a single chip or package. As used herein, the term logic hardware includes both hardware devices, such as FPGAs, ASICs, and processors, and programmable elements for hardware devices, such as firmware for an FPGA, microcode for a processor, and the like.","Embodiments of the solid-state storage controller module  implemented using an FPGA and\/or a hybrid device enable dynamic reconfiguration or reprogramming such that the solid-state storage controller module  can adapt to implement one or more data transformation  without changing the hardware used for the solid-state storage controller module . In one embodiment, the solid-state storage controller module  includes the processing logic to execute an arbitrary data transformation  using for example a general purpose processor or CPU. For example, a client  may supply the arbitrary data transformation  in the form of directly executable code (i.e. assembly). In another embodiment, the solid-state storage controller module  is programmable such that the solid-state storage controller module  can be programmed or reprogrammed to implement an arbitrary data transformation  using for example gates of an FPGA.","For example, at the time a solid-state storage device  is installed or formatted, the setup or configuration process can include programming or configuring the solid-state storage controller module  to support one or more data transformations . In one embodiment, the transformation module  is configured to apply a single data transformation . In another embodiment, the transformation module  is configured to apply two or more data transformation  selected from a set of data transformations .","In addition, or alternatively, the solid-state storage controller module  may be programmed during run-time operation to support or apply one or more data transformations . Definitions for these data transformations  may be supplied in the form of Verilog or netlist instructions that cause an FPGA to configure certain gates to support a logic operation represented by the Verilog or netlist instructions. Programming or re-programming the solid-state storage controller module  to support one or more different data transformations  may be done at different levels of execution granularity. For example, in one embodiment, a data transformation  is programmed for a particular data storage request from a particular client . In another embodiment, a data transformation  is programmed for each data storage request from a particular client . In certain embodiments, the solid-state storage controller module  is programmed with a plurality of different data transformations  and a selection circuit. In such an embodiment, the transformation module  may apply a different data transformation  by activating the selection circuit to activate a particular data transformation  for a set of data identified by the location identifier. The transformation module  may activate a particular data transformation  by sending data in the pipeline ,  through the selected data transformation circuit.","A data transformation  may comprise a predefined data transformation  or a data transformation  supplied by the client . Advantageously, the solid-state storage device  is dynamically programmable and\/or configurable to execute a wide range of transformations  so long as the transformations  conform to a predefined language and grammar. Predefined data transformation  may be selected from a library of possible data transformations . The predefined data transformation  are in a format and syntax suitable for the transformation module  to apply the data transformation  without further processing.","In addition, or alternatively, the transformation module  may comprise a fully programmable Central Processing Unit (CPU). The CPU may comprise a soft-core implemented within an FPGA or a hard-core such as an Advanced RISC Machine (ARM) or PowerPC processor integrated with an FPGA. The client  may include with a storage request a transformation in the form of script code or other human readable code such as source code. The transformation module  may dynamically compile or interpret the source code or script code at run-time to generate a corresponding data transformation .","Data transformations  relating to different purposes may be applied. For example, in one embodiment a data transformation  facilitates managing data integrity information. One form of data integrity protection that the transformation module  applies, in one embodiment, is adding and\/or removing T10 Data Integrity Field (DIF)\/DIX metadata to blocks for managing data integrity. Adding of data for the purpose of data integrity protection may be advantageous where the solid-state storage device  serves in a tiered storage architecture in which the solid-state storage device  passes data down to lower tiers. Where the lower tiers do not offer a desired level of data integrity protection such as the DIF\/DIX meta data, the solid-state storage device  can supply such missing functionality. For example, where the solid-state storage device  is used as a cache (described in U.S. patent application Ser. No. 12\/877,971, filed Sep. 8, 2010 to David Flynn, et al, entitled \u201cApparatus, system, and method for caching data on a solid-state storage device\u201d, which is hereby incorporated by reference) in front of a backing store that does not support the T10 DIF form of data integrity protection.","T10 DIF metadata comes in different types. The T10 DIF metadata may be passed through the I\/O stack to facilitate identifying if there is a data integrity error. For T10 DIF, the integrity metadata is 8 bytes\u2014the 8 bytes are a tuple of (a 16 bit CRC, a 16 bit placation tag, and a 32 bit reference tag\u2014often an incrementing counter). By applying a T10 DIF transformation the transformation module  accomplishes a goal of T10 DIF of computing this metadata as close in proximity to the original data as possible. The DIF\/DIX data integrity computation adds an additional layer of data integrity protection (regardless of the underlying media). T10 DIF\/DIX implements a Cyclic Redundancy Check (CRC) so, while errors are not correctable by T10 DIF metadata they are detectable.","In another embodiment, the data transformation  comprises a filter that reduces the size of the set of data stored to the solid-state storage media , or returned to the client  based on some predicate or condition that excludes data that fails to satisfy the predicate. Filtering of data between the solid-state storage device  and the computer  permits efficient use of the communication path (e.g. system bus , such as PCIe, described above in relation to ). In certain embodiments, the architecture and protocol used for the communication path limits the bandwidth and throughput of data between the computer  and the solid-state storage device . As the solid-state storage device  applies a data transformation  that filters the data as the data passes through the pipelines ,  and at the same speed as data normally flows through the pipelines, the solid-state storage device  accomplishes performance advantages.","A filter data transformation  is a form of a predicate that is to be applied to the data as the data flows into, or out of, the pipelines , . As used herein, a predicate is a condition or other function which when applied to a data set returns either a true or a false result. While applying predicates to data sets has been performed by software applications or device drivers at higher levels in the storage software stack, the solid-state storage device  performs data transformations  at the solid-state storage controller module  level. Performing operations at a lower level than traditionally performed in the storage software stack is referred to herein as predicate offloading. Datasets satisfying the predicate return a true result and datasets failing to satisfy the predicate return a false result. Where a dataset satisfies a predicate, the transformation module  may select certain data from the dataset to include in a returned result set. In one embodiment, the data transformation  is applied to a whole data block (e.g. sector). Alternatively, the data transformation  is applied to a subset of the requested set of data. In another embodiment, the data transformation  is a combination transformation applied to both a whole data set and a subset of the data set.","Another type of data transformation  allows a client  to write and\/or read data in data sizes less than a full data block (or data sector) of the solid-state storage device , accessing a sub-block (sub-sector). For example, the solid-state storage device  may store data in blocks or sectors with a fixed size, such as 512 bytes, 4096 bytes, or the like. When the transformation module  detects a storage request for an amount of data that is smaller than the block size for the solid-state storage device , the transformation module  may apply a data transformation  allowing access to a sub-block of data. For a read request, the data transformation  may include discarding a portion of a data block to return only data of the requested sub-block to a requesting client .","For a write request, the data transformation  may include a read, modify, write operation, performed internally within the solid-state storage device , so that the full block does not travel over a system bus to the computer  or require further processing on the computer . When a write request includes a set of data that is smaller than a block size (i.e. a sub-block), the transformation module  reads a full data block that includes the set of data from the solid-state storage media  into memory such as DRAM  or the like. The transformation module  modifies a portion of the data block, in memory, with the set of data. The write request may include an offset and size to identify the set of data within the data block. In one embodiment, the offset for the set of data comprises an indirect indicator for the offset, such as a logical block address for the set of data or the like. In another embodiment, the offset for the set of data comprises a direct indicator of the offset, such as a number of bytes into the data block that the set of data (the set of data maybe of a fixed or variable size and may be included in, or referenced by, the write request) is to be written, or the like.","The transformation module  may modify the data block in internal memory by overwriting a portion of the data block with the data set from the write request, or by otherwise modifying the data block to reflect changes from the received data set. The transformation module  writes the modified data block back out to the solid-state storage device . In one embodiment, the transformation module  writes the modified data block to an append point of a sequential log-based writing structure of the solid-state storage device , not to the location from which the data block was read. By applying the data transformation  internally within the solid-state storage device , without sending a full data block to the computer , the client , or another host device, the transformation module  conserves bandwidth on system buses, reduces processing overhead for a host device, and provides convenient sub-block access to clients .","A return result for applying the data transformation  may comprise a data set (including one or more data storage blocks or sectors both contiguously addressed and non-contiguously addressed), a subset of a requested dataset, and\/or a Boolean indicator resulting from applying the data transformation .","Embodiments of the present invention support a variety of different levels of granularity for applying the data transformation . In one embodiment, the data transformation  is applied at the bit level within a data block\/sector\/packet. For example, the data transformation  may instruct the transformation module  to return N bytes of data in a given data block identified by LBA X, starting at offset Y. The N bytes of data starting at offset Y may represent a known type of data.","For example, in a database application, N bytes of data starting at offset Y may correspond to data in a fixed length column of a database table. By employing the example data transformation , the database application can retrieve only data for a particular column without having to retrieve an entire database table row, only to use the one column's data. Alternatively, as the block\/sector\/packet sizes continue to increase for block storage devices, employing a data transformation  such as a filter enables a client  to retrieve data of a more fine granularity than the block\/sector\/packet size and optionally apply a predicate or transformation operation on that data as well.","In another embodiment, the transformation module  applies a data transformation  to data identified by a set of LBAs (the LBAs may be a set of contiguous LBAs, noncontiguous LBAs or a combination of these). For example, the data transformation  may instruct the transformation module  to return for a given contiguous LBA range, the sum of the 4th byte from each Block\/packet\/sector in the range. By employing the example data transformation , the client  can perform certain operations on the data which reduces the amount of data passed back to the client .","In one embodiment, the solid state storage controller module  stores the data at the physical addresses on the solid-state storage media  using a log-based, append only writing structure such that data overwritten by a subsequent write request invalidates other data stored earlier in the log. Consequently, a garbage collection (or space recovery) process recovers the physical capacity of the invalid data in the log. One embodiment of the log-based, append only writing structure is logically a ring-like data structure, as new data is appended to the log-based writing structure, previously used physical capacity is reused in a circular, theoretically infinite manner. In such embodiments, the solid-state storage controller module  may write an LBA to the solid-state storage media . Storing the LBA on the solid-state storage media  identifies each sector\/block\/packet written as well as the sector\/block\/packet's physical location on the solid-state storage media .","Because the LBA is available to the transformation module , the transformation module  can apply data transformations  that relate to LBA's (either individually, or collectively in a contiguous range, or in sets of noncontiguous ranges). For example, the data transformation  may include a predicate such as return the last 4 bytes of each LBA having an address that is evenly divisible by four.","Those of skill in the art will appreciate other kinds of predicates and operations that can be applied to the data passing through the controller module . For example, a certain index key may be looked up in an index stored on the media . Alternatively, any arithmetic, conditional logic, or pattern matching, expression can be applied to the data.","The type, size, and complexity of the data transformation  depends on the level of granularity at which the predicate is to be applied, as well as the processing capabilities of the solid-state storage controller module . As noted above, the solid-state storage device  is dynamically programmable and\/or configurable to execute a wide range of transformations  so long as the transformations  conform to a predefined language and grammar.","In certain embodiments, the solid-state storage controller module  comprises a processing module  that applies the data transformation  for the transformation module . The processing module  may support one or more predefined languages and\/or grammars. The processing module  may convert a given transformation provided by a client  in a storage request into a data transformation  suitable for applying to the data flowing into or out of the solid-state storage media , may apply a predefined transformation, or the like.","The processing module  includes hardware processing logic capable of performing general processing functionality. In one embodiment, the processing module  and its associated hardware logic are Turing complete. In one embodiment, the processing module  comprises a separate FPGA, such as for example a Look Up Tables (LUTs) based FPGA. Alternatively, the processing module  comprises an application-specific integrated circuit (\u201cASIC\u201d), custom logic solution, or a set of gates of an FPGA programmed to perform general purpose computing. Alternatively, the processing module  comprises a general purpose processor (e.g. CPU, GPU, PowerPC processor). The logic hardware of the processing module  may be the same hardware described above with regard to the solid-state storage controller module  and\/or the transformation module , or may comprise separate logic hardware in communication with the solid-state storage controller module  and\/or the transformation module .","For example, in one embodiment, the processing module  comprises logic hardware of the solid-state storage device , such as an FPGA, ASIC, general purpose processor, or the like of the solid-state storage controller module . In another embodiment, the processing module  may comprise logic hardware of the peer device , and the transformation module  may offload application of the data transformation  to the peer device . The peer device , in one embodiment, may be in communication with the solid-state storage device  independent of the computer  or other host device, such that communications between the solid-state storage device  and the peer device  use little or no system resources of the computer .","In one embodiment, the peer device  and the solid-state storage device  each communicate with the computer  or other host device over a PCIe bus. PCIe typically provides a higher bandwidth for communications between peers than for communications with a computer  or host device, as communications with the computer  or other host device are limited by the number of I\/O pins of the processor and by other limits on system resources. The peer device , in one embodiment. may be a GPU that supports general purpose GPU (\u201cGPGPU\u201d) functionality, such as Compute Unified Device Architecture (\u201cCUDA\u201d), Open Computing Language (\u201cOpenCL\u201d), DirectCompute, or the like. The peer device  may have more processing power, more processing cores, or the like than the solid-state storage controller module , allowing for more complicated or processor intensive data transformations . In one embodiment, the solid-state storage controller module  provides data from the solid-state storage device  directly to the peer device , making the offloading of the data transformation  to the peer device  more efficient than if data were transferred to the peer device  via the computer  or other host device.","The processing module  in one embodiment accepts a transformation having a variety of formats and\/or syntax. The transformation may comprise a query, predicate, or transformation in the form of a Regular Expression (REGEX), Structured Query Language (SQL), XML Path Language (XPATH), or X Query expression along with context information that identifies where in the data flow (pipelines , ) to apply the transformation.","The processing module  uses a language and grammar associated with the type of transformation provided. The processing module  converts the transformation provided into a data transformation  suitable for application by the transformation module . For example, the transformation may be in the form of script code or other human readable code such as source code. The processing module  may dynamically compile or interpret such source code or script code at run-time to generate the suitable data transformation . During operation the processing module  may use the DRAM  for temporary storage in performing its processing and translations. For example, the DRAM  may serve as a scratch pad for the processing module .","The data transformation  may be applied by the transformation module  in servicing data mining applications (e.g. client ) and\/or data warehouse applications submitting queries for the data on the solid-state storage media .","In certain embodiments, the client  and solid-state storage device  communicate using an interface . In certain embodiments, the interface  comprises an extension of an existing interface such as a block device interface (e.g. IOCTL calls). In another embodiment, the interface  comprises a separate or new interface specifically designed for managing transformations applied at the solid-state storage device . In one embodiment, the client  is an application and the interface  is an application level Application Programming Interface (API). In another embodiment, the client  is an Operating System (OS), File System (FS), or other application suited for directly interfacing with storage devices such as a Database Management System (DBMS), and the interface  is low level programming interface, which may comprise a proprietary interface.","In certain embodiments, the interface  includes new functions tailored specifically to client requests requesting, identifying, and triggering operation of the transformation module . Alternatively, the client request or indicator of which blocks\/sectors\/packets the transformation module  is to operate on and\/or an indicator of the data transformation  are included in parameters of a storage request from the client .","The solid-state storage controller module  receives a client request or other transformation indicator that a particular data transformation  is to be applied to data sent or received by the solid-state storage controller module . The client request or other transformation indicator may identify particular sets of data (e.g. Blocks having an LBA within a particular range, a specific set of data associated with a given LBA, etc.). The client request or other transformation indicator may also include an identifier of the data transformation  to be applied or a definition of the data transformation  to be applied.","In one embodiment, the client requests or other transformation indicator passed in the interface  are passed on the same bus as the data bus (e.g. the data and control information\/instructions are passed together in the same channel). Alternatively, the client requests or other transformation indicators passed in the interface  is passed over a control separate from the data bus (e.g. the data and control information\/instructions are passed in separate communication channels). Alternatively, the client requests or other transformation indicators passed in the interface  is passed over the same control path used to communicate other I\/O control messages. By separating the transformation information from the data, the bandwidth for data transfers is efficiently utilized.",{"@attributes":{"id":"p-0199","num":"0198"},"figref":["FIG. 6","FIG. 6","FIGS. 1"],"b":["604","2","3"]},"The solid-state storage controller  comprises one or more transformation stages , that, in one embodiment are integrated into the read pipeline  and the write pipeline . In certain embodiments, the transformation stages , may comprise the write program module  and read program module  described above in relation to . In certain embodiments, the transformation stages , may comprise the functionality described in relation to the transformation module  described above relation to . Certain embodiments of the solid-state storage controller  may include one or the other of the transformation stages , ","As described above, data written to the storage media  flows through the write data pipeline  from the input buffer  to the write sync buffer  through each successive stage. Similarly, data read from the storage media  flows through the read data pipeline  from the read sync buffer  to the output buffer  through each successive stage. With the transformation stages , integrated into the pipelines , , each transformation stage , can apply a data transformation  to the data in the pipeline at the requested level of granularity. (e.g. packet\/sector\/block level, ECC chunk level, physical page level, logical page level, logical erase block level, and the like). In one embodiment, the transformation stages , synchronize their operations with the data flow by way of control commands stored in command control queues . The control and status registers  and control queues  facilitate control and sequencing commands and subcommands associated with data processed in the write and read data pipelines , .","In one embodiment, the solid-state storage controller  includes a transformation module  and the transformation stages , . In such an embodiment, the transformation module  may convert a given transformation provided by a client  into a set of control commands sent to the command control queues  to execute a data transformation . In another embodiment, a device driver or controller generates a set of control commands to send to the command control queues  without the use of the transformation module .","Certain data transformations  may apply solely to write storage requests, (e.g. Write the first 12 bytes of every fourth block\/sector\/packet) while other data transformations  may apply solely to read storage requests (e.g. a database field filter such as read the 3 bytes at offset 32 in each block\/sector\/packet for 10,000 blocks\/sectors\/packets). In still other data transformations , the transformation stage , may apply a data transformation  for read and write storage requests (e.g. Store a DIF\/DIX data set with each write and verify a DIF\/DIX data set with each read of a block\/sector\/packet). The DIF\/DIX data set may optionally be removed by the transformation stage ","One example of the solid-state storage controller module  applying a data transformation  solely to write storage request is where the solid-state storage controller module  serves as the final tier storage device in a tiered storage architecture in which the solid-state storage device  receives data that includes a DIF\/DIX data set for data integrity purposes. In such an embodiment, the data transformation  applied in the transformation stage of the write data pipeline  may verify the DIF\/DIX data set of each block\/sector\/packet and\/or signal an error if the verification fails. In this manner, such an embodiment validates or verifies the data prior to the data beings stored on the media .","In another embodiment, the transformation stages , may apply a data transformation  for one of a write storage request or a read storage request and another software layer in a storage hierarchy or another solid-state storage device  (e.g. where one solid-state storage device  shares a PCIe link to another solid-state storage device  and the two devices  serve to provide high availability in an active-active or active-passive configuration) may perform an inverse of the data transformation  for the other corresponding storage request (read\/write). For example, where the solid-state storage device  serves as a cache for a backing store such as a block storage device (e.g. hard disk drive, SAN, etc), the solid-state storage controller module  may apply data transformations  for all write storage requests to add a DIF\/DIX data set with each write. Blocks\/sectors\/packets exiting the transformation stage include the DIF\/DIX data set. These DIF\/DIX protected blocks\/sectors\/packets may be sent to the backing store and to the next stage in the write data pipeline  (packetizer ). Similarly, DIF\/DIX protected blocks\/sectors\/packets read the backing store may enter the read data pipeline  at the transformation stage such that the DIF\/DIX data set can be verified with each read of a block\/sector\/packet from the backing store. In this manner, embodiments of the present invention use the transformation stages , to provide data transformations (including added data protections) data storage devices that are positioned behind the solid-state storage device  when viewed from the perspective of the client .","Embodiments that include the solid-state storage device  operating as a cache are described in U.S. patent application Ser. No. 12\/877,971, filed Sep. 8, 2010 to David Flynn, et al, entitled \u201cApparatus, system, and method for caching data on a solid-state storage device\u201d, U.S. patent application Ser. No. 12\/847,952, filed Jul. 30, 2010 to David Flynn, et al, entitled \u201cApparatus, system, and method for redundant write caching\u201d, U.S. patent application Ser. No. 12\/885,285, filed Sep. 17, 2010 to David Flynn, et al, entitled \u201cApparatus, system, and method for graceful cache device degradation,\u201d U.S. Provisional Patent Application 61\/373,271, filed Aug. 12, 2010 to David Flynn, entitled \u201cApparatus, system, and method for caching data,\u201d which are hereby incorporated by reference.","The control commands stored in command control queues  include sufficient instructions and metadata for the transformation stages , to apply the data transformation  to the appropriate set of data passing through the pipelines , . The control commands may be client requests or may include transformation information from client requests. For example, the control commands may identify how many bytes or data segments to allow to pass before applying a predicate\/transformation and which data within the data segment to apply the predicate\/transformation to. In addition, or alternatively, the control commands may include a trigger or marker to watch for in the data flow which causes the predicate\/transformation to be applied. By managing the order and timing of control commands in the control queues  and\/or the placement of markers or triggers in the data flowing though the pipelines , , the flow of the data and any applicable data transformations  is synchronized. In one embodiment, each clock cycle advances eight bytes through the pipelines ,  to either the next stage or an intermediate buffer in the pipeline ,.","In one embodiment, the transformation module  may be implemented in a device driver for the solid-state storage device . The device driver may execute or operate on the computer . In such an embodiment, the benefits of applying a transformation  may be weighed against the processing overhead and resource utilization impacts on a host computer's processors and\/or memory. As described in greater detail below, the transformation module  may offload certain data transformations  to the computer  or other host device for application to a data set.","In one embodiment, the transformation module  applies the data transformation  at a higher level of granularity for example processing a SQL query for a row of a database table. As the transformation module  applies the data transformation , the transformation module  may generate commands that are provided to the transformation stage and\/or transformation stage ","These commands may implement all or part of the data transformation at the bit-level as data segments sized to pass through the pipeline ,. Data segments move through the pipeline ,  at the rate of the local clock domain. Similarly, or in addition, the commands may operate on blocks\/sectors\/packets of data which comprise a plurality of data segments. In the example of a SQL query for a row of a database table, the transformation module  may receive a data transformation  that includes a layout of the structural relationship of blocks\/sectors\/packets to files, to extents, to tablespaces, to tables, to rows, to columns. The transformation module  may convert this relationship information into a command sent to the transformation stage and\/or transformation stage . The command may indicate the particular block count and offset within a select block at which the transformation stage and\/or transformation stage should do a comparison to see of the data in the pipeline ,  matches a particular bit pattern. Blocks\/sectors\/packets satisfying the pattern may be identified for the transformation module  while blocks\/sectors\/packets not satisfying the pattern may be counted and discarded.","Those of skill in the art will recognize that because the relationships between data segments in the pipeline ,  and fields within a row of a database table differ, the command may include instructions to skip a certain number of data segments and\/or blocks\/sectors\/packets before applying a match condition. Skipped data segments and\/or blocks\/sectors\/packets may be discarded or discarded and counted. The count of discarded data may be included in the return result to identify the magnitude of data reviewed in applying a data transformation .","In one embodiment, the transformation stages , gather or compute the results of applying the data transformation  at the rate that data flows through the pipelines , , referred to as line speed. In addition, the transformation stages , may maintain a count of data blocks\/sectors\/packets that fail to satisfy a data transformation  that comprises a predicate. The transformation stages , may gather the results within internal buffers or a common shared buffer used by the solid-state storage controller . Alternatively, the results may pool within a subsequent stage in the pipeline , .","Often the flow of data through the transformation stage , results in less data than the amount of data that entered the transformation stage , . Advantageously, the reduction in the amount of data maximizes the storage capacity available on the media  and\/or use of bandwidth between the solid-state storage device  and the host computer  and\/or client . In addition embodiments of the present invention perform the transformations as close to the persistently stored data as possible and retrieve for an application no more data than the client  such as a user application will need and use.","Often the bandwidth for data passing between the computer  and the solid-state storage device  over the system bus  (See ) is less than the bandwidth for internal busses in the computer  or the solid-state storage device . For example, where the system bus  is a PCIe bus the bandwidth is limited to about 5.0 Gbps. Consequently, the system bus  may be a bottleneck that restricts the optimal flow of data to and from the solid-state storage device .",{"@attributes":{"id":"p-0215","num":"0214"},"figref":["FIG. 7","FIG. 7","FIGS. 1"],"b":["704","2","3","5"]},"The solid-state storage controller  comprises a data transformation pipeline  and a transformation module . In certain embodiments, the transformation module  may comprise similar functionality to that described in relation to the transformation module  described above relation to .","The solid-state storage controller  illustrates an embodiment in which the data transformations  pass through the data transformation pipeline  and are then applied to a data segment\/packet\/sector\/block entering the write data pipeline  or exiting the read data pipeline .","The data transformation pipeline  independently receives transformations and prepares the transformations for application to data passing through one or both of the write data pipeline  and the read data pipeline . In one embodiment, the data transformation pipeline  comprises one or more optional stages such as a processing stage , a validation stage , and an efficiency stage . The processing stage  may function substantially similar to the processing module  described above. The processing stage  may convert a transformation from a non-executable state to an executable form of a data transformation . The validation stage  may verify that the data transformation is executable by the transformation module  and that the inputs for the data transformation match the type and size of data passing through the associated data pipeline , . The efficiency stage  may apply certain heuristics to determine whether the overhead of applying the transformation is more efficient than having this transformation performed by the host CPU\/computer . Those of skill in the art will recognize that the data transformation pipeline  may have zero or more stages depending on the format of the data transformation  supplied and on the amount of pre-processing desired for the data transformation . For example, in embodiments having zeros stages , , , the data transformation pipeline  may serve as a queue providing a sequence for data transformations  received.","The solid-state storage controller  may receive the transformations as part of a storage request, by way of a 3rd party client , by loading the transformations from a configuration file or other persistent store, or by way of a control channel between the solid-state storage device  and the client .","As mentioned above, the transformation module  uses a location identifier, a transformation, and an optional indicator of the return result requested. In one embodiment, the data transformation pipeline  supplies the next data transformation  to be applied to a data segment\/sector\/block\/packet in the data pipeline , . In one embodiment, the transformation module  receives the location identifier by way of a control queue such as control queue . For example, the location identifier may identify a certain number of data segments to skip in one or both of the data pipelines ,  before applying the next data transformation . Alternatively, the location identifier may comprise an address or marker of the data segment\/sector\/block\/packet the transformation module  should use in applying the next data transformation .","By having a separate data transformation pipeline , the solid-state storage controller  may perform pre-processing and\/or validation operations on a transformation. In addition, transformations passed to the data transformation pipeline  may be received over a communication channel separate from the data channel used for the other pipelines , . In addition, having a separate data transformation pipeline  may facilitate synchronization of application of a particular data transformation  with the data flow through the pipelines ,  while optimizing data throughput. For example, any stalls in the pipelines ,  may similarly stall the data transformation pipeline . In this manner, the transformation module  may simply apply the data transformation  at the tail end of the data transformation pipeline  when a marker or indicator is found in the appropriate data pipeline , .","In certain embodiments, the transformation module  identifies whether the data segment\/sector\/block\/packet to use is in the write data pipeline  or the read data pipeline  by way of the location identifier. Alternatively, the type of data transformation  may identify which data pipeline ,  to use.","In one embodiment, the transformation module  receives the optional indicator of the return result requested by way of a control queue such as control queue . In other embodiments, the return result is the result from applying the appropriate data transformation .","In certain embodiments, the transformation module  (Returning to ) performs a comparison of the cost in terms of processing overhead, memory (e.g. DRAM ) usage, and other factors versus the benefit in bandwidth utilization that a particular data transformation  will have. In certain embodiments, if a predefined or user defined efficiency metric is not satisfied, the transformation module  may reject the requested transformation  and thus not perform the transformation . In a further embodiment, if a requested data transformation  fails to satisfy the efficiency metric, the transformation module  offloads the requested data transformation  to the computer  or another host device, and the host device applies the data transformation  to a data set after the solid-state storage controller module  completes a storage operation for the data set and sends the data set or another result of the storage operation to the host device.","The efficiency metric, in one embodiment, is satisfied if the processing module  may apply the data transformation  at the speed of the corresponding pipeline , , \u201cline speed.\u201d In another embodiment, whether a data transformation  satisfies the efficiency metric may be based on performance of the solid-state storage device  when the data transformation  is requested, such as I\/O operations per second (\u201cIOPS\u201d) for the solid-state storage device , workload pressure on the solid-state storage device , or the like. If performance of the solid-state storage device  fails to satisfy the efficiency metric when a data transformation  is requested, in certain embodiments, the transformation module  offloads the data transformation  to the computer  for application.","In another embodiment, the efficiency metric is based on a current available bandwidth between the solid-state storage device  and the computer  or other host device. For example, if an amount of available bandwidth satisfies a bandwidth threshold, in certain embodiments, applying a data transformation  on the solid-state storage device  itself may not be beneficial, as bandwidth is available and the computer  may apply the data transformation .","In one embodiment, the transformation module  may dynamically determine whether a requested data transformation  satisfies the efficiency metric with each client request or other transformation indicator, selectively assigning the data transformation  to either the processing module  within the solid-state storage device  or to the computer  or other host device. In another embodiment, whether or not a data transformation  satisfies the efficiency metric is predetermined for the transformation module , and certain data transformations  are applied within the solid-state storage device  by the processing module  and other data transformations  are applied on the computer  or other host device. In one embodiment, a device driver for the solid-state storage device  applies the data transformation  on the computer device .","Certain data transformations  may increase the size of the data set as a result of the transformation. In certain embodiments, the transformation module  determines that a data transformation  that increases the size of the data should be performed because the offloading of this transformation to the solid-state storage device  may cause an improvement in overall processing efficiency due to the reduction in processing over head on a host CPU in the computer .","Conversely, certain data transformations  may decrease the size of the data set as a result of the transformation. But, there may be little or no bandwidth constraint between the solid-state storage device . Consequently, the transformation module  may reject or not perform a given data transformation  because the increased overhead does not lead to an overall increase in processing efficiency in the computer . In other words, the host CPU\/computer  may more efficiently perform the data transformation , and the transformation module  may offload the data transformation  as described above. Advantageously, the transformation module  is configured to determine these differences in processing efficiencies and facilitates performance of the transformation at the most efficient level between the solid-state storage device  and the client .","In one embodiment a client  (e.g. user space application, operating system, file system, and the like) uses an Application Programming Interface (API) that exposes functionality of the transformation module . In certain embodiments, a device driver for the solid-state storage device  may make the API available to the client  and may receive API calls, such as client requests, from the client . The client  may use the API to determine whether a particular data transformation  will provide the expected efficiency gains. The client  may use the API to send client requests, define the data transformation , monitor the progress of data transformations , and receive feedback from the transformation module  associated with a data transformation .","Of course, what the efficiency level is, and when to reject a given data transformation  may be managed by a storage policy. The efficiency threshold represents a trade off between bandwidth limitations between the solid-state storage device  and the computer  or host and the processing overhead of performing the transformation within the solid-state storage device .","Advantageously, embodiments of the present invention perform a dynamic and configurable set of data transformations within a solid-state storage device . Furthermore, embodiments of the present invention enable the software application such as the client  to manage and direct which data transformations  are applied to which blocks\/sectors\/packets (both noncontiguous sets and contiguous ranges of blocks\/sectors\/packets. Embodiments of the present invention enable client\/Application requested data transformations  to be performed in a solid-state storage device .","In addition, embodiments of the present invention perform a data transformations at the same rate that I\/O data flows through the pipelines ,  (e.g. \u201cline speed\u201d) with minimal overhead introduced into the stages. In exchange for the minimal overhead, the only the data desired by a client  is stored or returned from the solid-state storage device  which in turn optimizes use of bandwidth between the solid-state storage device  and the host\/computer .",{"@attributes":{"id":"p-0234","num":"0233"},"figref":"FIG. 8","b":["800","800","504","802","504","506","804","508","506","804","508","800","504","802","506","804","512","806","504","802","800"]},{"@attributes":{"id":"p-0235","num":"0234"},"figref":"FIG. 9","b":["900","900","504","902","504","506","904","106","108","506","906","508"]},"If the transformation module  determines  not to apply a data transformation  to the set of data, the method  continues as the storage controller module  executes  further storage operations. If the transformation module  determines  to apply a data transformation  to the set of data, the transformation module  determines  whether the data transformation  satisfies an efficiency metric.","If the data transformation  satisfies  the efficiency metric, the processing module  applies  the data transformation to the set of data internally within the storage device . If the data transformation  does not satisfy  the efficiency metric, a computer  or other host device of the storage device  applies  the data transformation . The storage controller module  returns  a return result to the client  to satisfy the storage operation, and the method  continues as the storage controller module  executes  further storage operations.","The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order that the advantages of the invention will be readily understood, a more particular description of the invention briefly described above will be rendered by reference to specific embodiments that are illustrated in the appended drawings. Understanding that these drawings depict only typical embodiments of the invention and are not therefore to be considered to be limiting of its scope, the invention will be described and explained with additional specificity and detail through the use of the accompanying drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
