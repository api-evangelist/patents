---
title: System and method for generating software unit tests simultaneously with API documentation
abstract: A system and method may generate unit tests for source code concurrently with API documentation. The system may receive a source code file including several comments sections. Each comments section may include a description of a source code unit such as a class, method, member variable, etc. The description may also correspond to input and output parameters the source code unit. The system and method may parsing the source code file to determine a source code function type corresponding to the unit description and copy the unit description to a unit test stub corresponding to the function type. A developer or another module may then complete the unit test stub to transform each stub into a complete unit test corresponding to the source code unit. Additionally, the system and method may execute the unit test and generate a test result indication for each unit test.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043759&OS=09043759&RS=09043759
owner: Trimble Navigation Limited
number: 09043759
owner_city: Sunnyvale
owner_country: US
publication_date: 20110809
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims the benefit of U.S. Provisional Patent Application No. 61\/436,878 filed Jan. 27, 2011, the disclosure of which is incorporated herein by reference in its entirety for all purposes.","The present disclosure generally relates to a system and method for generating unit tests during software development and, more particularly, to generating unit tests from the documentation and comments portions of high-level computer code.","Software programs or applications typically include several different functions, modules, methods, etc. (i.e., \u201cunits\u201d) that interact by accessing and using shared resources. Generally speaking, a unit may be described as the smallest testable portion of an application such as a function or procedure. On a larger scale, applications themselves are written so that other programs may be written to access and use the application's resources. To understand existing applications and to develop new applications that add functionality to these existing applications, an application programming interface (API) is often developed to aid future development. An API defines the rules and specifications for a software program so that other programs can be designed to use the various resources of that program. In other words, the API operates as an interface between programs.","To assist other programmers in creating compatible programs, each application typically includes an API while the source code for each unit within the application includes comments that describe the unit. For example, the comments may generally describe the classes, methods and objects within a unit of the source code as well as the inputs and outputs expected during that unit's execution. In conjunction with the API, these unit comments may guide developers as they write compatible applications or expand the application.","However, an API may be difficult and time-consuming to write. As the complexity of the source code grows, an API describing the source code will also become more complex. Numerous systems may automatically generate APIs and other documentation in a common format (e.g., HTML) directly from the API's source code. For example, commercial tools like Javadoc (\u201cJDoc\u201d) from Oracle Corporation, or open source tools such as JSDoc and Doxygen parse the source code and source code comments into hyperlinked HTML API documents.","In addition to the API, testing is often necessary to develop effective and efficient computer code. The process of testing code typically includes testing various units of the application in isolation from the other units of the application as the programmer writes the source code for the application. Testing normally involves writing a short application that utilizes the code that is the subject of the test. This short application includes a rigorous contract that the test subject source code must satisfy when it is executed. If the test is written correctly and the contract is satisfied, then the developer is more confident that the test subject source code will perform correctly for any other user or developer. Testing usually proceeds in isolation for each unit of the source code. If all units of an application pass the unit tests in isolation, then the application as a whole will execute as desired when all units are included.","While several tools exist to automatically write an API for a finished application, unit tests are written by the developer in the same manner as the source code, often while the source code for the unit is written, or at some time after the source code is finished. As an application increases in complexity, the number of unit tests increases. Because developers must write each unit test in the same manner as the source code, unit testing becomes a tedious and complex process for even the simplest of applications. Understanding whether testing for complex applications that include many testable units is successful or complete can also be confusing and time consuming.","A unit test generation tool may automatically generate unit tests for source code based on the API and comments within the source code. The unit test generation tool may shorten and improve the normally tedious process of unit testing. For each Method and Class in an API, a developer may write a description and example directly into the source code comment blocks. These comment blocks may be parsed and tokenized by a documentation generation tool or the unit test generation tool itself to create HTML (or any other format) help files. The unit test generation tool may then automatically generate unit tests and unit test stubs for an entire API.","In one embodiment, the unit test generation tool may read the source code files for an application and pull out information about each method and class to build a data structure for the application and its API that includes tokens for each method and class. The data structure may describe the source code methods and acceptable method parameters, and any blocks of example usage code that have been embedded into the source code comment blocks. The unit test generation tool may then provide test stubs that include a template of the typical code that a complete unit test suite normally includes. This template may be read into memory and parts of the template may be replaced with the tokens for the methods and classes. The unit test generation tool may then output a set of new files containing unit tests that match every example in the source code comments as well as common unit test stubs that provide a starting point for developers as they fully unit test the end API.","In one embodiment, a computer-implemented method may generate unit tests for source code, The method may receive a source code file including a comments section, the comments section including a keyword identifying a unit description. The method may also read the unit description from the source code file, wherein the unit description follows the keyword, and copy at least a portion of the unit description to a unit test stub. The unit test stub may include a declaration of a testing routine and parameters accepted by the testing routine, the parameters including the unit description.","In a further embodiment, a tangible computer-readable medium may store instructions that, when executed by a processor, cause the processor to receive a source code file including a comments section, the comments section including a keyword identifying a unit description, wherein the unit description corresponds to input and output parameters of a source code unit and the unit description follows the keyword in the source code file. The instructions may also cause the processor to serialize the source code file, parse the serialized source code file to identify the keyword, and write at least a portion of the unit description following the keyword to a unit test stub. The unit test stub may also include a declaration of a testing routine and the unit description written to the unit test stub.","Another embodiment may include a computer system for generating unit tests. The system may comprise several modules. A source code database interface module may be configured to store in a database a plurality of source code files. Each file may include a keyword identifying a unit description, wherein the unit description corresponds to input and output parameters of a source code unit and the unit description follows the keyword in the source code file. A unit test generator module may be configured to read a unit description, to determine a function type corresponding to the unit description, and to copy the unit description to a unit test stub corresponding to the function type. A unit test suite may be configured to store a plurality of unit test stubs corresponding to each source code unit and to receive additional code to transform each unit test stub into a unit test corresponding to a source code unit. Also, a unit test harness may be configured to execute the plurality of unit tests and to provide a test result indication for each unit test.","Another embodiment may include a computer-implemented method for generating unit tests for source code. The method may receive a source code file including a keyword identifying a unit description, wherein the unit description corresponds to input and output parameters of a source code unit and the unit description follows the keyword in the source code file. The method may also parse the unit description to determine a source code function type corresponding to the unit description and copying the unit description to a unit test stub corresponding to the function type. Also, the method may receive additional code to transform each unit test stub into a unit test corresponding to the source code unit, execute the unit test, and generate a test result indication for each unit test.","Another embodiment may include a tangible computer-readable medium storing instructions that when executed by a processor cause the processor to perform various tasks. For example, the instructions may cause the processor to receive a source code file including a keyword identifying a unit description, wherein the unit description corresponds to input and output parameters of a source code unit and the unit description follows the keyword in the source code file. The instructions may also cause the processor to parse the unit description to determine a source code function type corresponding to the unit description and copy the unit description to a unit test stub corresponding to the function type. Additionally, the instructions may cause the processor to receive additional code to transform each unit test stub into a unit test corresponding to the source code unit, execute the unit test, and generate a test result indication for each unit test.","The features and advantages described in this summary and the following detailed description are not all-inclusive. Many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings, specification, and claims hereof.","The figures depict a preferred embodiment of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100"]},"A developer  may write source code  for a computer program using a general text editing program (e.g., notepad, WordPad\u00ae, etc.), an integrated development environment (IDE) (e.g., NetBeans\u00ae, CodeLite, JBuilder\u00ae, etc.), or other program executing on a computing device. The developer  may store the source code  within a local or remote database  as a text file or type of file. In some embodiments, the database  is a component of a server  or other computing device including both a processor and memory .  illustrates one example of a portion of source code , in particular, a comments section  of a source code file . A comments section  includes text that is ignored by source code compilers and interpreters, but may provide useful information to developers who edit, optimize, or use the source code . The information in the comments portions  may make the source code  easier to understand for developers  to write other code that is compatible with the source code . Each programming language's specification includes syntax and rules for using comments so that the text is ignored during compilation or interpretation. For example, both Java\u00ae and C-based languages use a double forward slash (\u201c\/\/\u201d) or a forward slash and asterisk combination (\u201c\/***\/\u201d) notation as illustrated by . As a Java or C compiler or interpreter parses a line of code beginning these particular characters, the compiler or interpreter will ignore that line of code.","In some embodiments, the comments section  includes and example section  within the comments section. The example section  may include a unit description  (e.g., a method description, a member variable description, or other text) that may be useful in an API corresponding to the source code file. For example, the unit description  may include a portion of code that, if executed, would provide expected results from a function, method, class, or other unit of code from the source code file. As illustrated by , the unit description  provides code to determine an expected result from the \u201cVector3d.linear_combination\u201d method . The comments section may also include a beginning keyword and an ending keyword as well as additional text portions further describing the method  and the unit description  of the example section  (e.g., additional comments  and ). Each unit description  may also correspond to a unit of source code (i.e., the smallest testable portion of the application encoded in the source code file ).","Returning to , the a unit test generation system  may also include several components or software modules and instructions stored in a computer-readable storage memory and executed on a processor (e.g., and or similar structures within a local computer user by the developer ) to generate unit tests using one or more comments sections  within a source code file . In some embodiments, a module or component organizes and formats the source code, and generates unit test stubs (called the unit test generator module  or \u201courdoc\u201d module ). In some embodiments, the ourdoc module  includes one or more instructions stored in a computer-readable storage memory and executed on a processor to access the database  or other data storage and retrieve a source code file  that includes one or more comments portions . Alternatively, the ourdoc module  receives a source code file  or a portion of the source code file  including one or more comments sections . The ourdoc module  may also include one or more instructions stored in a computer-readable storage memory and executed on a processor to convert the source code file  into another format for analysis. For example, the ourdoc module  may convert the file  into a stream of text or other data (e.g., serialize the file ), search through the stream of text, and either break it up into useful chunks of information (i.e., tokens) or reformat the file  for analysis.","The ourdoc module  may also include one or more instructions stored in a computer-readable storage memory and executed on a processor to identify a comment section  within the source code file  and output one or more files using the comment section  as input. In some embodiments, the ourdoc module  identifies notation within the source code file  that indicates a comment section . For example, the ourdoc module  may identify any line of text within the source code file  beginning with \u201c\/\/\u201d or \u201c\/* . . . *\/\u201d notation as a portion of a comment section . Once the ourdoc module  identifies comment notation, then the text within the comment section  may be further analyzed. For example, the ourdoc module  may include one or more instructions stored in a computer-readable storage memory and executed on a processor to identify a particular character or token within the comments section that may be passed as an argument to another instruction stored in a computer-readable storage memory and executed on a processor.","The comments section  may be formatted in an industry standard that permits developers to quickly write comments so that they may be used to create public documentation. In some embodiments, the comments section  is written in the \u201cDoxygen\u201d format. For example, a particular character (e.g., an \u201c@\u201d character, a \u201c%\u201d character, etc.) and name combination (i.e., a command or keyword) within the comments section  may indicate that text following that character has particular meaning to create public documentation, unit tests, etc. One example of a command or keyword  includes \u201c@version\u201d and text following this keyword may include \u201cSketchUp 6.0\u201d to indicate that the comments section  corresponds to version six of the SketchUp application. Following the Doxygen format, the ourdoc module  may include one or more instructions stored in a computer-readable storage memory and executed on a processor to create public documentation. In some embodiments, the public documentation is an HTML, XML, or other type of uniformly-formatted document that describes the classes, class hierarchy, class members, etc., that correspond to the various classes listed in the comments section .","The ourdoc module  may also extend the Doxygen format to include keywords that are used to create unit tests. For example, the ourdoc module  may define various commands and keywords to extend Doxygen functions. In one embodiment, a \u201c@par Example\u201d ourdoc command  may be read and used as an input to a method of the ourdoc module  to indicate the beginning of comments that describe an ideal execution of the source code. Further, comments following the \u201c@par Example\u201d keyword may include Doxygen keywords and commands that may be read and used as an input to other methods of the ourdoc module . For example, \u201c@code\u201d and \u201c@endcode\u201d Doxygen commands may be used by both Doxygen and ourdoc module  methods to produce different results. As used by Doxygen, a block of comments beginning with a \u201c@code\u201d  command and ending with a \u201c@endcode\u201d command  may produce a public documentation file wherein Doxygen interprets the comments within the example section  as code. Within the Doxygen-produced public documentation file, the names of the classes and members that are documented within the unit description  will be replaced by references to the documentation for those particular classes and members.","The ourdoc module  may include one or more instructions stored in a computer-readable storage memory and executed on a processor to use the \u201c@code\u201d and \u201c@endcode\u201d commands as a signal to create unit tests for the classes and members described in the comments that follow the \u201c@code\u201d command and are before the \u201c@endcode\u201d command (i.e., the unit description ). With further reference to , the ourdoc module  may include instructions to generate unit test stubs  from the example section and store the stubs within a unit test suite . In some embodiments, a unit test stub  consists of a declaration of a testing routine  and input and output parameters accepted by the testing routine . The unit test stubs  may be used as placeholders for routines that need to be developed to fully test the source code. For example, the unit test stubs  may include only enough code to allow the stubs  to be compiled and linked with the rest of the unit test suite . Additional functionality may be added to the stubs  by adding more code. In some embodiments, the ourdoc module  copies the unit description  into a unit test stub , wherein the parameters accepted by the testing routine of the stub  include at least the unit description . Further, a developer  or another module or routine may add more code to the stubs  to augment the unit test.","The unit test suite  may include all of the unit tests for an application. The ourdoc module  may generate a variety of unit tests for the unit test suite  from each unit description  such that the tests represent the various categories of common coding problems and the tests cover a high degree of execution results for the source code file . For example, the ourdoc module  may create unit test stubs for trivial source code cases, but also for other categories of method and member inputs such as boundaries, bad input types, random inputs, negative tests, etc.","The ourdoc module  may also analyze the unit description  to determine to what type of function the unit description  corresponds. For example, the unit description  may correspond to parameters of a \u201csetter\u201d function (i.e., source code expressions that establish a value such as \u201cvar=2\u201d), a \u201cgetter\u201d function (i.e., source code expressions that retrieve an established value such as \u201creturn var\u201d), or other type of function in the source code for which a unit test is desired. After determining what type of function corresponds to the unit description , the ourdoc module  may include one or more instructions stored in a computer-readable storage memory and executed on a processor to generate a unit test stub  corresponding to the function type (i.e., a setter unit test, a getter unit test, etc.). For example, when the ourdoc module  serializes or tokenizes and parses the unit description , the ourdoc module  may identify a \u201c=\u201d symbol corresponding to a \u201csetter\u201d function. Once identified as a setter function, the ourdoc module  may generate setter unit tests. When the ourdoc module  identifies the word \u201creturn\u201d, which corresponds to a \u201cgetter\u201d function, the module  may generate getter unit tests. Of course, the ourdoc module  may include other instructions to identify and generate other types of unit tests depending on particular symbols, words, commands, keywords, etc., the module  identifies within the unit description .","Regardless of the type of unit tests the module  generates, each set of unit tests may include at least a trivial test of the unit description  that is generated from the comment section  and other categories of unit tests. With reference to , the test stubs  may include a trivial unit test , a boundary or \u201cedge case\u201d unit test , a bad parameters unit test , and other unit tests (e.g., random inputs, negative tests, etc.). Depending on the type of unit tests identified (e.g., setter or getter unit tests, etc.), the test stubs  may include different instructions corresponding to the type of unit in the unit description . For example, if the ourdoc module  identifies the unit description  as a \u201csetter\u201d, then instructions of the module  may generate a trivial unit test  having commands corresponding to the \u201csetter\u201d instructions of the comments section . The commands may correspond to typical \u201craise\u201d  and \u201cassert\u201d  commands to test the setter method from the unit description  of the comments section . For example, the assert command  for the setter method from the source code file  corresponding to the unit description  tests if the \u201cexpected\u201d value and the \u201cresult\u201d value of the \u201cnew_vector\u201d variable are equal. If the expected and actual values are not equal, then the unit test fails. Further, the assert command for a getter method from a unit description may test if the returned parameter is the same type as the expected parameter. If the expected and returned types are not equal, then the unit test fails. In any case, if the expected and actual values of a tested variable (i.e., the \u201cnew_vector\u201d variable illustrated in  or any other variable) are equal, then the unit test succeeds.","In some embodiments, the ourdoc module  may automatically add a test stub  to check the ability of the function to generate an expected type of error when executed. For example, when the ourdoc module  analyzes the unit description  and identifies it as a getter function, the test stub  for a \u201cget_coordinates\u201d function may apply an invalid coordinate point as an input to the function to ensure that an \u201cException::ArgumentError\u201d would be received, as expected. In contrast, when the ourdoc module  identifies a function as a setter, different kind of errors may be expected depending on what the function sets. For Example, an \u201cException::TypeError\u201d error may be expected from a \u201cset_coordinates\u201d function that, when executed, receives a \u201cstring\u201d type input when the function only accepts an \u201cinteger\u201d type input.","In other embodiments, the ourdoc module  may identify setter or getter functions that return Boolean values and generate an appropriate test stub . For example, the ourdoc module  may identify a Boolean getter function within the unit description  with a particular character (e.g., a \u2018?\u2019 character such as \u201cMyClass.is_visible?\u201d). The ourdoc module  may then output a test stub  for the Boolean getter to ensure the function result is not null (i.e., a stub \u201cresult_is_not_null( )\u201d) and that the result is one of \u201ctrue\u201d or \u201cfalse\u201d (i.e., a stub \u201cresult_is_true_or_false( )\u201d). Of course, the ourdoc module  may include instructions to generate other types of unit tests that are specific to the function type, such as testing that a parameter was correctly set by a setter function or that a getter function correctly retrieves the expected type of parameter, random inputs, negative tests, etc.","As indicated in , each of the unit test stubs  includes comments within a raise command , , . These comments may be automatically generated with the unit test stubs . In some embodiments, the comments within the raise commands , ,  may indicate to a developer that further action should be taken to complete each unit test , ,  so that the unit test stubs  may be completed so that each unit of the source code file  is properly tested and the unit test stubs  form complete unit tests. For example, a developer  may add code to each unit test stub  so that the stub  represents a complete unit test corresponding to a unit of the source code file . Of course, another module (e.g., the ourdoc module ) may also automatically add code to each unit test stub  and transform each stub  into a complete unit test corresponding to a unit of the source code file . Each unit may be properly tested when it passes its unit tests including at least a unit test corresponding to its description , boundaries unit tests, and bad input unit tests. These comments may be deleted by the developer to indicate when the developer has completed a review of the unit tests , , . In further embodiments, the developer may edit (i.e., add, delete, or change) the text of the unit tests , , and  so that each unit is properly tested.","Again referring to , a module  may test each of the unit tests , ,  within the unit test suite . The module or \u201ctest harness\u201d  may determine whether the unit tests have been properly completed for each unit identified within the corresponding source code file . In some embodiments, a module entitled \u201cTestUp\u201d may serve as the unit test harness . The TestUp module may be external to the application represented by the source code . In further embodiments, the TestUp module  may simulate services or functions that are not available in the test environment. For example, where the application represented by the source code  is an internet-deployed application requiring one or more web servers, the TestUp module  may include functions or routines that simulate web server communication such that the units of the source code  may be properly tested. Likewise, the TestUp module  may generally provide an environment in which all units of the source code  are properly tested. In some embodiments, the TestUp module  runs each unit test as it is created within the unit test suite  to determine how much of the source code file  is properly tested. The TestUp module  may provide a test result indication (e.g., a pass, fail, or follow up indication)  for each unit test within the unit test suite .","After testing each completed unit test  within the unit test suite , the ourdoc module , the TestUp module , a reporting module , or another module may generate unit test coverage reports and . The reports and may provide an indication of how much source code file  testing is complete and may also modify the unit test stubs  to indicate whether a particular unit test passed, failed, or needs further development. For example, if a unit test passes after being executed by the TestUp module , then the text corresponding to that passed test  within the unit test suite  may be highlighted in green or another indication. Likewise, if a unit test requires follow up  after being executed by the TestUp module , then the text corresponding to that test within the unit test suite  may be highlighted in yellow or another indication. Also, if a unit test fails  after being executed by the TestUp module , then the text corresponding to that failed test within the unit test suite  may be highlighted in red or another indication. Text or another indication may also be inserted into the unit tests  after execution by the TestUp module  indicating pass , follow up  or fail .","The unit test coverage reports and may also include an indication of how thoroughly and effectively the unit test suite  tests the units identified within the source code file . In some embodiments, the reports and may be an output of the TestUp module  or the ourdoc module , or a reporting module . The reports and may be sent to the developer  and include several indications about the source code  and the unit testing process. For example, the unit test reports and may include an indication of whether each unit test (e.g., unit tests , , ) properly tests its corresponding source code unit (the parameters of which are described in the comments section  of the source code file ), an indication of how many of the total number of unit tests described within the comments sections  of the source code file  are properly tested, and a coverage measure indicating how much of the testing process is complete, to name only a few of the indications that may be available in the reports and ","In some embodiments, a reporting module  may extract a list of source code units (e.g., the names of the classes and methods) from the comments sections  of the source code file  and correlate that list with the number of unit tests that passed when executed by the TestUp module  to determine a measure of testing coverage  For example, the reporting module  may parse the comments sections  of a source code file  to extract each method name  or class name, and copy each extracted method or class name to a list. The reporting module  may then compare the list of methods and classes against the method and classes tested by the TestUp module . The TestUp module  may create a list of classes and methods it tests as the tests are run and provide that list to the reporting module . The reporting module may then compare the lists to the indication of whether each particular unit test passed to generate a measure of testing coverage  for each class. The coverage measure  may generally describe how many units within a class are covered by unit tests that pass or succeed. For example, a report indicating sixty-eight percent test coverage may specify that, of a total of one hundred functions within a class, sixty-eight of those functions are tested properly and pass those tests (i.e., the unit test suite  includes unit tests that pass for sixty eight of one hundred total units within the class).","With reference to , the unit test generator system  described herein may be employed in a method  () to generate unit tests for a source code file. The method  may include one or more functions or routines in the form of computer-executable instructions that are stored in a tangible computer-readable medium and executed using a processor of a computing device (e.g., a computing device being used or accessed by the developer ). The routines may be included as part of any of the modules described in relation to , or as part of a module that is external to the system illustrated by .","At function , the system  may execute an instruction to receive a source code file . As described above, the source code file  may include a text file of computer code including one or more comments sections . The source code file may be created by the developer  using a general text editing program (e.g., notepad, WordPad\u00ae, etc.), an integrated development environment (IDE) (e.g., NetBeans\u00ae, CodeLite, JBuilder\u00ae, etc.), or other program executing on a computing device. The developer  may store the source code  within the local or remote database  as a text file or type of file, or the system  may receive the source code file  from an external source. The comments section  of the source code file  may include one or more unit descriptions  and be stored either internally or externally to the system .","At function , the system  may execute an instruction to retrieve a source code file  and convert the file  into another format for analysis by the system . For example, the function  may convert the file  into a searchable stream of text or other data, break the file  up into useful chunks of information (i.e., \u201ctokenize\u201d the source code file), or otherwise reformat the file .","At function , the system may execute an instruction to identify a comment section  and unit description  within the source code file . For example, using a data stream created at function , the function  may identify certain text characters that indicate a portion of the source code file  that includes the comments section , as described above. The unit description  may be identified within the comments section  by one or more keywords identified within the data stream or tokenized version of the source code file .","At function , the system  may execute an instruction corresponding to a command or keyword (e.g., commands  and ) within the comments section . In some embodiments, the system  may use the identified command or keyword as a method input to perform another function. For example, if the function  identifies a \u201c@code\u201d command , then the function  may read the text following that command until the function  encounters another command to signal the function  to stop reading the text (e.g., the \u201c@endcode\u201d command). The \u201ccode\u201d command  may also cause the function  to serialize or tokenize the text after the command  until the \u201c@endcode\u201d command  is read. The function  may also encounter other commands after an \u201c@code\u201d command. Other commands may signal the function  to perform other tasks such that the other commands may be nested between several \u201ccode\u201d and \u201c@endcode\u201d commands. In some embodiments, the text between the \u201ccode\u201d and \u201c@endcode\u201d commands includes the unit description . The unit description  may include a method description, a member variable description, a function, or other text that corresponds to the expected input and output of a unit of code (e.g., the \u201cVector3d.linear_combination\u201d method ) from the source code file .","At function , the system  may execute an instruction to identify a function type of the unit description  as read, serialized, or tokenized by the function  between the \u201c@code\u201d  and \u201c@endcode\u201d  commands. For example, if the function  identifies a \u201c=\u201d symbol within the unit description , the function  may identify the unit description  as a \u201csetter\u201d function. Further, if the function  serializes or tokenizes the unit description  and identifies the word \u201creturn\u201d, the function  may identify the unit description  as corresponding to a \u201cgetter\u201d function. Of course, the function  may identify other types of functions depending on particular symbols, words, commands, keywords, etc., the function  identifies within the unit description .","At function , the system  may execute an instruction to generate a unit test corresponding to the function type identified by function . In some embodiments, the function  generates a unit test stub  that incorporates text from the comments section . For example, the unit test stub  may include a portion of the code from the unit description . The function  may generate other code for the stub  as well, such as raise, assert, or other code that corresponds to the type of function identified by function . If the function  identifies the unit description  as a \u201csetter\u201d, then function  may generate a unit test  having commands corresponding to the \u201csetter\u201d instructions of the comments section . The function  may generate a plurality of unit tests or unit test stubs  corresponding to the typically encountered problems with units of the source code file  such as input boundary tests, bad input type tests, random input tests, negative tests, etc.","At function , the system  may execute an instruction to test each of the unit tests that were generated by function . In some embodiments, a test harness such as the TestUp module  may run each unit test within the unit test suite  to determine how much of the source code file  is properly tested. The function  may provide a pass, fail, or follow up indication for each unit test within the unit test suite .","At function , the system  may execute an instruction to generate a unit test coverage reports and . As illustrated by and , the reports and may include an indication of how much of the testing for the source code file  is complete and successful. In some embodiments, the function  modifies the appearance of the code within the unit test suite  such that a developer  or another module may easily determine if a unit test is complete. For example, if a unit test passes, requires follow up, or fails after being executed by the TestUp module , then the text corresponding to that test within the unit test suite  may be highlighted in green, yellow, red or another indication. The unit test coverage reports and may also include an indication of how thoroughly and effectively the unit test suite  tests the units identified within the source code file . For example, a unit test coverage report () may include a summary section  as well as a summary of each unit's testing completion and success by a color or other indication of pass, fail, or follow up needed (e.g., green, red, and yellow, respectively). Further, a unit test report () may include an indication of whether each unit test (e.g., unit tests , , ) properly tests its corresponding unit  (i.e., the comments section  of the source code file ), an indication of how many of the total number of unit tests described within the comments sections  of the source code file  are properly tested , a number that are not properly tested , and a coverage measure (for each unit  or the entire application ) indicating how much of the testing process is complete, to name only a few of the indications that may be available in the report .","In some embodiments, the reporting module  parses the comments sections  of a source code file  to extract each method name  or class name, and copies each extracted method or class name to a list. The reporting module  may then compare the list of methods and classes against the method and classes tested by the TestUp module . The reporting module  may then receive a list of classes and methods that were tested by the TestUp module . The reporting module  may then compare the lists to the indication of whether each particular unit test passed to generate a measure of testing coverage  for each class. As described herein, the coverage measure  may generally describe how many units within a class are covered by unit tests that pass or succeed. Further, the report  may include a coverage measure of how many units within a class are covered by unit tests that pass.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 6","FIG. 1","FIG. 5"],"b":["10","100","10","100","10","100"]},"As shown in , the computer system P includes a processor P that is coupled to an interconnection bus P. The processor P includes a register set or register space P, which is depicted in  as being entirely on-chip, but which could alternatively be located entirely or partially off-chip and directly coupled to the processor P via dedicated electrical connections and\/or via the interconnection bus P. The processor P may be any suitable processor, processing unit or microprocessor. Although not shown in , the system P may be a multi-processor system and, thus, may include one or more additional processors that are identical or similar to the processor P and that are communicatively coupled to the interconnection bus P.","The processor P of  is coupled to a chipset P, which includes a memory controller P and a peripheral input\/output (I\/O) controller P. As is well known, a chipset typically provides I\/O and memory management functions as well as a plurality of general purpose and\/or special purpose registers, timers, etc. that are accessible or used by one or more processors coupled to the chipset P. The memory controller P performs functions that enable the processor P (or processors if there are multiple processors) to access a system memory P and a mass storage memory P.","The system memory P may include any desired type of volatile and\/or non-volatile memory such as, for example, static random access memory (SRAM), dynamic random access memory (DRAM), flash memory, read-only memory (ROM), etc. The mass storage memory P may include any desired type of mass storage device. For example, if the example computer system P is used to implement the unit test generation system  (), the mass storage memory P may include a hard disk drive, an optical drive, a tape storage device, a solid-state memory (e.g., a flash memory, a RAM memory, etc.), a magnetic memory (e.g., a hard drive), or any other memory suitable for mass storage. As used herein, the terms \u201cmodule\u201d and \u201croutine\u201d refer to computer program logic used to provide the specified functionality. Thus, a module or a routine can be implemented in hardware, firmware, and\/or software. In one embodiment, program modules and routines are stored in mass storage memory P, loaded into system memory P, and executed by a processor P or can be provided from computer program products that are stored in tangible computer-readable storage mediums (e.g. RAM, hard disk, optical\/magnetic media, etc.).","The peripheral I\/O controller P performs functions that enable the processor P to communicate with peripheral input\/output (I\/O) devices P and P and a network interface P via a peripheral I\/O bus P. The I\/O devices P and P may be any desired type of I\/O device such as, for example, a keyboard, a display (e.g., a liquid crystal display (LCD), a cathode ray tube (CRT) display, etc.), a navigation device (e.g., a mouse, a trackball, a capacitive touch pad, a joystick, etc.), etc. The network interface P may be, for example, an Ethernet device, an asynchronous transfer mode (ATM) device, an 802.11 device, a DSL modem, a cable modem, a cellular modem, etc. that enables the computer system P to communicate with another computer system.","While the memory controller P and the I\/O controller P are depicted in  as separate functional blocks within the chipset P, the functions performed by these blocks may be integrated within a single semiconductor circuit or may be implemented using two or more separate integrated circuits.","Throughout this specification, plural instances may implement components, operations, or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations, one or more of the individual operations may be performed concurrently, and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the subject matter herein.","Certain embodiments are described herein as including logic or a number of components, modules, functions, or mechanisms. Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal) or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., a standalone, client or server computer system) or one or more hardware modules of a computer system (e.g., a processor or a group of processors) may be configured by software (e.g., an application or application portion) as a hardware module that operates to perform certain operations as described herein.","In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software) may be driven by cost and time considerations.","The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.","Similarly, the methods described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or processors or processor-implemented hardware modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors may be distributed across a number of locations.","The one or more processors may also operate to support performance of the relevant operations in a \u201ccloud computing\u201d environment or as a \u201csoftware as a service\u201d (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., application program interfaces (APIs).)","The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the one or more processors or processor-implemented modules may be located in a single geographic location (e.g., within a home environment, an office environment, or a server farm). In other example embodiments, the one or more processors or processor-implemented modules may be distributed across a number of geographic locations.","Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory (e.g., a computer memory). These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein, an \u201calgorithm\u201d is a self-consistent sequence of operations or similar processing leading to a desired result. In this context, algorithms and operations involve physical manipulation of physical quantities. Typically, but not necessarily, such quantities may take the form of electrical, magnetic, or optical signals capable of being stored, accessed, transferred, combined, compared, or otherwise manipulated by a machine. It is convenient at times, principally for reasons of common usage, to refer to such signals using words such as \u201cdata,\u201d \u201ccode,\u201d \u201ccontent,\u201d \u201cbits,\u201d \u201cvalues,\u201d \u201celements,\u201d \u201csymbols,\u201d \u201ccharacters,\u201d \u201cterms,\u201d \u201cnumbers,\u201d \u201cnumerals,\u201d or the like. These words, however, are merely convenient labels and are to be associated with appropriate physical quantities.","Unless specifically stated otherwise, discussions herein using words such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining,\u201d \u201cpresenting,\u201d \u201cdisplaying,\u201d or the like may refer to actions or processes of a machine (e.g., a computer) that manipulates or transforms data represented as physical (e.g., electronic, magnetic, or optical) quantities within one or more memories (e.g., volatile memory, non-volatile memory, or a combination thereof), registers, or other machine components that receive, store, transmit, or display information.","As used herein any reference to \u201csome embodiments,\u201d \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d or \u201cin some embodiments\u201d in various places in the specification are not necessarily all referring to the same embodiment.","Some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. For example, some embodiments may be described using the term \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other. The embodiments are not limited in this context.","As used herein, the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes,\u201d \u201cincluding,\u201d \u201chas,\u201d \u201chaving\u201d or any other variation thereof, are intended to cover a non-exclusive inclusion. For example, a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus. Further, unless expressly stated to the contrary, \u201cor\u201d refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).","In addition, use of the \u201ca\u201d or \u201can\u201d are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the invention. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.","Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for generating unit tests from the documentation and comments portions of high-level computer code through the disclosed principles herein. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications, changes and variations, which will be apparent to those skilled in the art, may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4","i":"b "},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
