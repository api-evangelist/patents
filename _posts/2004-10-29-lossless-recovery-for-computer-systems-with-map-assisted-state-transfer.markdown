---
title: Lossless recovery for computer systems with map assisted state transfer
abstract: Described are systems and techniques for losslessly restarting subsystems in a distributed file system. By partitioning functionality and logging appropriately across the kernel and user-level boundaries on a client, the user-level subsystem may be made losslessly restartable. In particular, a map assisted state transfer may include receiving one or more state updates, marshaling one or more active data-structures into a marshaled shadow, applying the received state updates to the marshaled shadow and re-instantiating the active data-structures by unmarshaling the marshaled shadow.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07472129&OS=07472129&RS=07472129
owner: Microsoft Corporation
number: 07472129
owner_city: Redmond
owner_country: US
publication_date: 20041029
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED PATENT APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This patent application claims the benefit of U.S. Provisional Patent Application No. 60\/583,903, filed Jun. 29, 2004, entitled \u201cLossless Recovery for Computer System.\u201d","This invention pertains generally to computer systems and, more particularly, to recovery mechanisms for computer systems.","Distributed computer systems have become a popular response to an ever increasing demand for computing system resources. However, the increasing complexity of distributed computer systems has resulted in threats to their robustness and reliability such as resource depletion, Heisenbugs (system bugs that change behavior during debugging), deadlocks and other transient faults. Multiplying the number of servers or, more generally, server replicas (i.e., instances of a server executing simultaneously on multiple computers) provides helpful redundancy but it doesn't solve every robustness and reliability problem. In particular, recovery from component underperformance or outright failure in conventional distributed computer systems may not be possible without excessive disruption of computer system resource users and\/or may result in data loss.","Examples of conventional distributed computer systems include the \u201cUNIX\u201d Network Filesystem (NFS) and its variants, the \u201cGOOGLE\u201d File System (GFS), the Calypso file system, the Echo file system, the Harp file system, the Frangipani file system, the Pangaea file system, the Ivy file system and the Coda file system as described in Kistler et al., \u201cDisconnected Operation in the Coda File System,\u201d (SOSP), October 1991 and, more generally, in James J. Kistler, \u201cDisconnected Operation in a Distributed File System,\u201d Technical Report CMU-CS-93-156, Carnegie Mellon University, May 1993. For the purposes of this description, distributed computer system components may be categorized as playing a server role (server-side components) or a client role (client-side components). In practical systems, distributed computer system components in a client role may be further categorized as operating at a user-level or a kernel-level. This distinction is particularly relevant to failure recovery mechanisms because failure of kernel-level components is typically more disruptive than failure of user-level components. In addition, kernel-level components are typically required to comply with a different set of operational constraints than user-level components.","Some conventional distributed computer systems provide for lossless restartability of server-side components but not client-side components. Some client-side components may not be transparently restarted, for example, a kernel-level client component failure may require a computer reboot (e.g., computer operating system restart). Some conventional distributed computer systems fail to minimize the complexity of kernel-level client components. Some conventional distributed computer systems incorporate transparently restartable user-level client components but do not provide for lossless restart which may result in the loss of, for example, any computer system resource updates that occurred in the 30 seconds before component failure.","Some conventional distributed computer systems provide for transparent restartability of server-side components but lack broad spectrum fault tolerance that includes, for example, Byzantine fault tolerance as well as fail-stop fault tolerance, such as may be supported by replicated state machine (RSM) architectures. Furthermore, some conventional distributed computer systems fail to provide an effective solution to the problem of underperforming server-side components. In particular, some conventional distributed computer systems that utilize state-based updates (e.g., some systems incorporating server replicas) fail to enable efficient incremental state changes without resorting to, for example, low-level page-based solutions or idiosyncratic solutions applicable only to narrow cases.","This section presents a simplified summary of some embodiments of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some embodiments of the invention in a simplified form as a prelude to the more detailed description that is presented later.","In an embodiment of the invention, map assisted state transfer may be performed by receiving one or more state updates, marshaling one or more active data-structures into a marshaled shadow, destroying the active data-structures, applying the received state updates to the marshaled shadow and re-instantiating the active data-structures by unmarshaling the marshaled shadow. In an embodiment of the invention, a computer system component is configured to send one or more state update messages including one or more incremental state changes. A potentially different computer system component is configured to receive the state update messages and perform the map assisted state transfer.","In an embodiment of the invention, a data structure includes a marshaled shadow of active data-structures. The active data-structures may include one or more invariance relationships, and the marshaled shadow may be structured to support independence from invariance relationships between the shadows of the active data-structures. The marshaled shadow may be further structured to support the application of one or more incremental state updates to the shadows of the active data-structures, as well as re-instantiation of the active data-structures by unmarshaling of marshaled shadow.","Prior to proceeding with a description of the various embodiments of the invention, a description of a computer in which the various embodiments of the invention may be practiced is now provided. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, programs include routines, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. The term \u201cprogram\u201d as used herein may connote a single program module or multiple program modules acting in concert. The terms \u201ccomputer\u201d and \u201ccomputing device\u201d as used herein include any device that electronically executes one or more programs, such as personal computers (PCs), hand-held devices, multi-processor systems, microprocessor-based programmable consumer electronics, network PCs, minicomputers, tablet PCs, laptop computers, consumer appliances having a microprocessor or microcontroller, routers, gateways, hubs and the like. The invention may also be employed in distributed computing environments, where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, programs may be located in both local and remote memory storage devices.","Referring to , an example of a basic configuration for the computer  on which aspects of the invention described herein may be implemented is shown. In its most basic configuration, the computer  typically includes at least one processing unit  and memory . The processing unit  executes instructions to carry out tasks in accordance with various embodiments of the invention. In carrying out such tasks, the processing unit  may transmit electronic signals to other parts of the computer  and to devices outside of the computer  to cause some result. Depending on the exact configuration and type of the computer , the memory  may be volatile (such as RAM), non-volatile (such as ROM or flash memory) or some combination of the two. This most basic configuration is illustrated in  by dashed line .","The computer  may also have additional features\/functionality. For example, computer  may also include additional storage (removable  and\/or non-removable ) including, but not limited to, magnetic or optical disks or tape. Computer storage media includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information, including computer-executable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory, CD-ROM, digital versatile disk (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to stored the desired information and which can be accessed by the computer . Any such computer storage media may be part of computer .","The computer  preferably also contains communications connections  that allow the device to communicate with other devices such as remote computer(s) . A communication connection is an example of a communication medium. Communication media typically embody computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. By way of example, and not limitation, the term \u201ccommunication media\u201d includes wireless media such as acoustic, RF, infrared and other wireless media. The term \u201ccomputer-readable medium\u201d as used herein includes both computer storage media and communication media.","The computer  may also have input devices  such as a keyboard\/keypad, mouse, pen, voice input device, touch input device, etc. Output devices  such as a display, speakers, a printer, etc. may also be included. All these devices are well known in the art and need not be described at length here.","An example of a computer networking environment  suitable for incorporating an embodiment of the invention is described with reference to . The example computer networking environment  includes several computers  communicating with one another over a network , represented by a cloud. Network  may include many well-known components, such as routers, gateways, hubs, etc. and allows the computers  to communicate via wired and\/or wireless media. When interacting with one another over the network , one or more of the computers  may act as clients, servers or peers with respect to other computers . Accordingly, the various embodiments of the invention may be practiced on clients, servers, peers or combinations thereof, even though specific examples contained herein may not refer to all of these types of computers.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computing devices, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","In an embodiment of the invention, a recovery architecture for a distributed computer system allows various components and subsystems to be restarted without losing data. Losslessly restartable distributed computer system components may be employed as a robust mechanism for handling transient faults. In addition, organization into losslessly restartable components and subsystems may ease debugging and testing.","A computer system's client-side user-level subsystem may be losslessly restarted through a combination of database recovery techniques and judicious partitioning of client-side functionality. Resource-storage subsystems may be losslessly restarted through probabilistic replication and lazy recovery processes. In an embodiment of the invention, a resource service subsystem is implemented as a replicated state machine, wherein a replica may be losslessly restarted by transferring state from other replicas. This state transfer may be supported by a practical technique called map assisted state transfer (MAST) that allows a running entity in a distributed system to incorporate incremental state updates from remote entities. The MAST technique may be also utilized in a replicated system in which update logs are truncated, such as the Byzantine file system described in Castro et al., \u201cPractical Byzantine Fault Tolerance,\u201d (OSDI), February 1999, or in which state transfer is state-based rather than log-based, such as the Windows File System (WinFS) described in like named sections of the -and of the (\u00ae) Library dated October 2003.","For clarity and concreteness, examples in this description are generally directed to a particular distributed file system called FARSITE. However, embodiments of the invention are not so limited, as will be apparent to one of skill in the art. Only some features of the FARSITE file system are described below. For additional context and details of the FARSITE distributed file system pertinent to the present application see Adya et al., \u201cFARSITE: Federated, Available, and Reliable Storage for an Incompletely Trusted Environment,\u201d OSDI, December 2002.","In an embodiment of the invention, the FARSITE file system is a replicated file system that maintains metadata via state machine replication (e.g., Byzantine or Fail-Stop) and file data via simple replication. Each computer  () in the FARSITE file system may serve in multiple roles including: as a distributed file system client acting on behalf of local applications (i.e., applications located on a same computer ), as a distributed file system server replica in a server replication group, and as a distributed file system file host that maintains file copies on behalf of remote computers .","In an embodiment of the invention, the server subsystem is restartable in a lossless manner since it is a member of a state machine replication group; members of the group may be used to transfer the missing state to a recovering replica. The file host subsystem makes weak assumptions about the consistency between its state and that of the server groups; it uses best-effort replication and low-priority recovery processes to provide probabilistic guarantees for file replication. This strategy is called Tolerable Inconsistency and Lazy Recovery (TILR). The client portion of FARSITE consists of two subsystems, a kernel-level driver and a user-level daemon; the daemon can be restarted losslessly by recovering its state from other subsystems. This strategy is called Remotely Dependent Data Recovery (RDDR).","In contrast to conventional distributed file systems that utilize kernel-level drivers primarily for optimizing file data paths and as a read-only cache of metadata, in an embodiment of the invention, the driver not only caches metadata but also buffers metadata updates in an update log, acting as a staging agent for all modifications done on behalf of applications. These updates are logged by the driver and later sent in batches to the daemon. In an embodiment of the invention, in further contrast to conventional distributed file systems, by extending the write-buffer log across the kernel-user interface and storing appropriate recovery information in the driver and at the server, the user-level client subsystem may recover losslessly from even complete subsystem failure (i.e., subsystem crash requiring restart).","Transactional storage systems (e.g., relational databases) may be utilized for maintaining data structures on disk. However, to ensure that data consistency for more reliable, available, and secure subsystems (e.g., server and driver) does not depend on those with weaker properties (e.g., daemon), in an embodiment of the invention, distributed transactions are not utilized across these subsystems. This isolation has implications in terms of state communication between subsystems. On one hand, exposing a subsystem's uncommitted state to another subsystem complicates the recovery protocols. On the other hand, exposing only committed state across subsystems requires frequent disk I\/O, since a subsystem must commit before communicating with another subsystem. Selective exposure of committed and uncommitted state across various subsystems may keep common-case processing overheads low while also keeping the recovery algorithm robust and simple. For example, in an embodiment of the invention, the client driver exposes uncommitted state to the client daemon, the daemon exposes uncommitted state to the server and driver, but the server does not expose uncommitted state.","The distributed file system server may be implemented as a replicated state machine (RSM). In replicated state machines, if one replica's execution falls very far behind that of the other replicas, it may be brought up-to-date by transferring the updated state. However, incorporating incremental state changes in a server replica can be a challenging practical programming task. In an embodiment of the invention, map assisted state transfer (MAST) is utilized to incorporate incremental state changes in a server replica. Map assisted state transfer may be more widely applicable, require less programming effort and more readily facilitate correct and robust implementation than conventional incremental state change implementation techniques such as low-level page-based programming and implementing an idiosyncratic solution that copes with the application. When a recovering server replica utilizing map assisted state transfer receives state updates, the replica marshals its active data-structures into a \u201cmarshaled shadow\u201d (in volatile or non-volatile memory , ), destroys the active data-structures, incorporates the incoming state updates into the marshaled shadow, and unmarshals the modified shadow to re-instantiate the active data-structures. Under map assisted state transfer, the overhead for a programmer may be limited to writing marshaling and unmarshaling routines which may be independent of the data-structure's detailed operational semantics.","Each computer  () in the FARSITE distributed file system may take on one or more of three roles: a distributed file system client, a member of a distributed file system server directory group, and a distributed file system file host.  depicts an example of a high level computer systems architecture  in accordance with an embodiment of the invention. In , a computer  includes an application , a local file system driver , a FARSITE client driver  and a FARSITE client daemon . The local file system driver  and the FARSITE client driver  perform at a kernel-level of the computer . The application  and the FARSITE client daemon  perform at a user-level.","The application  utilizes the FARSITE client driver  to create, read, update and delete files located at FARSITE file hosts  and\/or on a local file system (i.e., volatile or non-volatile memory  of ) of the computer  accessible with the local file system driver . The FARSITE client driver  accesses the FARSITE file hosts  with the FARSITE client daemon . When the FARSITE client driver  needs the contents of a particular file (e.g., because the application  needs the contents of the file), the client driver  requests that the client daemon  fetch the contents of the file. The FARSITE client daemon  determines which FARSITE file host  by querying a FARSITE server directory group  that includes one or more FARSITE server replicas . A response to the query contains metadata indicating which FARSITE file host  has the contents of the particular file. The FARSITE server directory group monitors and controls the FARSITE file hosts . The FARSITE client driver  and the FARSITE client daemon  may be referred to as a FARSITE client or as the client subsystem. The FARSITE server replicas  in the FARSITE server directory group  may be referred to as a FARSITE server or as the server subsystem.","In an embodiment of the invention, the FARSITE client driver  implements a distributed file system interface for the application . Example responsibilities of the FARSITE client daemon  include managing distributed concurrency leases and hosted file metadata obtained from server replica . Distributed concurrency leases (\u201clease\u201d) and hosted file metadata (\u201cmetadata\u201d) are known in the art so only some of their features are highlighted here. Distributed concurrency leases are part of a mechanism used by the FARSITE distributed file system to coordinate concurrent operations on hosted file objects. For example, one FARSITE client may obtain a lease with a limited duration on a hosted file object for purposes of editing a hosted file thus preventing a second FARSITE client from deleting the hosted file during the period covered by the obtained lease. Examples of hosted file metadata include file names and identifiers, location specification, file size and format, created\/modified\/accessed times, file attributes such as read-only, hidden, encrypted, compressed and so forth, as well as file permissions and associated security information. File directories or folders may be handled as a type of file or as a file system object with distinct semantics.","In an embodiment of the invention, the server subsystem of FARSITE is implemented as a replicated state machine (RSM). RSM is known in the art so only some of its features are highlighted here. RSM is a general architecture for building fault-tolerant services, wherein multiple replicas of a service run on different machines, with a replication system orchestrating the replicas to act as a single, consistent service. In the RSM model, the service that is replicated acts as a state machine: the service maintains state explicitly, receives operation requests in a sequence, and from its current state and an operation request, deterministically computes a new state and a reply. When discussing the server subsystem, it may add clarity to distinguish between a \u201cserver replica\u201d and a \u201cserver group\u201d. When discussing another subsystem's interactions with a server group, it may be clearer to simply use the term \u201cserver.\u201d","In an embodiment of the invention, the server manages part of the tree of file system metadata but not the actual file contents. It grants leases and supplies metadata to clients, recalls leases from clients, and accepts operation logs from clients as described in more detail below. The server also coordinates file hosts  to control file data replication. The file hosts  store replicas of file data at the behest of servers. They also provides access to the file data when requested by a client. The client daemon , server, and file host  subsystems may reside in the same process. Although this implies that a crash of any subsystem takes down the others with it, this does not compromise the system because the design incorporates lossless fault tolerance and restartability.","In an embodiment of the invention, each subsystem is assumed to be running on an un-trusted computer. In this case the RSM may be implemented using a Byzantine-fault-tolerant protocol. The design easily adapts to an environment with untrusted clients but trusted servers, in which the RSM layer may be replaced with a fail-stop fault-tolerant protocol which tolerates the same number of failures with fewer replicas. Byzantine and fail-stop fault-tolerant protocols are known in the art and need not be described here in detail.","In an embodiment of the invention, the recovery strategy depends on atomicity provided by transactions, for example, with a conventional database or transactional local file system. While FARSITE does not manage on-disk layout, its various components do write data to disk at different times, and hence face a problem analogous to the conventional problem of torn writes. Instead of implementing a careful write-ordering strategy, in an embodiment of the invention, FARSITE relies on transactions for atomicity.","In an embodiment of the invention, FARSITE subsystems commit component-local transactions before exposing their effects to other components. Advantage may be taken of the fact that, in order to provide catastrophic resilience, the RSM protocol commits client requests. As a result, the server does not need to commit its transaction before replying to the client. To avoid unnecessary commits, FARSITE exposes uncommitted state across boundaries where frequent interactions are expected and where the state can be recovered losslessly from other subsystems. In an embodiment of the invention, before the client daemon commits its state, it ensures that the state is consistent. FARSITE avoids requiring remote (or other high-latency) operations to complete in order to reach such a consistent state. Achieving this performance goal requires careful declaration of commit-safepoints to ensure that the committed data is sensible to concurrent tasks.","In an embodiment of the invention, loose coupling enables improved system performance by varying the commit-granularity policy in different parts of the system. The driver, daemon, and server may commit transactions according to their own requirements and policies. The driver may commit once in a few seconds to prevent loss of application data or, for example, when the daemon asks it to. The client may commit at its own pace to reduce recovery time, to reduce jitter, and to help the driver garbage collect its on-disk logs. The server may commit its state transaction (different from the RSM toolkit transaction) very infrequently since a longer recovery time is masked by other replicas that keep the state machine advancing; since FARSITE decouples client and server performance, jitter is less of an issue as well.","In an embodiment of the invention, the FARSITE client driver  is made as small as possible with respect to the FARSITE client daemon . The FARSITE client driver  exports a FARSITE distributed file system application programming interface (API) and manages file and metadata caching to reduce the frequency of kernel-user boundary crossings. In an embodiment of the invention, minimizing driver code size is advantageous for at least two reasons. First, code size is correlated to debugging effort, and user-level code is easier to debug than kernel-level code. Second, code size tends to be correlated to latent bug counts, and a software bug that crashes a driver is likely to crash the computer operating system (OS) as well.","The second point above assumes that it is beneficial for a file-system crash not to take down the OS with it. However, this assumption comes with a caveat: Computer users commonly recognize that when their systems reboot, they might lose the last few seconds or minutes of data they have entered. On the other hand, users do not expect to lose data absent a crash of either the OS or the particular application they are using. However, placing critical code in a daemon opens the possibility that a latent bug might crash the daemon and lose file-system updates without crashing the OS. This may expose system users to a failure mode that is unfamiliar and likely disturbing.","To eliminate this failure mode, the FARSITE client is capable of lossless restart (i.e., no data is lost when the daemon restarts). Rather than achieving losslessness by committing every file-system update, which would be expensive (i.e., in terms of waiting for commits to complete), the client daemon recovers its state with the assistance of other subsystems, using a technique called Remotely Dependent Data Recovery (RDDR). In an embodiment of the invention, the client daemon recovery utilizes state maintained by the client driver and the server.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 4","FIG. 3","FIG. 4","FIG. 4","FIG. 3"],"b":["300","308","402","404","310","406","408","410","420","418","412","314","414","416"]},"The local file cache  contains actual file data managed by the FARSITE client driver . The operations log  includes file system operations such as file and directory create, read, update and delete operations as well as distributed concurrency lease operations such as lease obtain, release and expire. Each operations log  entry is associated with a log sequence number (LSN) incremented by the FARSITE client driver .","The local file state module  tracks state information for file data stored locally to the FARSITE client daemon  including file identifiers, version numbers and ranges of locally stored file blocks. The metadata state module  tracks metadata information for files of interest to the application  () regardless of their location including file identifiers, lease specifications including lease expiration times, file sizes, and cryptographic file hashes and checksums. The metadata state module  is a partial replica of the metadata state module  of the server . The operations log  of the client daemon is a periodically synchronized partial replica of the operations log  of the driver .","The client message log  of the server  includes entries for each message sent from each client . Each message corresponds to one or more FARSITE distributed file system operations such as file or directory updates or lease operations. Each message is associated with a state sequence number (SSN) maintained and incremented by the sending client . The client message log  includes, for each client message, the associated SSN, a range of LSNs associated with the operation(s), a range of file identifiers (relevant file IDs) affected by the operations(s) and possibly one or more file identifiers (invalid file IDs) made invalid by the operation(s).",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 5","FIG. 4","FIG. 6","FIG. 7","FIG. 8","FIG. 9"],"b":["404","308","408","310","410","310","414","412","406","310","416","412"]},"In an embodiment of the invention, these elements are used as follows during normal operation. When an application  () performs a file-system operation, the details of the operation are recorded in the driver's log . In addition, whenever the driver releases a lease, this release is recorded in the driver's log . Entries in this log  are indexed by a log sequence number (LSN) that is assigned by the driver . Periodically (e.g., every 30 seconds), this log  is written persistently to disk, so a driver or OS crash will never lose more than a bounded interval of file-system updates. These log  entries are pushed from the driver  up to the daemon  periodically (i.e., to the operations log ), and, to expedite the server's  processing of lease operations, they are also pushed whenever the driver  records a lease releases in the log .","When the daemon  receives a pushed log entry, the daemon  records the entry in its own log ; it applies the operation to its local metadata state ; and it records the LSN of the entry (called the applied LSN or ALSN ). In addition, when the daemon  releases a lease that it has not forwarded to the driver , it records this release in its log . Every so often, the daemon  atomically commits both its metadata state  and its log  persistently to disk, but this does not imply that the daemon  might lose updates that have not been committed, thanks to the RDDR recovery process. Periodically, or anytime that the log  contains a lease release, the daemon  sends a batch of log entries in a message  to the server . These messages  are sent serially, and each is indexed by a state sequence number (SSN)  that is maintained, incremented and assigned by the daemon .","The logs  maintained by a server  are characteristically different from the logs ,  maintained by clients. Each server replica  () maintains a separate client-recovery log  for each client with which it communicates. Each entry in the log  corresponds to a message  from the client , and the entries are thus indexed by SSN . Each entry includes a range of LSNs referred to in the message , a set of relevant file IDs, and a set of invalid file IDs. When the server  receives a message  from the client , in addition to performing whatever actions are called for by the message  (e.g., applying the operations to the metadata state ), the server  also does the following.","For operations except file deletions, the server  records as \u201crelevant\u201d any file IDs referred to by the operation. For example, for a file-creation operation, the server  records both the ID of the parent directory and the ID of the new file. For messages including file delete operations, the server  records as \u201cinvalid\u201d the ID of the file being deleted, because the file's metadata will not be valid after the file is deleted. For lease requests, the server  records as relevant the file ID whose lease is being granted. For lease releases, the server  records as invalid the file ID whose lease is being released, because data regarding this file ID will not be valid once its lease is released. The use of the relevant and invalid file ID sets is described in more detail below.","The system garbage collects logs ,  and  as follows. The client driver  truncates its log  when the daemon  performs a commit. The driver  discards log  entries with LSNs less than or equal to the daemon's  committed LSN. The client daemon  truncates its log  when the server  acknowledges a message  from the client . The daemon  discards log  entries with LSNs that are referenced in the acknowledged message . The server  truncates its log  when it receives a message  from the client. Each client message  explicitly indicates the highest SSN that the daemon  has persisted in a commit, and the server  truncates log  records whose SSN is less than or equal to this daemon-persisted SSN.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Driver log",{},{},{},"4","5","6","7"]},{"entry":["Driver log (persisted)",{},{},{},"4","5","6","7"]},{"entry":"Daemon log"},{"entry":["Daemon log (persisted)","1","2","3"]},{"entry":["Server log","1","2","3","4","5"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"char"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Daemon SSN","102"]},{"entry":[{},"Daemon persistent SSN","100"]},{"entry":[{},"Daemon ALSN","5"]},{"entry":[{},"Daemon persistent ALSN","3"]},{"entry":[{},"Server SSN","102"]},{"entry":[{},"Server ALSN","5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The above tables show an example use of the various logs ,  and  and values for client recovery. In this example, operations 1-3 were submitted to the driver , pushed to the daemon , committed by the daemon , and sent to the server  in message  with SSN set to 101. Then, operations 4-7 were submitted to the driver  and committed. Of these, operations 4 and 5 were pushed to the daemon  and sent to the server  in message  with SSN set to 102.","The client driver  uses a transactional store for its persistent data, and it commits its log  in a single transaction. As a result, in an embodiment of the invention, when the driver  restarts, its data is in an internally consistent state and no special recovery procedure is needed. Because the driver  commits its state periodically, the committed state has a bounded age, so no more than a bounded interval of file-system updates will be lost if the driver  restarts. This guarantee is known in the art as bounded persistence.","In supporting driver  restartability, dependent commits may become an issue. When the daemon  receives state from the driver , the daemon's  commit of that state becomes dependent on the driver's  commit, so the daemon  should not commit the state before the driver  does. Similarly, when the daemon  sends state to the server , the server's  commit becomes transitively dependent on the driver's  commit. Since the server  immediately commits every update it receives, the latter constraint implies that the daemon  should not send the server  any state that the driver  has not committed. Similar constraints do not apply to state originating from the daemon , because the daemon  can recover state from the recipients, as described below.","For embodiments in which no transactional store is available in kernel mode, the daemon  may provide the driver  with a proxy to a user-mode database. This would keep the driver's log  consistent, but it would lose the atomicity of log updates and file-data modifications that the transactional store provides. A partially work around this problem may be having the driver  commit a \u201cpotentially dirty file\u201d log record before writing to a file then, during recovery, potentially dirty files may be checked for consistency with the log , and log corrections can be made post hoc. However, this is only a partial solution because the log  contains an authenticated secure hash of the file contents, which is used to guarantee that a computer  () that is compromised after a crash cannot forge file contents. This property would be lost without atomicity of file content and log updates.","When the client daemon  restarts, its persistent state either does or does not lag the state of the server . These two cases are described separately for clarity, although, in an embodiment of the invention, a recovery code need not explicitly distinguish between the cases.","After the client daemon  restarts, it recovers with the help of both the server  and the client driver . The client daemon  reads its persistent state from the local disk, thereby retrieving consistent but slightly stale state. In the example, if the daemon  were to restart at this point, it would recover a log  containing operations 1-3, and it would recover SSN and ALSN values of 100 and 3, respectively. This state is consistent with the completion of operation 3.","Next, the client daemon  sends the server  a recovery-assistance request message  that includes its recovered SSN and ALSN values. Using these values, the server  determines exactly what state information the daemon  needs, as follows. The server  first initializes two null sets of file IDs: a relevant set and an invalid set. It then walks in order through the elements in its log , beginning with the first element beyond the SSN it received from the daemon . It adds each element's relevant file IDs to the relevant set, and it removes the element's invalid file IDs from the relevant set. In like manner, it adds the element's invalid file IDs to the invalid set, and it removes the element's relevant file IDs from the invalid set. This procedure ensures that if the log  contains a series of alternating lock (or lease) grants and releases for the same file ID, the last entry will win (i.e., be determinate).","The server  then sends the client  a reply message containing: (1) the metadata and lease state for relevant file IDs, (2) the set of invalid file IDs, (3) the server's  stored value of the daemon's SSN (i.e., as determined from the client message log ), and (4) the server's  stored value of the daemon's ALSN (i.e., as determined from the client message log ). When the client daemon receives this message, it incorporates the state and deleted file IDs into its locally recovered state , using the map assisted state transfer (MAST) mechanism described below. It truncates its log  by removing entries with LSNs less than or equal to the ALSN received from the server . In the example, this would empty the log. It updates the values of its SSN  and ALSN  to those received from the server , but only if they are greater than the values recovered locally. In the example, these values are updated to 102 and 5, respectively.","At this point, the daemon's  state is consistent with the server's  state, but it is still not consistent with the state of the driver , mainly because the daemon's  information about locally stored files is stale. Next then, the daemon  asks the driver  to re-push all logged operations with LSNs greater than the daemon's  persistent ALSN but not greater than its updated ALSN . The daemon  applies these operations to its local file state , but it does not record them in its log . In the example, the daemon's  persistent ALSN is 3 and its updated ALSN is 5, so the driver  pushes operations 4 and 5. At this point, the daemon  has completely recovered, and it resumes normal operation. For the example system, the state has returned to that illustrated in the above tables.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Driver log",{},{},{},{},{},{},"7"]},{"entry":["Driver log (persisted)",{},{},{},"4","5","6","7"]},{"entry":["Daemon log",{},{},{},{},{},"6"]},{"entry":["Daemon log (persisted)",{},{},{},{},{},"6"]},{"entry":["Server log","1","2","3","4","5"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"char"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Daemon SSN","102"]},{"entry":[{},"Daemon persistent SSN","102"]},{"entry":[{},"Daemon ALSN","6"]},{"entry":[{},"Daemon persistent ALSN","6"]},{"entry":[{},"Server SSN","102"]},{"entry":[{},"Server ALSN","5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The above tables illustrate an example of what happens if, before the daemon  crashes and restarts, the driver  pushes operation 6 to the daemon , which then commits its state. In this case, the recovery proceeds slightly differently. The server  performs the same procedure, but since it has no recovery records with SSN values greater than 102, it sends null sets of metadata state and invalid IDs to the client , and therefore the client daemon  has no state-incorporation work to do. The daemon  still truncates its log  by removing entries with LSNs less than or equal to the server's  stored ALSN for the client . In the example, this removes entries 1-5, leaving only operation 6. However, the daemon  does not update the values of its SSN  or ALSN , since the values received from the server  are not greater than its locally recovered values.","If, in an embodiment of the invention, the FARSITE code is written using threads and fine-grained locking, it would be natural to create a separate transaction for each thread and to commit the transaction when the thread completes a task, thereby ensuring that the transaction commits consistent state. However, in an embodiment of the invention, to simplify concurrency management, the FARSITE code is written in an event-driven style, wherein each task monopolizes the central processing unit (CPU) (e.g., processing unit  of ) until it explicitly yields when it reaches a blocking point (typically an I\/O operation). Employing multiple concurrent transactions in such an embodiment would entail several complications. Concurrent transactions may require additional concurrency control beyond that implicit in event-driven code. Since pessimistic concurrency control interacts badly with event-driven code, an optimistic concurrency control mechanism would be required. Since performing a database commit at the end of each task would be prohibitively expensive, an in-memory transactional store, such as recoverable virtual memory (RVM), would be desirable.","Although the above approach is workable, in an embodiment of the invention, a different route is chosen. Each subsystem maintains a single transaction for its tasks, and, every so often, this single transaction is committed and a new transaction is started. This approach entails two problems, the first of which is how to ensure that the state of each task is consistent at the moment of commit. In an embodiment of the invention, a solution to this first problem gives rise to a second problem, which is how to prevent an excessive delay before the commit occurs.","Whenever a task resumes from a blocking point, it should verify its current state, and if the state is found to be inconsistent, the task should restart. With this code pattern in place, each subsystem runs a periodic commit task whose job is to commit the current transaction and start a new one. The code pattern ensures that committed state is effectively consistent. However, not all event-driven code in an embodiment follows this pattern strictly, so some work is required to ensure consistency.","By code inspection, it may be determined which blocking points follow the resume-verify-restart pattern, and these points may be tagged as commit-safe. When each task begins execution or resumes from a commit-safe blocking point, it acquires a nonexclusive commit lock; when the task terminates execution or reaches a commit-safe blocking point, it releases the lock. Before the commit task performs its commit operation, it acquires an exclusive commit lock, which conflicts with the commit locks held by the other tasks. The commit lock is managed in much the same manner as a single-writer\/multiple-reader lock, and it may ensure that no task is at an unsafe blocking point at the time of the commit.","Since the commit task waits until other tasks are at commit-safe blocking points, the commit could potentially be delayed by a very long time. Steps may be taken to prevent this. By code inspection and modification, it may be ensured that remote-operation blocking points are commit-safe. By profiling under a heavy load, blocking points responsible for high commit delays may be identified and they may be inspected and\/or modified to ensure that they are commit-safe.","In an embodiment of the invention, the server subsystem of FARSITE is built on top of a replicated state machine (RSM) service using a conventional RSM toolkit such as that described in Rodrigues et al., \u201cBASE: Using Abstraction to Improvie Fault Tolerance,\u201d , October 1991. In an RSM, a replica may fall far behind its peers, or a new replica may join a replica group with a clean slate. In either situation, it may be impractical to advance the replica by replaying the operation history that it missed, because storing and transferring a history that grows without bound is impractical. Instead, the RSM substrate requires the subsystem to emit and accept state-based updates.","In an embodiment of the invention, the RSM toolkit requires the subsystem to express its state as an array of marshaled objects. It makes three upcalls to the subsystem, and it provides one downcall. The downcall is modify, which warns the toolkit to take a preimage of an object before the subsystem modifies its state. The upcalls are: \u201cexecute,\u201d which indicates an operation request has arrived and instructs, for example, the FARSITE server subsystem to execute it. In the absence of state transfer, only this call is used. \u201cget_obj,\u201d which asks the subsystem for the marshaled state of an object with a given array index. This call is used for extracting state from an up-to-date replica. And \u201cput_obj,\u201d which instructs the subsystem to update an indexed object with new marshaled state. This call injects a marshaled state object into the subsystem on a laggard replica, which is responsible for incorporating the object into its working state.","The practical challenge of incorporating state has not been adequately addressed in conventional systems. For comparison and contrast with the MAST technique, conventional ways to organize data structures to support state incorporation are first described: opaque pages, incorporation-aware classes, raw interfaces, hybrid interfaces, and runtime interfaces.","In the opaque pages technique, the subsystem is programmed directly against the low-level array-of-objects interface provided by the RSM toolkit. In this approach, each state object is a memory page, and the state array is the memory address space. Manually laying out objects in memory is painful and abandons the compiler support designed to do object manipulation. Even assuming language support for controlled object layout, this approach requires a common address space among replicas, which may interact badly with heterogeneous distributed systems.","In the incorporation-aware classes technique, the subsystem's data structures are designed to be aware of state incorporation from the beginning. While this approach is sometimes sensible, it conflicts with the goals of modularity and encapsulation. Because incorporation must handle the interactions among all objects, an incorporation-aware design necessarily considers all such interactions together.","In the raw object interfaces technique, data structures are designed with a set of raw interfaces for state incorporation, disjoint from the runtime interfaces used by the subsystem's algorithms. Using only raw interfaces, it is difficult to navigate the object graph to place incoming state. It is also difficult to replace state incrementally. What should be done with disconnected object references, and what should be done with incoming state that refers to an object not yet reconstructed? Each question must be answered anew for each raw interface on each class.","In the hybrid object interfaces technique, raw interfaces are provided for injecting state into a local object, but runtime interfaces are used to navigate the object graph. This solution addresses the first problem with raw interfaces but introduces a worse problem. The runtime interfaces rely on invariants in the data structure that are not maintained by the arbitrary incremental replacement of state. Working around those invariants is class-specific and pollutes the design of the runtime interfaces with awareness of state-incorporation requirements.","In the runtime object interfaces technique, state is incorporated using only the runtime object interfaces. In this approach, used by the BASE RSM toolkit, a method accepts an array of marshaled objects, and makes a series of calls on the runtime object interfaces to transform its state into that represented by the marshaled objects. The worst problem with this approach is that it requires inferring a sequence of operations that produce an arbitrary state. This task is not achievable in general, and when it is, it requires deep knowledge of the subsystem's properties. A small change to the runtime calling protocol could result in a dramatic change to the operation-sequence inference algorithm. Another problem is that the approach requires transmitting and considering the entire state update all-at-once, not incrementally. Otherwise, the inference algorithm may be unable to construct an operation sequence that can produce the partial state. For systems with state larger than core, the inference algorithm must produce a sequence with the further constraint of disk-friendliness.","In addition to the problems mentioned with each approach, none of these conventional techniques are well suited to adapting existing legacy code for use in an RSM. The map assisted state transfer (MAST) technique relieves the problems described above. The MAST technique is applicable to other contexts, as well, for example, it can be used in systems where replicas synchronize via state-based updates such as WinFS.","In an embodiment of the invention, the code requirements for each class may be limited to marshaling and unmarshalling routines and the use of a pointer-swizzling strategy, for example, all-at-once swizzling for subgraphs of the object graph, references using non-pointer keys, or lazy swizzling. These techniques are known in the art and often already available for other purposes, such as persistence or out-of-core operation. Furthermore, they can often be written with only local and fairly limited understanding of a class's dynamic behavior.","Broadly, in MAST, incoming state is incorporated into a \u201cmarshaled shadow\u201d of the objects on the receiving replica, rather than into the runtime object graph. This shadow may be maintained in volatile or non-volatile memory  (). MAST maintains a shadow map that maps between keys and the shadowed objects. This map facilitates object placement without class-specific object-graph navigation.","Earlier conventional RSM toolkits require a dense linear key space, treating the state as an array of blobs. For convenience, in an embodiment of the invention, the RSM toolkit may be modified or implemented such that it allows each subsystem class to choose an independent, sparse, and programmer-defined key space. Before incorporating incoming state, the RSM ceases calling execute, and the state machine quiesces. MAST may then follow these steps:","1. Marshal all objects into the shadow, a collection of blobs.","2. Discard the in-memory runtime representations.","3. As put_obj supplies each incoming blob, use the associated key to insert or update the shadow. A key with an empty blob indicates a deletion.","4. Reconstruct the in-memory state from the shadowed blobs using the objects' unmarshaling constructors.","In an embodiment of the invention, the MAST technique has several advantages including that it works well with conventional object-oriented design, for example, it may be utilized to adapt persistence-aware but incorporation-unaware classes with minimal invasion. It may sidestep the problems of object-graph-navigation and invariants in runtime interface invariants by utilizing standard marshaling and swizzling (which may already be present). Swizzling may be made easier by allowing classes to use flexible, independent key spaces. It may incorporate state directly, rather than inferring runtime operations that should produce the desired state. In addition, it may be well-suited to incremental and out-of-core operation.","In an embodiment of the invention, the distributed file system classes may be marshaled into relational database tables. The database provides persistence, useful transactional semantics, and efficient indexing to support out-of-core operation. Each class may be marshaled to its own table, and the primary key for the table may be utilized as the class-specific shadow map key. Because the database table is considered the marshaled representation and not the runtime representation, database integrity constraints (such as foreign-key constraints) are not necessary. In an embodiment of the invention, this reflects the MAST strategy of exploiting invariance-freedom in the marshaled representation.","A \u201ccatastrophic event\u201d is one that violates the RSM assumption that no more than \u2018f\u2019 machines fail at once, for example, a power outage that causes every replica to crash and restart. In an embodiment of the invention, to recover from such an event requires two conditions. The persistent state stored on each server is required to be consistent, and this state is required to reflect operations that have been exposed to other subsystems.","The consistency condition is required because in general it is difficult to recover from an arbitrary or inconsistent state. In an embodiment of the invention, consistency of the persistent store is achieved by committing updates on boundaries between operation executions. For example, a long-running transaction may be utilized to perform 50 RSM operations in-memory with MAST tracking the list of created, updated, and deleted objects. Performing operations in-memory may absorb IPC traffic to the database server. Because a transaction is open, it is possible to push objects out-of-core, even in the course of an operation. When the batch ends, the remaining updates may be written and the transaction committed. The transaction may ensure that a restarted system sees a consistent state on an operation boundary.","The state-exposure condition seems to demand that we commit the state after every operation, before transmitting the reply to the client. However, as part of its solution to catastrophic-failure recovery, the RSM toolkit persistently records a log of operations that it has scheduled for execution. That log is sufficient to reconstruct the RSM state from the point of the last state commit. After restoring the state to the most-recent commit, the RSM may utilize the ordinary execute call to reconstruct the most-recent state.","In an embodiment of the invention, the file host subsystem uses a tolerable inconsistency and lazy recovery (TILR) strategy for maintaining its persistent state. Unlike the client and the server subsystems, the file host may perform its work in a best-effort fashion. When it restarts, it need not try to ensure that its state is strongly consistent with that of any other components. Instead, it may rely on background processes to eventually catch and repair inconsistencies.","The job of a file host includes replicating and storing file contents, under direction of server groups. A file host's state may include a set of file replicas, a catalog of replica metadata, a queue of pending work, and a queue of work in progress. Except for the file replicas, which are stored in the file host's local file system, all of this state may be stored in a local database. To keep the database internally consistent, in an embodiment of the invention, updates to the database are transactional. However, there need not be transactionality between the database and the file system, and, in addition, there need not be tight coupling between the file host and any server group.","As a result of this loosely coupled design, the file host's local file system may become out-of-sync with its local database, or the local database may become out of sync with the instructing server group's state. For example, a file host might finish the work of copying a file but then crash before it updates its replica metadata catalog to reflect the new copy, or it may crash before it tells the server about the copy.","To address such inconsistencies, the file host may periodically scan through its stored file replicas. For each replica it finds, it may check its local database to ensure that the replica is listed in its catalog. If it is not, the replica is discarded. If the replica is listed in the catalog, the file host then communicates with the server group indicated by the replica metadata to ensure that the replica is credited and still wanted by the server group. If it is not wanted, in an embodiment of the invention, the replica is discarded. If it is wanted but not credited, the server group may update its state to reflect the fact that the file host does hold a copy.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIG. 10","FIG. 10","FIG. 4","FIG. 1"],"b":["310","1002","310","110","112","406","408","410","418","420"]},"At step , remote state may be retrieved. For example, the client daemon  () may retrieve state from the server . Remote state retrieval is described in more detail below with reference to . At step , some or all of the recovered state may be updated with the retrieved remote state utilizing map assisted state transfer (MAST). For example, the client daemon  may utilize MAST to update the local file state  with the retrieved remote state.","At step , the operations log  () may be truncated. For example, the client daemon  may remove entries from the operations log  associated with log sequence numbers less than or equal to an applied log sequence number in the retrieved remote state. At step , the applied log sequence number  may be updated, for example, the applied log sequence number  may be updated to the applied log sequence number in the retrieved remote state if the applied log sequence number  is less than the applied log sequence number in the retrieved remote state. The value of the applied log sequence number  prior to update may be stored for later reference.","At step , a set of operations logged by the client driver  () may be requested. For example, the client daemon  may request that the client driver  re-push operations in its operations log  associated with log sequence numbers in a range between the recovered value of the applied log sequence number  and the updated value of the applied log sequence number . At step , a local resource state such as the local file state  may be updated with the operations pushed by the client driver  as a result of the request in step . The client daemon  may be fully recovered following the update of step .",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 11","FIG. 11","FIG. 4"],"b":["310","412","1102","422","310","422","412","422","418","420"]},"At step , the recovery-assistance request message  () may be received. For example, the server  may receive and parse the recovery-assistance request message . At step , a relevant set of resource identifiers may be instantiated and at step  an invalid set of resource identifiers may be instantiated. In an embodiment of the invention, step  is incorporated into step . For example, the server  may initialize the relevant and invalid sets of file identifiers by considering elements in its client message log  beginning with the entry corresponding to the SSN  contained in the recovery-assistance request message .","At step , the recovery-assistance reply message  may be sent. For example, the server  () may instantiate and send the recovery-assistance reply message  to the client daemon . The recover-assistance reply message  may include resource metadata and lease state for relevant resource identifiers, the set of invalid resource identifiers, the server's  stored value of the daemon's SSN , and the server's  stored value of the daemon's ALSN  (e.g., as determined from the client message log ). At step , the recovery-assistance reply message  may be received. For example, the client daemon  may receive and parse the recovery-assistance reply message . The information contained in the recovery-assistance reply message  may then be utilized in subsequent steps such as step  of .","Incorporating incremental state changes into active data-structures may be challenging in practice, for example, because of a need to avoid violating active data-structure invariants. Map assisted state transfer (MAST) may be utilized to overcome the challenges of active state update.  illustrates aspects of an example map assisted state transfer architecture  in accordance with an embodiment of the invention.","The map assisted state transfer architecture  includes an expeditious replica  component and a laggard replica  component, each maintaining an active replica state ,  data-structure and having a replica protocol layer ,  module. The replica protocol layers  and  may be identical or they may differ, for example, in version. The replica protocol layer  is shown in  as including a marshal\/unmarshal module . The laggard replica  is shown as including a marshaled shadow  of the active replica state , that is, the marshaled replica state shadow . Of course, the expeditious replica  may include a marshaled replica state shadow (not shown in  for clarity) if it should become laggard with respect to some other replica.","A goal of each replica  and  may be to seek to maintain identical active replica states  and . For example, replica  may be informed of changes to active replica state  and replica  may be informed of changes to active replica state . In normal operation, information about such changes are carried between each replica  and  by replica operational messages . For example, if the active replica state  includes a file directory and one of the files in the directory is renamed then one of the replica operational messages  sent to the replica  may include a specification of the file rename operation. However, this operation-by-operation replication of state may be computationally expensive. As a result, some replica in a replica network may lag others, for example, because they are slower (have access to less computational resources such as processor time or bandwidth) or because of component failure (being \u201coffline\u201d for a period).","The replication lag may reach a point where the laggard replica  determines that normal operation is insufficient to reduce the lag to an acceptable level. The laggard replica  may then initiate map assisted state transfer (MAST). Map assisted state transfer may include marshaling the active state replica  into the marshaled replica state shadow , sending a MAST trigger message  to the expeditious replica , receiving MAST update messages  containing one or more incremental state updates (or MAST updates), applying the incremental state updates to the marshaled shadow  and then re-instantiating the active replica state  from the updated marshaled shadow . Map assisted state transfer may be more efficient than operation-by-operation replication of state thus enabling the laggard replica  to reduce lag to an acceptable level. Moreover, map assisted state transfer may enable lag reduction when operation-by-operation replication is no longer an option such as when some or all of the operations log at the expeditious replica  becomes unavailable, for example, because the operations log has been truncated or otherwise limited in size. In such circumstances, map assisted state transfer may provide for incorporation of some or all of the active replica state  into the active replica state . Following map assisted state transfer, the active replica state  may match the active replica state .","Example details of active replica state  and  and the marshaled replica state shadow  are described below with reference to . For example, the marshaled shadow  may include shadowed versions of active replica state  objects and a shadow map that facilitates insertion and\/or update of shadowed objects independent of the class-specific object-graph navigation required for such operations on the active replica state . The replica protocol layer modules  and  may create, instantiate, format, send, receive, parse and\/or destroy replica operation messages , MAST trigger messages  and MAST update messages . The marshal\/unmarshal module  may create, instantiate, format and\/or update the marshaled shadow  with data from the active state  as well as creating, re-instantiating, formatting and\/or updating the active state  with data from the marshaled shadow . The marshal\/unmarshal module  may also read, delete and\/or destroy the active state  and its marshaled shadow .","The active replica state  may include active data-structures having invariance relationships, for example, relationships that, if violated, make the active replica state  inconsistent. The marshaled replica state shadow  may include shadows (e.g., transforms) of the data-structures of the active replica state  that are independent of invariance relationships. The marshaled shadow  may be unconstrained by the invariance relationships of the active state , in particular, in terms of suitable types of update.",{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 13","FIG. 12","FIG. 13","FIG. 12","FIG. 13","FIG. 12"],"b":["1206","1208","1216","1202","1302","1206","1204","1304","1306","1208","1216"]},"The active replica state  includes a file directory , a file table  and a file contents  area. The active replica state  likewise includes a file directory , a file table  and a file contents  area. The file directories  and  include filenames and file identifiers (IDs). Each filename corresponds to a file identifier. The file tables  and  include file identifiers, file offsets and file lengths. Each file identifier is associated with a file offset and a file length. The file length indicates a length of a file (e.g., in bytes) in the file contents area  or . The file offset indicates where the file begins in the file contents area  or . The marshaled replica state shadow  includes a shadow map of keys (e.g., cryptographic hashes represented by letters in ) to blobs (binary large objects, e.g., marshaled shadows of active replica state  data-structures).","In the example depicted by , an invariance relationship exists between the file directory  and the file table , that is, file table entries (rows) must have corresponding file directory entries and vice versa. The same invariant holds for the data-structures of the active state replica . In this example, a file with file ID  (i.e., \u201cBAZ\u201d) has been added to the active replica state  but not yet to the active replica state . In normal operation, the active replica state  may be updated with one or more replica operational messages  (). During a map assisted state transfer, the active replica state  may be synchronized by marshaling the active state replica  into the marshaled replica state shadow , applying one or more incremental state updates received in MAST update messages  to the marshaled shadow , and then re-instantiating the active state replica  from the updated marshaled replica state shadow . The procedure is described in more detail below with reference to .",{"@attributes":{"id":"p-0123","num":"0122"},"figref":["FIG. 14","FIG. 13","FIG. 4"],"b":["1402","1304","1302","1304","1218","1202","408"]},"At step , the active replica state  () may be marshaled into the marshaled replica state shadow  with any suitable marshaling procedure. Marshaling and unmarshaling procedures are known in the art and need not be described here in detail. Having been marshaled, at step , the active replica state  may be destroyed (e.g., deleted from system memory  of ). Following step  and prior to step , the laggard replica  may send a MAST trigger message  () to an expeditious replica such as the expeditious replica  in order to trigger a sending of MAST update messages  by the expeditious replica . Alternatively, it may be the expeditious replica  that determines that map assisted state transfer is required in step , in which case the expeditious replica  may send the MAST trigger message  to the laggard replica . The laggard replica  may perform step  by receiving the MAST trigger message  from the expeditious replica .","In any case, at step , MAST updates (i.e., replica state updates) may be received, for example, contained in MAST update messages  (). At step , the MAST updates may be applied to the marshaled replica state shadow  (). For example, each MAST update may contain one or more key-blob pairs and the updates may be applied to the marshaled shadow  by searching the shadow map of the marshaled shadow  for matching keys and replacing corresponding blobs in the marshaled shadow  with the blobs (i.e., marshaled replacement objects) from the state updates. If the state update contains a key without a blob, the corresponding blob in the marshaled shadow  may be deleted. If no matching key is found, the blob may be added to the marshaled shadow  and a corresponding entry made in the shadow map. Instead of key-blob pairs, key-object (e.g., programmatic object) pairs may be utilized or, if the marshaled shadow  is stored in a relational database, key-row pairs\/tuples.","At step , it may determined if there are more MAST updates to receive. If there are more MAST updates to receive, the procedure may return to step . Otherwise, the procedure may progress to step . At step , a new active replica state  may be instantiated by unmarshaling the updated marshaled shadow  with an unmarshaling procedure corresponding to the marshaling procedure utilized in step . For example, the marshaling of step  and the unmarshaling of step  may be performed by the marshal\/unmarshal module  of . Alternatively, the data-structures of the active replica state  may be associated with one or more programmatic objects having marshal and unmarshal methods. In that case, the active replica state  may be marshaled by invoking the marshal methods of its associated programmatic objects and similarly, unmarshaled by invoking the unmarshal methods.","Additional examples and context relevant to the present invention may be found in Appendix A.","All references, including publications, patent applications, patents and appendices, cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.","The use of the terms \u201ca\u201d and \u201can\u201d and \u201cthe\u201d and similar referents in the context of describing the invention (especially in the context of the following claims) are to be construed to cover both the singular and the plural, unless otherwise indicated herein or clearly contradicted by context. The terms \u201ccomprising,\u201d \u201chaving,\u201d \u201cincluding,\u201d and \u201ccontaining\u201d are to be construed as open-ended terms (i.e., meaning \u201cincluding, but not limited to,\u201d) unless otherwise noted. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range, unless otherwise indicated herein, and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples, or exemplary language (e.g., \u201csuch as\u201d) provided herein, is intended merely to better illuminate the invention and does not pose a limitation on the scope of the invention unless otherwise claimed. No language in the specification should be construed as indicating any non-claimed element as essential to the practice of the invention.","Preferred embodiments of this invention are described herein, including the best mode known to the inventors for carrying out the invention. Variations of those preferred embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate, and the inventors intend for the invention to be practiced otherwise than as specifically described herein. Accordingly, this invention includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover, any combination of the above-described elements in all possible variations thereof is encompassed by the invention unless otherwise indicated herein or otherwise clearly contradicted by context."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the invention with particularity, the invention and its advantages are best understood from the following detailed description taken in conjunction with the accompanying drawings, of which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
