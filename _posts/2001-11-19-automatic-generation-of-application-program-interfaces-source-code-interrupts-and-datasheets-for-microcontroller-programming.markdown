---
title: Automatic generation of application program interfaces, source code, interrupts, and datasheets for microcontroller programming
abstract: A method to facilitate programming a microcontroller is disclosed. In one embodiment, after a user configures the circuit by selecting circuit parameters and pin-outs, various items are automatically generated to facilitate programming the microcontroller. The generated items may include: application programming interfaces (APIs) for programming the operation of one or more user modules; source code for realizing the user modules in hardware; interrupt vectors to call interrupt service routines for one or more modules; and a data sheet for the circuit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07086014&OS=07086014&RS=07086014
owner: Cypress Semiconductor Corporation
number: 07086014
owner_city: San Jose
owner_country: US
publication_date: 20011119
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Notation and Nomenclature","Source Code Files","APIs","Interrupt Service Routines","Interrupt Vectors","Data Sheets"],"p":["The present invention relates to the field of programmable single-chip systems. Specifically, the present invention relates to a software program which allows a circuit designer to configure a circuit and then automatically generate a series of items to facilitate programming a microcontroller.","Microcontrollers allow circuit designers great flexibility in design choice. However, programming the microcontroller to perform the desired functions can be an arduous task. Conventional software for programming microcontrollers is not very robust and does not offer designers many tools to reduce the amount of low level details they need to memorize in order to configure the chip.","Conventional software for programming microcontrollers is very difficult to use. In one system, many windows pop-up as the user attempts to program the microcontroller. Windows pop-up based on \u201cflat-organized\u201d drop down menus. Each window corresponds to a discrete function. However, many functions are required to do simple tasks. Consequently, the many displayed windows cause confusion because the user needs to keep track of which window is used for which function. Furthermore, it is very difficult to navigate between the windows because some windows overlap others. The user may have difficulty remembering which windows contain what information and which windows receive what information.","Once a circuit designer selects the various functions desired for the circuit, the designer must organize those function within the constraints of the available resources of the hardware with which the design is to be implemented. Conventionally, the circuit designer manually places the functions within the available resources of a programmable device. Unfortunately, this process is tedious and error-prone.","The circuit designer must also design the various interconnections between the selected functions, as well as configure the input\/output pins. Conventionally, this can be an arduous and error-prone process. For example, the circuit designer must map the functions he has selected to actual hardware. Multifunction input\/output (I\/O) ports or pins may be very difficult to configure. They typically have multiple registers that needed to be programmed to configure the pin type as well as the drive characteristics for each of the I\/O pins.","Circuits designers also desire to have a datasheet describing the circuit he has designed. Conventionally, the datasheets are generated manually by the designers. Each time the design is modified, a new datasheet must be manually generated. Thus, the designer time is not used efficiently and the possibility of errors in the datasheet is great.","Finally, in many conventional systems, the microcontroller devices are programmed manually. The programmer needs to know all of the registers and other technical information required to instruct the microcontroller to do its embedded functions (e.g., start timing, stop timing, etc.). Manual programming is very error prone and tedious and difficult to error check.","Therefore, it would be advantageous to provide a method which provides for a convenient user-friendly interface for designing a circuit by programming a microcontroller. It would be further advantageous to provide a method which may help reduce errors in programming a microcontroller. Finally, it would be advantageous to provide such a method for programming a microcontroller which does not require the circuit designer to memorize registers and other technical information to invoke functions when programming a microcontroller.","Therefore, it would be advantageous to provide a method which may help reduce errors in programming a microcontroller. It would be further advantageous to provide such a method for programming a microcontroller which does not require the circuit designer to memorize register and other technical information to invoke functions when programming a microcontroller.","The present invention provides for a method to facilitate programming a microcontroller. Embodiments provide for a method which may help reduce errors in programming a microcontroller. Embodiments provide for such a method for programming a microcontroller which does not require the circuit designer to memorize registers and other technical information to invoke functions when programming the microcontroller. Embodiments provide an alternative to manually creating a datasheet describing a microcontroller implemented project. The present invention provides these advantages and others not specifically mentioned above but described in the sections to follow.","A method to facilitate programming a microcontroller is disclosed. In one embodiment, after a user configures the circuit by selecting circuit parameters and pin-outs, various items are automatically generated to facilitate programming the microcontroller. The generated items may include: application programming interfaces (APIs) for programming the operation of one or more user modules; source code for realizing the user modules in hardware; interrupt vectors to call interrupt service routines for one or more modules; and a data sheet for the circuit.","In the following detailed description of the present invention, a method for facilitating programming a microcontroller, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be recognized by one skilled in the art that the present invention may be practiced without these specific details or with equivalents thereof. In other instances, well known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present invention.","Some portions of the detailed descriptions which follow are presented in terms of procedures, steps, logic blocks, processing, and other symbolic representations of operations on data bits that can be performed on computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure, computer executed step, logic block, process, etc., is here, and generally, conceived to be a self-consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a computer system. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as \u201cindexing\u201d or \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ctranslating\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cscrolling\u201d or \u201cdisplaying\u201d or \u201crecognizing\u201d or \u201cgenerating\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","To facilitate the design process, embodiments provide various work-spaces. For example, a user may move between a user module selection work-space, a user module placement workspace, and a user module pin-out work-space.  illustrates an exemplary graphical user interface which allows a user to select user modules . Regarding user module selection, the workspace provides a user module window  for a catalog of available user modules , a listing  of selected user modules , a schematic  of a selected user module , plus its datasheet . The user may click on a user module  of user module window  to designate one. A histogram  (e.g., a series of cumulative bar charts or graphical indicators) of available resources on the target device (e.g., a microcontroller) is also shown. The datasheet  is tabbed for easy navigation therethrough. The various windows may be displayed simultaneously for easy reference back-and-forth. Button  may be used to automatically generate source code for the project.","Referring now to , a user module placement work-space includes a resource graphic window  illustrating the placement of user modules  with respect to the available resources (e.g., available programmable system blocks  of a microcontroller) in a hardware layout graphical display. Throughout this application the term resource image may denote the blocks  upon which user modules  are placed in window . As the resource images may represent programmable system blocks in one embodiment, the resource images may be referred to as programmable system blocks for convenience. It will be understood that the resource images may represent other resources however, as the present invention is not limited to implementing the user modules  in programmable system blocks.  shows a number of digital programmable system blocks along the top row (e.g., the blocks labeled DBA, DBA, etc.), as well as four columns of analog programmable system blocks (e.g., the blocks labeled ACA, ACA, etc.). The present invention is well suited to using any number of analog and digital programmable system blocks . Furthermore, the blocks in graphic window  are not limited to representing programmable system blocks.","A single user module  may map to one or more programmable system blocks . Color coding (not shown) may be used to relate the user modules  of selected modules window  with their schematic placement in resource graphic window . The analog and digital programmable system blocks may be more generally defined as two different classes to which a user module  maps. The present invention is well-suited to having many different classes.","Referring now to , a pin-out configuration work-space is shown. The pin-out configuration work-space allows the user to connect programmable system blocks  to input\/output (I\/O) pins, as well as configure the I\/O pins' drive characteristics. In one embodiment, a pin configuration window  may be used to configure pins. Pin configuration window  has a port column , a select column , and a drive column . In another embodiment, a user may set pin configurations by clicking on the GUI of the chip . The operation of these features will be discussed more fully herein.","Referring now to , after the user has configured the device, embodiments automatically generate source code, which may be edited by the user. A directory window  (source tree window) provides a listing of various exemplary source code files and API files that may be automatically generated. An editor workspace  is provided for a user to edit various files. In this fashion, a user may program a microcontroller without having detailed knowledge of all the registers in the microcontroller.","Reference will now be made to the flowchart of  and  and . Steps of process  may be implemented on a general purpose computer, such as illustrated in . Referring now to step  of  and , a selection  of available user modules  is displayed. A user module  may represent an accessible, pre-configured function that once programmed and placed will work as a peripheral to a target device. For example, a user module may be an amplifier, pulse width modulator, counter, digital-to-analog converter, etc. The user module window  of  shows amplifiers which may be selected. The user may select one of the \u2018buttons\u2019  to cause the user module window  to display other user modules . (For example, to display Timers, Pulse Width Modulators, etc.).","Referring still to  and , in step  in response to a user selection of one of the user modules , the selected user module  is displayed in a selected user module region  and a data sheet  and schematic  are displayed for the selected user module .  shows a schematic  for an instrumentation amplifier, along with its datasheet . The user is allowed to add more user modules  to the design by selecting more user modules  and causing them to be added to the selected user module area .","Referring now to step  of , in response to a request from a user for a potential (e.g., valid) position for a selected user module , a position is computed. The computer automatically determines the possible placements based on the available resources and the number of programmable system blocks  and the types of programmable system blocks  that are required for the unplaced user module . Because the user does not need to determine the potential placements, designing the circuit is faster and less error prone than conventional methods which do not provide such guidance.","User modules  may require multiple programmable system blocks  to be implemented. In some cases, user modules  may require special ports or hardware which may limit which programmable system blocks  can be used for their implementation. The process of mapping a user module  to programmable system blocks , such that the user module  is realized within the microcontroller, may be referred to as \u201cuser module placement.\u201d An embodiment automatically determines the possible placements of a user module  based on an Extensible Markup Language (XML) user module description and the hardware description of the underlying chip. However, the present invention is not limited to using XML descriptions. The potential placement positions may be automatically inferred based on the XML input data. Therefore, the placement process of embodiments of the present invention is data driven.","In step , one or more programmable system blocks  are highlighted to indicate a possible position for the user module  based on, for example, XML input data. The placement is shown in a graphical hardware layout diagram  by highlighting the programmable system blocks  involved. For example, referring to , the ADCINC121 user module  has been selected for placement in the window . This user module  requires two digital blocks and one analog block . The digital programmable system blocks labeled DBA and DBA are highlighted to indicate a possible position for the ADCINC121 user module . Referring now to , the analog programmable system block labeled ASB is highlighted to indicate that it is a possible position for the analog portion of the ADCINC121 user module . Embodiments may use color coding to associate the highlighting color with a unique color assigned to that user module .","User module placement is described in co-pending U.S. patent application Ser. No. 09\/989,762, filed concurrently herewith, entitled \u201cA SYSTEM AND METHOD FOR PERFORMING NEXT PLACEMENTS AND PRUNING OF DISALLOWED PLACEMENTS FOR PROGRAMMING AN INTEGRATED CIRCUIT,\u201d by Ogami et al., and assigned to the assignee of the present invention and incorporated herein by reference.","Referring now to  and to step  of , after placing a user module , a user may desire to move it to another programmable system block  (or blocks). In step , a new possible position for a user module  is computed, in response to a user request for a new position for the user module . The user may select a next position button  to cause this to occur.  illustrate three possible positions for the analog portion of the ADCINC121 user module . The user may then click on a place module button  to place the module . Placements that are incompatible with the user module requirements (e.g., characteristics) are automatically pruned out by the software and therefore are not displayed as valid placements. In one embodiment, all positions are shown to the user, sequentially, each time the next placement icon  is selected. However, if a potential placement involves a programmable system block  that has already been used (e.g., by another placed user module ), then in these cases the place user module icon  is grayed out indicating that this placement is only valid if the resources were vacant. This allows the user to see all possible placements.","If a user module  consists of both and digital and analog blocks , the system may show next positions for the digital and analog blocks separately. Thus, the user may change the placement of one without affecting the other. For example, the position of the analog block of the ADCINC121 user module  is moved in . However, the digital blocks for that module  do not move at this time. The user may separately seek a new position for those blocks  (e.g., digital blocks DBA and DBA in ). Embodiments allow for multiple different classes to be separately placed. For example, rather than placing analog and digital blocks separately, the user may place memory, routing, and I\/O separately in an embodiment which is not illustrated in the Figures. The present invention is well-suited to placing any number of classes separately. Furthermore, when placing a user module  with multiple classes, the system may highlight active resource images (e.g., those currently being placed) in a different color than inactive resource images.","The next position process is iterative, in that each time the next position button  is clicked, another possible placement will be determined and highlighted, etc., until the user module  is placed.","User module next placement is described in co-pending U.S. patent application Ser. No. 09\/989,781, filed concurrently herewith, entitled \u201cSYSTEM AND METHOD FOR DECOUPLING AND ITERATING RESOURCES ASSOCIATED WITH A MODULE,\u201d by Ogami et al., and assigned to the assignee of the present invention and incorporated herein by reference.","Steps  through  may be repeated to allow the user to add more user modules . Each time a new user module is selected, a system resource window may be updated. Referring again to , for each user module  selected, the system updates the data in the Resource Manager window  with the number of occupied programmable system blocks , along with RAM and ROM usage used by the current set of \u201cselected\u201d user modules . The system may also prevent a user from selecting a user module  if it requires more resources than are currently available. Tracking the available space and memory of configurations for the design may be performed intermittently during the whole process of configuring the microcontroller. Embodiments provide a live graph tracking the programmable system blocks  used by percentage. The RAM and ROM monitors may track the amount of RAM and ROM required to employ each selected user module .","After the user has selected one or more user modules , the user may select global parameters and user module parameters such as, for example, the gain of an amplifier, a clock speed, etc. Referring now to  and to step  of , in response to a user clicking on a region on a programmable system block  an interface  is displayed which allows the setting of user module parameters. For example, the user may place \u201cthe cursor\u201d over the lower-left corner of a programmable system block  to set input parameters. The system may display a superficial chip or a changed cursor in response to this. The user may then left-click a mouse, for example, to bring up a user module parameter window  to configure the user module input parameters. The process may be repeated in the lower-right corner of the programmable system block  for output parameters and on the upper-left corner for clock parameters. The present invention is not limited to these steps for bringing up a user module pop-up window , however. The system may then display the selected parameters in a user module parameter window . Various pop-up windows may be data driven in that the contents of the pop-up window may depend on, for example, the user module  selected. Alternatively, user parameters may be set in the user module parameter window .","When the user module  is placed (e.g., instantiated) on a particular programmable system block  the register settings and parameter settings may be mapped to a physical register address on the chip. This may also associate interrupt vectors that the user module  uses based on the programmable system block . Each of the digital blocks maps to one vector and each column of analog blocks maps to one vector. Once the user modules  are placed and the parameters are set, all the physical address registers that are associated with that user module  are fixed and the register values are determined.","In addition to setting user module parameters, the user also may set global parameters. For example, referring still to , a global resource window  is seen. Global resources may be hardware settings that determine the underlying operation of the part (e.g., the CPU_Clock, which may designate the speed in which the microcontroller processes). These settings may be used to program global registers, which may be in addition to the registers set by configuring the user module parameters.","One embodiment provides for a graphical user interface for facilitating the configuration of I\/O pins in a microcontroller software design tool. Referring now to  and to step  of , a GUI is displayed to allow input\/output pins to be configured. Each pin has a pin number associated therewith. Referring to , when the user clicks near a pin of GUI , a small window  opens allowing the pin type (e.g., Port01) and drive type (e.g., Port01_Drive) to be configured. Referring now to window  of , the pin type may include analog input or analog output or global bus, etc. Referring now to window  of , the drive type may include high-z, pull-up, pull-down, strong, etc. The windows  and  may include a list that contains items that can be selected using the cursor. When the cursor is clicked outside of the windows  or , then the windows ,  disappear automatically.","In another embodiment, a pin parameter table is provided to configure the pins. Referring to , the pin parameter table  includes a column for pin number , pin type  and drive type . The entries in the pin parameter table  can be selected by the cursor and again, the relevant window will open so that pin type or drive type can be selected. Therefore, the GUI of the chip  or the pin parameter table  can be used to configure the pins.","Each pin may contain three register values for configuration of both pin type and drive type. By using this user interface, the user need not be concerned with remembering register values, etc., for configuring the pins. Further, the user need not worry about how the configuration is to be done using the registers.","Pin configuration is described in co-pending U.S. patent application Ser. No. 10\/032,986, filed Oct. 29, 2001, entitled \u201cPIN-OUT CONNECTIONS\/DRIVE LEVELS DIRECT-SET BY DROP DOWN LIST,\u201d by Ogami et al., and assigned to the assignee of the present invention and incorporated herein by reference.","Referring now to  and to step  of , embodiments provide many different windows to assist the user in setting various parameters to 1 specify interconnectivity of programmable system blocks . Referring to , the user may cause window  to appear to configure the analog output buffer. Referring to , the user may cause a clock window  to appear by clicking on a clock MUX  to configure which clock will be the input to a column of analog programmable system blocks . Referring to  a port selection window  is shown. The port selection window  may be made to appear by clicking on or near the pin input MUX . The user may then select the input port. Referring now to , the user may click on or near the analog clocking MUX  to cause a window  to appear to select which digital programmable system block should be selected by the clock MUX ( of ).","Referring now to step  of , after the circuit has been configured by the user, the system automatically generates Application Program Interfaces (APIs), source code to implement the user's design, a data sheet of the user's design, and interrupt vectors. For example, referring to , the user clicks on the generate application code button . The system may use all device configurations to update existing assembly-source and C compiler code and generate Application Program Interfaces (APIs) and Interrupt Service Routine (ISR) shells. At this time, the system also creates a data sheet based on the part configurations. Embodiments produce files that are suitable for use with emulators and debuggers to allow these configurations to be emulated and debugged in a simple and convenient fashion. This concludes the discussion of the steps of .","Embodiments automatically generate source code files for realizing the user modules within the programmable system blocks  in the chip. Throughout this application the term source code may be defined as the code that is used to program registers on the chip to implement the selected user modules  as they have been placed by the user and to configure the programmable system blocks to operate with the user selected parameters, interconnections, and pin-outs. Thus, automatically generated source code programs may realize the user modules  within the programmable system blocks .","The automatically generated files may be programmed into flash memory of a target device (e.g., a microcontroller). The flash memory may then be used to program registers on the target device in order to implement a particular user module  in hardware (e.g., actual programmable system blocks ). Therefore, the source code may be generated based on the selection, placement, and configuration of the user modules . For example, the automatic code generation processes take into account the parameterization of the user modules  and the placement of the user modules , which the user may perform via a GUI of embodiments of the present invention.","By using the automatically generated source code, a user need not be aware of all of the low level registers and other low level technical information required to program a microcontroller to realize the user modules . The user need only to interact with the GUIs which are written in a higher level of abstraction.","Exemplary source code files are included in  and . The exemplary file of  is a data table which is used to set register values on the target device based on the user's configuration. The exemplary file of  moves the data from the file of  into memory (e.g., flash) on the target device.","Automatic generation of source code files is described in co-pending U.S. patent application Ser. No. 09\/998,848, filed Nov. 15, 2001, entitled \u201cDESIGN SYSTEM PROVIDING AUTOMATIC SOURCE CODE GENERATION FOR PERSONALIZATION AND PARAMETERIZATION OF USER MODULES,\u201d by Ogami, and assigned to the assignee of the present invention and incorporated herein by reference.","After the microcontroller has been configured to implement the selected user modules , the user may wish to program desired functionality into the microcontroller. For example, a user may wish the user modules , now implemented in programmable system blocks in hardware, to function in a certain fashion when the microcontroller is being used. Embodiments automatically generate APIs, which can be used to perform common functions that are required to interact with the user module (e.g., how to start the timer, how to stop the timer, how to talk to the timer, etc.) from an application program level. For example, a user may insert an API into a software program which he writes. Thus, one type of API may be described as a function call; however, APIs are not limited to function calls.","By using automatically generated APIs, a user need not be aware of all of the low level registers and other low level technical information required to instruct the user module to invoke its functions. The user need only to interact with the APIs which are written in a higher level of abstraction.","In one embodiment, the API files that are automatically generated include the name of the instantiation of the user module  for which they are associated. This makes it easy for the user to keep track of the files. The application editor workspace  allows easy viewing, presentation, and editing of these files. A directory window  (source tree window) provides a hierarchical ordering of these and other files by file type and user module.","Automatic generation of API files may take into consideration the configuration the user made. For example, the values to which certain registers are set may depend on which block  the user module  is placed in.  and  illustrate an exemplary API file that is automatically generated for a user module ADCINC121. This file contains the actual code for the API.  and  illustrate two more exemplary API files that may be generated for a user module named ADCINC121. Each instantiation of each user module  may have such files automatically generated for it. The file in  may be used to allow programs written in the C programming language to access the user module APIs. The file of  contains equates that are used by the APIs. The APIs simplify the designer's task by declaring values for various registers based on the programmable system blocks  the user module  occupies.","Additionally, the API files may be conditionally compiled based on the parameter selections the user made during device configuration. For example, a user module  for a digital-to-analog converter may have a parameter for the data format that allows three choices such as: \u201coffset_binary\u201d, \u201ctwos_complement\u201d, and \u201ctwo_byte_sign_and_magnitude\u201d. An API file may be generated by conditionally compiling the code based on the parameter selected.","Automatic generation of APIs is described in co-pending U.S. patent application Ser. No. 09\/994,599, filed concurrently herewith, entitled \u201cAUTOMATIC API GENERATION TO FUNCTIONAL PROGRAMMABLE SYSTEM BLOCKS,\u201d by Ogami et al., and assigned to the assignee of the present invention and incorporated herein by reference.","ISRs (Interrupt Service Routines) may also be automatically generated during the device configuration. These may be shells or routines to provide the device-interface and interrupt-activity framework for source programming. Thus, interrupt service routines may be described as a type of API. Automatic generation of ISRs may be performed each time device application code is generated and is transparent to the user.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 12A","FIG. 12B"],"b":"304","sub":"\u2014"},"Embodiments automatically generate interrupt vectors, based on the placement of the user modules  on the PSoC blocks  during device configuration. In one embodiment, there are two types of interrupt vectors: fixed function and configurable PSoC blocks . Examples of fixed function interrupts may be: Reset, Supply Monitor, and Sleep Timer. The present invention is well-suited to a variety of other fixed function interrupts.","In the present embodiment, the configurable PSoC block interrupts may include eight digital block interrupts and four analog column block interrupts. The present invention is well-suited to other numbers of configurable PSoC block interrupts. The definition of a configurable PSoC block interrupt (e.g., the ISR that is called) depends on the user module  that occupies that block . The present invention is not limited to automatically generating interrupt vectors for PSoC blocks.","Thus, embodiments may build an interrupt vector table. In one embodiment, a call or jump to the user module's interrupt handler is inserted in a startup source file. The startup file may be run when the target device is re-booted. In this fashion, the proper interrupt handler will be called when its interrupt occurs during target device operation.  illustrates an interrupt vector table  with code which has been automatically added. In particular, the \u201cljmp\u201d instructions  have been added.","The exemplary table  in  shows how the startup source file vector names  map to the data sheet interrupt names  and to fixed and PSoC block (configurable) interrupts . For example, interrupt  maps to digital PSoC block \u201cDBA\u201d. Furthermore, it is of type PSoC block. Referring to , a ljmp to the counter_ ISR has been automatically placed in the vector table  at the location for PSoC block DBA. Referring now to , the ljmp was placed automatically to reflect the configuration having module  CNTR_MSB at digital block \u201cDBA\u201d. Other interrupt vectors have been automatically added to the interrupt vector table , as well.","Embodiments may automatically generate a datasheet. The user module  and device descriptions may be stored in XML format. Parameterization information regarding the project may be combined with the XML user module and XML device descriptions to generate an HTML output datasheet for the design. Any output format can be used. An Extensible Stylesheet Language (XSL) extension may be used to perform the combination according to a predetermined stylesheet that represents the datasheet. However, the present invention is not limited to XML, XSL, and HTML to implement automatically generated datasheets.","The datasheet in HTML can be viewed by a browser and may include expected information of a datasheet including pin-out information, schematics, connectivity, parameters, block information, signal information, etc.","By using XSL to generate the HTML output (datasheet) based on XML descriptions, embodiments are very adaptable to changes in any of the user module  descriptions. For instance, the automatic datasheet generation process can readily be adapted to new user modules  by the mere addition of their XML files into a user module library. No recompiling of the software tool is required.","Automatic generation of datasheets is described in co-pending U.S. patent application Ser. No. 09\/994,600, filed concurrently herewith, entitled \u201cSYSTEM AND METHOD FOR DYNAMICALLY GENERATING A CONFIGURATION DATASHEET,\u201d by Ogami et al., and assigned to the assignee of the present invention and incorporated herein by reference.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 14","b":["100","100","99","101","102","99","101","103","99","101","100","104","99"]},"With reference still to , system  of the present invention also includes an optional alphanumeric input device  including alphanumeric and function keys is coupled to bus  for communicating information and command selections to central processor unit . System  also optionally includes a cursor control device  coupled to bus  for communicating user input information and command selections to central processor unit . System  of the present embodiment also includes an optional display device  coupled to bus  for displaying information. A signal input\/output communication device  coupled to bus  provides communication with external devices.","The preferred embodiment of the present invention, a method for automatically generating APIs, Interrupt Vectors, source code for programming a microcontroller, and a datasheet for the circuit implemented in the microcontroller, is thus described. While the present invention has been described in particular embodiments, it should be appreciated that the present invention should not be construed as limited by such embodiments, but rather construed according to the below claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3A","FIG. 3B","FIG. 3C"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5A","FIG. 5B","FIG. 5C"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6A","FIG. 6B","FIG. 6C","FIG. 6D"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 7A\u20137C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 8A\u20138B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 9A\u20139B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 10","FIG. 11"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 12A","FIG. 12B"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 13A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 13B","FIG. 13A"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
