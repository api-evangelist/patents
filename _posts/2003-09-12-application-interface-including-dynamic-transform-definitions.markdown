---
title: Application interface including dynamic transform definitions
abstract: An application programming interface configured to transform data responsive to a transform process definition. The transform process definition is interpreted concurrently with the transformation process. This interpretation dynamically determines navigation within, and processing of, the data to be transformed. Under control of the transform process definition, a transform engine is configured to transform input data using recursive calls to a transformation process. The recursive approach is responsive to data structures within the transform process definition and simplifies operations such as parallel processing, load-balancing of transformation tasks, nesting, un-nesting, filtering, and the like.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07970779&OS=07970779&RS=07970779
owner: Oracle International Corporation
number: 07970779
owner_city: Redwood Shores
owner_country: US
publication_date: 20030912
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The invention is in the field of computer software and more specifically in the field of application interfaces.","2. Description of the Prior Art","Computing systems are benefited by their ability to exchange data between applications. In some cases, this ability is extended to allow one application to call functions within another application. For example, it is common for a word processing program to transfer data and execute functions of a printer driver. These functions are accessed using application programming interfaces (APIs) defined for the word processing program and the printer driver.","When disparate applications must communicate with each other it is not unusual to transform data as part of the communication. This transform converts data from a format generated by one application to a format understood by the other application. In some cases scripts are used to generate transformation code that is then executed to perform a transformation. Once transformation code is generated using a script, the script is no longer an active part of the transformation process. These scripts are usually written with a specific transformation in mind and must be rewritten for each new transformation. This process can require significant effort and often includes rewriting common sections of script.","An API can be somewhat more flexible when metadata is received as input. In these cases, transformation code can determine the type of data received and perform appropriate transforms and error checking. However, even when taking advantage of metadata, current transform methods suffer significant disadvantages. For example, transforms introduce a new potential source of error that can be difficult to debug. Prior art transforms tend to be single thread processes that start at the beginning of data to be transformed and continue to the end of the data in a serial manner. They are, therefore not configurable to take advantage of dynamic multi-thread computing. Further, this serial approach makes nesting and un-nesting operations difficult. Known transforms are performed using static code configured to simply map one data field to another. Even when the transform code is generated using a script, the transformation code is static at the time of execution and therefore not configurable for dynamic optimization of the transform process.","There is a need for new application program interfaces and data transforms that overcome these and other disadvantages of the prior art.","The invention includes systems and methods of transforming data communicated through an application programming interface. This data may include both commands configured to direct an application and parameters on which the application is configured to act. The transformation uses a transform schema (transform process definition) that dynamically directs the transform process as it is occurring, in addition to mapping input data fields to output data fields. Typically, the transform process definition is in the form of meta-language configured to be interpreted during the defined transformation. Through the systems and methods described herein, the versatility and ease-of-use associated with meta-languages may be imparted to application programming interfaces thus increasing the range of formats and data structures with which communication can occur.","The process of transforming data between various data formats and structures includes using the transform process definition and a transformation engine to interpret incoming data to be transformed, and to generate corresponding output data. In various embodiments, the data to be transformed is received in a metadata format. The metadata structure of the data to be transformed is configured for the transformation engine to identify data elements within the data to be transformed and to apply the transform process definition responsive to this identification. The transform process definition is selected from a transform schema using identification information found in the data to be transformed. The transform schema typically includes a set of one or more transform process definitions.","In various embodiments, the transform schema is also embodied in a metadata format, such as an extensible markup language (XML). In various embodiments, the transform schema is configured in a hierarchical data structure representative of levels of nested data records that will be reflected in output data. Typically, the hierarchical data structure is configured to be navigated as a tree data structure. As described further herein, these configurations are optionally used to direct recursive processes during a transformation. Thus, in addition to defining mapping of input data fields to output data fields, the transform process definition selected from the transform schema is a process definition, used by the transformation engine to direct a transformation process.","In various embodiments, the transformation process occurs in two steps. The first step includes identification of an appropriate transform process definition and addition of this transform process definition to the input data. The result of this step is a single data set including both the input data and part of the transform schema configured to direct the conversion of the data to be transformed to a desired output. In the second step, this single data set is processed by a transformation engine to generate the desired output.","Various embodiments of the invention include a data transformation system comprising a data interface configured to receive data to be transformed or to send transformed data, memory configured to store one or more transform process definitions having at least one simple transform definition and at least one compound transform definition, an application including computer instructions, and a data interpreter configured to exchange data with the data interface and the application, the data interpreter including a transform engine configured to select a transform process definition from the one or more transform process definitions, the selected transform process definition including a hierarchical data structure, concurrently navigate the selected transform process definition and the data to be transformed, navigation within the data to be transformed being responsive to transform definitions within the selected transform process definition, and generate output data having a data structure responsive to a data structure of the selected transform process definition.","Various embodiments of the invention include a data interpreter configured to transform data to be transformed, the data interpreter comprising at least one computing device, and a transform engine supported by the computing device, the transform engine being configured to access a transform process definition including a hierarchical data structure of transform definitions, the data structure including a simple transform definition and a compound transform definition, concurrently navigate the transform process definition and the data to be transformed, navigation within the data to be transformed being responsive to the transform definition within the transform process definition, and generate output data having a data structure responsive to the transform process definition.","Various embodiments of the invention include a method of transforming data using an application programming interface, the method comprising receiving data to be transformed at the application programming interface, parsing identification data within the data to be transformed, the identification data characterizing the data to be transformed using the identification data to select a transform process definition from a transform schema, the selected transform process definition defining a process of translating data elements within the data to be transformed to output data elements, and transforming the data to be transformed to output data, using a transformation engine and the selected transform process definition, a data structure of the output data being responsive to a data structure of the transform process definition.","Various embodiments of the invention include a method of transforming data using an application programming interface, the method comprising receiving data to be transformed at the application programming interface, the data to be transformed including identification data using the identification data to select a transform process definition from a set of transform process definitions, the selected transform process definition defining a process of translating data elements within data to be transformed to output data elements, and transforming the data to be transformed to output data by concurrently navigating the data to be transformed and the selected transform process definition, navigation in the data to be transformed being responsive to the transform process definition.","Various embodiments of the invention include a method of transforming data, the method comprising positioning a definition pointer to point at one of a plurality of transform definitions within a transform process definition reading the pointed at transform definition, searching data to be transformed for a data element to be transformed, the search being responsive to the pointed at transform definition, and transforming any found data element into output data, responsive to the pointed at transform definition, a data structure of the output data being responsive to a data structure of the transform process definition.","Various embodiments of the invention include a method of transforming data, the method comprising positioning a definition pointer to point at a transform definition, the transform definition being one of a plurality of transform definitions within a transform process definition, reading the pointed at transform definition, positioning a payload pointer to point at a data element to be transformed, the positioning being responsive to a data structure of the transform process definition, and transforming the data element into output data, responsive to the read transform definition.","Various embodiments of the invention include a method of preparing data for transformation, the method comprising receiving data to be transformed, parsing the received data to determine identification information, using the identification information to extract a transform process definition from a transform schema, the extracted transform process definition including a transform definition configured to transform the data to be transformed, to direct navigation within the data to be transformed during transformation, and to determine a data structure of output data resulting from transformation of the data to be transformed, the transform definition including a hierarchical data structure having at least one simple transform definition and at least one compound transform definition, the compound transform definition being configured to generate a compound data element in the output data, and adding the extracted transform process definition to meta-language transform input data including the data to be transformed.","Various embodiments of the invention include a computer readable media having embodied thereon data, the data comprising computer instructions configured to position a definition pointer to point at a transform definition, the transform definition being one of a plurality of transform definitions within a transform process definition, computer instructions configured to read the pointed at transform definition, computer instructions configured to increment a payload pointer, within the data to be transformed, to a data element to be transformed, the incrementation being responsive to the pointed at transform definition, and computer instructions configured to transform any found data element into output data, responsive to the pointed at transform definition, a data structure of the output data being responsive to a data structure of the transform process definition.","Various embodiments of the invention include a computer readable media having embodied thereon data, the data comprising payload data including data to be transformed, the data to be transformed including metadata characterizing simple data elements and compound data elements, and a transform process definition including a transform definition configured to transform the data to be transformed, to direct navigation within the data to be transformed during transformation, and to determine a data structure of output data resulting from the transformation, the transform definition including a hierarchical data structure having at least one simple transform definition and at least one compound transform definition, the compound transform definition being configured to generate a compound data element in the output data.","Various embodiments of the invention include an application system comprising means for positioning a definition pointer to point at a transform definition within a transform process definition, means for reading the transform definition, means for positioning a payload pointer to point to a first data element, the first data element being a member of a plurality of data elements within data to be transformed, and means for generating output data using the first data element and the transform definition.","The invention includes a data interpreter configured to interpret data stored in a variety of data structures. The data interpreter may be integrated into an application or alternatively be part of an application programming interface used by one or more associated applications. The data interpreter includes a transformation engine configured to transform data from one data structure to another under the control of a transform process definition. In some instances this transformation includes transforming received data into a format that can be directly read by a first application and in some instance this transformation includes transforming output data of the first application to a format intended for a second application.","The transformation process performed by the transformation engine is defined and controlled by a structured transform process definition. In typical embodiments, this transform process definition includes a hierarchical set of nested records defining specific transforms for specific data types. The transform process definition also includes information configured to control navigation within the data to be transformed, to select data elements to be transformed, to determine a structure of the output data, or the like. The transform process definition is optionally reentrant and can thus have multiple simultaneous, interleaved, or nested invocations that do not interfere with each other. As further described herein, the reentrant property is useful to embodiments of the invention that include parallel processing and\/or recursive functions. In some embodiments, the transform process definition is defined in extensible markup language (XML).","During the transformation process the structured data to be transformed and the structured transform process definition are traversed concurrently. The transform process definition is traversed linearly from beginning to end while parts of data to be transformed are traversed as directed by the transform process definition to perform the transformation. In various embodiments, traversal of the transform process definition results in initiation of parallel processes that are configured to transform specific parts of the data to be transformed. As described further herein, these parallel processes are optionally defined by the data structure of the transform process definition.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1","b":["100","100","110","120","130","140","110","120","110","110"]},"Data Interpreter  includes computer instructions configured to exchange data through Data Interface  and to exchange data with one or more Application  included in Application System . In some embodiments, Data Interpreter  is integrated into Application . In some embodiments, one Data Interpreter  is configured to operate as an application programming interface to more than one Application . Data Interpreter  further includes a Transform Engine  configured to identify and use an Active XML  to transform data. Active XML  is a transform process definition selected from Transform Schema  stored in Memory . Data Interpreter  includes one or more computing devices configured to support Transform Engine  and optionally to support Application .","Application  is typically a set of computer instructions configured to execute on Application System . For example, in various embodiments Application  is a database application, accounting application, human resources application, customer management application, inventory application, internet application, or the like. In some embodiments, Application  executes on a computing device other than those computing device(s) configured to support Data Interpreter  or including Memory . Application  is optionally configured to receive transformed data from Data Interpreter  and\/or to provide data to be transformed by Data Interpreter .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","120","200","220","230","220","200","200","200","200","220","200"]},"Payload Data  includes data to be transformed using Data Interpreter . Typically, the format of Payload Data  is characterized by Instruction Data  or by metadata within Payload Data . Payload Data  optionally includes structured data types such as nested data records and\/or a tree structure.","As discussed further herein, in some embodiments, Active XML  is added to any Instruction Data  prior to transformation using Transform Engine . In these embodiments Transform Engine  is optionally divided into two components. A first component configured to select Active XML  from within Transform Schema  and add the selected Active XML  to Instruction Data , and a second component configured to transform the resulting Meta-language Transform Input Data . These two components are optionally executed on different computing devices. In some embodiments, the second component is integrated with Application  while the first component is not.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIGS. 3A-3F","FIGS. 3A-3F","FIGS. 4A-4B","FIGS. 5A-5D","FIGS. 4A-4B","FIGS. 3A-3F","FIGS. 3A-3F"],"b":["4","4","5","5","200","160","170","4","4","5","5"]},"The data illustrated in  include nested metadata records configured to store data characterizing a person. Data of this nature may be included in Meta-language Transform Input Data .  line  through  line  are a representative example of Instruction Data .  line  identifies the start and content of Meta-language Transform Input Data .  line  through  line  define the data field types found in Payload Data .  line  through  line  comprise a representative example of Payload Data .","The embodiment of Payload Data  shown in  includes at least two types of data elements, compound elements and simple elements. For example,  line  includes a simple element with name BIRTHDATE and including a value \u201c1953-10-14.\u201d  line  includes information indicating that the simple element BIRTHDATE is configured to hold data of type DATE, thus indicating a type for the value \u201c1953-10-14.\u201d In another example,  lines  through  include a compound element ADDRESSES of class=R (for record). This element is a record including sub-elements EMPLID, ADDRESS_TYPE, CITY, etcetera. In some embodiments, data to be transformed includes several layers of elements and nested sub-elements. Each element is defined by a start tag and an end tag. For example, line  includes a start tag <ADDRESSES class=R\u2033> and a corresponding end tag <\/ADDRESSES> is found at line . Transform Engine  is configured to determine the start and end of a data element using these tags. An end tag, without a start tag, is optionally used to indicate when no value is present in a field. See, for example,  line . Payload Data  includes records configured to control auditing functions. See for example,  lines  through . The PSCAMA record includes a AUDIT_ACTN element that is optionally set to indicate if the prior record has been added, changed or deleted.","The data illustrated in  is an illustrative example of Active XML . Active XML  optionally includes both simple transform definitions and compound transform definitions configured to result in simple data elements and compound data elements in the transformed data output, respectively. Typically, compound transform definitions include sub-definitions configured to define sub-elements in the transformed data output.","The bulk of the data included in Active XML  has been identified and selected from Transform Schema  for use in a particular transformation (i.e., transformation of the data shown in .  line  through line  include identification and version data). This line identifies the start of a compound data element in which the transform process definition is embodied. Further data, retrieved from Transform Schema , based on identifying data found in the Meta-language Transform Input Data , starts at  line . This line identifies other characteristics of the transformation, such as that it is configured for \u201cIA\u201d (inbound asynchronous) data. Transform Schema  typically includes data defining more than one type of transformation that may be selected for inclusion in Active XML  based on the data type, data source, direction of data transmission, or the like. However, in a typical embodiment, only the transform process definition necessary to perform a particular transformation is selected from Transform Schema  for inclusion in Active XML . Active XML  may be stored temporarily as needed to perform a transformation.","The Active XML  illustrated in  includes definitions for transformation of both data structures and data values. These transformations are defined from  line  through  line . Structural transformations optionally include reordering or records, filtering of records, elimination of records, addition of records, nesting and un-nesting of data structures, or like operations. Data value transformations optionally include removal of values substitution of values, or addition of values.","Active XML  illustrated in  further includes dynamic functions configured to be interpreted during the transformation process. A dynamic function is illustrated in  lines -. Dynamic functions are optionally configured to perform logic operations, external process calls, or other operations associated with a computer function and to transform payload Data  in response.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIGS. 5A-5D","FIGS. 4A-4B","FIGS. 3A-3F"],"b":["150","160","200","150","200","160","200","160","160","220","200","150","200"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 6","b":["200","170","200","200","160","230","160"]},"In a Receive Input Step , Transform Engine  receives Meta-language Transform Input Data  from Application  or through Data Interface . Typically, data received from Application  is to be transformed to a format desired by an application external to Application System . Likewise, data received through Data Interface  is typically to be transformed to a format compatible with input to Application .","In a Parse Identification Information Step , Meta-language Transform Input Data  is examined for identification data, such as the data included in Instruction Data . This information may include, for example, the message name \u201cPERSON_BASIC_FULLSYNC\u201d at  line  and  line , the source information, the destination information, or the like. In some embodiments of Parse Identification Information Step , field types ( line  through  line ) are also noted.","In Extract XML Step , identification data, and optionally field type data, found in Parse Identification Information Step , are used to extract transform process definitions from Transform Schema . The extracted transform process definitions are included in Active XML . For example, in various embodiments, a transmission type of IA will result in extraction of transform definitions for a transformation type of IA. Field types information is optionally used to select the transform definitions at greater granularity (e.g. extracting only those transform definitions corresponding to the field types noted in Parse Identification Information Step ).","In an Add XML Data Step  the transform definitions extracted from Transform Schema  are added to Meta-language Transform Input Data . In some embodiments, the transform definitions are added to Instruction Data . The resulting data set includes both the original Meta-language Transform Input Data  to be transformed and a process definition (the added Active XML  transform definition) configured to perform the transformation. In some embodiments, the resulting data set is transferred to another computing device before transformation. For example, in some embodiments the Meta-language Transform Input Data  to be transformed is received from Application , Active XML  is added using the method illustrated by , and the resulting data is sent to an application external to Application System . The receiving application may interpret the received data using the included Active XML  process definition. In some embodiments, the resulting data set is transformed prior to being sent to an application external to Application System . In some embodiments, the resulting data set is stored on computer readable media such as memory included in Data Interface  or a hard drive. Further details of transformation processes are described with respect to .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["230","160","160","160","150","230","160","160"]},"In a Position Definition Pointer Step  the definition pointer is positioned to point at the next data element within Active XML  to be executed. Position Definition Pointer Step  is optionally responsive to how the process of  is initiated. For example, in some embodiments, when the process of  is invoked at the start of a transformation process, Position Definition Pointer Step  includes positioning the definition pointer to point at the first transform definition within Active XML  ( lines -). When the process of  as invoked through a Recursive Call Step , discussed further herein, Position Definition Pointer Step  typically includes positioning the definition pointer to the first transform definition within a compound transform definition. For example, the definition pointer may be moved from the compound transform definition at  line  to the first sub-element of that compound transform definition at  line . When the process of  is invoked immediately following initiation of a parallel processing thread, Position Definition Pointer Step  optionally includes positioning the definition pointer to point at the next transform definition at the same level of the data structure as the current transform definition in Active XML . For example, the definition pointer may be moved from the compound transform definition at  line  to the compound definition at  line , skipping the sub-definitions of the compound transform definition at  line . In these embodiments, the parallel processing thread is typically configured to transform the skipped sub-definitions.","In a Read Transform Definition Step , the transform definition to which the definition pointer is pointed is read. For example, if the definition pointer is pointed to the transform definition at  line , then \u201c<LM_PERSON class=\u201cR\u201d source_record=\u201cPERSON\u201d>\u201d is read. This transform definition characterizes an output field having a field name of LM_PERSON. The value of \u201cR\u201d for \u201cclass\u201d indicates that this transform definition is a compound transform definition and not a simple transform definition. The \u201csource_record\u201d parameter indicates that data to be transformed should be retrieved from a compound element \u201cPERSON\u201d in Payload . In various embodiments, the transform definition read in Read Transform definition step  may include other parameters such as \u201cvalue,\u201d \u201ctype,\u201d \u201csource_field\u201d and \u201ctranslation_codeset.\u201d Examples of these parameters are found on  lines , , and . The value parameter is used to specify a value for an output data element in the transformed data output. Typically, when a value parameter is included, Payload  is not examined for a value to place in the output data element. However, in some embodiments, the value specified using the value parameter is a default value that may be replaced if an alternative value is found in Payload . The type parameter is used to define a type of the data included in the output data element. The source_field parameter is used to indicate a data element in Payload  wherein a value for the corresponding output data element should be found. The translation_codeset parameter is used to identify a set of computer instructions configured for performing logical operations on data within Payload . An example of these computer instructions is shown on  lines  through .","In a Position Payload Pointer Step  the payload pointer is positioned within Payload . This step is only necessary if the transform definition read in Read Transform definition Step  included a source_field, source_record, or other parameter indicating that data is needed from Payload  in order to generate the transformed data output. The payload pointer is incremented from a prior position until a data element corresponding to the source_field parameter or source_record parameter is found. The incrementation (search) continues until the corresponding data element has been found, or all data elements at the same level as the current data element have been searched. (E.g, from the last data element in a compound record the payload pointer will be incremented to the first data element and then continue until it returns to its starting position unless the desired record is found.) For example, if the payload pointer is pointed to  line , then the current data element is EMPLID and a search for a source_field named MAR_STATUS would result in incrementing the payload pointer to  lines ,  and then .","The prior position of the payload pointer is optionally dependent on how the process of  is initiated. For example, when the process of  is invoked at the start of a transformation process, the payload pointer typically starts by pointing at a root node of Payload Data  (i.e.,  line ). When the process of  as invoked through a Recursive Call Step  or immediately following initiation of a parallel processing thread, the prior position of the payload pointer is determined by the previous execution of Position Payload Pointer Step .","In some embodiments the position of the payload pointer following Position Payload Pointer Step  is dependent on the current data element and the position of the payload pointer prior to this step. For example, if Transform Engine  seeks a source field EFFDT in Payload , the payload pointer may be set to point to  line ,  line ,  line , or  line , responsive to the location of the current data element.","In a Perform Transformation Step  Transform Engine  uses the transform definition in Active XML  to which the definition pointer is pointed to transform the data element to which the payload pointer is pointed. Perform Transformation Step  is only required if the transform definition read in Read Transform definition Step  included a source_field, source_record parameter or other parameter requiring data from Payload . If the payload pointer is pointed to  line  (EMPLID) and the definition pointer is pointed to  line  then the data value (\u201cB-BARET100\u201d) found in the data to be transformed is transferred to the LM_PERSON_ID field of type char in the transformed data output. The result is illustrated in the transformed data output at  line .","Transformations can be applied to either simple elements or compound elements. For example, if the payload pointer is pointed to the PERSON element of  line  (a compound element) and the definition pointer is pointed to the <LM_PERSON class \u201cR\u201d source_record=\u201cPERSON\u201d> transform definition ( line ), then the source record \u201cPERSON\u201d is transformed to a new record having a name LM_PERSON. This new record includes data fields configured to hold the data defined by Active XML  between  line  and  line .","Where a \u201cvalue\u201d is specified for a particular data field, that value is stored in the new field or record. For example, the data field \u201cLM_COMM_METHOD\u201d (a simple data element) has a data type of \u201cCHAR\u201d and is populated with a value \u201cEMAL\u201d ( line ). This value is placed in the transformed data output (see  line ). In some embodiments, data found in the transformed data does not have corresponding data elements in the data to be transformed. For example, at  line  Active XML  defines a field LM_EXT_PERSON_FLG of type CHAR with a value of \u201cN\u201d. A resulting field is found at  line  of the transformed data output. There is no corresponding data element in the data to be transformed as shown in . As discussed further herein, fixed values are populated into data fields as each transform definition is process by Transform Engine . New fields defined by Active XML  do not necessarily need to contain default values. See, for example, the Active XML  at  line  and resulting transformed data output at  line .","Where a \u201csource_field\u201d is specified for a transform definition in Active XML , a value is expected to be found in the data to be transformed, such as that illustrated in . For example,  line  indicates PER_STATUS as a source field for a LM_PER_STATUS data field in the transformed data output. At  line  the PER_STATUS field includes a value of \u201cE\u201d. During Perform Transformation Step  this value is inserted into a new field LM_PER_STATUS (see  line ).","Where there is no corresponding transform definition within the current element the data element found in the data to be transformed has no contribution to the transformed data output. For example, . line  includes an MAR_STATUS field as part of a PERS_DATA_EFFDT record. However, the Active XML  of  does not use this field as part of a corresponding transform record LM_PERSON_EFFDT (see  line  through  line ). In typical embodiments, only instances of the MAR_STATUS field associated with the current data element are considered in Active XML . Thus, instances of any MAR_STATUS transform definition outside of the LM_PERSON_EFFDT transform record are not used to define transformation of the MAR_STATUS found within the LM_PERSON_EFFDT compound element ( line ).","In a Compound Definition Step  the type of the transform definition read in Read Transform definition Step  is determined. If this transform definition is a compound definition then the method proceeds to a Recursive Call Step . If this transform definition is a simple definition then the method proceeds to an End of Element Step .","In Recursive Call Step , a recursive call is made to the process illustrated by  in order to process sub-definitions within the compound transform definition. Typically, this call includes defining a new payload pointer and a new definition pointer associated with the new process. The initial positions of these pointers are set to the positions of the previously existing payload and definition pointers associated with the parent process that executes Recursive Call Step . In alternative embodiments, Recursive Call Step  is replaced by a series of steps performing similar operations, but without the use of recursion.","In End of Element Step , Transform Engine  determines if all sister transform definitions at the level of the current transform definition (the transform definition at which the definition pointer is pointing) have been processed. If so, then the process proceeds to a Return Step  wherein execution is returned to the function that called the current process of . For example, if the current process was invoked by a Recursive Call Step , performed in a parent process, then execution returns to this parent process in Return Step . If the current process was a parallel process spawned by a parent process the spawned process is optionally terminated in Return Step . A set of sister transform definitions can be found from  lines  through line . In some instances a source record is found more than once in Payload Data . For example, ADDRESSES records are found at both  lines  and . Processing of the compound transform definition of  line  is not complete until both instance of these ADDRESSES records have been transformed.","If, in End of Element Step , Transform Engine  determines that all sister transform definitions in the level of the current transform definition are not completed, then the process returns to Position Definition Pointer Step . All of the sub-elements of a compound transform definition are transformed before the compound transform definition is considered completed. For example, when sub-definitions of the compound transform definition shown in  lines  through  are being processed, End of Element Step  will return a value of YES only when all of the sub-definitions shown on  lines  through  are processed. Typically, this will have occurred when the end tag at  line  is reached by the definition pointer. Likewise, the compound transform definition beginning at  line  is not completed until the sub-definitions of lines  through  are completed.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIGS. 3A-3F","FIGS. 4A-4B","FIG. 7","FIG. 4A","FIG. 4B","FIG. 3C","FIG. 7"],"b":["4","4","5","5","150","160","710","16","72","720","160","730","146","750","720","760"]},"In some embodiments, during the first execution of the process of , the payload pointer and definition pointer will be positioned at  line  and  line  after Position Definition Pointer Step  and Position Payload Pointer Step  are executed, respectively. Since the transform definitions from  line  through  line  are simple transform definitions, the process of  will loop through Perform Transformation Step  and End of Element Step  until the compound transform definition at  line  is reached. At this transform definition, a new process is invoked to apply the sub-definitions within the compound definition LM_PERSON_EFFDT. The end of the LM_PERSON_EFFDT compound definition is reached and the new process is terminated at  line . Termination occurs when End of Element Step  results in \u201cYES\u201d and Return Step  is executed. The parent process continues with the transform definition at  line .","In this illustrative example each Recursive Call Step  spawns a new process. This is typical of embodiments wherein parallel processing is available. Using parallel processing, a parent process can continue to the next transform definition at the same level without waiting for a daughter process to return. Thus, in the above example, if the new process is executed in parallel with its parent process, then the transform definition at  line  may be processed concurrently with transform definition at  line . In alternative embodiments, each Recursive Call Step  does not spawn a new process. In these embodiments, a single process calls computer instructions configured to perform the step shown in  in a recursive manner and a single pair of payload pointer and definition pointer are optionally used.","In some embodiments, Transform Engine  is used to create new elements in the transformed data. For example, in the embodiment of Active XML  illustrated in , a transform definition for creating a new simple element in the transformed data output is found on  line . As discussed further herein, this transform definition results in the new simple element shown in  line .","In another example, in the embodiment of Active XML  illustrated in , the transform definition for creating a new compound element in the transformed data output is found on  lines  through . These lines define a compound data element LM_PERSON_OPRID including sub-elements LM_PERSON_ID and OPRID. The empty value for source_record in  line  indicates that this compound element is not dependent on a record within the data to be transformed. The field LM_PERSON_ID is specified to have a default value of \u201c0\u201d and the OPRID field is specified to be of type CHAR without a non-NULL default value. In the transformed data output the resulting data is shown at  lines  through .","In some embodiments, Transform Engine  is configured to change the order or hierarchy of data elements. For example, the order of sub-elements within a record may be sorted differently in Active XML  than in the data to be transformed. The order found in Active XML  is reflected in the transformed data output.","In some embodiments, Transform Engine  is configured to merge data elements. For example, the transform definition shown in  lines  and  includes both a source_field and a source_record. The indication of a source_record overrides the default source record ADDRESSES for the current transform definition as indicated in  line . The resulting transformed data output is illustrated at  lines  and . The data element of  line  had been merged with the compound element starting at  line .","In some embodiments, Transform Engine  is configured to nest data elements. For example, in Payload Data  as shown in  there are two compound elements PERS_DATA_EFFDT and NAMES at the same hierarchical level (See  lines  through  line  and  line  through  line , respectively). In the Active XML  of  the source_record NAMES is used to define a sub-element of new record LM_PERSON_EFFDT which is based on the source_record PERS_DATA_EFFDT (See  lines  and , respectively). In the transformed data output data that was at the same hierarchical level in Payload Data  are now nested in the new compound element LM_PERSON_EFFDT (See  at line ).","In some embodiments, Transform Engine  is configured to un-nest data elements found in Payload Data . In this process an element at a lower level in the data structure of Payload Data  is placed at a higher lever in the transformed data output. In this process a compound element can become a sibling (same hierarchical level) element to one of its former sub-elements, thus flattening the data structure. For example, the Payload Data  shown in  line  includes a sub-element PERS_NID of compound element PERSON (starting on  line ). In the Active XML  illustrated in  line  and  line  these data elements are used in defining new elements LM_PERSON ( line ) and LM_PERS_NID ( line ) at the same hierarchical level.","In alternative embodiments, un-nesting is accomplished by specifying both a compound element and a sub-element of that compound element within a source_record or source_field. For example, one embodiment of Active XML  includes LM_FLATTENED_ID type=\u201cCHAR\u201d source_field=\u201cPERSON.STUDENT_ID\u201d, where PERSON is a compound element in the data to be transformed and STUDENT_ID is a sub-element of PERSON.","As illustrated herein, the transformations defined by Active XML  optionally include changing the names (namespace) of simple elements and compounds. In various embodiments the same approach is used to change the namespace of an entire Meta-language Transform Input Data . For example, the transform definition included in  lines  and  are configured to change the name of the message within Payload Data  from PERSON_BASIC_FULLSYNC to LM_PERSON_BASIC_FULLSYNC.","In various embodiments, transform definitions, included in Active XML , include further advanced functions configured to perform logic operations. For example, in some embodiments, value translation optionally includes a call to a function. The Active XML  illustrated in  includes a function call at  line  and  line . The parameter \u201ctranslation_codeset\u201d is used to specify a function labeled COUNTRY_CODESET. The definition of this function is typically found elsewhere in Active XML . In the illustrated example the definition is at  lines  through . The value of the element COUNTRY (\u201cUSA\u201d) is passed to this function from Payload Data  at  lines  or . Using the computer instructions included in  lines  through , the value USA is transformed to \u201cUnited States of America\u201d and a new leaf element is created for STATE that holds the transformed value \u201cCalifornia.\u201d The translation_codeset COUNTRY_CODESET includes a call to an external codeset PS_COUNTRY01. (PS_COUNTRY01 is, for example, a pointer to a function or a lookup table.) Through this call, or similar calls, Active XML  can invoke a variety of dynamic internal or external operations to process the data to be transformed.","For example, in some embodiments, Data Interpreter  is used as a security filter that restricts communication of selected data elements to or from Application . In these embodiments, external operations are optionally used to confirm user or device identity and\/or the Active XML  derived from Transform Schema  is responsive to the user or device identity.","Several embodiments are specifically illustrated and\/or described herein. However, it will be appreciated that modifications and variations are covered by the above teachings and within the scope of the appended claims without departing from the spirit and intended scope thereof. For example, the transform definitions are optionally configured in a hierarchical data format other than XML and the structures of Payload Data  do not have to be nested and\/or hierarchical."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTIONS OF THE VARIOUS VIEWS OF THE DRAWING","p":[{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 3A-3F"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 4A-4B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 5A-5D","FIGS. 4A-4B"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
