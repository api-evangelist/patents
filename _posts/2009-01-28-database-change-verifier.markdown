---
title: Database change verifier
abstract: A method and system for automatically verifying a change to a database. An input file including a test query for the database and an expected output from executing the test query is received. The test query is automatically executed on the database. An actual output resulting from executing the test query is retrieved. Based on a comparison between the actual output and the expected output, a match or mismatch between the actual output and the expected output is automatically identified. If a mismatch is identified, a failure indication is stored that indicates that the database change is invalid and that the database change may initiate a defect in an application coupled to the database. In one embodiment, the change to the database is a change in a services engagement. In one embodiment, the test query is automatically generated in the method and system described above.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07953744&OS=07953744&RS=07953744
owner: International Business Machines Corporation
number: 07953744
owner_city: Armonk
owner_country: US
publication_date: 20090128
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to a technique and tool for verifying database changes and more particularly to a technique and tool for verifying database changes for services engagements.","During the lifecycle of web development projects, application database changes occur that are either structural changes or changes to data in particular tables. Database changes are made, but human error (e.g., by a database administrator) that fails to propagate database changes to subsequent environments introduces defects in the application. The defects may bring down a web page or a website may work in an unexpected way. Conventional techniques for verifying database changes include manual verification of database changes in every environment, from local environment to test environment, and to production environment until the application is delivered. Such manual verifications are labor-intensive, expensive, require high-level skills, and are prone to human error. Other conventional verification techniques that compare an installed schema with a last working schema lack support for one or more types of database verification, and therefore have limited ability to test certain aspects of a database change. Thus, there exists a need to overcome at least one of the preceding deficiencies and limitations of the related art.","In first embodiments, the present invention provides a computer-implemented method of automatically verifying a change to a target database. The method comprises:","a computer system receiving an input file that indicates a change to a target database, wherein the input file includes a test query for the target database and a predefined output expected from executing the test query on the target database;","the computer system automatically executing the test query on the target database subsequent to receiving the input file;","the computer system retrieving an actual output resulting from automatically executing the test query;","the computer system comparing the actual output with the predefined output;","the computer system automatically identifying a mismatch between the actual output and the predefined output based on a result of comparing the actual output with the predefined output; and","the computer system storing an indication of a failure in a computer data storage unit, wherein the failure indicates the mismatch, and wherein the failure further indicates that the change to the target database is invalid and the change to the target database initiates a defect in an application coupled to the target database.","In second embodiments, the test query in the above-summarized method is automatically generated.","A system, computer program product, and process for supporting computing infrastructure corresponding to the above-summarized methods are also described and claimed herein.","In one or more embodiments, the present invention provides a platform-independent technique for automatic database change verification for services engagements that allows for early detection of application defects due to schema or data changes in a database and detection of such defects in any environment (i.e., phase) of an application coupled to the database.","Overview","In one or more embodiments, the present invention may provide a platform-independent technique for automatic verification of database changes for services engagements. In other embodiments, the present invention may provide a platform-independent technique for automatic verification of database changes that is not limited to services engagements. As used herein, a verification of database changes includes a determination that a database change is valid based on predefined expected results or a determination that a database change is invalid based on predefined expected results. The system and method described herein accepts test queries and expected output of the test queries, and executes the test queries on a target database in order to determine if database changes are correct based on whether actual output of the test queries match the expected output. In one embodiment, the test queries are generated and provided by users of the disclosed system. In another embodiment, the test queries are automatically generated and provided by a test query generator. For example, a database change is performed by the following Structured Query Language (SQL) query:","Create table xyz col, col, . . .","The test query for this example is \u201cdescribe table\u201d and the expected output is \u201ctable name, column name\u201d. It should be noted that embodiments of the present invention base the automatic verification of database changes on test queries and expected output, and therefore differ from known data integrity methods that rely on checksums, cryptographic authentication codes, MD5 hash values, and integrity constraints such as entity integrity, referential integrity, and domain integrity.","The technique disclosed herein may allow for an early detection of application defects due to database schema or data changes, rather than a discovery of defects during later phases of a development project (e.g., during a testing phase, post production delivery phase). Moreover, embodiments of the present invention provide for collective verification of all database changes for a particular application and automatic verification on different environments in the development of an application (e.g., local, development, integration, testing, staging (pre-production), production, etc.). The embodiments of the present invention may reduce or eliminate a need for manual efforts to verify database changes. Furthermore, in one or more embodiments, the verification features of the present invention are beneficial for services engagements in which there is a tight coupling between an application and a database, there are different groups working on a database end and an application end, and\/or there are frequent enhancements to database schema or data and same or similar changes are to applied to different environments. Still further, one or more embodiments of the present invention are advantageously employed during deployment of an application so that application code is deployed only in response to determining that database changes are valid by the database change verification process disclosed herein.","As used herein, a database change is a change to a structure (i.e., schema or meta data) of a database or a change to existing data or an existing table of a database. Examples of database changes include creating a new database table, changing a primary key, adding a trigger, inserting a row into an existing table, adding columns to an existing table, and putting critical business configurations in tables. Examples of verifying a database change include verifying whether a new table has been created, validating the structure of a newly added table, determining whether a primary key is correct, determining whether a trigger has been created, determining whether a particular row has been inserted into an existing table, determining whether a particular business configuration is inserted correctly in a particular row of a table, where this business configuration is specific to a particular environment, and verifying if a particular trigger is functionally working by executing the trigger.","As used herein, a database change to meta data is defined as a database change to the schema of a database and includes adding a new table, adding a new column to an existing table, adding a default value on a column, and malting a column nullable.","As used herein, a trigger (a.k.a. database trigger) is defined as procedural code that is executed whenever a particular event happens on a table of a database.","Automatic Database Change Verification System",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","102","104","104","106","108"]},"Inputs configuration  includes test queries and expected test result data (i.e., expected results of running the test queries; a.k.a. expected output). In one embodiment, the test queries and the expected test result data in inputs configuration  are predefined by one or more users. For example, the input file that provides input to DCV program  is an Extensible Markup Language (XML) file (e.g. input.xml). The XML input file may have, for example, a Database Change Request (DCR) tag (i.e., <DCR>) that can be used to track the number of database changes associated with a particular requirement. As used herein, a DCR refers to any request for a database change.","In one embodiment, the test queries and expected test result data included in inputs configuration  are provided by one or more users of computer system . In another embodiment, the test queries are automatically generated.","Database connection configuration  includes information required by DCV program  to obtain a connection (e.g., Java Database Connectivity (JDBC) connection) to a database  (a.k.a. target database). Inputs configuration , database connection configuration  and database  are stored in one or more computer data storage units (not shown) coupled to computer system . In one embodiment, the test queries included in inputs configuration  are SQL queries and database  is capable of executing SQL queries.","Based on input from inputs configuration , DCV program  selects and fires an appropriate test query to database  or receives required meta data from database . In one embodiment, DCV program  queries database  via a JDBC application programming interface (API) (i.e., database  is JDBC compliant). DCV program  processes the results of the test query or meta data to generate a results file  (i.e., an output log file). Results file  is a computer data file (e.g., text file) that includes a status (e.g., Success or Failure) of each test query. The functionality of each component of system  is described in more detail in the discussion of  presented below.","In one embodiment, system  is developed in Java\u00ae and utilizes XML files in inputs configuration  and database connection configuration  so that the system is platform independent.","Automatic Database Change Verification Process",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 1"],"b":["200","104","202","204","206","208","210"]},"In one embodiment, prior to step , DataChangeVerificationProcess  receives the arguments Target Environment, UserName, and Password. The Target Environment argument is the target environment against which the database changes are to be verified. UserName is the User identifier (Userid) used to connect to the target database  (see ). Password is the password associated with the Userid that is used to connect to the target database. DataChangeVerificationProcess  validates the aforementioned arguments. The validation of the arguments includes checking if the arguments provided by the user are null or empty and returning an appropriate error message to the user. Furthermore, the validation of the arguments includes verifying if the Target Environment provided by the user is included in a predefined list of valid environments stored in database connection configuration  (see ). If DataChangeVerificationProcess  determines that the arguments Target Environment, UserName and Password are valid, then DataChangeVerificationProcess  performs step .","In step , DataChangeVerificationProcess  retrieves a resource bundle from database connection configuration  (see ) and sends a createConnection message to DCRConnectionManager . The retrieved resource bundle includes database configuration information that allows DCV program  (see ) to access database  (see ). In one embodiment, the retrieved resource bundle is based on the target environment and includes a user identifier and password used to connect to database  (see ). Sending the createConnection message in step  requests a connection between DCV program  (see ) and database  (see ) using DCRConnectionManager . In step , DCRConnectionManager  establishes the requested connection between DCV program  (see ) and database  (see ).","In step , DataChangeVerificationProcess  sends a message to InputXmlProcessor  that results in a retrieval of an input file from inputs configuration  (see ). InputXmlProcessor  reads and parses the retrieved input file in step . Also in step , InputXmlProcessor  retrieves a test query and expected test result data from the parsed input file and stores the retrieved test query and expected test result data in input classes (i.e., data input objects) of a database residing on a computer data storage unit. Examples of input classes are discussed below relative to . In one embodiment, in step , DataChangeVerificationProcess  identifies a particular type of database change associated with the retrieved test query and expected test result data. The type of database change identified may be a change to (1) master data, (2) meta data, or (3) a database trigger. As used herein, master data is defined as data that is either business configuration data (i.e., data that changes over environments) or base data (e.g., country or currency).","In one embodiment, step  includes the DataChangeVerificationProcess  creating a hash map of the data input objects. Furthermore, in a first embodiment, a test query retrieved in step  is initially generated prior to step  by a manual process that provides the test query to inputs configuration  (see ). In a second embodiment, a test query retrieved in step  is generated by an automated process prior to step , where the automated process is described below relative to . In a third embodiment, a test query retrieved in step  is generated prior to step  by the aforementioned manual process or by the aforementioned automated process.","In step , InputXmlProcessor  sends a response message to DataChangeVerificationProcess , where the response message includes the data input objects that include the test query and the expected test result data corresponding to the test query (i.e., the results of parsing the input file).","In step , DataChangeVerificationProcess  sends a verify message to DataVerifier , which initiates a verification procedure (i.e., determines whether or not a database change in database  (see ) is verified). In step , the verify message includes the test query and expected test result data that were sent in step .","In one embodiment, the verify message passes the data input objects to a particular verifier class based on the type of database change identified in step . DataChangeVerificationProcess  may receive the aforementioned hash map of all input data. From the hash map, a method in DataChangeVerificationProcess  filters a particular type of database change and passes the database changes of that type to a corresponding verifier class (e.g., a class that verifies master data changes in the target database, a class that verifies meta data changes in the target database, or a class that verifies database trigger changes in the target database). Each of the types of verifier classes implements a verify method from a base class (see DataVerifier class  in ) to perform the desired database change verification per the type of verifier. The verify method is overridden by all the verifier classes for each type of database change.","Depending on the type of database change identified in step , a DataVerifierFactory class (not shown) returns an instance of a particular DataVerifier class. Different DataVerifier classes are described below relative to . In one embodiment, all of the different DataVerifier classes are singleton classes.","In one embodiment, in step , the verify message specifies that the verification of the database change occurs on the environment identified by the target environment argument described above.","In step , DataVerifier  sends a response message to DataChangeVerificationProcess , where the response message includes an indication that the database change is verified (e.g., a result of a test query is a success) or an indication that the database change includes a defect (e.g., a result of test query is a failure). The actions performed in steps  and  are described in more detail in the discussion presented below relative to .","In step , DataChangeVerificationProcess  sends a closeConnection message to DCRConnectionManager  to initiate a closing of the connection created in step . In step , DCRConnectionManager  sends a response to DataChangeVerificationProcess , which results in a completion of the closing of the connection created in step .","In step , DataChangeVerificationProcess  sends a generateOutput message to OutputLogGenerator . OutputLogGenerator  generates results file  (see ). In step , OutputLogGenerator  sends a response to DataChangeVerificationProcess , where the response includes results file  (see ). Results file  (see ) includes an indication that the database change is valid (i.e., results of the one or more test queries successfully matched the corresponding expected test result data) or an indication that the database change is invalid (i.e., at least one test query result failed to match the corresponding expected test result data) and that a defect in an application coupled to database  (see ) exists. DCV computer system  (see ) stores results file  (see ) in a computer data storage unit (not shown in ). Following step , if the database change is invalid, results file  (see ) is displayed to a user (e.g., on a display device), and the user corrects the defect in the application by modifying the database change (e.g., modifying the SQL command in a query that provided the database change, modifying parameters of the SQL command in the query that provided the database change, modifying a trigger of the target database, and\/or modifying attributes of the target database).","It should be noted that the names of components , , ,  and  and the names of commands described in this section are merely examples-the present invention contemplates embodiments in which different names are used.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3","FIG. 2","FIG. 2","FIG. 1","FIG. 1"],"b":["300","302","208","302","104","106","302"]},"In step  and based on the input received in step , DataVerifier  (see ) identifies and selects an appropriate test query based on the database change specified by the input received in step  and then queries database  (see ) with the appropriate test query (i.e., executes the selected test query on the target database). If the database change is a change to meta data, then the appropriate test query selected in step  obtains meta data of database  (see ).","In one embodiment, a test query is selected as the appropriate test query in step  based on the particular environment of the application (e.g., local, development, integration, testing, staging (pre-production), production, etc.). That is, different test queries may be executed at different environments.","In step , DataVerifier  (see ) retrieves a result. The result retrieved in step  is a result of querying database  (see ) with the test query in step . If the database change is a change to meta data, then the result retrieved in step  is meta data of database  (see ) resulting from the execution of the test query in step .","In step , DataVerifier  (see ) compares the result of step  with expected test result data that is specified by the input received in step . If the comparison in step  detects a match between the result of step  and the expected test result data, then DataVerifier  (see ) determines that the database change is verified. If the comparison in step  detects a mismatch between the result of step  and the expected test result data, then DataVerifier  (see ) determines that the database change is not verified and that the database change includes a defect.","In step , DataVerifier  (see ) sends the determination resulting from the comparison in step  to DataChangeVerificationProcess  (see ). In response, DataChangeVerificationProcess  (see ) initiates a generation of results file  (see ) by OutputLogGenerator  (see ), which includes the determination resulting from the comparison in step . The database change verification process ends at step .","Class Diagrams",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIGS. 4A-4B","FIG. 2","FIG. 3","FIG. 4A","FIG. 4B","FIG. 4B","FIGS. 4A-4B","FIG. 2","FIG. 2"],"b":["216","218","302","400","1","400","2","400","1","402","404","406","400","2","408","410","412","206","216"]},"DataInput  (see ) is a super class for all the types of input extracted from an input file in inputs configuration  (see  and ). In one embodiment, the types of input are (1) input for verifying a change in meta data of a database, (2) input for verifying a change in master data (i.e., non-meta data) of a database, and (3) input for verifying a change in a database trigger, which are specified by MetaDataInput  (see ), MasterDataInput  (see ), and TriggerDataInput  (see ), respectively.","In one embodiment, DataInput  (see ) specifies ValidEnvironments, a list of valid environments against which the automatic database change verification process runs. That is, the list of valid environments specifies a complete set of environments in which the database change verification process should be verifying the database changes. The valid environments in the list are specific to the application or project. The list of valid environments may be configured in a resource bundle file (i.e., database connection configuration  (see ). For example, the list of valid environments may be LOCAL, DEV, TEST, and PROD, which indicate the local, development, test and production environments, respectively.","DataInput  (see ) may also specify dcrNumber (i.e., the DCR number by which the DCR was raised), dcrDescription (i.e., a description of the DCR that is provided by the person who has raised the DCR), assignedTo (i.e., name of the DBA who has worked on the DCR), and raisedBy (i.e., name of the person who has raised the DCR).","MasterDataColumnInput  (see ) is the class for master data column input and is associated with the MasterDataInput class  (see ). In one embodiment, MasterDataColumnInput  may specify columnName (i.e., a name of a column to be verified), expectedValue (i.e., the expected value of the column named by columnName), and type (i.e., the data type of the column named by columnName; e.g., String, Integer, Double, or timestamp).","MasterDataInput  (see ) is a class for master data input. Master data for an application is data that is required for the application to run. Master data is the data that is not added or deleted by the application. For example, in an order processing application in a system, master data may be types of reports generated by the system. In one embodiment, master data input is used by a verifier process (see, e.g., MasterDataVerifier in ) to verify that the DCR is applied correctly.","In one embodiment, MasterDataInput  (see ) may specify query (i.e., a query that needs to be fired on the database) and columnInputs (i.e., a list of column inputs that have the expected value for each column after the query is fired).","MetaDataColumnInput  (see ) is a class for meta data column input and is associated with MetaDataInput class  (see ). MetaDataColumnInput  (see ) provides the input for each column that needs to be verified as part of meta data verification.","In one embodiment, MetaDataColumnInput  (see ) may specify columnName (i.e., name of a column whose value needs to be verified), columnSize (i.e., size of the column that needs to be verified), type (i.e., data type of the column), nullable (i.e., a Boolean value indicating whether or not the nullability of the column needs to checked, and defaultValue (i.e., the expected default value for the column).","MetaDataInput  (see ) is a class for meta data input, which applies to all meta data DCRs. A meta data verifier (i.e., MetaDataVerifier  in ) uses meta data input to verify that the DCR is applied correctly. Data such as column nullability, size, default value, and primary key can be checked with the help of meta data input.","In one embodiment, MetaDataInput  (see ) may specify tableName (i.e., the name of the table for which the meta data needs to be verified), columnInputs (i.e., a list of column inputs that needs to be verified for the table, and primaryKey (i.e., a list of primary keys that needs to be verified on the table).","TriggerDataInput  (see ) is a class for trigger data input. Trigger data input applies to all the trigger data DCRs. Trigger data input is used by a verifier (see, e.g., TriggerDataVerifier in ) to verify that the DCR is applied correctly. Scenarios such as fire a trigger on one table and verify the results on another or the same table can be done using trigger data input.","In one embodiment, TriggerDataInput  (see ) specifies triggeringSql (i.e., a triggering SQL command that is fired on database  of  and that invokes the trigger), triggerName (i.e., a name of the trigger), and masterDataInputs (i.e., master data that needs to be verified after the triggering SQL has been fired).",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIGS. 5A-5B","FIG. 2","FIG. 5A","FIG. 5B"],"b":["500","1","500","2","500","1","502","504","506","508","510","500","2","512","514"]},"The class diagram of  includes the classes for the XML processor (i.e., InputXmlProcessor  in ), the connection manager (i.e., DCRConnectionManager  in ) and the verifier (i.e., DataVerifier  in ).","DataVerifier  (see ) is a base class for all the types of data verifier classes: MasterDataVerifier  (see ), MetaDataVerifier  (see ), and TriggerDataVerifier  (see ).","MasterDataVerifier  (see ) is a class that verifies changes to master data in database  (see ). Examples of changes to master data include adding a new row to a table and updating an existing row in a table. A singleton instance of MasterDataVerifier  is specified in step  (see ) and includes a method that returns an instance of the MasterDataVerifier class . MasterDataVerifier  also includes a verify method that verifies database changes to master data. The verify method accepts a list of MasterDataInput objects (see MasterDataInput  in ), iterates over the list, and verifies each input object by calling a verifyMasterData( ) method. The verifyMasterData( ) method accepts and verifies a MasterDataInput object against the target database based on a comparison of each actual value in the result set with a corresponding expected value, where the expected values are extracted from the input file (see step  of ). If there is a mismatch between an actual value and the expected value, the verifyMasterData( ) method outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid actual value). If the actual value does match the expected value, then the method determines that the value is valid.","Furthermore, MasterDataVerifier  includes getValueBasedOnType method that accepts parameters of a result set object and a MasterDataColumnInput object (see class  in ), and returns an actual value included in the result set object depending on the data type (e.g., double, string, etc.). As used herein, a result set object includes actual data values resulting from an execution of a test query on the target database and\/or actual attributes of the target database.","MetaDataVerifier  (see ) is a class that verifies changes to meta data in database  (see ). Examples of changes to meta data include creating a new table, adding a new column to an existing table, and changing a primary key. A singleton instance of MetaDataVerifier  is specified in step  (see ) and includes a method that returns an instance of the MetaDataVerifier class . MetaDataVerifier  includes a method that retrieves meta data for the target database from the connection object. MetaDataVerifier  also includes a verify method that verifies database changes to meta data. The verify method accepts a list of MetaDataInput objects (see MetaDataInput  in ), iterates over the list, and verifies each input object by calling other verification methods. The other verification methods include (1) a checkTableName method that checks if a table name is correct in the target database (e.g., to verify a new table that has been created), (2) a checkColumnAttributes method that checks different column attributes of a table, and (3) a checkPrimaryKey method that checks if a primary key of a table matches with the expected primary key as given in the input file.","In one embodiment, the checkTableName method receives a MetaDataInput  (see ) object as a parameter and determines that a table name is correct if the table name is found in the target database and is not null.","In one embodiment, the checkColumnAttributes method calls one or more of the following methods: (1) a verifyColumnName method that verifies the name of a particular column in a table in the target database, (2) a verifyColumnDataType method that verifies the data type for a particular column in a table in the target database, (3) a verifyColumnSize method that verifies the column size of a table in the target database, (4) a verifyColumnNullability method that verifies whether or not a column in a table of the target database is nullable, and () a verifyColumnDefaultValue method that verifies a default value in a column in the target database.","The verifyColumnName method receives a result set parameter that includes an actual name of the column being verified and a MetaDataColumnInput  (see ) object parameter that includes the expected name of the column. The expected name is extracted from the input file (see step  of ). The verifyColumnName method compares the actual name of the column to the expected name and outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid column name) if the actual name does not match the expected name. If the actual name does match the expected name, then the method determines that the column name is valid.","The verifyColumnDataType method receives a result set parameter that includes an actual data type of a column of the target database and a MetaDataColumnInput  (see ) object parameter that includes the expected data type of the column. The expected data type is extracted from the input file (see step  of ). The verifyColumnDataType method compares the actual data type to the expected data type and outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid data type) if the actual data type does not match the expected data type. If the actual data type does match the expected data type, then the method determines that the data type is valid.","The verifyColumnSize method receives a result set parameter that includes an actual size (a.k.a. column size) of a column of the target database and a MetaDataColumnInput  (see ) object parameter that includes the expected size of the column. The expected size is extracted from the input file (see step  of ). The verifyColumnSize method compares the actual size to the expected size and outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid column size) if the actual size does not match the expected size. If the actual size does match the expected size, then the column size is valid.","The verifyColumnNullability method receives a result set parameter that includes an actual indicator (a.k.a. column nullability indicator) of whether or not a column of the target database is nullable and a MetaDataColumnInput  (see ) object parameter that includes the expected indicator of whether or not the column is nullable. The expected indicator of column nullability is extracted from the input file (see step  of ). The verifyColumnNullability method compares the actual column nullability indicator to the expected column nullability indicator and outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid column nullability indicator) if the actual column nullability indicator does not match the expected column nullability indicator. If the actual column nullability indicator does match the expected column nullability indicator, then the method determines that the column nullability indicator is valid.","The verifyColumnDefaultValue method receives a result set parameter that includes an actual default value for a column of the target database and a MetaDataColumnInput  (see ) object parameter that includes the expected default value of the column. The expected default value is extracted from the input file (see step  of ). The verifyColumnDefaultValue method compares the actual default value to the expected default value and outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid default value) if the actual default value does not match the expected default value. If the actual default value does match the expected default value, then the method determines that the default value for the column is valid.","In one embodiment, the checkPrimaryKey method receives a MetaDataInput  (see ) object as a parameter. The expected primary key is extracted from the input file (see step  of ). The checkPrimaryKey method compares the actual primary key to the expected primary key and determines whether or not the actual primary key matches the expected primary key. The checkPrimaryKey method outputs a message to results file  (see ), where the message indicates a failure (i.e., an invalid primary key) if the actual primary key does not match the expected primary key. If the actual primary key does match the expected primary key, then the method determines that the primary key is valid.","TriggerDataVerifier  (see ) is a class that verifies changes to database triggers in database  (see ). Examples of changes to triggers include creating a new update trigger, a new insert trigger, or a new delete trigger for a particular table. Other examples of changes to triggers include updating an update trigger, an insert trigger, or a delete trigger for a particular table. A singleton instance of TriggerDataVerifier  is specified in step  (see ). TriggerDataVerifier  includes a verify method that verifies database changes to triggers. The verify method accepts a list of TriggerDataInput objects (see TriggerDataInput  in ), iterates over the list, and verifies each input object by calling other verification methods. The verify method of TriggerDataVerifier  performs the following steps to functionally execute a trigger: (1) sets the auto-commit property of the connection to false; (2) inserts, deletes, or updates row(s) in the target table, which causes the trigger to execute; (3) verifies, via the test query, that the data has been inserted, deleted or updated from the triggered table; and (4) rolls back the changes completed in step (2) so that the functional execution of the trigger results in no change to the state of the database from the user's perspective.","The other verification methods include (1) a checkTableName method that checks if a table name is correct in the target database (e.g., to verify a new table that has been created), (2) a checkColumnAttributes method that checks different column attributes of a table, and (3) a checkPrimaryKey method that checks if a primary key of a table matches with the expected primary key as given in the input file.","The DCRConnectionManager class  (see ) creates a connection to database  (see ), as described above relative to steps  and  of .","The InputXmlProcessor class  (see ) parses the input file (e.g., input.xml), retrieves a test query and expected test result data from the parsed input file, and populates the input classes depicted in  with the retrieved test query and expected test result data (see steps  &  of ).","The verifier classes include the core code to execute the test queries (see step  of ) and compare the expected test result data with the actual data in database  (see ), as described above relative to step  (see ).","Automatically Generated Test Queries",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 6","FIG. 1","FIG. 6","FIG. 6"],"b":["600","102","104","106","108","110","112","600","106","602","602","604","604","110","602","606","604","604","606","606","606","604","102","102","106","600","602","106","600","602"]},"The functionalities of automatic test query generator , input query  and reverse dictionary  are described in more detail in the discussion of  presented below.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 7","FIG. 6","FIG. 6"],"b":["700","602","702","704","706","708"]},"In step , AutomaticTestQueryProcessor  sends a readInput message to InputQueryReader  to read input query  (see ). In step , InputQueryReader  sends a response message that includes input query  (see ) to AutomaticTestQueryProcessor .","In step , AutomaticTestQueryProcessor  sends a readReverseDictionary message to ReverseDictionaryReader , where the readReverseDictionary message includes input query  (see ). In step , ReverseDictionaryReader  parses input query  (see ) and extracts an SQL command from the input query  (see ). Also in step , ReverseDictionaryReader  looks up and retrieves an entry in reverse dictionary  (see ) that associates the extracted SQL command with an SQL command (i.e., the reverse command) that is the reverse of the extracted SQL command. ReverseDictionaryReader  extracts the reverse command from the retrieved entry of reverse dictionary  (see ).","In step , ReverseDictionaryReader  sends a response message to AutomaticTestQueryProcessor , where the response message includes the extracted reverse command.","In step , AutomaticTestQueryProcessor  parses input query  (see ) to extract items included in the input query, where a first set of one or more items (e.g., column names and a table name) are to be included in the test query and a second set of one or more items are data items to be included in the expected output. Also in step , AutomaticTestQueryProcessor  automatically generates a test query by using the extracted reverse command and the extracted first set of one or more data items. In one embodiment, if the extracted reverse command is the SQL describe command, then step  includes generating an intermediate SQL query that includes the extracted describe command, converting the intermediate SQL query into meta data column tags, and then generating a test query in the input file that includes the meta data column tags rather than the describe command per se. If the extracted reverse command is the SQL command of insert, delete or update, then step  includes generating a test query that includes the extracted reverse command. Furthermore, in step , the test query and expected output are used to generate an output (step ), which is as per format specified in the input file. In step , AutomaticTestQueryProcessor  completes the automatic generation of the test query.","In step , AutomaticTestQueryProcessor  sends a write message to TestQueryWriter  to provide inputs configuration  (see ) with the automatically generated test query and expected output. In step , TestQueryWriter  writes the test query and expected output automatically generated in step  to inputs configuration  (see ) (i.e., stores the automatically generated test query in an input file included in a computer data storage unit).","In step , TestQueryWriter sends a response message to AutomaticTestQueryProcessor  to indicate that the automatically generated test query has been written to inputs configuration  (see ). In one embodiment, the steps of  follow step , where the test query retrieved in step  of  is the test query automatically generated in step .","For example, input query  (see ) is \u201cInsert table col, col (data to be inserted)\u201d (i.e., the original command). The original command is read (see step ). A lookup of reverse dictionary  (see ) is performed to retrieve the Select command (i.e., the reverse command of the Insert command) (see step ). Data items col, col, and the table name are extracted from the original command (see step ). A test query of \u201cselect col, col from table name\u201d is automatically generated (see step ). The expected output is \u201cdata to be inserted\u201d, which was extracted from the original command (see step ).","An embodiment that utilizes the system of  and the steps of  is limited to processing an input query that does not change throughout the environments in the development of an application (e.g., local, development, integration, testing, staging (pre-production), production, etc.).","An embodiment that requires a check as to whether a particular data item exists in a table cannot utilize the automatic generation of a test query described above relative to ; instead, a user manually specifies the test query and the expected output in an input file in inputs configuration  (see ).","It should be noted that the names of components , ,  and  and the names of commands described in this section are merely examples-the present invention contemplates embodiments in which different names are used.","Input File","This section provides three parts of an XML document that is an example of an input file included in inputs configuration  (see  and ). The first part includes examples of data items in a <tablecommand> tag used to verify a change to meta data of the target database. The second part includes examples of data items in a <sqlCommand> tag used to verify a change to master data of the target database. The third part includes examples of data items in a <triggercommand> tag used to perform a functional verification of a trigger of the target database by invoking the trigger with the name of the trigger to execute a database transaction, verifying the change to the database caused by the trigger, and rolling back the database transaction, thereby returning the database to the database state that existed prior to the trigger being invoked (i.e., the functional verification of the trigger causes no change in the state of the database from the user's perspective).","First part of the XML document:",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<tableCommand>"},{"entry":"\u2003<validEnv>"},{"entry":"\u2003\u2003<env>LOCAL<\/env>"},{"entry":"\u2003\u2003<env>DEV<\/env>"},{"entry":"\u2003\u2003<env>TEST<\/env>"},{"entry":"\u2003\u2003<env>PROD<\/env>"},{"entry":"\u2003<\/validEnv>"},{"entry":"\u2003<table>EMPLOYEE<\/table>"},{"entry":"\u2003<metaDataColumn name=\u201cEMPLOYEE_ID\u201d type=\u201cVARCHAR\u201d"},{"entry":"\u2003nullable=\u201cNO\u201d \/>"},{"entry":"\u2003<metaDataColumn name=\u201cEMPLOYEE_NAME\u201d type=\u201cVARCHAR\u201d"},{"entry":"\u2003\u2003nullable=\u201cNO\u201d \/>"},{"entry":"\u2003<metaDataColumn name=\u201cDESIGNATION\u201d type=\u201cVARCHAR\u201d"},{"entry":"\u2003nullable=\u201cNO\u201d \/>"},{"entry":"\u2003<metaDataColumn name=\u201cDEPARTMENT\u201d type=\u201cVARCHAR\u201d"},{"entry":"\u2003nullable=\u201cNO\u201d \/>"},{"entry":"\u2003<metaDataColumn name=\u201cACTIVE_FLG\u201d type=\u201cCHAR\u201d"},{"entry":"\u2003\u2003nullable=\u201cNO\u201d defaultValue=\u201c\u2018T\u2019\u201d \/>"},{"entry":"<\/tableCommand>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Second part of the XML document:",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<sqlCommand>"},{"entry":"\u2003<validEnv>"},{"entry":"\u2003\u2003<env>LOCAL<\/env>"},{"entry":"\u2003\u2003<env>DEV<\/env>"},{"entry":"\u2003\u2003<env>TEST<\/env>"},{"entry":"\u2003\u2003<env>PROD<\/env>"},{"entry":"\u2003<\/validEnv>"},{"entry":"\u2003<selectQuery>select EMPLOYEE_ID, EMPLOYEE_NAME,"},{"entry":"\u2003\u2003DESIGNATION, DEPARTMENT, ACTIVE_FLG from"},{"entry":"\u2003\u2003DB2ADMIN.EMPLOYEE where"},{"entry":"\u2003\u2003EMPLOYEE_ID=\u2018E001\u2019<\/selectQuery>"},{"entry":"\u2003<masterDataColumn name=\u201cEMPLOYEE_ID\u201d"},{"entry":"\u2003\u2003expectedValue=\u201cE001\u201d type=\u201cSTRING\u201d \/>"},{"entry":"\u2003<masterDataColumn name=\u201cEMPLOYEE_NAME\u201d"},{"entry":"\u2003\u2003expectedValue=\u201cRAMESH\u201d type=\u201cSTRING\u201d \/>"},{"entry":"\u2003<masterDataColumn name=\u201cDESIGNATION\u201d"},{"entry":"\u2003\u2003expectedValue=\u201cSR.SOFTWARE\u201d type=\u201cSTRING\u201d \/>"},{"entry":"\u2003<masterDataColumn name=\u201cDEPARTMENT\u201d expectedValue=\u201cE14\u201d"},{"entry":"\u2003\u2003type=\u201cSTRING\u201d \/>"},{"entry":"\u2003<masterDataColumn name=\u201cACTIVE_FLG\u201d expectedValue=\u201cT\u201d"},{"entry":"\u2003type=\u201cSTRING\u201d \/>"},{"entry":"<\/sqlCommand>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Third part of the XML document:",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<triggerCommand>"},{"entry":"\u2003<validEnv>"},{"entry":"\u2003\u2003<env>LOCAL<\/env>"},{"entry":"\u2003\u2003<env>DEV<\/env>"},{"entry":"\u2003\u2003<env>TEST<\/env>"},{"entry":"\u2003\u2003<env>PROD<\/env>"},{"entry":"\u2003<\/validEnv>"},{"entry":"\u2003<triggeringSql>UPDATE DB2ADMIN.EMPLOYEE SET"},{"entry":"\u2003\u2003ACTIVE_FLG=\u2018F\u2019 WHERE"},{"entry":"\u2003\u2003EMPLOYEE_ID=\u2018E001\u2019<\/triggeringSql>"},{"entry":"\u2003<triggerName>EMPLOYEE_AU<\/triggerName>"},{"entry":"\u2003<sqlCommand>"},{"entry":"\u2003\u2003<validEnv>"},{"entry":"\u2003\u2003\u2003<env>LOCAL<\/env>"},{"entry":"\u2003\u2003\u2003<env>DEV<\/env>"},{"entry":"\u2003\u2003\u2003<env>TEST<\/env>"},{"entry":"\u2003\u2003\u2003<env>PROD<\/env>"},{"entry":"\u2003\u2003<\/validEnv>"},{"entry":"\u2003\u2003<selectQuery>select EMPLOYEE_ID, EMPLOYEE_NAME,"},{"entry":"\u2003\u2003\u2003DESIGNATION, DEPARTMENT, ACTIVE_FLG from"},{"entry":"\u2003\u2003\u2003DB2ADMIN.OLD_EMPLOYEE where"},{"entry":"\u2003\u2003\u2003EMPLOYEE_ID=\u2018E001\u2019<\/selectQuery>"},{"entry":"\u2003\u2003<masterDataColumn name=\u201cEMPLOYEE_ID\u201d"},{"entry":"\u2003\u2003\u2003expectedValue=\u201cE001\u201d type=\u201cSTRING\u201d \/>"},{"entry":"\u2003\u2003<masterDataColumn name=\u201cEMPLOYEE_NAME\u201d"},{"entry":"\u2003\u2003\u2003expectedValue=\u201cRAMESH\u201d type=\u201cSTRING\u201d \/>"},{"entry":"\u2003\u2003<masterDataColumn name=\u201cDESIGNATION\u201d"},{"entry":"\u2003\u2003\u2003expectedValue=\u201cSR.SOFTWARE\u201d type=\u201cSTRING\u201d \/>"},{"entry":"\u2003\u2003<masterDataColumn name=\u201cDEPARTMENT\u201d expectedValue=\u201cE14\u201d"},{"entry":"\u2003\u2003\u2003type=\u201cSTRING\u201d \/>"},{"entry":"\u2003\u2003<masterDataColumn name=\u201cACTIVE_FLG\u201d expectedValue=\u201cF\u201d"},{"entry":"\u2003\u2003type=\u201cSTRING\u201d \/>"},{"entry":"\u2003<\/sqlCommand>"},{"entry":"<\/triggerCommand>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To test the applicability of a Database Change Request (DCR) (i.e., verify the database change requested by the DCR), a developer prepares or modifies an XML document, such as the sample input file presented above in this section. The sample input file in this section includes database changes required to be verified against a particular environment.","Descriptions of the tags used in the sample input file presented above are included in Table 1 presented below.",{"@attributes":{"id":"p-0109","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["TAG","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<sqlCommand> (in the second","This tag identifies the SQL command used to test the Master"]},{"entry":["part of the XML document listed","data DCRs"]},{"entry":"above)"},{"entry":["<validEnv>","This tag decides the valid environments in which the DCR"]},{"entry":[{},"can be verified."]},{"entry":["<env>","This tag includes the name of the environment against which"]},{"entry":[{},"the database change should be verified. This environment"]},{"entry":[{},"identified by this tag is one of the environments defined in a"]},{"entry":[{},"property file in the database connection configuration 108"]},{"entry":[{},"(see FIG. 1) (e.g., LOCAL to indicate the local environment)."]},{"entry":["<selectQuery>","The select query which is used to verify the DCR."]},{"entry":["<masterDataColumn>","The expected values that need to be verified from the result"]},{"entry":[{},"set, once the above select query has been fired on the"]},{"entry":[{},"database. The valid attributes for this element are presented"]},{"entry":[{},"below:"]},{"entry":[{},"name - Column name"]},{"entry":[{},"expectedValue - The expected value of the column"]},{"entry":[{},"type - The type of the column"]},{"entry":["<tableCommand>","This tag is used to test meta data DCRs."]},{"entry":["<table>","The name of the table whose semantics needs to be verified."]},{"entry":["<metaDataColumn>","The expected values which need to be verified on a particular"]},{"entry":[{},"column of the table identified by <table>. The valid"]},{"entry":[{},"attributes for this element are presented below:"]},{"entry":[{},"name - Column Name"]},{"entry":[{},"type - Data type of the column"]},{"entry":[{},"size - Expected size of the column"]},{"entry":[{},"nullable - Indicates whether or not the column is nullable"]},{"entry":[{},"defaultValue - The default value for the column"]},{"entry":["<triggerCommand>","This tag provides inputs to verify triggers."]},{"entry":["<triggeringSql>","The SQL command that fires a trigger."]},{"entry":["<triggerName>","The name of the trigger"]},{"entry":["<sqlCommand> (in the third part","This tag identifies the SQL command used to verify the effect"]},{"entry":["of the XML document listed","of firing the trigger identified by <triggerName>. The effect"]},{"entry":["above; i.e., a child element of","of firing the trigger may be verified on the same table or a"]},{"entry":["<triggerCommand>)","different table."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, it is assumed that in a services engagement, there are different environments and hence different databases. For example, there may be a test environment in which the application is tested by developers, a user testing environment in which the application is tested by users, and finally a production environment. There can be one or more other intermediate environments in which there may be a need to verify that the database changes have been correctly applied. To facilitate the verification of database changes over multiple environments, the configuration file which contains database connection configuration  (see  and ) includes a parameter (a.k.a. target environment parameter; e.g., target-environment) that specifies a target environment against which the verification program runs. Moreover, some of the database changes may be applicable to one environment but not to another environment. For example, a database change may be applicable to the test environment and not to the production environment (e.g., test data on which developers want to test the application). To facilitate verification of database changes that are applicable to one environment but not another environment, the input file (e.g., input.xml) includes a tag (a.k.a. valid environment tag) that indicates valid environments (see, e.g., validenv in Table 1). This valid environment tag has one or more child tags (see, e.g., env tags in Table 1) which include one or more names of the one or more environments in which the database changes should be verified. The name(s) of the environment(s) and their database Uniform Resource Locator(s) (URL(s)) may be configured in the configuration file which contains database connection configuration  (see  and ). For example, if a database change needs to be verified against the LOCAL environment and TEST environment, but not against the PROD (i.e., production) environment, then validEnv has env tags for LOCAL and TEST, but not for PROD. Furthermore, the database change verification tool disclosed herein allows the user the flexibility to execute a particular test query based on the particular target environment specified in the configuration file. For example, if test queries  through  are required for an application, the tool may extract and execute only test queries  through  if the configuration file specifies that the target environment is the TEST environment and the validEnv tag for test queries  through  is set to \u201cTEST\u201d, and extract and execute test queries  through  if the target environment is the PROD (i.e., production) environment and the validEnv tag for test queries  through  is set to \u201cPROD\u201d.","In one embodiment, the input file retrieved in step  (see ) (1) associates a first set of one or more test queries and a first set of one or more expected outputs with a first valid environment (e.g., via a first valid environment tag) and (2) associates a second set of one or more test queries and a second set of one or more expected outputs with a second valid environment (e.g., via a second valid environment tag), where the first and second valid environments are mutually exclusive. The first set of one or more expected outputs is a set of one or more predefined outputs expected from executing the first set of one or more test queries. The second set of one or more expected outputs is a set of one or more predefined outputs expected from executing the second set of one or more test queries. The input file may specify different first and second sets of one or more test queries and different first and second sets of one or more expected outputs. Alternatively, the input file may specify first and second sets of one or more test queries that are the same while the first and second sets of one or more expected outputs are different. As another alternative, the input file may specify first and second sets of one or more test queries that are the same and first and second sets of one or more expected outputs that are the same. In the embodiment described in this paragraph, verifying a database change to an environment-specific database coupled to an application includes: (1) receiving a user-specified first target environment identifier from the configuration file which contains database connection configuration  (see  and ), where the first target environment identifier identifies a first target environment of the application; (2) selecting and extracting a first set of one or more test queries and a first set of one or more expected outputs from the input file, where the input file associates a first valid environment identifier with the first set of one or more test queries and with the first set of one or more expected outputs, and where selecting and extracting the first set of one or more test queries and the first set of one or more expected outputs are based on the received first target environment identifier matching the first valid environment identifier; (3) automatically executing the first set of one or more test queries in a first environment identified by the first valid environment identifier to generate a first set of one or more actual outputs; (4) automatically verifying the database change based on a comparison of the first set of one or more actual outputs with the first set of one or more expected outputs (i.e., a match between the first set of one or more actual outputs and the first set of one or more expected outputs indicates a valid database change; a mismatch between the first set of one or more actual outputs and the first set of one or more expected outputs indicates an invalid database change); (5) subsequent to step (4), receiving a user-specified second target environment identifier from the configuration file which contains database connection configuration  (see  and ), where the second target environment identifier identifies a second target environment of the application; (6) selecting and extracting a second set of one or more test queries and a second set of one or more expected outputs from the input file, where the input file associates a second valid environment identifier with the second set of one or more test queries and with the second set of one or more expected outputs, where selecting and extracting the second set of one or more test queries and the second set of one or more expected outputs are based on the received second target environment identifier matching the second valid environment identifier, where the first and second sets of one or more test queries may be the same or different, and where the first and second sets of one or more expected outputs are different; (7) automatically executing the second set of one or more test queries in a second environment identified by the second valid environment identifier to generate a second set of one or more actual outputs; and (8) automatically verifying the database change based on a comparison of the second set of one or more actual outputs with the second set of one or more expected outputs (i.e., a match between the second set of one or more actual outputs and the second set of one or more expected outputs indicates a valid database change; a mismatch between the second set of one or more actual outputs and the second set of one or more expected outputs indicates an invalid database change).","Prior to performing step (5) in the embodiment of the previous paragraph, the user-specified second target environment identifier replaces the user-specified first target environment identifier in the configuration file (i.e., configuration  in  and ). In an alternate embodiment, the configuration file initially specifies both the first and second target environment identifiers. In this alternate embodiment, DCV program  (see  and ) extracts the first target environment identifier from the configuration file that includes both the first target environment identifier and the second target environment identifier; performs the processing described above to automatically verify the database change using the first target environment identifier; automatically extracts the second target environment identifier from the configuration file; and performs the processing described above to automatically verify the database change using the second target environment identifier.","Computer System",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 8","FIG. 1","FIG. 6"],"b":["102","802","804","806","808","102","810","812","802","102","802"]},"Memory  may comprise any known type of computer data storage and\/or transmission media, including bulk storage, magnetic media, optical media, random access memory (RAM), read-only memory (ROM), a data cache, a data object, etc. In one embodiment, cache memory elements of memory  provide temporary storage of at least some program code (e.g., code ) in order to reduce the number of times code must be retrieved from bulk storage during execution. Moreover, similar to CPU , memory  may reside at a single physical location, comprising one or more types of data storage, or be distributed across a plurality of physical systems in various forms. Further, memory  can include data distributed across, for example, a local area network (LAN) or a wide area network (WAN).","I\/O interface  comprises any system for exchanging information to or from an external source. I\/O devices  comprise any known type of external device, including a display device (e.g., monitor), keyboard, mouse, printer, speakers, handheld device, facsimile, etc. Bus  provides a communication link between each of the components in computer system , and may comprise any type of transmission link, including electrical, optical, wireless, etc.","I\/O interface  also allows computer system  to store and retrieve information (e.g., data or program instructions such as code ) from an auxiliary storage device such as computer data storage unit  or another computer data storage unit (not shown). Computer data storage unit  may be a non-volatile storage device, such as a magnetic disk drive (i.e., hard disk drive) or an optical disc drive (e.g., a CD-ROM drive which receives a CD-ROM disk).","Memory  includes computer program code  that provides the logic for verifying database changes (e.g., the process of ). In one embodiment, code  provides logic for the processes of  and . In another embodiment, code  provides logic for the processes of  and . Further, memory  may include other systems not shown in , such as an operating system (e.g., Linux) that runs on CPU  and provides control of various components within and\/or connected to computer system .","Memory , storage unit , and\/or one or more other computer data storage units (not shown) that are coupled to computer system  may store DCV program  (see  and ), inputs configuration  (see  and ), database connection configuration  (see  and ), database  (see  and ), results file  (see  and ), reverse dictionary  (see ), automatic test query generator  (see ), and input query  (see ).","As will be appreciated by one skilled in the art, the present invention may be embodied as a system, method or computer program product. Accordingly, an embodiment of the present invention may be an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201csystem\u201d (e.g., system  of , system  of , or computer system  of , , or ). Furthermore, an embodiment of the present invention may take the form of a computer program product embodied in any tangible medium of expression (e.g., memory  or computer data storage unit ) having computer-usable program code (e.g., code ) embodied or stored in the medium.","Any combination of one or more computer-usable or computer-readable medium(s) (e.g., memory  and computer data storage unit ) may be utilized. The computer-usable or computer-readable medium may be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared or semiconductor system, apparatus, device or propagation medium. A non-exhaustive list of more specific examples of the computer-readable medium includes: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a transmission media such as those supporting the Internet or an intranet, or a magnetic storage device. Note that the computer-usable or computer-readable medium could even be paper or another suitable medium upon which the program  is printed, as the program  can be electronically captured via, for instance, optical scanning of the paper or other medium, then compiled, interpreted, or otherwise processed in a suitable manner, if necessary, and then stored in a computer memory . In the context of this document, a computer-usable or computer-readable medium may be any medium that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The computer-usable medium may include a propagated data signal with the computer-usable program code (e.g., program ) embodied therewith, either in baseband or as part of a carrier wave. The computer-usable program code may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc.","Computer program code (e.g., code ) for carrying out operations of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java\u00ae, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on a user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server (e.g., computer system ). In the latter scenario, the remote computer may be connected to the user's computer through any type of network (not shown), including a LAN, a WAN, or the connection may be made to an external computer (e.g., through the Internet using an Internet Service Provider).","The present invention is described herein with reference to flowchart illustrations (e.g., ), sequence diagrams (e.g.,  and ) and\/or block diagrams of methods, apparatus (systems) (e.g., ,  and ), and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations, sequence diagrams and\/or block diagrams, and combinations of blocks in the flowchart illustrations, sequence diagrams and\/or block diagrams, can be implemented by computer program instructions (e.g., code ). These computer program instructions may be provided to a processor (e.g., CPU ) of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart sequence diagram and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer-readable medium (e.g., memory  or computer data storage unit ) that can direct a computer (e.g., computer system ) or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable medium produce an article of manufacture including instruction means which implement the function\/act specified in the flowchart, sequence diagram and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer (e.g., computer system ) or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart, sequence diagram and\/or block diagram block or blocks.","Any of the components of an embodiment of the present invention can be deployed, managed, serviced, etc. by a service provider that offers to deploy or integrate computing infrastructure with respect to the process for automatically verifying database changes. Thus, an embodiment of the present invention discloses a process for supporting computer infrastructure, comprising integrating, hosting, maintaining and deploying computer-readable code (e.g., code ) into a computer system (e.g., computer system ), wherein the code in combination with the computer system is capable of performing a process for automatically verifying database changes.","In another embodiment, the invention provides a business method that performs the process steps of the invention on a subscription, advertising and\/or fee basis. That is, a service provider, such as a Solution Integrator, can offer to create, maintain, support, etc. a process for automatically verifying database changes. In this case, the service provider can create, maintain, support, etc. a computer infrastructure that performs the process steps of the invention for one or more customers. In return, the service provider can receive payment from the customer(s) under a subscription and\/or fee agreement, and\/or the service provider can receive payment from the sale of advertising content to one or more third parties.","The flowchart in , the sequence diagrams in , and the block diagrams in , , and  illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart, sequence diagram or block diagrams may represent a module, segment, or portion of code (e.g., code ), which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams, sequence diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams, sequence diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","While embodiments of the present invention have been described herein for purposes of illustration, many modifications and changes will become apparent to those skilled in the art. For example, the names provided herein for methods, classes, parameters, objects and processes are merely examples; the present invention contemplates that one or more of the aforementioned names may be changed to one or more different names. Accordingly, the appended claims are intended to encompass all such modifications and changes as fall within the true spirit and scope of this invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 4A-4B","FIG. 2","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 5A-5B","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 8","FIG. 1","FIG. 6"]}]},"DETDESC":[{},{}]}
