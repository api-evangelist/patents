---
title: System and method for directing clients to optimal servers in computer networks
abstract: A communication protocol includes one or more messages passed between Web routers over a reliable transmission protocol used for inter-Web router communication. These messages include information that allows the Web routers to dynamically update mappings of client addresses or address ranges to information object repository addresses based on client-to-server distance and server load. The mappings are preferably optimal mappings of the client addresses or address ranges to the information object repository addresses and the messages report updated distances from these information object repository addresses to the client addresses or address ranges. For example, the messages may report, for each updated distance, an associated client address or address range and/or an associated anchor address of a Web router co-located with an information object repository that is the subject of the message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07664876&OS=07664876&RS=07664876
owner: Adara Networks, Inc.
number: 07664876
owner_city: San Jose
owner_country: US
publication_date: 20020910
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present application is related to and hereby claims the priority benefit of the following commonly-owned and U.S. Provisional Patent Applications:\n\n","the present application is also a continuation in part of commonly owned and U.S. patent application Ser. No. 09\/810,148, entitled \u201cSYSTEM AND METHOD FOR DISCOVERING INFORMATION OBJECTS AND INFORMATION OBJECT REPOSITORIES IN COMPUTER NETWORKS\u201d, filed Mar. 15, 2001, by J. J. Garcia-Luna-Aceves, which claims priority from U.S. Provisional Patent Application No. 60\/190,331, filed Mar. 16, 2000 and from U.S. Provisional Patent Application No. 60\/200,401, filed Apr. 28, 2000, and which issued as U.S. Pat. No. 7,162,539 B2 on Jan. 9, 2007.","The present invention relates to a system and method for directing a client (i.e., an information requesting application such as a Web browser) to an optimal server (i.e., information object repository) among many available servers for servicing of a request for one or more information objects.","An internetwork is a collection of computer networks interconnected by nodes, each such node may be a general-purpose computer or a specialized device, such as a router. As such, an internetwork is often called a network of networks. The purpose of building an internetwork is to provide information services to end nodes, each end node may be a general-purpose computer or a specialized device, such as a camera or a display. The Internet is an internetwork in which information is organized into packets to be distributed on a store- and forward manner from source to destination end nodes, and in which routers and end nodes use the Internet Protocol (IP) to communicate such packets.","The World Wide Web (also known as WWW or Web) has become an essential information service in the Internet. The Web constitutes a system for accessing linked information objects stored in end nodes (host computers) all over the Internet. Berners-Lee wrote the original proposal for a Web of linked information objects (T. Berners-Lee, \u201cInformation Management: A Proposal,\u201d CERN Document, March 1989). The Web consists of a vast collection of information objects organized as pages, and each page may contain links to other pages or, more generally, information objects with which content is rendered as audio, video, images, text or data. Pages are viewed by an end user with a program called a browser (e.g., Netscape Navigator\u2122). The Web browser runs in an end system at the user premises. The client (Web browser) obtains the required information objects from a server (Web server) using a request-response dialogue as part of the Hypertext Transfer Protocol (HTTP). Information objects are identified by means of names that are unique throughout the Internet; these names are called Uniform Resource Locators or URLs. A URL consists of three components:\n\n","Like any large-scale system, the Web requires the use of mechanisms for scaling and reliability. More specifically, as the number of information objects that can be obtained through the Web increases, people find it more difficult to locate the specific information objects they need. Furthermore, as the number of Web users and servers increase, the sites or servers that store the requested information objects may be very far from the users requesting the objects, which leads to long latencies in the access and delivery of information, or the servers storing the information objects may be overwhelmed with the number of requests for popular information objects.","To enable the Web to scale to support large and rapidly increasing numbers of users and a vast and growing collection of information objects, the information objects in the Web must be stored distributedly at multiple servers, in a way that users can retrieve the information objects they need quickly and without overwhelming any one of the servers storing the objects. Accordingly, distributing information objects among multiple sites is necessary for the Web to scale and be reliable. The schemes used to accomplish this are called Web caching schemes. In a Web caching scheme, one or multiple Web caches or proxy Web servers are used in computer networks and the Internet to permit multiple host computers (clients) to access a set of information objects from sites other than the sites from which the content (objects) are provided originally. Web caching schemes support discovering the sites where information objects are stored, distributing information objects among the Web caches, and retrieving information objects from a given Web cache. The many proposals and implementations to date differ on the specific mechanisms used to support each of these services.","Many methods exist in the prior art for determining the server, cache, mirror server, or proxy from which information objects should be retrieved. The prior art dates to the development of the ARPANET in the 1970s and the study and implementation of methods to solve the file allocation problem (FAP) for databases distributed over the ARPANET and computer networks in general.","File allocation methods for distributed databases (e.g., W. W. Chu, \u201cOptimal File Allocation in a Multiple Computer System,\u201d IEEE Transactions on Computers, October 1969; S. Mahmoud and J. S. Riordon, \u201cOptimal Allocation of Resources in Distributed Information Networks,\u201d ACM Transactions on Data Base Systems, Vol. 1, No. 1, March 1976; H. L. Morgan and K. D. Levin, \u201cOptimal Program and Data Locations in Computer Networks,\u201d Communications of the ACM, Vol. 20, No. 5, May 1977) and directory systems (e.g., W. W. Chu, \u201cPerformance of File Directory Systems for Data Bases in Star and Distributed Networks,\u201d Proc. National Computer Conference, 1976, pp. 577-587; D. Small and W. W. Chu, \u201cA Distributed Data Base Architecture for Data Processing in a Dynamic Environment,\u201d Proc. COMPCON 79 Spring) constitute some of the earliest embodiments of methods used to select a delivery site for accessing a file or information object that can be replicated at a number of sites.","Another example of this prior art is the method described by Chiu, Raghavendra and Ng (G. Chiu, C. S. Rahgavendra, and S. M. Ng, \u201cResource Allocation with Load Balancing Consideration in Distributed Computing Systems,\u201d Proc. IEEE INFOCOM 89, Ottawa, Ontario, Canada, April 1989, pp. 758-765). According to this method, several identical copies of the same resource (e.g., a file, an information object) are allocated over a number of processing sites (e.g., a mirror server, a cache) of a distributed computing system. The method attempts to minimize the cost incurred in replicating the resource at the processing sites and retrieving the resource by users of the system from the processing sites.","Several different approaches exist in the prior art for discovering information objects in Web caching schemes. Recent work has addressed the same resource allocation and discovery problems within the context of Internet services. Guyton and Schwartz (J. D. Guyton and M. F. Schwartz, \u201cLocating Nearby Copies of Replicated Internet Servers,\u201d Technical Report CU-CS-762-95, Department of Computer Science, University of Colorado-Boulder, February 1995; Proc. ACM SIGCOMM 95 Conference, Cambridge, Mass., August 1995, pp. 288-298) describe and analyze server location techniques for replicated Internet services, such as Network Time Protocol (NTP) servers and Web caches.","Guyton and Schwartz propose gathering location data with router support in two ways. In one method, routers advertise the existence or absence of replicated servers as part of their normal routing exchanges involving network topological information. Routers examine a distance metric for the advertised servers in a way that each router retains knowledge of at least the nearest servers. In this way, each router in an internetwork has enough knowledge to direct client requests to the nearest servers, without necessarily having to maintain knowledge of all the servers in the internetwork. In another method, servers poll routers for the content of their routing tables.","Guyton and Schwartz also describe a method for gathering location data using router probes without router support by means of measurement servers. According to this method, measurement servers explore the routes to the replicated serves providing services and content to the clients. When a client asks a measurement server for a list of nearby servers from which to request a service, the measurement server takes into account the route back to the client in deciding upon the list of servers that appear closer to the client.","One approach to object discovery consists in organizing Web caches hierarchically. In a hierarchical Web cache architecture, a parent-child relationship is established among caches; each cache in the hierarchy is shared by a group of clients or a set of children caches. A request for an information object from a client is processed at a lowest-level cache, which either has a copy of the requested object, or asks each of its siblings in the hierarchy for the object and forwards the request to its parent cache if no sibling has a copy of the object. The process continues up the hierarchy, until a copy of the object is located at a cache or the root of the hierarchy is reached, which consists of the servers with the original copy of the object.","One of the earliest examples of hierarchical Web caching was the Discover system (A. Duda and M. A. Sheldon, \u201cContent Routing in Networks of WAIS Servers,\u201d Proc. IEEE 14th International Conference on Distributed Computing Systems, June 1994; M. A. Sheldon, A. Duda, R. Weiss, J. W. O'Toole, Jr., and D. K. Gifford, \u201cA Content Routing System for Distributed Information Servers,\u201d Proc. Fourth International Conference on Extending Database Technology, March 1994), which provides associative access to servers; the user guides the refinement of requests.","Harvest (A. Chankhunthod, P. Danzing, C. Neerdaels, M. Schwartz, and K. Worrell, \u201cA Hierarchical Internet Object Cache,\u201d Proc. USENIX Technical Conference 96, San Diego, Calif., January 1996) and Squid (D. Wessels, \u201cSquid Internet Object Cache,\u201d http:\/\/www.squid.org, August 1998) are two of the best known hierarchical Web cache architectures. Harvest and Squid configure Web caches into a static hierarchical structure in which a Web cache has a static set of siblings and a parent. The Internet Caching Protocol or ICP (D. Wessels and K. Claffy, \u201cInternet Cache Protocol (ICP), Version 2,\u201d RFC 2186, September 1997) is used among Web caches to request information objects.","In the Harvest hierarchies, siblings and parents are configured manually in Web caches or proxies; this is very limiting and error prone, because reconfiguration must occur when a cache enters or leaves the system. A more general limitation of hierarchical Web caching based on static hierarchies is that the delays incurred in routing requests for information objects can become excessive in a large-scale system, and the latency of retrieving the information object from the cache with a copy of the object can be long, because there is no correlation between the routing of the request to a given cache in the hierarchy and the network delay from that cache to the requesting client. Furthermore, some Web caches may be overloaded with requests while others may be underutilized, even if they store the same objects.","In the WebWave protocol (A. Heddaya and S. Mirdad, \u201cWebWave: Globally Load Balanced Fully Distributed Caching of Hot Published Documents,\u201d Technical Report BU-CS-96-024, Boston University, Computer Science Department, October 1996; A. Heddaya and S. Mirdad, \u201cWebWave: Globally Load Balanced Fully Distributed Caching of Hot Published Documents,\u201d Proc. IEEE 17th International Conference on Distributed Computing Systems, Baltimore, Md., May 1997) Web caches are organized as a tree rooted at the server that provides the original copy of one object or a family of information objects; the leaves of the tree are the clients requesting the information objects, and the rest of the nodes in the tree are Web caches. The objective of the protocol is to achieve load balancing among Web caches; each Web cache in such a tree maintains a measurement of the load at its parent and children in the tree, and services or forwards the request to its parent automatically based on the load information. This approach reduces the possibility of overloading Web caches as in the Harvest approach to hierarchical Web caching; however, delays are still incurred in the propagation of requests from heavily loaded Web caches to their ancestors in the Web hierarchy.","Hash routing protocols (K. W. Ross, \u201cHash Routing for Collections of Shared Web Caches,\u201d IEEE Network, Vol. 11, No. 6, November 1997, pp 37-44) constitute another approach to support object discovery in shared caches. Hash routing protocols are based on a deterministic hashing approach for mapping an information object to a unique cache (D. G. Thaler and C. V. Ravishankar, \u201cUsing Name-Based Mappings To Increase Hit,\u201d IEEE\/ACM Trans. Networking, 1998; V. Valloppillil and J. Cohen, \u201cHierarchical HTTP Routing Protocol,\u201d Internet Draft, http:\/\/www.nlanr.net\/Cache\/ICP\/draft-vinod-icp-traffic-dist-00.txt) to distribute the information objects (universal resource locator or URL in the case of the Web) among a number of caches; the end result is the creation of a single logical cache distributed over many physical caches. An important characteristics of this scheme is that information objects are not replicated among the cache sites. The hash function can be stored at the clients or the cache sites. The hash space is partitioned among the N cache sites. when a client requires access to an information object o, the value of the hash function for o, h(o), is calculated at the client or at a cache site (in the latter case the cache would be configured at the client, for example). The value of h(o) is the address of the cache site to contact in order to access the information object o.","The Cache Resolver is another recent approach to hierarchical Web caching (D. Karger, E. Lehman, T. Leighton, M. Levine, D. Lewin, and R. Panigrahy, \u201cConsistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web,\u201d Proc. 29th ACM Symposium on Theory of Computing (STOC 97), El Paso, Tex., 1997; D. Karger, Sherman, A. Berkheimer, B. Bogstad, R. Dhanidina, K. Iwamoto, B. Kim, L. Matkins, and Y. Yerushalmi, \u201cWeb Caching with Consistent Hashing,\u201d Proc. 8th International World Wide Web Conference, Toronto, Canada, May 1999). This approach combines hierarchical Web caching with hashing and consists of two main tools, random cache trees and consistent hashing. A tree of Web caches is defined for each information object. When a browser (client) requires an information object, it picks a leaf of the tree and submits a request containing its identifier, the identifier of the object, the sequence of caches through which the request is to be routed if needed. A Web cache receiving a request determines if it has a local copy of the page and responds to the request if it does; otherwise, it forwards the request to the next Web cache in the path included in the request.","A Web cache starts maintaining a local copy of an information object when the number of requests it receives for the object reaches a predefined number. A client selects a Web cache by means of consistent hashing, which disseminates requests to leaves of the Web caching hierarchy evenly but, unlike traditional hashing techniques, need not redistribute an updated hash table every time a change occurs in the caching hierarchy (e.g., a new Web cache joins or a Web cache fails). Because caching is difficult to implement or add to existing Web browsers, the Cache Resolver approach implements the hashing in DNS servers modified to fit this purpose.","The remaining limitations with this approach stem from the continuing use of a hierarchy of Web caches and the need to implement a hashing function in either Web clients or DNS servers. Routing a request through multiple Web caches can incur substantial delays for clients to retrieve information objects that are not popular among other clients assigned to the same Web cache by the hashing function. Additional delays, even if small, are incurred at the DNS server that has to provide the address of the Web cache that the client should access. Furthermore, the DNS servers supporting the consistent hashing function must receive information about the loading of all the Web caches in the entire system, or at least a region of the system, in order to make accurate load-balancing decisions.","This DNS-based approach, without the use of hierarchies of Web caches, is advocated in the Akamai CDN solution (F. T. Leighton and D. M. Lewin, \u201cGlobal Hosting System,\u201d U.S. Pat. No. 6,108,703, Aug. 22, 2000). The \u201cglobal hosting system\u201d advocated by Akamai assumes that a content provider services an HTML document in which special URLs specifying a domain name specific to Akamai. When the client needs to obtain the IP address of the Web cache hosting the content specified in the special URL, the client first contacts its local DNS. The local DNS is pointed to a \u201ctop-level\u201d DNS server that points the local DNS to a regional DNS server that appears close to the local DNS. The regional DNS server uses a hashing function to resolve the domain name in the special URL into the address of a Web cache (hosting server) in its region, which is referred to as the target Web cache in the present application, in a way that the load among Web caches in the region is balanced. The local DNS passes the address of that Web cache to the client, which in turn sends its request for the information object to that Web cache. If the object resides in the target Web cache, the cache sends the object to the client; otherwise, the object is retrieved from the original content site.","The global hosting system advocated by Akamai was intended to address problems associated with traditional load-balanced mirroring solutions in which a load balancer or a hierarchy of load balancers redirect requests to one of a few hosting sites to balance the load among such sites. Companies such as Cisco Systems of Santa Clara, Calif., F5 Networks, Inc. of Seattle, Wash., Resonate, Inc. of Sunnyvale, Calif., Nortel Networks of Brampton, Ontario, and Foundry Networks, Inc. of San Jose, Calif. currently provide examples of load-balanced solutions. The limitations of the global hosting system are inherent to the fact that the approach is, in essence, a DNS-based load-balanced mirroring solution. The global hosting system selects a target Web cache based entirely on the region that appears to favor the local DNS, which need not favor the client itself, and balances the load among Web caches without taking into account the latency between the Web caches and the clients. In the case of a cache miss, the information object has to be retrieved from the original content site, which means that latencies in the delivery of content can vary widely, unless the content is mirrored in all the caches of all regions.","Another alternative approach to hierarchical web caching and hash routing protocols consists of forwarding client requests for URLs using routing tables that are very similar to the routing tables used today for the routing of IP packets in the Internet (L. Zhang, S. Michel, S. Floyd, and V. Jacobson, \u201cAdaptive Web Caching: Towards a New Global Caching Architecture,\u201d Proc. Third International WWW Caching Workshop, Manchester, England, June 1998, B. S. Michel, K. Nikoloudakis, P. Reiher, and L. Zhang, \u201cURL Forwarding and Compression in Adaptive Web Caching,\u201d Proc. IEEE Infocom 2000, Tel Aviv, Israel, April 2000). According to this approach, which is referred to as \u201cURL request forwarding\u201d herein, Web caches maintain a \u201cURL request routing table\u201d and use it to decide how to forward URL requests to another Web caches when requested information objects are not found locally. The keys of the URL request routing tables are URL prefixes, which are associated with one ore more identifiers to the next-hop Web caches or cache groups, and a metric reflecting the average delay to retrieve a request from a matching URL.","In this approach, an entry in the URL request routing table specifies a URL prefix and the next-hop Web cache towards an area or neighborhood of Web caches where the object resides. Ideally, a Web cache needs to know where a copy of a given object resides; however, because of the large number of objects (identified by URLs) that can be requested in a system, the URL request forwarding approach requires Web caches to be organized into areas or neighborhoods. All Web caches within the same area know the objects available in every other Web cache in the same area. In addition, for those objects that are not found in the area of a Web cache, the Web cache also maintains the next-hop Web cache towards the area in which a Web cache with the content resides.","Unfortunately, this approach has several scaling and performance limitations. First, requiring each Web cache to know all the Web caches where each object in the area resides incurs a large overhead, which is akin to the overhead of a traditional topology-broadcast protocol for IP routing, with the added disadvantage that the number of objects that can reside in an area can be much larger than the number of IP address ranges maintained in backbone routers of the Internet. Second, because Web caches only know about the next hop towards a URL that does not reside in a region, a request for an object that lies outside the area of a Web cache may traverse multiple Web-cache hops before reaching a Web cache in the area where an object is stored. This introduces additional latencies akin to those incurred in the caching hierarchies proposed in other schemes discussed above. Third, it is difficult to modify Web caches in practice to implement the mechanisms needed for the forwarding of URL requests.","To reduce the delays incurred in hierarchical Web caches, Tewari, Dahlin, Vin and Kay (R. Tewari, \u201cArchitectures and Algorithms for Scalable Wide-area Information Systems,\u201d Ph. D. Dissertation, Chapter 5, Computer Science Department, University of Texas at Austin, August 1998; R. Tewari, M. Dahlin, H. M. Vin, and J. S. Kay, \u201cDesign Considerations for Distributed Caching on the Internet,\u201d Proc. IEEE 19th International Conference on Distributed Computing Systems, May 1999) introduce hint caches within the context of a hierarchical Web caching architecture. According to this scheme, a Web cache maintains or has access to a local hint cache that maintains a mapping of an object to the identifier of another Web cache that has a copy of the object and is closest to the local hint cache. Web caches at the first level of the hierarchy maintain copies of information objects, while Web caches at higher levels only maintain hints to the objects. Hints are propagated along the hierarchy topology from the Web caches lower in the hierarchy to Web caches higher in the hierarchy. Furthermore, a Web cache with a copy of an object does not propagate a hint for the object. The limitation with this approach is that a Web caching hierarchy must still be established, which needs to be done manually in the absence of an automated method to establish the hierarchy, and the Web caching hierarchy must match the locality of reference by clients to reduce control overhead.","A number of proposals exist to expedite the dissemination of information objects using what is called \u201cpush distribution\u201d and exemplified by Backweb, Marimba and Pointcast (\u201cBackWeb: http:\/\/www.backweb.com\/\u201d\u2019; \u2018\u201cMarimba: http:\/\/www.marimba.com\/\u2019\u201d; \u201cPointcast: http:\/\/www.pointcast.com\/\u2019\u201d). According to this approach, a Web server pushes the most recent version of a document or information object to a group of subscribers. The popular Internet browsers, Netscape Navigator and Internet Explorer\u2122, use a unicast approach in which the client receives the requested object directly from the originating source or a cache. As the number of subscribers of a document or information object increases, the unicast approach becomes inefficient because of processing overhead at servers and proxies and traffic overhead in the network. The obvious approach to make push distribution scale with the number of subscribers consists of using multicast technology. According to this approach (P. Rodriguez and E. W. Biersack, \u201cContinuous Multicast Push of Web Documents over The Internet,\u201d IEEE Network Magazine, Vol. 12, No.2, pp. 18-31, 1998), a document is multicasted continuously and reliably within a multicast group. A multicast group is defined for a given Web document and subscribers join the multicast group of the Web document they need to start receiving the updates to the document. A multicast group consists of the set of group members that should receive information sent to the group by one or multiple sources of the multicast group. The main shortcoming of this particular approach to push distribution are:\n\n","Furthermore, Rodriguez, Biersack, and Ross (P. Rodriguez, E. W. Biersack, and K. W. Ross, \u201cImproving the WWW: Caching or Multicast?,\u201d Institut EURECOM 2229, Route Computer Networks and ISDN Systems, pp. 1-17 (Mar. 30, 1998) have shown that multicasting Web documents is an attractive alternative to hierarchical Web caching only when the documents to be pushed are very popular, caching distribution incurs less latency.","Kenner and Karush (B. Kenner and A. Karush, \u201cSystem and Method for Optimized Storage and retrieval of Data on a Distributed Computer Network,\u201d U.S. Pat. No. 6,003,030, Dec. 14, 1999) propose a method for expediting the delivery of information objects to end users. In this method, the end user site is equipped with special software in addition to the Web browser. This software consists of a configuration utility and a client program. The configuration utility is used to download a delivery site file specifying a list of the delivery sites (Web caches or originating Web servers) from which the information objects can be retrieved and a suite of tests that can be run to determine which delivery site to contact. The limitations with this approach stem from the fact that it is not transparent to end user sites. In particular, the end user site needs to run additional software; performance tests must be conducted from the end-user site to one or more delivery sites to decide which site to use; and when changes occur to the delivery sites, a new version of the delivery site file must be retrieved by the end-user site, or new performance tests must be conducted.","Another approach to helping select servers in a computer network (Z. Fei, S. Bhattacharjee, E. W. Zegura, and M. H. Ammar, \u201cA Novel Server Selection Technique for Improving The Response Time of a Replicated Service\u201d Proc. IEEE Infocom 98, March 1998, pp. 783-791) consists of broadcasting server loading information after a certain load threshold or time period is exceeded. The limitation of this approach is that, just as with topology-broadcast protocols used for routing in computer networks, the scheme incurs substantial overhead as the number of servers increases.","Still another approach to directing clients to hosting sites with requested information objects or services is the replica routing approach proposed by Sightpath, Inc. (D. K. Gifford, \u201cReplica Routing,\u201d U.S. Pat. No. 6,052,718, Apr. 18, 2000). According to the Replica Routing approach, an information object or service is replicated in a number of replica servers. The replica routing system redirects a client requesting the information object or service to a \u201cnearby\u201d replica of the object or service. In one approach, all replica routers know the replica advertisements from each of the replica servers in the system, which summarize information about their location and observations about the local internetwork topology and performance. Using this flooding of advertisements, a replica router discerns which replica server appears nearby any one client. However, requiring each replica router to receive the advertisements from every other replica server becomes impractical as the number of replica servers and replica routers increases.","To remedy this problem, replica routers are organized into a hierarchy, and replica advertisements are propagated only part way up such router hierarchy. A client request is routed to the root of the hierarchy and from there is forwarded down the hierarchy, until it reaches a replica router with enough knowledge about the replica's internetwork location to make an informed redirection decision. This approach has similar performance and scaling limitations as the prior approaches summarized above based on hierarchies of Web caches, flooding of information among caches or servers, and forwarding of requests over multiple hops.","Another recent approach to directing clients to hosting sites with requested information objects or services is the enhanced network services method by Phillips, Li, and Katz (S. G. Phillips, A. J. Li, and D. M. Katz, \u201cEnhanced Network Services Using a Subnetwork of Communicating Processors,\u201d U.S. Pat. No. 6,182,224, Jan. 30, 2001.). Insofar as directing clients to servers, the enhanced network services method is very similar to the gathering of location data with router support advocated by Guyton and Schwartz described previously. This technique is used by Cisco Systems of Santa Clara, Calif.","As in the Guyton and Schwartz approach, routers using the enhanced network services approach gather network topological data and also include as part of their normal routing exchanges information about the hosts that can provide content and services to clients; routers can then rank the hosts according to their relative distance in the network. In addition to data regarding hosts that can provide services, routers in the enhanced network services approach can include in their normal routing exchanges host information regarding logged-in users and willingness to pay for performing a designated service. This approach has a number of performance and scaling limitations just like other prior approaches summarized above. These limitations include the following.","The client in Cisco's enhanced network services method is pre-configured to contact a specific name server or router. In the case of a name server, the name server contacts the router on behalf of the client. In either case, the router determines the best server from the given list of server addresses. The router uses its routing tables (and server loads when available) to locate the best server. The assumption is that the proxy name server or router is close to the client in network terms. This assumption and preconfiguration are too restrictive. A more general solution is needed to enable an entity capable to provide enhanced network services to be contacted by any client to obtain best server information.","In contrast to the proposal by Guyton and Schwartz, the enhanced network services approach does not attempt to limit the amount of network topological information that routers need to exchange in order to direct clients to best qualified servers. Hence, the use of flooding of information among nodes providing enhanced network services and the forwarding of requests over multiple hops limits the scalability of the Cisco approach.","In Cisco's enhanced network services method, the client obtains the list of server addresses and provides it to the router for ordering them based on distances. The network latencies from the client to the servers are obtained from \u201ctraditional\u201d routing tables. The server load information is then taken into account on demand at the router that receives the request. This imposes unnecessary functionality in the clients, because nodes in charge of enhanced services (not necessarily IP routers) could and should be more proactive in determining the best matches for clients in a completely transparent way from a client's standpoint. Furthermore, in Cisco's enhanced network services method, a router has route information only for itself to the servers. This is only partial information and, hence, the router is unable to determine distance from arbitrary clients to servers. The routers do not have the capability to combine network topology views from different routers. Constructing Internet topologies using inter-domain routing information (e.g., as provide from the BGP) is not performed by the routers involved in this process.","In one embodiment, one or more tables are constructed at one or more of a collection of Web routers communicatively coupled to one another via a computer network that supports an inter-Web router communication protocol wherein inter-Web router communication messages are exchanged between neighbor Web routers. These one or more tables contain client-to-server distance information, and the tables that are constructed by each of the respective Web routers are stored in a computer-readable medium accessible by the corresponding Web router. As used in this context, the term client refers to any information object requesting device, or a group thereof, communicatively coupled to one or more of the Web routers and the term server refers the any information object repository accessible by one or more clients. Thereafter, using the client-to-server distance information contained in one or more of the tables, a determination of a best server for servicing a request for a particular information object made by one of the clients is made.","The best server may be determined in terms of distance from the best server to the client making the request and a current load on the best server. The distance from the best server to the client making the request may be measured in terms of network latency.","The tables may be updated in response to revised client-to-Web router distance information. Such revised client-to-Web router distance information may be included in the inter-Web router communication messages and is preferably determined, at least in part, from internetwork connectivity information received through an exchange of messages according to an inter-domain routing protocol (e.g., the Border Gateway Protocol). Furthermore, the tables may be updated in response to revised server load information and the updated table information transmitted to one or more of the Web routers using one or more inter-Web router communication messages.","A further embodiment provides a communication protocol that includes one or more messages passed between Web routers over a reliable transmission protocol used for inter-Web router communication. These messages include information which allows the Web routers to dynamically update mappings of client addresses or address ranges to information object repository addresses based on client-to-server distance and server load. The mappings are preferably optimal mappings of the client addresses or address ranges to the information object repository addresses and the messages report updated distances from these information object repository addresses to the client addresses or address ranges. For example, the messages may report, for each updated distance, an associated client address or address range and\/or an associated anchor address of a Web router co-located with an information object repository that is the subject of the message.","Another embodiment provides a process wherein at a first Web router of a network of Web routers, a network latency map for at least one of the Web routers of the network and a client communicatively coupled to the at least one Web router is created using internetwork connectivity information received at the first Web router through an inter-domain routing protocol, and the network latency map is disseminated from the first Web router to one or more neighbor Web routers of the first Web router through a reliable communication protocol used for inter-Web router communication messages exchanged via the network. The network latency map specifies a distance between the client and the at least one Web router as reported by the first Web router.","Further, the network latency map may be used to produce a client-to-server map that specifies a most favored server for servicing information object requests by the client. The client-to-server map is produced by combining (e.g., adding together where the server load and the distance between the client and the at least one Web router are measured in common units) server load information with information specified by the network latency map.","The client-to-server map may be updated in response to one or more of a server load change or a network latency map update. Thereafter, the network latency map update may be transmitted as one of the inter-Web router communication messages exchanged via the network. Likewise, in response to updating the client-to-server map, a client-to-server map update may be transmitted as one of the inter-Web router communication messages exchanged via the network.","However, in one embodiment, the client-to-server map in response to a network latency map update only if the network latency map update specifies a better mapping than the client to server map. This condition is true if (1) a first sequence number associated with the network latency map update is greater than a second sequence number associated with the client-to-server map, (2) a first distance associated with the network latency map update is less than a second distance associated with the client-to-server map, or (3) a first result of a hashing function computed using one or more parameters of the network latency map update is less than a second result of the hashing function computed using corresponding one or more parameters of the client-to-server map.","A further embodiment provides a method in which an inter-Web router communication message including an update for a mapping between a client and a second Web router is received at a first Web router, and a client-to-Web router table at the first Web router is updated to include the mapping between the client and the second Web router if this client-to-Web router mapping specifies a better client-to-Web router distance than is currently maintained in the client-to-Web router table for the client. Thereafter, the mapping between the client and the second Web router may be propagated to neighbor Web routers of the first Web router. In addition, the mapping between the client and the second Web router may be used to compute a client-to-server mapping.","In such cases, a client-to-server table may be updated to include the client-to-server mapping if the client-to-server mapping specifies a better client-to-server distance than is currently maintained in the client-to-server table for the client. The client-to-server mapping is computed by adding server load to distance information included in the client-to-Web router mapping. Determining whether the client-to-Web router mapping specifies a better client-to-Web router distance than is currently maintained in the client-to-Web router table for the client may be done by comparing one or more of (1) sequence numbers associated with the client-to-Web router mapping and the client-to-Web router distance maintained in the client-to-Web router table, (2) anchor addresses associated with the client-to-Web router mapping and the client-to-Web router distance maintained in the client-to-Web router table, (3) Web router addresses associated with the client-to-Web router mapping and the client-to-Web router distance maintained in the client-to-Web router table, or (4) distances associated with the client-to-Web router mapping and the client-to-Web router distance maintained in the client-to-Web router table. The client-to-server mapping may also be propagated to neighbor Web routers of the first Web router.","The core of the Internet is congested and, hence, delivering content across the Internet incurs high latency. Increasing the bandwidth of the \u201clast mile\u201d (e.g., the last link in communication path to the end user or content source) via high-speed modems and digital subscriber line (DSL) technology, for example, alone will not improve the end-user experience of the Internet. What is required is a reduction in the end-to-end latencies of the Internet by avoiding congestion points in the core of the Internet.","To avoid Internet congestion and reduce latencies, content (e.g., web pages and related information objects) must be moved to the edge, i.e., to locations that are close to the clients. This requires maintaining copies of content on several caches located around the Internet, and then directing clients to their nearest cache. The present invention enables this functionality.","The present invention provides a method and system for directing a client (e.g., a Web browser) to an optimal server (e.g., a cache) among many available servers. An optimal server, from a client's viewpoint, is a server that offers the lowest response time in delivering a requested information object to the client. When the server does not hold the requested information object, it obtains that information object from another server that has the information object. In the case that none of the servers in the system have the requested information object, the server approaches the main or origin content server to obtain the information object. Thus, a method and system for directing clients to optimal caches and\/or servers storing information objects distributed over computer networks will now be described.","In the following description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be evident to those of ordinary skill in the art that some of these specific details need not be used to practice the present invention and\/or that equivalents thereof may be used. In other cases, well-known structures and components have not been shown in detail to avoid unnecessarily obscuring the present invention. Thus, although discussed with reference to certain illustrated embodiments, upon review of this specification, those of ordinary skill in the art will recognize that the present system and methods may find application in a variety of systems and the illustrated embodiments should be regarded as exemplary only and should not be deemed to be limiting in scope.","Some portions of the description that follow are presented in terms of algorithms and symbolic representations of operations on data within a computer memory (e.g., in pseudocode). These algorithmic descriptions and representations are the means used by those skilled in the computer science arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers or the like. It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, it will be appreciated that throughout the description of the present invention, use of terms such as \u201cprocessing\u201d, \u201ccomputing\u201d, \u201ccalculating\u201d, \u201cdetermining\u201d, \u201cdisplaying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","In one embodiment of the present invention, a device called a Web router, which may be implemented in software and\/or hardware and configured to maintain mappings specifying the associations between client addresses or address ranges to optimal servers, receives a request for an optimal server for a given client address. The request may come from a variety of entities, such as clients, redirection servers and\/or DNS servers. Whatever the source of the request, the Web router returns the address of the optimal server according to the above-mentioned mappings.","In a further embodiment, a number of Web routers are deployed in a network or network of networks and these Web routers communicate with one another using a communications protocol that includes one or more messages transmitted reliably over inter-Web router communication channels called tunnels. The messages carry the mappings specifying the association between clients or client address ranges to available servers. The specific metric associated with the mapping can be one or more of an average delay from the client or client address range to a server, average processing delays at the servers, reliability of a path from client to the server, available bandwidth in such a path, and loads on the server. When these mappings change due to changes in the topology of the Internet, the messages carry updated distance information (e.g., as computed according to the metric) in the maps. The Web routers employ special rules when updating their local maps in response to received messages.","In another embodiment, the mappings between clients and servers that the Web routers exchange in order to determine the optimal map between a client and server is derived (at least in part) from an inter-domain routing protocol such as the Border Gateway Protocol (BGP). Likewise, the mappings between clients and servers residing in the same domain may be derived (at least in part) from an intra-domain routing protocol such as the Open Shortest Path First (OSPF) protocol. The interfacing of the inter-domain and intra-domain protocols takes place at special Web routers called anchor Web routers.","As an aside, exterior gateway protocols (like BGP) are designed to route between routing domains. In the terminology of the Internet, a routing domain is called an autonomous system (AS). BGP is an inter-AS routing protocol created for use in the Internet that enables groups of routers (i.e., ASes) to share routing information so that efficient, loop-free routes can be established. BGP is commonly used within and between Internet Service Providers (ISPs) and the complete protocol is defined in Request For Comments 1771 of the Internet Engineering Task Force. Although BGP maintains a routing table with all feasible paths to a particular network, it advertises only the primary (optimal) path in its update messages. The BGP metric is an arbitrary unit number specifying the degree of preference of a particular path. Degrees of preference may be based on any number of criteria, including AS count (paths with a smaller AS counts are generally better), type of link, and other factors.","Returning now to another embodiment of the present invention, the type information associated with different servers may be propagated to others servers in the network. The type information can specify whether the server is a streaming sever, an anchor Web-router, a DNS capable Web router, and so on. Based on this information, mappings are produced to associate the closest optimum server of the required type to service a client or client address range that needs that specific type of service.","In still another embodiment, the server load is folded into the mapping between clients and servers. This produces the effect of load balancing, such that, when the load on the nearest given server is unacceptable, another server is assigned to service the client.",{"@attributes":{"id":"p-0072","num":"0078"},"figref":"FIG. 1","b":["100","100","100","100","110","170","110","120","120","130","140","150","160","170"]},{"@attributes":{"id":"p-0073","num":"0079"},"figref":"FIG. 2","b":["200","202","202","204","206","202","208","210","204","206","202","202","208","202","208","110"],"i":["a","h "]},"As indicated above, a Web router is one embodiment of the systems and methods described herein for directing clients to information objects and object repositories in computer networks. The functionality of a Web router can be co-located and\/or implemented as part of a content server , a Web server , a Web cache , a router or as a separate entity. To simplify its description, the Web router is described and treated herein as a separate entity from a Web cache or a router.","In one embodiment of the present invention, a Web router may be implemented in software to be executed by a general purpose (or special purpose) computer processor, or it may be implemented as part of the software of a router or Web cache. In another embodiment of the present invention, some or all of the Web router functionality may be implemented in hardware. Such details are not critical to the present invention.","In one embodiment of the present invention, a collection of one or multiple Web routers  is used to refer the request for an object to a Web cache  or content server  that is able to transfer the requested object to the target client  while satisfying a given set of parameters, such as network delays, bandwidth availability, reliability of paths from the chosen sites to the target client , and loads on the Web caches  and content servers . The method used to select the best site from which information objects should be retrieved by user sites (clients) is transparent to the user sites, and the computer network or internetwork over which the system operates need not support multicast delivery to end-user sites.","To reduce communication and processing overhead in Web routers, a topology of Web routers is defined, such that a given Web router has as its neighbor Web routers a subset of all the Web routers in the system (where the term system refers to all or a portion of the VON  for Web routers discussed above). A Web router may thus be configured with its set of neighbor Web routers. Such a configuration may be expressed as a table of neighbor Web routers that is defined by a network service provider and\/or is dynamically updated. In another embodiment of the present invention, a Web router dynamically selects the set of neighbor Web routers with which it should communicate out of all of the Web routers in the system.","A Web router (WR) preferably communicates with its neighbor Web routers only and uses the Web Information Locator by Distance (WILD) protocol for this purpose. The WILD protocol is disclosed in co-pending and commonly-owned U.S. patent application Ser. No. 09\/810,148, entitled \u201cSystem and Method for Discovering Information Objects and Information Object repositories in Computer Networks\u201d, filed Mar. 15, 2001, by J. J. Garcia-Luna-Aceves, the complete disclosure of which is hereby incorporated by reference.","The WILD protocol (or simply WILD) constructs tables (which are stored locally in memory or other computer-readable media) containing the client-to-server distance information. Each Web router uses the tables computed by WILD for directing a client to the server that is nearest to the client. In the present embodiment, the best or nearest server is determined in terms of the distance or network latency (NL) of the server to the client and the current load on the server.","The Web router maps each URL provided by the Web server to the address of a Web cache or the content server that can optimally provide the associated information object to the client. This mapping of URLs to addresses of Web caches or content servers is accomplished by the collaboration among Web routers through WILD. Accordingly, the Web router contacted by the Web server can return the required addresses immediately after processing the request. In turn, the Web server returns a Web page to the requesting client that contains a URL for each information object that points to the nearest Web cache or content server that can provide the information objects to the client. The client is then able to retrieve the information objects referenced in the Web page directly from the identified Web cache, proxy, or content server.","In other embodiments, the Web router may receive a request from a client, a cache, a Web server, another Web router, a name (e.g., DNS) server, or another type of server, and use the address of the client (or a range of client addresses) specified in the request to obtain the address of the nearest Web cache, set of Web caches, content server, or Web router (i.e., information object repository) that should service the client.","In one embodiment, if the Web router maps the address of the client requiring the location of information objects to addresses of Web caches that do not currently store such objects, the Web router can instruct the corresponding Web caches to obtain a copy of the required objects immediately after it provides the requesting Web server the address of such a Web cache or proxy. In another embodiment, a Web cache or proxy attempts to retrieve a requested object from another Web cache or a content server only after it is contacted by a client and determines that a copy of the requested information object is not available locally. In both instances, the Web router provides the Web cache servicing a client request with the address of the nearest Web cache that stores the information object requested by the client; therefore, the Web cache needing the information object communicates directly with the Web cache storing the requested information object, without having to go through any intermediate Web caches and without having to know the content stored in all other Web caches.","Maintaining optimum server information on a per-client basis is expensive and (in many cases) unnecessary. It is generally sufficient to maintain the optimum server on a per-subnet basis, where a subnet is defined by its prefix and mask. The subnet-to-server mapping information is determined at the special Web routers, called the anchor Web Routers, which are BGP-enabled and are capable of receiving Internet connectivity information (e.g., ASPATHs, etc.) from the external BGP peers running in the host autonomous system (AS). Anchor Web routers are those that originate the mapping information for a given client or client address range.","In order to provide the sort of functionality discussed above, each Web router executes locally a path-selection algorithm, such as Dijkstra's shortest-path first algorithm, to compute the local distance from attached Web caches to each client address range if the Web router has complete intra-domain and inter-domain routing data, or to each client address range in the local AS if the Web router only has intra-domain routing data. A Web router can execute a different path-selection algorithm to compute local distances to address ranges for each defined in the system.","Having computed local distances from attached Web caches to all or a subset of client address ranges, a Web router uses this information to compute the best match between a client address range and the set of Web caches that should serve the client address range because they have the best distance to the client. To accomplish this process, for each known destination address a Web router maintains a set of one or more addresses of the Web caches or content servers that have the best distances to the destination address and the value of such distances, and may also maintain the address of one or more Web routers that can be used to redirect requests from clients in the address range and the value of the distances from the redirecting Web routers to the client address range.","Turning now to , a functional representation of an anchor Web router  is illustrated. Non-anchor Web routers are similar to anchor Web routers , but need not include the WBGP module . In each anchor Web router , however, a WILD-BGP (WBGP) module  converts the ASPATH information obtained from BGP peers, together with on-line latency measurements performed by a WILD module , into subnet-to-Web router latency information, known as \u201cNL maps\u201d. Note, throughout the remaining discussion, where the term subnet is used it should be understood that a subnet may be a single client or, preferably, a range of client addresses identified by the prefix and mask. The anchor Web routers  then propagate NL maps extracted from the ASPATH information to the respective Web routers. Each Web router will then know its network latency to each subnet. At each Web router, the load of the local servers  is added to the NL map information to produce the subnet-to-server latency information. The final output of the WILD protocol module  is to install, at each Web router, a mapping table with entries of the form [subnetid, serverid], where serverid is the address of the server that is best suited to service requests from clients in the subnet defined by subnetid.","The following is an example of an API that could be used for the interfacing of the WBGP module  to the WILD module .",{"@attributes":{"id":"p-0088","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function name","wldAlgNewMap"]},{"entry":["Return value","void"]},{"entry":["Paramters","IpAddr prefix"]},{"entry":[{},"IpAddr mask"]},{"entry":[{},"IpAddr mcaddr"]},{"entry":[{},"MCType type"]},{"entry":[{},"Distance dist"]},{"entry":["Description","Called by WBGP to provide a new NL map to WILD."]},{"entry":[{},"mcaddr specifies the subject Web router and"]},{"entry":[{},"dist specifies the distance of the prefix"]},{"entry":[{},"to the subject Web router."]},{"entry":["Function name","wldDeletePrefix"]},{"entry":["Return value","void"]},{"entry":["Parameters","IpAddr prefix"]},{"entry":[{},"IpAddr mask"]},{"entry":["Description","Called by WBGP to inform WILD that the specified pre-"]},{"entry":[{},"fix is no longer valid."]},{"entry":["Function name","wldBgpWridState"]},{"entry":["Return value","void"]},{"entry":["Parameters","IpAddr mcaddr"]},{"entry":[{},"Flag flag"]},{"entry":["Description","A WBGP routine that is called by WILD to indicate that"]},{"entry":[{},"it is interested in receiving maps related to the specified"]},{"entry":[{},"Web router (mcaddr)."]},{"entry":["Function name","wldAddrToPrefix"]},{"entry":["Return value","void"]},{"entry":["Parameters","IpAddr mcaddr"]},{"entry":[{},"IpAddr *prefix"]},{"entry":[{},"IpAddr *mask"]},{"entry":["Description","A WBGP routine that WILD calls to obtain the network"]},{"entry":[{},"address of the client specified in mcaddr."]},{"entry":["Function name","wldAddrPrefix"]},{"entry":["Return value","void"]},{"entry":["Parameters","IpAddr *prefix"]},{"entry":[{},"IpAddr *mask"]},{"entry":["Description","A WBGP routine WILD calls to add the network address"]},{"entry":[{},"to the BGP database so that the network of a given"]},{"entry":[{},"client address can be determined. This is used at the"]},{"entry":[{},"non-anchor Web routers."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The WBGP module  is supported by the WLM module, which provides realistic link metrics to WBGP to augment the AS hop-count metric of WBGP. In addition to the WBGP module , the anchor Web routers  each include a WILD protocol module . The WILD protocol module  uses the WBGP module  to communicate with the external BGP router(s) in the host AS to obtain the ASPATH information and generate the NL maps. As part of this process, the WILD protocol module's WLM module (not shown in detail) converts the ASPATH information to a latency metric.","The WILD protocol module  further uses an Adaptive Link-State Protocol or ALP (see, J. J. Garcia-Luna-Aceves and M. Spohn, \u201cScalable Link-State Interface Routing,\u201d Proc. IEEE International Conference on Network Protocols (ICNP 98), Austin Tex., Oct. 14-16, 1998, incorporated herein by reference) module  for obtaining VON connectivity and Web router reachability information. It also uses ALP messages to encapsulate and deliver its own WILD messages. Other routing protocols can be used instead of ALP, provided that the protocol does not create permanent or long-term loops after link cost increases or resource failures.","The ALP module  reports distances to the WILD module , so that the WILD module  knows about unreachable anchor Web routers while determining validity of NL maps and WILD maps (see below). One application programming interface (API) for integrating the WILD module  with the ALP module  resembles the following:",{"@attributes":{"id":"p-0092","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function name","wldAlpInit"]},{"entry":["Return value","void"]},{"entry":["Paramters","IpAddr hostAddr"]},{"entry":["Description","Called by ALP to initialize WILD with the address of the"]},{"entry":[{},"host Web router"]},{"entry":["Function name","wldAlpMcState"]},{"entry":["Return value","void"]},{"entry":["Parameters","IpAddr mcaddr"]},{"entry":[{},"McType metype"]},{"entry":[{},"Flag isnbr"]},{"entry":[{},"Flag state"]},{"entry":[{},"Distance dist"]},{"entry":["Description","Called by ALP to indicate the status of a Web router."]},{"entry":[{},"mctype specifies the types associated with the device."]},{"entry":[{},"dist specifies the distance of the subject Web router"]},{"entry":[{},"identified by the MAC address (mcaddr) to this Web"]},{"entry":[{},"router. state specifies if the Web router is operational"]},{"entry":[{},"or not and isnbr indicates whether the subject Web router"]},{"entry":[{},"is a neighbor."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The WILD protocol module  also uses a Web router interface (WRI) to obtain server-load information from the server . This server load information is subsequently used by the WILD protocol module  for generating WILD maps. More particularly, the WRI module (not shown in detail, as the WRI may be included in WILD module ) informs the WILD module  about the status and load of the local server(s) . The WRI module periodically polls the local server(s)  to obtain the load information. If the server  fails, a load of infinity is reported to the WILD module . An API for interfacing the WILD module  with the WRI is as follows:",{"@attributes":{"id":"p-0094","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function name","wldCacheLoadNotify"]},{"entry":["Return value","void"]},{"entry":["Parameters","IpAddr caddr"]},{"entry":[{},"Distance dist"]},{"entry":["Description","Called by WRI to inform WILD of change in the load"]},{"entry":[{},"(dist) of a server identified by caddr. A load value of"]},{"entry":[{},"infinity is reported if the server has failed."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The WILD protocol module  further interacts with a Web router query (WRQ) module  in directing clients to optimum servers. The Web router responds to queries from the WRQ module . The queries can be for the nearest server, redirector, DNS server or another Web router. AN API for this interface is:",{"@attributes":{"id":"p-0096","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function name","wldGetClosestCache"]},{"entry":["Return value","void"]},{"entry":["Parameters","unit32 count"]},{"entry":[{},"IpAddr caddr"]},{"entry":[{},"unit32 *error"]},{"entry":[{},"IpAddr *list"]},{"entry":["Description","Called by WRI to obtain information regarding the clos-"]},{"entry":[{},"est server for a client (caddr)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each Web router runs the WILD protocol (to allow for the above-described mappings of subnets to servers) and exchanges WILD messages with neighbor Web routers to construct the WILD tables. The WILD messages primarily carry the subnet-to-Web router and subnet-to-server mapping information. As indicated above, a subnet is defined by a network prefix and a mask, and the map information related to a subnet applies to all clients with addresses that belong to that subnet. The messages are exchanged as payloads of control messages of the underlying ALP.","In one embodiment, ALP is implemented in GateD and runs on each Web router. GateD is a commercially available, modular software program that includes certain core services, a routing database and various protocol modules supporting multiple routing protocols. GateD and GateD-based products are available from NextHop Technologies, Inc. of Ann Arbor, Mich. ALP notifies the WILD protocol module  as distances to various Web routers and servers change.","When a Web router receives a WILD message it first validates the message contents using sequence numbers, and then updates its tables based on distance. The end result is that the WILD tables at each Web router converge to the closest subnet-to-server mappings. As mentioned earlier, the subnet-to-server latency is sum of the subnet-to-Web router latency and the server-load latency and is graphically depicted in . All measured network latencies and server latencies are converted to common metric called Cenus Metric Units (CMUs). The subnet-to-Web router and subnet-to-server distances or latencies are thus measured in CMUs. When queries (issued by the WRQ module ) for a nearest server, redirector, etc. are received, the Web router performs a table lookup using the WILD tables and returns the requested information.","Thus far, the description has indicated the use of various tables and maps (i.e., table entries). The following notation will be used below in describing these tables and maps in more detail.",{"@attributes":{"id":"p-0101","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"prefix, mask","Together they define a subnet in the Internet"]},{"entry":[{},"cs","Address of a server"]},{"entry":[{},"wr","Address of a web router"]},{"entry":[{},"asn","The AS number of a WR"]},{"entry":[{},"dist","Distance specified in CMUs"]},{"entry":[{},"anch","Address of an anchor web router"]},{"entry":[{},"seq","Sequence number"]},{"entry":[{},"load","Load on a server specified in CMUs"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The following are the key tables maintained at a Web router. These tables include entries that are referred to as maps.","Network Latency (NL) Tables: A table entry is of the form [prefix, mask, wr, dist, anch, seq] and is referred to as a map. It specifies the distance between the subnet defined by prefix and mask to the Web router wr as reported by the anchor anch. seq is the sequence number assigned by anch to this information. The distance dist measured in CMUs includes only the network latency and not the latency of the server. The table holds only the best map among all the maps reported by the anchor Web routers for each subnet.","Server Load (CL) Table: Contains the load information of the local servers. A table entry is of the form [cs, load], where cs is the address of the local server and load is the server latency measured in CMUs. Each time load on a local server changes, the corresponding table entry is updated and a WILD event is triggered. A WILD event may be propagation of a map as part of one or more of the updates described below for Procedure WILD.","WILD Table: The table entry is of the form [prefix, mask, cs, dist, anch, seq]. The entry states that cs is the most favored server that can service the subnet specified by prefix and mask. The distance dist is measured in CMUs and is the sum of the network latency and the server latency. seq is the sequence number assigned by the web router to this information when it is advertised. This table is updated in response to WILD updates received from neighbors, local server load changes and NL map updates received from anchors.","Machine (MC) Table: This is a compound table that holds information regarding local servers and remote Web routers. For local servers, the table includes the server load information. For Web routers, it includes type information, such as whether the Web router is an anchor, a redirector, etc. The table entry is of the form [mc\/cs, flags, type\/load]. mc is the address of a Web router and cs is the address of a server, depending upon which form of entry is referenced. The flags field indicates whether the identified device (i.e., server or Web router) is operational or not, etc. The type\/load field indicates for a Web router whether that device is an anchor web router, a redirector etc., and for a local server specifies the load on that server.","The WILD messages are exchanged between Web routers as payload information in ALP messages. Each WILD message has one or more WILD updates whose packet data units (PDUs) contain one or more NL and\/or WILD updates. An NL update entry is of the form [prefix, mask, wr, dist, anch, seq], and thus carries information contained in an entry of an NL table. An example of a PDU for an NL-map update is:",{"@attributes":{"id":"p-0108","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"prefix","mask","wr","dist","anch","seq"]},{"entry":[{},"(32 bits)","(32 bits)","(32 bits)","(32 bits)","(32 bits)","(48 bits)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0109","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"prefix","mask","wr","dist","anch","seq"]},{"entry":[{},"(32 bits)","(32 bits)","(32 bits)","(32 bits)","(32 bits)","(48 bits)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["prefix","mask","wr","dist","anch","asn","seq"]},{"entry":["(32 bits)","(32 bits)","(32 bits)","(32 bits)","(32 bits)","(32 bits)","(48 bits)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"The above-described update messages are used to determine whether or not the corresponding map entries in the NL and WILD tables should be updated. The WILD protocol module  handles this process. The following pseudocode describes the handling of various events that are received by the WILD protocol module . Flow charts are also provided to illustrate these procedures, which may each be implemented as a subroutine that may be called as the triggering events occur.","Procedure WILD:\n\n","The rules for determining map precedence may be understood as follows. Let \u03b1=[p, m, w, d, a, s] and \u03b2=[p, m, w, d, a, s] be two NL maps of particular subnet with prefix p and mask m. w and ware corresponding Web router addresses in the two NL maps. Similarly, d and dare distances, a and aare the anchor addresses, and s and sare the sequence numbers. The precedence between NL maps x and y is defined as follows:\n\n","The above precedence rules strictly order the two given maps. If two maps have the same precedence, then they are identical. The hashing technique is designed to achieve load balancing by distributing subnets evenly among several equidistant servers.","The same precedence rules apply for comparing WILD maps. For WILD maps, however, w and ware the server addresses, and a and aare the addresses of the Web routers to which the servers are attached.","Now that the processes for updating maps have been described, we return to the procedures for creating the maps in the first place. NL maps are created at anchor Web routers. Recall that an anchor is a Web router that has a BGP feed from its host AS. For a given Web router, the WBGP module of the anchor Web router associated with that Web router searches the BGP ASPATH database and generates NL maps between the Web router and all the subnets. Ideally, an anchor will produce NL maps for only those Web routers that are in the same AS. This will be efficient, as it reduces number of map updates that are generated.","Sometimes, however, an AS that has one or more Web routers may not be able to provide BGP feeds to any of those Web routers. These Web routers, which we call \u201corphan Web routers\u201d, thus have to depend on anchors in other ASes for their NL maps. So, it is sufficient for each anchor Web router to generate NL maps for Web routers in the set W=W\u222aW, where Wis the set of Web routers in the same AS as the anchor and Wis the set of all orphan Web routers.","To illustrate the sets W, Wand W, consider the Web routers shown in . The Web routers c, e and d in AS, AS and AS, respectively, are anchors and receive BGP feeds from their host ASes. These anchors generate NL maps for all the web routers in the same AS. For example, the Web router c in AS generates maps for a, b and c. As there is no anchor web router in AS, the Web routers x and y in AS are considered orphan Web routers. Anchors in other ASes generate NL maps for these orphan web routers. So for example, the anchor c generates NL maps for a, b, c, x, and y. It does not, however, generate maps for Web routers in AS and AS, as they are provided for by the anchors e and d respectively.","We now describe how the set W=W\u222aWis computed at an anchor, assuming the anchor has a list of all anchor web routers available. How the list of anchors is constructed is described subsequently.","Once an anchor constructs a list of known anchors, it can construct the list Was follows:\n\n","Once the anchor Web routers have been identified, they can proceed to generate NL maps. Given a set of prefixes and their ASes, a set of Web routers, and a set of ASPATHs, the NL maps are generated as follows:\n\n","Each of the above items (i.e., prefixes and their ASes, a set of Web routers, and a set of ASPATHs) is dynamic and can change. The following rules describe adaptations that need to be made in response to these dynamic changes.\n\n","As indicated above, one mechanism for constructing an anchor list is to use the Anchor-Type Protocol to propagate Web router type information. Each Web router receiving this information adds the new Web router to its list of anchors. The type (e.g., anchor or not) of a Web router can be explicitly configured through an ALP configuration file or implicitly determined through automatic detection of a BGP peering relationship. ATP can be realized through various methods","tone such method utilizes the following rules:\n\n","Thus, a scheme for directing clients to optimal serves has been described and although the foregoing description and accompanying figures discuss and illustrate specific embodiments, the present invention is to be measured only in terms of the claims that follow, and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not limitation, in the figures of the accompanying drawings in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0052","num":"0058"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0053","num":"0059"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0054","num":"0060"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0055","num":"0061"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0056","num":"0062"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0057","num":"0063"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0058","num":"0064"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0059","num":"0065"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0060","num":"0066"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
