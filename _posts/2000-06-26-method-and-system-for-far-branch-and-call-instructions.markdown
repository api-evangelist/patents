---
title: Method and system for far branch and call instructions
abstract: The present invention provides a method for far branch and call instructions. The present invention includes the link-time modification of object code generated by the compiler or assembler and the addition of custom generated object code to the link for the purpose of implementing far branches and calls without changing the compiler generated instructions or expanding compiler generated object code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06928641&OS=06928641&RS=06928641
owner: Texas Instruments Incorporated
number: 06928641
owner_city: Dallas
owner_country: US
publication_date: 20000626
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of provisional application Ser. No. 60\/158,248 filed Oct. 8, 1999.","The present invention relates to software development tools, and, more particularly, to software program linking and methods.","Software is constructed in pieces. Source code is expressed in a language, such as \u201cC\u201d or assembly, and is organized into multiple text files. Each of these files is processed into a corresponding binary file known as an object file by a compiler and\/or an assembler. A linker combines the object files into a single file. The linked output file may be a complete application, and may be executed on a particular target hardware system. Alternatively, the output may be a partial link such that it is used as an ingredient in a subsequent link.","To perform the linking process, the linker is given a list of ingredient object files, a description of the hardware and directions on how to combine and place the ingredients into the memories. The ingredient files are composed of \u201csections\u201d. Each section contains code or data to be placed into the memories. During this process, different sections of the compiled application are assigned to various memories of the target hardware system. Embedded systems, such as digital signal processors (\u201cDSPs\u201d), have a plurality of memory types with different sizes, speeds and other characteristics. The allocation of memory to the different pieces of application code and data to the different locations in memory affects the performance of the application after it is embedded onto the hardware system.","Referring to , a software development system  is depicted. As described above, text files  and  are source code written by a programmer. Text files  and  may represent a plurality of text files. Compiler  translates the source code in text files  into assembly language source code. Text files  represent assembly language source code files written manually. Assembler  translates the assembly language source files from compiler  or a programmer. Machine language object files  are outputted from assembler . Object files  may be known as object programs or object modules. As described above, object files  are the corresponding binary files to text files  and , either alone or in combination.","Linker  combines object files  into a single executable object module, or output file . In addition to object files , linker  accepts library files  containing multiple object files. Linker  also allows for the combination of object file sections, binds sections or symbols to addresses within memory ranges, and defines or redefines global symbols. After linking operations are completed, output file  is downloaded to processor . Thus, linker  places object files  in memory on processor  as output file, or output program, .",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2A","b":["200","110","108","108","206"]},"Linker allocation directions in linker commands  are expressed in a custom text-based command language requiring extensive study and documentation. A user inputs and edits linking instructions in text editor . Text editor  writes the instructions into command file  to be inputted into linker . The user studies the textual linker output in map file  and errors  for the results of the linking instructions and makes any necessary changes to the command file . This process is repeated until the desired results are obtained. Linker  receives object files  and library files . Using command file , linker  links ingredients  according the linking instructions to separate output file . As described above, output file  may be an executable application.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2B","b":["221","110","222","110","108","112","206","224","110","110","206","225"]},"Step  executes by determining whether all referenced symbols have been defined by linker . If no, then step  executes by issuing an error signal or message. If yes, then step  executes by determining whether the sections of code and data fit in the target memories. If no, then step  executes by issuing an error signal or message as a problem has arisen that must be resolved. If yes, then step  executes by relocating symbolic references in the allocated sections of code or data. Step  executes by writing output file  and link map file  for review by a user.","Step  executes by denoting a failure has occurred in the linking operations. Step  may execute subsequent to the error message in step . Step  executes by denoting the linking operations have been successful.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3","b":["110","316","318","300","1","2","3","302","1","2","304","1"]},"Allocation module  inputs linker commands . Linker commands  are a set of instructions that tell allocation module  where to place the sections of object files A, B, and C in the target computer hardware memories. Memories  and  represent memory devices within the target system. Memories  and  have different locations and addresses within the address space of the target system. Using the linking instructions, allocation module  places each section within the ingredients into a memory device. For example, allocation module  places section A of object file A in memory  at a specified location. Allocation module also places section B of object file B in memory  at another location, different from the location of section A.","Allocation module  also resolves any issues regarding symbolic references within the sections of the object files. Sections may have calls, or branches, to subroutines in other sections within the object files, or even to other object files. These calls are represented by symbol references within the code. As the sections of code are linked within memories  and , the symbolic references to symbols within these sections are replaced by address locations within the memory.","Referring to , a linker symbol resolution system is depicted. Ingredients  include object files having a plurality of sections of code, including sections  and . Section  includes a code block  that contains a definition of a branch label A. Code block  also includes other information. Section  also includes a symbol dictionary block  that lists symbol A as being defined in section , and has an offset of 20 from the origin of code block .","Section  includes a code block  and a symbol dictionary block , similar to section . In code block , a branch instruction lists branch label A as its target. Symbol dictionary block  lists symbol A as being a reference to a definition elsewhere without a known offset as section  has not been allocated to a memory location.","During the allocation phase of allocation module  in , linker allocation decision module  allocates sections  and  of ingredients  to specific addresses in the target computer hardware memory. Linked output file  includes allocated sections  and  that correspond to section  and , respectively. Branch target , or label A, is located within allocated section . Further, branch instruction, or call,  to label A is located within allocated section . Branch instruction  is known as a symbol reference within allocated section .","The base, or beginning, addresses of sections  and  are recorded in table block  inside linker . For example, the base address of section  is memory address . Referring to symbol dictionary block , symbol A has an offset of 20 from the base address. Thus, branch target , or label A, is located at address  within the memory.","During the relocation and output steps of the linking operations, all symbol references  are replaced by actual addresses computed by adding the symbol offsets in the symbol dictionaries to the section base addresses in table block . These addresses are inserted into the linked code, such as symbol reference . Thus, the symbol references are replaced by address locations by linker .","Referring back to , after allocation module  completes the allocation of the sections of object files A, B, and C, then output module  links the sections within the memories to generate output file  that represents an application to be run on a target computer system.","The linking process involves a preparation period for a user to resolve any errors with the linking process, as described in step  of . Known linkers report errors and may fail to complete the allocation of the ingredients object files if there are unresolved symbolic references. Thus, if the list of input object files and libraries is not complete, then an error occurs within the linking process. The user then re-edits command file  to improve or adjust the linking instructions. This activity inhibits interactive allocation strategies in which a user attempts to optimize the allocation of only a part of the ingredients of the software program before the remaining parts of the program are available or written. No links may be left incomplete. Therefore, extensive experimentation is prohibited and users are discouraged from finding more optimal ways of linking.","Attempts to reduce development time for the linking instructions include tools that dialogue with the user, and write linker instruction command files for the user. These tools are appropriate for simple applications, but may not be able to adequately optimize complex applications or memories. Another attempt includes a visual link map analyzer that uses visual input to edit a linker instruction command file, and runs the command file through the linker. The analyzer displays the linker map file . These systems, however, include two separate programs, a traditional linker and a visual analyzer. These programs maintain separate models of the link in order to perform their respective tasks.","Further, known linkers are unable to resolve incomplete links. Referring back to , all sections must fit in memories before an output file may be created or the symbol references resolved. This requirement inhibits interactive linking strategies as all links must be complete before an map file is generated for review by the user.","As software applications evolve, the ingredients change as do the sizes and the properties of the individual ingredient object files . The instructions in command file  for allocation of a target system memory may become obsolete periodically and require maintenance. Directions are updated to interface with new hardware target system memories.","In many instances, it is the user's responsibility to understand all component specifications and requirements and to reflect them in text-based linker command file . The user combines these constraints in generating the linking instructions with text editor . For updates, the user manually merges linker command file  into a bigger command file each time.","Linking operations impact performance on embedded processors, such as digital signal processors. Unlike general purpose processors having a single, large memory, embedded processors have many different memories. The layout of the application into various target memories impacts performance. Certain kinds of fast memory, such as on-chip memory, are limited in space and desired for critical application functions. Trade-offs are made depending on the size of the programmer's application plus any third party components and libraries. As the program evolves and grows, the allocation decisions are revised in a time-consuming manner.","New software development tools that build applications from large, predefined components are available. The tools attempt to manage the linking process, but are hindered by having to write commands  and by having to parse map files , and error files , that intended for humans.","Many linking operations result in \u201cnear-branch\u201d and \u201cfar-branch\u201d instructions. Linking operations also result in \u201cnear-call\u201d and \u201cfar-call\u201d instructions. A branch is a one way instruction, while a call is a branch and return instruction. Calls typically are used in conjunction with subroutines. Known computer architectures employ both types of instructions. A near-branch or near-call instruction, or near branch, is capable of transferring program control a limited distance from the address of the branch instruction to the target address. A far-branch or far-call instruction, or far branch, is capable of transferring program control a greater distance to a target address. The far branch, however, requires more memory space and is slower than a near branch. The far branch takes more bits to designate the remote location and going to that remote location takes more time. For a call the word call would take 8 bits and the location for a far call would take more than 8 bits. A target address may have many branches that reference it from inside and outside the section or block of code. An \u201cexternal branch\u201d and a \u201cglobal target\u201d identify a branch and target address in different object code sections. In addition, these terms may be referred to as \u201cexternal call\u201d and \u201cglobal subroutine\u201d in branch and return applications.","Because of the lower memory requirements and higher speed, near branches are preferred over far branches. Generally, the distance between an external branch and its target address is not known until the linker places the sections in memory. This step is after the compiler has generated the branch code. If a near branch is generated where a far branch is needed, the object code does not run correctly and may require modification. One modification is to recompile or reassemble the source code using correctly-sized branches. Few compilers and linkers, however, provide for communication of actual branch distances from the linker to the compiler. A common practice is to direct the compiler to generate only far branches. This practice is inefficient. Another common practice is to annotate source code to specify particular near and far branches. This practice results in a long term maintenance problem as the software program evolves and branch distances change. It also is time-consuming.","One attempt to resolve these issues is described in U.S. Pat. No. 5,740,447, herein incorporated by reference. The method described in the patent calls for the linker to change near branches to far branches, and vice versa. Depending on the computer architecture, this method may require the linker to substitute different branch instructions of possibly different sizes, and possibly to insert additional instructions. Requiring additional instructions is notable because some computer architectures require the use of a register in order to load an address for a far branch. Therefore, when a near branch is produced by the compiler, a free register may not be available to use for the new far branch inserted by the linker. Further, it may be necessary to change near-return instructions to far-return instructions if the original branch is actually a subroutine call instruction.","Two deficiencies may exist in the method of link-time fix-up. First, it may be difficult to implement the method in a linker because changing a branch may cause other changes to ripple throughout the object file as its size changes. Specifically, analyzing object code to locate a free register may be quite difficult. Second, the modified object code may be less efficient than the object code produced by the new method. The inefficiency arises by changing several near branches sharing a single target to far branches requiring additional memory space than the new method. In addition, if the compiler reserves a register in order to simplify potential link-time fix-ups, then the overall object code efficiency may suffer by not having the register available.","From the foregoing it may be appreciated that a need has arisen for a system and method for an interactive visual linker that may be controlled either by humans or software components. In accordance with one embodiment of the present invention, a method and system for a visual linker is provided that substantially eliminates and reduces the disadvantages and problems associated with conventional linkers in software development systems.","The method involves the link-time modification of object code generated by the compiler or assembler, and the addition of custom-generated object code to the link, for the purpose of implementing \u201cfar branches\u201d.","The present invention implements and results in space savings depending on particular characteristics of the object code.","Compilers and assemblers generate near-branch or near-call instructions for all external branches or external calls, respectively. (Hereafter we refer only to calls but the same applies to branches.) The linker analyzes each external call. If the target is too distant from the call, the linker redirects the near call to new \u201ctrampoline code\u201d which then performs a far call to the original target. The original return will return control to the trampoline, which in turn returns to the original call. Special care is taken to be sure the processor state, including call stack, registers, arguments, etc., appear to the final target to be exactly as if a near call had been made from the original call site.","This single-trampoline modification may fail to work if any of certain conditions exist, including: the need to use resources such as registers to prepare for a far call; the need to use different entry points for near and far calls; or any other condition in which a far call to the original call target cannot be made in a way that mimics a near call from the original caller. In these cases, a two-trampoline solution is needed.","For the two-trampoline solution, the linker creates two trampolines; the first trampoline is linked close to the original call, and the second trampoline is linked close to the original target. The original near call is changed to point to the first trampoline; the first trampoline performs a far call to the second trampoline; and the second trampoline performs a near call to the original target. Special care is taken to be sure the processor state, including call stack, registers, arguments, etc., appear to the final target to be exactly as if a near call had been made from the original call site.","When there are several branches to the same target, the linker attempts to share the same trampoline code to save space.","The present invention allows a user, software program, or component via commands, gestures, and application programming interfaces (\u201cAPI\u201d) to specify a link in an incomplete fashion. During such incremental specification, the link may be incomplete. Ingredient object files need not be complete. Nor do all sections from each object file need to be placed into memory. Symbolic references need not be resolved.","With reference to the incomplete link, the visual linker of the present invention communicates to the user via visual or graphical displays without producing errors or other procedures to prevent further linking operations. This feedback includes the allocated position and size of the sections that are allocated to memory, the values of symbols that are allocated, a list of symbolic references that are not defined, and a list of ingredient object files and sections that are not allocated. Thus, the user receives real-time feedback on the results of the linking operations even if not all object files and sections are allocated to a location in memory. Therefore, the user may select or experiment with linking instructions without the need for verification.","Further, the user may complete incrementally an incomplete link by a plurality of commands, either alone or in combination. The commands include adding or removing ingredient object files or code sections to be included in the linking operations. The commands also include specifying the sections from the ingredient files that are to be allocated. The commands also include de-allocating or reallocating sections previously allocated. The commands also include specifying a memory area that certain sections or various kinds of sections are to be allocated. The commands also include specifying constraints on the allocation of certain sections and object files, such as specifying absolute addresses for sections or symbols, or specifying alignment constraints on addresses for sections or symbols. The commands also include specifying the order that sections and object files are allocated. The commands also include defining new symbols that are referenced by object files during linking operations. The commands also include specifying characteristics of the allocation strategy, such as specifying those sections that are not referenced by other sections that may be included in the linking operations.","The present invention also includes a link server API that allows other client software programs or program components to participate in the link process. The link server provides continues feedback to the client programs or components and this enables the programs or components to monitor and react to the incomplete link described above. The client program or component may issue a plurality of commands through the API, either alone or in combination, to the link server. The commands include adding or removing ingredient object files or code sections to be included in the linking operations. The commands also include specifying the sections from the ingredient files that are to be allocated. The commands also include de-allocating or reallocating sections previously allocated. The commands also include specifying a memory area that certain sections or various kinds of sections are to be allocated. The commands also include specifying constraints on the allocation of certain sections and object files, such as specifying absolute addresses for sections or symbols, or specifying alignment constraints on addresses for sections or symbols. The commands also include specifying the order that sections and object files are allocated. The commands also include defining new symbols that are referenced by object files during linking operations. The commands also include specifying characteristics of the allocation strategy, such as specifying those sections that are not referenced by other sections that may be included in the linking operations.","The link server provides continuous feedback from the linking operations. Feedback is information passed from the linking operations back to the client software program or component so that the program or component may perform additional operations. Via the link server, the client software program or component may determine the address assigned to a section or symbol during linking operations. The program or component may determine the length of a section. The program or component may determine whether any section is not allocated as specified. The program or component may determine whether any control action succeeded or failed. Further, the interface between the link server and other software programs or components allows more than one program or component to simultaneously control and\/or receive feedback during linking operations.","The present invention also includes a link server that receives commands or gestures from an input device and translates the commands or gestures into linking instructions within a linking recipe. The commands or gestures include drag and drop commands, and menu commands using a mouse. The link server allows the steps of the linking recipe to be replayed, without user interaction, to obtain a similar effect as the sequence of commands or gestures. The linker also allows the steps of the recipe to be viewed and individually changed. The linker also allows the steps of the recipe to be imported into other recipes to perform part or all of a linking process.","During the process of creating the steps, the link server generalizes the gestures or commands. Thus, a consecutive series of commands or gestures that result in moving each section of a particular kind to a particular memory area is generalized to a single step that moves all sections of the particular kind to the particular memory area. Further, a command or gesture that moves each section currently referenced by a particular section is generalized to a single step that moves any sections referenced by the particular section. Moreover, a command or gesture that moves each section from a particular object file is generalized to a single step that moves all section from the particular object file.","A technical advantage of the present invention is that a visual linker is provided. Another technical advantage of the present invention is that a visual linker is portable and compatible with multiple target embedded memory systems.","Another technical advantage of the present invention is that the visual linker interacts with other software tools and wizards. Another technical advantage of the present invention is that the visual linker builds a linking strategy amongst mixed multiprocessor systems.","Another technical advantage of the present invention is that the visual linker allows a user to view visual and graphical memory layouts while adjusting memory allocations. Another technical advantage of the present invention is that the visual linker may be a stand-alone software tool. Another technical advantage of the present invention is that the visual linker has plug-and-play capability.","Another technical advantage of the present invention is that the time to develop linking process instructions and strategies is reduced. Another technical advantage of the present invention is that training requirements are minimized and training time is reduced. Another technical advantage of the present invention is that a visual linker is provided with increased functionality. Another technical advantage of the present invention is that the visual linker allocates blocks of code to embedded memory machines without running confidence check programs and in reduced time.","An embodiment of the present invention and its advantages are best understood by referring now in more detail to  of the drawings, in which like numerals refer to like parts. A description of a visual linker using the present invention is further described in provisional U.S. Patent application Ser. No. 60\/158,249 filed Oct. 8, 1999 and non-provisional application serial no. filed of L. Szewerenko et.al entitled \u201cMethod and System for Visual Linker\u201d incorporated herein by reference.  illustrate a visual linker for far branch and call instructions in accordance with one embodiment of the present invention.","As discussed in the linker of the referenced application the hardware system includes a computer workstation  with a processor , a display with screen , a keyboard  and a mouse  as illustrated in . The workstation includes a GUI interface with a drag and drop program where the ingredients or object files and libraries are dragged and dropped (allocated) to memory locations. When the command is for a branch or a call instruction the linker analyses each branch or call and if the target location is for an address that too distant from the branch or call location, the linker of the present invention redirects the near call to a new custom generated object code or \u201ctrampoline code\u201d for implementing the \u201cfar branches or calls\u201d. This new custom generated code or \u201ctrampoline code can when not too far perform the far call to the original target. When a call the original return will return control to the trampoline, which in turn returns to the original call.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6","b":["502","506","510","504","504","506","510","512","508","506","502","504"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 7","b":["502","504","602","502","602","1","609","506","1","609","1","610","612","510","504","510","512","614","616","618","618","508","610","616","0","0","0","0"],"sub":"\u2014"},"The single-trampoline may not work in certain conditions such as: the need to use resources such as registers to prepare for a far call; the need to use different entry points for near and far calls; or other conditions in which a far call to the original call target cannot be made in a way that mimics a near call from the original caller. In these cases a two-trampoline solution is needed.","For the two-trampoline solution, the linker creates two trampolines wherein the first trampoline is linked close to the original call and the second trampoline is linked close to the original target. The original near call is changes to point to the first trampoline; the first trampoline performs a far call to the second trampoline; and the second trampoline performs a near call to the original target.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 8","FIG. 7"],"b":["602","702","504","702","2","704","506","1","609","1","612","2","704","2","708","510","512","710","714","614","618","508","602","610","616","702","706","712"]},"The trampolines necessary to implement one-way branches instead of calls is an simplification of the cases shown. The call instructions  in section ,  in section , and  in section  are replaced by one-way branches. The following lines of code in the figures do not exist in the one-way branch case:  in the first section ;  in the second section ; , , and  in the first trampoline section ; and lines , , and  in the second trampoline section . When there are several branches to the same target, the linker attempts to share the same trampoline code to save space.","The detailed logic used to determine when and how to create trampolines is as follows and illustrated by the flow chart of , given a near call C in one section that references a target T in a second section. This algorithm is used for each such call in the program being linked. (The same symbol names are used as in .)\n\n",{"@attributes":{"id":"p-0073","num":"0081"},"figref":["FIG. 10","FIG. 11","FIG. 12"],"sub":["\u2014","\u2014","\u2014","\u2014","\u2014"]},"The present invention fixes link time problems that occur at link time because of link time decisions. This is done without reverse engineering around calls. There is no need for changing source code for the linker can take care of it's own problems. There is also provided sharing of trampolines to reduce growth. There is also provided a sequence to preserve recovery.","Thus, it is apparent that there has been provided, in accordance with an embodiment of the present invention, a visual linker that satisfies the advantages set forth above. Although the present invention has been described in detail, it should be understood that various changes, substitutions, and alterations may be made herein. Other examples are readily ascertainable by one skilled in the art and may be made without departing from the spirit and scope of the present invention as defined by the following claims."],"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in connection with the accompanying drawings, in which:",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
