---
title: Searching apparatus, searching method, and computer program product
abstract: In a searching apparatus: a first receiving unit receives a search request from a client; based on the search request, a first generating unit generates a distributed search request to request a server to conduct a search and an integration request to integrate search results of the distributed search request; a first transmitting unit transmits the distributed search request to the server; a second transmitting unit transmits identification information of an execution result of the integration request to the client; a second receiving unit receives, from the client, an obtainment request to obtain the execution result identified by the identification information; a receiving unit receives the search results of the distributed search request from the server; an executing unit executes the integration request on the received search results; and a third transmitting unit transmits the execution result of the integration request to the client that transmitted the obtainment request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047391&OS=09047391&RS=09047391
owner: Toshiba Solutions Corporation
number: 09047391
owner_city: Tokyo
owner_country: JP
publication_date: 20110825
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is based upon and claims the benefit of priority from Japanese Patent Application No. 2010-238531, filed on Oct. 25, 2010; the entire contents of which are incorporated herein by reference.","Embodiments described herein relate generally to a searching apparatus, a searching method, and a computer program product.","Distributed XQuery processing techniques for realizing XQuery processing by using a distributed system have been developed. However, attempts to realize distributed XQuery processing have just begun, and it is only possible to find some documents written about distributed XQuery processing.","XQuery Remote Procedure Call (XRPC), which is a type of distributed XQuery Processing, is a language extension of XQuery for different types of distributed data sources. XRPC realizes distributed XQuery with a technical feature called Remote Procedure Call (RPC) used as a built-in function for an XQuery.","With XRPC, which is a representative conventional technique to realize distributed XQuery processing, a problem remains where, for example, the user needs to explicitly describe XRPC in an XQuery, XRPC being a special language extension.","A searching apparatus according to an embodiment includes a first receiving unit, a first generating unit, a first transmitting unit, a second transmitting unit, a second receiving unit, a receiving unit, an executing unit, and a third transmitting unit. The first receiving unit receives a search request from a client. Based on the search request, the first generating unit generates a distributed search request to request a server to conduct a search and an integration request to integrate search results of the distributed search request. The first transmitting unit transmits the distributed search request to the server. The second transmitting unit transmits identification information of an execution result of the integration request to the client. The second receiving unit receives, from the client, an obtainment request to obtain the execution result identified by the identification information. The receiving unit receives the search results of the distributed search request from the server. The executing unit executes the integration request on the received search results. The third transmitting unit transmits the execution result of the integration request to the client that transmitted the obtainment request.","Exemplary embodiments of a searching apparatus will be explained in detail, with reference to the accompanying drawings. In the following sections, a system will be explained as an example in which a search is conducted on data in an Extensible Markup Language (XML) format in response to a search request in an XQuery format. However, the systems to which the embodiments are applicable are not limited to this example.","In XML, individual parts constituting a document structure are called \u201celements\u201d. Each of the elements is written by using tags. More specifically, each of the elements is expressed by enclosing text data between two tags that are namely a tag (a start tag) indicating the start of the element and a tag (an end tag) indicating the end of the element. The text data enclosed between the start tag and the end tag serves as a text element (a text node) contained in the one element expressed by using the start tag and the end tag.","XQuery is a functional language used for querying an XML database (an XML-Database Management System [DBMS]). A characteristic of an XQuery is a FLWOR (for-let-where-order by-return) structure. While Structured Query Language (SQL), which is a query language for a relational database (RDB), is a declarative language, XQuery in contrast has many characteristics of a functional language. In the following sections, language specifications of XQuery will be explained from a viewpoint of procedures.","A for clause is expressed by using a structure \u201cfor variable in expression\u201d. The structure of a for clause indicates that a member that satisfies the expression should be assigned to the variable so as to cause a loop. A let clause is expressed by using a structure \u201clet variable :=expression\u201d. The structure of a let clause indicates that members that satisfy the expression should be aggregated and assigned to the variable as a sequence. The \u201csequence\u201d is a flat list. A where clause limits the loop iterated by the for clause. A where clause is expressed by using a structure \u201cwhere expression\u201d. The structure of a where clause indicates that only members satisfying the expression go through the loop, whereas members not satisfying the expression skip the loop. A return clause formats a result of processing an XQuery. A return clause is expressed by using a structure \u201creturn expression\u201d. By using the structure of a return clause, it is possible to describe arbitrary XML data containing variables. A variable is expressed by using a structure \u201c$ character string\u201d. Except when being doubly declared due to a nested query or the like, variables having mutually the same character strings are considered as the same variable. As path operators each specifying a hierarchical condition between elements in XML data, the following operators can be used in an XQuery:\n\n","As described above, XRPC is known as a distributed XQuery processing technique for realizing XQuery processing in a distributed system.",{"@attributes":{"id":"p-0048","num":"0050"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","10","20","21","30"]},"The client \u2032 requests the central server \u2032 to execute a query  written in an XQuery format. The query  indicates that \u201cthe function filmsByActor of an XQuery  that is present in the site x.example.org should be called with respect to Actor A and Actor B\u201d. The XQuery  indicates that \u201cfilmName having an actorName that matches the variable $actor should be extracted from an XML file \u201d.","An overview of the process to be performed when the query  is received will be explained below.\n\n","The XRPC technique has problems as described below:\n\n","To cope with these problems, a virtual XML database system including a central server  serving as a searching apparatus according to a first embodiment is able to realize distributed XQuery processing without using XRPC.",{"@attributes":{"id":"p-0053","num":"0061"},"figref":"FIG. 2","b":["10","100","20","20","30"],"i":["a ","b "]},"The DB servers and include databases (DB) and storing therein data in, for example, an XML format, respectively. Because the DB servers and have mutually the same technical features, the DB servers and may simply be referred to as the \u201cDB servers \u201d hereinafter.","The client  requests the central server  to execute a query written in an XQuery format. The network  may have an arbitrary network configuration such as a Local Area Network (LAN) or a Wide Area Network (WAN).","There are various communication protocols that can be used in the network ; however, an example that uses an Internet Protocol (IP) network will be explained below, the IP network being a computer network in which mutual connections are realized by the Internet Protocol technology. The example is applicable even if a communication protocol other than IP is being used.",{"@attributes":{"id":"p-0057","num":"0065"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["10","100","100","20"]},"REST is a style of a software architecture for a distributed hyper media system and is characterized with a stateless client\/server protocol. An HTTP message contains all the information required for understanding the request (the message). For this reason, neither the client  nor the central server  needs to store therein the state of sessions between messages. Further, a number of methods that are frequently used are defined. Of those methods, important methods are: get, post, put, and delete.","In REST, a unique address expressed with a Uniform Resource Identifier (URI), which uniquely identifies a resource, is used. The URI serves as an argument for a method. URIs are obtained by extending the concept of Uniform Resource Locators (URLs). An URI is an identifier that specifies a resource while using a predetermined format. URIs were defined as Request for Comments (RFC) 2396 in 1998 and were revised as RFC 3986 in 2005.","For example, the URI of a resource \u201cindex.html\u201d for \u201cxxxx.ne.jp\u201d can be expressed as http:\/\/www.xxxx.ne.jp\/yyyy\/public\/index.html.","According to the first embodiment, REST is extended so as to include a method \u201cquery\u201d and a method \u201cgquery\u201d. As shown in (1) and (2) below, \u201cquery\u201d and \u201cgquery\u201d are methods for requesting an execution of XQuery processing and an execution of distributed XQuery processing, respectively.","Examples of the methods used in the first embodiment are shown below. Hereinafter, \u201curi\u201d and \u201curi_* (where * is an arbitrary character string)\u201d in lower case each denote an identifier expressed using an URI format. Further, \u201cresource uri\u201d and \u201cresource uri_*\u201d denote the resources identified by the identifiers \u201curi\u201d and \u201curi_*\u201d, respectively.","(1) A Query Method","An XQuery (\u201cxquery\u201d in ) is specified (step S) and a resource uri for storing therein result XML data (hereinafter, a \u201cresult XML\u201d) of XQuery processing resulting from the specified XQuery is obtained (step S).","(2) A gquery Method","An XQuery (\u201cxquery\u201d in ) is specified (step S) and a resource uri for storing therein a result XML of distributed XQuery processing resulting from the specified XQuery is obtained (step S).","(3) A Get Method","A uri is specified (step S) and a result XML to be stored into the resource identified by the specified uri is obtained (step S).","(4) A Put Method","A uri and XML data are specified (step S) so that the XML data is stored into the resource identified by the specified uri, and a stored result (\u201cstatus\u201d in ) is obtained (step S).",{"@attributes":{"id":"p-0067","num":"0075"},"figref":"FIG. 4","b":["100","100","110","120","102","103","104"]},"The request receiving unit  receives a request from the client  or other servers (e.g., the DB server and the like). For example, the request receiving unit  receives an XQuery processing request such as a query or a gquery or a resource processing request such as a get or a put and calls a necessary process. The request receiving unit  includes a transmitting unit  (a second transmitting unit, a third transmitting unit) that transmits a response to the request.","As illustrated on the left-hand side of , the request receiving unit  receives, for example, a data search request  from the client . The transmitting unit  returns a uri  of the resource for storing therein a result XML, to the client  that transmitted the search request . Further, the request receiving unit  receives, from the client , an obtainment request  for the result XML to be stored in the resource specified by the uri. The transmitting unit  returns a result XML  to the client  that transmitted the obtainment request .","The virtual planner  performs a planning process for the distributed XQuery processing. The virtual planner  includes a generating unit  (a first generating unit), a transmitting unit  (a first transmitting unit), and a receiving unit .","When the request receiving unit  receives a distributed gquery requesting an execution of the distributed XQuery processing, the generating unit  generates a DXQuery (a distributed search request) requesting the set of DB servers  to conduct a data search and a GXQuery (an integration request) to integrate search results of the DXQuery, from the XQuery specified by the received search request (gquery).","The transmitting unit  transmits the search request with the DXQuery to the DB servers . The receiving unit  receives the search results of the DXQuery from the DB servers .","The XQuery processor  executes the XQuery.","The resource allocating unit  manages the resources while using the uri's as keys. Because XML data is exchanged in XQuery, the resource allocating unit  allocates a resource uri to each piece of XML data for the purpose of controlling the data exchange. The resource allocating unit  has a technical feature of reserving an area for storing therein a resource, a technical feature of returning a uri expressing the URI of the reserved area, a technical feature of assigning XML data to the resource uri, and a technical feature of obtaining the XML data stored in the area identified by the uri.","The server notification detecting unit  causes server information (SInfo) to be exchanged among the servers by using a broadcast or the like and detects the servers connected to the network . The virtual planner  transmits the DXQuery to the DB servers  detected in this manner. Another arrangement is acceptable in which the server notification detecting unit  is not provided, but the virtual planner  accesses the DB servers  specified in advance.","Next, a searching process performed by the central server  according to the first embodiment configured as described above will be explained, with reference to .  is a flowchart of an overall flow in the searching process according to the first embodiment.","First, when the central server  is started up, a main thread is generated (step S). The following processes at steps S through S are the processes to be executed in the main thread.","In the main thread, two server notification detecting threads (i.e., a server information notifying thread and a server information detecting thread) and a request processing thread generated for each request are generated (steps S, S, and S).","In the server information notifying thread, the server notification detecting unit  regularly transmits server information of the central server  to the other apparatuses such as the DB servers  that are connected to the network , by using, for example, a broadcast (step S). This process is repeated until the server information notifying thread ends.","In the server information detecting thread, the server notification detecting unit  receives server information from the other apparatuses such as the DB servers  that are connected to the network  and updates existing server information (step S). This process is repeated until the server information detecting thread ends.","The request processing thread is generated after an accepting process at a socket has been completed. During the accepting process, a connection is established after receiving a request indicating that a connection is waited for, so that a new socket is generated.","By using the generated socket, the request receiving unit  judges whether a request such as an XQuery processing request (query, gquery) or a resource processing request (get, put) is received (step S). If no request is received (step S: No), the process is repeated until a request is received.","If a request is received (step S: Yes), the request receiving unit  generates the request processing thread (step S). In the request processing thread, request processing to process the received request is executed (step S).","During the request processing, a syntax analysis is performed on a received HTTP message, i.e., a GET message in the present example. The HTTP message is a message that is transmitted as a request from the client  to the central server  and is returned as a response from the central server  to the client .","The structure of the HTTP message is configured so as to include a \u201cmessage header\u201d and a \u201cmessage body\u201d arranged in a plurality of lines, and the \u201cmessage header\u201d and the \u201cmessage body\u201d are separated from each other by a blank line (Carriage Return [CR]+Line Feed [LF]). The message header contains the contents of the request or the response that should be processed by the central server  or the client . The message body contains the data itself that should be transferred.","The GET method is the only method defined by HTTP\/0.9 and is used most often in HTTP. A server compliant with HTTP\/1.1 needs to support the GET method.",{"@attributes":{"id":"p-0087","num":"0095"},"figref":"FIG. 6"},"The request receiving unit  extracts the method from the message and causes conditional branching according to the type of the method extracted (i.e., the message type).\n\n","Because distributed XQuery processing is requested, the virtual planner  is called.\n\n","Because XQuery processing is requested, the XQuery is executed by the XQuery processor .\n\n","A resource is generated by the resource allocating unit , and the uri of the generated resource is returned.\n\n","The data corresponding to the resource specified by the uri is obtained.\n\n","Data is assigned to the resource specified by the uri.\n\n","Data is merged, so that the merged data is assigned to the specified resource.",{"@attributes":{"id":"p-0095","num":"0109"},"figref":"FIG. 7","b":["120","20"],"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["(1) DXQuery: an XQuery for accessing the XML data stored in each of the DB servers ","(2) GXQuery: an XQuery for integrating the XML data output by the DXQuery"]}},"First, the generating unit  included in the virtual planner  performs a DXQuery generating process to generate the plurality of DXQueries by analyzing the input XQuery (step S). The details of the DXQuery generating process will be explained later.","The virtual planner  selects one of the generated DXQueries (step S). The virtual planner  selects one of the plurality of DB servers  (step S). The transmitting unit  included in the virtual planner  transmits an execution request to request an execution of the selected DXQuery to the selected DB server  (step S). The DB server  to which the execution request was transmitted transmits the URI (i.e., uri_d) of the resource for storing therein an execution result (result XML) of the DXQuery, to the central server . Accordingly, the virtual planner  obtains uri_d, which is the URI of the resource for storing therein the result XML.","Subsequently, the virtual planner  judges whether an execution request has been transmitted to each of all the DB servers  (step S). If the judgment result is in the negative (step S: No), one of the unprocessed DB servers  is selected, so that the process is repeated thereon (step S).","If an execution request has been transmitted to each of all the DB servers  (step S: Yes), the virtual planner  requests the server of its own (i.e., the central server ) to execute a merge method to merge the pieces of data obtained from the DB servers  and stored in the plurality of resources uri_d (step S). When the request receiving unit  included in the central server  receives a message requesting the merge method, the request receiving unit  first returns the URI (uri_m) of the resource for storing therein the merged result (the result XML), to the virtual planner . Accordingly, the virtual planner  obtains the uri_m, which is the URI of the resource for storing therein the result XML.","After that, the virtual planner  judges whether all the DXQueries have been processed (step S). If the judgment result is in the negative (step S: No), one of the unprocessed DXQueries is selected, so that the process is repeated thereon (step S).","If all the DXQueries have been processed (step S: Yes), the generating unit  included in the virtual planner  performs a GXQuery generating process to generate a GXQuery that outputs a result XML satisfying the input XQuery (step S). The details of the GXQuery generating process will be explained later.","Subsequently, the virtual planner  rewrites a doc( ) function of the GXQuery with the uri_m (step S). The resource allocating unit  reserves a resource uri_g for storing therein an execution result of the GXQuery (step S). The virtual planner  returns the uri_g to the client, as a GET response (step S).","The XQuery processor  executes the GXQuery (step S). The XQuery processor  assigns the result XML, which is an execution result of the GXQuery, to the resource uri_g (step S).","As explained later, the client  transmits a get method specifying the uri_g to the central server . When having received an execution request to execute the get method, the request receiving unit  generates a request processing thread so as to wait until the result XML is assigned to the resource uri_g (step S in ). When the result XML is assigned to the resource uri_g at step S, the result XML is returned to the client  as a GET response, in this request processing thread.","Next, the details of the DXQuery generating process at step S will be explained.  is a flowchart of an example of the DXQuery generating process. During the DXQuery generating process, a main process is to traverse nodes from a doc( ) function, while considering the XQuery as a tree, in the same manner as with XQueryX. XQueryX is a specification that makes it possible to describe an XQuery expression by using an XML structure.","Rules for the traversing process are as follows:\n\n","Rules for returned values are as follows:\n\n","First, the generating unit  normalizes the input XQuery (step S). During the normalizing process, the generating unit  performs, for example, a process to expand a predicate clause into a FLWOR structure and a process to arrange a return clause to be enclosed in the form of a let clause that includes a variable and tags.","After that, the generating unit  marks (detects) doc( ) functions appearing in the input XQuery (step S). Hereinafter, the loop in the process at steps S through S is repeated for each of the appearing doc( ) functions. In other words, a DXQuery is generated for each of the doc( ) functions. A basic algorithm is to find, while marking it, a range that is traceable from the doc( ) function via paths or constants.","The generating unit  sorts the processes by judging which clause in the FLWOR structure contains the marked part (the doc( ) function). In other words, the generating unit  judges whether the marked part is contained in a for clause (step S). If the marked part is contained in a for clause (step S: Yes), the generating unit  newly marks a part structured with the variables, the constants, the functions and the paths that are marked (step S). In other words, the generating unit  traces the paths while using the marked doc( ) function as a starting point and newly marks the traced part. The generating unit  then outputs the marked part as a for clause of the DXQuery (step S).","If the marked part is not contained in a for clause (step S: No), the generating unit  judges whether the marked part is contained in a let clause (step S). If the marked part is contained in a let clause (step S: Yes), the generating unit  newly marks a part structured with the variables, the constants, the functions, and the paths that are marked (step S). In other words, the generating unit  traces the paths while using the marked doc( ) function as a starting point and newly marks the traced part. The generating unit  then outputs the marked part as a let clause of the DXQuery (step S).","If the marked part is not contained in a let clause (step S: No), the generating unit  judges whether the marked part is contained in an order-by clause (step S). If the marked part is contained in an order-by clause (step S: Yes), the process proceeds to step S.","If the marked part is not contained in an order-by clause (step S: No), the generating unit  judges whether the marked part is contained in a where clause (step S). If the marked part is contained in a where clause (step S: Yes), the generating unit  newly marks a part structured with the variables, the constants, the functions and the paths that are marked (step S). The generating unit  then outputs the marked part as a where clause of the DXQuery (step S).","If the marked part is not contained in a where clause (step S: No), the generating unit  judges whether the marked part is contained in a return clause (step S). If the marked part is contained in a return clause (step S: Yes), the generating unit  outputs a return clause of the DXQuery while using a format \u201creturn<rec>{X}<\/rec>\u201d (step S). A clause using the formats shown in (1) and (2) below is output in \u201cX\u201d above.",{"@attributes":{"id":"p-0115","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(1):"]},{"entry":[{},"<col0>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{$variable}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/col0>"]},{"entry":[{},"(2):"]},{"entry":[{},"for $dummy variable in $variable"]},{"entry":[{},"return"]},{"entry":[{},"<col1>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{dummy variable}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/col1>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"If it is determined at step S that the marked part is not contained in a return clause (step S: No), the process proceeds to step S. At step S, the generating unit  judges whether there is a clause that is traceable from the marked part, i.e., whether there is another clause that contains the variables, the constants, the functions, the path, and the like that are contained in the marked part (step S). If there is such a clause (step S: Yes), the processes at step S and thereafter are repeated on the clause. If there is no such clause (step S: No), the process proceeds to step S.","At step S, the generating unit  judges whether all the doc( ) functions appearing in the input XQuery have been processed (step S). If the judgment result is in the negative (step S: No), the doc( ) function appearing next is marked, and the process is repeated (step S). If all the doc( )functions have been processed (step S: Yes), the DXQuery generating process ends.","Next, the details of the GXQuery generating process at step S will be explained.  is a flowchart of an example of the GXQuery generating process. During the GXQuery generating process, the process is performed by using the XQuery marked in the DXQuery generating process. The GXQuery generating process is to, mainly with respect to a marked part, calculate a for clause or a let clause for extracting corresponding data from a previously-generated DXQuery and to replace the marked part with the calculated clause.","First, the generating unit  obtains a part marked in the input XQuery (hereinafter, the \u201cmarked part\u201d) (step S). The generating unit  judges whether the marked part contains a for clause (step S). If the marked part contains a for clause (step S: Yes), the generating unit  replaces the marked part with a for clause for extracting the corresponding data from the DXQuery and outputs the for clause (step S). The generating unit  outputs, for example, a for clause in a format as shown in (1) below.",{"@attributes":{"id":"p-0120","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(1):"]},{"entry":[{},"for $dummy variable in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"doc([uri])\/root\/rec"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for $variable in"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$dummy variable\/col\/*"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"If the marked part contains no for clause (step S: No), the generating unit  judges whether the marked part contains a let clause (step S). If the marked part contains a let clause (step S: Yes), the generating unit  replaces the marked part with a let clause for extracting the corresponding data from the DXQuery and outputs the let clause (step S). The generating unit  outputs, for example, a let clause in a format as shown in (2) below.",{"@attributes":{"id":"p-0122","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(2):"]},{"entry":[{},"let $variable :="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for $dummy variable 1 in"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"doc([uri])\/root\/rec"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for $dummy variable 2 in"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$dummy variable 1\/col\/*"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return $dummy variable 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"If the marked part contains no let clause (step S: No), the generating unit  judges whether the marked part contains an order-by clause (step S). If the marked part contains an order-by clause (step S: Yes), the generating unit  outputs the order-by clause as it is (step S).","If the marked part contains no order-by clause (step S: No), the generating unit  judges whether the marked part contains a where clause (step S). If the marked part contains a where clause (step S: Yes), the generating unit  replaces the marked part with a let clause for extracting the corresponding data from the DXQuery and outputs the let clause (step S). The generating unit  outputs, for example, a let clause in a format as shown in (3) below.",{"@attributes":{"id":"p-0125","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(3):"]},{"entry":[{},"let $dummy variable := in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$variable\/col\/*"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"If the marked part contains no where clause (step S: No), the generating unit  judges whether the marked part contains a return clause (step S). If the marked part contains a return clause (step S: Yes), the generating unit  outputs the return clause as it is (step S).","After any of the processes at steps S, S, S, S, and S is performed or if it is determined at step S that the marked part contains no return clause (step S: No), the generating unit  judges whether all the marked parts have been processed (step S). If the judgment result is in the negative (step S: No), one of the unprocessed marked parts is obtained so that the process is repeated thereon (step S). If all the marked parts have been processed (step S: Yes), the GXQuery generating process ends.","Next, the XQuery processing performed by any of the DB servers  in response to a DXQuery execution request from the virtual planner  will be explained. It should be noted that the XQuery processing performed by the XQuery processor  when the client  requests XQuery processing (query) instead of distributed XQuery processing (gquery) is also performed in the same manner.  is a flowchart of an example of the XQuery processing.","The DB server  reserves a resource uri_d for the requested DXQuery (step S). The DB server  returns the uri_d to the central server  as a GET response (step S). The DB server  executes the DXQuery on the XQuery processor (step S). The DB server  assigns the result XML, which is an execution result of the DXQuery, to the resource uri_d (step S). When the XQuery processor  executes the XQuery processing, a request processing thread is generated so as to wait until the result XML is assigned to the resource uri_d.","Next, an obtaining process to obtain the data corresponding to a resource by a get method will be explained.  is a flowchart of an example of the obtaining process.","The request receiving unit  obtains the data corresponding to the resource uri specified by the get method (step S). If it is not possible to obtain the data, a request processing thread is generated so as to wait until the data is assigned, and the process enters a waiting state to wait for the event of the assigning. When the data is assigned to the resource uri, the request receiving unit  returns the data to the request origin of the get method, as a GET response (step S).","Next, a merging process to merge pieces of resource data by a merge method will be explained.  is a flowchart of an example of the merging process.","The request receiving unit  reserves a resource uri_m for storing therein a result of the merging process (step S). The request receiving unit  returns the uri_m, which is the URI of the reserved resource, to the request origin, as a GET response (step S). The request receiving unit  performs a merging process on the resources included in the set of resources on which a merging process was requested by the merge method (step S).","The notation \u201cU uri_d\u201d in  denotes the set of resources uri_d on which a merging process was requested. In this situation, the \u201cmerging process\u201d means to join the pieces of resource data in series.","The request receiving unit  assigns the result XML, which is the XML data obtained as a result of the merging process, to the uri_m (step S). When an assignment of a result XML to the uri_m is waited for in another thread or the like, a request processing thread is generated so as to wait until the result XML is assigned.",{"@attributes":{"id":"p-0136","num":"0157"},"figref":["FIG. 13","FIG. 13"],"b":["10","100","20","20"],"i":["a, ","b"]},"First, by a gquery method, the client  requests the central server  to perform distributed XQuery processing (step S).","By a query method, the central server  requests the DB server to perform XQuery processing (step S). The query method used in this situation has the DXQuery generated by the generating unit  as an argument. The central server  obtains uri_d indicating the URI of the resource for the result XML resulting from the query method, from the DB server (step S).","By a query method, the central server  requests the DB server to perform XQuery processing (step S). The query method used in this situation has the DXQuery generated by the generating unit  as an argument. The central server  obtains uri_d indicating the URI of the resource for the result XML resulting from the query method, from the DB server (step S).","By a merge method, the central server  requests the server itself (i.e., the central server ) to perform a merging process on the resource uri_d and the resource uri d (step S). The central server  obtains the uri_m indicating the URI of the resource for the result XML resulting from the merge method, from the server itself (i.e., the central server ) (step S).","By a get method, the central server  requests the DB server to obtain the result XML corresponding to the uri_d (step S). By a get method, the central server  requests the DB server to obtain the result XML corresponding to the uri_d (step S).","The central server  returns the uri_g to the client , as a GET response to the gquery method (step S).","By a get method, the client  requests the central server  to obtain the result XML corresponding to the uri_g (step S).","By a get method, the central server  requests the server itself (i.e., the central server ) to obtain the result XML corresponding to the uri_m obtained at step S (step S).","When the result XML that represents the execution result of the query method requested by the central server  from the DB server is generated, the DB server assigns xml_d, which is the result XML, to the resource uri_d (step S).","Similarly, when the result XML that represents the execution result of the query method requested by the central server  from the DB server is generated, the DB server assigns xml_d, which is the result XML, to the resource uri_d (step S).","When the result XML that is a result of the merging process performed on the uri_d and the uri_d as requested from the server itself (i.e., the central server ) by the merge method is generated, the central server  assigns xml_m, which is the result XML, to the resource uri_m (step S).","When the result XML corresponding to the uri_g that was requested by the client  from the central server  by the get method is generated, the central server  assigns the result XML to the uri_g (step S).","As shown in , in response to the query method requested, each of the DB servers  returns the response notifying the resource for storing therein the execution result, before the execution result is available (e.g., steps S and S). In other words, each of the DB servers  needs to have a technical feature of returning, in response to the query method, the response notifying the resource for storing therein the execution result of the XQuery processing before the execution result is available, instead of returning a response notifying the execution result after the execution result becomes available. If each of the DB servers  did not have this technical feature, it would be acceptable to configure the central server  so as to include an alternative technical feature.","On the right-hand side of , a relationship among the XQueries, the resources, and the XML data processed in the sequence described above are shown. More specifically, each of the DB servers and executes the DXQuery, so that the execution results are stored into the resource uri_d and the resource uri_d, respectively. Further, the resource uri_g for storing therein the execution result of the GXQuery in which the resource uri_m merging the resource uri_d and the resource uri_d is embedded is transmitted to the client . When the result XML that is the execution result of the GXQuery is obtained, the result XML is transmitted to the client .","Next, a specific example of a searching process will be explained.  shows an example of an XQuery being input from a client. The XQuery in  indicates that \u201call the rows containing \u201cKanagawa\u201d in column  should be extracted\u201d.",{"@attributes":{"id":"p-0152","num":"0173"},"figref":["FIG. 15","FIG. 2","FIG. 15","FIG. 15"],"b":["21","21","1","2","3"],"i":["a ","a "]},{"@attributes":{"id":"p-0153","num":"0174"},"figref":["FIG. 16","FIG. 14","FIG. 14","FIG. 16"],"b":"3"},{"@attributes":{"id":"p-0154","num":"0175"},"figref":["FIG. 17","FIG. 16","FIG. 17","FIG. 15"],"b":["1","21"],"i":"a "},{"@attributes":{"id":"p-0155","num":"0176"},"figref":["FIG. 18","FIG. 14","FIG. 18"],"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["(1) A part for extracting each rec by reading the result XML of the DXQuery; and","(2) A part for extracting the value of col? of the rec"]}},"As shown in , the following is satisfied: \u201cthe GXQuery\u201d+\u201cthe DXQuery\u201d=\u201cthe XQuery being input\u201d.","Next, the process of generating the DXQuery in  and the GXQuery in  from the XQuery in  will be further explained.","First, a doc( ) function \u201cdoc(\u201cdatabase.XML\u201d)\u201dis extracted from the XQuery in  (step S in ).","As for a for clause, because the main body of the clause is marked by tracing \u201c\/\/row\u201d from the doc( ) function, the part up to \u201c$x\u201d is marked.","As for a where clause, \u201c$x\u201d is already marked. \u201c$x\/\/column3\u201d is also marked. \u201cKanagawa\u201d is a constant. Accordingly, the entirety of the where clause is marked. As a result, a DXQuery as shown in  is generated.","After that, the GXQuery is generated. Because the for clause and the where clause are marked for the DXQuery, a for clause for extracting the corresponding data from the DXQuery is as shown in .",{"@attributes":{"id":"p-0162","num":"0185"},"figref":["FIG. 19","FIG. 18","FIG. 19"]},"Next, another example of an XQuery that is more complicated than the one shown in  will be further explained.  shows another example of an XQuery being input from a client. The XQuery in  indicates that \u201crows should be counted with respect to column  of the rows\u201d. For example, with reference to the data shown in , the XQuery indicates that \u201cthe business offices should be counted for each of the prefectures\u201d.","Next, a number of built-in functions will be explained.\n\n",{"@attributes":{"id":"p-0165","num":"0190"},"figref":["FIG. 21","FIG. 20"]},"With the following rules for traversing, two DXQueries (DXQuery  and DXQuery ) will be generated:\n\n",{"@attributes":{"id":"p-0167","num":"0194"},"figref":["FIG. 22","FIG. 23","FIG. 22","FIG. 24","FIG. 25","FIG. 24","FIG. 26","FIG. 20"],"b":["1","1","2","2"]},"As shown in , , and , the following is satisfied: \u201cthe GXQuery\u201d+\u201cthe DXQuery (the DXQuery , the DXQuery )\u201d=\u201cthe XQuery being input\u201d.  shows an example of the result XML that is an execution result of the GXQuery in . As shown in , a result of \u201ccounting the business offices for each of the prefectures\u201d is obtained as the result XML.","As explained above, the searching apparatus according to the first embodiment is able to realize the distributed XQuery processing without using XRPC. Consequently, the following advantageous effects are achieved:\n\n","A searching apparatus according to a second embodiment converts (generalizes) a DXQuery so as to satisfy the searching capability (query processing capability) of the DB server and generates a search result of the pre-conversion DXQuery from a search result of the converted DXQuery. With this arrangement, it is possible to realize a search with a high level of precision, according to the query processing capabilities of the DB servers.",{"@attributes":{"id":"p-0171","num":"0201"},"figref":"FIG. 28","b":["200","200","110","220","102","103","104","230"]},"The second embodiment is different from the first embodiment because of technical features of the virtual planner  and because the generalizing processor  is additionally provided. The other configurations and technical features are the same as those shown in , which is a block diagram of the central server  according to the first embodiment. The same configurations and technical features will be referred to by using the same reference characters, and the explanation thereof will be omitted.","The virtual planner  is different from the virtual planner  according to the first embodiment in that the virtual planner  requests the generalizing processor  to generalize a generated DXQuery and causes a transmitting unit  to transmit the generalized DXQuery (hereinafter, \u201cDXQuery\u2032\u201d) to the DB servers .","The generalizing processor  includes a converting unit  and a generating unit  (a second generating unit). The converting unit  converts a DXQuery generated by the generating unit  included in the virtual planner  into a DXQuery\u2032 generalized according to the query processing capability of the DB server . The generating unit  generates a VXQuery (a generation request), which is an XQuery for verifying a search result of the DXQuery\u2032. The VXQuery is an XQuery for generating such a search result that would be obtained if the pre-conversion DXQuery is used, by verifying an insufficient part of the query processing capability of the DB server  exhibited in the search result of the DXQuery\u2032 and supplementing the insufficient part.",{"@attributes":{"id":"p-0175","num":"0205"},"figref":"FIG. 29","b":["220","230"]},"The processes at steps S through S are the same as the processes at steps S through S performed by the central server  according to the first embodiment. Thus, the explanation thereof will be omitted.","At step S, a generalizing process to generate the DXQuery\u2032 and the VXQuery from the DXQuery is performed. The details of the generalizing process will be explained later.","After that, the transmitting unit  included in the virtual planner  transmits an execution request to execute the generalized DXQuery\u2032 to a selected one of the DB servers  (step S). The DB server  to which the execution request was transmitted transmits the URI (the uri_d) of the resource for storing therein an execution result (the result XML) of the DXQuery\u2032, to the central server . Thus, the virtual planner  obtains the uri_d, which is the URI of the resource for storing therein the result XML.","Subsequently, the virtual planner  rewrites the doc( ) function of the VXQuery with the obtained uri_d (step S). The virtual planner  requests the server of its own (i.e., the central server ) to execute the VXQuery by specifying a query method (step S) and obtains uri_v for storing therein the result XML of the VXQuery.","The process at step S is the same as the process at step S in , and the explanation thereof will be omitted. The process at step S is different from the process at step S in  in that the resource uri_v is used instead of the resource uri_d. In other words, the virtual planner  requests the server of its own (i.e., the central server ) to execute a merge method to merge the pieces of data respectively stored in the plurality of resources uri_v (step S).","The processes at steps S through S are the same as the processes at steps S through S performed by the central server  according to the first embodiment. Thus, the explanation thereof will be omitted.","Next, the generating process at step S will be explained.  is a flowchart of an example of the generalizing process.","First, the generalizing processor  obtains a distributed server definition from each of the DB servers  (step S). The distributed server definition is information expressing the query processing capability of the DB server.  shows an example of the distributed server definition. \u201cSERVICE http:\/\/example.com\/?key=%1\u201d indicates that the server is capable of processing a parameter for a \u201ckey\u201d. \u201cXQuery for $x in . . . \u201d indicates that it is possible to replace the parameter for the \u201ckey\u201d with \u201ccontains ($x, \u201c% 1\u201d)\u201d.","Returning to the description of , the generalizing processor  checks to see if the selected DXQuery matches an XQuery pattern of the distributed server definition (step S). If the selected DXQuery does not match the XQuery pattern (step S: No), the converting unit  generalizes the DXQuery (step S), so that the process returns to step S and the process is repeated.","To generalize the DXQuery, the converting unit  performs a process of, for example, (1) omitting a path, (2) expanding an OR condition, or (3) converting a tag name into \u201c*\u201d (converting the name of an element contained in the XML data).","If the DXQuery matches the XQuery pattern of the distributed server definition (step S: Yes), the converting unit  outputs the generalized DXQuery (or the selected DXQuery, if not generalized) as a DXQuery\u2032 (step S). Subsequently, the generating unit  generates a VXQuery from the original DXQuery (step S), and the generalizing process ends.",{"@attributes":{"id":"p-0187","num":"0217"},"figref":["FIG. 32","FIG. 14","FIG. 31","FIG. 16","FIG. 32"],"b":"20"},{"@attributes":{"id":"p-0188","num":"0218"},"figref":["FIG. 33","FIG. 14","FIG. 31"]},{"@attributes":{"id":"p-0189","num":"0219"},"figref":["FIG. 34","FIG. 34"],"b":["20","20","20","1","2","2","2","1","2","10","10"],"i":["b. ","a ","b, "]},"Next, the process of generating the DXQuery in  from the XQuery in  and the distributed server definition in  will be further explained.","The distributed server definition in  describes a declaration regarding the query processing capability of the DB server  where \u201cin order for the DB server to obtain data, the DB server is able to conduct a search (\u201ccontains\u201d) only by using a keyword (\u201ckey\u201d)\u201d.","The generalizing processor  compares the XQuery in  with the distributed server definition in  and list up syntax differences (step S in ). For example, the generalizing processor  loads a syntax tree of the XQuery into a memory by combining tools for a lexical analysis and a syntax analysis such as Yacc&Lex, so as to compare the syntax trees in the two memories.","As a result, the generalizing processor  is able to detect that there is a difference between \u201cdoc( )\/\/row\u201d and \u201cdoc( )\/*\u201d and there is a difference between \u201c$x\/\/column3\u201d and \u201c$x\u201d. These two differences are related to the XQuery paths. Accordingly, the converting unit  applies a generalizing operation of \u201comitting a path\u201d thereto. It is possible to realize the generalizing operation by using, for example, a rule-based system technique. In other words, the generalizing operation is expressed by using a rule constituted with two parts including an IF clause and a THEN clause such as \u201cIF there is a difference in a path, THEN the path is omitted\u201d. By repeatedly applying a set of such rules until a stop condition is satisfied while using an inference engine, it is possible to realize the generalizing operation. The stop condition in this situation is that there is no longer any difference between the DXQuery and the distributed server definition.","For example, with regard to the XQuery in , the stop condition is satisfied when the following two generating operations are performed: (1) omit the path from \u201cdoc( )\/\/row\u201d to \u201cdoc( )\/*\u201d; and (2) omit the path from \u201c$x\/\/column3\u201d to \u201c$x\u201d.","After that, when a return clause is output in the format \u201creturn <rec> { . . . } <\/rec>\u201d, the DXQuery in  is generated.","Next, the process of generating the VXQuery in  from the XQuery in  and the distributed server definition in  will be further explained.","As the VXQuery, a special XQuery for checking the difference parts generalized by the generalized operations described above (i.e., the difference between \u201cdoc( )\/\/row\u201d and \u201cdoc( )\/*\u201d and the difference between \u201c$x\/\/column3\u201d and \u201c$x\u201d) is generated.","For example, the generating unit  generates the VXQuery by embedding clauses \u201cfor $x in doc( )\/\/row\u201d and \u201cwhere contains ($x\/\/column3, \u201cKanagawa\u201d)\u201d, which contain the difference parts, into a base XQuery as shown in (A) below. In this situation, the generating unit  rewrites, as necessary, the variable in the embedded difference parts with the variable in the base XQuery. It is possible to set the base XQuery in advance.",{"@attributes":{"id":"p-0199","num":"0229"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(A):"]},{"entry":[{},"for $_0 in doc([uri_d1])\/rec"]},{"entry":[{},"for $_1 in $_0\/col0\/*"]},{"entry":[{},"return"]},{"entry":[{},"<rec>"]},{"entry":[{},"{<col0>{$x}<\/col0>}"]},{"entry":[{},"<\/rec>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The VXQuery resulting from the embedding process is shown in (B) below.",{"@attributes":{"id":"p-0201","num":"0231"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(B):"]},{"entry":[{},"for $_0 in doc([uri_d1])\/rec"]},{"entry":[{},"for $_1 in $_0\/col0\/*"]},{"entry":[{},"for $x in doc $_1\/\/row"]},{"entry":[{},"where contains ($x\/\/column3, \u201cKanagawa\u201d)"]},{"entry":[{},"return"]},{"entry":[{},"<rec>"]},{"entry":[{},"{<col0>{$x}<\/col0>}"]},{"entry":[{},"<\/rec>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the VXQuery shown above, lines 3 and 4 are embedded. Also, \u201c$x\u201d in line  is replaced by \u201c$1\u201d.","As explained above, according to the first and the second embodiments, it is possible to realize the distributed XQuery processing having XQuery transparency, without using XRPC.","Next, a hardware configuration of the searching apparatus (the central server) according to the first or the second embodiment will be explained, with reference to .  is a drawing explaining a hardware configuration of the searching apparatus according to the first or the second embodiment.","The searching apparatus according to the first or the second embodiment has a hardware configuration utilizing a commonly-used computer and includes: a control device such as a Central Processing Unit (CPU) ; storage devices such as a Read-Only Memory (ROM)  and a Random Access Memory (RAM) ; a communication interface (I\/F)  that establishes a connection to a network and performs communication; external storage devices such as a Hard Disk Drive (HDD) and\/or a Compact Disk (CD) drive device; a display device such as a display monitor; input devices such as a keyboard and\/or a mouse; and a bus  that connects these constituent elements together.","A searching computer program (hereinafter, \u201csearching program\u201d) executed by the searching apparatus according to the first or the second embodiment is provided as a computer program product as being recorded on a computer-readable recording medium such as a Compact Disk Read-Only Memory (CD-ROM), a Flexible Disk (FD), a Compact Disk Recordable (CD-R), a Digital Versatile Disk (DVD), or the like, in a file that is in an installable format or in an executable format.","Another arrangement is acceptable in which the searching program executed by the searching apparatus according to the first or the second embodiment is stored in a computer connected to a network like the Internet, so that the searching program is provided as being downloaded via the network. Yet another arrangement is acceptable in which the searching program executed by the searching apparatus according to the first or the second embodiment is provided or distributed via a network like the Internet.","Further, yet another arrangement is acceptable in which the searching program according to the first or the second embodiment is provided as being incorporated in a ROM or the like in advance.","The searching program executed by the searching apparatus according to the first or the second embodiment has a module configuration that includes the functional units described above (e.g., the request receiving unit, the virtual planner, the XQuery processor, the resource allocating unit, and the server notification detecting unit). As the actual hardware configuration, these functional units are loaded into a main storage device when the CPU  (the processor) reads and executes the searching program from the storage device described above, so that these functional units are generated in the main storage device.","While certain embodiments have been described, these embodiments have been presented by way of example only, and are not intended to limit the scope of the inventions. Indeed, the novel embodiments described herein may be embodied in a variety of other forms; furthermore, various omissions, substitutions and changes in the form of the embodiments described herein may be made without departing from the spirit of the inventions. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of the inventions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 15","FIG. 2"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 16","FIG. 14"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 18","FIG. 14"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 19","FIG. 18"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 21","FIG. 20"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 22","b":"1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 23","FIG. 22"],"b":"1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 24","b":"2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 25","FIG. 24"],"b":"2"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 26","FIG. 20"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 27","FIG. 26"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 32","FIG. 14","FIG. 31"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 33","FIG. 14","FIG. 31"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 35"}]},"DETDESC":[{},{}]}
