---
title: Automated testing framework for event-driven systems
abstract: Techniques for programmatically coordinating, and synchronizing execution of, automated testing in event-driven systems. One or more user-provided test system event listeners listen for generated events and update test system status accordingly. A user-provided test suite definition invokes a test framework interface, thereby defining the structure of a test suite. This test suite is executed, referring to the test system status to determine when to move to a next stage (e.g., to a next test case or next test module). Test system status may also be updated directly from a test case or test module (e.g., when the test designer determines that the tested code will not generate events that can be leveraged for test status information).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07779302&OS=07779302&RS=07779302
owner: International Business Machines Corporation
number: 07779302
owner_city: Armonk
owner_country: US
publication_date: 20040810
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to computer programming, and deals more particularly with programmatically coordinating, and synchronizing execution of, automated testing in event-driven systems.","2. Description of the Related Art","Software testing for a complex application may require executing a large number of test cases to exercise sufficient coverage of paths through the software. In years past, human test personnel were largely responsible for carrying out the testing process, and in particular, for selecting which test cases should be executed, in which order, and under what conditions. A software test engineer would therefore invoke a test case, determine whether it completed successfully, and based on that determination, decide whether another test case should be invoked\u2014or perhaps whether the test case should be re-executed after some type of software modification.","This level of human involvement in the testing process is very time-consuming and therefore costly. Accordingly, advancements have been made in automating the testing process. However, areas remain where automated testing has room for improvement. In particular, automated testing for systems that are event-based can be difficult. An event-driven system typically communicates with external and\/or internal components through the use of events and listeners. Typically, listener software undergoes a registration process, whereby the listener informs the system of the event(s) in which it is interested; then, when a particular event is fired at run time, notification of the event occurrence is automatically sent to each registered listener. Listeners generally comprise application-specific code for reacting to the particular event(s) for which they register. Thus, upon notification of an event, the listener will perform certain action(s) pertaining to the event.","While automated test systems are known in the art, these systems are not sufficient for use with event-driven, listener-based systems.  illustrates problems that commonly arise, and will now be described.","The sample test case  in , referred to as \u201cTestcase_\u201d, performs a series of steps which call several methods (\u201cMethod\u201d through \u201cMethod\u201d, in the example) sequentially. When this sample test case is started, Method in the event-driven system is invoked. See encircled numeral . Method (depicted symbolically at reference number ) fires an event as it executes, where this event is referred to in  as \u201cEvent_A\u201d. See reference number , where the invocation of Event_A is depicted as processing performed by the code of Method, and reference number , representing the triggered event. In this example, Method executes within a first system named \u201cSYSTEM \u201d , and a listener  for Event_A is located in a second system named \u201cSYSTEM \u201d . Responsive to receiving notification of the firing of Event_A, listener  begins to execute its corresponding code .","Code  executes, performing processing for Event_A, and will complete in an unknown period of time. However, since Method is a non-blocking method in this example, it will finish and return control back to Testcase_ immediately after Event_A is fired. See encircled numeral , where this is illustrated. Since Testcase_ therefore believes that Method is finished, Testcase_ will then proceed to invoke Method. Method thus begins to execute while SYSTEM  is still processing Event_A. If Method is also non-blocking, then Testcase_ will invoke Method immediately upon completion of Method; similarly, Method may be invoked immediately following completion of Method.","At some generally unpredictable time, the code  for processing Event_A reaches the end. As shown at , this sample listener code  triggers \u201cEvent_B\u201d upon completion. Reference number  represents the triggered Event_B, and in this example, a listener  for Event_B is located in System_ . Responsive to receiving notification of the firing of Event_B, listener  begins to execute its corresponding code (which, for example, might comprise printing a result related to the processing of Event_A). When listener  completes its execution, the result of executing Method_ is now available for Testcase_, as shown generally by encircled numeral . However, it may happen that one, two, or even all three of the subsequent methods (i.e., Method through Method) in the sample test case have already completed prior to completion of the event processing triggered by execution of Method. Thus, the results from Method may be returned to an incorrect state (or at least an unpredictable state) of Testcase_.","Furthermore, additional problems may result due to the unpredictable completion time of event processing that is triggered by Method. For example, the processing of Method, Method, and\/or Method may be affected by whether Method has completely finished. The unpredictable duration of the event processing may therefore cause one or more of these methods to be invoked during the wrong system state, such that the entire outcome of Testcase_ becomes invalid.","One may think that an obvious solution is to insert intentional delay between the method calls to address this problem. See , where a revised version of the sample test case, now referred to as \u201cNew_Testcase_\u201d , is presented. In this revised version, a \u201cwait\u201d instruction  has been inserted between execution of Method and Method, and is depicted in the example as waiting for \u201cx minutes\u201d. At first glance, this may seem like an acceptable solution. However, recall that the processing time of the events (Event_A and Event_B, in this example) is unknown. One would need to experiment with different time delays through trial and error for each method call. In addition, different computer systems might have different performance characteristics, such that the intended result is achieved on some systems but not on others. Furthermore, as time goes on, more functionality might be added to the systems under test, and each method might therefore take longer to run. As a result, one might have to repeatedly adjust the time delay in all existing test cases. In short, the intentional delay approach is error-prone and labor intensive, and is not a viable solution.","Accordingly, what is needed are techniques that avoid problems of the type described above, and which yield predictable results during automated testing of event-driven systems.","The present invention provides techniques for automated testing in event-driven systems. One or more user-provided test system event listeners listen for generated events and update test system status accordingly. A user-provided test suite definition implements a test framework interface, thereby defining the structure of a test suite. This test suite is executed, referring to the test system status to determine when to move to a next stage (e.g., to a next test case or next test module). Test system status may also be updated directly from a test case or test module (e.g., when the test designer determines that the tested code will not generate events that can be leveraged for test status information).","In one aspect, the present invention preferably comprises: registering a test system listener to listen for events generated during execution of the event-driven system being tested; receiving, by the registered test system listener, notification of the events generated during the execution of the event-driven system; updating a current testing status indication responsive to information specifying ones of the received event notifications that signal work starting or work ending; and using the current testing status indication to determine whether the testing can progress.","In another aspect, the present invention preferably comprises: obtaining a definition of a test suite, comprising one or more test cases, each of the test cases comprising one or more steps for executing code, wherein the code fires at least one event; registering a test system listener to listen for the fired events; executing the test steps of the test cases of the test suite, thereby executing the code; updating, during the executing, a test status indicating whether any of the test steps is executing, responsive to receiving a notification at the registered test system listener that one of the events has been fired by the code; and if the test status indicates that any of the test steps is executing, preventing a next one of the test steps from executing, and otherwise, allowing the next one of the test steps to execute.","The present invention will now be described with reference to the following drawings, in which like reference numbers denote the same element throughout.","The present invention provides techniques for automated testing in event-driven systems. In an event-driven system, events are a primary means of communication among processes. Each type of event has a deterministic and logical response that the system will produce. For example, whenever Event_A from the sample test case in  happens, it is known that the system needs to process that event for an unknown period of time. And, whenever Event_B from the sample test case happens, it is known that the system has completed the processing of Event_A. This information can be used to determine when the system is still busy with the processing of code pertaining to Method, and when it is not, according to preferred embodiments.","Preferred embodiments leverage this information, using events that communicate the start and end of activity. Thus, automated test execution according to the present invention uses listeners in event-driven systems to listen to events, and responsive to those events, maintains test status information that enables coordinating and synchronizing the automated testing. (Note that, according to preferred embodiments, the test system only listens to the events, and existing listeners are used to perform the actual event-specific processing. For example, listener  in  continues to execute its code  responsive to the firing of Event_A, and an additional test system listener for Event_A responds by updating test status information, as will be discussed in more detail below.)","The listeners in the test system of preferred embodiments provide a means to observe the state in the event-driven system under test. A data structured referred to herein as a \u201ctime table\u201d is maintained, according to preferred embodiments, by a testing framework controller. The test system listeners update this time table, responsive to occurrence of events, with information that the test system needs to accurately coordinate the testing sequence. (Note that the term \u201ctime table\u201d should be interpreted generally as a status-recording mechanism. This time table may be implemented in various ways, and is not limited to implementation as an actual table data structure. The time table of preferred embodiments comprises a Boolean indication of status, and may also provide further status-related information.)","Typically, automated test cases need to be run in a pre-defined order. A test suite may contain many test cases, and a test case may contain a number of steps. Furthermore, a test step may contain a number of method calls. Ideally, all of these items should only be run after the previous method, step, or case is completed.","One might consider using the time table information to coordinate a test sequence by having a thread that checks the status of the time table continually. If the current status fulfills the conditions to run a certain step, then that step will execute. For instance, the condition to execute the second step in a particular test case may be that the first step in that test case has successfully completed. Pseudocode  for a thread using this approach is illustrated in . As shown therein, conditional logic specifies conditions under which each of \u201cN\u201d test cases may be executed. The conditions may be written to include current status information obtained from the time table. In this sample , for example, a test designer may specify a list of one or more criteria in the condition part of an \u201cIF\u201d statement (see reference number ) that determines whether a particular test case is to be executed, where that test case is identified in the \u201cTHEN\u201d part of the \u201cIF\u201d statement (see reference number ).","While the approach illustrated in  may be adequate in some scenarios, it would mean that all the steps for all test cases, and all the test cases for the test suite, would have to be placed in this one thread\u2014which (except for very simple test scenarios) would typically make the test software unmanageable.","The present invention provides a testing framework that is easy to use yet achieves the goal of coordinated, synchronized test execution in an event-driven system. The testing framework manages coordination among threads performing test execution and also manages the conditions for executing particular test steps. A user of this testing framework provides the listeners and the actual contents of the test suite and test cases. As discussed briefly above, these user-provided listeners listen to the events that occur during testing and supply status information for the time table, such that the time table is updated when certain events occur. Thus, the testing framework of preferred embodiments provides an application programming interface (\u201cAPI\u201d) with which the time table can be updated.","Taking the sample system in  as an example, the user knows that Event_A will kick off a process that runs in an unknown amount of time and that Event_B will be fired when this processing is completed. Therefore, according to preferred embodiments, upon receipt of Event_A, the user-provided listener (not shown in ) notifies the time table that the system is now \u201cbusy\u201d doing processing. Accordingly, if the time table is queried (e.g., to determine whether another test step can be executed), the current \u201cbusy\u201d status will be detected. When the user-provided listener receives Event_B, it notifies the time table that the system has finished its current processing (and the system status is thus changed to \u201cidle\u201d or another \u201cnot busy\u201d indicator).","A single test system listener may be used, where this user-provided listener is written to receive and respond to all events of interest to the test suite. Alternatively, more than one user-provided listener may be used, where each listener handles some subset of the events of interest. In addition to these one or more test system listeners, users of the present invention also supply the contents of the test cases for the test suite. A test suite may be comprised of one or more test cases. Preferably, test cases are structured as collections of one or more test modules, where a test module comprises one or more test steps (such as method invocations) and is designed as a logical unit of work that can serve as a building block for test cases. Test cases can then reuse these test modules to create different kinds of test scenarios. (Alternatively, some or all test cases may be comprised of test steps that do not form part of a separately-defined test module.)","The testing framework of preferred embodiments provides interfaces for three different levels of test functionality: TestSuite, TestCase, and TestModule. (Support for reusable test modules is optional, and the TestModule interface may therefore be omitted in alternative embodiments without deviating from the scope of the present invention.)  depicts a logical view of interfaces and components of the automated testing framework of preferred embodiments, as will now be described.","A testing framework controller  supports a TestSuiteFramework interface , a TestCaseFramework interface , a TestModuleFramework interface , and a time-table-updating interface . Preferred embodiments of the TestSuiteFramework interface , for example, support adding a test case to the test suite content (see reference numbers  and ). Whereas the test framework interfaces are shown in a column appearing in the middle of  (see, generally, reference number ), user implementations are depicted in a column  appearing at the right-hand side of . Thus, a user implementation of a test suite implements the TestSuiteFramework interface and supplies the contents of the test suite by adding test cases to the suite. See reference number , where a sample illustrates invoking the \u201caddTestCase( )\u201d method for a first test case named \u201cTestcase\u201d and for a second test case named \u201cTestcase\u201d. The test cases are preferably created in an analogous manner. Reference numbers  and  illustrate samples of defining test cases by invoking the \u201caddTestModule( )\u201d method and passing names of particular test modules as input. Similarly, test modules are created and can be added to various test cases. Reference numbers , , and  illustrate specification of three sample test modules. (Note that the test module named \u201cTestModule\u201d is reused in this example, as it is specified for both TestCase  and TestCase .) Thus, for the sample test suite defined by the user-provided information at reference numbers , , , , , and , the test execution sequence is as follows: TestModule (from TestCase), TestModule (from TestCase), TestModule (from TestCase) and TestModule (from TestCase).","Reference number  illustrates the user-provided listener, which is written to invoke the time-table-updating API  upon occurrence of events from which test system status can be determined. (Note that preferred embodiments are described herein in terms of notifying the time table only of busy\/idle-type status changes. In alternative embodiments, additional information may be communicated using this API, such as an indication of which event has started or completed.)","By implementing the interfaces , , and , the test suite will be seamlessly integrated with the testing framework controller . As each entity of the test suite is defined, preferred embodiments record information about the structure of the suite for run-time use by the testing framework controller. For example, using the samples depicted in , the testing framework controller can determine that the test suite named \u201cTestSuite\u201d is comprised of two test cases (see reference number ), and each of these test cases is comprised of two test modules (see reference numbers , ). As the test suite executes, the user-provided listener (see reference number ) will provide updates to the time table that the testing framework controller will use to manage this user-provided test execution sequence.","It may happen that code executed by some test modules (or test cases, in the absence of test modules) does not trigger any events in the event-driven system. In this case, the user preferably annotates the test module (or test case) to directly update the time table. This is illustrated at reference numbers  and , where the time table is updated (reference number ) to record that work has been started, prior to execution of the method named \u201cMethod\u201d, and is then updated again (reference number ) to record that the work has been completed, following execution of the method named \u201cMethod\u201d. Recall that the user or users designing the test suite is\/are aware of the content of the methods being tested, and will therefore know whether the methods themselves fire events. Thus, in this example, it is not necessary to annotate TestModule  because the user knows that this particular invoked method, \u201cMethod\u201d (which was depicted in ), contains its own event-triggering code. The user therefore includes, within user-provided listener , code that updates the time table appropriately upon the firing of events by Method. (See the discussion of , below, for more information on this user-provided listener .)",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 4"],"b":["400","430","510"]},"Preferably, when the test system is started, the state machine thread  starts and runs continuously to monitor the time table . Using information registered by invocations of the framework interfaces , the test system initiates execution of the test suite (TestSuite, in this example) which was implemented by the users. Preferably, a separate thread is used for the test suite, as shown at . The registered test suite information identifies TestCase, in this example, as the first test case to be executed. Thus, preferred embodiments initiate execution of that first test case in yet another thread . (Using separate threads for the test suite, test case, and state machine is believed by the present inventors to simplify the state machine.)","The thread used for TestCase is a thread that runs until all the test modules in that test case are completed. It preferably keeps track of which module it has run and which one it should run next. In the example, as TestModule is executed, Method is called and, according to the code  of , Event_A is fired. The event listener  receives notification of Event_A and, in response (as shown generally at ), updates the time table  to indicate that work (i.e., testing) has started. The state machine thread  of preferred embodiments checks the time table on a regular basis (e.g., at configured or default intervals) and therefore knows that the event-driven system is currently doing work. Some time later, the event-driven system finishes the processing of Method and its Event_A, and Event_B is therefore fired. The event listener  receives notification of Event_B and, in response (as shown generally at ), updates the time table  to indicate that work has ended. On its next check of the time table, the state machine thread  sees that the system has completed its task at hand, and will move the test to the next stage. In preferred embodiments, this comprises using the information registered in response to the test framework interface invocations (such as \u201caddTestCase( )\u201d and \u201caddTestModule( )\u201d, which were discussed with reference to ) to determine the next test module, if any, and the next test case, if any. (The state machine thread  also preferably records information indicating which test case and test module are currently being executed, as shown generally at .) Upon determining that another module remains to be executed in this test case, the state machine thread  preferably invokes a method such as \u201cMoveToNextTestModule( )\u201d, as depicted at  in . The thread used for TestCase preferably checks with the state machine on a regular basis, and will therefore know that the state machine has moved the test to the next stage in this manner (e.g., by setting a flag indicating that the next module can now be executed); thread  will then initiate execution of the next test module. (Alternatively, the state machine thread  may signal the thread used for the test suite or the thread used for the test case, responsive to determining that the time table shows the current processing as having ended. As an example of this alternative approach, the thread for TestCase initiates execution of the next module, TestModule, upon receiving a signal from the state machine after the state machine learns of the completion of TestModule.)","When all the test modules in the currently-executing test case are completed, the thread used for that test case execution will preferably be terminated. At this point, the next check of the time table  by state machine  will indicate that the current processing has ended. If the suite has not yet completed (as may be determined using the previously-registered test suite information), the state machine thread  preferably invokes a method such as \u201cMoveToNextTestCase( )\u201d, as depicted at . The thread  used for the test suite will then detect (either by checking with the state machine, or alternatively by receiving a signal therefrom) that the test case has ended, and will then start a thread for its next test case (e.g., the TestCase thread , in this example). The test modules inside that test case will be run under control of the state machine in a similar manner to that which has been described for the first test case.","The direct invocations of the time-table-updating API which were previously discussed with reference to  and  of  execute during execution of their containing test module, enabling the time table to reflect the user-defined starting of work and ending of work in the absence of events fired by the code under test.","The testing framework disclosed herein can be adapted to automate testing on any event-driven systems. It is transparent, in that it does not require any modifications in the event-driven system itself because the testing framework and software of the test system are external to the event-driven systems. It is extensible, in that the test suite designer controls the definition of a particular test suite; the test suite is then iteratively executed by the testing framework, based on this definition.","As will be appreciated by one of skill in the art, embodiments of the present invention may be provided as (for example) methods, systems, and\/or computer program products. The present invention may take the form of an entirely hardware embodiment, an entirely software embodiment, or an embodiment combining software and hardware aspects. Furthermore, the present invention may take the form of a computer program product which is embodied on one or more computer-usable storage media (including, but not limited to, disk storage, CD-ROM, optical storage, and so forth) having computer-usable program code embodied therein.","The present invention has been described with reference to flow diagrams and\/or block diagrams according to embodiments of the invention. It will be understood that each flow and\/or block of the flow diagrams and\/or block diagrams, and combinations of flows and\/or blocks in the flow diagrams and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, embedded processor, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute the more processor of the computer or other programmable data processing apparatus, create means for implementing the functions specified in the flow diagram flow or flows and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer-readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable memory produce an article of manufacture including instruction means which implement the function specified in the flow diagram flow or flows and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions specified in the flow diagram flow or flows and\/or block diagram block or blocks.","While preferred embodiments of the present invention have been described, additional variations and modifications in those embodiments may occur to those skilled in the art once they learn of the basic inventive concepts. Therefore, it is intended that the appended claims shall be construed to include preferred embodiments and all such variations and modifications as fall within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
