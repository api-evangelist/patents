---
title: Shared buffer techniques for heterogeneous hybrid graphics
abstract: The graphics processing technique includes detecting a transition from rendering graphics on a first graphics processing unit to a second graphics processing, by a hybrid driver. The hybrid driver, in response to detecting the transition, configures the first graphics processing unit to create a frame buffer. Thereafter, an image rendered on the second graphics processing unit may be copied to the frame buffer of the first graphics processing unit. The rendered image in the frame buffer may then be scanned out on the display.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09111325&OS=09111325&RS=09111325
owner: NVIDIA CORPORATION
number: 09111325
owner_city: Santa Clara
owner_country: US
publication_date: 20091231
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["Conventional computing systems may include a discrete graphics processing unit (dGPU) or an integral graphics processing unit (iGPU). The discrete GPU and integral GPU are heterogeneous because of their different designs. The integrated GPU generally has relatively poor processing performance compared to the discrete GPU. However, the integrated GPU generally consumes less power compared to the discrete GPU.","The conventional operating system does not readily support co-processing using such heterogeneous GPUs. Referring to , a graphics processing technique according to the conventional art is shown. When an application  starts, it calls the user mode level runtime application programming interface (e.g., DirectX API d3d9.dll)  to determine what display adapters are available. In response, the runtime API  enumerates the adapters that are attached to the desktop (e.g., the primary display ). A display adapter , , even recognized and initialized by the operating system, will not be enumerated in the adapter list by the runtime API  if it is not attached to the desktop. The runtime API  loads the device driver interface (DDI) (e.g., user mode driver (umd.dll))  for the GPU  attached to the primary display . The runtime API  of the operating system will not load the DDI of the discrete GPU  because the discrete GPU  is not attached to the display adapter. The DDI  configures command buffers of the graphics processor  attached to the primary display . The DDI  will then call back to the runtime API  when the command buffers have been configured.","Thereafter, the application  makes graphics request to the user mode level runtime API (e.g., DirectX API d3d9.dll)  of the operating system. The runtime  sends graphics requests to the DDI  which configures command buffers. The DDI calls to the operating system kernel mode driver (e.g., DirectX driver dxgkrnl.sys) , through the runtime API , to schedule the graphics request. The operating system kernel mode driver then calls to the device specific kernel mode driver (e.g., kmd.sys)  to set the command register of the GPU  attached to the primary display  to execute the graphics requests from the command buffers. The device specific kernel mode driver  controls the GPU  (e.g., integral GPU) attached to the primary display .","There is, however, a need to enable applications to render graphics on the discrete graphics processor and present the rendered graphics on a display attached to the integral graphics processor.","Embodiments of the present technology are directed toward shared buffer techniques for heterogeneous graphics. The present technology may best be understood by referring to the following description and accompanying drawings that are used to illustrate embodiment of the present technology.","In one embodiment, a graphics processing technique includes loading a device kernel mode driver agent, such as a wrapper driver, that includes a kernel mode device driver for a first graphics processing unit attached to a primary display and a kernel mode device driver for a second graphics processing unit. A call may be received by the device kernel mode driver agent from a service or user interface to transition from rendering graphics on the first graphics processing unit to the second graphics processing unit. In response to the transition call, the device kernel mode driver agent generates a call to configure the first graphics processing unit to create a surface in a frame buffer. In response to the call to create the surface, the device kernel mode driver agent receives a virtual address of the surface in the frame buffer of the first graphics processing unit. The device kernel mode driver agent determines and stores a physical address of the surface from the virtual address for use in transporting rendered data from the second graphics processing unit to the frame buffer of the first graphics processing unit attached to the primary display.","In another embodiment, a device kernel mode wrapper driver impersonates the operating system and sends a sequence of command to cause the GPU attached to the primary display to create a displayable surface and make it accessible to direct memory access (DMA) blits from a second GPU. The sequence of commands includes creating a shared primary surface, setting a mode with this created surface to show it on the primary display and mapping it through the bus coupling the second GPU to the GPU attached to the primary display. The surface that the wrapper driver causes the GPU attached to the primary display to create is DMA accessible to an external DMA engine, such as the copy engine of the second GPU. Upon successful setup of the shared surface, the second GPU can then display the frames that it computes on the primary display.","Reference will now be made in detail to the embodiments of the present technology, examples of which are illustrated in the accompanying drawings. While the present technology will be described in conjunction with these embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of the present technology, numerous specific details are set forth in order to provide a thorough understanding of the present technology. However, it is understood that the present technology may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present technology.","Referring to , a graphics co-processing computing platform, in accordance with one embodiment of the present technology is shown. The exemplary computing platform may include one or more central processing units (CPUs) , a plurality of graphics processing units (GPUs) , , volatile and\/or non-volatile memory (e.g., computer readable media) , , one or more chip sets , , and one or more peripheral devices , - communicatively coupled by one or more busses. The GPUs include heterogeneous designs. In one implementation, a first GPU may be an integral graphics processing unit (iGPU) and a second GPU may be a discrete graphics processing unit (dGPU). The chipset ,  acts as a simple input\/output hub for communicating data and instructions between the CPU , the GPUs , , the computing device-readable media , , and peripheral devices , -. In one implementation, the chipset includes a northbridge  and southbridge . The northbridge  provides for communication between the CPU , system memory  and the southbridge . In one implementation, the northbridge  includes an integral GPU. The southbridge  provides for input\/output functions. The peripheral devices , - may include a display device , a network adapter (e.g., Ethernet card) , CD drive, DVD drive, a keyboard, a pointing device, a speaker, a printer, and\/or the like. In one implementation, the discrete graphics processing unit is coupled as a discrete GPU peripheral device  by a bus such as a Peripheral Component Interconnect Express (PCIe) bus.","The computing device-readable media ,  may be characterized as primary memory and secondary memory. Generally, the secondary memory, such as a magnetic and\/or optical storage, provides for non-volatile storage of computer-readable instructions and data for use by the computing device. For instance, the disk drive  may store the operating system (OS), applications and data. The primary memory, such as the system memory  and\/or graphics memory, provides for volatile storage of computer-readable instructions and data for use by the computing device. For instance, the system memory  may temporarily store a portion of the operating system, a portion of one or more applications and associated data that are currently used by the CPU , GPU  and the like.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIGS. 3A and 3B","FIG. 3A"],"b":["110","120","120","180","120","130","170","180","130","170","180","130","120"]},"In addition, during initialization of the system, one or more driver layers are loaded, including a thunk layer (e.g., GDI32.dll) , an operating system level kernel mode driver (e.g., dxgkrnal.sys) , a device kernel mode driver agent, and\/or the like. In one implementation, the device kernel mode driver agent may be a kernel mode wrapper driver  that includes the binary images of the device specific kernel mode driver for the integral graphics processing unit  and the device specific kernel mode driver for the discrete graphics processing unit . The kernel mode wrapper driver  may also be referred to as a hybrid driver. Generally, the entry points into the kernel mode wrapper driver  are the same as the entry points for the device specific entry points.","Initially, the attached adapter includes the integral graphics processing unit  and its device specific kernel mode driver  because the integral graphics processing unit  is attached to the primary display . Thereafter, the device kernel mode driver agent  may detect a transition from rendering graphics on the integral graphics processing unit  to the discrete graphics processing unit . In one implementation, the discrete graphics processing unit  and its device specific kernel mode driver  are configured as the attached adapter and the integral graphics processing unit  and its device specific kernel mode driver  are detached, as illustrated in . In one implementation, the transition is initiated by a service or user interface calling a given entry point of a local function in the wrapper driver .","In response to the transition, the device kernel mode driver agent  configures the integral graphics processing unit  to create a frame buffer  and to scan out from the frame buffer to the attached display . In one implementation, the kernel mode wrapper driver  receives a call to create a surface in a frame buffer  for the discrete graphics processing unit. The call to create the surface in the frame buffer  for the discrete graphics processing unit is redirected as a call to create the surface in a frame buffer for the integral graphics processing unit . In response to the redirected call to create the surface, the kernel mode wrapper driver  receives from the device specific kernel mode driver  a virtual address of the surface in the frame buffer  of the integral graphics processing unit . The kernel mode wrapper driver  determines a physical address from the virtual address of the surface. The kernel mode wrapper driver stores the physical address for use in transporting rendered data from the discrete graphics processing unit to the frame buffer  of the integral graphics processing unit  attached to the primary display . For example, the kernel mode wrapper driver, impersonating the operating system, may make a sequence of calls including: GetStandardAllocationDriverData to get the allocation bits to pass to the following calls, CreateAllocation to create an allocation, OpenAllocation to open it (specifying an offset into the heap, 0), AcquireSwizzlingRange to request a CPU mapping to the allocation, CommitVidPn to assign the allocation to scanout, SetVidPnSourceAddress to point the digital-to-analog converter (DAC) to the allocated surface, and SetVidPnSourceVisibility to turn on the primary display. The sequence of calls works because the operating system is not handling the integral graphics processing unit  attached to the primary display  at the time.","Thereafter, when the application  makes graphics request to the user mode level runtime API (e.g., DirectX API d3d9.dll)  of the operating system, the runtime  sends graphics requests to the DDI  which configures command buffers. The DDI calls to the operating system kernel mode driver (e.g., DirectX driver dxgkrnl.sys) , through the runtime API , to schedule the graphics request. The operating system kernel mode driver  then calls to the device kernel mode driver agent . The device kernel mode driver agent  determines a context of one or more calls after the transition call. The wrapper driver redirects the calls to the device specific kernel mode driver  of the integral graphics processing unit  attached to the primary display  and\/or the device specific kernel mode driver  of the discrete graphics processing unit  based upon the context of the given call.","When a call to display a surface rendered by the discrete graphics processing unit  is received, the device kernel mode driver agent  inserts a call to the kernel mode driver  of the discrete graphics processing unit  to copy the rendered image to the physical address of the frame buffer  of the integral graphics processing unit . In one implementation, the rendered image is copied from a scanout of the discrete graphics processing unit  to the surface in the frame buffer  of the integral graphics processing unit . For example, a physical PCIe address can be deduced from the virtual address obtained from the AcquireSwizzlingRange call, and used for the discrete graphics processing unit  to emit direct memory access (DMA) blits into the specified range. The device kernel mode driver agent  also inserts a call to the kernel mode driver  of the integral graphics processing unit  to present the rendered image from the frame buffer on the display . The rendered image may be presented from the frame buffer by a digital-to-analog converter of integral graphics processing unit .","In one implementation, the scanout buffer of the discrete graphics processing unit  and\/or the frame buffer for the integral graphics processing unit  may be double buffered. In one implementation, the rendered image is copied through a Peripheral Component Interconnect Express (PCIe) bus coupling the discrete graphics processing unit  to the integral graphics processing unit .","Accordingly, embodiments of the present technology advantageously enable applications to render graphics on the discrete graphics processor  and present the rendered graphics on a display  attached to the integral graphics processor . The integrated graphics processing unit is configured by a device kernel mode driver agent as a dumb buffer. The embodiments advantageously remove the need for multiplexers to transport the rendered images from the scanout of the discrete graphics processing unit to the display device attached to the integrated graphics processing unit.","The foregoing descriptions of specific embodiments of the present technology have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the present technology and its practical application, to thereby enable others skilled in the art to best utilize the present technology and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present technology are illustrated by way of example and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A and 3B"}]},"DETDESC":[{},{}]}
