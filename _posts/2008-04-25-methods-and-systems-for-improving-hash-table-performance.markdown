---
title: Methods and systems for improving hash table performance
abstract: Methods and systems for generating a hashcode for a hash table are provided to improve the hash table performance. A particular method includes receiving an input of a key; applying a hash function to the key to generate an incoming hashcode of the key; encoding a key type into the incoming hashcode to generate a first hashcode; and storing the first hashcode. A particular method includes encoding the key type into at least one bit of a bucket index portion of the incoming hashcode.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08429143&OS=08429143&RS=08429143
owner: International Business Machines Corporation
number: 08429143
owner_city: Armonk
owner_country: US
publication_date: 20080425
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Embodiments of the present disclosure generally relate to the field of storage of data using hash tables, and in particular to improving the performance of hash tables.","A hash table or a hash map is a data structure that associates a given \u201ckey\u201d with a given \u201cvalue\u201d. Hash tables are used for storing and accessing data in computer systems. Efficient storage and fast location of data are important features of a computer system and therefore improving hash table performance is an important consideration. Hash tables are used in many different applications within a computer system.","The primary operation of a hash table is a lookup: given a key (for example, a name), find the corresponding value (for example, a birth date). The hash table works by transforming the key using a hash function into a \u201chashcode\u201d which is a number that is used as an index in an array to locate the desired location (a \u201cbucket\u201d) where the values should be.","To facilitate fast storage and retrieval, hash tables compute hashcodes of the keys. The hashcode is an identifier that is required to be identical for all keys that are considered equal within the data structure; however, some keys that are not equal may also have the same hashcode.","When storing or retrieving keys, known hash table implementations first look for those keys whose hashcodes are equal (a fast check) then test the keys themselves to determine if they are actually equal. The effect of only testing keys whose hashcodes are equal reduces the number of more time-costly key equality checks that must be performed.","Key equality checks are costly because they involve de-referencing object memory references for the keys being compared, which can cause central processing unit cache misses and thereby increased execution time to recover.","Known existing implementations of hash tables are not optimized for particular key types, so they suffer the drawback of having to support all possible key types.","It is an aim of the present disclosure to distinguish between different types of keys and use this knowledge to improve the data structure's overall performance.","According to a first aspect of an embodiment of the present disclosure there is provided a method that includes receiving an input of a key. The method also includes applying a hash function to the key to generate an incoming hashcode of the key. The method also includes encoding a key type into the incoming hashcode to generate a first hashcode. The method also includes storing the first hashcode at a hash table.","In another embodiment, a method includes receiving an input of a first key. The method also includes applying a hash function to the first key to generate an incoming hashcode of the first key. The method also includes encoding a key type into at least one bit of a bucket index portion of the incoming hashcode to generate a search hashcode. The method also includes determining if the search hashcode matches a stored hashcode of a second key.","According to another aspect of the present disclosure there is provided a computer program product stored on a computer readable storage medium comprising computer readable program instructions executable by a processor to: receive an input of a key; apply a hash function to the key to generate an incoming hashcode of the key; and encode a key type into the incoming hashcode to generate a first hashcode.","It will be appreciated that for simplicity and clarity of illustration, elements shown in the figures have not necessarily been drawn to scale. For example, the dimensions of some of the elements may be exaggerated relative to other elements for clarity. Further, where considered appropriate, reference numbers may be repeated among the figures to indicate corresponding or analogous features.","In the following detailed description, numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. However, it will be understood by those skilled in the art that the present disclosure may be practiced without these specific details. In other instances, well-known methods, procedures, and components have not been described in detail so as not to obscure the present disclosure.","Hash tables are used as data storage structures extensively in computer systems. A computer system employing such data structures is shown in . Referring to , a data processing system  suitable for storing and\/or executing program code is shown including at least one processor  coupled directly or indirectly to memory elements through a bus system .","The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.","The memory elements may include system memory  in the form of read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS)  may be stored in ROM . System software  may be stored in RAM  including operating system software . Software applications  may also be stored in RAM .","The system  may also include a primary storage means  such as a magnetic hard disk drive and secondary storage means  such as a magnetic disc drive and an optical disc drive. The drives and their associated computer-readable media provide non-volatile storage of computer-executable instructions, data structures, program modules and other data for the system . Software applications may be stored on the primary and secondary storage means ,  as well as the system memory .","The computing system  may operate in a networked environment using logical connections to one or more remote computers via a network adapter .","Input\/output devices  can be coupled to the system either directly or through intervening I\/O controllers. A user may enter commands and information into the system  through input devices such as a keyboard, pointing device, or other input devices (for example, microphone, joy stick, game pad, satellite dish, scanner, or the like). Output devices may include speakers, printers, etc. A display device  is also connected to system bus  via an interface, such as video adapter .","Referring to , a schematic diagram is shown of the operation  of a hash table or hash map. The hash table includes keys  which are transformed by a hash function into hashcodes . The hashcodes  are used as an index for the location of values  for the keys . For example, the keys  may be names as shown in  such as John Smith , Sam Brown  and Sarah Jones , and the values  may be the dates of birth of each key, Sam Brown 03\/10\/1956 , John Smith 14\/11\/1943 , and Sarah Jones 03\/10\/1956 .","Each key  is transformed into a hashcode . A hashcode  indexes a key's value . In the example shown, the key of John Smith  has a hashcode of 569 which indexes the value  of the date of birth of John Smith. Here, the full entry (key and value) is shown with the key in the form of the name present alongside the value in the form of the date of birth.","A hash function is deterministic in that two identical or equivalent inputs must generate the same hash value. If two keys hash to the same index, the corresponding records cannot be stored in the same location. So, if it is already occupied, another location must be found in which to store the new record. There are a number of collision resolution techniques, but one of the most popular is separate chaining using linked lists.","The present disclosure provides an improved implementation of a hash table. In this description, the methods and systems are described in terms of a Java (Java is a trade mark of Sun Microsystems, Inc.) hash table implementation and the detailed description and explanation is expressed using Java syntax and terminology. However, the described methods and systems are applicable to the equivalent implementation in any programming language.","A common representation of a hash table or hash map is as an array of linked lists. For example, the two classes in the Java class library can be considered as such a representation: java.util.HashMap and java.util.Hashtable.","The class of Hashtable implements a hash table, which maps keys to values. Any non-null object can be used as a key or as a value. To successfully store and retrieve objects from a hash table, the objects used as keys implement a hashcode method (which is the hash function) and an equals method.","An instance of Hashtable has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The hash table uses separate chaining: in the case of a \u201chash collision\u201d, a single bucket stores a linked list, which may contain multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the capacity is increased by calling a rehash method.","The class of HashMap is a hash table based implementation of a map interlace. This implementation provides all of the optional map operations, and permits null values and the null key. The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.","Referring to , a schematic representation is shown of the components of a data structure  with a hash table  implemented as an array  of linked lists. Each element of the array  represents a bucket - that contains a reference - to the head of a linked list of map entries .","Each entry  in the hash table  is a structure as shown in the inset  of . An entry  contains at least three fields: the key , the value , and the \u201cnext\u201d reference  for constructing a linked list of entries. As the key comparison can be a complex and computationally intensive operation, the hash table implementation usually adds one extra field inside the entry structure called \u201chash\u201d . The hash  is computed at the entry creation based on some properties of the key element in the entry structure. The purpose of the hash  is to create a representation of the key , such that it can be used for quick test to determine if two keys  are not equal. If the hash  matches for two keys  then a full equality test is preformed.","Each map entry  comprises a reference  to the key object , a reference  to the value object , the stored hashcode  of the key, and a reference  to the next map entry in the linked list.","In a described embodiment, the hash table  may be in the form of the class library java.util.HashMap. The number of buckets - is constrained to be a power of 2 to make later computations fast. The minimum length is constrained to be 2 buckets. The hashcode of an object is a 32-bit signed integer value, determined by invoking the hashCode( ) method. The key may be null, in which case the key reference is null and the stored hashcode is zero.","In another embodiment, a hash table may be provided in the form of the class library java.util.Hashtable.","Adding a Map Entry","One desirable property of a hash function is that conversion from the hash value (typically 32 bits) to a bucket index for a particular-size hash table can be done simply by masking, preserving only the lower k bits for a table of size 2.","When adding a new map entry to a hash table containing numBucket buckets, the incoming key's hashcode is first computed. The bucket index is determined by considering the numBucket least significant bits from the key's hashcode.\n\n","This is illustrated with reference to . An incoming hashcode  is shown in binary form \u201c01001101\u201d. If there are 8 buckets in the array, a bucket mask  is provided for indexing the 8 buckets in binary form \u201c00000111\u201d. The bucket mask  has the three least significant bits set to \u201c1\u201d, as the three least significant bits \u201c111\u201d is equal to 7 (numBucket minus 1).","When the bucket mask  is applied to the incoming hashcode  as a bit masking operation, the bucket index  is obtained. In this example, the bit masking operation leaves \u201c00000101\u201d which indicates index \u201c101\u201d (bucket number ) in the array.","The new entry is stored at the head of the bucket, and any existing entry at that position is linked to the next reference of the new entry. The key's hashcode is stored in the entry.","Searching for a Map Entry","When searching for a map entry by key, the incoming key hashcode is computed, the bucket number is determined (as above), then the linked list is searched for the matching key. As an optimization, the equality of the incoming hashcode can be tested with the stored hashcode as a fast integer-to-integer comparison before testing the equality of the incoming key with the stored key, which is an expensive object de-reference, equals( ) message send with the incoming key.",{"@attributes":{"id":"p-0050","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"while (entry != null &&"]},{"entry":[{},"\u2003\u2003\u2003(entry.storedKeyHash != incomingHash ||"]},{"entry":[{},"\u2003\u2003\u2003!incomingKey.equals(entry.key))) {"]},{"entry":[{},"\u2003entry = entry.next;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Finding Spare Bits in the Stored Hashcode","The set of possible values for an incoming key's hashcode occupies the full range of a 32 bit signed integer. However, within a given bucket the set of possible hashcode values that may be found in the linked list is smaller. This is because for a hash table with numBucket buckets, where numBucket is 2, the algorithm for adding a new map entry guarantees that all entries within a given bucket have identical bit values in the lowest n bit positions.","This information can be used to \u2018steal\u2019 up to n bits from the stored hashcode value to represent optimization information, knowing that the actual hashcode can be reconstructed from the stored hashcode.","Furthermore, this technique does not lose any information contained in the original hashcode.","This is shown with reference to  in which numBucket is 2with an array  with eight buckets -. The last three bits  of the hashcodes  of entries  indicate the bucket - in which the entry  is stored.","In the example shown in , there are the following entries : an entry  \u201c00001000\u201d in bucket  (\u201c000\u201d) ; an entry  \u201c01110001\u201d in bucket  (\u201c001\u201d) ; and three entries - \u201c01001101\u201d, \u201c00010101\u201d, and \u201c01110101\u201d in bucket  (\u201c101\u201d) .","The entries exemplify that all entries within a given bucket have identical bit values in the lowest bit positions. For instance, the entries - for bucket  (\u201c101\u201d) all have the same last three bits (\u201c101\u201d), which is the same as the bucket index.","Knowing that bit values are the same as the bucket index, the bits indicating the bucket index can be re-purposed for storing other information in the knowledge that the original bit values can be reconstructed from the bucket index when necessary.","Optimizing for a Known Key Type","Using the spare bits in the stored hashcode, searching can be optimized for some known key types. The optimization avoids de-referencing the key object reference and invoking the equals method for each searched entry with an equal incoming and stored hashcode.","This is the original search shown earlier but with the expensive de-reference indicated:",{"@attributes":{"id":"p-0062","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"while (entry != null &&"]},{"entry":[{},"\u2003\u2003(entry.storedKeyHash != incomingHash ||"]},{"entry":[{},"\u2003\u2003!incomingKey.equals(entry.key))) { <<--- Avoid this test"]},{"entry":[{},"\u2003entry = entry.next;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Types that are suitable for optimization are those whose computed hashcode value and equality art defined, for example, by the Java Language Specification, and for which the equality criteria can be encoded in the hashcode. Examples include, Boolean, Byte, Character, Short, Integer, Float, etc.","Within a given bucket, the value of the n bits of a stored hashcode can be used to determine the type of the key, and the remaining bits of the stored hashcode are unique to the equality proposition of the key instance.","Optimizing for the Integer Key Type","As an example embodiment, the Integer key type is used. If the numBucket is constrained to be \u22672 then there is at least one spare bit to encode the integer key type in the stored hashcode.","The algorithms for adding a map entry, and searching for a map entry are modified as follows. When adding a new entry, the incoming key's hashcode is first computed. The bucket is determined by considering the n least significant bits from the key's hashcode as before.","If the incoming key is an Integer, the stored hashcode is computed as (key.hashcode( )|0\u00d71), i.e. the least significant bit is set. If the incoming key is not an Integer, the stored hashcode is computed as (key.hashcode( ) & 0\u00d7FFFFFFFE), i.e. the least significant bit is cleared.",{"@attributes":{"id":"p-0069","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int index = incomingKeyHash & (numBucket \u2212 1);"]},{"entry":[{},"if (incomingKey instanceof Integer) {"]},{"entry":[{},"\u2003entry.storedKeyHash = incomingKeyHash | 0x00000001;"]},{"entry":[{},"} else {"]},{"entry":[{},"\u2003entry.storedKeyHash = incomingKeyHash & 0xFFFFFFFE;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This is illustrated with reference to  in which numBucket is 2with an array  with eight buckets -. The last three bits  of the hashcodes  of entries  originally (as shown in ) indicated the bucket - in which the entry  is stored. However, now the least significant bit  of the hashcodes  is used to indicate the key type. In this example, the key type is whether the key is an Integer or not.","In the example shown in , there are the following entries : an entry  \u201c00001000\u201d in bucket  (\u201c000\u201d)  (this entry  has the last bit set to \u201c0\u201d to show it is a non-Integer key); an entry  \u201c01110001\u201d in bucket  (\u201c001\u201d)  (this entry has the last bit set to \u201c1\u201d to show it is an Integer key); and three entries - \u201c01001101\u201d, \u201c00010100\u201d, and \u201c01110101\u201d in bucket  (\u201c101\u201d) . Each of these entries has the last bit set to \u201c1\u201d or \u201c0\u201d to indicate respectively if it is an Integer key or non-Integer key.","A method of adding a key entry with key type information is shown in the flow diagram  of . A key's incoming hashcode is computed . If the number of buckets is determined  as 2, a bucket mask for the n least significant bits is applied  to determine  the bucket index in which the key is to be stored. The key type is then determined , and the key type mask is applied  to up to the n least significant bits of the incoming hashcode. The result is a stored hashcode which is stored  in the bucket. For example, if the key type is whether the key is an Integer or non-Integer, an Integer type mask is respectively applied to set or clear the least significant bit.","The search algorithm now becomes:",{"@attributes":{"id":"p-0074","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (incomingKey instanceof Integer) {"},{"entry":"\u2003int searchKeyHash = incomingKey.hashCode( ) | 0x00000001;"},{"entry":"\u2003while (entry != null && (entry.storedKeyHash != searchKeyHash)) {"},{"entry":"\u2003\u2003entry = entry.next;"},{"entry":"\u2003}"},{"entry":"} else {"},{"entry":"\u2003int searchKeyHash = incomingKey.hashCode( ) & 0xFFFFFFFE;"},{"entry":"\u2003while (entry != null &&"},{"entry":"\u2003\u2003\u2003\u2003(entry.storedKeyHash != searchKeyHash ||"},{"entry":"\u2003\u2003\u2003\u2003!incomingKey.equals(entry.key))) {"},{"entry":"\u2003\u2003entry = entry.next;"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The search is divided into two parts, depending on whether the incoming key is an Integer or not. If the key is not an Integer, then the original algorithm is used, which uses the costly equals method. If the key is an Integer, then only the hashcodes are compared.","A first important remark is now made: an integer to integer comparison (entry.storedKeyHash!=searchKeyHash) carries out two comparisons at once. It compares the key types in a bit to bit comparison of the least significant bit. This determines whether the two keys are both Integers. It also compares the most significant bits of the original hash functions of the two keys up to the least significant bit. If this part of the hashcode is equal, then the hash functions are equal, because it is already known that the least significant bit is equal; the hash functions generated the same bucket index.","A second important remark is now made: the hashcode function and the integer value of an Integer are identical; if two hashcodes of two Integers are equal, then the two Integers are equal. Thus the full test for equality is not required for Integers as it is for most other key types.","These two remarks imply that three tests for equality: equal hashcodes, equal types and equals method can be replaced by a single integer to integer comparison between the stored hashcode and the search hashcode. This removes the expensive equality check identified above for the case of an Integer key.","Referring to , a flow diagram  shows a method of searching for a map entry by key as described above. The key's incoming hashcode is computed , and the bucket number is determined . The linked list for the bucket is determined . The key type is determined . It is determined  if the key type is that of an Integer. If not, then the search hashcode is computed  for the incoming key based on its type (as above). Then the search proceeds  as per prior art as in Section \u201cSearching for a map entry\u201d.","If in  the key type is an Integer, then the search hashcode is computed  for the incoming key based on its type (as above). Then the linked list is searched  for the matching stored hashcode. It is determined  if an identical stored hashcode is found. If so, the method has found a key that is equal in type and value, and the value is returned  directly. If not, then the method did not find a matching key, the key object is not contained in the hash table and null is returned .","Rehashing the Hash Table","The stored hashcodes are not returned to the caller through regular application programming interface calls. However, it is necessary to do the inverse operation when rehashing the hash table, since the stored hashes are only unique within the bucket, and during rehashing the entries may change buckets.","When rehashing from 2buckets to 2buckets, the stored hashcode is first restored to the original incoming hashcode value by setting the lowest n bits back to the value of the bucket index it is leaving, then computing the new stored hashcode using the lowest m bits as described above.","For example, when using a single bit, each entry in the bucket oldIndex is rehashed to newIndex using",{"@attributes":{"id":"p-0085","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int actualHash = (oldIndex & 0x00000001) | (entry.storedKeyHash &"]},{"entry":[{},"0xFFFFFFFE);"]},{"entry":[{},"int newIndex = actualHash & (numBucket \u2212 1);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Alternative Embodiments and Concluding Remarks","The described methods enhance the implementation of a hash table to optimize the data locality for known uses of the data structure.","As will be understood by those skilled in the art, alternative embodiments may be provided using different key types.","In the case where the number of buckets is \u22674 there are at least two spare bits such that two least significant bits ate available for reuse in the stored hashcode, allowing four values to be encoded.","In this case, three distinct key types may be encoded in the stored hashcode, with the fourth encoding being used to identify all remaining key types. As an example alternative embodiment, Integer, Float and Short could be arranged to be the three such key types that are encoded and thus optimized. As before, the optimization depends on the relationship that objects of the encoded types are equal if their hashcodes are equal, so this relationship must be maintained for the implementations of Integer, Float and Short. For Integer and Float, this is implied in the Java Language Specification.","Some differing keys may generate the same incoming hashcode. When searching a hash table for entries matching a given incoming hashcode, matching entries are identified, then each entry is analyzed for full equality to the key. Full equality testing is resource-costly. The described method reduces the number of occasions full equality testing is required.","The example embodiments use the least significant bits to indicate the bucket index and to use these least significant bits to encode the key type. The bucket index may be determined by other selected bits in the incoming hashcode. For example, the most significant bits may be used for encoding the key type.","Embodiments of the present disclosure can take the form of an entirely hardware embodiment, an entirely software embodiment, or an embodiment containing both hardware and software elements. In a preferred embodiment, the present disclosure is implemented in software, which includes but is not limited to firmware, resident software, microcode, etc.","Embodiments of the present disclosure can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer usable or computer readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus or device.","The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory (CD-ROM), compact disk read\/write (CD-R\/W), and DVD.","Improvements and modifications can be made to the foregoing, without departing from the scope of the present disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
