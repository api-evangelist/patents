---
title: Robust efficient distributed RSA-key generation
abstract: The invention provides for robust efficient distributed generation of RSA keys. An efficient protocol is one which is independent of the primality test “circuit size”, while a robust protocol allows correct completion even in the presence of a minority of arbitrarily misbehaving malicious parties. The disclosed protocol is secure against any minority of malicious parties (which is optimal). The disclosed method is useful in establishing sensitive distributed cryptographic function sharing services (certification authorities, signature schemes with distributed trust, and key escrow authorities), as well as other applications besides RSA (namely: composite ElGamal, identification schemes, simultaneous bit exchange, etc.). The disclosed method can be combined with proactive function sharing techniques to establish the first efficient, optimal-resilience, robust and proactively-secure RSA-based distributed trust services where the key is never entrusted to a single entity (i.e., distributed trust totally “from scratch”). The disclosed method involves new efficient “robustness assurance techniques” which guarantee “correct computations” by mutually distrusting parties with malicious minority.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07313701&OS=07313701&RS=07313701
owner: CQR Cert, LLC
number: 07313701
owner_city: New York
owner_country: US
publication_date: 20010521
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/315,979, May 21, 1999, now U.S. Pat. No. 6,237,097.","The application relates to the field of electronics and data processing, and particularly to methods and apparatus for generating cryptographic keys.","The notion of distributed cryptographic protocols has been in cryptography for over fifteen (15) years. Some protocols have been designed to solve communication problems which are impossible from an information-theoretic perspective, like the coin-flipping protocol [B82] and the millionaire-problem protocol [Y82]. Other protocols have been designed to solve generic problems. These protocols (called \u201cgeneral compiler protocols\u201d) can securely compute any public function on secure inputs. The first such protocols were developed by Yao [Y86] and Goldreich, Micali and Wigderson [GMW], and various developments were made in subsequent works, e.g., [GHY, K, BGW, CCD].","Recently there has been a thrust to construct more efficient protocols for problems involving the distributed application of cryptographic functions (surveyed in GW97). Function sharing protocols are needed to provide increased memory security, distributed trust, and flexible management (i.e., adding and deleting trustees) of crucial functions like certification authorities and group signatures.","A major efficiency difference between a general compiler protocol (which should be thought of as a plausibility result\u2014see [Gr97]) and a function sharing protocol results from the fact that the communication complexity of the former depends linearly on the actual size of the circuit computing the cryptographic functions, while the communication complexity of the latter is independent of the circuit size (and is typically a polynomial in the input\/output size and the number of participants). This difference (pointed out first in FY93, DDFY94) is crucial to practitioners who require efficient protocols. A function sharing protocol involves a protocol for applying the function (based on distributed shares), and sometimes (in what is called a \u201cproactive model\u201d) also a protocol for re-randomizing the function shares.","Another important step regarding \u201cdistributed cryptographic functions\u201d is the (efficient) distributed generation of the function (the key shares). For cryptographic functions based on modular exponentiation over a field (whose inverse is the discrete logarithm which is assumed to be a one-way function), a protocol for the distributed generation of keys was known [P2]. However, for the RSA function and related cryptographic functions to be described below, which requires the generation of a product of two primes and an inverse of a public exponent, this step was an open problem for many years. Note that Yao's central motivation [Y86] is introducing general compiler protocols that \u201ccomputer circuits securely in communication\u201d was the issue of distributed generation of RSA keys. Indeed the results of [Y86, GMW] show the plausibility of this task.","Another step forward was achieved by Boneh and Franklin [BF97] who showed how a set of participants can generate an RSA function efficiently, thus detouring the inefficient compiler. They showed that their protocol was secure in the limited model of \u201ctrusted but curious\u201d parties. They left open the issue of robustness, i.e., generation in the presence of misbehaving (malicious) parties. If adversaries misbehave arbitrarily, the Boneh-Franklin protocol may be prevented from ever generating a shared RSA key (due to lack of robustness).","The following references provide additional background for the invention.\n\n","The preferred embodiment of the invention is a network of computers performing operations to generate a cryptographic key for use in an asymmetric (e.g., public\/private) cryptosystem. The invention permits generation of a secret key by a group of computers. The process generates the key in the form of distributed shares in such a way that a (large enough) subset of computers have sufficient information to recover the key, and a subset of computers can perform cryptographic functions using the shares (e.g., signing a certificate). However, at no time during key share generation or key share use is the secret key actually formed. In one particularly preferred version, the method is secure against a number of misbehaving participants.","The preferred embodiment of the invention generates key shares for use in a cryptosystem that requires a number that is the product of two large prime numbers. The method proceeds generally in the following steps.\n\n","The invention has particular utility in cryptographic applications requiring maximum security against both external and internal adversaries. Robustness assures proper operation in various system conditions like errors, failures, attacks with which a distributed system is supposed to cope.","Robustness has motivated basic notions in cryptography such as verifiable secret sharing [CGMA] and general zero-knowledge proofs [GMR]. The present invention provides for the robust, efficient and secure generation of shared RSA keys (or more generally, keys based on multiplying two large primes and exponentiation). It assumes a number n of participants that participate in generating shares of a cryptographic key. The participants may be programmed computers connected by a communication network. The method will successfully generate shares of a key for n\u22672t+1, i.e., where at most t parties misbehave in any malicious and arbitrary way. The method achieves optimal resilience, since a majority of good participants is required. If n\u22673t+1, a slightly more efficient variant of the protocol may be used.","Referring to , the method begins in step . In the next step , the method selects a group of initial participants to participate in generating shares of the cryptographic value. In the next step , the method initiates the initial participants to perform a process of first, second, and third protocols, the protocols being stored in a computer or a computer readable medium, where (i) the first protocol is constructed to compute a number N, (ii) the second protocol is constructed to test the value N for double primality without revealing the factors of N to the participants, (iii) the third protocol is constructed to compute shares of the cryptographic value without revealing the cryptographic value to the participants; and (iv) the process includes procedures to detect whether a participant has deviated from a protocol. In the next step , the method commences the process of performing the protocols. In the next step , the method checks for at least one of the first, second, and third protocols, whether a participant has deviated from the first, second, and third protocols, respectively. The method then ends in step .","Techniques of the present invention solve numerous other problems, because they can be employed to distributively initiate other cryptographic schemes based on composite numbers, such as: composite ElGamal encryption\/signature, identification schemes where no participant is allowed to know the factorization of N (as in Feige, Fiat, Shamir [FFS]), and an efficient version of Yao's simultaneous bit exchange protocol [Y86].","The preferred embodiment of the invention is built upon the following novel techniques.","1. Multiplication protocols for shared \u201csum-of-poly\u201d representations of values drawn from (1) a prime field (with robustness and security based solely on the hardness of the discrete logarithm problem), or (2) a subset of the integers (with robustness and security based solely on the hardness of the RSA problem, but without requiring a shared RSA modulus). The technique has potential in other applications since it is information-theoretically secure but also produces publicly verifiable witnesses which are held by the \u201ccommunity of servers.\u201d","2. Techniques for \u201cchained-consistency\u201d of shared information and its associated checking information, i.e., forcing checking information to be consistent over various computational tasks (e.g., generation protocols, multiplication protocols, and double primality tests) even when the representation of that checking information changes.","This Involves:",{"@attributes":{"id":"p-0020","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":{"@attributes":{"id":"ul0004-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":["A. the idea of \u201ccross-checking\u201d information, i.e , maintaining consistency by verifying share information through check information, and moreover, verifying new checking information (perhaps a different representation) through share information. This duality of \u201cchecking and computing\u201d is promising and is perhaps of independent interest;","B. efficient zero-knowledge arguments which verify that checking information is consistent;","C. a bootstrap technique assuring global checking by using a multitude of checking information w.r.t. individual keys."]}}}},"Indeed, the techniques are general enough to cope with variations of many exponentiation-based cryptosystems and distributed protocols for applying these functions.","3. A commitment mechanism, called Simulator-Equivocal Commitments, which are as secure and efficient as normal commitments, but allow for certain simultability arguments on committed data which could not be accomplished with standard commitments. The mechanism leads to a new proof technique of security for result-producing protocols.","The protocol described below assures that distributed systems employing the RSA function (and the other functions mentioned above) can be initiated distributively as well. The techniques developed here can be used to construct a robust threshold DSS as in [GJKR], but with optimal resilience and with no additional cryptographic assumptions. The protocol is implementable in hardware or software or both.","The protocol is relatively efficient (it does not depend on the size of the circuit of primality tests as in the general compilers). In addition, the number of rounds can be made about the same as the number of rounds in a non-robust protocol, and the computation complexity (measured in the number of modular exponentiations) can be brought to about 100 times the computational complexity of a non-robust protocol, given reasonable values for the number of shareholders and security requirements, and a few modifications for efficiency as also discussed below.","The protocol is feasible and can be used in system initiation and key replacement in numerous systems (as mentioned above) and in various settings which require distributed trust. For example, shared public key replacement in a certification authority may be performed every three or five years, and thus need not be a \u201creal time\u201d operation. Therefore, a somewhat long (say, two-three week) protocol is reasonable. On the other hand a general compiler protocol which will take more than the five year period itself is unreasonable.","The invention is preferably implemented in a network of computers. It has many advantages, particularly in terms of security against certain classes of adversaries as discussed below.","THE NETWORK: Preferred system uses a network of computers (shareholders) having properties satisfying the so-called \u201ca model\u201d similar to various recent works and also (BF97). The system has a group of n (probabilistic) servers, all connected to a common broadcast medium C, called the communication channel. Messages sent on C are assumed to instantly reach every party connected to it. The system is synchronized (and w.l.o.g. servers can be assumed to act synchronously). Implementations which satisfy the environment of the \u201cmodel\u201d can be based on known implementations of broadcast and multicast protocols, message sending protocols, encrypted and authenticated message sending protocols, and agreement protocols. These implementations are apparent based on the known and practiced art of computer communications (e.g., , Andrew Tanenbaum, Prentice-Hall, Inc., 1996).","THE ADVERSARY: The adversary is computationally bounded (i.e., it can not break the underlying cryptographic primitives) and it can corrupt servers at any moment by viewing the memories of corrupted servers and\/or modifying their behavior. The adversary decides on whom to corrupt at the start of the protocol. It will be assume that the adversary corrupts no more than t out of n servers throughout the protocol, where n\u22672t+1 (or n\u22673t+1 for the more efficient protocol variant). For the purpose of classifying adversaries, malicious faults need not be differentiated from \u201cnormal\u201d server failures (e.g., crashes). An adversaries can be connected to the broadcast channel C, which means it can hear all the messages and inject its own. It cannot, however, modify messages sent to C by a server that the adversary does not control, nor can it prevent a non-corrupted server from receiving a message sent on C.","In fact, the preferred protocol will be useful against a more mobile adversary [OY91], where the protocol proceeds in \u201ctrials\u201d and each trial is independent of past trials. During a trial, misbehaving servers (including malicious adversaries) can be detected. A proper key can be generated, or the remaining servers (which were not caught deviating from the protocol) restart a new trial. Provided that the eliminated misbehaving servers till now are t\u2032, the protocol permits generation of a proper key if the adversary occupies t\u22121\u2212t\u2032 new servers at the start of the new trial.","NOTATION: The description below will use the following notation. The term \u201csp\u201d will be a security parameter, and the term H=2. The subscripts \u201ci\u201d, \u201cj\u201d, and \u201ck\u201d designate individual elements indexed within a vector, and the subscript \u201c*\u201d designates the multitude of all elements in the vector (for describing parallel operations). The term Nwill be the product of two unknown primes, each in the range \u221a{square root over ( )}H, 2\u221a{square root over ( )}H. The terms g* and h* are generators whose discrete log mod N* with respect to each other is unknown. Indeed finding such an N* may be difficult, since that is the goal of the protocol.","In the description of the preferred protocol below, reference will be made to techniques known in the art for secret sharing [Sh], verifiable secret sharing [F], unconditionally secure verifiable secret sharing [P91], basic commitments using discrete logs over prime groups [P91], basic proofs of knowledge of discrete logs [GHY85, CEG, CEGP], and certain methods by which a number of parties can generate a random value by all committing to private random values, and then revealing those values. All publications referenced herein (both above and below) are hereby incorporated by reference in their entirety.","The main protocol proceeds in a series of steps as follows.\n\n","The MAIN PROTOCOL uses a number of supporting protocols. Those supporting protocols are described below.","Commitments are used to simulate in electronic communication the notion of posting a value in a sealed envelope that can only be opened in one-way (a binding property), but until opened it is concealing the value in it (a security property).","A party B can commit to value for party A, such that the commitment is binding, but a simulator could produce a commitment that is non-binding. An earlier use of such a mechanism (although it is a less efficient one) is in [IY87]. Simulator-Equivocal commitments are basically trapdoor commitments [FS89] combined with a proof of knowledge of the trapdoor.","The preferred commitment mechanism uses the following setup protocol, which only needs to be run once for any number of commitments (by itself it uses regular commitments to set up the special commitments).","Setup:",{"@attributes":{"id":"p-0037","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":[{"@attributes":{"id":"ul0008-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["A strong prime P and a generator g for Z*are distributively chosen using techniques known in the art.","Party A chooses a value g\u2032\u2208Z*to be used for B's commitments to A, transmits g\u2032 to B and proves to B that it knows the discrete log of g\u2032 base g. (This can be done using basic procedures for proving knowledge of discrete logs known in the art.)"]}},"Basic Commitments:\n    \n    "]}},"The scheme for multiplication over the integers is a variation of a protocol for distributed multiplication over a prime field. Multiplication over a prime field will be described first, and modifications to permit multiplication over the integers will be described second.","Sum-of-Poly Multiplication Over A Prime Field","The protocol multiplies two secret values where each is represented as a sum of polynomials. Related protocols (over prime fields only) are described in [GJKR], however, as opposed to those protocols, the protocol described here is unconditionally secure, and is based on the difficulty of discrete logs with no additional assumptions.","The scheme uses semantically-secure public-key encryption for sending private messages between servers. The severs (shareholders) S, . . . , S(for n\u22672t+1) can perform robust multiplication over a prime field while maintaining unconditional security. The goal of the protocol is to compute C\u2261(A+A+ . . . +A) (B+B+ . . . +B) mod P\u2032 where Aand Bare chosen by S. (The variable C as used in this section will correspond to N of the MAIN PROTOCOL, Awill correspond to pof the MAIN PROTOCOL, and Bwill correspond to qof the MAIN PROTOCOL.) The scheme proceeds in steps as follows.\n\n",{"@attributes":{"id":"p-0041","num":"0126"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"msub":{"mi":"V","mrow":{"mi":["i","j"],"mo":","}},"mo":["=","\u2062"],"mi":{},"mrow":{"mo":["\u220f","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":[{"mrow":{"mo":["(",")"],"msub":{"mi":["\u03b1","u"]}},"msub":{"mi":"b","mrow":{"mi":["i","v"],"mo":","}}},{"mi":"h","msub":{"mi":"r","mrow":{"mi":["i","j"],"mo":","}}}],"mo":["\u2062","\u2062"],"msub":{"mi":"\u03c1","mrow":{"mi":["i","j"],"mo":","}}}}}}},{"mtd":{"mrow":{"mrow":{"mi":["u","v"],"mo":"+"},"mo":["=","\u2062"],"mi":[{},"j"]}}}]}}},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":[{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":"All servers Scan check to see whether local shares match public shares. On a dispute as to the correct v(j) values, Schallenges Sto reveal the shares b(j) and r(j). All shareholders can determine if b(j) fits the verification shares for b(x), and they can check if the share v(j) fits the verification shares for v(x) by computing (gh)(gh)hmod P, where ghmod P can be computed from the \u03b1 verification shares for (a(x), a\u2032(x)), and ghmod P can be computed from the \u03c1 verification shares for (z(x), z\u2032(x))."}},"5. Prove Correctness of Verification Shares\n    \n    ","6. Outputs:\n    \n    "]}},"The MAIN protocol requires multiplication over the integers, whereas the basic scheme described above achieves multiplication over a finite field. The above scheme (over a finite field) can be modified as follows to perform multiplication over the integers.\n\n","The protocol begins with n+1 secret sharings: the first being a Shamir sharing of the secret over the integers, and the next n being sharings of companion secrets using the variant of Shamir sharing over the integers as described above. Specifically, for a secret s\u2208[0,K], a party chooses a random polynomial a(x)=\u03a3axsuch that a\u2261Ls, and each other a\u2208[0, L,2L, . . . , LK]. Then for each triple (N, g, h), the party chooses a random polynomial a\u2032(x)=\u03a3a\u2032xwith each a\u2032\u2208[0 . . . L, K]. Then the party sends shares of each polynomial to each shareholder (n+1 total shares to each shareholder) and publishes the verification shares {ghmod N}. Each shareholder Scan verify its shares a(k) and a\u2032 (k) using the verification shares over N, (for all 1\u2266k\u2032\u2266n).\n\n","The SUM-OF-POLY MULTIPLICATION OVER A FINITE FIELD can be modified as follows to perform multiplication over the integers. The protocol is unconditionally secure, but only in the statistical sense.","The protocol uses semantically-secure public-key encryption for sending private messages between servers. This protocol allows servers (shareholders) S, . . . S(for n\u22672t+1) to perform robust multiplication over the integers while maintaining unconditional security. The goal of the protocol is to compute C\u2261(A+A+ . . . +A(B+B+ . . . +b) mod P\u2032 where Aand Bare chosen by Sfrom the range [\u00bd\u221a{square root over ( )}H, \u221a{square root over ( )}H]. (The adversary may choose values from outside this range.)","The protocol is the same as that of the previous section except that the share computation is performed over the integers rather than mod P\u2032, the verification and check share computations are performed mod Nrather than mod P, and with the following specific changes:\n\n","Proofs of knowledge use the commitment tools chosen in the set up. These tools allow servers to perform efficient constant-round zero-knowledge proofs.\n\n","The preferred method uses a double-prime test scheme based on a prior one by Boneh-Franklin but modified to be robust and to \u201cchain\u201d the robustness tools to the preceding generation of the value n. In this method, servers can check whether a previously computed value N is the product of two large prime numbers (a condition that is required for using N in certain signature and other cryptographic schemes). To get robustness (e.g., to determine that N is double prime even if one server participating in the protocol is corrupt) the protocol makes use of a polynomial for each server Sdefined as:\n\n()=()+()=\u03a3,\n\nwhere a(x) and b(x) were used to distribute pand qrespectively in the Distributed Computation of N. The preferred method also uses the corresponding check shares used in the Pedersen sharing steps. For description purposes, these check share will be called \u03b3for 0\u2266j\u2266t, with\n\n\u03b3mod N,\n\nwhere p\u2032and q\u2032are the companion secrets to pand q, respectively.\n","The parties repeat the following steps as many times as necessary get the desired security level. Each successful repetition increases the confidence that the computed value N is double prime. A failure of any repetition indicates that N is not double prime, and the servers return to the RESTARTING POINT to compute a new value of N.\n\n","For each i\u22671 (i.e., remaining servers), each server Sbroadcasts Q=gmod N. Then it proves knowledge of the discrete log of Qand a corresponding representation of \u03b3(over gand h*) using the protocol in PROOF OF KNOWLEDGE OF A DISCRETE LOG.\n\n","The key generation step makes use of the relationship that \u03c6(N)=N\u2212\u03a3(p+q)+1(\u03c6(N) is the Euler function). The preferred protocol uses one of two procedures, a simple one for small public keys and a more complicated one for larger (general) public keys.","Certain operations can be easily done (while maintaining checking information to assure robustness) if a change of representation of the shared value is first performed. A \u201cpoly-to-sum\u201d technique is used which transforms a function shared by a t degree polynomial amongst n servers into a t-out-of-t additive (sum) sharing. A \u201csum-to-poly\u201d technique which transforms a function shared additively t-out-of-t into a t-out-of-n polynomial sharing. Share representation transformation techniques from [FGMYa] may be employed.","For small public keys, e.g., an RSA system where e=3, the following procedure may be used.\n\n","If \u03c6(N)=2 mod 3, the first shareholder Scomputes its share of d as d=(r\u2212(p+q\u2212x)\/3 (case 1), and for 2\u2266i\u2266n, each remaining shareholder Scomputes is share of d as d=\u2212(p+q\u2212x)\/3 (case 2).","If \u03c6(N)\u22611 mod 3, the first shareholder Scomputes its share of d as d=(r\u2032\u22122(p+q\u2212x))\/3 (case 3), and for 2\u2266i\u2266n, each remaining shareholder Scomputes its share of d as d=\u22122(p+q\u2212x)\/3 (case 4). (Recall that the value d is a secret, and the generation of shares of d without actually generating d is an object of the invention.)\n\n","For e large, the preferred protocol uses different techniques for finding (\u03c6(N))mod e which are related to ideas described by Boneh and Franklin. The preferred protocol takes advantage of an assumption that a value e can be found that is a prime, with E=2e+1 a (strong) prime. Earlier steps in the method utilized a definition that for 1\u2266i\u2266n, f(x)=a(x) +b(x). For description purposes, let f(x)=L(N+1)\u2212\u03a3f(x). Then f(0)=L\u03c6(N). The preferred method proceeds with the following steps.\n\n","In typical systems, h can be on the order of 1000 (i.e., 1024-2048). Working over the integers will add Less than 400 to the size of exponents, assuming that assurance of 2is reasonable. It can be expected that the value n will be less than 10, and 2\u2212kchance of error on proofs with k=40 to be sufficient assurance of correctness.","The probability of generating an RSA modulus from two random primes of sp\/2 bits each is about (sp\/2), so the procedure is expected to repeat for about sp\/4 rounds. The communication complexity of each round is bounded by O(nk(sp)) and the computational complexity of each round is about O(n(k+t)) modular exponentiations. Given realistic values of k and t, the computational complexity is dominated by the multiplication protocol and would be about 24n(t+1) modular exponentiations. Not much efficiency can be gained by performing trial division as discussed by Boneh and Franklin, since each trial against a small prime would involve a robust multiplication, and thus around O(ntB\/lnB) modular exponentiations for each distributed integer tested.","Numerous practical improvements can be made. First, trial division can be done once a possible N is generated, and this would eliminate many distributed double-primality tests. Also, if the test that each pand qare in the correct range is done after this trial division, then many of those can be saved. (In this case, N needs to be tested to make sure it is in a possible range, so that flagrant misbehavior of shareholders can be determined.)","Perhaps the largest improvement would come from revealing the value of each pmod-the-product-J-of-small-primes-up-to some-B, and assuming the shared value is a multiple of the J. The sum of the revealed values could be tested to see if it is divisible by any of the small primes up to B. If so, the distributed integer would not be prime and would be thrown out. Of course, this reduces security, so it would preferably be done for primes up to, e.g., 7. This reduces the security by about 6 bits (log((2\u22121)(3\u22121)(5\u22121)(7\u22121))), but would increase the probability that the number is prime by a factor of about 5, and thus reduce the expected number of rounds for the protocol by a factor of about 25. (If the reduction in security is worrisome, sp could be slightly increased without affecting the running time significantly. Or one could only use primes 2 and 3, reducing the security by about 1 bit, while reducing the expected number of rounds for the protocol by about 6.)","With the improvements described above, the total number of modular exponentiations in the protocol will be about 24n(t+1) times (sp\/10)(reduced from (sp\/2)because of the substitute for trial division), which is about 10,000. For the case n=4 and t=1, there are 2,000,000 modular exponentiations. The non-robust protocol of Boneh-Franklin using trial division up to 8,103 performs about 484 modular exponentiations, about a factor of 4000 less.","If it is likely that all parties are honest, one can increase performance by performing \u201coptimistic execution\u201d. The idea is to run the protocol (plus the trial division from Boneh-Franklin) but without any checking information. That is, there would be no companion polynomials or verification shares generated. At the end of each round in which the participants failed to produce an RSA modulus, they reveal all their information from the round. If all participants agree that the information revealed is correct, then there has been no cheating in that round, and they proceed. If cheating is ever found, they revert to the robust protocol described in this paper. If an RSA modulus is found, then they rerun the round using the same polynomials sharings, but including the robustness checks (i.e., companion polynomials, verification shares, proofs of knowledge). If all the information is verified correctly, then they use the RSA modulus. Otherwise, cheating has occurred and they revert to the robust protocol.","The problem with this \u201cmode\u201d of operation is that cheating can be detected, but it is impossible to determine exactly which participant cheated. To determine who cheated, one can require that participants sign their messages to other participants, and have recipients of messages either accept the signature or ask the sender to reveal the message to everyone. Assuming the signatures are RSA signatures on participants private keys, one can assume that they require a single modular exponentiation. Furthermore, one could use one signature per round, or even over multiple rounds, to reduce the number of modular exponentiations. In all, this method will still be robust and secure (with some standard assumptions about security and robustness of signatures and encryptions), but require only about ntimes the modular exponentiation of the non-robust protocol, where n is the number of participants. (Note that this only works when n is greater than 3t+1], because one cannot use zero knowledge [ZK] proofs to guarantee correct shares in the multiplication protocol.)","Performance can also be improved by using a faster modular exponentiation algorithm, as in [BGM], since in these robust protocols, participants will be performing many exponentiations over the same base and modulus.","Another source of efficiency may come from collapsing rounds in the zero-knowledge proofs by using the known method of self-challenging string derived from a common one-way hash function believed to be computationally indistinguishable from a random oracle [FS86].","The supporting protocols can be combined to improve many of the applications of mathematical operations over distributed values or cryptographic keys. Such operations involve multiplication, inversion, additional, and exponentiation. One example mentioned above is the DSS distributed protocol.","Once a composite N is established there are numerous ways to use it in various cryptographic protocols other than as a distributed RSA system:\n\n"],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","BRIEF DESCRIPTION OF THE PREFERRED EMBODIMENTS","General System Description","The Main Protocol","Simulator Equivocal Commitments","Multiplication Scheme Over The Integers","Basic Techniques Over The Integers","Robustness Tools","Robust Distributed Double-Primality Test","Robust Distributed Generation of Public and Private Keys","Key Generation for Small Public Keys","Key Generation for Large Public Keys","Efficiency of the Protocol and Variations","Variations on the Protocol"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":{"@attributes":{"id":"p-0013","num":"0064"},"figref":"FIG. 1"}},"DETDESC":[{},{}]}
