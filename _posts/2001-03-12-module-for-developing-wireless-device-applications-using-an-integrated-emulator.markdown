---
title: Module for developing wireless device applications using an integrated emulator
abstract: An apparatus for facilitating development of an application for a wireless-connected device including a module have a plurality of development tools for use in the creation of the application and an emulator of the wireless-connected device integrated with the module. An additional emulator for an additional wireless-connected device is also included. The module may be included in an Integrated Development Environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07155381&OS=07155381&RS=07155381
owner: Sun Microsystems, Inc.
number: 07155381
owner_city: Santa Clara
owner_country: US
publication_date: 20010312
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This invention relates to the field of software development tools utilizing integrated emulators for developing applications. The applications are written to execute on mobile, wireless-connected devices.","The basic functionality of a computer is dictated by the type of operating system it uses. Various operating systems exist in the market place, including Solaris\u2122 from Sun Microsystems Inc., Palo Alto, Calif. (Sun Microsystems), MacOS\u00ae from Apple Computer, Inc., Cupertino, Calif., Windows\u00ae 95\/98 and Windows NT\u00ae, from Microsoft Corporation, Redmond, Wash., and Linux. The different types of operating systems will be referred to herein as \u201cplatforms\u201d. Prior to the popularity of the Internet, software developers wrote programs specifically designed for individual platforms. Thus, a program written for one platform could not be run on another. However, the advent of the Internet made cross-platform compatibility a necessity.","Prior art  illustrates a conceptual arrangement wherein a first computer () running the Solaris\u2122 platform and a second computer () running the Windows\u00ae 98 platform are connected to a server () via the internet (). A resource provider using the server () might be any type of business, governmental, or educational institution. The resource provider has a need to be able to provide its resources to both the user of the Solaris\u2122 platform and the user of the Windows\u00ae 98 platform, but does not have the luxury of being able to custom design its content for the individual platforms.","The Java\u2122 programming language was developed by Sun Microsystems to address this problem. The Java\u2122 programming language was designed to be simple for the programmer to use, yet able to run securely over a network and work on a wide range of platforms.","Referring to , in order to create a Java\u2122 application, the developer first writes the application in human-readable Java\u2122 source code. As used herein, the term \u201capplication\u201d refers to Java\u2122 2 Standard Edition (J2SE\u2122) applications, Java\u2122 2 Micro Edition (J2ME\u2122), and Java\u2122 \u201capplets\u201d which are essentially small applications usually embedded in a web page. In the example shown, the application \u201cProgram\u201d () is created as a human-readable text file. The text file contains Java\u2122 language commands, e.g. \u201cimport java.awt.frame.\u201d The name of this text file is given the required five-character extension \u201c.java\u201d.","The Java\u2122 compiler (\u201cjavac\u201d, \u201cfastjavac\u201d, \u201cjvc\u201d, et. al.) () is used to compile the source code into a platform independent bytecode (). Compilation of J2ME\u2122 applications is slightly different than for J2SE\u2122. The J2ME\u2122 compilation process adds a pre-verification step after the bytecode () is generated. This final step produces a pre-verified bytecode. Using either method of compilation, the resulting binary file () will automatically receive the same file name as the source text file with \u201c.class\u201d extension or the same name of the source file plus a special character \u201c$\u201d plus the name of an inner class with the extension \u201c.class.\u201d","The Java\u2122 runtime environment incorporates a virtual machine () to verify whether a given bytecode () has the proper format (verification process) and convert the \u201c.class\u201d byte codes into actual machine executions (). The machine executions (like drawing windows, buttons, and user prompt fields) will occur in accordance to the application developer's code instructions. Because Sun Microsystems specifically designed the virtual machine () to run on different platforms, a single set of \u201c.class\u201d byte codes will execute on any platform where a virtual machine () has been installed. An Internet browser such as Netscape\u00ae and Microsoft\u00ae Internet Explorer that incorporates a virtual machine () is called a \u201cjava-enabled\u201d browser. A discussion of the Java\u2122 language itself is beyond the scope of this document. However, complete information regarding the Java\u2122 programming language and the Java\u2122 platform are available from Sun Microsystems in print.","The cross-platform architecture of the Java\u2122 programming language is illustrated in , which shows how the Java\u2122 language enables cross-platform applications over the Internet. In the figure, the computer () running the Solaris\u2122 platform and the computer () running the Windows\u00ae 98 platform are both provided with the virtual machine (). The resource provider creates a Java\u2122 application using the Java\u2122 software development kit (\u201cSDK\u201d) () and makes the compiled Java\u2122 byte codes available on the server (), which in this example is running on a Windows NT\u00ae platform. Through standard Internet protocols, both the computer () and the computer () may obtain a copy of the same byte code and, despite the difference in platforms, execute the byte code through their respective virtual machine ().","As the popularity of the Internet has increased, users have become accustomed to many different types of interfaces. Thus, aesthetic conformity has become less of an issue. At the same time, speed, functionality, and versatility have become increasingly important. Therefore, the J2SE\u2122 SDK includes a new \u201cpackage\u201d for the developer called \u201cswing\u201d that is essentially library of \u201clightweight components\u201d. This new package is simply one library that is possible; other libraries may be created and in fact are available from third parties. Swing provides the developer with the option and flexibility to use lightweight. A detailed discussion of the Swing package is beyond the scope of this document. Complete documentation is available from Sun Microsystems both in print and at the web site java.sun.com.","Forte for Java\u2122 products derived from NetBeans\u2122 Open Source Project, are visual programming environments written entirely in Java\u2122 and Swing. These products are commonly regarded as Integrated Development Environment (IDE). This IDE is easily customizable and extensible, as well as platform independent. As is illustrated in , Forte\u2122 for Java\u2122 includes a powerful Form Editor (), integrated full-featured text editor (), debugger (), compiler (), etc. Forte\u2122 for Java\u2122 is also completely modular and is built around a set of Open Application Programming Interface (API's) which allow the IDE to be easily extensible. This means that the IDE functionality for editing, debugging, GUI generation, etc. is represented in modules that can be downloaded and updated dynamically as is illustrated in . Instead of waiting months for a completely new release, as soon as new versions () or new modules () are available, users can update that individual version or module via the Update Center () or from other vendors.","With an increase in popularity of mobile, wireless-connected devices (like cellular phones, personal digital assistants, point of sale terminals, two-way pagers or any other device constrained in processing power, memory and graphical capability), the release of J2ME\u2122 technology () has emerged. J2ME\u2122 is the edition of Java\u2122 2 platform that targets consumer electronics and embedded devices. J2ME\u2122 technology () allows the use of applications that are on these devices targeted at satisfying consumer market demand for wireless access to at-your-fingertips information, service, and entertainment (e.g., sport scores, financial information, e-commerce, games, interpersonal communication, etc.). This J2ME\u2122 technology provides a standard platform for small, resource-limited, wireless-connected mobile information devices.","In addition to being wireless-connected, these mobile information devices have small displays, low bandwidth, high latency network connections, limited input devices, limited local storage, battery life and processor power. These devices may be roughly divided into two categories: devices that are mostly mobile, and devices that typically remain fixed. The hardware and network resources available to mobile devices tend to be more limited than in the case of devices with an ample supply of wall-power. Conversely, devices with easy access to power and wired network connections can take advantage of the wires to provide more power and sophistication to the user. Recognizing this distinction, the J2ME\u2122 technology () consists of the virtual machine () and set of APIs suitable for providing tailored runtime environments for consumer and embedded electronics.","J2ME\u2122 technology () as depicted in  has two primary kinds of components\u2014a configuration () and a profile (). The configuration () is the combination of a virtual machine (any virtual machine that is at least as capable as a Sun Microsystems K virtual machine (KVM)) and \u201ccore\u201d APIs () that represent an underlying development platform for a broad class of devices. Configurations () are nestable, so that any software able to execute on a less capable configuration is able to execute on a more capable one. At present, two accepted configurations () are a Connected Device Configuration (CDC) and a J2ME\u2122 Connected Limited Device Configuration (CLDC) (). The CDC is a more robust configuration that allows any software to be able to execute on larger, fixed hardware. The design center for smaller handheld devices is addressed by the CLDC (). The CLDC () specification outlines the most basic set of libraries and virtual machine features () that must be present in each implementation of a J2ME\u2122 environment on highly constrained devices. To form a complete environment for any given class of device, manufacturers add additional libraries, that address API areas not dealt with in the low-level CLDC (), such as user interface and device-specific networking.","The heart of the CLDC () and J2ME\u2122 technology () in mobile devices is KVM. The KVM is a virtual machine designed from the ground up with the constraints of inexpensive mobile devices in mind. It is highly optimized for very resource-constrained consumer devices. Named to reflect that its size is measured in the tens of kilobytes, the KVM is suitable for devices with 16\/32-bit RISC\/CISC microprocessors\/controllers, and with as little as 160 K of total memory available, of which 128 K is for the storage of the KVM and libraries themselves. Like all virtual machines (), the KVM provides the foundation for the download and execution of dynamic content and services.","Like a standard virtual machine (), a KVM supporting CLDC () must be able to reject invalid classfiles. However, since the static and dynamic memory footprint of the standard Java\u2122 classfile verifier is excessive for a typical CLDC () target device, a more compact and efficient verification solution has been created. The implementation of the new verifier in the KVM requires about ten kilobytes binary code and less than 100 bytes of dynamic RAM at runtime for typical class files. The verifier performs only a linear scan of the bytecode (), without the need of a costly iterative dataflow algorithm. The new verifier requires Java classfiles to contain a special attribute. The new verifier includes a pre-verification tool that inserts this attribute into normal class files. A transformed class file is still a valid J2SE\u2122 class file, with additional attributes. These attributes are automatically ignored by the conventional classfile verifier, so the solution is fully upward compatible with the J2SE\u2122 virtual machine ().","The profile () is a set of original equipment manufacturer (OEM) specific APIs () built on top of and utilizing an underlying configuration (), necessary to provide a complete runtime environment for a specific kind of device. The profile () must be complete in the sense that an application written to the specification can execute in the specified Java\u2122 technology environment without the addition of other Java\u2122 classes. The profile () can be thought of as selecting classes from APIs to form a complete environment. The profile () is designed and integrated to meet the needs of specific industry segments. At present, two J2ME\u2122 wireless profiles exist: 1) Mobile Information Device Profile (MIDP) () and 2) DoJa, which is a proprietary profile developed by NTT DoCoMo similar to MIDP ().","The MIDP () is a set of Java\u2122 APIs which, together with the CLDC (), provides a complete J2ME\u2122 application runtime environment targeted at mobile information devices, such as cellular phones and two-way pagers. A diagram showing the relationship between MIDP (), CLDC (), OEM specific APIs () and MIDP applications ()\/OEM applications () running on different platforms () is shown in . The MIDP specification addresses issues such as user interface, persistence storage, networking, and application model. The MIDP specification also provides a standard runtime environment that allows new applications and services to be dynamically deployed on end user devices.","Any J2ME\u2122 wireless application may be in the form of an MIDP applications () or an OEM application (). However, as is shown in , the applications are not totally different. A J2ME\u2122 wireless application consists of two files, namely a jar file () and an application descriptor (). The jar file () contains the MIDP application () itself. The application descriptor () contains information such as the name of the application, location of the jar file, and main class. The IDE uses the same user interface for both types of the applications, but the format of the file that is used for storing and checking of values depends on type of the application.","In one aspect, the invention comprises an apparatus for facilitating development of an application for a wireless-connected device. The application is created by the use of a module having a plurality of development tools. The module is integrated with an emulator of the wireless-connected device that in an embodiment is designed to execute the application. In an embodiment, the module is integrated with an additional emulator for an additional wireless device. In an embodiment, the module is included in an Integrated Development Environment (IDE) and the module is accessible through a drop-down menu in the IDE. In an embodiment, the module is designed to allow creation and packaging of the application with a plurality of profiles without modification of the module.","In another aspect, the invention comprises an apparatus for facilitating development of an application for a wireless-connected device including a module integrated with an emulator of the wireless-connected device, a means for executing the application on the emulator of the wireless-connected device, and a means for creating and packaging the application with a plurality of profiles without modification of the module. In an embodiment, the module is included in an IDE. In an embodiment, the module comprises a plurality of development tools used in the creation of the application executed on an integrated emulator of the wireless-connected device. In an embodiment, the module is integrated with a plurality of emulators for a plurality of different wireless-connected devices.","In another aspect, the invention comprises a computer system for facilitating development of an application for a wireless-connected device. The computer system has a storage element comprising a module. The module stores a plurality of development tools. A processor and an input device creates the application using the module. An emulator is integrated with the module stored on the storage element using the processor to execute the application on the emulator of the wireless-connected device. In an embodiment, the module is integrated with an additional emulator for an additional wireless device. The module is designed to allow creation and packaging of the application with a plurality of profiles without modification of the module. In an embodiment, a computer monitor adapted to display the application and the integrated emulator of the wireless-connected device is included in the computer system. In an embodiment, the module is included in an IDE accessible through a drop-down menu.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.","The invention described here may be implemented on virtually any type computer regardless of the platform being used. For example, as shown in , a typical computer () has a processor (), associated memory (), and numerous other elements and functionalities typical to today's computers (not shown). The computer () has associated therewith input means such as a keyboard () and a mouse (), although in an accessible environment these input means may take other forms. The computer () is also associated with an output device such as a display (), which may also take a different form in an accessible environment. Computer () is connected via a connection means () to the Internet (). The computer () is configured to run a virtual machine (), implemented either in hardware or in software.","Development of applications for CLDC () target, wireless-connected devices is typically done on a different platform than the J2ME\u2122 technology () because the inputting and testing of applications on the small, limited devices is tedious. Ideally, an IDE (), such as Forte\u2122 for Java\u2122 is used to develop applications for CLDC () target, wireless-connected devices. The multi-threaded IDE () provides editing, compilation, packaging, and execution of an application.","Referring to , J2ME\u2122 specific compilation and packaging is provided by a J2ME\u2122 Wireless Emulator Module () for the IDE (). Execution is done in an external emulator () and the module () provides a bridge to the emulator (). The emulator () is used to test applications and is executed in the same virtual machine () as the IDE (). The three main features of the module () are: (1) a pluggable architecture where it is possible to add a new implementation of the emulator () by a third party or a manufacturer for wireless-connected devices; (2) an ability to configure and run with different implementations of the emulator (); and (3) an ability to create and to package applications developed according to different profiles (such as MIDP or DoJa) without modification of the module ().","As illustrated in , there are defined two interfaces for the module () that allow for integration between an IDE () such as Forte\u2122 for Java\u2122 and an emulator (). A first interface is an Emulator Environment (EE) () that works as a factory and is used for communication with the emulator (). The EE () allows for execution of an application, provides configuration beans, and provides information that is necessary for compilation of the application. Included in the information are methods that make it possible to obtain classpath configurations (e.g., path to classes defined by CLDC (), path to classes defined by MIDP\/DoJa profiles, and path to OEM specific classes). A second interface is an Emulator Configuration () that allows a user to change the behavior and \u201clook and feel\u201d of the emulator (). The class name of the implementation of the EE () is specified in a special configuration file together with additional properties. The configuration is changed by using a configuration bean provided by the emulator (). The bean is used as a parameter for the emulator's invocation. By changing the configuration of the EE (), a classpath can be affected (the emulator can emulate different devices with different APIs). The classpath for a particular configuration is obtained by using EmulatorEnvironment.getAPIClassPath (Emulator Configuration) method.","The IDE (), such as Forte\u2122 for Java\u2122, dynamically downloads the implementation and facilitates the emulator () to be used for execution of J2ME\u2122 applications. An example an implementation of Emulator Configuration () is shown in  where a property httpProxy () is used for configuration of http proxy. \u2018Device Name\u2019 property () makes it possible to change type of device (e.g., mobile phone, pager, etc.).  shows the corresponding emulator look of the emulator in the case \u2018Device Name\u2019 property () has value \u2018DefaultColorPhone\u2019 (). By changing \u2018Device Name\u2019 property () to value \u2018Minimum Phone\u2019 the emulator look changes, as is shown in .","When a new version of the emulator () is developed, implementation of a new emulator interface (EE () and Emulator Configuration ()) may also be necessary. If so, once the interface is implemented, the IDE () is able to interface with the emulator (). The module () is able to work with different application types and different profiles () of the J2ME\u2122 applications in a seamless manner. It is also possible to add new\/change existing types of applications without a modification of the module () and to create a configuration file () for another type of the application descriptor () without a necessity to change the module ().","Following is a description of how the EE () is installed, configured and used in one embodiment of this invention. The EE () must be installed and configured prior to using the module () because the IDE () uses an emulator () to execute an application. However, there are various implementations (and different configuration dialogs) of the emulator () that differ in user interface and configuration. That is the reason for the creation of the EE () where the IDE () is able to use all different types of emulators () without having to recompile the module (). Just as with module (), the emulator () is executed in the same virtual machine () as the IDE (). When used internally by the IDE (), the EE () is configured and launched from within the IDE ().","In one embodiment, the installation process of the EE () copies the module () (kjava.jar) to a {forte.home}\/modules directory and EE interface classes (kenv.jar) to a {forte.home}\/lib\/ext directory. During the installation of the module (), the installation process creates a kee.properties file in a {forte.home}\/system\/kjava directory. The kee.properties file contains at least the following items:\n\nkee.tools=<location of EE tools classes>\n\nkee.emulator.class=<class that implements EE interface>\n\nkee.home=<home directory of EE>\n\nkee.preverifier=<path to preverifier process>\n\nkvem.home=<the same as kee.home\u2014used for compatibility reasons>\n\nThe properties file is read upon the IDE () startup and all properties are set as system properties so the EE implementation can use them.\n","In one embodiment of the invention, access to the module () specific settings is made possible by creating a drop-down menu in the IDE (). The project-specific settings are found under a \u2018Project Settings\u2019 menu heading under a menu \u2018J2ME Wireless Settings.\u2019 Global specific settings are found under \u2018Tools\u2019 menu heading under a menu \u2018Global Options\u2019 and a submenu \u2018J2ME Wireless Options\u2019.","An overview of a development cycle for programming an application for a CLDC () target, wireless-connected device using the module () is shown in . This overview is followed by a detailed description of the steps of the cycle. The cycle starts with an initialization process (step ) followed by an editing step (step ) where a human-readable text file is created and modified. Next is the compilation process (step ). If compilation is unsuccessful, the text file should be edited and the cycle continues from the editing step (step ). After successful compilation, the preverification process (step ) is performed. If preverification is unsuccessful, modifications should be made and the cycle continues from the editing step (step ). After successful preverification is performed, the next process is packaging (step ). If packaging is unsuccessful, modifications should be made and the cycle continues from the editing step (step ). After successful packaging is performed, the last process is execution (step ). If execution is unsuccessful, modifications should be made and the cycle continues from the editing step (step ).","The initialization process (step ) as shown in  starts with either loading or setting properties from kee.properties (step ). Next, an Emulator Executor () is initialized (step ) and then configurations from previous sessions (if any) are deserialized (step ).","Referring to , the compilation process (step ) begins by getting an assigned emulator configuration (step ). Next, a classpath is set using a value obtained by getAPIClassPath( ) method (step ). Lastly, the text file generated in the editing step (step ) is compiled by a J2ME\u2122 Wireless Compiler () (step ). If any errors occur during the process, the process ends without successful compilation.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 17","b":["118","140","146","148","149","144","142","144"]},"The execution process (step ), as shown in , begins with checking the manifest file (step ). If the manifest is not proper, an error occurs (step ) and the execution process ends without successful execution. If the manifest file is proper, the given application is executed with the given configuration (step ). If the execution results in an input\/output exception (IOException), an error occurs (step ) and the execution process ends without successful execution. If the execution does not result in an IOException, the execution process is complete.","The use and support of the module () with the IDE () starts with a proper installation of the components as presented in . An installation process involves the following steps. First, the installation of an IDE () such as Forte\u2122 for Java\u2122 (step ). Next, the installation of the module () (step ). Next, the emulator configuration files (EE (), Emulator Configuration ()) are installed (step ). Next, OEM specific files, additional templates, a parser database and examples are installed. Basic templates are part of the module () and are installed in the \u2018Templates\u2019 folder of the Forte\u2122 for Java\u2122 IDE during the installation of the module (). The set of installed templates may change depending on OEM installation and customer request. Lastly, the IDE () is run (re-started) (step ) to finish the installation.","The parser database is installed to ensure proper functionality and to enable an IDE code completion feature. Two possible ways of handling the parser installation of the database include copying prepared databases or to generate required databases on the fly during the installation of the module ().","After the installation is complete, two data objects are integrated. The JavaDataObject () is integrated () in conjunction with the integration of a corresponding ADDataObject (). The JavaDataObject (), as shown in , is part of Java\u2122 Module that is included in standard distribution for Forte\u2122 for Java\u2122. The JavaDataObject () covers Java\u2122 sources and class files and displays the sources and class files as one node in an IDE Explorer. The module () adds some functionality to the JavaDataObject (). The module () defines J2ME\u2122 Wireless Compiler () which extends Internal Compiler.","J2ME\u2122 Wireless Compiler () is used for compilation of classes as shown in .","Referring to , the module () defines Emulator Executor (), J2ME\u2122 Wireless Compiler (), ADDataObject () and interfaces (EE () and Emulator Configuration ()). Emulator Executor () uses EE () to produce the Emulator Configuration (). Emulator Executor () holds exactly one Emulator Configuration (), which may be customized. Emulator Executor () also uses EE () for execution of the application.","ADDataObject () represents one J2ME\u2122 wireless project and may contain other DataObject defined by the IDE. The most typical DataObject are Java sources (JavaDataObject ()) and images (). ADDataObject () uses three files for storing information. First, an application descriptor () defined in MIDP or DoJa specification. Next, an application jar file (). Third, an adContent file () that contains additional information that may be necessary to build the application jar file (), e.g. a list of files that are part of a J2ME\u2122 application, a filter (to exclude some files from the jar file () such as sources), compress level of the jar file, and type of application descriptor.","The adContent file uses XML format with the following structure:\n\n<?xml version=\u201c1.0\u201d?>\n",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<AdContent version=\u201c1.0\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<FileSystem systemName=\u201cfilesystemID\u201d>"]},{"entry":[{},"<File name=\u201cpath\u201d \/>"]},{"entry":[{},"<\/FileSystem>"]},{"entry":[{},"<Filter common=\u201cDefault\u201d \/>"]},{"entry":[{},"<Jar compressLevel=\u201c6\u201dcompress=\u201ctrue\u201d \/>"]},{"entry":[{},"<Descriptor descriptorType=\u201cjad\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/AdContent>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The ADDataObject () appears in one node in the IDE explorer and defines four different operations. First is the open operation that allows the ability to add\/remove files to the J2ME\u2122 Wireless application, change settings of the jar file (), and edit the application descriptor (). Next, an update jar operation creates or updates the jar file (). This operation covers preverification of class files, packaging and update of a manifest file and application descriptor () (size of jar file () and last modification time). Next, an execute operation that allows execution of a CLDC () target, wireless-connected device application. The last operation is a collection of cut, copy, paste, delete, rename, save as template, tools, and properties that operate in the usual manner expected by someone skilled in the art. The ADDataObject () hides all differences between DoJa, MIDP or any other possible specifications. Every type of application is described by a special Extensible Markup Language (XML) file, so ADDataObject () reads a configuration file within the special XML file for an appropriate type of application and then changes internal behavior to match.","Every type of application (DoJa, MIDP, other) has a separate configuration file. The name of a file is <extension of application descriptor>.xml and it is located in a{forte.home}\/system\/kjava directory. Currently there are two types, namely jam for DoJa and jad for MIDP. The configuration file is an XML file with the following structure:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d?>"},{"entry":"<Options version=\u201c1.0\u201d>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Option name=\u201cAppName\u201drequired=\u201ctrue\u201d \/>"]},{"entry":[{},". . ."]},{"entry":[{},"<Encoding name=\u201cSJIS_i\u201d \/>"]},{"entry":[{},"<Delimiter char=\u201c=\u201d \/>"]},{"entry":[{},"<Validator class=\u201ccom.nttdocomo.kvem.environment.Jam-"]},{"entry":[{},"Validator\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/Options>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Possible tags include Encoding, Delimiter, Option and Validator. Encoding is an encoding for the application descriptor. Delimiter indicates the application descriptor uses the same format as Java\u2122 properties. However, different delimiters can be used (typically : or =). A delimiter other than the default may be specified using this element. Option describes one item of the application descriptor. Options can be marked as required (attribute required), as manifest (attribute manifest). Options can also be marked as a special option, which is generated by the module () (for example, the option that represents time of a last modification of a jar file). Options have assigned a special format meaning that either a format which should be used by the module when it creates an automatically generated value or a format that is required for user typed values. Validator tag may define a class that is used for a more sophisticated check of an option value. For example, the Validator can require an attribute with the name \u201cAppName.\u201d","Advantages of developing applications using the module () are many. First, programming is simplified and streamlined by using the module () integrated with an IDE (). The IDE () typically allows for development with an editing tool, compiler, de-bugger and packager in one product. The IDE () with the plug-in module () integrated with an emulator (), adds the ability to program, observe and test applications for CLDC () target, wireless-connected devices in an IDE () without requiring downloads of applications onto a particular device to test the application. In addition, the module () employs a pluggable architecture where it is possible to add, configure and run a new implementation of the emulator () by a third party or a manufacturer for wireless-connected devices. Another advantage of using the module () to develop J2ME\u2122 applications is the ability to create and to package applications developed according to different profiles (such as MIDP or DoJa) without modification of the module ().","While the invention has been described with respect to a limited number of embodiments, those skilled in the art will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
