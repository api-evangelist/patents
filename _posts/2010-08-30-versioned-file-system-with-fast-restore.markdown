---
title: Versioned file system with fast restore
abstract: A versioned file system comprises a set of structured data representations, such as XML. Each structured data representation corresponds to a “version,” and each version comprises a tree of write-once objects rooted at a root directory manifest. Each version in the versioned file system has associated therewith a “borrow window.” When it is desired to reconstruct the file system to a point in time (or, more generally, a given state), i.e., to perform a “restore,” it is only required to walk (use) a single structured data representation (a tree). During a restore, metadata is pulled back from the cloud first, so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if/when the user goes to open the file. As a result, the entire file system (or any portion thereof) can be restored to a previous time nearly instantaneously. A “fast” restore is performed if an object being restored exists within a “borrow window” of the version from which the system is restoring.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08799231&OS=08799231&RS=08799231
owner: Nasuni Corporation
number: 08799231
owner_city: Natick
owner_country: US
publication_date: 20100830
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["This application is related to the following applications:","Ser. No. 12\/483,030, filed Jul. 11, 2009, titled \u201cMethod and system for versioned file system using structured data representations\u201d;","Ser. No. 12\/508,614, filed Jul. 24, 2009, titled \u201cMethod and system for interfacing to cloud storage.\u201d","1. Technical Field","This application relates generally to data storage.","2. Background of the Related Art","It is known to provide an interface between an existing local file system and a data store (e.g., a \u201cwrite-once\u201d store) to provide a \u201cversioned\u201d file system. The versioned file system comprises a set of structured data representations, such as XML. In a representative embodiment, at a first time, the interface creates and exports to a data store a first structured data representation corresponding to a first version of the local file system. The first structured data representation is an XML tree having a root element, a single directory (the \u201croot directory\u201d) under the root element, zero or more directory elements associated with the root directory, and zero or more elements (such as files) associated with a given directory element. Each directory in turn can contain zero or more directories and zero or more files. Upon a change within the file system (e.g., file creation, file deletion, file modification, directory creation, directory deletion and directory modification), the interface creates and exports a second structured data representation corresponding to a second version of the file system. The second structured data representation differs from the first structured data representation up to and including the root element of the second structured data representation. Thus, the second structured data representation differs from the first structured data representation in one or more (but not necessarily all) parent elements with respect to the structured data element in which the change within the file system occurred. The interface continues to generate and export structured data representations to the data store, preferably at given \u201csnapshot\u201d times when changes within the file system have occurred. The data store comprises any type of back-end storage device, system or architecture. In one embodiment, the data store comprises one or more cloud storage service providers. As necessary, a given structured data representation is then used to retrieve an associated version of the file system. In this manner, the versioned file system only requires write-once behavior from the data store to preserve its complete state at any point-in-time.","A versioned file system comprises a set of structured data representations, such as XML. Each structured data representation corresponds to a \u201cversion,\u201d and each version comprises a tree of write-once objects rooted at a root directory manifest. Each version in the versioned file system has associated therewith a \u201cborrow window.\u201d When it is desired to reconstruct the file system or any portion thereof (including just a single file) to a point in time (or, more generally, a given state), i.e., to perform a \u201crestore,\u201d it is only required to jump to (and use) a particular node in a single structured data representation, and the identity of that node is known from the file being restored. During a restore, an existing file (or, more generally, a portion of the file system) is associated into a new place in the file system, which results in two identifiers (e.g., filenames) within the file system pointing to the same (single) object. Only the metadata for the existing file (or file system portion) being associated into a new place in the file system is necessary to do a restore; thus, a restore operation occurs quickly, and without regard to the size of the file (or file system portion). In effect, the metadata for the file (or file system portion) being restored is pulled back from the cloud first, so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if\/when the user goes to open the file. As a result, the entire file system or any portion thereof can be restored to a previous time nearly instantaneously. A \u201cfast\u201d restore is performed if an object being restored exists within a \u201cborrow window\u201d of the version from which the system is restoring.","In an alternative embodiment, the above-described method is performed in an apparatus comprising a processor, and computer memory holding computer program instructions that when executed by the processor perform the fast restore method.","In another alternative embodiment, the above-described method is performed by a computer program product in a computer readable medium for use in association with the versioned file system, which itself may be located in a backing store. The computer program product holds computer program instructions which, when executed by a processor, perform the fast restore method.","The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["100","102","102","104","102","104","104"]},"The interface  may be implemented as a machine. A representative implementation is the Nasuni\u00ae Filer, available from Nasuni Corporation of Massachusetts. Thus, for example, typically the interface  is a rack-mounted server appliance comprising hardware and software. The hardware typically includes one or more processors that execute software in the form of program instructions that are otherwise stored in computer memory to comprise a \u201cspecial purpose\u201d machine for carrying out the functionality described herein. Alternatively, the interface is implemented as a virtual machine or appliance (e.g., via VMware\u00ae, or the like), as software executing in a server, or as software executing on the native hardware resources of the local file system. The interface  serves to transform the data representing the local file system (a physical construct) into another form, namely, a versioned file system comprising a series of structured data representations that are useful to reconstruct the local file system to any point-in-time. A representative VFS is the Nasuni Unity File System (UniFS\u2122). Although not meant to be limiting, preferably each structured data representation is an XML document (or document fragment). As is well-known, extensible markup language (XML) facilitates the exchange of information in a tree structure. An XML document typically contains a single root element (or a root element that points to one or more other root elements). Each element has a name, a set of attributes, and a value consisting of character data, and a set of child elements. The interpretation of the information conveyed in an element is derived by evaluating its name, attributes, value and position in the document.","The interface  generates and exports to the write-once data store a series of structured data representations (e.g., XML documents) that together comprise the versioned file system. The data representations are stored in the data store. Preferably, the XML representations are encrypted before export to the data store. The transport may be performed using known techniques. In particular, REST (Representational State Transfer) is a lightweight XML-based protocol commonly used for exchanging structured data and type information on the Web. Another such protocol is Simple Object Access Protocol (SOAP). Using REST, SOAP, or some combination thereof, XML-based messages are exchanged over a computer network, normally using HTTP (Hypertext Transfer Protocol) or the like. Transport layer security mechanisms, such as HTTP over TLS (Transport Layer Security), may be used to secure messages between two adjacent nodes. An XML document and\/or a given element or object therein is addressable via a Uniform Resource Identifier (URI). Familiarity with these technologies and standards is presumed.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","202","200","206","202","204","208","210"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["306","300","308","302","310","3","304","312","314","316"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","402","402","404","406","400","402","404","408","406","410","412","408","410","414","412","416","418","418","420"]},"The interface shown in  may be implemented as a standalone system, or as a managed service. In the latter case, the system executes in an end user (local file system) environment. A managed service provider provides the system (and the versioned file system service), preferably on a fee or subscription basis, and the data store (the cloud) typically is provided by one or more third party service providers. The versioned file system may have its own associated object-based data store, but this is not a requirement, as its main operation is to generate and manage the structured data representations that comprise the versioned file system. The cloud preferably is used just to store the structured data representations, preferably in a write-once manner, although the \u201cversioned file system\u201d as described herein may be used with any back-end data store.","As described above, the file system agent  is capable of completely recovering from the cloud (or other store) the state of the native file system and providing immediate file system access (once FSA metadata is recovered). The FSA can also recover to any point-in-time for the whole file system, a directory and all its contents, a single file, or a piece of a file. These and other advantages are provided by the \u201cversioned file system\u201d of this disclosure, as it now described in more detail below.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 5","b":["500","502","504"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6","FIG. 5"],"b":["502","602","600","604"]},"The second structured data representation may \u201cborrow\u201d unchanged parts of the first structured data representation. Thus, the second structured data representation does not need to construct or even consider parts of the tree that were not changed; it just points to the same c-nodes that the first structured data representation does.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 6","FIG. 7","FIG. 8"],"b":["700","804","808"]},"Moreover, as noted, it is possible but not required that a new version be created at the time of the actual change in the local file system; typically, the new version is created after a \u201csnapshot\u201d of the local file system is taken, and a number of change events may occur during a given snapshot period.  illustrates this approach. As seen in this drawing, an FSA instance preferably aggregates all of the changes to the local file system in two ways: delta frames , and reference frames . The delta frames  control the number (and size) of the objects that need to be stored in cloud storage. As noted above, preferably every local file system event is recorded by the FSA instance as a change event . As noted, new inodes, directories and files trigger corresponding new entities (created by FSA) in the cloud; however, preferably modifications to existing structures create change events that are aggregated by FSA into a single new entity, the delta frame . A delta frame  starts with a new root that represents the current state of the file system. Preferably, the FSA instance compiles the delta frame information such that each of the new entry points (i.e. any modifications to the previous version) to c-nodes, directories and files are represented as new versions of the data structures plus pointers to the old structures. To reconstruct the current state of a local file system, an FSA client only has to walk a tree for any version to see all the correct items in the tree. Reference frames  are also compiled by FSA and contain an aggregation of the previous reference frame plus all the intervening delta frames.","A given reference frame  may be thought of as an entire copy with no references to previous versions, while a delta frame  may be thought of as including pointers to older versions. In other words, a delta frame logically is a combination of a current version and one or more prior versions. Each frame (reference or delta) may be considered a complete file system from a tree-walk perspective. This means that a walk of the tree, by itself, is all that is required to restore the file system (or any portion thereof, including a single file) to its associated state or point-in-time (as represented by the tree).","Preferably, by pointing to the same c-node that a previous version did, each version is complete in and of itself. There is no need to regenerate a \u201cfull\u201d copy of a given version, as preferably each version is always full.","When it is desired to reconstruct the file system to a point in time (or, more generally, a given state), i.e., to perform a \u201crestore,\u201d it is only required to walk (use) a single structured data representation (a tree). In other words, one and only one VFS tree may be used to identify a prior state of the local file system. It is not required to jump across multiple trees for this purpose.","Frames preferably are stored in an event pipe . As will be seen, the event pipe is implemented in a structured data representation as a table of contents (TOC), although this is not a limitation. Preferably, this data structure is held both at the FSA instance and at CCS, as illustrated in . The event pipe (with its entry points into cloud storage) is then the primary means to access all files stored remotely. In particular, one of ordinary skill in the art will appreciate that this is a lightweight data structure that preferably contains only versions of root for the given volume. Although it is desired that CCS be highly available, preferably the \u201cwrites\u201d occur periodically in a transaction safe way as controlled by FSAs. The \u201creads\u201d are only necessary when an FSA copy has failed; therefore, CCS can be run using an ordinary (high-availability) database or file-based back-end. Preferably, the mix of delta and reference frames in the event pipe is chosen to balance storage and bandwidth utilization against a practical recovery time for FSA to create a new local file system instance. The composition of the event pipe can also be set according to a configurable policy. For instance, users may choose to keep only so many versions or versions dating back to a specific date.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 11","FIG. 12","FIG. 11"],"b":["1","2"]},"Restore and Prune","In a versioned cloud file system according to embodiment described in Ser. No. 12\/483,030, filed Jul. 11, 2009, the disclosure of which is incorporated herein by reference, a versioned file system (VFS) comprises a set of structured data representations such as XML documents and document fragments. Names are object references that typically are not parsed by the system. The handle names typically have no relation to the actual file names or content. The handle names in the XML preferably are prefixed with a length component. Also, for items other than the table of contents (TOC), the path and version elements in the XML are informative and need not be used by the system. The \u201cpath\u201d typically represents the originating path (in the local file system) when the item was last updated. The \u201cversion\u201d typically represents the version of root at the time the item was last updated. The table of contents (TOC) is a table at the head of every version; preferably, the TOC contains references to all versions.","Fast Restore","During a restore, preferably metadata is pulled back from the cloud first, so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if\/when the user goes to open the file. As a result, the entire file system (or any portion thereof, including a single file) can be restored to a previous time nearly instantaneously. The metadata appears first (and is stitched into the file system, where it remains available for immediate use), and then the cache gradually fills with the associated files as they are requested (and as they are streamed back from the cloud). From the user's perspective, however, it will appear as if the data is actually present (restored) once merely the metadata is returned.","As used herein, a \u201cfast\u201d restore is said to be performed if an object being restored exists within a \u201cborrow window\u201d of the version from which the system is restoring. During a fast restore, the file (or, more generally, file system portion) being restored is associated into a new place in the file system, which results in two identifiers (e.g., filenames) within the file system pointing to the same (single) object. As noted above, the metadata for the file (or file system portion) being restored is pulled back from the cloud first, so users can see the existence of needed files immediately. The remainder of the data is then pulled back from the cloud if\/when the user goes to open the file. This enables the file system portion to be restored to a previous time nearly instantaneously.","Typically, a restore is triggered by a user choosing to restore his\/her\/its data. In a representative embodiment, a user opens an interface (e.g., a web-based UI) and selects a file (data, time, snapshot, etc.) and selects a \u201crestore\u201d button. The system determines whether the restore will proceed on a \u201cfast\u201d basis based on a \u201cborrow window.\u201d By way of brief background, each version in the versioned file system is identified as a particular version (typically by a version number) and has associated therewith a \u201cborrow window,\u201d which preferably is an integer value. A most-recently created version is a \u201ccurrent\u201d version. In the context of a fast restore operation, the borrow window of interest is the borrow window of the older version from which an object is being restored. As used herein, this construct is sometimes referred to as the \u201crestore\u201d borrow window. Each individual version has its own associated borrow window, and for a set of versions, each borrow window may be different. A \u201cborrow window\u201d is sometimes referred to as a \u201cborrowing window\u201d or \u201cwindow.\u201d","If a user-initiated restore requires objects from a version outside the restore borrow window, the system performs a \u201cslow restore\u201d (with respect to versions outside the restore borrow window) to copy from an old version to the latest version as necessary. The word \u201cslow\u201d in the phrase \u201cslow restore\u201d does not necessarily have temporal implications; by definition, a \u201cslow restore\u201d is a state or status associated with a new file that just happens to have the same name and content as an older file. The metadata for a new file, like all new files, is available when the file is written.","The following describes additional details of the preferred \u201cfast restore\u201d functionality. As noted above, generally this function works by borrowing dependencies from one or more prior versions. Suppose it is desired to restore file \u201c\/A\/B\/C\u201d from version X to the current version Y at \u201c\/A\/B\/C.\u201d As noted above, a version has a \u201cborrow window\u201d value (typically an integer), which value preferably is advertised. The borrow window for a version may differ from the borrowing window from another version. The fast restore process begins by determining the \u201cversion created\u201d of all chunks of \u201c\/A\/B\/C\/\u201d in version X. For each chunk i in the manifest, the fast restore operation sets the \u201cversion created\u201d of i be V. Then, a fast restore is permitted if and only if, for all i, (Y\u2212V) is less than or equal to the borrowing window advertised by version V. If this condition is met (at an individual object level), the fast restore function proceeds as follows.","The manifest for \u201c\/A\/B\/C\u201d in version X is already present in the cloud. Its handle is obtained. Then, a new directory entry \u201cC\u201d in created in \u201c\/A\/B.\u201d This directory entry includes the same attributes as \u201c\/A\/B\/C\u201d from X (this is the borrowing), as well as the handle of the original file manifest that was just obtained. A next push then commits the modified directory \u201cA\/B\u201d to the cloud. As a result, the chunk objects and manifest of \u201cA\/B\/C\u201d are now referenced from different versions X and Y.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 13","b":["2","4","5","5","2","5"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIGS. 17-20","FIG. 17","FIG. 18","FIG. 19","FIG. 20"],"b":["1700","1702","1704","1706","1708","1710","1702","1706","1708","1802","1902","2002"]},"Pruning","In the versioned cloud file system, each file is represented by a manifest object, and a series of chunk objects. The manifest object comprises a listing of the chunk objects that make up the file and each entry in the manifest preferably comprises a handle, an offset, and chunk length. The entry also preferably identifies a number of the version in which the chunk was created. A directory in the versioned cloud file system is represented in a similar manner (as is a file), with the contents of the directory being a series of directory entries. A directory entry also comprises a name, as well as other attributes for the file\/directory, as well as the handle for the manifest that represents the contents of the file\/directory. As described, a version is defined as the tree of objects rooted at a particular root directory manifest. A file-system table of contents (TOC) contains the handle of a latest root directory manifest, as well as a list of all previously root directory manifests. For each table of contents entry, there is also preferably stored a timestamp, version number, and a borrow window (as noted above, preferably an unsigned integer). In the versioned cloud file system, each of the objects is a write-once object, and versions often share objects (file\/directory manifests, file\/directory chunks).","Pruning a version, as used herein, means an operation starting from the root directory manifest for the version and deleting all objects in the tree that are not referenced in another version. A difficulty in pruning is dealing with the situation where items from that version have been \u201cborrowed\u201d by other versions. Thus, for example, assume that a first version V is created upon a write of file A and a write of file B. Now, assume that a second version V is created upon a write file C and a delete of file B. If it is then desired to prune V, it is not possible to do so by merely deleting all the objects that V references because File A is still being used (i.e., borrowed) by version V. As noted above, such \u201csharing\u201d of objects is a characteristic of the versioned file system. As a consequence, any pruning algorithm must take into consideration two (2) types of objects: (i) objects in the pruned version that have been referenced from previous versions and thus should not be purged (sometimes referred to as \u201cborrowed\u201d objects); and (ii) objects created in the pruned version that are referenced (restored) in later versions (sometimes referred to as \u201clent\u201d objects). During pruning, any objects that are borrowed or lent are not purged.","As will be seen, during pruning, preferably the search for \u201clent\u201d objects is constrained by the borrow window of the version to be pruned, and preferably the search for \u201cborrowed\u201d objects is constrained by the size of the borrow window of the version in which the borrowed object was created. Constraining the searches in this manner provides computational and storage efficiencies, as the approach obviates scanning all versions backwards and forwards and limits the searching just to the versions within the above-described windows.","Thus, according to the teachings of this disclosure, a borrow window is associated to each of a set of versions in the versioned file system. A version is then pruned by deleting all objects in the tree associated with the version that, at the time of pruning: (i) are not being lent to any other version within the borrow window of the version being pruned, and (ii) are not referenced in any other version whose borrow window is sufficiently large enough such that an object in the version could have been restored from that other version. Another way of thinking about constraint (ii) with respect to a particular object in the tree associated with the version (being pruned) is that the object is deleted if it does not reside within the lending window of the version in which the object was created. If it is assumed that the borrow window of the version being pruned does not include the current version of the versioned file system, then the temporal limitation (\u201cat the time of pruning\u201d) is not necessary, as all of the objects associated with the version being pruned either are borrowed or not (and this fact cannot change during the time the pruning is taking place). Thus, pruning of versions that are still available for borrowing into the current version is not recommended and, in one embodiment, it not permitted at all.","The following describes in detail how a preferred pruning algorithm determines which objects in a tree are not referenced in another version.","Consider pruning a version X with a borrowing window Y. In one embodiment, for each manifest in X, the following characteristics are true: (i) the manifest could be referenced from a previous version only if the directory or file did not change since the immediately previous version (X\u22121); and (ii) the manifest could be referenced from a later version only if the directory or file did not change between X and an immediate next version (X+1). Thus, to determine whether a manifest is referenced in a version besides X, a check of all manifests in versions (X\u22121) and (X+1) suffices. If version (X\u22121) is already pruned, only the most recent version<X needs to be used; likewise, if version (X+1) is already pruned, only the most recent version>X needs to be used. In an alternative embodiment, manifests can be borrowed.","Likewise, with respect to chunks: the following characteristics are true: (i) for chunks created in X, the chunk may be referenced in any version V where X<V<X+Y; with respect to chunks created in previous versions: if the chunk is created in version V (V<X) and the borrowing window of version V is V, then, if version V has not been pruned, the chunk is still referenced by V, but if V has been pruned the chunk may be referenced by any version V^ where V<V^<V+V.","A pruning algorithm then proceeds as follows. Reference is made to the process flow shown in . At step , all chunks and manifests in version X are first enumerated by walking the entire tree of X starting from the root directory manifest for X. All manifests in version (X\u22121), or in a most recent version<X if version (X\u22121) has already been pruned, are enumerated at step . All manifests in version (X+1), or in a least recent version>X if version (X+1) has already been pruned, are enumerated at step . Steps  and  may be carried out in reverse order, or concurrently. At step , the prune algorithm calculates bounds for each chunk search as follows: define a minimum (min)=X, and define a maximum (max)=X+Y. For each chunk in the list of X, if version created for chunk is <min, min=version created for the chunk Likewise, for each chunk in the list of X, if version created+borrowing window for that version>max, max=version created+borrowing window for that version. Note that if the borrowing window is not allowed to change, then then max value will always be X+Y, although this is not a limitation. Then, at step , the routine searches for chunk references in the calculated search space (defined by these bounds). Step  enumerates chunks referenced in each version from min to max. Any chunk found in version not=X is then removed from the list of objects for X (if present). All objects remaining in the list for X are only referenced in X and may all be deleted. This completes the prune.","Thus, preferably the pruning algorithm takes into account not only a version back and a version forward, but also preferably all versions within a fast restore range (i.e., a configurable borrow window). This ensures that the pruning operation can be carried out efficiently and in a scalable, reliable manner. If the pruning operation were not constrained in this manner, the operation would be difficult to scale efficiently once the number of versions becomes large (due in part to the sharing of objects across versions).",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIGS. 15 and 16","FIG. 15","FIG. 16","FIG. 15"],"b":["4","4","4"]},"In a typical prune operation, the system may need to account for several borrow windows including some of differing values. For example, assume that are ten (10) versions: V . . . V, that the first five versions (V-V) each have a borrowing window of , and the next first versions (V-) each having a borrowing window of . Now, consider what happens when it is desired to prune version V. Because of the first five versions V-V have borrowing windows of , objects from V could be restored to any version as high as V, objects from V could be restored to any version as high as V, and so forth. Thus, the prune algorithm must search for references in these early versions, as well as more recent versions that may borrow the object. More generally, the prune algorithm deletes a version from the versioned filed system by deleting all objects in the tree associated with the version that are not referenced in any other version whose borrow window is sufficiently large such that an object in the version could be restored from that other version.","One of ordinary skill in the art will appreciate that the interface described herein provides a primary, local, but preferably non-resident application layer to interface the local file system to the data store. As has been described, the interface caches user data and file system metadata (organized in a unique manner) to the data store (e.g., one or more SSPs), preferably as a service. The metadata provides a level of indirection (from the data), and the VFS enables it to be stored separately from the data that it represents.","While the above describes a particular order of operations performed by certain embodiments of the disclosed subject matter, it should be understood that such order is exemplary, as alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic.","While the disclosed subject matter has been described in the context of a method or process, the subject matter also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including an optical disk, a CD-ROM, and a magnetic-optical disk, a read-only memory (ROM), a random access memory (RAM), a magnetic or optical card, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. A computer-readable medium having instructions stored thereon to perform the interface functions is tangible.","A given implementation of the disclosed subject matter is software written in a given programming language that runs on a server on an Intel-based hardware platform running an operating system such as Linux. As noted above, the interface may be implemented as well as a virtual machine or appliance, or in any other tangible manner.","While given components of the system have been described separately, one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions, program sequences, code portions, and the like."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
