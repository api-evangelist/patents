---
title: System and theme file format for creating visual styles
abstract: A method of specifying a visual style for a set of graphical components is provided for use on a computer system having a graphical operating environment. The method includes providing a schema file of available graphical components for which a visual style can be created. In the schema file, each component is defined by a unique class name. The method further includes selecting graphical components from the schema file that are desired to have a defined visual style. Properties are then assigned to these selected components according to the desired visual style, and pairs of selected graphical components and corresponding assigned properties for the defined visual style together are grouped together in a class data file that defines the overall appearance for the defined visual style.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694229&OS=07694229&RS=07694229
owner: Microsoft Corporation
number: 07694229
owner_city: Redmond
owner_country: US
publication_date: 20040506
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of U.S. application Ser. No. 09\/825,488 filed Apr. 3, 2001, now U.S. Pat. No. 6,753,885, entitled SYSTEM AND THEME FILE FORMAT FOR CREATING VISUAL STYLES, which claims the benefit of U.S. Provisional Application No. 60\/195,594, filed Apr. 6, 2000.","Not applicable.","The present invention relates to a computer system and, more particularly, to a method, system and file format that facilitates creating and changing the visual style of displayed graphical components, such as controls.","Computer users in both the business and home environment have become accustomed to using a computer with a graphical operating system. For example, many users operate computers having a Microsoft Corporation \u201cWINDOWS\u201d operating system thereon. Certain components of these graphical operating systems are known as \u201ccontrols.\u201d For example, a control may be an \u201cOK\u201d button, which is generally a rectangular button with \u201cOK\u201d written in it. By moving the cursor over the button and clicking on the mouse, a known operation will begin that is associated with the control. Many other controls exist, with examples including scroll bars, dialog boxes and sliders. Beyond controls, the graphical operating systems also draw, or render, other graphical components as needed on the display of the computer, such as the window frame, the minimize box and the close box, which may collectively be called \u201cnon-client\u201d components.","There are two general kinds of controls in WINDOWS: standard and custom. Standard controls are provided by the operating system. The code to create, draw and operate standard controls is contained in the common control library (DLL), or in USER.dll, both of which are standard libraries provided as a part of WINDOWS. Custom controls are all other controls. Custom controls may be created by the manufacturer of the operating system or by third parties. The code for custom controls is contained in a corresponding separate library (DLL) or within an application.","Currently, when a graphical user interface component, such as a control, is used by an application, the application requests that an instance of the component be created. Following this, the operating system transmits a generic message to the component, instructing the component to render itself. The application plays a role in routing the message from the main window to the targeted control, but the control code performs the drawing. The application uses application programming interfaces (API's) to create and interact with the control. An API serves as a software interface to be used by other programs, much as the keypad serves as an interface to a calculator. An API is a fundamental concept of high-level programming. In high-level programming, a program often does not execute tasks by itself. Instead, the program asks some other program to execute these tasks. For example, programs frequently delegate various tasks to the underlying operating system. Continuing with the above example, an application delegates the rendering of a control to the control's code.","In the existing environment, when a generic rendering message is received by a control to draw itself, the control will draw itself using its own drawing software code. In this prior art environment, the control knows what it is supposed to look like, how it is supposed to behave, and can effectuate such a display on the user interface of the computer. Thus, the application may delegate all aspects of visual rendering to the controls, avoiding the need to contain software code to support the visual rendering of the control within the host application itself.","By utilizing the standard controls defined and rendered by the operating system, all controls will have the same appearance, regardless of the application. Users of graphical operating systems can change only a limited number of characteristics of the controls. In the \u201cWINDOWS\u201d operating system, a user can change the color scheme used to display the various controls and components on the monitor. The user can also select one of a number of fonts to be used by the controls and components. The user can also specify nonclient sizes that will control the sizing of the non-client areas. Thus, the colors, fonts and sizes of the controls and components may be changed. However, the basic appearance of the controls and components is dictated by the rendering software code within the control library containing the particular graphical component or control. In the prior art environment, to change the appearance of the controls or graphical components, the rendering software code must be altered. For example, if it is desired to change the appearance of the \u201cOK\u201d button, the rendering software code within the operating system DLL file containing the button control must be altered and the DLL file reconstructed at the binary level. If it was desired to render the button as an oval, the software code would have to be changed accordingly. Such an approach makes it difficult, if not impossible, for a computer user and for software manufacturers, to easily alter the appearance of the controls and graphical components.","In order to enhance the user experience of the computer, it would be desirable for the user to have the ability to change the overall \u201clook and feel\u201d of the graphical display by changing the overall visual appearance or \u201ctheme\u201d of the various graphical components. In other words, it would be desirable if the user could change not only the color and font of the graphical components appearing on the monitor, but to change the appearance of those graphical components as well. For example, it would be desirable to be able to alter and direct the layout of the parts of a control, and to define the shape of a control or its parts. It would also be desirable to control all aspects of how a control or its parts are drawn. Because the controls and graphical components existing within the DLL file in the prior art environment are \u201chard coded\u201d with their own rendering software code, it is difficult and cumbersome to change the appearance of all of the controls and components. To do so would require recoding each of the controls to achieve the desired appearance. If multiple visual styles were required, they would each have to be predefined and each \u201chard coded\u201d into every control.","Using the current approach, if a user interface designer desires to have a new \u201clook\u201d for a set of graphical components, the designer must communicate this desire to a programmer. The programmer will then attempt to appropriately code the components to achieve the look desired by the designer. The designer will then review the look and communicate any needed changes to the programmer. This process continues, often with multiple iterations, until the designer is satisfied with the look achieved. It can be seen that the above process is time-consuming and is limited by the communication between the designer and the programmer. It would be desirable to allow the designer to be able to perform the tasks necessary to achieve a specific look and to be able to revise the look achieved until the designer is satisfied. This would eliminate the revision time between the designer and the programmer and would give the designer more flexibility in the look achieved.","Certain prior approaches exist that attempt to address the above situation. However, these solutions do not allow all of the controls and graphical components of the entire system to be changed. Instead, the prior art approaches address only limited portions of the set of displayed components. This allows the appearance of some controls and graphical components to be altered, leaving the remainder unaltered. Further, the prior art approaches may suffer from poor performance and may lack the desired level of stability.","Accordingly, there is a need for an effective system, method and file format that allows a designer to efficiently create a visual style for a set of controls and graphical components that addresses the above drawbacks and deficiencies. Such a system and file format should allow a programmer or custom control author the flexibility to create new options for the controls and components, such that the designer has additional options. Adding a new control type or a new custom property does not require a change to the theme manager, including the parser, loader and renderer code. A need also exists for a system and method that allows options within a \u201ctheme\u201d or visual style, such as an easy method for creating a different size theme or a different color theme. A need also exists for a method and system that provides a file format for a visual style that defines components in a hierarchical fashion, making the file easier to maintain.","Generally described, a method of creating a visual style for a set of graphical components is provided for use on a computer system having a graphical operating environment. The method includes providing a schema file that contains the available graphical components or controls for which a visual style can be created, along with their associated theming properties. Each component or control within the schema file is defined by a unique class name. The method further includes selecting controls from the schema file and assigning desired properties to the selected controls. The method further includes providing a second schema file which is an extension of the first schema file. This allows the schema file to be extensible so that authors of custom controls can easily extend the list of themed controls to include additional custom controls. The theme author can use the standard theme properties as well as defining custom properties.","The method includes providing another file, called a \u201cclass data\u201d file, which specifies the set of drawing, layout and measuring properties and values that are to be applied to each control or graphical component. In one embodiment, the properties are defined in a hierarchical fashion that can specify property value pairs on the global, control, part and state levels.","The method further includes providing yet another file, called a \u201cpackage\u201d file. The package file describes a set of related class data files that comprise a logical theme. This file includes documentation and user interface properties and values that describe the logical theme and each class data file within it. The package file also associates each class data file with a named \u201cColor Scheme\u201d and \u201cSize\u201d. In addition, it provides for the automatic generation of new color and size combinations at runtime, based on color and size transformation properties.","A computer readable medium is also provided that has stored thereon a data structure. The data structure is used to store a set of defined visual characteristics for a graphical component. The data structure includes a class control name object representative of one of a number of class control names defined within a schema file and a class control property object that defines a desired property for the class control name object. The class control property object is selected from one of a number of defined properties corresponding to the class control name within the schema file. The data structure can also include a part name object representative of one of a number of part names defined within the schema file corresponding to the class control name, and a part property object that defines a desired property for the part name object. The part property object is selected from one of a number of defined properties corresponding to the part name within the schema file. The data structure can also include a state name object representative of one of a number of state names defined within the schema file corresponding to the part name object, and a state property object that defines a desired property for the state name object. The state property object is selected from one of a number of defined properties corresponding to the state name within the schema file.","Additional advantages and novel features of the invention will be set forth in part in a description which follows, and in part will become apparent to those skilled in the art upon examination of the following, or may be learned by practice of the invention.","The present invention provides a system, method and file format that facilitates creating and changing the visual style of displayed graphical components, such as controls, within a graphical operating environment.  illustrates an example of a suitable computing system environment  on which the invention may be implemented. The computing system environment  is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment  be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment .","The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although many other internal components of the computer  are not shown, those of ordinary skill in the art will appreciate that such components and the interconnection are well known. Accordingly, additional details concerning the internal construction of the computer  need not be disclosed in connection with the present invention.","Those skilled in the art will understand that program modules such as the operating system , application programs  and data  are provided to the computer  via one of its memory storage devices, which may include ROM , RAM , hard disk drive , magnetic disk drive  or optical disk drive . Preferably, the hard disk drive  is used to store data  and programs, including the operating system  and application programs .","When the computer  is turned on or reset, the BIOS , which is stored in the ROM  instructs the processing unit  to load the operating system from the hard disk drive  into the RAM . Once the operating system  is loaded in RAM , the processing unit  executes the operating system code and causes the visual elements associated with the user interface of the operating system  to be displayed on the monitor . When a user opens an application program , the program code and relevant data are read from the hard disk drive  and stored in RAM .","In the present invention, operating system  is a graphical operating system having graphically displayed controls and components associated therewith. Controls include, but are not limited to, such things as scroll bars, push buttons and sliders. Other controls are within the scope of this invention, and are known to those of skill in the art. Other graphically displayed components are also within the scope of this invention. These components include, but are in no way limited to, non-client sections of the windows in the display, such as the frame surrounding an application display on the user interface, the minimize box, scrollbars and the close box.","An example display of graphical components having a variety of appearances is seen in . As shown in , the controls may take the form of an OK button , a Cancel button  and an Apply button . The present invention allows the appearance of the controls and other components to be visually changed to better suit the desire of the computer user. The invention allows the appearance of the controls to be altered beyond color and font selection. For example, the layout of the parts of a control can be defined as desired. For example, a scroll bar could be rendered with the up and down arrow buttons adjacent to each other at the bottom of the scroll bar, instead of the up arrow and the top and the down arrow at the bottom. Further, the shape of the control and its parts may be defined. As shown in , four different overall appearances are shown for each of the buttons ,  and . Each different appearance setting is coordinated and is called a \u201ctheme.\u201d Each theme is represented by one of the rows of buttons in . While only four themes are shown in , an unlimited variety of themes may be created for selection by the computer user. The theme is a collection or set of appearance characteristics relating to a particular subject or desired visual environment. As described below, the present invention allows the user of the computer to specify which of a number of predefined themes is to be applied to the controls and other components of the visual display. Moreover, the present invention allows new visual themes to be added to the system without the need of changing the software code of the controls and other graphical components. Still further, the present invention allows a software designer to compose a themed set of controls and components with a desired look without the need for changing the theme manager code. The invention also allows the visual specification to be done in a hierarchical manner, so that each state of each part of each control can be completely controlled without repeating the values of common properties in every instance, making the file easier for the designer to maintain.","Turning now to , the basic architecture used in the present invention is illustrated. The architecture is illustrated with example applications  that are open and running on the computer . As an application  is running it often requires a control or graphical component to be rendered, or displayed, on the monitor  of the computer . For example, with reference to , the display of an OK button  may be needed by the application on the monitor.","In the prior art environment, application  requests that an instance of button  be created. Following this, the operating system transmits a generic message to the control instructing it to draw itself. This request would be routed to the dynamic link library (DLL) that contained the particular control. As an example, the DLL in the WINDOWS operating environment would be called User32.dll or ComCtl32.dll (V), shown as  and , respectively, in . Libraries  and  exist within graphical operating system . In the prior art environment, libraries  and  are linked directly with applications . The defined control within libraries  and  contains the drawing code needed to render the control on the monitor. Therefore, to change the appearance of controls within libraries  and , the software drawing code must be changed for each control within libraries  and .","The present invention includes an additional DLL, shown as  in . In the WINDOWS operating environment, DLL  may be called ComCtl32.dll (V), as indicated in . This DLL is similar to library , in that it contains a number of predefined controls and graphical components that may be used by application . Broadly, DLL  contains a number of components that are to be graphically displayed. In library , however, the controls are defined differently, making them \u201ctheme aware.\u201d Rather than containing all of the software code needed to render the control, the controls are defined with certain basic information or values about the control, for example, the location, parts and states of the controls.","The location is the position on the user interface where the control is desired. Parts are the different items that make up the control. For example, OK button  has a background part and a text part. As another example, a scrollbar control has an elongated rectangular shaft part, a smaller thumb part that slides within the shaft part, and an arrow part at each end of the shaft part. The state of a control describes the current appearance and functional state. For example, a button can be active, pressed, hot (when the mouse is over the control), disabled or inactive.","As stated above, in the prior art environment, libraries  and  are linked directly with applications . In the present invention, libraries ,  and  are linked to the applications  through a fusion process . Fusion  enables the theming of controls in applications without needing to change the applications themselves to request the themable version of the controls. Fusion  enables each application  to load the specific version of the DLL ,  or  at run time through the use of a manifest. The fusion manifest specifies the environment in which an application will run, which allows multiples versions of a DLL to exist on one machine. Thus, fusion  will map the request for OK button  so that it is rendered as a themable element in DLL  instead of a non-themable element from DLL . This allows an existing application to be themed without changing code of the application. Fusion  also allows the new themable controls to be placed in a different DLL from the existing DLL, which simplifies implementation and minimizes compatibility risks.","Controls existing within DLL  are therefore used if they are available. As seen above, the controls within DLL  are defined as a series of parts and states. The controls within DLL  also contain the drawing code needed to render the controls if no themes are selected, as well as the theme-aware paths through the code. DLL  requests rendering or drawing services from a theme manager DLL . Theme manager  provides the requested rendering services and draws the control on the display at the indicated location, with the indicated parts in the indicated states.","Theme manager  contains a series of APIs that allow library  to interact and communicate with the theme manager. The APIs allow a control author to define a control within DLL  as a series of parts and states without the need for software rendering code. These APIs are generally divided into three types: drawing APIs , information APIs  and utility APIs .","Drawing APIs  are generally used to render and assist in the layout of the needed control parts and other components. Drawing APIs  are thus a collection of theme-aware drawing services. Each individual API within the set of drawing APIs  is used to perform a different drawing service. Generally, each API requires a specified part and state of the graphical component at hand.","Information APIs  are generally used to obtain information about the current defined appearance of the controls to allow controls to be individually customized. These information APIs  allow controls to be individually customized. In other words, these APIs are utilized in only certain instances and may be used to obtain information about specific controls. These information APIs are used to query theme manager  for defined theme information regarding specified properties of the theme. Each API  thus requests information, which is provided by theme manager . Utility APIs  are those APIs used by parts of the operating system other than the controls, to control theme selection. Utility APIs  include functions that can be used to enumerate an installed theme and load it.","As an example, if an OK button  was requested by an application , the control within DLL  would pass the part, state and location information to drawing APIs  through a function call, such as DrawThemeBackground, or DrawThemeText. As is more fully described below, this part and state information is matched with appearance characteristics and theme manager  draws the control on the user interface.","Drawing APIs  and information APIs  allow the author or creator of controls within DLL  to define the controls as a series of parts and states. The defined control is therefore abstracted from the rendering process of theme manager  and is also abstracted from the theme-defined appearance information or characteristics. Using APIs  and  the control author can create controls that are \u201ctheme-aware\u201d and that are equipped to communicate with theme manager . This communication involves passing basic information or values to theme manager  that allow the theme manager to render the desired control, having the needed parts in the desired states.","Theme manager  also contains the renderers needed to execute the drawing instructions. For example, a border-fill renderer  could be used that allows different color themes to be applied to the controls. As another example, a bitmap renderer  could be used that defines the control parts as images. Other examples of renderers include using a vector definition language, portable network graphics (PNG) files, or portable document format files (PDF). It should be understood that the present invention is not limited to a particular rendering technology. If a different renderer is desired or needed, the drawing code of theme manager  is revised to add the renderer to theme manager . The controls within DLL  are therefore isolated or abstracted from the rendering technology within theme manager .","The renderer within theme manager  renders the requested control according to an appearance theme that has been selected by the user of the computer. For example, appearance themes  and  are shown in . As shown, theme  may be a consumer theme and theme  may be a business theme. It should be understood, however, that other themes could be used and that the invention is in no way limited to the particular theme. For example, other themes could include a cartoon theme, a children's theme or a golf theme. As seen in , business theme  has been selected by the user, as represented by the solid line . Consumer theme  is available for selection, as represented by the broken line .","Each theme  and  has similar architecture. As seen in , a theme directory  is included with business theme . Directory  includes a series of image files . Image files  are the image files that will be used by the particular theme. In this case, image files  are the image files that will be used by business theme . Business theme  also includes a themes.ini file . File  is a text file and can be created in either ANSI or UNICODE character sets. File  specifies the available color schemes and sizes available for the theme. In the case of theme , file  specifies the available color schemes and sizes available for business theme . File  therefore represents all of the variations of the theme to which it applies, as is more fully described below.","File  is a directory of available class data files . In other words, the class data files  are packaged into file , as is described below. Class data files  are also .ini files as shown by the label \u201cDefault.ini.\u201d Class data files are used to list the theme data for a specific size and color. Each class data file is created by the theme author or designer from a schema file , labeled TMSchema.h in . Schema file  defines the controls, parts, states and available properties. Schema file  defines the properties that are recognized by the theme manager and gives them a unique identifier so they can be shared between the theme manager  and the control code at runtime. Schema file  is thus the defining vocabulary of available options that may be placed in a class data file . However, file  is extensible, as represented by the added material  in . When a theme-aware custom control is registered, its schema information is queried at theme parse time or load time and combined with the main schema information. This allows the theme properties of the control to appear in the main classdata file or in one registered with the custom control itself. It should be understood that the invention could be used with other schema approaches, such as a hardcoded list of controls and their parts.","As an example of the type of information within schema file , information about the button control may be present. For example, the following may be contained within the schema file :\n\n","This information informs the theme author of the available controls and the defined parts and states for those controls. This information, along with available properties for the controls, parts and states, informs the theme author as to what is available for composing class data file . When a theme-aware custom control is registered, its schema information is queried at theme parse time or load time and combined with the main schema information. This allows the theme properties of the control to appear in the main classdata file or in one registered with the custom control itself. Thus, schema file  and any mini-schema files  are basically master definition files that allow the theme author to create a defined theme appearance.","As best seen in  each class data file  has a specific file format that allows each class data file  to be easily and uniformly created. File  may contain defining sections , which may be either predefined sections  or created sections . Typical predefined sections  include a globals section  that is a list of property name settings that are inherited by each parent class section. If used, the globals section  must be the first section. The globals values will be overridden by more specific, created properties if they are present, as is more fully described below.","Another predefined section that may be specified is called \u201cSysmetrics,\u201d and is labeled  in . Sysmetrics section  allows the theme author to set the system metrics when the theme is loaded so that the look of non-themed applications can be made to more closely match the look of the theme. The Sysmetrics section  is therefore available to legacy applications that are not \u201ctheme aware.\u201d When a theme is created, the theme author can set system metrics values to appear as close to the theme as possible. System metrics such as the colors for controls and nonclient components, fonts, sizes, booleans and strings can be set using the Sysmetrics sections .","Created sections  are also referred to as class sections. Each class section can have an optional group name , a control name , an optional part name  and an optional state name . The group name  is the base name of an application, such as \u201cMICROSOFT MONEY.\u201d If the group name is specified, then the properties specified will be applied only to that application. The control name  is simply the class name as defined by the control author. For example, the control name might be \u201cbutton.\u201d The part name  is the child part name. For example, a part name for a button might be \u201cpushbutton.\u201d The child part name  must be defined as a part name for the control name  in the TMSchema.h file . Finally, the state name  is the state that the part might be in. For example, a state name  for the pushbutton part might be \u201cup.\u201d The state name  must be defined as a state name for its part  in the TMSchema.h file . In order to logically separate each of the above, the group name  is followed by ::, a period is placed between the control name  and the part name  and the state is placed in parentheses. As an example, a theme author may specify [MICROSOFT MONEY::button.pushbutton(up)]. The properties defined using this specification would apply only to the up state of the pushbutton part of the button in MICROSOFT MONEY applications. For both the predefined sections  and the created sections  properties are specified along with a corresponding value, as indicated at  in . The following table represents the basic property types and the corresponding value formats:",{"@attributes":{"id":"p-0062","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["PROPERTY",{}]},{"entry":["TYPE","VALUE FORMAT"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["String","Any text to the right of the \u201c=\u201d with no quotes."]},{"entry":["Int","A signed integer or hex number"]},{"entry":["Bool","On of the values: \u201ctrue\u201d or \u201cfalse.\u201d"]},{"entry":["Color","A space separated list of three numbers, corresponding to"]},{"entry":[{},"red, green and blue."]},{"entry":["Enum","A string value that gets matched to a declared enum."]},{"entry":["Margins","A comma separated list of four integers, with partnames"]},{"entry":[{},"\u201clw\u201d, \u201crw\u201d, \u201cth\u201d and \u201cbh\u201d."]},{"entry":["Filename","A relative path that gets fully qualified."]},{"entry":["Size","An integer followed by optional \u201ctwips,\u201d \u201cpixels,\u201d or"]},{"entry":[{},"\u201cpoints.\u201d"]},{"entry":["Position","A comma separated list of two integers with partnames \u201cx\u201d"]},{"entry":[{},"and \u201cy.\u201d"]},{"entry":["Rect","A comma separated list of four integers with partnames \u201cl\u201d,"]},{"entry":[{},"\u201ct\u201d, \u201cr\u201d, and \u201cb\u201d."]},{"entry":["Font","Family name, size and font flags."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each of the group name, control name, part name and state name behave in a hierarchical fashion. State names  inherit from their part name  or control name  and part names  inherit from their control names . The group name , control name , part name  and state name  contain, together with the inherited globals section , all of the property values needed to render the specified class of control. This hierarchy can best be seen in . As indicated at , it is first determined if properties are defined for the control, part and state. If so, they will be used. Similarly, it is next determined if properties are defined for the control and part, as indicated at . If so, the defined properties will be used. If not, it is then determined whether properties are defined for the control, as shown at . If so, the defined properties will be used. If not, the properties defined in the globals section  will be used, as indicated at .","The above file format for the class data files , along with the available vocabulary as defined in the schema file  can be used by the theme author to create a variety of class data files  without the need to go through a series of iterations with a programmer. As an example, a theme author may draft the following:\n\n","In this example, the properties defined for all buttons are \u201cfont\u201d and \u201cImageFile\u201d. The pushbutton part of the button overrides the \u201cfont\u201d property with its own value, adds a new \u201cTextColor\u201d property, and inherits the \u201cImageFile\u201d property from button. The defined properties for the button class will be applied to all buttons, but the specified properties for the pushbutton part will prevail over the specified properties for the button class.","Theme file , the \u201cpackage\u201d file, also consists of one or more sections. The sections within theme file  include a documentation section , a size section , a color scheme section  and a file section . Documentation section  is optional and may contain any property name. For example, documentation section may specify a name for the theme to be displayed on the user interface, such as \u201cbusiness theme.\u201d Size section  specifies the size names available, such as \u201cdefault size,\u201d \u201cvery small\u201d or \u201cvery large.\u201d","Color scheme section  is used to specify a simple color scheme name and an optional color scheme transformation associated with the color scheme name. For example, if only one color scheme is available, the color scheme name would likely be \u201cdefault color.\u201d Other color scheme names could be made available, as described below, and would be named as well. For example, a blue color scheme and a red color scheme could be listed in color scheme section. If a particular desired color scheme has not been created as a class data file, as more fully described below, the theme author can perform a color scheme transformation on an existing theme file. In the color scheme section, the theme author can transform an existing color scheme through use of \u201cFrom Color=\u201d and \u201cTo Color=\u201d commands along with available \u201cFrom Hue=\u201d and \u201cTo Hue=\u201d commands. The values specified after the \u201c=\u201d sign are values for red, green and blue, respectively. For example, if the theme author desired to change any color that is red to green and to change the hue of the color scheme, the theme author may specify in the color scheme section :\n\n","The size section  can operate similarly to color scheme section  as described above. As such, a size name can be associated with a specific class data file. Additionally, size transformations can be performed on a specified class data file in a manner like that described above for the color transformations.","File section  is used to specify a unique name for each of the class data files . Each class data file listed in the file section  will include the file name, a color scheme (from color scheme section , including transformations) for that file name, and the sizes (from the size section ) that the file will support. File section  is therefore a list of all possible colors and sizes available, including color transformations. The file section  is named \u201cfile.xxx\u201d where \u201cxxx\u201d is replaced with a unique name for the class data file. The file section  recognizes properties for a filename, color schemes and sizes. An example file section for the class data file named \u201cOne\u201d would be:\n\n","In this example, file section  corresponds to the Large class data file and supports the color schemes default, blue and red. The only size that the file supports is \u201cLarge.\u201d","Image files , theme file  (including packaged class data files ) are broadly grouped together to make up theme directory . Theme directory  and the schema file  are used to build the business theme file . The mini-schemas  are header files compiled into the custom control code, usually a .dll file. The mini-schemas  are not accessed until theme parse or load time, but are merged with the tmschema.h information in memory. Theme directory  thus contains a theme.ini file , one or more class data files  and all of the image files  used by the theme. The contents of theme directory  can be packaged into a DLL file by packthem tool . Packthem tool  processes the Themes.ini file  by parsing it against the schema file  for syntax errors and adding the .ini file to the package being built. Recognized properties from documentation section  are written to a package string table. Color scheme information from color scheme section  and size information from size section  is also written to a package string table. Each class data file  is also processed. As the class data file is processed, the file is parsed against the schema file  for syntax errors. Each class data file is also added to the package being built.","The DLL file produced by packthem tool  is business theme file . File  contains the theme data and this theme data is isolated from control library . This allows different themes to be created and selected without changing the controls defined within library . Thus, control authors can create and define controls independently of the appearance or theme data. File  is in binary format and is passed into a shared theme data file  when business theme  is selected by the computer user, as best seen in . File  is a shared memory map file that can be accessed by all processes. Thus, when a theme is selected by the computer user, theme manager  will read the information for a defined theme file, such as file , and will place that information in a binary format in file  where all running processes have access to the binary information.","As best seen in , a theme-switching control panel  is provided that is in communication with theme manager . Panel  cooperates with a user interface that displays the available themes from which the user can select. As shown in , control panel  would allow a user to select business theme  or consumer theme . The user would also be presented with available options created by the theme author within each of the class data files. For example, as is best seen in , the user interface may present a series of drop down menus corresponding to the visual style , the available color scheme  for that visual style and the available sizes  for that visual style. In the example seen in , the user can see that the business theme  is selected, but that consumer style  is available. For the selected business theme , the user can see that the theme author has created two color schemes, displayed as \u201cBLUE\u201d and \u201cRED.\u201d Finally, the user can see that the only size the theme author has made available is the default size.","If as has been discussed above, business theme  is selected and the user of the computer switches to select consumer theme , theme  will be loaded into shared memory map file  as binary data. Theme manager  also sends a message to each theme-aware control within DLL file  that the theme has changed. Each theme-aware control knows how to respond to this message.","Alternative embodiments of the present invention will become apparent to those skilled in the art to which it pertains upon review of the specification, including the drawing figures. Accordingly, the appended claims rather than the foregoing description define the scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING","p":["The present invention is described in detail below with reference to the attached drawing figures, wherein:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
