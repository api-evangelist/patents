---
title: Dynamic runtime range checking of different types on a register using upper and lower bound value registers for the register
abstract: Software defects (e.g., array access out of bounds, stack overflow, infinite loops, and data corruption) occur due to integer values falling outside their expected range. Because programming languages do not include range-checking instructions as part of their language, to detect software defects and ensure that the code runs smoothly, programmers generally use 1) runtime assertions and/or 2) sub-range data types. However, these techniques cause additional conditional branches, incur additional overhead, and decrease processor performance. Processors comprising a range checking hardware feature supported by machine instructions for runtime integer range checking can eliminate the conditional branches generated during runtime integer range checks. Programming language extensions for the range checking hardware can allow dynamic range bounds to be defined during runtime without decreasing the processor's performance. This can allow for easier programming and code that is easier to maintain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962729&OS=07962729&RS=07962729
owner: International Business Machines Corporation
number: 07962729
owner_city: Armonk
owner_country: US
publication_date: 20090105
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DESCRIPTION OF EMBODIMENT(S)"],"p":["1. Technical Field","Embodiments of the inventive subject matter generally relate to the field of computers, and more particularly, to runtime checking of dynamic sub-ranges.","2. Background","Software can suffer from the effects of integer variables assuming values outside their specified range. This often leads to data corruption resulting from a variety of errors including stack overflow, array access out of bounds, etc. Programmers use programming practices, which include the use of assertions and sub range data types, to combat these errors. However, these programming practices often lead to an increase in conditional statements, which in turn decreases processor performance. To avoid the decrease in processor performance, programmers disable range checking in performance-critical code.","Embodiments include a method comprising determining a target register. An instruction indicates operations to modify contents of the target register. A lower range bound value and an upper range bound value for the target register is determined. A set of one or more range bound registers indicate the upper range bound value and the lower range bound value. A value in the target register is determined to be invalid based on the lower range bound value and the upper range bound value. A range checking exception is generated, wherein the range checking exception indicates that the value in the target register violates any one of the lower and the upper range bound values.","The description that follows includes exemplary systems, methods, techniques, instruction sequences, and computer program products that embody techniques of the present inventive subject matter. However, it is understood that the described embodiments may be practiced without these specific details. Although examples refer to general purpose registers, techniques for range checking can be applied to any other types of registers, e.g., floating point registers, vector registers, etc. In some instances, well-known instruction instances, protocols, structures, and techniques have not been shown in detail in order not to obfuscate the description.","Software defects often occur due to integer values falling outside their expected range. Examples of such defects can include array access out of bounds, stack overflow, infinite loops, and data corruption. Programming languages do not include range-checking instructions as part of their language. Therefore, to detect software defects and ensure that the code runs smoothly, programmers generally use 1) runtime assertions (asserts) and\/or 2) sub-range data types.","Software programmers using mainstream programming languages (e.g., C, C++, Java, etc.) typically insert runtime assertions (asserts) at strategic places in code to perform range checking on integer variables. An assert is a Boolean expression that is assumed to be true while the assert executes within a program. If the assert evaluated returns a \u201cfalse\u201d value, the program throws an exception. Asserts can be placed at function entry (pre-condition check), at function exit (post-condition check), inside loops (loop invariant check), and in all functions that manipulate the structure (data invariant checks). Although asserts are a quick and effective way of detecting program errors, runtime range checking using asserts leads to additional conditional branches which can slow down processor pipeline performance. Asserts can be tedious to use, hard to maintain, incur additional overhead, and cause a decrease in performance. Introducing detailed range checking asserts also makes code maintenance harder because programmers have to remember to update all the asserts affected by their code changes. Therefore, programmers typically enable asserts for runtime range checking during development and remove (or disable) these asserts from production code, especially in performance-critical code.","Some programming languages (e.g., Ada, Pascal, etc.) alleviate the problems associated with using asserts by providing sub-range data types. Sub-range data types define a subset of values of a particular standard data type and can be used to detect when a variable's value falls outside a given boundary. By declaring an integer variable of a sub-range type, the programmer need not use asserts to check the range of the variable at runtime, since the compiler generates code for variable range checking. However, bounds on the sub-range data types are generally constants and are known at compile-time. Also, in using sub-range data types, the compiler generates runtime checking code and performs range checking every time the variable is modified (or type casted). Thus, depending on the number of variable modifications, the additional runtime range checking code generated may include more conditional branches as compared to using asserts. As a result, programmers may also choose to disable runtime range checking code generation in performance-critical production code. Thus, asserts and sub-range data types generate conditional branches for runtime range checking which impacts processor performance.","Processors comprising a range checking hardware feature supported by machine instructions for runtime integer range checking can help eliminate the conditional branches generated for runtime integer range checks. This can also enable runtime checking of integer ranges to be included in production code, without decreasing the processor's performance (e.g., processor pipeline throughput). Programming language extensions (i.e., support for higher level languages like C programming language), which allow dynamic range bounds to be defined during runtime, operating on the range checking hardware can allow for easier programming. This allows commonly used programming asserts to be replaced by declarative range constraints. These declarative range constraints would need to be placed only where integer variables (including fields of structures) are declared, and hence would be easier to maintain.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","104","102","108","106","110","110","108","102","108","104","106","102","104"]},"The central processing unit (CPU or processor)  comprises general purpose registers  coupled with a load unit . The CPU  also comprises a range checking unit  coupled with the load unit , an arithmetic and logic unit (ALU) , and range checking registers . The general purpose registers  are coupled with the arithmetic and logic unit . The load unit  carries out load instructions to load data into one or more of the general purpose registers  from a memory location in accordance with a decoded instruction. Data can be loaded from a memory location, another register, an immediate value, etc. Embodiments can also implement a single unit to carry out store instructions as well as load instructions (\u201cload\/store unit\u201d). The load\/store unit can store data (a value in the one or more general purpose registers , an immediate value, etc) into a memory location specified by a store instruction. The ALU  performs one or more arithmetic and\/or logic operations on the data and generates an output.","At stage A, a range checking unit  determines that a value in one of the general purpose registers  targeted by an instruction (\u201ctarget register\u201d) is modified by a machine instruction. In some instances, the target register may be initialized to \u201czero\u201d (or another pre-defined initialization value). Writing to an unused target register or a target register that has been initialized may also be considered as modifying the register value. Determining that a value in a general purpose register  is modified by a machine instruction comprises retrieving an output of ALU  and determining a target general purpose register  for the output of ALU  (e.g., by interfacing with an instruction decoder). Determining that a value in a general purpose register  is modified by a machine instruction can also comprise retrieving an output of the load unit  and determining a target general purpose register  for the output of the load unit .","At stage B, the range checking unit  determines if the value in the general purpose register  is within range bounds defined by range checking registers  for the general purpose register . The range checking unit  accesses the range checking registers , determines lower and upper bounds for the target register, and determines the type of range checking to be performed on the ALU's output. The range checking unit  determines whether the value to be stored in the target register of the general purpose registers  is within a specified range (as indicated by the range checking registers ).","At stage C, the range checking unit  throws a hardware exception if the value in the target register violates the range bounds. For example, the range checking unit  determines that the ALU output to be stored in the target register is not within the target register's specified range and throws a hardware exception. The range checking unit  may also direct the load unit  not to store the ALU output in the target register. Programmers can use special machine instructions, which operate on the range checking registers , to specify the range bounds for one or more general purpose registers . After the processor  executes the special machine instruction, it enables range checking for the one or more general purpose registers . Machine instructions can also allow the programmer to disable range checking for one or more general purpose registers  and to save or restore the range checking state associated with the general purpose registers (e.g., during context switches).","The hardware structure of the range checking registers  is further described using .  is an example conceptual diagram depicting range checking in a processor. An example processor  comprises thirty-two general purpose registers , range checking registers  associated with the general purpose registers , and a range checking unit . The thirty-two 64-bit general purpose registers  are R0 (), R1 (), R2 () . . . , R31 (). The range checking registers  comprise range bound registers , range status registers , and a range checking (RC) bit  in the processor's machine status register (MSR) .","At stage A, the range checking unit  detects modification of a value in a general purpose register R2 . For example, the range checking unit  determines that a result of an arithmetic operation has been stored in the general purpose register R2 .","At stage B, the range checking unit  determines that range checking is enabled by examining the RC bit . The RC bit  is a flag in the processor's machine status register (MSR)  that indicates whether range checking is enabled (RC=1) or disabled (RC=0) for all the thirty two general purpose registers .","At stage C, the range checking unit  determines upper and lower bounds of a range. The range bound registers  comprise registers that correspond to the general purpose register R2 . The upper bound is stored in range bound register R2_MIN . The lower bound is stored in range bound register R2_MAX . As shown in , for each of the 32 general purpose registers  (Rk=R0, R1, R2 . . . , R31), there is a pair of 64-bit range bound registers (Rk_min and Rk_max)  which hold the range bounds associated with register Rk. For example, R0_min  and R0_max  respectively hold the lower and upper bound values for register R0 .","At stage D, the range checking unit  determines a type of range checking based on the range status registers . The range status registers  comprise two 32-bit registers SRC  and TRC . The SRC register  indicates the \u201csignedness\u201d of the range bound registers  associated with each general purpose register . If a kbit of the SRC register  is 1, the processor uses signed arithmetic to perform range checking on register Rk . If the kbit of the SRC register  is 0, the processor uses unsigned arithmetic to perform range checking on register Rk .","The TRC register  indicates the type of range checking to be performed on each register. If the kbit of the TRC register  is 0, the processor  performs inclusive range checking on register Rk . Inclusive range checking implies that the value of register Rk  must be inside the range specified by the corresponding range bound registers  (i.e., Rk_min\u2266Rk\u2266Rk_max). Alternately, if the kbit of TRC register  is 1, the processor  performs exclusive range checking on register Rk . Exclusive range checking implies that the value of register Rk  must lie outside the bounds specified by the corresponding range bound registers  (i.e., Rk<Rk_min or Rk>Rk_max).","At stage E, the range checking unit  determines that the value written to the general purpose register R2 () violates the range and throws an exception. The value is out of range if it violates either of the upper or lower bound. In another embodiment, the range checking unit  can determine whether the value to be written into the general purpose register (e.g., output of an ALU, output of a load\/store unit, etc.) violates the range bounds. The range checking unit  can throw an exception if the value violates either of the lower or upper range bounds and direct the ALU (or the load\/store unit) to discard the illegal value. In some implementations, the range checking unit  may temporarily store the illegal value (e.g., in another register, in a memory location, etc.) to enable further debugging.","The initial states of the range checking registers , range status registers  and RC bit , when the processor  is first powered-on, can be as follows; 1) the RC bit  in the MSR  is set to zero, 2) all the lower bound registers (Rk_min) are set to zero, 3) all the upper bound registers (Rk_max) are set to their maximum value, and 4) the range status registers  (i.e., SRC and TRC) are set to zero. Thus, by default, range checking is disabled for all the general purpose registers  and unsigned inclusive range checking is selected for all the general purpose registers.","The range checking resisters are hidden from the programmer. This implies that programmers cannot manipulate the range checking registers other than by using a special instruction set. Once the general purpose register's range is set (using the special instruction set), instructions that attempts to modify the general purpose registers will trigger a register range check. If a value written or to be written in a general purpose register violates the range bounds, the range checking unit  triggers a hardware exception. Also, the range checking registers  and the logic of the range checking unit  eliminates the need for processor compare and branch instructions. Thus, when the range checking unit detects an operation that will write a value to a target register, the logic of the range checking unit performs range checking based on values in the range checking registers if range checking is enabled by a flag bit . This hardware-based range checking can be more efficient in terms of instruction cycles.","In some embodiments, the processor (e.g., processor  of ) can have load\/store architecture, such that all updates to variables in a program have to follow the sequence load into register from memory, modify register, store register value to memory. Therefore, performing range checking at the register level is sufficient to implement range checking on memory variables as well. In other embodiments, the range checking registers (e.g., range checking registers  of ) can also be used to detect stack overflow and underflow. For example, a runtime stack pointer can be stored in a general purpose register designated for that purpose (e.g., register R1 is the stack pointer in systems with an IBM-AIX operating system with PowerPC\u00ae architecture). When the operating system initializes the stack pointer register for a given thread (on a context switch), it can also specify the range bounds for the register (i.e., stack pointer range bounds). Thus, if the stack pointer register (R1) takes a value that is outside the range of addresses in the allocated stack, the range checking unit  will throw an exception.","Any one of these functionalities may be partially (or entirely) implemented in hardware, firmware, and\/or machine-readable media including instructions for performing the operations described herein. For example, the functionality may be implemented with an application specific integrated circuit, in logic implemented in the processing unit, in a co-processor on a peripheral device or card, etc. Further, realizations may include fewer or additional components not illustrated in  (e.g., video cards, audio cards, network interfaces, peripheral devices, etc.). For example, in some instances, the computer system  may include multiple processors, multiple cores, multiple external CPU's. Also, not shown in , the expansion bus  can be connected to peripheral devices including ports, I\/O controllers, busses, audio & video devices, etc. In some instances, components may be integrated or subdivided. In addition, embodiments may be embodied in an electrical, optical, acoustical or other form of propagated signal (e.g., carrier waves, infrared signals, digital signals, etc.), or wireline, wireless, or other communications medium.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["300","301"]},"At block , a range checking unit determines that a processor is executing an instruction that indicates an operation to modify a target register. In some implementations, an instruction decoder may interface with the range checking unit and indicate that a register is being modified. In other implementations, the range checking unit can monitor output from or input into one or more units (e.g., an arithmetic logic unit, a load unit, etc.) and determine whether a register is being modified. The flow continues at block .","At block , the range checking unit determines if range checking is enabled. Range checking may be enabled by a special instruction in the instruction set. The range checking unit can determine that range checking is enabled by examining a range checking (RC) bit in the processor's machine status register. If the RC bit (e.g., RC bit  of ) is set (RC=1), implying that range checking is enabled for all the registers, the flow continues at block . Otherwise, the flow ends without the range checking unit performing any range checking operations.","At block , the range checking unit selects range bound registers that correspond to the target register. In some implementations, a single range bound register may be associated with the target register. In load\/store processor architectures, data is first loaded into a target register, where it is modified, and then stored in memory. This enables the range checking unit to use the range checking registers to determine whether the data held in the target register is a valid value, before storing the data in memory. In some embodiments, the range checking unit may examine the data before storing it in the general purpose register (e.g., at the output of the ALU, at the output of the load unit, etc). The flow continues at block .","At block , the range checking unit determines range bounds for the target register based on the values in the selected range bound registers. Each register has two hidden range bound registers associated with it\u2014one to hold the lower bound on the register's value and the other to hold the upper bound on the register's value. In some implementations, the target register may have a single hidden extended range bound register associated with it. The extended range bound register may hold both the lower bound and the upper bound on the target register's value. For example, a single 64-bit range bound register may be used instead of two 32-bit range bound registers. The 32 least significant bits of the 64-bit range bound register may hold the lower bound while the 32 most significant bits may hold the upper bound on the target register's value. After the range checking unit determines the upper and lower range bounds for the target register, the flow continues at block .","At block , the range checking unit determines the type of range checking to be performed on the target register based on values in the range status registers. The range checking registers include two 32-bit status registers, SRC and TRC. Assuming that the kregister is modified by the instruction, the range checking unit accesses the kbit in the SRC register to determine whether signed or unsigned arithmetic is to be used for range checking. Likewise, the range checking unit accesses the kbit in the TRC register to determine whether inclusive (register values within the range bounds) or exclusive (register values outside the range bounds) range checking should be performed. The flow continues at block .","At block , the range checking unit determines whether the value to be stored in the target register violates the range bounds based on the type of range checking being performed. When the range checking unit encounters an operation that attempts to modify the value of the target register, the range checking unit checks for a violation of the register's range bounds. In some implementations, after an arithmetic and logic unit (ALU) performs its computations and determines an output value to be stored in the target register, the range checking unit may determine whether the ALU output value falls within the register's range bounds. In another implementation, a load unit may trigger the range checking unit every time it (the load unit) tries to load a value into the target register. The range checking unit may then determine whether the value to be loaded into the target register is valid. In another implementation, the load unit may interface with the range checking unit, before storing a value in the target register, to determine if the value to be loaded into the target register is a valid value. In some implementations, the range checking unit may be triggered after the value is stored in the target register. If the range checking unit determines that the value to be stored in the determined target register violates the range bounds, the flow continues at block . Otherwise, the flow continues at block .","At block , the range checking unit throws a hardware range exception to indicate an illegal register value. The range checking unit may also direct a load unit to not store the illegal value in the target register. In some instances, the operating system (OS) can generate a new signal to indicate a range exception (SIGRANGE). The application's signal handler can take the necessary steps to catch the signal and handle the error (e.g., restart the application, modify the register value, etc). If the application does not have a signal handler, the application may terminate. If the range violation occurs in the kernel code, the kernel can catch the hardware exception or can cause the program to crash initiating a core dump. In some implementations, to enable better debugging, the range checking unit may store the illegal register value in a temporary memory location or may retain the illegal register value in the target register. After the range checking unit throws a hardware range exception, the flow ends.","At block , the range checking unit directs the load unit to store the valid value in the target register. In load store processor architectures, the valid register value can also be stored in a suitable memory location. Performing range checking at the register level ensures that valid values within the specified range are stored into memory as well. From block , the flow ends.","A RANGE machine instruction that sets the current range checking parameters for a given general purpose register can be added to an instruction set. In other words, this instruction sets range bound registers (Rk_min, Rk_max) associated with a register Rk, according to the specified range. Also, depending on the specified operands, the instruction turns on or off the kbit in the SRC  and TRC  registers. Once range checking is enabled for a register, and if the RC bit  of the MSR register  is on (RC=1), any subsequent instruction that modifies the general purpose register will trigger a range checking operation. Range checking remains in effect for the specified general purpose register until the processor executes another RANGE instruction or a range-clear (RNGCLEAR) instruction for the specified general purpose register.","The syntax for the RANGE instruction is:",{"@attributes":{"id":"p-0043","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["RANGE <signedness bit>, <range type bit>, <Rdest>, <Rlow>, <Rhigh>\n\nwhere,\n","<signedness bit> specifies if signed (1) or unsigned (0) arithmetic will be used. This operand is used to set the corresponding bit in the SRC register (according to the register specified for <Rdest>)","<range type bit> specifies if the range is inclusive (0) or exclusive (1). This operand is used to set the corresponding bit in the TRC register (according to the register specified for <Rdest>)","<Rdest> indicates the target register, Rk, for which range bounds are being set.","<Rlow> indicates the register that contains the lower bound of the range. This operand is used to set the corresponding Rk_min register.","<Rhigh> indicates the register that contains the upper bound of the range. This operand is used to set the corresponding Rk_max register."]}},"For example, the machine code to set range checking for general purpose register R1, so that R1 is within the range 0 to 65535, using unsigned arithmetic and inclusive range checking is,",{"@attributes":{"id":"p-0045","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LI R5, 0","(Value in R5 = 0)"]},{"entry":["LI R6, 0xffff","(Value in R5 = 65535)"]},{"entry":["RANGE 0, 0, R1, R5, R6","(Setting range checking for R1 with specified"]},{"entry":[{},"conditions)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0046","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LI R3, \u22121","(Value in R3 = \u22121)"]},{"entry":["LI R4, 1","(Value in R4 = 1)"]},{"entry":["RANGE 1, 1, R3, R3, R4","(Setting range checking for R3 with specified"]},{"entry":[{},"conditions)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In addition to the RANGE machine instruction there are three other machine instructions that operate on the hidden range bound registers\u2014RNGCLEAR, RNGSAVE, and RNGRESTORE. The following discussion will describe each of these instructions in greater detail.","The RNGCLEAR instruction clears the current range checking parameters for a specified general purpose register . In other words, using the RNGCLEAR instruction resets the range bound registers  (Rk_min, Rk_max) associated with the specified general purpose register (i.e., Rk), to (0x0000000000000000, 0xffffffffffffffff). This instruction also turns off the kbit in the SRC and TRC registers (i.e., kbit=0).","The syntax for this instruction is:",{"@attributes":{"id":"p-0049","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"RNGCLEAR <Rk>\n\nwhere <Rk> indicates the target register, Rk, for which range checking is being disabled. For example, the instruction to disable range checking for general purpose register R3 is, RNGCLEAR R3.\n"}},"The RNGSAVE instruction saves the range checking state for all general purpose registers, in memory, at a specified address. In other words, this instruction stores, in memory, the values in the range bound registers (Rk_min, Rk_max) for all registers Rk (k: 0 . . . 31) and the values in the range status registers (i.e., SRC and TRC).","The syntax for this instruction is RNGSAVE <reg>,","where; <reg> is a general purpose register that contains the memory address where the range checking registers are to be saved.","For example, the instruction to save the contents of the hidden range checking registers at memory location specified by general purpose register R3 is, RNGSAVE R3.","The layout in memory of the saved range-checking registers is described by the following C structure, where values of the range bound registers and range status registers, for each of the thirty two general purpose registers, are stored contiguously.",{"@attributes":{"id":"p-0052","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct range_checking_regs"]},{"entry":[{},"{"]},{"entry":[{},"uint64_t rc_r0_min;"]},{"entry":[{},"uint64_t rc_r0_max;"]},{"entry":[{},"..."]},{"entry":[{},"uint64_t rc_r31_min;"]},{"entry":[{},"uint64_t rc_r31_max;"]},{"entry":[{},"uint32_t rc_src;"]},{"entry":[{},"uint32_t rc_trc;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The RNGRESTORE instruction restores the range-checking state for all general purpose registers, which was previously saved in memory, using the RNGSAVE instruction. In other words, this instruction restores, from memory, the values in the range bound registers and the range status registers from the address specified in a register operand.","The syntax for this instruction is RNGRESTORE <reg>,","where; <reg> is a general purpose register that contains the memory address where the range checking registers are to be restored from.","For example, the instruction to restore the contents of the hidden range checking registers from the memory location specified by general purpose register R3 is, RNGRESTORE R3.","In some embodiments, the processor's calling conventions may dictate that range settings may not be preserved across function calls. In some instances, compilers can automatically generate code to save range settings before function calls and restore the range settings after control is passed back to the calling function. In a multi-processor environment, a context switching routine (e.g., switching between threads) can use the RNGSAVE and RNGRESTORE instructions to save and restore range checking states (i.e., range bounds and range status values) as part of the thread's context. In some embodiments, interrupt handlers may also be modified to disable range checking on entry (e.g., by turning off the RC bit in the MSR) to prevent infinite recursion while handling range checking exceptions.","Software language extensions can be used to exploit the hardware-based range checking features from software written in high-level languages. The software language extensions (e.g., pragmas) can provide a mechanism to specify the range bounds associated with an integer variable, an integer typedef, or an integer field of a structure. For example, in C\/C++, ranges can be specified using one of the pragmas in front of the corresponding variable typedef or field declaration. The range bounds can be constants (e.g., similar to sub-range data types) or variables in the scope of the variable being declared (e.g., range bounds on one variable can depend on one or more other variables). When a compiler encounters a range checking pragma, it generates the corresponding machine level instructions based on the pragma. The machine level instructions enable range checking, load minimum and maximum bounds into range bound registers and set status bits corresponding to \u201csignedness\u201d and type of range checking (i.e., inclusive or exclusive). Pragmas assist programmers in enabling and applying range checking without using asserts, as the compiler generates code to use the range checking hardware based on the programmer-specified pragmas. Also, instead of generating explicit compare and branch instructions to implement runtime range checking, the compiler can generate range checking machine instructions (e.g., RANGE, RNGSAVE, etc.) to specify the ranges of the registers allocated to hold values of the variables, store and restore range bounds, etc.",{"@attributes":{"id":"p-0056","num":"0060"},"figref":["FIG. 4","FIG. 4"],"b":["402","403","404","402","404","406","404","402","402"]},"The \u201cin_range\u201d pragma  specifies an unsigned inclusive range. The syntax for the pragma  is:",{"@attributes":{"id":"p-0058","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#pragma in_range(<lower bound>, <upper bound>)"]},{"entry":[{},"<variable or typedef declaration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":"<lower bound>, <upper bound> can be signed integer expressions, using constants or variables in scope where the pragma is used."}},"In C code , the programmer defines a lower bound (min_times) and upper bound (max_times) on a variable's values. The \u201cin_range\u201d pragma  defines the lower and upper bound values of all variables declared with the data type \u201cNUM_TIMES_T\u201d. Variable of type \u201cNUM_TIMES_T\u201d will be checked to ensure that values of the variables fall within the specified lower and upper bounds. The compiler determines that a variable \u201cNUM1\u201d of type \u201cNUM_TIMES_T\u201d in C code  is to be stored in general purpose register R1. Since the type \u201cNUM_TIMES_T\u201d is associated with the pragma , the compiler translates the pragma  instruction into the corresponding RANGE machine instruction in Power PC assembly code  thus enforcing range checking on register R1. As shown in Power PC assembly code , the compiler generates a range definition instruction, which indicates that the value of register R1  (i.e., variable \u201cNUM1\u201d) should be between 1 and 10 and that inclusive unsigned range checking should be performed on register R1 . The processor stores the range bounds (1 and 10) from registers R5 () and R6 () respectively in the appropriate lower bound range register  and upper bound range register .","A loop is defined in the C code . The loop is to be executed four times. Each time the loop is executed variable \u201cNUM1\u201d is incremented by 2. The corresponding Power PC assembly code  includes instructions to load the value of variable \u201cNUM1\u201d into register R1  and initialize the loop counter (CTR). In the loop, an arithmetic and logic unit in the processor adds two to the previous value of R1 at each loop iteration (i.e., R1=R1+2), decrements the value in CTR (i.e., CTR=CTR\u22121) and returns to the beginning of the loop until the value in CTR reaches zero. The range checking unit (e.g., the range checking unit  of ) performs a range check every time the value of the variable \u201cNUM1\u201d, and hence the value of register R1 , is modified (i.e., when \u201cNUM1\u201d is initialized with value 5 and every time \u201cNUM1\u201d is modified in the loop). The values stored in the register R1  are shown at different times during the program's execution. The value in register R1  at the beginning of the loop is 5. As the control passes into the loop, the processor modifies the value of R1 . Because R1=7 (I=4) and R1=9 (I=3) fall within the range bounds (1\u2266R1\u226610), the program continues to execute the code without any errors. When I=2, the value of R1  is 11. This value of R1  falls outside the range bounds (1\u2266R1\u226610). Therefore, the range checking unit throws an exception indicating that the register value is out of bounds. As explained earlier, in some instances, the program may include code to catch and handle this exception, while in other instances, the program may terminate after the exception is thrown.","The compiler may generate and execute the RANGE instruction for a target register only once irrespective of the number of operations performed on the target register. In instances where the program has more than one variable to be range checked, the compiler can generate a set of RANGE instructions at the beginning of the assembly code that map each of the variables to various general purpose registers, set the range bound registers, configure the range status registers, and enable range checking.","In addition to the \u201cin_range\u201d pragma for specifying an unsigned exclusive range, the C language extensions also include three other pragmas including an \u201cin_signed_range\u201d pragma for specifying a signed inclusive range, an \u201cout_range\u201d pragma for specifying an unsigned exclusive range, and an \u201cout_signed_range\u201d pragma for specifying a signed exclusive range. The following discussion will describe each of these pragmas along with their syntax and an example of the pragma's usage.","The \u201cin_signed_range\u201d pragma specifies a signed inclusive range. The syntax for this pragma is:",{"@attributes":{"id":"p-0064","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#pragma in_signed_range(<lower bound>, <upper bound>)"]},{"entry":[{},"<variable or typedef declaration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"<lower bound>, <upper bound> can be signed integer expressions, using constants or variables in scope where the pragma is used.\n\nFor example, C program code to specify that all variables with the typedef \u201cdelta_t\u201d must lie within the range \u22121 to 1 and that inclusive range checking should be performed using signed arithmetic is,\n"}},{"@attributes":{"id":"p-0065","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define MIN_DELTA \u22121"},{"entry":"#define MAX_DELTA 1"},{"entry":"#pragma in_signed_range(MIN_DELTA, MAX_DELTA)"},{"entry":"typedef int8_t delta_t; \u2003\u2003\/* valid values are within the range \u22121 ... 1 *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The \u201cout_range\u201d pragma specifies an unsigned exclusive range. The syntax for this pragma is:",{"@attributes":{"id":"p-0067","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#pragma out_range(<lower bound>, <upper bound>)"]},{"entry":[{},"<variable or typedef declaration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{},{}]},{"@attributes":{"id":"p-0068","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define MAX_FORBIDDEN_ADDR 4095"]},{"entry":[{},"#pragma out_range(0, MAX_FORBIDDEN_ADDR)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef uint8_t num_times_t;","\/* valid values are outside"]},{"entry":[{},{},"the range 0 ... 4095 *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The \u201cout_signed_range\u201d pragma specifies a signed exclusive range. The syntax for this pragma is",{"@attributes":{"id":"p-0070","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#pragma out_signed_range(<lower bound>, <upper bound>)"]},{"entry":[{},"<variable or typedef declaration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":"<lower bound>, <upper bound> can be signed integer expressions, using constants or variables in scope where the pragma is used.\n\nFor example, the C code to specify that all variables with the typedef \u201cdelta_t\u201d must lie outside the range \u22125 to 5 and that range checking should be performed using signed arithmetic is,\n"}},{"@attributes":{"id":"p-0071","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define MIN_DELTA \u22125"},{"entry":"#define MAX_DELTA 5"},{"entry":"#pragma out_signed_range(MIN_DELTA, MAX_DELTA)"},{"entry":"typedef int8_t delta_t; \u2003\/* valid values are outside the range \u22125 ... 5 *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Embodiments may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem\u201d. Furthermore, embodiments of the inventive subject matter may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium. The described embodiments may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic device(s)) to perform a process according to embodiments, whether presently described or not, since every conceivable variation is not enumerated herein. A machine-readable medium includes any mechanism for storing or transmitting information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The machine-readable medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; or other types of medium suitable for storing electronic instructions.","Computer program code for carrying out operations of the embodiments may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on a user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN), a personal area network (PAN), or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","While the embodiments are described with reference to various implementations and exploitations, it will be understood that these embodiments are illustrative and that the scope of the inventive subject matter is not limited to them. In general, techniques for runtime checking of dynamic sub-ranges of integers are described herein and may be implemented with facilities consistent with any hardware system or hardware systems. Many variations, modifications, additions, and improvements are possible.","Plural instances may be provided for components, operations, or structures described herein as a single instance. Finally, boundaries between various components, operations, and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the inventive subject matter. In general, structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the inventive subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present embodiments may be better understood, and numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
