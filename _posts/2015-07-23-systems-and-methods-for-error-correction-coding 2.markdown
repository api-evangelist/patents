---
title: Systems and methods for error correction coding
abstract: Described are methods, systems, and apparatus, including computer program products for error correction coding and decoding procedures for data storage or transfer. A plurality of data blocks is received. A plurality of checksum blocks are generated by multiplying the plurality of data blocks by a coding matrix, where the coding matrix comprises values of at least one basic interpolation polynomial and the multiplying is according to a finite field arithmetic for a finite field comprising all possible values of the plurality of data blocks and the plurality of coding blocks. The plurality of data blocks and the plurality of checksum blocks are stored in a data storage medium.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09647690&OS=09647690&RS=09647690
owner: Raidix Corporation
number: 09647690
owner_city: St. Petersburg
owner_country: RU
publication_date: 20150723
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["REFERENCE TO RELATED APPLICATION","FIELD OF THE TECHNOLOGY","BACKGROUND","SUMMARY OF THE TECHNOLOGY","DETAILED DESCRIPTION","Galois Fields and Reed-Solomon Codes","Coding Using Vandermonde Matrix and Interpolation Polynomials","Decoding"],"p":["This application claims the benefit of priority of U.S. Patent Application No. 62\/028,056 filed Jul. 23, 2014, entitled \u201cSystems and Methods for Error Correcting Coding,\u201d the entirety of which is incorporated herein by reference.","The present technology relates generally to error correction coding, and more specifically, to error correction coding and decoding for data storage or transfer.","Data can be corrupted when stored to and\/or read from a storage device, or transmitted over an unreliable channel. For example, data can become corrupted when it is stored to a magnetic hard drive. Without a mechanism to detect when data has been corrupted and\/or correct the corruption, the data can be unusable. Error correction coding, in some applications, can be used to facilitate reliable storage and retrieval of data, and\/or delivery of data. In general, the concept behind error correction coding is that by adding redundancy to the data, the redundancy can permit correcting corruption in the data. Some approaches to error correction coding can be referred to as systematic. A systematic error correction coding approach generally involves providing the data and some amount of check bits, parity bits, error correction codes, or other data generated based on the data to facilitate recovery from corruption.","Accordingly, there is a need for efficient approaches to systematically encoding data to facilitate error recovery, and for efficiently decoding and recovering data. The present technology relates to techniques for systematically encoding data that, in some embodiments, can provide computational efficiency gains over existing techniques. For example, the matrix-based techniques of some embodiments of the present technology can facilitate recovery of failure errors and silent data corruption errors without requiring computationally-expensive approaches using polynomials over a finite field.","In one aspect, there is a computer-implemented method for systematically coding a plurality of data blocks for error detection and correction. The method includes receiving, by a computer system, the plurality of data blocks. The method includes generating, by the computer system, a plurality of checksum blocks by multiplying the plurality of data blocks by a coding matrix, wherein the coding matrix includes values of at least one basic interpolation polynomial, the multiplying according to a finite field arithmetic for a finite field including all possible values of the plurality of data blocks and the plurality of coding blocks. The method includes storing, by the computer system, the plurality of data blocks and the plurality of checksum blocks in a data storage medium.","In some embodiments, the coding matrix consists of a plurality of values of a plurality of basic interpolation polynomials computed for a sequence of powers of a primitive element of the finite field. In some embodiments, the method includes constructing the coding matrix of the form:",{"@attributes":{"id":"p-0008","num":"0007"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]}]}}}}},"br":{},"sub":["1","m"],"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00001","he":"2.79mm","wi":"1.44mm","file":"US09647690-20170509-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00002","he":"2.79mm","wi":"1.44mm","file":"US09647690-20170509-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]},"In some embodiments, the method includes generating, by the computer system, the coding matrix in response to receiving the plurality of data blocks. In some embodiments, the method includes receiving, by the computer system, a second plurality of data blocks. In some embodiments, the method includes generating, by the computer system, a second coding matrix in response to receiving the plurality of data blocks. In some embodiments, the method includes generating, by the computer system, a second plurality of checksum blocks by multiplying the second plurality of data blocks by the second coding matrix. In some embodiments, the method includes storing, by the computer system, the second plurality of data blocks and the second plurality of checksum blocks in the data storage medium.","In some embodiments, the method includes receiving, by the computer system, a second plurality of data blocks. In some embodiments, the method includes generating, by the computer system, a second plurality of checksum blocks by multiplying the second plurality of data blocks by the coding matrix. In some embodiments, the method includes storing, by the computer system, the second plurality of data blocks and the second plurality of checksum blocks in the data storage medium.","In another aspect, there is a computer-implemented method for decoding a plurality of code blocks for error detection and correction. The method includes receiving, by a computer system, the plurality of code blocks, the plurality of code blocks including a plurality of data blocks and a plurality of checksum blocks. The method includes detecting, by the computer system, a failure error at a failure location within the plurality of code blocks. The method includes detecting, by the computer system, a silent data corruption (SDC) error at an SDC location within the plurality of blocks, detecting the SDC error including: calculating a syndrome matrix from a first portion of the plurality of code blocks not containing the failure error; and determining the SDC location of the SDC error in the plurality of blocks based on the syndrome matrix. The method includes constructing, by the computer system, a recovery matrix using the failure location and the SDC location. The method includes recovering, by the computer system, a first block containing the failure error and a second block containing the SDC error by multiplying the recovery matrix with a second portion of the plurality of code blocks not containing the failure error and the SDC error, wherein the recovery matrix includes values of at least one basic interpolation polynomial, the multiplying according to a finite field arithmetic for a finite field including all possible values of the plurality of data blocks and the plurality of coding blocks.","In some embodiments, determining the SDC location of the SDC error in the plurality of blocks based on the syndrome matrix includes constructing an error locator polynomial based on the syndrome matrix. In some embodiments, the error locator polynomial includes a plurality of coefficients, the method further including determining the coefficients of the error locator polynomial using a Berlekamp-Massey algorithm. In some embodiments, determining the SDC location of the SDC error in the plurality of blocks based on the syndrome matrix includes determining the SDC location based on a root of the error locator polynomial. In some embodiments, the recovery matrix consists of a plurality of values of a plurality of interpolation polynomials.","In some embodiments, constructing the recovery matrix using the failure location and the SDC location the recovery matrix further includes constructing the recovery matrix of the form:\n\n()], 1, . . . ,0, . . . ,1}\\{}\n\nwhere the plurality of data blocks consists of n data blocks and the plurality of checksum blocks consists of m checksum blocks; where N=m+n; where a is a primitive element of the finite field; where {tilde over (W)}(), . . . , {tilde over (W)}() are basic interpolation polynomials; where l is a number of failure errors and SDC errors; and where {k, . . . , k} include the failure location and the SDC location.\n","In another aspect, there is a data storage system. The data storage system includes one or more storage devices. The data storage system includes a code block generation module, wherein the code block generation module is configured, in response to receiving a first plurality of data blocks, to generate a first plurality of checksum blocks by multiplying the first plurality of data blocks by a coding matrix, wherein the coding matrix includes values of at least one basic interpolation polynomial, the multiplying according to a finite field arithmetic for a finite field including all possible values of the first plurality of data blocks and the first plurality of coding block; and store the first plurality of data blocks and the first plurality of checksum blocks in one or more storage devices of the one or more storage devices. The data storage system includes an error recovery module, wherein the error recovery module is configured to receive a plurality of code blocks, the plurality of code blocks including a second plurality of data blocks and a second plurality of checksum blocks, from the one or more storage devices; and detect a failure error at a failure location within the plurality of code blocks. The error recovery module is configured to detect an SDC error at an SDC location within the plurality of code blocks by calculating a syndrome matrix from a first portion of the plurality of code blocks not containing the failure error; and determining the SDC location of the SDC error in the plurality of code blocks based on the syndrome matrix. The error recovery module is configured to construct a recovery matrix using the failure location and the SDC location; and recover a first block containing the failure error and a second block containing the SDC error by multiplying the recovery matrix with a second portion of the plurality of code blocks not containing the failure error and the SDC error, wherein the recovery matrix includes values of at least one basic interpolation polynomial, the multiplying according to the finite field arithmetic for the finite field.","In some embodiments, the coding matrix consists of a plurality of values of a plurality of basic interpolation polynomials computed for a sequence of powers of a primitive element of the finite field. In some embodiments, the code block generation module is further configured to construct the coding matrix of the form:",{"@attributes":{"id":"p-0016","num":"0015"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]}]}}}}},"br":{},"sub":["1","m"],"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00005","he":"2.79mm","wi":"1.44mm","file":"US09647690-20170509-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00006","he":"2.79mm","wi":"1.44mm","file":"US09647690-20170509-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]},"In some embodiments, the code block generation module is further configured to generate the coding matrix in response to receiving the first plurality of data blocks; receive a third plurality of data blocks; generate a second coding matrix in response to receiving the third plurality of data blocks; generate a third plurality of checksum blocks by multiplying the third plurality of data blocks by the second coding matrix; and store the third plurality of data blocks and the third plurality of checksum blocks in a second one or more storage devices of the one or more storage devices.","In some embodiments, the code block generation module is further configured to receive a third plurality of data blocks; generate a third plurality of checksum blocks by multiplying the third plurality of data blocks by the coding matrix; and store the third plurality of data blocks and the third plurality of checksum blocks in a second one or more storage devices of the one or more storage devices.","In some embodiments, the error recovery module is configured to determine the SDC location of the SDC error in the plurality of code blocks based on the syndrome matrix by constructing an error locator polynomial based on the syndrome matrix. In some embodiments, the error locator polynomial includes a plurality of coefficients, wherein the error recovery module is configured to determine the coefficients of the error locator polynomial using a Berlekamp-Massey algorithm. In some embodiments, the error recovery module is configured to determine the SDC location of the SDC error in the plurality of code blocks based on the syndrome matrix by determining the SDC location based on a root of the error locator polynomial. In some embodiments, the recovery matrix consists of a plurality of values of a plurality of interpolation polynomials.","In some embodiments, the error recovery module is configured to construct the recovery matrix using the failure location and the SDC location by constructing the recovery matrix of the form:\n\n()], 1, . . . , 0, . . . , 1}\u2020{}\n\nwhere the second plurality of data blocks consists of n data blocks and the second plurality of checksum blocks consists of m checksum blocks; where N=m+n; where a is a primitive element of the finite field; where {tilde over (W)}(), . . . , {tilde over (W)}() are basic interpolation polynomials; where l is a number of failure errors and SDC errors; and where {k, . . . , k} include the failure location and the SDC location.\n","Systems and methods of the present technology can provide fault tolerant protection of information. Embodiments of the technology can be implemented in data storage (e.g., data storage in hard disk drives, solid state drives, etc.) or data transfer devices (e.g., network cards, modems, etc.). For illustrative purposes, systems and methods of the present technology are described in the context of data storage in hard disk drives. However, the present technology can also be used in other applications involving the storage and transfer of digital information.","There are generally two types of data corruption. The first type, a failure error, relates to failure of a storage device (e.g., a drive or a part of the drive), the position of which can be detected by technical (e.g., hardware) control devices. Storage devices can include hardware and\/or firmware for detecting the location of failure errors, such as, e.g., failed sectors. For example, storage devices can include S.M.A.R.T (Self-Monitoring, Analysis and Reporting Technology), which can monitor the state of storage devices. In some storage devices, some controllers or cards can check failure of storage devices or their parts. Such a failure can be referred to as a failure error, or the refusal or failure of the drive. For the second type, a silent data corruption (SDC) error, data can be distorted in the process of transmitting, recording, storing or reading, but the fact of corruption as well as its position is not detected by technical (e.g., hardware) control devices.","In some aspects of the technology, an error correction coding approach is provided that includes detecting the presence and type of data corruption (e.g., data distortion), finding its position, and correcting the corrupted\/erroneous data on the basis of certain redundant information.","In some embodiments, given a data storage device, the available memory of the data storage device can be partitioned into two subsets of equal-sized groups, blocks, or sequences of k-bit words. At least a portion of these blocks are called data blocks and are used to store useful information. These data blocks are denoted as D, D, . . . , D. The remaining blocks store redundant information, which are used for data recovery in cases when an error or failure occurs. These blocks are called checksums and are denoted as C, C, . . . , C. In this context, n and m stand for some positive integers, and it can be assumed that m\u2266n.  shows exemplary data blocks  (Dto D) and checksum blocks  (Cto C) expressed as sequences of k-bit words  (e.g., Dis expressed as d, d. . . ).","To ensure fault tolerance against both types of errors (i.e. failure errors and SDC errors), the formalism of finite (or Galois) fields can be used. The field GF (2) of characteristic 2 can be taken. It contains 2elements which can be treated as k-bit words (vectors). Thus, with respect to k-bit words  in , one can treat {d, c} \u2282 GF(2). Arithmetic of Galois fields includes operations on its elements such as addition, multiplication, inversion and discrete logarithm extraction. The sum of the elements dand dis defined as bitwise sum modulo 2 (XOR), while multiplication of the elements dand dis defined as polynomial product d*dmodulo f with reduction coefficients modulo 2, where f is an irreducible polynomial that generates a Galois field. There exists a primitive element of the field, i.e., such an element a \u03b5 GF(2) that its powers a, a, . . . , arepresent distinct elements of the field. As a consequence, for any nonzero element d of the field there exists the unique solution of the equation a=d with respect to r \u03b5 {0,1, . . . , 2\u22122}. This solution is called the (discrete) logarithm of d (to the base a).","In some embodiments, the above-defined finite field arithmetic is applied to the problem of recovering one type of errors\u2014the failure errors. In the context of data storage technology, the n data blocks D, D, . . . , D(storing the useful information) are complemented with m=2 additional checksums C, C. The checksums are calculated by the following formulas:\n\n,\n\n.\u2003\u2003(1)\n\nThe addition and multiplication operations in the right-hand sides of the formulas (1) are performed word-wide, i.e.,\n\n=(, . . . ), . . . ,\n\n=(, . . . ), . . . .\n\nwith the word operations defined in an appropriate Galois field GF(2), where a represents a primitive element of this field. If one or more of the data blocks D, D, . . . , Dfail, then the values of the remaining data blocks and the recalculated values for C, Cby the formulas (1) permit one to restore the failed data blocks via resolving the system of two linear equations.\n","To extend the above failure recovery algorithm to the case of m>2 errors, one can reserve m checksums C, C, . . . , C. The values for these checksums are computed by the following formulas:\n\n=\u03a3=;\u2003\u2003(2)\n\nor, in the expanded form, the formulas for C, Care equivalent to (1), while C, . . . , Care computed as:\n\n,\n\n,\n\n. . . .\n","In some embodiments, a more complicated coding procedure known as the Reed-Solomon code is applied to the problem of recovering another type of errors, namely the SDC (Silent Data Corruption) errors. Given n data blocks D, D, . . . , D, values for checksum blocks C, C, . . . , Care computed that satisfy the relations:\n\n=\u2003\u2003(3)\n\nThis procedure is known as systematic coding and can be formally performed via computation of the remainder of the polynomial in the variable \n\n++ . . . +\n\non division by the polynomial\n\n()=(+)(+) . . . (+)\u2003\u2003(4).\n\nThe coefficients of the remainder can be taken as the values of checksums.\n","To test some sequence of code blocks D, D, . . . , D, C, C, . . . , Cfor the presence of SDC errors, one can substitute them into the left-hand side of the relations (3).\n\n=\u2003\u2003(5)\n","If all the computed values are equal to 0, then it is concluded that an SDC has not occurred. If, on the contrary, any of the values is nonzero, then at least one SDC has occurred in the given sequence. In this case, it is possible to detect the positions of one or more SDC errors and restore the correct values for the erroneous blocks provided that the number p of the occurred SDC errors satisfies the condition p\u2266\u2514m\/2\u2518, where \u2514m\/2\u2518 denotes the greatest integer not exceeding m\/2. Hereinafter, the values {tilde over (S)}, {tilde over (S)}, . . . , {tilde over (S)}are referred to as syndromes of the sequence of blocks D, D, . . . , D, C, C, . . . , C.","The technique described above can be formalized further with the aid of matrix analysis. A Vandermonde matrix, as follows, can be used:",{"@attributes":{"id":"p-0038","num":"0037"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"V","mrow":{"mi":["m","n"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"\u03bb","mn":"1"},{"mi":["\u03bb","n"]}],"mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mn":"1"},{"mi":"\u2026"},{"mn":"1"}]},{"mtd":[{"msubsup":{"mi":"\u03bb","mn":["1","1"]}},{"msubsup":{"mi":"\u03bb","mn":["2","1"]}},{"mi":"\u2026"},{"msubsup":{"mi":["\u03bb","n"],"mn":"1"}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u2026"},{"mi":"\u22ee"}]},{"mtd":[{"msubsup":{"mi":"\u03bb","mn":"1","mrow":{"mi":"m","mo":"-","mn":"1"}}},{"msubsup":{"mi":"\u03bb","mn":"2","mrow":{"mi":"m","mo":"-","mn":"1"}}},{"mi":"\u2026"},{"msubsup":{"mi":["\u03bb","n"],"mrow":{"mi":"m","mo":"-","mn":"1"}}}]}]}}],"mo":"="}}},"br":{},"sub":["1","n"],"sup":["k","k"]},{"@attributes":{"id":"p-0039","num":"0038"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"D","mo":"=","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"D","mn":"0"}}},{"mtd":{"msub":{"mi":"D","mn":"1"}}},{"mtd":{"msub":{"mi":"D","mn":"2"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"D","mrow":{"mi":"n","mo":"-","mn":"1"}}}}]}}},{"mi":"C","mo":"=","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"C","mn":"0"}}},{"mtd":{"msub":{"mi":"C","mn":"1"}}},{"mtd":{"msub":{"mi":"C","mn":"2"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"C","mrow":{"mi":"m","mo":"-","mn":"1"}}}}]}}}],"mo":","}}},"br":{},"sub":["0","1","n\u22121","0","1","m\u22121 "],"sup":"k"},"In this notation, formulas (2) can be rewritten in matrix form as\n\n(, . . . ,1)\u2003\u2003(6)\n\nEquations (3) or (5) can also be represented with the aid of the Vandermonde matrix. For this purpose, the following matrix is introduced:\n",{"@attributes":{"id":"p-0041","num":"0040"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Y","mo":"=","mrow":{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"D"}},{"mtd":{"mi":"C"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"D","mn":"0"}}},{"mtd":{"msub":{"mi":"D","mn":"1"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"D","mrow":{"mi":"n","mo":"-","mn":"1"}}}},{"mtd":{"msub":{"mi":"C","mn":"0"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"C","mrow":{"mi":"m","mo":"-","mn":"1"}}}}]}}],"mo":"="}}}},"br":[{},{},{},{},{},{},{}],"sub":["0","N\u22121","m,N","m,n","m,m","m,m","m,n","m,m"],"in-line-formulae":[{},{},{},{},{},{},{},{}],"i":["V","a",",a","Y=",{},"V","a",",a",", . . . ,a","D+V","a",",a","C=",{},"C=[V","a",",a","V","a",",a",", . . . ,a","D"],"sup":["N\u22121","N\u22122","N\u22121","N\u22122","m","m\u22121","m\u22122","k","m\u22121","m\u22122","\u22121","N\u22121","N\u22122","m","\u22121 "],"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00018","he":"3.22mm","wi":"2.46mm","file":"US09647690-20170509-P00002.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00019","he":"3.22mm","wi":"2.46mm","file":"US09647690-20170509-P00002.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00020","he":"3.22mm","wi":"2.46mm","file":"US09647690-20170509-P00006.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]},"In one aspect, the inversion of the Vandermonde matrix can be used as an integral part of the systematic coding procedure of the present technology. A principal feature of the Vandermonde matrix in the context of error correction coding is based on the simple conditions for its nondegeneracy (in case of a square matrix, i.e. m=n). Specifically, the matrix V(\u03bb, . . . , \u03bb) is nondegenerate (invertible) if and only if all of its generating elements \u03bb, . . . , \u03bbare distinct.","To determine [V(\u03bb, . . . , \u03bb)], the following basic interpolation polynomials {tilde over (W)}() (j=) are first introduced:",{"@attributes":{"id":"p-0044","num":"0043"},"maths":[{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"]}},{"munderover":{"mo":"\u220f","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":["\u03bb","i"]}}}}],"mo":"="},{"mrow":[{"msub":{"mi":["W","j"]},"mo":"\u2061","mrow":{"mo":["(",")"]}},{"mfrac":{"mrow":[{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"]}},{"mo":"-","msub":{"mi":["\u03bb","j"]}}]},"mo":"=","mrow":{"munderover":{"mo":"\u220f","mrow":{"mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":["i","j"],"mo":"\u2260"}],"mo":","},"mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":["\u03bb","i"]}}}}}],"mo":"="}],"mo":[",","\u2062",",","\u2062"],"mstyle":[{"mtext":{}},{"mtext":{}}],"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"j"},"mo":"\u2061","mrow":{"mo":["(",")"]}},"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"msub":{"mi":["W","j"]},"mo":"\u2061","mrow":{"mo":["(",")"]}},{"msub":{"mi":["W","j"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["\u03bb","j"]}}}]}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"msub":{"mi":["W","j"]},"mo":"\u2061","mrow":{"mo":["(",")"]}},{"msup":{"mi":["W","\u2032"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["\u03bb","j"]}}}]}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":"\u03bb","mn":"1"}}},{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":"\u03bb","mn":"2"}}},{"mi":"\u2026","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":"\u03bb","mrow":{"mi":"j","mo":"-","mn":"1"}}}}},{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":"\u03bb","mrow":{"mi":"j","mo":"+","mn":"1"}}}},{"mi":"\u2026","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":["\u03bb","n"]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062"]},{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":["\u03bb","j"]},{"mi":"\u03bb","mn":"1"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msub":[{"mi":["\u03bb","j"]},{"mi":"\u03bb","mn":"2"}],"mo":"-"}},{"mi":"\u2026","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["\u03bb","j"]},{"mi":"\u03bb","mrow":{"mi":"j","mo":"-","mn":"1"}}],"mo":"-"}}},{"mo":["(",")"],"mrow":{"msub":[{"mi":["\u03bb","j"]},{"mi":"\u03bb","mrow":{"mi":"j","mo":"+","mn":"1"}}],"mo":"-"}},{"mi":"\u2026","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["\u03bb","j"]},{"mi":["\u03bb","n"]}],"mo":"-"}}}],"mo":["\u2062","\u2062","\u2062","\u2062"]}]}}}},{"mtd":{"mrow":{"mrow":[{"mo":["=","\u2062"],"mi":{},"mrow":{"msub":[{"mi":"w","mrow":{"mi":"j","mo":",","mn":"0"}},{"mi":"w","mrow":{"mi":"j","mo":",","mn":"1"}},{"mi":"w","mrow":{"mi":"j","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}],"mo":["+","+","+"],"mi":"\u2026"}},{"mi":"j","mo":"=","mrow":{"mover":{"mrow":{"mn":"1","mo":",","mi":"n"},"mi":"_"},"mo":"."}}],"mo":[",",","],"msup":{"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}]}}}},{"@attributes":{"id":"MATH-US-00006-2","num":"00006.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mrow":{"mi":"Then","mo":["\u2062","[","]"],"mstyle":{"mtext":{}},"mrow":{"msub":{"mi":"V","mrow":{"mi":["n","n"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"\u03bb","mn":"1"},{"mi":["\u03bb","n"]}],"mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}},"mtable":{"mtr":{"mtd":[{"mo":"-"},{"mn":"1"}]}}},"mo":"=","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"w","mrow":{"mn":["1","0"],"mo":","}}},{"msub":{"mi":"w","mrow":{"mn":["1","1"],"mo":","}}},{"mi":"\u2026"},{"msub":{"mi":"w","mrow":{"mn":"1","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}]},{"mtd":[{"msub":{"mi":"w","mrow":{"mn":["2","0"],"mo":","}}},{"msub":{"mi":"w","mrow":{"mn":["2","1"],"mo":","}}},{"mi":"\u2026"},{"msub":{"mi":"w","mrow":{"mn":"2","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u2026"},{"mi":"\u22ee"}]},{"mtd":[{"msub":{"mi":"w","mrow":{"mi":"n","mo":",","mn":"0"}}},{"msub":{"mi":"w","mrow":{"mi":"n","mo":",","mn":"1"}}},{"mi":"\u2026"},{"msub":{"mi":"w","mrow":{"mi":"n","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}]}]}}}}}],"br":{}},{"@attributes":{"id":"p-0045","num":"0044"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"C","mn":"0"}}},{"mtd":{"msub":{"mi":"C","mn":"1"}}},{"mtd":{"msub":{"mi":"C","mn":"2"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"C","mrow":{"mi":"m","mo":"-","mn":"1"}}}}]}},{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"D","mn":"0"}}},{"mtd":{"msub":{"mi":"D","mn":"1"}}},{"mtd":{"msub":{"mi":"D","mn":"2"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"D","mrow":{"mi":"n","mo":"-","mn":"1"}}}}]}}],"mo":"\u2062"}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"9"}}]}}}},"br":{}},{"@attributes":{"id":"p-0046","num":"0045"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"m"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["a","m"]}}}}]}]}}}}},"br":{},"sub":["1","2","m"],"sup":["m\u22121","m\u22122"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","202","204","206","208"],"sub":["0 ","n\u22121 ","0 ","m\u22121"]},"In some aspects, the matrix approach can be extended to the problem of error correction or decoding. It is assumed that the data blocks are already encoded systematically with the aid of formulas (9) using, for example, the algorithm described with reference to :\n\n()\u2192()\n\nThe general theory of the error correction coding is that the redundancy in m checksum blocks permits one to correct the erroneous values of l failure errors (data lost at known positions) and p SDC errors (data lost at unknown positions) provided that the condition l+2p\u2266m is fulfilled. Below are exemplary data recovery algorithms in accordance with the present technology:\n","A. All the occurred errors are failure errors.","B. All the occurred errors are SDC errors.","C. A more general case of appearance of both types of errors","A. Only Failure Errors","Suppose that among the code blocks Y, Y, . . . , Yfailure errors have occurred at the known positions k, . . . , k(k< . . . <k), l\u2266m. Compose the matrix from the failed blocks:",{"@attributes":{"id":"p-0054","num":"0053"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mover":{"mi":["Y","_"]},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"Y","msub":{"mi":"k","mn":"1"}}}},{"mtd":{"msub":{"mi":"Y","msub":{"mi":"k","mn":"2"}}}},{"mtd":{"msub":{"mi":"Y","msub":{"mi":"k","mn":"3"}}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"Y","msub":{"mi":["k","l"]}}}}]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"or"}},{"mover":{"mi":["Y","_"]},"mo":"=","mrow":{"mo":["[","]"],"msub":{"mi":["Y","i"]}}},{"mi":"i","mo":"=","mrow":{"mo":["{","}"],"mrow":{"msub":[{"mi":"k","mn":"1"},{"mi":["k","l"]}],"mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}],"mo":[",",",",","],"mi":"briefly"}}},"br":{}},{"@attributes":{"id":"p-0055","num":"0054"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msup":{"mi":["Y","\u2032"]},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"Y","mrow":{"msub":{"mi":"k","mn":"1"},"mo":"-","mn":"1"}}}},{"mtd":{"msub":{"mi":"Y","mrow":{"msub":{"mi":"k","mn":"1"},"mo":"+","mn":"1"}}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"Y","mrow":{"msub":{"mi":"k","mn":"2"},"mo":"-","mn":"1"}}}},{"mtd":{"msub":{"mi":"Y","mrow":{"msub":{"mi":"k","mn":"2"},"mo":"+","mn":"1"}}}},{"mtd":{"mi":"\u22ee"}}]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"or"}},{"msup":{"mi":["Y","\u2032"]},"mo":"=","mrow":{"mo":["[","]"],"msub":{"mi":["Y","i"]}}},{"mi":"i","mo":"=","mrow":{"mrow":[{"mo":["{","}"],"mrow":{"mn":"0","mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"N","mo":"-","mn":"1"}}},{"mo":["{","}"],"mrow":{"msub":[{"mi":"k","mn":"1"},{"mi":["k","l"]}],"mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}],"mo":["\u2062","\u2062"],"mi":"\\"}}],"mo":[",",",",",","\u2062"],"mi":"briefly","mstyle":{"mtext":{}}}}},"br":{}},"Step 1: Construct the matrix with l rows and N\u2212l columns",{"@attributes":{"id":"p-0057","num":"0056"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"R","mrow":{"mi":"l","mo":",","mrow":{"mi":["N","l"],"mo":"-"}}},"mo":"=","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","msub":{"mi":"k","mn":"1"}}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":["-","-"],"msub":{"mi":"k","mn":"1"},"mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}}}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","msub":{"mi":"k","mn":"1"}}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":["-","-"],"msub":{"mi":"k","mn":"1"},"mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"l"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"1"}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"l"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"l"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":"-","msub":{"mi":"k","mn":"1"}}}}}},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"l"},"mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"a","mrow":{"mi":"N","mo":["-","-"],"msub":{"mi":"k","mn":"1"},"mn":"2"}}}}},{"mi":"\u2026"},{"mrow":{"msub":{"mover":{"mi":"W","mo":"~"},"mi":"l"},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}}}]}]}}}}}},"or, briefly,\n\n()],1, . . . ,0, . . . ,1}\\{},\u2003\u2003(10)\n\n","Step 2: Recover failed blocks from those block without failure errors:\n\n\u2003\u2003(11)\n","B. Only SDC Errors","Suppose that the sequence of code blocks Y, . . . , Ycontains up to p\u2266\u2514m\/2\u2518 SDC errors placed at a priori unknown positions j, j, . . . , j. The exact value of p is to be determined within the error correcting process. Moreover, even the fact of occurrence of any of these SDC is not certain. To detect the SDC errors, the values for syndromes {tilde over (S)}can be calculated using formulas (5):",{"@attributes":{"id":"p-0062","num":"0062"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"S","mo":"~"},"mi":"j"},"mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"0"},{"mi":"N","mo":"-","mn":"1"}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["Y","i"]},"mo":"\u2062","msup":{"mi":"a","mrow":{"mi":"j","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["N","i"],"mo":["-","-"],"mn":"1"}}}}}}},{"mi":"j","mo":"=","mover":{"mrow":{"mn":"0","mo":",","mrow":{"mi":"m","mo":"-","mn":"1"}},"mi":"_"}}],"mo":","}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["{tilde over (S)}=V","a",",a",", . . . ,a,","Y"],"sub":"m,n","sup":["N\u22121","N\u22122"]},"If at least one syndrome {tilde over (S)}is not 0, then the sequence Y, . . . , Ycontains at least one SDC error. To find the positions j, j, . . . , jof the SDC errors, an error locator polynomial can be constructed, i.e., the polynomial with the roots coinciding with the elements\n\n.\n\nThe coefficients of this polynomial (and value of p)\n\n\u03c3()= . . . +\u03c3.\n\ncan be found with the aid of the iterative Berlekamp-Massey algorithm (BMA). It should be appreciated that any other algorithm to define the coefficients of the error locator polynomial, as many are well known to those of skill in the art, can be used.\n","In general, BMA can be briefly described as follow. The input of this algorithm is the sequence of m code words (w, w, . . . , w) and the number t which is the maximal even number such that t\u2266m. To determine the coefficients of error locator polynomial \u03c3() in the BMA, two auxiliary polynomials B() and T() are used. The BMA consists of the following steps:\n\n",{"@attributes":{"id":"p-0065","num":"0068"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["\u0394","j"]},"mo":"=","mrow":{"msub":{"mi":"w","mrow":{"mi":"j","mo":"-","mn":"1"}},"mo":"+","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"L"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":"\u03c3","mrow":{"mi":["L","i"],"mo":"-"}},{"mi":"w","mrow":{"mi":["j","i"],"mo":["-","-"],"mn":"1"}}],"mo":"\u2062"}}}}}},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["4. \u0394is compared to 0 if \u0394=0 then proceeds to step 9","5. Calculate T()=\u03c3()\u2212\u0394B()","6. Verify whether to increase the degree of the current polynomial: value 2L is compared with j\u22121. If 2L>j\u22121 then proceeds to step 8","7. Calculate new values of B(), \u03c3() and L.\n\n()=\u0394\u03c3(), \u03c3()=(), \n","8. Assign \u03c3()=T()","9. Assign B()=B()","10. Check if j<t, then proceeds to step 2","11. Check if deg \u03c3()\u2260L then proceeds to step 13","12. Completion of the algorithm","13. Detected an unrecoverable error"]}}}},"In the context of the present technology, the sequence {tilde over (S)}, {tilde over (S)}, . . . , {tilde over (S)}, {tilde over (S)}is an input of the algorithm. The outputs of the algorithm are the coefficients of the polynomial \u03c3(), i.e. \u03c3, \u03c3, . . . , \u03c3. Roots of this polynomial are a, . . . , a. One can find them with the aid of, for instance, the Chien's search algorithm for determining roots of polynomials defined over a finite field. It should be appreciated that any other algorithm for calculation of roots of the polynomial over the finite field, as many are well known to those of skill in the art, can be used. The exponents of the primitive element provide the SDC locations. When all the SDC locations are identified, the data in these blocks are restored using, for instance, the algorithm presented above in \u201cA. Only Failure Errors\u201d (e.g., by treating SDC error with known locations as failure errors).","C. Failure and SDC Errors","Consider now the general case, where, in addition to SDC errors, a sequence of data blocks also contains failure errors. Suppose within the data blocks there are l failure errors at the known positions k, . . . , kand up to p SDC errors at a priori unknown positions j, j, . . . , j(e.g., even the presence of the SDC errors is not certain). In this case, if the condition l+2p\u2266m is valid, then all the SDC errors can be detected and all the lost data due to both SDC and failure errors can be corrected in accordance with embodiments of the technology. In some embodiments, the following can be used to recover from failure errors and SDC errors:\n\n",{"@attributes":{"id":"p-0069","num":"0086"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"z","mo":"\u2061","mrow":{"mo":["(",")"]}},{"mrow":[{"munderover":{"mo":"\u220f","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"l"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mo":"+","msup":{"mi":"a","mrow":{"mi":"N","mo":["-","-"],"msub":{"mi":["k","i"]},"mn":"1"}}}}},{"msub":{"mi":"z","mn":"0"},"mo":["+","+","+"],"mrow":[{"msub":{"mi":"z","mn":"1"},"mo":"\u2062"},{"msub":{"mi":["z","l"]},"mo":"\u2062","msup":{"mi":"l"}}],"mi":"\u2026"}],"mo":"="}],"mo":"="}}},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":{"@attributes":{"id":"ul0010-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":["4. Calculate values\n\n=\u03a3=\u2003\u2003(13)\n","5. If at least one of Tis not zero then an SDC error has occurred.","6. An error locator polynomial is constructed and the positions of SDC errors are determined via the Berlekamp-Massey algorithm described in Section B, in which the input sequence is chosen as T, T, . . . , T","7. Find positions of the SDC errors via the error locator polynomial root evaluation.","8. All data are restored according to the algorithm presented above in \u201cA. Only Failure Errors,\u201d since now the positions of SDC-related and failure-related blocks are known."]}}}},{"@attributes":{"id":"p-0070","num":"0092"},"figref":["FIG. 3","FIG. 2"],"b":["300","302","304","304","304","306","308","308","308","310","312","314"],"i":["a","b","a","b"],"sub":"i "},"However, at step , if there is at least one nonzero syndrome, it means that the data blocks contain at least one SDC error. In this case, the process uses the iterative Berlekamp-Massey algorithm (BMA) at step  to determine the location(s) of the SDC error(s) in the data blocks at step . When all the SDC locations are identified, the errors in the data blocks are restored using the algorithm presented above in \u201cA. Only Failure Errors,\u201d which begins at step .","At step , if there is at least one failed block, it means that the data blocks can potentially contain a mix of failure and SDC errors. In this case, Tare calculated at step  from the syndromes using formula (13). If all Tvalues are zero (step ), it means that there is no SDC error and the data blocks contain only failure error(s). In this case, the failure errors in the data blocks are restored using the algorithm presented above in \u201cA. Only Failure Errors,\u201d which begins at step . On the other hand, if at least one of the Tvalues is non-zero, then an SDC error has occurred in addition to at least one failure error. In this case, the process executes the BMA at step , in which the input sequence is T, to determine the location(s) of SDC error(s) at step . Both the failure and SDC errors are restored according to the algorithm presented above in the section \u201cA. Only Failure Errors\u201d starting at step , since now the positions of the SDC-related and failure-related blocks are known.","If SDC error checking is not activated at step , the process can determine at step  if there is any failure errors associated with the data blocks. If there is no failure error, the process can return the requested data at step , along with an indication that there is no failure error associated with the data. If there is at least one failure error in the data blocks, a recovery matrix is constructed using formula (10) at step . The blocks containing the errors can be recovered from those blocks that do not contain any errors using formula (11) at step . Finally, the process returns the requested data at step  with the errors corrected.","In some embodiments, the present technology can be implemented on a data storage system that includes one or more storage devices. As will be described in greater detail below, the data storage system can include a code block generation module implementing the encoding algorithms described herein (e.g., as described with respect to ). The data storage system can include an error recovery module implementing the decoding algorithms described herein (e.g., as described above in the section entitled \u201cDecoding\u201d and\/or with respect to ). In some embodiments, the code block generation module and the error recovery module can be implemented in same hardware and\/or software.  illustrates an exemplary data storage system . The data storage system  includes one or more hardware modules configured to implement the algorithms and\/or software of the present technology. For example, the data storage system  can include one or more hardware devices to implement the algorithms described herein (e.g., as described above in the section entitled \u201cDecoding\u201d and\/or with respect to ). As shown, the data storage system  includes at least one driver  that creates a redundant array of inexpensive disks (RAID) by combining multiple storage devices (e.g., Storage devices , , ) into a logical unit for the purpose of data storage and redundancy. The RAID driver  can use these storage devices , ,  to create a virtually-protected RAID system. In addition, a volume manager  is used to create virtual volumes using RAID's address space. The virtual volumes are presented to clients (e.g., device driver , ) using a SCSI target driver . In some embodiments, the storage devices , ,  codes data stored therein using the encoding algorithms described herein (e.g., as described with respect to ). In some embodiments, the RAID driver  uses an array calculation algorithm module  that implements the decoding algorithms described herein (e.g., as described above in the section entitled \u201cDecoding\u201d and\/or with respect to ) to calculate checksums and perform corrective\/restorative functions if failure errors and\/or SDC errors are detected in the encoded data. In some embodiments, a storage cache  that is in electrical communication with the RAID driver  is used to store information pertinent to the decoding process, such as the decoded data, the locations of the errors in the data blocks, the corrected data, etc.",{"@attributes":{"id":"p-0075","num":"0097"},"figref":["FIG. 5","FIGS. 2 and 3","FIG. 2","FIG. 3"],"b":["500","500","500","502","504","506","508","502","504","508","508","508","508","508","504","508","504"],"i":["a ","a "]},"The above-described techniques can be implemented in digital and\/or analog electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The implementation can be as a computer program product, i.e., a computer program tangibly embodied in a machine-readable storage device, for execution by, or to control the operation of, a data processing apparatus, e.g., a programmable processor, a computer, and\/or multiple computers. A computer program can be written in any form of computer or programming language, including source code, compiled code, interpreted code and\/or machine code, and the computer program can be deployed in any form, including as a stand-alone program or as a subroutine, element, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one or more sites.","Method steps can be performed by one or more processors executing a computer program to perform functions of the technology by operating on input data and\/or generating output data. Method steps can also be performed by, and an apparatus can be implemented as, special purpose logic circuitry, e.g., a FPGA (field programmable gate array), a FPAA (field-programmable analog array), a CPLD (complex programmable logic device), a PSoC (Programmable System-on-Chip), ASIP (application-specific instruction-set processor), or an ASIC (application-specific integrated circuit), or the like. Subroutines can refer to portions of the stored computer program and\/or the processor, and\/or the special circuitry that implement one or more functions.","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital or analog computer. Generally, a processor receives instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and\/or data. Memory devices, such as a cache, can be used to temporarily store data. Memory devices can also be used for long-term data storage. Generally, a computer also includes, or is operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. A computer can also be operatively coupled to a communications network in order to receive instructions and\/or data from the network and\/or to transfer instructions and\/or data to the network. Computer-readable storage mediums suitable for embodying computer program instructions and data include all forms of volatile and non-volatile memory, including by way of example semiconductor memory devices, e.g., DRAM, SRAM, EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and optical disks, e.g., CD, DVD, HD-DVD, and Blu-ray disks. The processor and the memory can be supplemented by and\/or incorporated in special purpose logic circuitry.","To provide for interaction with a user, the above described techniques can be implemented on a computer in communication with a display device, e.g., a CRT (cathode ray tube), plasma, or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse, a trackball, a touchpad, or a motion sensor, by which the user can provide input to the computer (e.g., interact with a user interface element). Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, and\/or tactile input.","The above described techniques can be implemented in a distributed computing system that includes a back-end component. The back-end component can, for example, be a data server, a middleware component, and\/or an application server. The above described techniques can be implemented in a distributed computing system that includes a front-end component. The front-end component can, for example, be a client computer having a graphical user interface, a Web browser through which a user can interact with an example implementation, and\/or other graphical user interfaces for a transmitting device. The above described techniques can be implemented in a distributed computing system (e.g., a cloud-computing system) that includes any combination of such back-end, middleware, or front-end components.","Communication networks can include one or more packet-based networks and\/or one or more circuit-based networks in any configuration. Packet-based networks can include, for example, an Ethernet-based network (e.g., traditional Ethernet as defined by the IEEE or Carrier Ethernet as defined by the Metro Ethernet Forum (MEF)), an ATM-based network, a carrier Internet Protocol (IP) network (LAN, WAN, or the like), a private IP network, an IP private branch exchange (IPBX), a wireless network (e.g., a Radio Access Network (RAN)), and\/or other packet-based networks. Circuit-based networks can include, for example, the Public Switched Telephone Network (PSTN), a legacy private branch exchange (PBX), a wireless network (e.g., a RAN), and\/or other circuit-based networks. Carrier Ethernet can be used to provide point-to-point connectivity (e.g., new circuits and TDM replacement), point-to-multipoint (e.g., IPTV and content delivery), and\/or multipoint-to-multipoint (e.g., Enterprise VPNs and Metro LANs). Carrier Ethernet advantageously provides for a lower cost per megabit and more granular bandwidth options.","Devices of the computing system can include, for example, a computer, a computer with a browser device, a telephone, an IP phone, a mobile device (e.g., cellular phone, personal digital assistant (PDA) device, laptop computer, electronic mail device), and\/or other communication devices. The browser device includes, for example, a computer (e.g., desktop computer, laptop computer, mobile device) with a world wide web browser (e.g., Microsoft\u00ae Internet Explorer\u00ae available from Microsoft Corporation, Mozilla\u00ae Firefox available from Mozilla Corporation).","One skilled in the art will realize the technology may be embodied in other specific forms without departing from the spirit or essential characteristics thereof. The foregoing embodiments are therefore to be considered in all respects illustrative rather than limiting of the technology described herein. Scope of the technology is thus indicated by the appended claims, rather than by the foregoing description, and all changes that come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, features, and advantages of the present technology, as well as the technology itself, will be more fully understood from the following description of various embodiments, when read together with the accompanying drawings, in which:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
