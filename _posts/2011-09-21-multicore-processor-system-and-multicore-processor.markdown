---
title: Multicore processor system and multicore processor
abstract: According to one embodiment, a multicore processor system includes: a memory region, and a multicore processor that includes plural cores, a first cache, and a second cache shared between the plural cores. The memory region permits first state in which exclusive use by using the first and second cache is granted to one core, second state in which exclusive use by using the second cache is granted to one core group, and third state in which use by using neither the first cache nor the second cache is granted to all core groups. A kernel unit writes back a first cache to the second cache when a transition of the memory region from the first state to the second state is made, and writes back a second cache to the memory region when a transition of the memory region from the second state to the third state is made.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08762647&OS=08762647&RS=08762647
owner: Kabushiki Kaisha Toshiba
number: 08762647
owner_city: Tokyo
owner_country: JP
publication_date: 20110921
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is based upon and claims the benefit of priority from Japanese Patent Application No. 2011-133546, filed on Jun. 15, 2011; the entire contents of which are incorporated herein by reference.","Embodiments described herein relate generally to a multicore processor system and a multicore processor.","For a processor that becomes a core of information processing, performance improvement is always being expected. As one of methods for improving process performance, clustering processor cores is pointed out.","Further, conventionally, to suppress increase of a chip area and power consumption, development of a technique for implementing a function of maintaining consistency of caches by software and not by a hardware mechanism has been required.","In general, according to one embodiment, a multicore processor system includes: memory that includes a memory region; and a multicore processor that includes plural processor cores each including a first cache, and a second cache shared between the plural processor cores, in which processor cores that share the second cache form a core group of each processor core to which the memory mapping is common. The memory region is permitted to be in one of the following first to third states. The first state is a state in which reading and writing by a first access by using both the first cache and the second cache is permitted, and in which the exclusive right of use is granted to one processor core. The second state is a state in which reading and writing by a second access by using the second cache but not using the first cache is permitted, and in which the exclusive right of use is granted to one core group. The third state is a state in which reading and writing by a third access by not using either the first cache or the second cache is permitted, and in which the right of use is granted to all core groups. The multicore processor functions as a kernel unit that makes transition of the memory region between the states. The kernel unit makes transition of the memory region between the first state and the second state and between the second state and the third state. The kernel unit writes back a corresponding first cache to the second cache when the kernel unit makes transition of the memory region from the first state to the second state, and writes back a corresponding second cache to the memory region when the kernel unit makes transition of the memory region from the second state to the third state.","Exemplary embodiments of a multicore processor system and a multicore processor will be explained below in detail with reference to the accompanying drawings. The present invention is not limited to the following embodiments.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 1"},"A multicore processor system  includes a multicore processor  and memory . The multicore processor  and the memory  are connected to each other via a bus. Respective constituent elements can be connected to each other by other network topology such as a mesh instead of the bus.","The memory  is configured by RAM (Random Access Memory), for example. A kernel program  that manages a hardware resource of the multicore processor  and a user program  that causes the multicore processor system  to be operated as a user desires are loaded on the memory . A kernel management region  that the multicore processor  can use as main memory is secured in the memory . The multicore processor  allocates memory regions within the kernel management region  to respective cores  while holding consistency of caches (L1 caches  and L2 caches  described later), by executing the kernel program  and the user program .","In the following explanation, operation that is mainly performed by the multicore processor  is achieved by executing the kernel program  or the user program  by the multicore processor  (more accurately, by the cores ). Operation based on the kernel program  is sometimes expressed as the operation performed by the kernel program , and operation based on the user program  is sometimes expressed as the operation performed by a task. A source of loading the kernel program  and the user program  can be a nonvolatile memory region configured by ROM (Read Only Memory) or the like that stores the programs in advance or an external storage device. Hereinafter, the kernel program  is simply expressed as a kernel .","The multicore processor  includes plural cores (processor cores) . Each core  includes the L1 cache (L1C) . The multicore processor  also includes plural (two in the case of ) clusters , and each core  belongs to any of the plural clusters . Each cluster  includes the L2 cache (L2C)  at a memory  side, and the cores  that belong to the same cluster  are connected in common within the cluster by a bus. That is, each core  can access the memory  via caches at two stages of the L1C  and the L2C . Respective constituent elements within the cluster can be connected to each other by other network topology such as a mesh instead of the bus.","Between the L1C  and the L2C , an ATU (address translation unit)  that translates a virtual address into a physical address is provided for each core . The core  uses a virtual address as information for specifying an access destination. When an access destination is not hit in the L1C , the ATU  translates the virtual address into a physical address, and transmits the address to the L2C  or the memory .","This indicates that a memory map of each core  can be mapped in the memory  by the ATU . That is, the ATU  can redundantly map plural memory regions on a virtual address space to a memory region on the same physical address space. In the first embodiment, plural memory regions on a virtual address space are redundantly mapped to a memory region on the physical address space. Whether the caches (the L1C , the L2C ) are to be used for the access can be selected, depending on which memory region is to be accessed among the redundantly-mapped plural memory regions on a virtual address space.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 2","b":["23","21"]},"As illustrated in the drawing, the ATU  of the core maps virtual addresses 0x00000000 to 0x3FFF_FFFF of the core into physical addresses 0x00000000 to 0x3FFF_FFFF via both the L1C  and the L2C  (hereinafter, expressed as L1C\/L2C), and maps virtual addresses 0x40000000 to 0x7FFF_FFFF into the same physical addresses 0x00000000 to 0x3FFF_FFFF not via the L1C  but via the L2C  (hereinafter, expressed as L1UC\/L2C). Further, the ATU  maps, as a memory region to be shared between the clusters , virtual addresses 0x80000000 to 0x8FFF_FFFF into physical addresses 0xA0000000 to 0xAFFF_FFFF, by the L1C\/L2C, maps virtual addresses 0x90000000 to 0x9FFF_FFFF into the same physical addresses 0xA0000000 to 0xAFFF_FFFF by the L1UC\/L2C, and maps physical addresses 0xA0000000 to 0xAFFF_FFFF into the same physical addresses 0xA0000000 to 0xAFFF_FFFF not via either the L1C  or the L2C  (hereinafter, expressed as L1UC\/L2UC).","The ATU  of the core maps virtual addresses 0x00000000 to 0x5FFF_FFFF into physical addresses 0x0000000 to 0x9FFF_FFFF by the L1C\/L2C, and maps virtual addresses 0x40000000 to 0xBFFF_FFFF into the same physical addresses 0x0000000 to 0x9FFF_FFFF by the L1UC\/L2C. Further, the ATU  maps, as a memory region to be shared between the clusters , virtual addresses 0xC0000000 to 0xCFFF_FFFF into physical addresses 0xA0000000 to 0xAFFF_FFFF by the L1C\/L2C, maps virtual addresses 0xD0000000 to 0xDFFF_FFFF into the same physical addresses 0xA0000000 to 0xAFFF_FFFF by the L1UC\/L2C, and maps virtual addresses 0xE0000000 to 0xEFFF_FFFF into the same physical addresses 0xA0000000 to 0xAFFF_FFFF by the L1UC\/L2UC.","Because virtual addresses are redundantly mapped into the memory region of the physical addresses 0xA0000000 to 0xAFFF_FFFF from both the cores and , the cores and can share data by using this memory region. Further, the memory region on this physical address space is redundantly mapped in three memory regions including a memory region that is determined to be accessed by the L1C\/L2C, a memory region that is determined to be accessed by the L1UC\/L2C, and a memory region that is determined to be accessed by the L1UC\/L2UC. Therefore, in this memory region on the physical address space, the cores and can access the memory region of the physical address space, in a desired mode among the L1C\/L2C, the L1UC\/L2C, and the L1UC\/L2UC, by switching between the virtual addresses of access destinations. Hereinafter, a memory region to which access by the L1UC\/L2C is determined and a memory region to which access by the L1UC\/L2UC is determined are also expressed as shadow regions of the memory regions to which access by the L1C\/L2C is determined.","According to the first embodiment, in order to keep consistency of the caches (the L1C  and the L2C ) that are applied to the memory region on the physical address space mapped by plural cores , a MAP (memory access protocol) explained below is defined.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 3"},"(a) The INVALID state","In this state, a memory region can be allocated to a task. A memory region before allocation and after freeing belongs to this state. A task cannot access the memory region in this state at all.","(b) The PRIVATE state","In this state, only a task that has changed a memory region to this state is permitted to perform a read\/write access by the L1C\/L2C. This access is achieved by accessing a virtual address that is mapped in a physical memory by the L1C\/L2C.","(c) The PUBLIC state","In this state, tasks (the cores ) of which mapping set by the ATU  is the same share data. That is, tasks of which mapping set by the ATU  is the same are permitted to perform a read\/write access by the L1UC\/L2C. This access is achieved by accessing a virtual address that is mapped in a physical memory by the L1UC\/L2C.","In this case, a concept of a process (a core group) that means a group of tasks of which mapping by the ATU  is the same is introduced.  is an explanatory diagram of the concept of the process. In , three cores  (tasks) belong to a process A, and four cores  (tasks) belong to a process B. Tasks executed on plural cores , whose settings of the ATU  are the same, belong to the same process. That is, not only tasks that have changed memory regions to the PUBLIC state, but also all tasks that belong to the process are permitted to access the memory region in the PUBLIC state. Although plural processes can exist in one cluster , it is assumed that one process cannot stride over the cluster .","(d) The PROTECTED state","In this state, one or more tasks that belong to the same process and that have requested a transition of the memory region to this state are permitted to perform a read access by the L1C\/L2C. A task cannot perform a write access to the memory region in this state at all.","(e) The EXTERNAL state","In this state, all tasks that stride over the cluster  are permitted to perform a read\/write access by the L1UC\/L2UC. This access is achieved by accessing a virtual address that is mapped in a physical memory by the L1UC\/L2UC.","(f) The UNMANAGED state","This state is a state that is not managed by the kernel . That is, this is a portion excluding the kernel management region  out of memory regions that the memory  has. Because the kernel  does not manage consistency of caches in a memory region in this state, a task must hold consistency of the caches by taking responsibility, when a task uses this memory region.","A memory region that is included in the kernel management region  is in one of the INVALID state, the PRIVATE state, the PUBLIC state, the PROTECTED state, and the EXTERNAL state. As for the INVALID state, transition can be made between this state and the PUBLIC state, between this state and the PRIVATE state, and between this state and the EXTERNAL state. As for the PUBLIC state transition can be made between this state and the INVALID state, between this state and the PRIVATE state, between this state and the EXTERNAL state, and between this state and the PROTECTED state. Within the kernel management region , consistency of caches can be held, by keeping a memory access based on the definition of each state and the transition rule of a transition between states.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 5","b":["1","2","26","27","28","32","2","29","33"]},"The state transition function  is an API (Application Programming Interface) to perform a transition between the states in the MAP illustrated in , and functions as a kernel unit in cooperation with the memory allocator  and the cache\/memory management unit . The state transition function  includes the following 14 functions.","(1) allocate_private_memory (size_t size)","This is a function that secures a memory region in the PRIVATE state of the size specified by an argument \u201csize\u201d from a memory region in the INVALID state.","(2) free_private_memory (void *addr, size_t size)","This is a function that frees a memory region in the PRIVATE state that is specified by a header address \u201caddr\u201d and the argument \u201csize\u201d. The area that is freed by this function becomes the INVALID state.","(3) allocate_public_memory (size_t size)","This is a function that secures a memory region in the PUBLIC state of the size specified by the argument \u201csize\u201d from a memory region in the INVALID state.","(4) free_public_memory (void *addr, size_t size)","This is a function that frees a memory region in the PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d. The area that is freed by this function becomes the INVALID state.","(5) allocate_external_memory (size_t size)","This is a function that secures a memory region in the EXTERNAL state of the size specified by the argument \u201csize\u201d from a memory region in the INVALID state.","(6) free_external_memory (void *addr, size_t size)","This is a function that frees a memory region in the EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d. The area that is freed by this function becomes the INVALID state.","(7) open_private_memory (void *addr, size_t size)","This is a function that changes a memory region in the PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the PUBLIC state to the PRIVATE state.","(8) close_private_memory (void *addr, size_t size)","This is a function that changes a memory region in the PRIVATE state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the PRIVATE state to the PUBLIC state.","(9) open_protected_memory (void *addr, size_t size)","This is a function that a memory region in the PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the PUBLIC state to the PROTECTED state.","(10) close_protected_memory (void *addr, size_t size)","This is a function that changes a memory region in the PROTECTED state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the PROTECTED state to the PUBLIC state.","(11) open_public_memory (void *addr, size_t size)","This is a function that changes a memory region in the EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the EXTERNAL state to the PUBLIC state.","(12) close_public_memory (void *addr, size_t size)","This is a function that changes a memory region in the PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the PUBLIC state to the EXTERNAL state.","(13) enter_memory_access_protocol (void *addr, size_t size)","This is a function that changes a memory region in the UNMANAGED state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UNMANAGED state to the INVALID state.","(14) leave_memory_access_protocol (void *addr, size_t size)","This is a function that changes a memory region in the INVALID state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the INVALID state to the UNMANAGED state.","The allocate functions (allocate_private_memory, allocate_public_memory, and allocate_external_memory), the free functions (free_private_memory, free_public_memory, and free_external_memory), the open functions (open_private_memory, open_protected_memory, and open_public_memory), and the close functions (close_private_memory, close_protected_memory, and close_public_memory) are called by the task , and the enter function (enter_memory_access_protocol) and the leave function (leave_memory_access_protocol) are called by the kernel  by itself.","The memory allocator  increases and decreases the kernel management regions , and allocates and frees a memory region within the kernel management region  to the task . The cache\/memory management unit  manages cache lines of the L1C  and the L2C . The memory allocator  and the cache\/memory management unit  are called from the state transition function  respectively.","Operation of each function that is included in the state transition function  in the first embodiment is explained next. In the explanation of the first embodiment, an address in a memory region on a virtual address space that is set accessible by the L1C\/L2C is simply expressed as an L1C\/L2C virtual address, an address in a memory region on a virtual address space that is set accessible by the L1UC\/L2C is simply expressed as an L1UC\/L2C virtual address, and an address in a memory region on a virtual address space that is set accessible by the L1UC\/L2UC is simply expressed as an L1UC\/L2UC virtual address.",{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 6","b":["29","27","1","1","2","1","29","27","3","4","29","4"]},{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 7","b":["29","22","28","11","27","12"]},{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 8","b":["29","21","21","22","21","29","27","23","24","29","25","29","29","25"]},{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 9","b":["29","31","28","32"]},{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 10","b":["29","41","41","42","41","29","27","43","24","28","44","45","29","46","29","46","29"]},"The caller task  can notify the address returned at S and the assigned argument \u201csize\u201d to other tasks  that belong to the same process and to tasks  that belong to other processes, thereby enabling all tasks  to recognize that this memory region is in the EXTERNAL state. Because the ATU  sets mapping differently between the processes, the address needs to be translated when it is exchanged between processes. The address can be translated by any method.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 11","b":["29","51","27","52"]},{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 12","b":["29","61","29","62","29","62"]},{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 13","b":["29","22","24","22","28","71","72","73","29","29","73"]},{"@attributes":{"id":"p-0129","num":"0128"},"figref":"FIG. 14","b":["29","81","82","29","29","82"]},{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 15","b":["29","22","28","91","92","93","29","29","93"]},{"@attributes":{"id":"p-0131","num":"0130"},"figref":"FIG. 16","b":["29","101","102","29","29","102"]},{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 17","b":["29","24","28","111","112","113","29","113","29"]},{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 18","b":["32","31","27","121","31","32","122","32","31"]},{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 19","b":["32","31","27","131","31","32","132","31","32"]},"An example of performing a state transition of a memory region by using the state transition function  that operates as described above is explained next.  is a flowchart for explaining an example of a state transition when a memory region is shared within a process.","First, a memory region is in the UNMANAGED state (S). When the kernel  calls the enter_memory_access_protocol function, the enter_memory_access_protocol function changes this memory region from the UNMANAGED state to the INVALID state (S). Next, to share data between tasks  within a certain process, one task  within this process calls the allocate_public_memory function, and the allocate_public_memory function changes the memory region from the INVALID state to the PUBLIC state (S). Next, one task  within this process calls the open_private_memory function, and the open_private_memory function changes the memory region to the PRIVATE state, and the task  which is the caller of the open_private_memory function performs a read\/write access to this memory region by the L1C\/L2C (S). During this period, other tasks  are not permitted to access, and therefore, the access is properly performed.","When the access ends, the task  which is the caller of the open_private_memory function calls the close_private_memory function, and the memory region is returned to the PUBLIC state (S). In this case, a cache line of the L1C  corresponding to this memory region is properly written back to the L2C , and is then invalidated. Any task  within this process is permitted to perform read\/write in the memory region that becomes in the PUBLIC state, by the L1UC\/L2C virtual address (S). Thereafter, the task  within this process calls the open_protected_memory function, and the open_protected_memory function changes the memory region to the PROTECTED state, and the task  which is the caller of the open_protected_memory function performs a read access by the L1C\/L2C (S). When the access ends, the task  that called the open_protected_memory function calls the close_protected_memory function, and the memory region is returned to the PUBLIC state (S). In this case, the cache line of the L1C  corresponding to the memory region is properly invalidated.","One task  within the same process calls the free_public_memory function, and the free_public_memory function returns the memory region to the INVALID state (S). The kernel  calls the leave_memory_access_protocol function, and the memory region becomes the UNMANAGED state (S), and ends a series of operation.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 21","b":["161","32","162","29","29","24","163","164"]},"Thereafter, one task  in a certain process calls the open_public_memory function to exclusively use for a shared purpose within this process, and the open_public_memory function changes the memory region to the PUBLIC state (S). In this state, all tasks  within the process to which the task  of the caller of the open_public_memory function belongs to are permitted to perform a read\/write access by the L1UC\/L2C virtual address (S). Thereafter, one task  within this process calls the open_private_memory function to exclusively use this memory region, and the open_private_memory function changes the memory region to the PRIVATE state (S). In this state, only the task  of the caller of the open_private_memory function is permitted to perform a read\/write access by the L1C\/L2C virtual address. After ending the access, the task  of the caller of the open_private_memory function calls the close_private_memory function, and the close_private_memory function returns the memory region to the PUBLIC state (S). In this case, the cache line of the L1C  corresponding to this memory region is properly written back to the L2C , and is then invalidated.","Thereafter, one task  within this process calls the open_protected_memory function, and the open_protected_memory function changes the memory region to the PROTECTED state, and the task  of the caller of the open_protected_memory function performs a read access by the L1C\/L2C (S). When the access ends, the task  of the caller of the open_protected_memory function calls the close_protected_memory function, and returns the memory region to the PUBLIC state (S). In this case, the cache line of the L1C  corresponding to this memory region is properly invalidated.","Thereafter, when the exclusive use by the process ends, one task  within this process calls the close_public_memory function, and the close_public_memory function returns the memory region to the EXTERNAL state (S). In this case, the cache line of the L2C  corresponding to this memory region is properly written back to the memory , and is then invalidated. When a certain task calls the free_external_memory function, the free_external_memory function returns the memory region to the INVALID state (S). When the kernel  calls the leave_memory_access_protocol function, the memory region becomes the UNMANAGED state (S), and the operation ends.","As explained above, according to the first embodiment, the memory region includes the kernel unit that permits the PRIVATE state in which the L1C\/L2C is allowed to read\/write by access, and one task  (the core ) is given the exclusive right of use, the PUBLIC state in which the L1UC\/L2C is allowed to read\/write by access, and one process is given the exclusive right of use, and the EXTERNAL state in which the L1UC\/L2UC is allowed to read\/write by access, and all tasks  (that is, all processes) are given the right of use, and that performs a transition between the PRIVATE state and the PUBLIC state and between the PUBLIC state and the EXTERNAL state. The kernel unit is configured to write back the corresponding L1C  to the L2C  when changing a memory region from the PRIVATE state to the PUBLIC state, and write back the corresponding L2C  to the memory region when changing a memory region from the PUBLIC state to the EXTERNAL state. Therefore, in the multicore processor system that includes the multicore processor in which plural cores each including a first cache form a cluster by sharing a second cache, the multicore processor system can share the memory region between the tasks , between the processes, and between the clusters, while holding consistency of the storage content of the first cache, the second cache, and the memory . That is, a multicore processor system of a cluster type can maintain consistency of the caches by software.","Further, because the kernel unit performs a transition between the PRIVATE state, the PUBLIC state, the EXTERNAL state, and the INVALID state, the kernel unit can allocate a memory region to a specific task, a specific process, or whole processes.","Further, because the kernel unit performs a transition between the PUBLIC state and the PROTECTED state, the kernel unit can read the memory from one or more tasks belonging to the same process at a high speed.","In the explanation of the first embodiment, the multicore processor system  does not check operation of each task  that is prohibited by the MAP (for example, the access operation that is prohibited in each state, and delivery of a memory region between tasks that is against the rule of a transition between states). When operation that is prohibited by the MAP is performed, consistency of the caches cannot be maintained.","To solve this problem, the state transition function  outputs each function by relating a state of a memory region after a transition to an identifier of the task  (or the process) that owns the right of use. It can be arranged such that when a function is called, whether a transition by this function is against the transition rule defined by the MAP, by referring to the output relationship. When operation that is against the transition rule is detected, a detected result can be output. There can be provided a mechanism that determines whether an access performed to the memory region is against a state of the memory region of an access destination, by referring to the relationship output by the state transition function .","The first embodiment can be applied not only to the multicore processor  that has plural clusters  each including plural cores , but also to a multicore processor that includes only one cluster  that includes plural cores .","According to the first embodiment, consistency of caches can be held in a physical memory region that has a shadow region. On the other hand, according to a second embodiment, consistency can be held in a physical memory region that has no shadow region, in which an access is permitted to only the L1 cache and the L2 cache.","A configuration of a multicore processor system according to the second embodiment is equal to that of the first embodiment, except the content of functions that are included in the state transition function , and therefore, a redundant explanation of the configuration excluding the functions included in the state transition function  is omitted.",{"@attributes":{"id":"p-0151","num":"0150"},"figref":"FIG. 22"},"(g) The UM_INVALID state","In this state, the kernel  can allocate a memory region. A memory region before allocation and after the memory is freed belongs to this state. In this state, a task cannot access the memory region at all.","(h) The UM_PRIVATE state","In this state, only a task that has changed a memory region to this state is permitted to perform a read\/write access by the L1C\/L2C. This access is achieved by accessing a virtual address that is mapped in a physical memory by the L1C\/L2C.","(i) The UM_PUBLIC state","In this state, tasks of which mapping set by the ATU  is the same, that is, tasks that belong to the same process, share data. However, a task cannot directly access a memory region in this state. Only tasks that belong to the same process are permitted to access, after changing a memory in this state to the UM_PRIVATE state or the UM_PROTECTED state.","(j) The UM_PROTECTED state","In this state, one or more tasks that belong to the same process and that have requested a transition to this state are permitted to perform a read access by the L1C\/L2C. A task is not permitted to perform a write access to a memory region in this state.","(k) The UM_EXTERNAL state","In this state, all tasks share data. However, a task is not permitted to directly access a memory region in this state. A task is permitted to access a memory region, after changing the memory region to the UM_PUBLIC state, and after a task that has the same memory address mapping as that of this task changes the memory region to the UM_PRIVATE state or the UM_PUBLIC state.","(l) The UNMANAGED state","The state is the same as the UNMANAGED state in the first embodiment.","A memory region that is included in the kernel management region  is in one of the UM_INVALID state, the UM_PRIVATE state, the UM_PUBLIC state, the UM_PROTECTED state, and the UM_EXTERNAL state. Transition of the UM_INVALID state can be made between this state and the UM_PUBLIC state, between this state and the UM_PRIVATE state, and between this state and the UM_EXTERNAL state. Transition of the UM_PUBLIC state can be made between this state and the UM_PRIVATE state, between this state and the UM_EXTERNAL state, and between this state and the UM_PROTECTED state. Within the kernel management region , consistency of caches can be held, by keeping a memory access based on the definitions of the UM_INVALID state, the UM_PRIVATE state, the UM_PUBLIC state, the UM_PROTECTED state, and the UM_EXTERNAL state and the transition rule of a transition between the states.","In the second embodiment, a memory region can be also changed between the UNMANAGED state and the UM_INVALID state. With this arrangement, the kernel management region  can be dynamically increased or decreased.","The state transition function  in the second embodiment is an API (Application Programming Interface) to perform a transition between the states defined above. The state transition function  includes the following 14 functions.","(15) allocate_um_private_memory (size_t size)","This is a function that secures a memory region in the UM_PRIVATE state of the size specified by the argument \u201csize\u201d.","(16) free_um_private_memory (void *addr, size_t size)","This is a function that frees a memory region in the UM_PRIVATE state that is specified by a header address \u201caddr\u201d and the argument \u201csize\u201d.","(17) allocate_um_public_memory (size_t size)","This is a function that secures a memory region in the UM_PUBLIC state of the size specified by the argument \u201csize\u201d.","(18) free_um_public_memory (void *addr, size_t size)","This is a function that frees a memory region in the UM_PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d.","(19) allocate_um_external_memory (size_t size)","This is a function that secures a memory region in the UM_EXTERNAL state of the size specified by the argument \u201csize\u201d.","(20) free_um_external_memory (void *addr, size_t size)","This is a function that frees a memory region in the UM_EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d.","(21) open_um_private_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_PUBLIC state to the UM_PRIVATE state.","(22) close_um_private_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_PRIVATE state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_PRIVATE state to the UM_PUBLIC state.","(23) open_um_protected_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_PUBLIC state to the UM_PROTECTED state.","(24) close_um_protected_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_PROTECTED state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_PROTECTED state to the UM_PUBLIC state.","(25) open_um_public_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_EXTERNAL state to the UM_PUBLIC state.","(26) close_um_public_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_PUBLIC state to the UM_EXTERNAL state.","(27) enter_um_memory_access_protocol (void *addr, size_t size)","This is a function that changes a memory region in the UNMANAGED state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UNMANAGED state to the UM_INVALID state.","(28) leave_um_memory_access_protocol (void *addr, size_t size)","This is a function that changes a memory region in the UM_INVALID state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_INVALID state to the UNMANAGED state.","The allocate functions (allocate_um_private_memory, allocate_um_public_memory, and allocate_um_external_memory), the free functions (free_um_private_memory, free_um_public_memory, and free_um_external_memory), the open functions (open_um_private_memory, open_um_protected_memory, and open_um_public_memory), and the close functions (close_um_private_memory, close_um_protected_memory, and close_um_public_memory) are called by the task , and the enter function (enter_um_memory_access_protocol) and the leave function (leave_um_memory_access_protocol) are called by the kernel  by itself.","Operation of each function that is included in the state transition function  in the second embodiment is explained next. In the explanation of the second embodiment, for physical memory regions that have no corresponding shadow spaces, only memory areas on a virtual address space that is set accessible by the L1C\/L2C is allocated. The address in a memory region on a virtual address space is simply expressed as an L1C\/L2C virtual address.",{"@attributes":{"id":"p-0197","num":"0196"},"figref":"FIG. 23","b":["29","27","181","181","182","181","29","27","183","29","184","29","184"]},{"@attributes":{"id":"p-0198","num":"0197"},"figref":"FIG. 24","b":["29","22","28","191","27","192"]},{"@attributes":{"id":"p-0199","num":"0198"},"figref":"FIG. 25","b":["29","27","201","201","202","201","29","27","203","29","204","29","29","204"]},"The caller task  can notify the memory region that is assigned by the address returned at  and the argument \u201csize\u201d, to other tasks  that belong to the same process, and these other tasks  that belong to the same process recognize this memory region as the memory region in the UM_PUBLIC state.",{"@attributes":{"id":"p-0201","num":"0200"},"figref":"FIG. 26","b":["29","27","211"]},{"@attributes":{"id":"p-0202","num":"0201"},"figref":"FIG. 27","b":["29","27","221","221","222","221","29","27","223","24","28","224","29","225","29","225","29"]},"The caller task  can notify the address returned at S and the specified argument \u201csize\u201d to other tasks  that belong to the same process and to tasks  that belong to other processes, thereby enabling all tasks  to recognize that this memory region is in the UM_EXTERNAL state. Because the ATU  sets mapping differently between the processes, the address needs to be translated when it is exchanged between processes. The address can be translated by any method.",{"@attributes":{"id":"p-0204","num":"0203"},"figref":"FIG. 28","b":["29","27","231"]},{"@attributes":{"id":"p-0205","num":"0204"},"figref":"FIG. 29","b":["29","29","241","29","241"]},{"@attributes":{"id":"p-0206","num":"0205"},"figref":"FIG. 30","b":["29","24","22","28","251","252","29","29","252"]},{"@attributes":{"id":"p-0207","num":"0206"},"figref":"FIG. 31","b":["29","261","29","29","261"]},{"@attributes":{"id":"p-0208","num":"0207"},"figref":"FIG. 32","b":["29","22","28","271","272","29","29","272"]},{"@attributes":{"id":"p-0209","num":"0208"},"figref":"FIG. 33","b":["29","281","29","29","281"]},{"@attributes":{"id":"p-0210","num":"0209"},"figref":"FIG. 34","b":["29","24","28","291","292","29","292","29"]},{"@attributes":{"id":"p-0211","num":"0210"},"figref":"FIG. 35","b":["32","31","27","301","31","32","302","32","31"]},{"@attributes":{"id":"p-0212","num":"0211"},"figref":"FIG. 36","b":["32","31","27","311","31","32","312","31","32"]},"An example of performing state transitions of a memory region by using the state transition function  that operates as described above is explained next.  is a flowchart for explaining an example of state transitions when a memory region is shared within a process.","First, a memory region is in the UNMANAGED state (S). When the kernel  calls the enter_um_memory_access_protocol function, the enter_um_memory_access_protocol function changes this memory region from the UNMANAGED state to the UM_INVALID state (S). Next, to share data between tasks  within a certain process, one task  within this process calls the allocate_um_public_memory function, and the allocate_um_public_memory function changes the memory region from the UM_INVALID state to the UM_PUBLIC state (S). Next, one task  within this process calls the open_um_private_memory function, and the open_um_private_memory function changes the memory region to the UM_PRIVATE state, and the task  of the caller of the open_um_private_memory function performs a read\/write access to this memory region by the L1C\/L2C (S). During this period, other tasks  are not permitted to access, and therefore, the access is properly performed.","When the access ends, the task  of the caller of the open_um_private_memory function calls the close_um_private_memory function, and the memory region is returned to the UM_PUBLIC state (S). In this case, cache lines of the L1C  corresponding to this memory region is properly written back to the L2C , and is then invalidated. An access to memory in the UM_PUBLIC state in this state is prohibited. Thereafter, other task  within this process calls the open_um_protected_memory function, and the open_um_protected_memory function changes the memory region to the UM_PROTECTED state, and the task  of the caller of the open_um_protected_memory function performs a read access by the L1C\/L2C (S). When the access ends, the task  that called the open_um_protected_memory function calls the close_um_protected_memory function, and the memory region is returned to the UM_PUBLIC state (S). In this case, the cache line of the L1C  corresponding to the memory region is properly invalidated.","The task  within the same process calls the free_um_public_memory function, and the free_um_public_memory function frees the memory region, and returns the memory region to the UM_INVALID state (S). The kernel  calls the leave_um_memory_access_protocol function, and the memory region becomes the UNMANAGED state (S), and ends a series of operation.",{"@attributes":{"id":"p-0217","num":"0216"},"figref":"FIG. 38","b":["331","32","332","29","24","333"]},"Thereafter, one task  in a certain process calls the open_um_public_memory function to exclusively use for a shared purpose within this process, and the open_um_public_memory function changes the memory region to the UM_PUBLIC state (S). In this state, all tasks within this process are prohibited to access yet. Thereafter, one task  within this process calls the open_um_private_memory function to exclusively use this memory region, and the open_um_private_memory function changes the memory region to the UM_PRIVATE state (S). In this state, only the task  of the caller of the open_um_private_memory function is permitted to perform a read\/write access by the L1C\/L2C virtual address. After ending the access, the task  of the caller of the open_um_private_memory function calls the close_um_private_memory function, and the close_um_private_memory function returns the memory region to the UM_PUBLIC state (S). In this case, the cache lines of the L1C  corresponding to this memory region are properly written back to the L2C , and is then invalidated.","Thereafter, one task  within this process calls the open_um_protected_memory function, and the open_um_protected_memory function changes the memory region to the UM_PROTECTED state, and the task  of the caller of the open_um_protected_memory function performs a read access by the L1C\/L2C (S). When the access ends, the task  of the caller of the open_um_protected_memory function calls the close_um_protected_memory function, and returns the memory region to the UM_PUBLIC state (S). In this case, the cache lines of the L1C  corresponding to this memory region is properly invalidated.","Thereafter, when the exclusive use by the process ends, one task  within this process calls the close_um_public_memory function, and the close_um_public_memory function returns the memory region to the UM_EXTERNAL state (S). In this case, the cache line of the L2C  corresponding to this memory region is properly written back to the memory , and is then invalidated.","Next, for another process to access this memory region, any task  within this process calls the open_um_public_memory function, and the open_um_public_memory function changes this memory region to the UM_PUBLIC state (S). However, because an address that indicates a memory in the UM_EXTERNAL state is different for each process, this relationship needs to be managed separately. Thereafter, the task  within this process performs a necessary access to this memory region, after suitably making transition of this memory region to the UM_PRIVATE state or the UM_PROTECTED state (S). After ending the process, the task  returns the memory region to the UM_PUBLIC state (S). After the access in the process ends, one task  within this process calls the close_um_public_memory function, and the close_um_public_memory function returns this memory region to the UM_EXTERNAL state (S). When any task  calls the free_um_external_memory function, the free_um_external_memory function frees the memory, and returns this memory region to the UM_INVALID state (S). When the kernel  calls the leave_um_memory_access_protocol function, the leave_um_memory_access_protocol function sets the memory region to the UNMANAGED state (S), and ends the operation.","As explained above, according to the second embodiment, the memory region includes the kernel unit that permits the UM_PRIVATE state in which the L1C\/L2C is allowed to read\/write by access, and one task  is given the exclusive right of use, the UM_PUBLIC state in which read\/write is prohibited, and one process is given the exclusive right of use, and the UM_EXTERNAL state in which read\/write is prohibited, and all tasks  (that is, all processes) are given the right of use, and that performs a transition between the UM_PRIVATE state and the UM_PUBLIC state and between the UM_PUBLIC state and the UM_EXTERNAL state. The kernel unit is configured to write back the corresponding L1C  to the L2C  when making transition of a memory region from the UM_PRIVATE state to the UM_PUBLIC state, and write back the corresponding L2C  to the memory region when making transition of a memory region from the UM_PUBLIC state to the UM_EXTERNAL state. Therefore, in the multicore processor system that includes the multicore processor in which plural cores each including a first cache form a cluster by sharing a second cache, the multicore processor system can share the memory region of the memory  between the tasks , between the processes, and between the clusters, while holding consistency of the storage content of the first cache, the second cache, and the memory , even in the memory  that does not have a shadow region.","Further, because the kernel unit performs a transition between the UM_PRIVATE state, the UM_PUBLIC state, the UM_EXTERNAL state, and the UM_INVALID state that is not allocated to any core , the kernel unit can allocate a memory region to a specific task , a specific process, or whole processes.","Further, because the kernel unit performs a transition between the UM_PUBLIC state and the UM_PROTECTED state in which the L1C\/L2C is permitted to perform a read only access and in which one or more tasks  that request belonging to the same process are given the right of use, the kernel unit can read the memory from one task at a high speed.","The second embodiment can be also applied to a multicore processor system having the memory  that includes both a memory region which includes a shadow region and a memory region which does not include a shadow region, by adding the functions (1) to (14) explained in the first embodiment to the state transition function .","The second embodiment can be also applied to a multicore processor that includes only one cluster  which includes plural cores , not only to the multicore processor  having plural clusters  each cluster including plural cores .","In the memory access protocol explained in the second embodiment, a task within any process is prohibited to access a memory that is used to be shared between processes, in the UM_EXTERNAL state. For a task to be able to access the memory, a task within any process needs to change a memory region to the UM_PRIVATE state or to the UM_PROTECTED state via the UM_PUBLIC state. During this period, none of tasks within other processes are permitted to access. This becomes a strict constraint that when there is read only data to be referred to in common by processes, this read only data cannot be referred to simultaneously from plural processes. In a third embodiment, to mitigate this constraint, more states are added to the MAP according to the second embodiment.","A configuration of a multicore processor system according to the third embodiment is equal to that of the second embodiment, except the content of functions that are included in the state transition function , and therefore, a redundant explanation of the configuration excluding the functions included in the state transition function  is omitted.",{"@attributes":{"id":"p-0229","num":"0228"},"figref":"FIG. 39"},"(m) The UM_FROZEN_EXTERNAL state","In this state, a memory region can be changed from the UM_EXTERNAL state, and a task within a certain process can perform a read only access. Other process is permitted to redundantly change a memory region that a certain process has changed to the UM_FROZEN_EXTERNAL state, to the UM_FROZEN_EXTERNAL state. A memory region that plural processes have set to this state remains in this UM_FROZEN_EXTERNAL state until when all of these processes return the memory region to the UM_EXTERNAL state.","The state transition function  according to the third embodiment includes the following two functions, in addition to the functions explained in (15) to (28).","(29) freeze_um_external_memory (void *addr, size_t size)","This is a function that enables the caller task  or the task  that belongs to the same process as that of this caller task  to use a memory region in the UM_EXTERNAL state or the UM_FROZEN_EXTERNAL that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, as a memory region in the UM_FROZEN_EXTERNAL state.","(30) melt_um_frozen_external_memory (void *addr, size_t size)","This is a function that returns a memory region that is used in the UM_FROZEN_EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_FROZEN_EXTERNAL state to the UM_EXTERNAL state. When plural processes are present that use a memory region in the UM_FROZEN_EXTERNAL state, when this function is called from all of these plural processes, this function returns the memory region from the UM_FROZEN_EXTERNAL state to the UM_EXTERNAL state.","In the third embodiment, the task  and the kernel  can recognize a memory region that is in the UM_FROZEN_EXTERNAL state and a number of processes that use this memory region as a memory region in the UM_FROZEN_EXTERNAL state. For example, in the memory , a table is prepared that relates between information (for example, the header physical address and the size) that specifies a memory region in the UM_FROZEN_EXTERNAL state and a list of identifiers of processes that are using this memory region as a memory region in the UM_FROZEN_EXTERNAL state. The task  and the kernel  refer to this table.","Operation of each function that is included in the state transition function  in the third embodiment is explained next. Because the operation of each function explained in (15) to (28) is the same as that of the second embodiment, their explanation is omitted, and only the operations of the freeze_um_external_memory function and the melt_um_frozen_external_memory function are explained.",{"@attributes":{"id":"p-0239","num":"0238"},"figref":"FIG. 40","b":["29","351","29","29","29","351"]},{"@attributes":{"id":"p-0240","num":"0239"},"figref":"FIG. 41","b":["29","22","21","28","361","25","362","25","362","24","28","363","364","25","362","363","363","29"]},"An example of performing state transitions of a memory region by using the state transition function  that operates as described above is explained next.  is a flowchart for explaining an example of a state transition to perform a read only access from plural processes.","Processes that are the same as those at S to S in  are performed at S to S in . When the task  that belongs to a certain process (a process A) calls the freeze_um_external_memory function by specifying the memory region in the UM_EXTERNAL state, the freeze_um_external_memory function sets the assigned memory region to the UM_FROZEN_EXTERNAL state, and permits all tasks  that belong to the process A to perform a read only access to the memory region (S). When the task  that belongs to a process B that is different from the process A calls the freeze_um_external_memory function by specifying the memory region, the freeze_um_external_memory function permits all tasks  that belong to the process A and the process B to perform a read only access to the memory region (S). A virtual address for specifying this memory region is different for each process. Therefore, a relationship of the virtual address for each process needs to be separately managed.","When the task  that belongs to a process C that is different from the process A and the process B calls the freeze_um_external_memory function by specifying the memory region, the freeze_um_external_memory function permits all tasks  that belong to the process A, the process B, and the process C to perform a read only access to the memory region (S).","Thereafter, after the process B ends the access, when the task  that belongs to the process B calls the melt_um_frozen_external_memory function, the melt_um_frozen_external_memory function prohibits all tasks  that belong to the process B to access the memory region (S). In this case, the melt_um_frozen_external_memory function invalidates the corresponding cache line from the L1C  of the cores  that belong to the process B. When the process A and the process C belong to the cluster  that is different from that of the process B, the L2C  is also invalidated. At this time, in addition to the process B, there is a process that is using the memory region in the UM_FROZEN_EXTERNAL state. Therefore, even after the process at , the memory region is still recognized as a memory region in the UM_FROZEN_EXTERNAL state.","Thereafter, after the process A ends the access, when the task  that belongs to the process A calls the melt_um_frozen_external_memory function, the melt_um_frozen_external_memory function prohibits all tasks  that belong to the process A to access the memory region (S). In this case, the melt_um_frozen_external_memory function invalidates the corresponding cache lines from the L1C  of the cores  that belong to the process A. When the process C belongs to the cluster  that is different from that of the process B, the L2C  is also invalidated. At this time, in addition to the process A, there is a process that is using the memory region in the UM_FROZEN_EXTERNAL state. Therefore, even after the process at S, the memory region is still recognized as a memory region in the UM_FROZEN_EXTERNAL state.","Thereafter, after the process C ends the access, when the task  that belongs to the process C calls the melt_um_frozen_external_memory function, the melt_um_frozen_external_memory function prohibits all tasks  that belong to the process C to access the memory region. Because there is no other process that is using the memory region in the UM_FROZEN_EXTERNAL state, this memory region is returned to the UM_EXTERNAL state (S). In this case, the melt_um_frozen_external_memory function invalidates the corresponding cache line from the L1C  of the cores  that belong to the process C and the L2C  of the cluster  to which the process C belongs.","Thereafter, processes that are the same as those at S and S are performed at S and S, and a series of process ends.","As explained above, according to the third embodiment, because the UM_FROZEN_EXTERNAL state in which the L1C\/L2C is permitted to perform a read only access to requested one or more processes is added to the MAP, plural processes can simultaneously read the memory region that has no shadow region, by using a cache. Therefore, a data exchange between the processes becomes simple. Also, a data exchange within a single process becomes simple.","According to the third embodiment, the UM_FROZEN_EXTERNAL state is added to the MAP according to the second embodiment. Meanwhile, a MAP according to a fourth embodiment is configured to have similar states added to the MAP of the first embodiment.","A configuration of a multicore processor system according to the fourth embodiment is equal to that of the first embodiment, except the content of functions that are included in the state transition function , and therefore, a redundant explanation of the configuration excluding the functions included in the state transition function  is omitted.",{"@attributes":{"id":"p-0251","num":"0250"},"figref":"FIG. 43"},"(n) The FROZEN_EXTERNAL state","In this state, a memory region can be changed from the EXTERNAL state, and a task within a certain process can perform a read only access by the L1C\/L2C. Other process is also permitted to redundantly change a memory region that a certain process has changed to the FROZEN_EXTERNAL state, to the FROZEN_EXTERNAL state. A memory region that plural processes have set to this state remains in this FROZEN_EXTERNAL state until when all of these processes return the memory region to the EXTERNAL state.","The state transition function  according to the fourth embodiment further includes the following two functions, in addition to the functions explained in (1) to (14).","(31) freeze_external_memory (void *addr, size_t size)","This is a function that enables the caller task  or the task  that belongs to the same process as that of this caller task  to use a memory region in the EXTERNAL state or the FROZEN_EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, as a memory region in the FROZEN_EXTERNAL state.","(32) melt_frozen_external_memory (void *addr, size_t size)","This is a function that returns a memory region that is used in the FROZEN_EXTERNAL state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the FROZEN_EXTERNAL state to the EXTERNAL state. When plural processes are present that use a memory region in the FROZEN_EXTERNAL state, when this function is called from all of these plural processes, this function returns the memory region from the FROZEN_EXTERNAL state to the EXTERNAL state.","In the fourth embodiment, the task  and the kernel  can also recognize a memory region that is in the FROZEN_EXTERNAL state and a number of processes that use this memory region as a memory region in the FROZEN_EXTERNAL state.","Operation of each function that is included in the state transition function  in the fourth embodiment is explained next. Only the operations of the freeze_external_memory function and the melt_frozen_external_memory function are explained here.",{"@attributes":{"id":"p-0261","num":"0260"},"figref":"FIG. 44","b":["29","391","392","29","29","29","392"]},{"@attributes":{"id":"p-0262","num":"0261"},"figref":"FIG. 45","b":["29","24","28","401","25","402","25","402","24","28","403","404","405","25","402","403","405","29"]},"An example of performing state transitions of a memory region by using the state transition function  that operates as described above is explained next.  is a flowchart for explaining an example of a state transition to perform a read only access from plural processes.","First, a memory region is in the UNMANAGED state (S). When the kernel  calls the enter_memory_access_protocol function, the enter_memory_access_protocol function changes this memory region from the UNMANAGED state to the INVALID state (S). Next, to share data between processes, a certain task  calls the allocate_external_memory function, and the allocate_external_memory function changes the memory region from the INVALID state to the EXTERNAL state, after invalidating the corresponding cache line of the L2C  (S). In this state, any task in any process is permitted to access the L1UC\/L2UC.","When the task  that belongs to a certain process (the process A) calls the freeze_external_memory function by specifying the memory region in the EXTERNAL state, the freeze_external_memory function changes the assigned memory region to the FROZEN_EXTERNAL state, and permits all tasks  that belong to the process A to perform a read only access to the memory region by the L1C\/L2C (S). Tasks  that belong to a process other than the process A are permitted to perform a read only access by the L1UC\/L2UC.","When the task  that belongs to the process B that is different from the process A calls the freeze_external_memory function by specifying the memory region, the freeze_external_memory function permits all tasks  that belong to the process A and the process B to perform a read only access to the memory region by the L1C\/L2C (S). A virtual address for specifying this memory region is different for each process. Therefore, a relationship of the virtual address for each process needs to be separately managed.","When the task  that belongs to the process C that is different from the process A and the process B calls the freeze_external_memory function by assigning the memory region, the freeze_external_memory function permits all tasks  that belong to the process A, the process B, and the process C to perform a read only access to the memory region by the L1C\/L2C (S).","Thereafter, after the process B ends the access, when a task  that belongs to the process B calls the melt_frozen_external_memory function, the melt_frozen_external_memory function prohibits all tasks  that belong to the process B to access the memory region by the L1C\/L2C and permits the L1UC\/L2UC to perform a read only access this memory region (S). In this case, the melt_frozen_external_memory function invalidates the corresponding cache lines of the L1C  of the cores  that belong to the process B. When the process A and the process C belong to the cluster  that is different from that of the process B, the L2C  is also invalidated. At this time, in addition to the process B, there is a process that is using the memory region in the FROZEN_EXTERNAL state. Therefore, even after the process at S, the memory region is still recognized as a memory region in the FROZEN_EXTERNAL state.","Thereafter, after the process A ends the access, when a task  that belongs to the process A calls the melt_frozen_external_memory function, the melt_frozen_external_memory function prohibits all tasks  that belong to the process A to access the memory region by the L1C\/L2C, and permits the L1UC\/L2UC to perform a read only access this memory region (S). In this case, the melt_frozen_external_memory function invalidates the corresponding cache lines of the L1C  of the cores  that belong to the process A. When the process C belongs to the cluster  that is different from that of the process B, the L2C  is also invalidated. At this time, in addition to the process A, there is a process that is using the memory region in the FROZEN_EXTERNAL state. Therefore, even after the process at S, the memory region is still recognized as a memory region in the FROZEN_EXTERNAL state.","Thereafter, after the process C ends the access, when a task  that belongs to the process C calls the melt_frozen_external_memory function, the melt_frozen_external_memory function prohibits all tasks  that belong to the process C to access the memory region by the L1C\/L2C. Because there is no other process that is using the memory region in the UM_FROZEN_EXTERNAL state, this memory region is returned to the EXTERNAL state (S). That is, all tasks  are permitted to perform a read\/write access to the memory region by the L1UC\/L2UC. In this case, the melt_frozen_external_memory function invalidates the corresponding cache lines of the L1C  of the cores  that belongs to the process C and the L2C  of the cluster  to which the process C belongs.","Thereafter, processes that are the same as those at S and S are performed at S and S, and a series of process ends.","As explained above, according to the fourth embodiment, because the FROZEN_EXTERNAL state in which the L1C\/L2C is permitted to perform a read only access to requested one or more processes is added to the MAP, plural processes can simultaneously read the memory region by using the L1C\/L2C. Therefore, a data exchange between the processes can be performed at a high speed. Also, a data exchange within a single process can be performed at a high speed.","According to a fifth embodiment, a MAP is configured such that the MAP in the first embodiment additionally has the FROZEN_PUBLIC state to which a memory region can be changed from the PUBLIC state and in which tasks that belong to the same process can perform a read access.","A configuration of a multicore processor system according to the fifth embodiment is equal to that of the first embodiment, except the content of functions that are included in the state transition function , and therefore, a redundant explanation of the configuration excluding the functions included in the state transition function  is omitted.",{"@attributes":{"id":"p-0275","num":"0274"},"figref":"FIG. 47"},"(o) The FROZEN_PUBLIC state","In this state, a memory region can be changed from the PUBLIC state, and all tasks  within the same process can perform a read only access by the L1C\/L2C.","The state transition function  according to the fifth embodiment further includes the following two functions, in addition to the functions explained in (1) to (14).","(33) freeze_public_memory (void *addr, size_t size)","This is a function that changes a memory region that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the PUBLIC state to the FROZEN_PUBLIC state. Only a task  that belongs to the process that is permitted to access in the PUBLIC state can call this function.","(34) melt_frozen_public_memory (void *addr, size_t size)","This is a function that changes a memory region that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the FROZEN_PUBLIC state to the PUBLIC state.","Operation of each function that is included in the state transition function  in the fifth embodiment is explained next. Only the operations of the freeze_public_memory function and the melt_frozen_public_memory function are explained here.",{"@attributes":{"id":"p-0284","num":"0283"},"figref":"FIG. 48","b":["29","431","432","29","29","29","432"]},{"@attributes":{"id":"p-0285","num":"0284"},"figref":"FIG. 49","b":["29","22","29","28","441","442","443","29","29","29","443"]},"As explained above, according to the fifth embodiment, because the FROZEN_PUBLIC state in which the tasks that belong to the same process are permitted to perform a read only access by the L1C\/L2C is added to the MAP, plural tasks that belong to the same process can simultaneously read by using the L1C and the L2C. Therefore, the tasks can exchange data within the process at a high speed.","Further, because a memory region can be directly changed from the PUBLIC state to the FROZEN_PUBLIC state without via the EXTERNAL state, when data is desired to be shared within the same process, data can be shared more simply than in the fourth embodiment.","According to a sixth embodiment, a MAP is configured such that the MAP in the second embodiment additionally has the UM_FROZEN_PUBLIC state to which a memory region can be changed from the UM_PUBLIC state and in which tasks that belong to the same process can perform a read access.","A configuration of a multicore processor system according to the sixth embodiment is equal to that of the second embodiment, except the content of functions that are included in the state transition function , and therefore, a redundant explanation of the configuration excluding the functions included in the state transition function  is omitted.",{"@attributes":{"id":"p-0290","num":"0289"},"figref":"FIG. 50"},"(p) The UM_FROZEN_PUBLIC state","In this state, a memory region can be changed from the UM_PUBLIC state, and all tasks  within the same process can perform a read only access by the L1C\/L2C.","The state transition function  according to the sixth embodiment further includes the following two functions, in addition to the functions explained in (15) to (28).","(35) freeze_um_public_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_PUBLIC state to the UM_FROZEN_PUBLIC state. Only the task  that belongs to the process that is permitted to share in the UM_PUBLIC state can call this function.","(36) melt_um_frozen_public_memory (void *addr, size_t size)","This is a function that changes a memory region in the UM_FROZEN_PUBLIC state that is specified by the header address \u201caddr\u201d and the argument \u201csize\u201d, from the UM_FROZEN_PUBLIC state to the UM_PUBLIC state.","Operation of each function that is included in the state transition function  in the sixth embodiment is explained next. Only the operations of the freeze_um_public_memory function and the melt_um_frozen_public_memory function are explained here.",{"@attributes":{"id":"p-0299","num":"0298"},"figref":"FIG. 51","b":["29","451","29","29","29","451"]},{"@attributes":{"id":"p-0300","num":"0299"},"figref":"FIG. 52","b":["29","22","29","28","461","462","29","29","29","462"]},"As explained above, according to the sixth embodiment, because the UM_FROZEN_PUBLIC state in which the tasks that belong to the same process are permitted to perform a read only access by the L1C\/L2C is added to the MAP, plural tasks that belong to the same process can simultaneously read by using the L1C and the L2C. Therefore, the tasks can exchange data within the same process at a high speed.","Further, because a memory region can be directly changed from the UM_PUBLIC state to the UM_FROZEN_PUBLIC state without via the UM_EXTERNAL state, when data is desired to be shared within one process, data can be shared more simply than in the third embodiment.","As explained above, according to the first to sixth embodiments, the multicore processor system  of a cluster type can maintain consistency of the caches (the L1C , the L2C ) by software.","While certain embodiments have been described, these embodiments have been presented by way of example only, and are not intended to limit the scope of the inventions. Indeed, the novel embodiments described herein may be embodied in a variety of other forms; furthermore, various omissions, substitutions and changes in the form of the embodiments described herein may be made without departing from the spirit of the inventions. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of the inventions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 52"}]},"DETDESC":[{},{}]}
