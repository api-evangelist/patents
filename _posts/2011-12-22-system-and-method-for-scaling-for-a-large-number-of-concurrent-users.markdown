---
title: System and method for scaling for a large number of concurrent users
abstract: A computer-implemented method for providing a stateful computer application to a multitude of users. The method may comprise generating a session identification (e.g., a primary key) for a user session for one user and retrieving a state representation using the session identification. The state of the stateful computer application may be described by a set of user-specific session variables that may be reconstructed from information contained in the state representation. The method may further comprise restoring the set of user-specific session variables using the retrieved state representation and calling functional computing logic based thereon. The functional computing logic may comprise the code of the stateful computer application and the call may provide an updated set of user-specific session variables. Upon completion of functions performed by the called functional computing logic, an updated state representation may be assembled from the updated set of user-specific session variables and stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08751469&OS=08751469&RS=08751469
owner: SAP AG
number: 08751469
owner_city: Walldorf
owner_country: DE
publication_date: 20111222
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of U.S. application Ser. No. 12\/976,175, filed Dec. 22, 2010 (pending), and also claims priority to the European Patent Application No. 11 194 610.9, filed Dec. 20, 2011, the contents of both applications are incorporated herein by reference.","The present invention relates to a system and method for providing a stateful computer application to a multitude of users, as well as a computer program product.","Certain computer applications, such as SAP\u00ae ABAP\u2122 applications, are \u201cstateful\u201d applications in which a state of a user session is maintained as a collection of user-specific session variables in main memory of the application server. The set of user-specific session variables may even be unique to the specific session. Stateful applications are efficient and provide excellent performance when there are a known, or at least predictable, number of concurrent users allowing appropriate HW sizing. In those situations, stateful applications handle in particular very high frequent requests of relatively short duration which might even operate on very large sessions with great efficiency. However, in environments such as cloud computing and software-as-a-service, where the number of concurrent users can range from a few to many, and is typically an unknown quantity, stateful applications may not provide the same efficiency and may lack performance due to the memory constraints. Also, the user sessions in cloud computing and software-as-a-service provided activities may typically experience rather infrequent requests (i.e. long think times), so the user session reserves unutilized computing resources for a longer period of time, which can contribute to the congestion and inefficient use of computing and memory resources.","Computer applications that are \u201cstateless\u201d are better suited for use in the cloud computing and software-as-a-service environment. A stateless application is a computer application that does not allocate dedicated main memory of the application server for maintaining the state of a user session (in between user requests), but rather uses external storage, such as a database, to maintain the state of a user session in a persistent memory. It would be beneficial if stateful applications could be transformed into stateless applications to take advantage of a \u201ccloud computing\u201d environment.","The present invention provides for a method for providing a stateful computer application to a multitude of users, a system for providing a stateful computer application to a multitude of users and a computer program product.","The invention is described by the independent claims. Preferred embodiments are described in the dependent claims.","The invention relates to a method for providing a stateful computer application to a multitude of users, the method comprising for a given user of the plurality of users:\n\n","Embodiments of the invention may have the advantage that a stateful application may be run on a stateless server system or may be run on a stateful server system but behaving like a stateless application. Embodiments may take existing stateful applications, for example web-based applications such as ABAP applications, and transform them into a stateless application. Thus, the advantages of stateful applications can be combined with the advantages of stateless applications. The present invention permits to transform the stateful application into a stateless application. This can be generally done by applying a combination of techniques, such as stateless consistency handling, and manual state management pattern, to web applications and batch jobs, respectively. To the user of the application, the application still appears to be stateful, whereas internally the stateful application is transformed and benefits the combined advantages of a stateful and stateless application.","Since a state representation is used, the amount of data which needs to be stored is kept at a minimum level. Based on the session identification, for a given user session the respective state representation can be obtained from a storage. The state representation comprises information permitting to reconstruct a set of user-specific session variables. These variables may comprise any variables which were used in the respective session. Thus, reconstructing these variables can be illustrated as resuming the execution of a session of a stateful application which was suspended for a period of time in a highly efficient and flexible manner.","It has to be noted that typically, the nature of a stateful application is that all variables necessary to maintain a session of this application need to be kept in a memory system of the stateful application, whereas a stateless computer system does not permit to maintain the state of a session in a main memory. Thus, the general architectures of these two concepts are strongly different. Nevertheless, the above described method may permit to combine the advantages of stateless and stateful applications: resources on the stateful server may be blocked or reserved only while the request is actually processed. After the request processing is finished (i.e. a response is sent to the client), all resources in particular the user context (i.e. the system variables and application variables incl. global and static variables) are freed and\/or returned for reuse with other requests.","In accordance with an embodiment of the invention, retrieving the state representation comprises retrieving a cookie related to the user from the storage using the session identification, wherein the state representation is comprised in the cookie. For example, server side cookies are used to store the state representation. Cookie storage is particularly advantageous since any existing web-server session identification techniques can be used in order to implement the invention. Thus, this simplifies the implementation process.","In accordance with an embodiment of the invention, the stateful computer application is an application of a set of stateful computer applications, wherein the generation of the session identification is performed specific to the stateful computer applications of the set of stateful computer applications.","In accordance with an embodiment of the invention, the method further comprises providing a result of the calling by a user interface to the user.","In accordance with an embodiment of the invention, the functions performed by the functional computing logic are performed by a stateful computer system. For example, the session identification is generated by the stateful computer application and the restoring of the set of user-specific session variables is performed by the stateful computer system.","The implementation of the above described method may either be done by modifying the coding of the stateful application, i.e. a transformation of the stateful application into an application behaving like a stateless application. Or the stateful application can be maintained, while the application server is modified. The first approach does not require changes to the stateful server (kernel etc.) whereas the second one does. The advantage of the second approach is that it minimizes the number of necessary stateful application modifications compared with the first approach. The first approach does not require server changes but depends on new framework modules as addon.","In accordance with an embodiment of the invention, the method further comprises transforming the stateful application into a transformed application by a recoding process, wherein the transformed application is able to perform the method. This is the first approach.","In accordance with an embodiment of the invention, the functional computing logic comprises the code of the stateful computer application in an unmodified manner. This is the second approach.","Herein, recoding can be understood as for example exchanging individual statements in the original coding of the stateful application by statements which make the stateful application behaving stateless. An example is given below with respect to the substitution of locking functions by the stateless locking framework module. Another example is given below with respect to the stateless update task framework.","It has to be noted, that these frameworks can either be implemented using a recoding process of the stateful application or by providing addons (i.e. modules) to the server which interpret the original coding of the stateful application in such a manner that as a result the behavior when executed is the behavior of a stateless application. While the first approach requires modification of the code, the second approach requires modification of the server, for example its firmware.","In accordance with an embodiment of the invention, the stateful computer system comprises a stateless locking framework module, wherein in case the calling of the functional computing logic comprises calling of locking functions of the stateful computer application, the stateless locking framework module substitutes the locking functions of the stateful computer application by substitute locking functions, wherein the substitute locking functions are adapted for providing database locks on data resources requested by the calling of the functional computing logic. Thus, in the second approach, the stateless locking framework module may be provided which enables to implement a stateless-like locking behavior with the stateful application. This \u2018upgrades\u2019 the stateful computer system which is normally not able to implement the stateless-like locking behavior.","In accordance with an embodiment of the invention, the data resources are comprised in an application database.","In accordance with an embodiment of the invention, the database locks are stored in a lock storage database, wherein the database locks are stored associated with the session identification, the name of the computer running the stateful computer application and a timestamp as a compound primary key, wherein the timestamp comprises the point in time when the respective database lock was set. This may have the advantage, that lock tracking can be ensured at high accuracy. Typically, the session identification is not a globally unique ID. However, by combining the session ID with the name of the computer running the stateful computer application and a timestamp as a compound primary key, the uniqueness of the key can be guaranteed. Further, the timestamp may be used as an additional diversifying element which ensures uniqueness of the key.","In accordance with an embodiment of the invention, the stateful computer system comprises a stateless update task framework module, wherein the stateless update task framework module is queuing predetermined statements of the code of the stateful computer application, wherein the queued statements are executed upon reception of a predefined execution statement, wherein the queuing is performed in a database table, wherein the database table is maintainable over the whole user session. Thus, even though a queuing of statements may not be provided for stateless applications, nevertheless the stateful application which now behaves like a stateless application is able to use the queuing feature.","In accordance with an embodiment of the invention, the stateful computer system comprises a clean-up job module, wherein the clean-up job module is removing the database locks on data resources previously set by the stateless locking framework module, wherein the removal of the database locks is performed after a timeout, wherein the timeout is determined for each database lock from a predetermined time period and the timestamp. Preferably, the clean-up job module regularly checks for the locks on the data resources. This can be done in regular time intervals. In case the lock was already maintained for a longer period of time than a maximum predefined time interval calculated from predetermined time period and the timestamp of the lock, the lock is released. Also, any existing state representation related to the user, session and computer system may be deleted. This permits to clean-up the system. The number of active locks and state representations is minimized thus further increasing the number of users which can be potentially served with the computer system.","In another aspect, the invention relates to a computer program product comprising computer executable instructions to perform the above described method.","In another aspect, the invention relates to a computer system for providing a stateful computer application to a multitude of users, the system being adapted for performing the following steps for a given user of the plurality of users:\n\n","In another aspect, the invention relates to A method for transforming a stateful computer application to a stateless application to facilitate scaling to a large number of concurrent users of the computer system, comprising:\n\n","In accordance with an embodiment of the invention, the method further comprises generating a new session identification for each of a plurality of users of a different computer application while the previous session identification remains active.","In accordance with an embodiment of the invention, the session identification is generated by a stateful computer application, and the user context is restored by a stateless computer application.","In accordance with an embodiment of the invention, the stateless computer application is a business page server (BSP) application.","In another aspect, the invention relates to a computer system for transforming a stateful computer application to a stateless application to facilitate scaling a computer system to a large number of concurrent users, comprising a terminal for receiving inputs and outputting data; a database for storing data; and an application server having a processor configured to:\n\n","In accordance with an embodiment of the invention, the processor is further configured to generate a new session identification for each of a plurality of users of a different computer application having different functional computing logic while the previous session identification remains active.","In accordance with an embodiment of the invention, the session identification is generated by a stateful computer application, and the user context is restored by a stateless computer application.","In accordance with an embodiment of the invention, the stateless computer application is a business page server application.","In another aspect, the invention relates to a machine-readable storage medium embodied with program instructions for causing a computer processor to execute a method for scaling a computer system to a large number of concurrent users, the method comprising:\n\n","In accordance with an embodiment of the invention, the method further comprises generating a new session identification for each of a plurality of users of a different computer application having different functional computing logic while the previous session identification remains active.","In accordance with an embodiment of the invention, the session identification is generated by a stateful computer application, and the user context is restored by a stateless computer application.","In accordance with an embodiment of the invention, the stateless computer application is a business page server application executing on a processor.","In another aspect, the invention relates to a method for substituting a stateless implementation for a stateful implementation to provide further functionality to scale a computer application for use by a large number of users, comprising:\n\n","In another aspect, the invention relates to a system for substituting a stateless implementation for a stateful implementation to provide further functionality to scale a computer application for use by a large number of users, comprising a terminal for receiving inputs and outputting data; a database for storing data; and an application server having a processor configured to:\n\n","In another aspect, the invention relates to a machine-readable storage medium embodied with program instructions for causing a computer processor to execute a method for scaling a computer system to a large number of concurrent users, the method comprising:\n\n","Thus, the disclosed subject matter relates to a system and method for scaling of a computer system of limited hardware resources from a small number of concurrent users to a large number of concurrent users. In an embodiment, the disclosed subject matter relates to a software architecture for scaling to a large number of concurrent users using limited hardware resources by transforming the state management and consistency handling of traditional computer programs, such as ABAP\u2122 programs.","Embodiments may take existing stateful web-based applications, such as ABAP applications, and transform them into a stateless application by applying a combination of techniques, such as stateless consistency handling, and manual state management pattern, to web applications and batch jobs, respectively.","Described herein are embodiments of a system, a machine-readable storage medium, and a method for transforming a stateful computer application to a stateless application so a large number of concurrent users may use limited hardware resources. In an exemplary method, a processor may generate a session identification for a user session of each of a plurality of users of the computer application. Cookies related to each of the plurality of users may be retrieved from external storage using the session identification (ID). A user context may be restored for each of the plurality of users of the computer application by using the retrieved cookies. The user context may be the \u201cmain memory content\u201d that the application uses to process a request, and includes local data structures, user input, caches, and perhaps related database information. Functional computing logic, may be called based on the restored user context. A state representation subset of the user context may be assembled afterwards. The state representation may be the portions of the user context that are sufficient to recreate the full user context. The state representative may be understood as a compressed version of the user context. For example, the \u201cuser context\u201d\u2014of for example ABAP applications\u2014is made up out of system variables and application variables (e.g. global and static variables). A \u201cstate representation\u201d is a subset of the user context which is sufficient to rebuild the user context.","Upon completion of functions performed by the called functional computing logic, the assembled state representation may be stored as a cookie for each of the plurality of users in external storage, in which case, the session ID may be a primary key. Based on the user context, and data from the accessed database, HTML code may be generated by a user interface layer.","Embodiments may provide a system that may include a user terminal, a database, and an application server. The user terminal may receive inputs and output data. The database may store data. The application server may have a processor configured to generate a session identification for a user session of each of a plurality of users of the computer application. The processor may retrieve cookies related to each of the plurality of users from external storage using the session identification. A user context for each of the plurality of users of the computer application may be restored by using the retrieved cookies. Functional computing logic may be called based on the restored user context. A state representation subset of the user context may be assembled by the processor. Upon completion of functions performed by a processor according to the called functional computing logic, the assembled state representation may be stored as a cookie for each of the plurality of users in external storage. When storing the assembled state representation, the session ID may be a primary key. Based on the user context, and data from the accessed database, HTML code may be generated by a user interface.","Also, described embodiments provide a machine-readable storage medium embodying computer program instructions for implementing a method for transforming a stateful computer application to a stateless application so a large number of concurrent users may use limited hardware resources.","Terms used in the disclosure include: \u201cState storage\u201d that may refer to persistent storage that holds the server side cookies; an \u201capplication database\u201d that may refer to the database (DB) used as persistence storage of the application; a \u201cuser context\u201d, such as in ABAP applications, may include system variables and application variables (e.g. global and static variables); a \u201cstate representation\u201d may be a subset of the full user context that is sufficient to rebuild the user context; and a \u201cdialog step\u201d may be a single request by the system to a user. It should be understood that the claimed embodiments may refer to any stateful application executing on a stateful server, but, for ease of explanation, reference to a specific example of an ABAP application executing on a server, such as an ABAP server, may be made. Other examples include two tier applications which may be converted into Rich Internet Application (RIA) internet applications by separating UI from computation logic tier so that the UI tier runs in the browser and the computation logic tier runs on the application server. These applications may employ programming environments like Microsoft .Net and Java. Functional computing logic may be executed by a processor to provide a specific operator on data and may encompass any number of processes, such as invoicing, accounting, human resources and the like.","A stateless pattern may refer to stateless request processing performed on a server, such as an stateful ABAP server. Stateless request processing may occur when a computer application that does not allocate main memory, but rather may use external storage, such as a database, to maintain the state of the user session in persistent memory in between dialog steps. In addition, the term \u201cstateless\u201d may mean that resources on the server are blocked or reserved only while the request is actually processed. After the server finishes the request processing (i.e. a response is sent to the client), all resources, in particular, the user context may be freed or returned for reuse with other requests.",{"@attributes":{"id":"p-0056","num":"0110"},"figref":["FIG. 1","FIG. 1"],"b":["105","103"]},"As illustrated in the stateless pattern of , different actions may take place to accomplish the transformations.","The working principle of the stateless pattern is illustrated in . The implementing computer system may include an application server , a state storage  and an application database (DB) . The application server  may include a computer application . The computer application  may include a user interface (UI) layer  and a functional computing logic layer . The user interface layer  may cause a graphical user interface to be presented on a workstation . The respective layers  and  may include modules containing software code executable by a processor in workstation . In the process  of , a request issued from a browser under control of a processor executing on a workstation  may be received by the UI layer  at step . The request may include data related to the user (e.g., password, logon ID, and the like). The functional computing logic layer  may be executable code related to a functional computer process such as invoicing, human resources management and\/or the like. However, the functional computing logic layer log can be related to any suitable process, such as file management.","The process  may authenticate the user via the UI layer  executing on the computer processor, and generate a session ID. The session ID may be generated by a UI framework (e.g. the Business Server Pages (BSP) application framework) executing on the application server  and in combination with processing at the UI layer . The processor executing the UI layer , using the session ID, may retrieve at step  cookies associated with the data of the session ID from, for example, the state storage . The state storage  may be any data storage capable of storing the server side cookies and accessible by the processor. Since the user session ID may be a small amount of data and may be easily passed between functions within the application server , the user session ID may be used as a primary key when storing the cookie in state storage .","The processor may use the UI layer  to restore a user context (or state) from a state representation derived from the cookies. As mentioned above, the user context may be made up of system and application variables. Since system variables (SY variables) may not be set by the application directly, the components of the application (functional computing logic layer  or user interface layer ) that may use the SY variable may be configured to utilize the respective SY variables on a case-by-case basis.","Furthermore, since most SY variables are only consumed during a single dialog session, the likelihood of errors related to them is rather low.","At step , based on the state representation stored in the retrieved cookie, the functionality of the UI layer  may cause the processor to restore the user context by setting all necessary static variables of the function modules, the global variables, and the like, related to the authenticated user. The functional computing logic  may be called at step  using the restored user context.","At step , the functional computing logic  may cause the processor to access the application database  and\/or may set or release locks based on the data requested for use by the workstation . Locks may managed by a lock manager, e.g. the SAP Enqueue server.","The application database  may contain a lock storage, e.g. a database table, operated on by a lock manager that maintains the status of all locks for each session. After the functional computing logic  has completed retrieving data, at step , the functionality of UI layer  may cause the processor to assemble a state representation of the current user session.","After the state representation is assembled, at step , the user context may be stored as a cookie in the state storage . At step , the UI  may generate the HTML containing the data requested by the workstation  for rendering by the browser on the workstation . The UI  may use the restored user context when generating the HTML for rendering by the browser.","Transforming a stateful application into a stateless application may comprise to regroup the code structure such that it complies with the stateless pattern. Regrouping may require modification of the functional computing logic  and user interface  layer. In addition, new coding for steps , ,  and  may be added to manage the state (by applying the state management pattern). As illustrated in , a computer application  may be conceptually split into a user interface  and functional computing logic . Manual state management may comprise two phases: phase  and phase . During phase  (comprising steps - of ), the user context may be restored from a condensed state representation read from, for example, external state storage  such that the functional computing logic  can be called basically unchanged. During phase  (steps - of ), the condensed state representation may be assembled using the user context and persisted (e.g. saved) on the external state storage . The session ID may be used to identify the state representation on the external storage  in both cases.","As described above, changes to a stateful server instead of modifications of the stateful application code may be used. .  illustrates an exemplary component diagram of a software framework in an application environment for scaling a computer system to a large number of concurrent users according to an exemplary embodiment. The stateful computer application  executing on a computer processor may include two software layers: a user interface (UI) layer - and a functional computing logic (FL) layer -. The computer application  may also generate batch jobs -. The UI layer - may generate HTML pages which may be rendered (directly or indirectly using, for example, a plug-in) by a browser on a client. The HTML pages may be created based on a server-side programming model within the framework of a stateless computer application , such as a business server pages (BSP) application framework.","The computer application  may be a stateful application that may include the following components: pages, page fragments, navigation structure, application class, MIME objects, a topic, and\/or other features. A topic may be a predefined content category used for classifying and targeting content, and for user subscription. Stateless business server pages may also process HTTP requests in a stateless fashion. The computer application  may generate a HTML page, and the HTML page in a specific example may also be considered a component of a business server page application. The generated HTML page may include a layout part, event handlers, as well as page attributes and type definitions. In some embodiments, the computer application  may be any form of web application that may utilize a HTTP request handler, such as CL_BSP_EXTENSION. For example, the web application may be a portal, an online shop, or the like.","The computer system of  may include, in a stateful condition, the application server , which may host computer application . However, when transformed to a stateless application , the transformed application  may include additional data and executable code. For example, the transformed application  may include a transformed user interface (UI) -, transformed functional computing logic - and transformed batch job -.","Furthermore, the stateful application server  may be modified running various modules or a so called \u2018consistency framework\u2019  that may include a stateless locking framework or module - and stateless update task framework or module - in order to support the consistency handling of the transformed application. In addition, a clean up job module - may remove data of no longer active sessions from an external storage used by consistency frameworks and\/or from the state storage, for example the data storage  of .","The UI - of the transformed application may be stateless, and may interact with a further application, such as a stateless BSP application. The UI - may also include additional functionality provided by additional executable code that provides state handling. The state of, for example, the BSP application belonging to the UI - may be included as part of the state representation as well. The batch jobs - of the transformed application  may also include additional functionality for maintaining consistency handling. Similarly, the functional computing logic - of the transformed application  may include additional functionality for both consistency handling and state handling.","In order to apply the state management pattern (which may apply to steps , ,  and  of ), manual changes to the to-be-transformed application  may be made. Additional coding in order to retrieve the state representation (phase ) and recreate the context from the state representation (phase ) may be added to obtain the functional computing logic -. This coding is then called (e.g., during steps  and  of ) to retrieve and set the context, respectively. For example, methods to serialize the internal state of an object plus special constructors to recreate those objects from the serialized data may be added to classes and\/or functional groups so function modules may retrieve\/set the state of function groups (i.e., variables with scope function group). In the transformed application , only minor modifications may be needed to the way the locks are handled, for example, at step . These modifications may be replacements of, for example, SAP Enqueue lock calls with calls to semantically compatible functions provided by the stateless locking framework.","The stateless locking framework - may provide substitutes for all existing functions, in particular the functions trying to set a lock (e.g., S_ENQUEUE instead of ENQUEUE provided by an SAP application server), remove a lock (e.g., S_DEQUEUE instead of DEQUEUE) and remove all locks of a giving session (e.g., S_DEQUEUE_ALL instead of DEQUEUE_ALL) may have substitutes. Each of the above functions\u2014in addition to the parameters of the original function\u2014may include the new parameter LUW_ID. A LUW is a logical unit of work, and may be active for the span of time during which any transaction is updated in an all-or-nothing manner. For example, the session ID may be used as the LUW_ID. The session ID can be retrieved from, for example, a BSP application executing on application server  using, for example, a RUNTIME object where (RUNTIME->session-id).","The implementation of the stateless locking framework may include a lock manager and a lock storage. The lock storage may be a database table with a compound primary key consisting of a computer name, a LUW_ID, and a timestamp. The timestamp may contain the point in time when the lock was set and the computer name and unique identification of the application server calling the stateless locking framework. With this data structure, all locks associated with a user session can be easily identified by means of the common LUW_ID. In addition locks may be selected based on time and by which computer they were set. The asynchronous behavior of the stateless locking framework - may be implemented, for example, by using asynchronous remote function calls.","In the transformed application , the manner in which update tasks are handled may be modified at step  of . Therefore, the stateless update task framework - may provide compatible substitutes for the following functions:\n\n","A general idea of the stateless update task framework may be, instead of executing the above statements directly, their execution may be deferred to a later point in time (which may be determined by the application  logic) by queuing the statements in a specific database table (the update task storage). It has to be noted, that queuing is normally not possible for stateless applications. Thus, the stateless update task framework provides functionalities which are normally not available for stateless applications.","The queued statements may be maintained in the update task storage, like a database table, for the entire user session, not just a single dialog step. The task of queuing and replaying these statements may be managed by the stateless update task framework -. The point in time when the replay or cancel is triggered may be determined by executing a COMMIT WORK or ROLLBACK WORK statement within the application  logic. Specifically, instead of calling, for example CALL FUNCTION IN UPDATE TASK (and the other statements) directly, the stateless update task framework - may be called. The stateless update task framework - may store the name of the function and the value of all its parameters using the session key as the primary key in a persistent queue. In addition before each COMMIT WORK or ROLLBACK WORK statement, a call to the stateless update task framework - to replay or cancel the queued statements, respectively, may be inserted. Canceling the queued statements can be simplified by registering a subroutine with PERFORM ON COMMIT and PERFORM ON ROLLBACK before step  of the stateless pattern illustrated in . This subroutine may call the stateless update task framework - to trigger the appropriate action.","When, for example, a COMMIT WORK is called, the stateless update task framework - may retrieve all queued statements, and may execute them one by one. In case of a ROLLBACK WORK, memorized statements may be removed from the stateless update task framework - queue. In order to simplify the implementation of the framework queue and to avoid another background task clearing the database entries, data storage such as state storage  of  that stored the server side cookies may be used.","While doing the transformation, i.e. while carrying out the method outlined in  it may be checked whether the application context is restored appropriately such that the statements can execute in an expected context. Otherwise additional coding must be added to make sure the context is restored as needed.","When a new task is begun by a process, a statement, such as a CALL FUNCTION STARTING NEW TASK statement may be called. The statement CALL FUNCTION STARTING NEW TASK may only be indirectly affected by the stateless pattern. Only in the case in which callbacks are used may a code modification be required. For example, callbacks may not work after the dialog step in which the CALL FUNCTION STARTING NEW TASK is executed has ended. Hence the statement WAIT_UNTIL may be added before the end of the dialog step in the stateful application, in order to sync with the asynchronously called functions.","In a situation where two (or more) remote function calls to the same function module instance are to be executed in different dialog steps, and each of the different dialog steps expect stateful behavior on the receiving side, the application server  may have to address the remote function calls to insure proper execution of the remote function call. A technique similar to the one used for web applications may be used where the internal state of the called function module (or even function group) is serialized and stored using a server side cookie and retrieved again when the function module is called again. For example, the receiving side may call a stateless function or application remote from the transformed stateful application. In this case, the application server  has to ensure the proper execution of the remote function call. Still, a stateful application is provided to the receiving side like for example the workstation  of  while the internal processing is optimized with features of a stateless application","The application  may perform background tasks by batch jobs - in . A background task may for example be a task which is executed in the background until a final result is generated by the task. After the generation of the result, a user may be notified of the task completion. In order for background tasks to work smoothly (i.e. to avoid inconsistencies) with the transformed user interface - and related functional computing logic -, the batch jobs - may need to be adjusted like the other parts to become batch jobs -. In an example, a background task may have no session ID since it is not called directly by for example the workstation  of  in a session. The background task may haven been instantiated by a stateful application, wherein the stateful application itself was called by a user. Thus, since there may be no session ID for background tasks, an artificial session ID may be created. The artificial session ID may be created by generating a GUID (which is a unique ID) using, for example, a function GUID_CREATE for each task instance. Creating the GUID may be a work-around since there might be no easy way to retrieve the user context ID from within an ABAP program. In this context, the GUID may only be generated once, and may be used as the session ID. The GUID allows for consistency handling since it is unique to the session. All transformations may apply to the GUID during the session. This applies not only to batch jobs but also to remote function calls, function new task calls, a business application programming interface (BAPI), and the like. A BAPI may be an interface for providing access to processes and data in business application systems such as SAP R\/3. As mentioned above, the GUID may be a combination of a session identification, the name of the computer running the stateful computer application and a timestamp.","An implementation within the stateful server may directly access the user context ID and does not depend on the work-around described above. The user context ID is used within the stateful server like the session ID for the UI. The kernel knows whether the coding runs as UI or background task hence it can pick the appropriate ID.","Since the stateless locking framework - is not integrated with an ABAP basis it may not be called in case the application may end (either normally or abnormally). Locks remain, for example, because of unforeseen aborts that may occur with computer application . Hence, a mechanism is needed to ensure that those locks managed by the stateless locking framework - are removed which are no longer valid. Similar issues exist for the storage of the stateless update task framework - and the state storage. A clean-up function - may check for inactive sessions (sessions that are no longer active but for which locks, update tasks or stored state representations still exist), and may remove invalid locks, update tasks and state representations belonging to session which no longer exist. A batch job running the clean-up function - may run repeatedly from time to time, e.g. every 15 minutes, and may remove all locks, update tasks and state representations for which no active session exists anymore.","In a specific example, the state information of an ABAP application, functioning as application , may include the following information: the user interface interaction state, which may include a current state of user interface controls; and a record of all user issued changes not yet committed to a database. The user issued changes may be stored in application specific data structures and variables. Any other data may be considered supporting data structure. A supporting data structure may for example comprise a search index generated from data resources requested by the calling of the functional computing logic of the stateful application. Particular cached data that may be held in the user context for performance reasons is not part of the user state. Instead, it may be re-read with every request. Any variable containing a copy or derived information may also not be part of the user state, and may also be re-read from the database or recomputed when necessary.","In one embodiment, only the state information as listed above need to be stored in state storage and all the supporting data structures are rebuild using the state information each time in phase . However, depending on the time required to build up the supporting data structures it may be beneficial to include some or all of the supporting data in the user state. The trade-off of how much of the state information is needed or should be stored may be determined for each application.",{"@attributes":{"id":"p-0087","num":"0147"},"figref":"FIG. 2B"},"The computer system of  may include, in a stateful condition, the application server , which may host computer application . Thus, the server  is a stateful server and the application  is a stateful application.","However, when transformed, the transformed application  may include some additional data and executable code. For example, it may include a transformed user interface (UI) -, transformed functional computing logic - and unchanged batch jobs -. In addition, an application server  may be extended to an extended application server , and may include additional software frameworks for stateless consistency handling. In particular, the extended server  may include a consistency framework  that may include a stateless locking framework - and a stateless update task framework -.","The UI - of the transformed application may be stateless, and may include additional functionality provided by additional code that provides state handling similar to the transformed application of . In addition, the functional computing logic - of the transformed application  may include additional code for state handling similar to the transformed application of .","The implementation of the consistency framework  within, for example, an application server implemented as the extended application server  may directly access the user Session ID generated by the UI framework (e.g. the BSP application framework). In addition, for batch jobs, the application server may either generate a unique ID or reuse an internal unique ID like a process ID, e.g. the user context ID in case of an ABAP application server, to identify each batch job. Hence, in each case the consistency framework  could access this ID. Therefore, the application server may be able to select an appropriate LUW_ID, required to call the consistency framework, based on the determination that the coding runs as a user interface task or background job automatically.","An LUW_ID, determined by the application server and required by the consistency framework, may be passed on internally within the application server , which is in this example, an ABAP server. As a consequence, further modifications to provide this functionality to the coding of the application , for example, the functional computing layer coding and the batch jobs of an ABAP application, may not be required. In other words, the following ABAP statements may be used without any changes to the original application coding: CALL FUNCTION . . . IN UPDATE TASK, PERFORM ON COMMIT, CALL FUNCTION . . . IN BACKGROUND TASK DESTINATION, COMMIT WORK, PERFORM ON COMMIT, PERFORM ON ROLLBACK, ROLLBACK, SET UPDATE TASK LOCAL, ENQUEUE, DEQUEUE and DEQUEUE_ALL.","The two consistency frameworks, stateless lock and update task framework, may be implemented similarly to the ones shown in . The implementation of stateless lock and update task framework may use lock storage and update tasks storage, respectively.","Generally, a batch job to run the clean-up function cyclically is not required to remove data for abnormal terminated applications from the different storages in case the application server calls the clean up functionality directly when a session ends (either abnormally or regular). In case the application server itself aborts abnormally, it may terminate all running sessions abnormally, too. Hence, a clean-up function may to be called at startup of the server to remove information belonging to inactive sessions.","A general guideline for structuring the stateless application user context may include limiting the size of the state representation data to be smaller than the user context in the original stateful application (for example,  of ).","The efficiency of the state management (state storage and user context rebuild) may be optimized if the state is maintained with less data than the user context of the original application. As a result, the state representation may be maintained between requests (dialog steps).",{"@attributes":{"id":"p-0097","num":"0157"},"figref":"FIG. 3","b":["300","310"]},"For example, the session ID may be generated by a business server page framework executing on an application server, and in combination with a UI layer as shown in . At step , a user context for each of the plurality of users may be restored by using the respective generated session ID to retrieve cookies from external storage. Using the restored user context, the functional computing logic may be called to provide, for example, requested functions to each of the plurality of users.","According to requests from a user interface and based on data, such as permissions and security settings, from the restored user context, the functional computing logic functions, at step , may access data in a database, may create\/cancel update tasks and may set\/reset locks by means of the consistency framework that may include stateless lock management and an update task framework. A state representation subset of a user context may be assembled at step . The user context and the assembled state representation may be stored as a cookie in external storage like the storage  of  or the database  of  using, for example, the session ID as a primary key. At step , HTML code may be generated by, for example, the user interface based on the assembled state representation, user context, and data from the accessed database.","The process  may also be applied to an application server embodiment in which as shown in , the application server  may be extended to provide state handling and consistency handling without the application. The extended server  may implement the process steps indicated above that are explained as being handled by a computer application. In the case of a server implementation, only changes to state handling of the application coding may be necessary as all state and consistency handling functions are performed by a processor at the server. Accordingly, the above described stateless functionality may be provided to a number of different computer applications at the server level.","An exemplary computer system for implementing a process as described with respect to  is illustrated in . The computer system  may comprise terminals A and B, a web application server  and a database . The terminals A and B may have access to respective data storage A and B. The terminals A and B may be simply display devices with input capabilities, e.g., keyboard, for presenting a graphical user interface and receiving input. Alternatively, terminals A and B may contain processors and execute functional computing logic, such as computer applications related to, for example, invoicing and human resources management.","Stateful computer application processes may execute on a processor of the web application server , which in this case is a stateful server, and a graphical user interface may render data for presentation on the client terminals A and B. Alternatively, the graphical user interface and related functionality may be present on the terminals A and B. The web application server  may be in communication with additional servers within a network such as servers  and . Either or both of the servers  and  may maintain the above-described lock server and message server, act as a database server or a web application server. Servers  and  may retrieve and store data in the database . The servers  and  may also be stateless servers running stateless applications to be called via the web application server . In all cases, the web application running on the server  acts as a stateless server, even though the internal processing is optimized with features of a stateless application.","The exemplary method and computer program instructions may be embodied on a machine readable storage medium such as a computer disc, optically-readable media, magnetic media, hard drives, RAID storage device, and flash memory. In addition, a server or a database server may include machine readable media configured to store machine executable program instructions. The features of the disclosed embodiments may be implemented in hardware, software, firmware, or a combination thereof and utilized in systems, subsystems, components or subcomponents thereof. When implemented in software, the elements of the disclosed embodiments are programs or the code segments used to perform the necessary tasks. The program or code segments can be stored on machine readable storage media. The \u201cmachine readable storage media\u201d may include any medium that can store information. Examples of a machine readable storage medium include electronic circuits, semiconductor memory device, ROM, flash memory, erasable ROM (EROM), floppy diskette, CD-ROM, optical disk, hard disk, fiber optic medium, or any electromagnetic or optical storage device. The code segments may be downloaded via computer networks such as Internet, Intranet, etc.","Although the invention has been described above with reference to specific embodiments, the invention is not limited to the above embodiments and the specific configurations shown in the drawings. For example, some components shown may be combined with each other as one embodiment, or a component may be divided into several subcomponents, or any other known or available component may be added. The operation processes are also not limited to those shown in the examples. Those skilled in the art will appreciate that the invention may be implemented in other ways without departing from the sprit and substantive features of the invention. For example, features and embodiments described above may be combined with and without each other. The present embodiments are therefore to be considered in all respects as illustrative and not restrictive."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The enclosed drawings disclose preferred embodiments of the invention. It should be understood, however, that the drawings are designed for the purpose of illustration only and not as a definition of the limits of the invention. In the drawings:",{"@attributes":{"id":"p-0045","num":"0099"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0046","num":"0100"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0047","num":"0101"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0048","num":"0102"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
