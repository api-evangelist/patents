---
title: Optimizing if statements in computer programming
abstract: A method for optimizing if statements in a program includes obtaining, by a processing device, for each of conditional expressions of a plurality of if statements in the program, a set of conditional expressions having an inclusion relation; computing, for each of the set, a position with low execution frequency in the program as a move destination of a conditional expression having an inclusion relation, using information of the set in which the conditional expression is included; and moving the conditional expression to the computed move destination of the conditional expression.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09298434&OS=09298434&RS=09298434
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09298434
owner_city: Armonk
owner_country: US
publication_date: 20150424
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FOREIGN PRIORITY","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Example 1","Example 2","Example 3","1. Example of Optimization of Conditional Expression Causing No Side Effect","2. Example of Optimization of Conditional Expression Having Possibility of Causing Side Effect","Example 4","REFERENCE SIGNS LIST"],"p":["This application claims priority to Japanese Patent Application No. 2014-098069, filed May 9, 2014, and all the benefits accruing therefrom under 35 U.S.C. \u00a7119, the contents of which in its entirety are herein incorporated by reference.","The present invention relates to a method for optimizing if statements in a program, and more specifically relates to a method of if statement optimization including transformation (move, cache in a variable, etc.) of conditional expressions in consideration of an inclusion relation between conditional expressions of if statements in a program.","The same if statement may be repeatedly generated when, for example, a program is machine-generated. Repeatedly executing the same if statement in such a case causes a corresponding decrease in processing performance (speed) of the program. It is therefore desirable to optimize if statements by some method, to avoid repeated execution of the same if statement in the program.","Regarding the optimization of if statements, US2007\/0169039 discloses the following. In a method of converting a first intermediate representation of automatically generated code into a second intermediate representation through an optimization technique, the first intermediate representation is optimized by moving a section of code to a location where the section of code is executed or combining a plurality of loops (such as if statements) into a single loop, thus reducing the number of times a loop is executed (e.g. the number of memory accesses).","JP2012-014526 discloses a program code structure conversion apparatus that, in the case where an if statement block is present in a function call part extracted from original code and a function call is used in the conditional expression of the if statement, moves the conditional expression to a position before the if statement and temporarily assigns it to \u201clocal_cond1\u201d, and substitutes the temporarily assigned \u201clocal_cond1\u201d in the conditional expression of the if statement, to remove the function call from the conditional expression in the if statement.","In one embodiment, a method for optimizing if statements in a program includes obtaining, by a processing device, for each of conditional expressions of a plurality of if statements in the program, a set of conditional expressions having an inclusion relation; computing, for each of the set, a position with low execution frequency in the program as a move destination of a conditional expression having an inclusion relation, using information of the set in which the conditional expression is included; and moving the conditional expression to the computed move destination of the conditional expression.","In another embodiment, a non-transitory computer readable storage media has instructions stored thereon that, when executed by a computer, implements a method for optimizing if statements in a program. The method includes obtaining for each of conditional expressions of a plurality of if statements in the program, a set of conditional expressions having an inclusion relation; computing, for each of the set, a position with low execution frequency in the program as a move destination of a conditional expression having an inclusion relation, using information of the set in which the conditional expression is included; and moving the conditional expression to the computed move destination of the conditional expression.","The methods described above neither cover the optimization of if statements in the case where an inclusion relation exists between conditional expressions of if statements, nor sufficiently take into consideration the prediction of benefits (costs) associated with movements of conditional expressions of if statements.","Accordingly, embodiments of the invention provide for, in the case where an inclusion relation exists between conditional expressions of if statements in a program, improving the processing performance (speed) of the program by optimizing if statements while predicting the benefits (costs) associated with movements of conditional expressions.","An embodiment of present invention provides a method for optimizing if statements in a program. The method includes obtaining, for each of conditional expressions of a plurality of if statements in the program, a set of conditional expressions having an inclusion relation; computing, for each obtained set, a position with low execution frequency in the program as a move destination of a conditional expression having an inclusion relation, using information of the set in which the conditional expression is included; and moving the conditional expression to the computed move destination of the conditional expression.","In one aspect, obtaining a set includes setting a positive condition and a negative condition in each conditional expression having the inclusion relation, and computing, for each condition, a cost from the number of conditional expressions as a subset and a probability of the conditional expression being true. For example, the cost may be computed for each conditional expression, as a product of the number of conditional expressions and the probability of the conditional expression being true.","In one aspect, moving the conditional expression includes: moving a conditional expression causing no side effect, to a position with lowest execution frequency in an area in which the conditional expression has a possibility of being executed in the program; and moving a conditional expression having a possibility of causing a side effect, to a position with lowest execution frequency in an area in which the conditional expression is definitely executed and the movement causes no side effect in the program.","In one aspect, moving the conditional expression includes: in the case where a result of the conditional expression is not cached in a variable, generating an if statement relating to a conditional expression having the inclusion relation, and caching a result of the conditional expression of the if statement in a new variable; and in the case where the result of the conditional expression is cached in the variable, replacing a conditional operator of the conditional expression having the inclusion relation with a logical operator, and then caching a result of the conditional expression in the new variable.","In one aspect, generating an if statement relating to a conditional expression having the inclusion relation and caching a result of the conditional expression of the if statement in a new variable includes generating the if statement in increasing order of a total cost of the positive condition and the negative condition and caching a result of the conditional expression of the if statement in the new variable.","In one aspect, computing a position with low execution frequency in the program using information of the set in which the conditional expression is included includes performing data-flow analysis using the positive condition and the negative condition as the information of the set.","In one aspect, moving the conditional expression is performed in the case where a result of comparison between an execution cost of the conditional expression before the movement and an execution cost of the conditional expression after the movement indicates an improvement in execution speed.","The following describes an embodiment of the present invention with reference to drawings.  is a block diagram showing a structural example of a computer for implementing a method according to the present invention. A computer  includes a processor (CPU) , storage means , and various interfaces , which are connected to each other via a bus . The various interfaces  are a collective term for interfaces including an input interface, an output interface, an external storage interface, and an external communication interface. Each interface is connected to a corresponding one of input means  such as a keyboard and a mouse, display means  such as a CRT and an LCD, external storage means  such as a USB-connected semiconductor memory and an HDD, and the like. The storage means  may include an HDD, a semiconductor memory such as a RAM or a ROM, and the like. The method according to the present invention is implemented by the computer  calling and executing predetermined software stored in the storage means  or , as an example. The method according to embodiments the present invention is executed when debugging or compiling a program.","The following describes process flow of the method according to the present invention, with reference to .  is a basic flowchart showing the method according to the present invention. In operation S in , for each of conditional expressions of a plurality of if statements in a program to be edited, a set of conditional expressions having an inclusion relation is obtained. When obtaining the set, a positive condition and a negative condition are set in each conditional expression having the inclusion relation, and a cost is computed for each condition from the number of conditional expressions as a subset and the probability of the conditional expression being true.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 3 and 4","FIG. 3","FIG. 3"],"b":"11"},"In , the provisional cost can be obtained by multiplying P which is the \u201cprobability of conditional expression being true\u201d by N which is the \u201cnumber of expressions as subset\u201d (P*N). For example, the provisional cost of the negative condition I !=5 is 0.96*2=1.92. The provisional cost of each of the other conditional expressions can be computed in the same way. The total provisional cost can be obtained as the sum total of the set of positive and negative conditions. For example, the total provisional cost of I=5 and I !=5 is 0+1.92=1.92. The total provisional cost of each of the other sets of conditional expressions can be computed in the same way. The total provisional cost is used as a criterion to determine the generation order (priority) when generating the if statement in the move destination of the code (if statement), as described later.","The set in  can be obtained basically by the same procedure as in the case of the conditional expressions having the equality sign in , except that each conditional expression has an inequality sign. For example, the positive condition DD>29 has the relation of including two expressions of the positive conditions DD>30 and DD>31, and so the \u201cnumber of expressions as subset\u201d of the positive condition DD>29 is 2. Likewise, for example, the negative condition DD\u226629 has the relation of including one expression of the negative condition DD\u226628, and so the \u201cnumber of expressions as subset\u201d of the negative condition DD\u226629 is 1. The \u201cnumber of expressions as subset\u201d of each of the other conditional expressions can be computed in the same way. The provisional cost and the total provisional cost can be computed in the same way as in , too. For instance, the total provisional cost obtained by summing the two provisional costs of the set of the positive condition DD>29 and the negative condition DD\u226629 is 0.12+0.94=1.06.","The description refers back to . In operation S, for each set obtained in operation S, a position with low execution frequency in the program is computed as a move destination of a conditional expression having an inclusion relation, using information of the set in which the conditional expression is included. Here, the position with low execution frequency in the program can be determined by performing data-flow analysis using, as the information of the set, the expressions of positive and negative conditions mentioned above. The position may be determined using, for example, a conventional data-flow analysis algorithm (e.g. lazy code motion). To determine a final (latest) executed position from positions with the same execution frequency, conventionally each conditional expression is registered into a gen set used in data-flow equations. In this example, on the other hand, the computation is performed by incorporating the above-mentioned set of positive and negative conditions corresponding to the conditional expression into the gen set. The final executed position with the same execution frequency is a candidate for the move destination of the code (if statement, conditional expression) described later.","In operation S, the conditional expression is moved to the computed move destination of the conditional expression. In this moving operation, an appropriate process corresponding to each case (condition) is performed as shown in the following (a) to (c), to actually improve the processing performance (speed) of the program.","(a) In the moving operation, in the case where the conditional expression causes no side effect, the conditional expression is moved to a position with lowest execution frequency in an area in which the conditional expression has a possibility of being executed in the program. After this, the conditional expression is executed, and the result (0 or 1) is cached (stored) in a variable. The position with lowest execution frequency is computed using the data-flow equations mentioned above. The side effect typically means that a function in the program changes the logical state of the computer and affects the subsequently obtained results. A representative example is that, in assignment of a value to a variable, the value of the variable changes. In the case where the conditional expression has a possibility of causing a side effect, the conditional expression is moved to a position with lowest execution frequency in an area in which the conditional expression is definitely executed and the movement causes no side effect in the program. After this, the conditional expression is executed, and the result (0 or 1) is cached (stored) in the variable.","(b) In the operation of moving the conditional expression, in the case where the result of the moved conditional expression is not cached in a variable, when the conditional expression is in an inclusion relation with any conditional expression, an if statement relating to the conditional expression having the inclusion relation is generated, and the result of the conditional expression is cached in a new variable. When doing so, the if statement is generated in increasing order of the total provisional cost of the positive and negative conditions in the set, and the result is cached in the new variable. In the case where the result of the conditional expression is cached in the variable, on the other hand, the conditional operator (conditional AND, OR, XOR) of the conditional expression having the inclusion relation is replaced with a logical operator (logical AND, OR, XOR), and then the result of the conditional expression is cached in the new variable.","(c) The operation of moving the conditional expression is enabled in the case where the result of comparison between the execution cost of the conditional expression before the movement and the execution cost of the conditional expression after the movement indicates an improvement in execution speed. In detail, cost-benefit computation is performed for the conditional expression optimized through the movement and, in the case where a benefit is greater than a predetermined threshold, the conditional expression is replaced with a computed variable or a cached variable. Otherwise, the transformation (move, generate, or cache the conditional expression in a variable) in the above-mentioned (a) and (b) is not performed. A method by which, without actually executing the transformation in the above-mentioned (a) and (b) until the cost computation and evaluation, the information of the transformation is stored in a memory can thus be employed.","The reason for the need of cost-benefit computation can be explained as follows. In the optimization of if statements, a conditional expression is often unable to be completely deleted even after optimization and the speed might decrease, unlike the optimization of computational expressions. This requires cost computation. Whether or not the speed is increased depends on the total execution frequency of the optimized conditional expression, the cost of the conditional expression, the total execution frequency of the inserted conditional expression, and the access cost of the cached variable. For example, the optimization of if statements differs from the optimization of computational expressions as shown below.","(A) Optimization of Computational Expressions:",{"@attributes":{"id":"p-0037","num":"0036"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mo":["(",")"],"mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["Original","program"]}},{"mrow":{"mrow":{"mo":["(",")"],"mn":"2"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["After","optimization"]}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mi":"T","mo":"=","mrow":{"mi":["b","c"],"mo":"+"}}}]},{"mtd":[{"mrow":{"mi":"a","mo":"=","mrow":{"mi":["b","c"],"mo":"+"}}},{"mrow":{"mi":["a","T"],"mo":"="}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"mi":"d","mo":"=","mrow":{"mi":["b","c"],"mo":"+"}}},{"mrow":{"mi":["d","T"],"mo":"="}}]}]}}}},"(B) Optimization of if Statements:",{"@attributes":{"id":"p-0039","num":"0038"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mo":["(",")"],"mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["Original","program"]}},{"mrow":{"mrow":{"mo":["(",")"],"mn":"2"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["After","optimization"]}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mi":"T","mo":"=","mrow":{"mo":["(",")"],"mi":"cond"}}}]},{"mtd":[{"mrow":{"mi":["if","cond"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":"IFT"}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"mrow":{"mi":["if","cond"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":"IFT"}]}]}}}},"The cost of (1) is C*2, the cost of (2) is C+C*3, and the benefit is C\u2212C*3, where the cost of the conditional expression cond is C and the cost of memory access to T is C. The optimization is performed when the benefit is greater than the predetermined threshold.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIGS. 5 and 6","FIG. 2","FIG. 5","FIGS. 3 and 4","FIG. 6","FIG. 5","FIG. 6"]},"In the example in ,","the original cost: 1.5*C","the cost after optimization: 1.25*C+2*C","the benefit of optimization: 0.25*C\u22122*C,","where the cost of memory access to A is C, the cost of memory access to T is C, the probability of A<1 being true is 50%, and the probability of the left path being executed is 50%. The transformation is enabled in the case where the benefit of optimization (0.25*C\u22122*C) is greater than the predetermined threshold.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7","FIG. 2","FIG. 7"]},"the cost in (a): 4*C","the cost in (b): 1.11*C+8*C","the benefit of optimization: 2.89*C\u22128*C,","where the cost of comparison with TXNFL-DATE-DD is C and the cost of memory access to a temporary variable is C. The transformation (code movement) is enabled in the case where the benefit of optimization (2.89*C\u22128*C) is greater than the predetermined threshold.","An example of optimization in the case where there are four occurrences of the following if statement:","IF R-RESTOCK-01 OF REPORT-RESTOCK OF REPORT-BMO5=SPACE","OR R-RESTOCK-01 OF REPORT-RESTOCK OF REPORT-BMO5=LOW-VALUE","is given below. The following instruction sequence is generated for the above-mentioned if statement. In this case, the number of memory accesses is large and the cost is high.","L 4,312(0,9)","CLC 304(12,4),12(12)","BC 8,2612(0,11)","CLI 304(4),X\u201800\u2019","BC 7,2620(0,11)","CLC 305(11,4),304(4)","BC 7,2620(0,11).","It is assumed that the two conditional expressions included here cause no side effect, and the value is unchanged between the if statements. The transformation is performed as follows, by the method according to the present invention.","Cond1=(R-RESTOCK-01 OF REPORT-RESTOCK OF REPORT-BMO5=SPACE)","Cond2=(R-RESTOCK-01 OF REPORT-RESTOCK OF REPORT-BMO5=LOW-VALUE)","Cond3=Cond1|Cond2\/\/Speed up conditional OR by logical OR.","The benefit of optimization in this case is determined to be greater than the predetermined threshold, and the four if statements are replaced with the conditional expression of Cond3.","IF Cond3 process 1","process 2","IF Cond3 process 3","process 4","IF Cond3 process 5","process 6","IF Cond3 process 7.","Suppose the second conditional expression (R-RESTOCK . . . ) of the if statement in the above 1. can cause an access exception. In such a case, the following transformation is performed in the moving operation in (b) mentioned above.",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003Cond1 = (R-RESTOCK-01 OF REPORT-RESTOCK OF REPORT-"},{"entry":"BMO5 = SPACE)"},{"entry":"\u2003\u2003IF Cond1 OR"},{"entry":"\u2003\u2003\u2003\u2003R-RESTOCK-01 OF REPORT-RESTOCK OF REPORT-"},{"entry":"BMO5 = LOW-VALUE"},{"entry":"\u2003\u2003\u2003\u2003Cond3 = 1"},{"entry":"\u2003\u2003ELSE"},{"entry":"\u2003\u2003\u2003\u2003Cond3 = 0"},{"entry":"\u2003\u2003END-IF."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Regarding the generation example of the if statements having the inclusion relation in , the original program and the optimized program were generated in a source code level, and their processing (execution) speeds were examined. The result demonstrated that the optimized program shows an improvement in speed of about 40% as compared with the original program.","Though the embodiment of the present invention has been described with reference to drawings, the present invention is not limited to such an embodiment. Various improvements, modifications, and changes may be made based on the knowledge of those skilled in the art without departing from the scope of the present invention.",{"@attributes":{"id":"p-0078","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":[{"@attributes":{"id":"ul0002-0001","num":"0077"},"b":"30"},{"@attributes":{"id":"ul0002-0002","num":"0078"},"b":"100"}]}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIGS. 6() and 6()","FIG. 5"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 7() and 7()"}]},"DETDESC":[{},{}]}
