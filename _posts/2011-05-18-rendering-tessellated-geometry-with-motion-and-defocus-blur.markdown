---
title: Rendering tessellated geometry with motion and defocus blur
abstract: A moving or defocused geometry may be stochastically rendered by grouping a plurality of primitives of that geometry in a hierarchical data structure. Visible fragments may be located in that data structure by hierarchically traversing a ray frustum through the structure. A time-dependent ray tracing data structure may be used in some embodiments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08791945&OS=08791945&RS=08791945
owner: Intel Corporation
number: 08791945
owner_city: Santa Clara
owner_country: US
publication_date: 20110518
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["This relates to graphics processing and, particularly, to rendering motion blur and defocus blur.","Correct rendering of distributed effects such as motion blur and depth of field in interactive graphics will be a major leap towards increased realism and visual fidelity. Most applications currently make the assumptions that the scene is seen through a pinhole camera with a shutter that is open for an infinitesimally short amount of time, and rely on post-processing to create the desired blur. Although several rasterization algorithms that stochastically sample in time and over the lens have been proposed, they all suffer from unpredictable performance and poor scaling with increased blur. By sacrificing the stochastic property and discretizing time and lens coordinate using accumulation buffering or interleaved sampling, a constant cost can be achieved, but this may introduce strobing artifacts.","In real-time graphics there is a prevailing trend towards using smaller primitives. This was emphasized with the introduction of tessellation in DirectX 11, which made it possible to generate a large amount of geometry on chip. However, smaller primitives put a high pressure on the rasterizer, and make shading less efficient due to the constraint of shading on 2\u00d72 quads. The problem is reinforced with accumulation buffering or interleaved sampling, as these techniques can be seen as rendering each primitive multiple times, but in lower resolution. Also, the amount of blur introduced by motion and\/or depth of field is independent of the geometric detail of the scene. Hence, stochastic rasterization of small primitives is exceedingly expensive, as the screen-space region that needs to be traversed for each blurred primitive is very large compared to the size of the primitive. A large amount of work is performed that does not result in visible samples.","We present an algorithm for the efficient rendering of tessellated geometry with stochastic motion blur and\/or defocus blur. High-quality motion blur and depth of field rendering are key components for taking interactive graphics to the next level of realism. By adding stochastic time (t) and\/or lens coordinate (u, v) to the rasterizer, correct motion and defocus blur can be resolved in some embodiments. We propose a ray casting approach, in one embodiment, which exploits the implicit spatial coherence of tessellated geometry by performing ray casting through a small local acceleration structure built per patch. Using frustum traversal and analytical time overlap computations, we arrive at a method that scales well with increased blur and smaller primitives in some embodiments.","Our algorithm may operate in a streaming fashion within an otherwise traditional rasterization pipeline. The rasterization\/traversal cost is amortized over a group of primitives, instead of rasterizing them one by one. By grouping primitives together, the size of the blurred region is reduced relative to the size of the primitives, and a lot of the redundant work can be avoided. This is illustrated in . The enclosed region illustrates the area affected by a triangle rendered with motion blur and depth of field. For each triangle in a patch, an area approximately this size needs to be traversed. In this example there are 24 triangles. With our approach, all triangles in the patch are rendered in one batch using ray casting. The gray area needs to be traversed only once, at the cost of a small additional overhead to find which primitive each sample overlaps, if any.","First, a small hierarchical data structure is built over the triangles generated from a single patch, and the screen-space region covered by the blurred patch is traversed. We use a tiled traversal to improve efficiency in some embodiments. For each screen-space tile, a tile frustum is created and hierarchically traversed through the data structure. If the frustum does not intersect, we can directly reject all samples in the tile. Otherwise, we analytically compute the overlap in time between the tile frustum and the patch and cast only the relevant rays. Hence, a very high hit rate is achieved and it is easy to guarantee that samples are coherently generated in a grid layout, which simplifies shading. In addition, in one embodiment, during frustum traversal we detect the optimal start node for the individual rays, and initiate their traversal from there instead of from the root of the hierarchical data structure. This further reduces the total traversal cost in some embodiments.","Our algorithm is a hybrid of ray tracing and rasterization in some embodiments. By working on a small local data set, we avoid the drawbacks of a global ray tracing solution, while maintaining the key performance characteristics of state-of-the-art ray tracing approaches in some embodiments. The streaming approach may also maintain coupatibility with the feed-forward rasterization pipeline of modern graphics processing units (GPUs) and graphics application program interfaces (APIs).",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","b":["10","12","12","14","16"]},"The tessellator  provides the spatial locality and implicit connectivity information that is required to build a compact and efficient hierarchical data structure over the patch. Note that only the rasterizer in the original pipeline needs to be modified. All other stages may be left as is, with the exception that the pixel shader  is able to handle samples coming from different primitives. Our method can be made entirely transparent to the application programming interfaces (APIs), which makes it attractive to developers and eases hardware adoption.","Our algorithm includes several parts in one embodiment, as shown in . The input consists of N transformed triangles that form a tessellated patch. First, a small hierarchical data structure is built over the triangles, or a subset of the triangles, generated from the tessellation of a patch (blocks  and ). The data structure consists of a hierarchy of moving bounding boxes enclosing the geometry. Then, the screen-space bounds of the moving patch are determined (block ) and this region is traversed using a tiled traversal (blocks  and ). This is illustrated in . The left figure shows a patch with 8 triangles that moves in space-time (limited to only two spatial dimensions for illustrative purposes). Note that each vertex can be arbitrarily transformed and displaced at the start (t=0) and end (t=1) times, but we assume linear motion in between. Seen in screen-space (right figure), a patch moves across the screen. The tile-aligned bounding box  is traversed, and for each tile  we compute the potential time overlap with the moving patch.","For each tile, a frustum is created and tested for overlap against the hierarchy (, diamond ). During traversal, conservative bounds for the time segment in which the geometry potentially intersects the tile are computed (block ). Samples that overlap in both time and space are converted into rays, which are cast through the hierarchy to find the closest intersection (block ). In this step, a number of optimizations are involved, which we will describe later. Samples that hit (diamond ) are written to an output queue for processing by the back end (block ). Traversal continues until there are no more samples and tiles to test (blocks  and ).","The flow chart may be implemented by the following pseudo-code:",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1\u2003\u2003Build hierarchy over triangles in patch"]},{"entry":[{},"2\u2003\u2003BBOX = Compute patch bbox"]},{"entry":[{},"3\u2003\u2003for each tile in BBOX"]},{"entry":[{},"4\u2003\u2003\u2003Test tile against hierarchy"]},{"entry":[{},"5\u2003\u2003\u2003if tile overlaps"]},{"entry":[{},"6\u2003\u2003\u2003\u2003TIME = Compute time segment of overlap"]},{"entry":[{},"7\u2003\u2003\u2003\u2003for each sample in TIME"]},{"entry":[{},"8\u2003\u2003\u2003\u2003\u2003Test sample against hierarchy"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The test tile\/sample against hierarchy steps (blocks  and ) perform frustum and ray traversal, respectively, through the bounding box hierarchy, much like in a traditional ray tracer. When a tile is tested, the output is either reject or a conservative time segment where overlap possibly occurs. For all tested samples that are not rejected, the output is a triangle intersection, i.e., a visibility sample.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5","FIG. 4"],"sub":["min","max"],"b":["62","64","56"]},"As a comparison, consider how traditional stochastic rasterization methods handle this case. First, existing methods do not compute time bounds. Hence the sampled region in space-time is enclosed by vertical lines (c.f., ), and many more samples are tested. Second, primitives are rasterized one-by-one, so there is one such large bounding box for each triangle, further multiplying the amount of inside tests performed. It is critical to reduce the volume of tested samples to improve efficiency. Interval-based rasterization does this successfully by partitioning the time domain and bounding each stratum individually, but the triangles are still rendered sequentially. Hence there is a significant overlap between the bounding boxes, especially in cases with large motion. A similar situation occurs in interleaved rasterization as triangles are individually rasterized.","Our method exploits the spatial coherency of tessellated geometry to improve the sampling efficiency in some embodiments. As a side effect, our samples will be output in coherent grids with high utilization in some cases. The trade-off is that we introduce a more expensive traversal step. It is thus important to minimize the cost of both tile frustum and per-sample traversal in some embodiments.","Next, we describe the main steps of one embodiment of our algorithm shown in  in greater detail. We will start with the setup done before traversal starts, i.e., construction of the hierarchical data structure and bounding of this, followed by the tile frustum and per-sample traversal methods. These are put together into a multi-level traversal algorithm, which starts ray traversal as far down in the tree as possible.","The input to our algorithm is transformed vertices for the primitives generated by tessellating a patch. For example, in a Direct3D 11-style pipeline, the transformed vertices would be produced by the domain shader (DS) , as indicated in . We assume all primitives are time-continuous with linear per-vertex motion, i.e., each vertex has two positions, qi and ri, storing the location at t=0 and t=1, respectively. The interpolated position pat any time, t, is given by: p(t)=(1\u2212t)q+tr. Further, we assume that if depth of field (DOF) is used, the hardware can shear the projection matrix to compute the projected position for any lens coordinate (u, v). The output from our algorithm is a number of visibility samples (, block ) overlapping the patch, which form the input to the pixel back end responsible for pixel shader (PS)  () and output merger (OM)  ().","For motion blur rendering, the primitives are assumed to be linearly moving between the start\/end times. First, a bounding box, B, is computed for each primitive at t=0 and t=1 (, block ). This can, for example, be done by taking the minimum and maximum of the vertex positions. Conservative bounds can then be computed at any time t by linear interpolation: B(t)=(1\u2212t)B(0)+tB(1). The data structure is built by hierarchically merging the time-dependent bounding boxes of nearby primitives (, block ). The merging of two time-dependent bounding boxes is performed by separately merging their respective boxes at t=0 and t=1. The merged box at any t is given by linear interpolation, as before.","The algorithm exploits the known tessellation pattern of the tessellator stage (c.f., block , ) to find primitives that are known implicitly to be spatially nearby. In most cases, all primitives tessellated from a single patch are processed as a group. If the patch contains a large number of primitives, we may divide the primitives into several groups to process only a subset of the primitives at a time. Similarly, it is possible to process several small patches together, if they are spatially nearby.","The data structure is stored in local scratch memory on-chip and reused when it is no longer needed, i.e., after the patch has been rendered. In one embodiment, the algorithm operates in 3D space and the bounding boxes are 4D hyper-trapezoids. In another embodiment, the bounding boxes are time-dependent 2D screen-space bounds, and in yet another embodiment, they are time-dependent 2D homogeneous bounds (2DH). If interleaved sampling is used, i.e., a small fixed number of discrete times, the bounds may be updated as a preprocess to the current time t, and stored as static (non-time-dependent) bounding boxes. In this case, all steps of the algorithm proceed as if we were rendering static triangles. In all cases, the bounding boxes may be axis-aligned, oriented, or oriented and sheared to be aligned with the principal axes of the geometry. The principal axes may be found using a heuristic, such as the edge directions of the input patch, or the average edge direction of the individual primitives.","In order to know which screen-space region to traverse, conservative screen-space bounds for the blurred patch must be determined (, block ). The most conservative approximation is to assume the entire screen needs to be traversed, but this is inefficient if the patch only covers a small part of the screen.","One possibility is to project the corners of the top-level bounding box in the hierarchical data structure to screen space, and use min\/max operations to find an axis-aligned bounding box (AABB). Other bounding shapes, for example, a convex hull or an object-oriented box (OBB), may also be used. To get tighter bounds, we can instead project the corners of the bounding boxes at a level further down in the tree. For example, if we have a binary tree, we can project the 2bounding boxes at level l (the root is l=0). There is a tradeoff between the cost of computing screen-space bounds and the cost of performing unnecessary tile frustum tests for the region outside the true patch.","In some embodiments, the screen-space bounds are computed in connection with building the hierarchical data structure instead of as a separate step, as the vertices may have to be projected anyway. Note that in all projections from 3D\/2DH to 2D screen space, care has to be taken to avoid problems when the primitives cross the camera plane, z=0. In such cases, known clipping procedures (not covered by this invention) are employed. One may, for example, use a method similar to MCGUIRE, M., ENDERTON, E., SHIRLEY, P., AND LUEBKE, D. 2010. Real-Time Stochastic Rasterization on Conventional GPU Architectures. In 173-182.","The screen-space bounds of the blurred patch is divided into tiles (e.g., 4\u00d74 pixels), and each tile is tested against the hierarchical data structure to determine if the tile overlaps the patch (, blocks  and ). The tiles that overlap (diamond ) can be hierarchically subdivided into smaller tiles, or we can go directly to per-sample traversal (blocks -).","In order to test a tile (block ), we setup four frustum planes that are aligned to the sides of the tile. In additional, two planes representing the near and far clipping planes, respectively, are added. Each frustum plane, \u03c0, is defined by its plane equation n\u00b7p+d=0, where nis the plane's normal and dan offset. A point p is outside the plane if n\u00b7p+d>0 (assuming outward-facing normals). If a point is inside all planes, then it is inside the frustum.","In our case, we want to test the frustum planes against a hierarchy of linearly moving bounding boxes, and at leaf nodes compute a conservative time segment in which the moving box may intersect the frustum. In the most general case, the bounding boxes are object-oriented 4D hypertrapezoids, but similar computations are performed in the simpler cases. We start by transforming the frustum planes into the local coordinate frame of the bounding box hierarchy, which reduces the problem to plane-moving AABB tests. For static geometry, it is enough to test the corner of the AABB that is farthest in the negative direction (n-vertex) relative to \u03c0, in order to determine if the box intersects. The sign bits of the plane's normal, n, directly decides which corner is the n-vertex. The same holds true for linearly moving bounding boxes, as the orientations of the frustum planes and bounding boxes remain constant. In ), we test each frustum plane against the vertex farthest in the negative direction relative to the plane, in order to find out if the moving box overlaps the frustum. For leaf nodes, we additionally solve for the time of intersection .","The n-vertex of the moving AABB is given as: p(t)=(1\u2212t)q+tr, where t\u03b5[0, 1]. Hence, to determine if a bounding box in the hierarchy intersects a frustum plane, we test the two points p()=qand p()=ragainst the plane. If both are outside, we can trivially reject the box as it can never be inside, giving the following simple inside test:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1\u2002 \u2003bool IsNodeInside( )"]},{"entry":[{},"2\u2002 \u2003{"]},{"entry":[{},"3\u2002 \u2003\u2003\u2003for each frustum plane i=1..6"]},{"entry":[{},"4\u2002 \u2003\u2003\u2003{"]},{"entry":[{},"5\u2002 \u2003\u2003\u2003\u2003\u2003d0 = dot(n_i,q_n) + d_i"]},{"entry":[{},"6\u2002 \u2003\u2003\u2003\u2003\u2003d1 = dot(n_i,r_n) + d_i"]},{"entry":[{},"7\u2002 \u2003\u2003\u2003\u2003\u2003if (d0>0 && d1>0) return false"]},{"entry":[{},"8\u2002 \u2003\u2003\u2003}"]},{"entry":[{},"9\u2002 \u2003\u2003\u2003return true"]},{"entry":[{},"10 \u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that it is not necessary for the plane equations to be normalized. A hardware implementation might exploit this by, e.g., setting up plane normals that always have one component equal to 1.0, thereby avoiding one multiplication per dot product. Additionally, the comparisons are normally done by moving di to the right-hand side, reducing the cost to 4 Multiply-Adds (MADDs) per frustum plane. Another minor optimization to exploit is the fact that the near and far planes are parallel. Hence, we only have to compute the dot products q\u00b7nand r\u00b7nonce for these two planes, and use different d.","At leaf nodes in the hierarchy, we are additionally interested in computing the point of intersection in time, which is given by:",{"@attributes":{"id":"p-0042","num":"0041"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mrow":{"msub":{"mi":["n","i"]},"mo":"\u00b7","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mi":"t"}},"mo":"\u2062","msub":{"mi":["q","n"]}},"mo":"+","msub":{"mi":["tr","n"]}}}},"mo":"+","msub":{"mi":["d","i"]}},{"mrow":[{"mn":"0","mo":["\u2062","\u27fa"],"mstyle":{"mtext":{}},"mi":"t"},{"mfrac":{"mrow":[{"mi":"d","mo":"+","mrow":{"msub":[{"mi":["n","i"]},{"mi":["q","n"]}],"mo":"\u00b7"}},{"mrow":[{"msub":[{"mi":["n","i"]},{"mi":["q","n"]}],"mo":"\u00b7"},{"msub":[{"mi":["n","i"]},{"mi":["r","n"]}],"mo":"\u00b7"}],"mo":"-"}]},"mo":"."}],"mo":"="}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"Note that the nominator and both terms in the denominator are already needed in the simple test, so the only additional cost is a subtraction and a division. The division can be made in very low precision in hardware, as long as the result is always conservatively rounded. We start with the full time interval, [t, t]=[0, 1], and progressively refine it using min\/max operations. If the interval ever becomes empty, i.e., t>t, we can make an early-out. This catches some of the cases, which would normally be falsely classified as inside. An example is shown in ). In this case, the box is only briefly inside the far plane, while it is inside the other plane only towards the opposite end of the movement. There is no point in time where it is inside both planes simultaneously, and hence a false positive is avoided.","The following pseudo-code illustrates the algorithm:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1\u2002 \u2003bool IsLeafInside(float& t_min, float& t_max)"]},{"entry":[{},"2\u2002 \u2003{"]},{"entry":[{},"3\u2002 \u2003\u2003\u2003[t_min,t_max] = [0,1]"]},{"entry":[{},"4\u2002 \u2003\u2003\u2003for each frustum plane i=1..6"]},{"entry":[{},"5\u2002 \u2003\u2003\u2003{"]},{"entry":[{},"6\u2002 \u2003\u2003\u2003\u2003\u2003d0 = dot(n_i,q_n) + d_i"]},{"entry":[{},"7\u2002 \u2003\u2003\u2003\u2003\u2003d1 = dot(n_i,r_n) + d_i"]},{"entry":[{},"8\u2002 \u2003\u2003\u2003\u2003\u2003if (d0>0 && d1>0) return false"]},{"entry":[{},"9"]},{"entry":[{},"10 \u2003\u2003\u2003\u2003\u2003if (d0>0) \/\/ p_n moves from out to in"]},{"entry":[{},"11 \u2003\u2003\u2003\u2003\u2003\u2003\u2003Compute t"]},{"entry":[{},"12 \u2003\u2003\u2003\u2003\u2003\u2003\u2003t_min = max(t_min, t)"]},{"entry":[{},"13 \u2003\u2003\u2003\u2003\u2003else if (d1>0) \/\/ p_n moves from in to out"]},{"entry":[{},"14 \u2003\u2003\u2003\u2003\u2003\u2003\u2003Compute t"]},{"entry":[{},"15 \u2003\u2003\u2003\u2003\u2003\u2003\u2003t_max = min(t_max, t)"]},{"entry":[{},"16 \u2003\u2003\u2003\u2003\u2003\/\/ else: both inside, no need to update times"]},{"entry":[{},"17"]},{"entry":[{},"18 \u2003\u2003\u2003\u2003\u2003if (t_min > t_max) return false \/\/ early-out"]},{"entry":[{},"19 \u2003\u2003\u2003}"]},{"entry":[{},"20 \u2003\u2003\u2003return true"]},{"entry":[{},"21 \u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the above two algorithms, we have assumed that all six frustum planes need to be tested. However, if a moving box is entirely inside a plane, it is unnecessary to test its children against the same plane, as these are guaranteed to be inside as well. Doing this at every level in the traversal and masking out the relevant planes requires testing the vertex farthest in the positive direction (the p-vertex) against the planes at t=0 and t=1, which essentially doubles the cost of the test and generally does not pay off. However, the moving patch rarely intersects the near\/far planes, so we start by testing the p-vertex against these at the root level, and continue with a cheaper 4-sided frustum traversal, if possible.","At a high level, our algorithm first performs frustum traversal to identify tiles that overlap the moving patch (, diamond ). In these tiles, individual rays are created and cast through the hierarchy (, block ). In general, the rays in a tile will take a similar path through the tree and often only intersect one or a few leaves. Hence, it is in many cases unnecessary to start the ray traversal at the root of the tree, as all rays in a tile will take the same path for the first few levels. During frustum traversal, we find the first node in the hierarchy where the traversal of the individual rays will start to diverge. We call this the branch node, B, for the tile. In the per-sample traversal step, we start the ray traversal directly from B.","We propose two different ways of finding the branch node. The simplest method is to use the first node in the hierarchy where the frustum overlaps both children's bounding boxes as branch node. Incidentally, in a stack-based traversal, this is the first node in which a child node needs to be pushed on the stack. If this never occurs and the tile is not rejected, there is by construction only one intersected leaf, in which case we directly use the leaf as starting node. The drawback of this method is that the interior nodes' bounding volumes are overly conservative. A frustum may very well intersect both children, although the traversal for one of them is later terminated before reaching the leaves. Hence, rays will be started higher up in the hierarchy than necessary. This is illustrated in ). Intersected leaves are marked with a filled circle, and intersecting interior nodes with hollow circles.","The alternative is to note exactly which leaves the frustum intersects, and then find the first node with two subtrees that has leaves overlapping the frustum. In a recursive implementation, this information would be easy to backtrack post-recursion, but in a stack-based traversal, the interior nodes are never revisited once they have been processed. Instead, we propose a simple binary method, which keeps a bit mask with n bits, where n is the number of leaf nodes. The mask represents the nodes linearly laid out in memory, and is initialized to zero. When overlapping leaves are found, they are marked by 1s. After traversal, the bit mask is hierarchically reduced using OR operations. The branch node is found by looking for the bottommost level that has only a single bit set. This is the point where per-ray traversal needs to be initiated. See ) for an example.","It should be noted that, as the tree typically only has a handful of levels, this is an inexpensive way to find the true branch node. At each level, testing if it has a single bit set can be done by testing if x&(x\u22121) is equal to zero. This works since we know there is always at least one bit set, otherwise the whole tile would have been rejected.","In graphics processing unit architectures, it is common to use a hierarchical z-buffer to quickly cull tiles of pixels for geometry that is occluded. Similarly, we can cull parts of the patch early by initializing the far plane of the tile frustum to zfor the tile, instead of to the position of the far clipping plane. This potentially further reduces the amount of work spent on rendering occluded geometry, as fewer per-sample traversals have to be performed.","After the tile frustum traversal has determined that a screen-space tile overlaps with the moving patch (, diamond ), all samples within this tile needs to be tested (, block ). The exact placement of samples is orthogonal to our algorithm, and may be chosen arbitrarily. In general, we have a set of 5D sample points, s=(x,y,u,v,t), where x,yare screen-space coordinates, u,vare lens position, and tis sample time. If only motion blur or only depth of field is used, u, vor tare omitted, respectively. First, if a time overlap was computed during tile frustum traversal, all samples with a time, t, outside this range can be directly rejected. The remaining samples are converted into rays, o+zd, and transformed into the local coordinate frame of the bounding box hierarchy, if necessary.","The rays are then traversed through the hierarchical data structure in order to find leaf nodes they intersect (block ). If a branch node, B, was computed during the tile frustum traversal, we start the traversal at this node instead of at the root node. This can significantly reduce the number of interior nodes that need to be traversed, especially for larger primitives or when the motion is limited. At leaves in the hierarchy, the samples are tested against the individual triangles. Each such test can be a standard ray-triangle intersection test executed on the triangle displaced according to t, or be done as an inside test using time-continuous edge equations in homogeneous space. Samples that hit a primitive (diamond ) are written to an output queue for further processing by the back end (block ). When all the samples in a tile have been tested (, block ) and all the tiles have been tested (, block ), we are done rendering the current patch. At this point, all temporary resources may be released and the algorithm may restart from the beginning with a new patch or subset of a patch.","One of the benefits of some embodiments our hybrid rasterization and ray casting approach, is that we can exploit the z-buffer to reduce the cost for partially or fully occluded patches. To do so, we initiate the rays' tto the depth of the current sample read from the z-buffer. Hence, the traversal effectively avoids visiting nodes that are known to be occluded.","In the most general case, the nodes in our bounding box hierarchy are bounded by 4D hyper-trapezoids, i.e., oriented 3D bounding boxes at t=0 and t=1 with identical orientation that are linearly interpolated in time. We follow the standard strategy for ray-AABB intersection, which sees the bounding box as an intersection of three axis-aligned slabs. The entry and exit ray parameters are computed for each slab according to z=(x\u2212o)\/d, and min max operations used to find the ray's overlap, if any. In our case, the location of the slabs' planes are time-dependent functions, e.g., [x(t),x(t)]. The position of the planes at the sample's time ti are given by (similar for the y and z axes):\n\n()=(1),\n\n()=(1),\u2003\u2003(2)\n\nwhere xand x, j\u03b5{0,1}, are the positions of the planes along the x-axis at t=0 and t=1. For a ray with positive direction, the ray's entry point is given by:\n",{"@attributes":{"id":"p-0056","num":"0055"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"msub":{"mi":["t","entry"]},"mo":"=","mrow":{"mrow":{"mo":["[","]"],"mrow":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msub":{"mi":["t","i"]}}},"mo":"\u2062","msubsup":{"mi":["x","min"],"mn":"0"}},{"msub":{"mi":["t","i"]},"mo":"\u2062","msubsup":{"mi":["x","min"],"mn":"1"}}],"mo":["+","-"],"msub":{"mi":["o","x"]}}},"mo":"\u00b7","mfrac":{"mn":"1","msub":{"mi":["d","x"]}}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"msubsup":[{"mi":["Ax","min"],"mn":"0"},{"mi":["Bx","min"],"mn":"1"}],"mo":["+","+"],"mrow":{"mi":"C","mo":"."}}}}}]}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}},"br":{},"sub":"exit"},{"@attributes":{"id":"p-0057","num":"0056"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"A","mo":"=","mfrac":{"mrow":{"mn":"1","mo":"-","msub":{"mi":["t","i"]}},"msub":{"mi":["d","x"]}}},{"mi":"B","mo":"=","mfrac":{"msub":[{"mi":["t","i"]},{"mi":["d","x"]}]}},{"mrow":[{"mi":["and","C"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":"-","mrow":{"mfrac":{"msub":[{"mi":["o","x"]},{"mi":["d","x"]}]},"mo":"."}}],"mo":"="}],"mo":[",",","]}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}}},"These constants only depend on the sample's parameters, so can be pre-computed before traversal starts and reused for all bounding box tests performed for the ray. In total, there are three slabs for which we compute entry\/exit points according to Equation 3, at a total cost of 12 MADDs per ray-box test in the general case.","The output from our patch rendering algorithm is a number of visibility samples, i.e., sample points that overlap primitives in the tessellated patch. Note that if alpha-testing is enabled, all intersections need to be returned (not just the nearest) in order to resolve partial transparency. The design of the pixel back end is not specific to our invention. Depending on the architecture the samples may be directly shaded, either at sample frequency (super-sampled antialiasing) or at pixel frequency (multi-samples antialiasing), as done in a traditional GPU. Note that care has to be taken with respect to how derivatives are computed if the samples do not form a regular grid in screen space. McGuire et al. [2010], for example, manually compute derivatives in the pixel shader, instead of relying on the finite differences over 2\u00d72 quads provided by the hardware.","It is also possible to entirely decouple the shading frequency from the visibility sampling frequency using a shading cache or by shading on a grid in object space. These approaches are very promising in that they can make the shading cost largely independent of the amount of blur, which is important for a high and predictable performance. They do, however, represent a larger step away from how GPUs currently operate.","We have presented an efficient method for rendering tessellated geometry with real motion blur and defocus blur. For small-triangle workloads, it combines the performance benefits of state-of-the-art ray tracing approaches, while maintaining compatibility with the feed-forward rasterization pipeline of modern GPU parts and graphics APIs in some embodiments.","We do not require a global view of the scene geometry, avoiding construction and storage of this structure. Each tessellated patch is handled one at a time, in streaming order. The time-dependent data structure may be quickly constructed immediately prior to rasterization in some embodiments. The rasterizer traverses this structure to generate visible fragments, and then the structure is discarded. Since the data structure is small and built on-demand from streaming pipeline data, it can remain on-chip and be discarded after it is consumed. Additionally, we perform frustum traversal against the time-dependent local data structure, which has not been done in this context before. In one embodiment, our data structure is constructed and traversed entirely in screen-space, resulting in increased performance in construction, storage, and in most common cases, traversal as well.","Our algorithm handles small primitives in groups in order to improve the sampling efficiency, in some embodiments. In doing so, we exploit the spatial locality among the primitives generated by a fine-grained tessellation pipeline stage. Our approach computes visibility over the temporal domain in a single pass, thereby avoiding redundant execution of any pipeline stage, in some embodiments.","The computer system , shown in , may include a hard drive  and a removable medium , coupled by a bus  to a chipset core logic . The computer system may be any computer system, including a smart mobile device, such as a smart phone, tablet, or a mobile internet device. A keyboard and mouse , or other conventional components, may be coupled to the chipset core logic via bus . The core logic may couple to the graphics processor , via a bus , and the central processor  in one embodiment. The graphics processor  may also be coupled by a bus  to a frame buffer . The frame buffer  may be coupled by a bus  to a display screen . In one embodiment, a graphics processor  may be a multi-threaded, multi-core parallel processor using single instruction multiple data (SIMD) architecture.","In the case of a software implementation, the pertinent code may be stored in any suitable semiconductor, magnetic, or optical memory, including the main memory  (as indicated at ) or any available memory within the graphics processor. Thus, in one embodiment, the code to perform the sequences of  may be stored in a non-transitory machine or computer-readable medium, such as the memory , and\/or the graphics processor , and\/or the central processor  and may be executed by the processor  and\/or the graphics processor  in one embodiment.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 4","FIG. 4"]},"The graphics processing techniques described herein may be implemented in various hardware architectures. For example, graphics functionality may be integrated within a chipset. Alternatively, a discrete graphics processor may be used. As still another embodiment, the graphics functions may be implemented by a general purpose processor, including a multicore processor.","References throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one implementation encompassed within the present invention. Thus, appearances of the phrase \u201cone embodiment\u201d or \u201cin an embodiment\u201d are not necessarily referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be instituted in other suitable forms other than the particular embodiment illustrated and all such forms may be encompassed within the claims of the present application.","While the present invention has been described with respect to a limited number of embodiments, those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"i":["a ","b "]},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
