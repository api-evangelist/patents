---
title: Eliminating superfluous namespace declarations and undeclaring default namespaces in XML serialization processing
abstract: In one embodiment, at least a portion of an object model having at least one namespace is serialized. An ancestor namespace is searched for based on a current namespace declaration. The ancestor namespace is associated with an ancestor prefix and an ancestor uniform resource indicator (URI). The current namespace is associated with a current prefix and current URI. The search is performed to find an ancestor prefix matches the current prefix. When the current namespace is an implicit no default namespace and the ancestor namespace is an explicit default namespace based on, at least in part, the ancestor prefix, a serialized namespace declaration is generated for the current namespace.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07120864&OS=07120864&RS=07120864
owner: International Business Machines Corporation
number: 07120864
owner_city: Armonk
owner_country: US
publication_date: 20040127
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","A Template-based Technique","A Hashing Technique","Recursive SQL\/XML queries"],"p":["1. Field of the Invention","The present invention relates generally to serialization of XML data, and in particular to XML canonicalization.","2. Description of the Related Art","Databases allow data to be stored and accessed quickly and conveniently. Various query languages may be used to access the data. An example of a typical query language is the Structured Query Language (SQL) which conforms to a SQL standard as published by the American National Standards Institute (ANSI) or the International Standards Organization (ISO). An extensible mark-up language (XML) can represent data in a serial text format. XML text can be conveniently exchanged with applications over the Internet. XML query languages, such as SQL\/XML and XQuery, can be used to retrieve data from a database and represent that data in XML format.","XML query languages contain query features, called constructors, which are used to construct XML data based on input data. The constructed XML data may be stored in an internal format, such as a tree that conforms to the XQuery data model. Eventually, in many cases, the constructed XML data goes through a serialization process to generate equivalent XML text (or binary stream), also referred to as serialized data or text, for applications to consume.","An XML document may contain many element names and attribute names, and names that represent semantic information. In W3C recommendation, \u201cNamespaces in XML\u201d, REC-xml-names-19990114, Jan. 14, 1999, to avoid name conflict, XML provides a mechanism, referred to as XML namespaces. An XML namespace provides a unique name so that semantics of names associated with the namespace are well-defined. The XML namespace is a fundamental feature of XML and in the constructed XML data. An XML namespace has a namespace name (a uniform resource identifier, i.e. URI), which is bound to a namespace prefix, and is sometimes represented as (prefix, URI). The URI is used to identify and locate resources on the Internet, and the prefix is used as a proxy for the URI.","In the serialized data, a namespace declaration, signified by the \u201cxmlns\u201d attribute name or prefix, is used to declare a namespace. Due to syntactic and semantic requirements of query languages, the literally serialized XML text from constructed data in an internal XML format often contains redundant XML namespace declarations. If the data returned in response to a SQL\/XML query is literally serialized into text format, the namespace declarations can sometimes take up the major portion of the XML text. To reduce the amount of data and application processing expense, it is desirable to reduce the number of redundant or superfluous namespace declarations in the serialized XML text. Eliminating superfluous namespace declarations is also a part of XML canonicalization, W3C recommendation, \u201cCanonical XML Version 1.0\u201d, 15 Mar. 2001.","In addition, when a portion of the XML data, such as an XML fragment or sub-tree, is constructed without a default namespace, but later is connected to a containing fragment or tree with a default namespace, the fragment without the default namespace has to \u201cundeclare\u201d the default namespace in the containing fragment. If the default namespace is not undeclared, the XML fragment or sub-tree will inherit the default namespace, which is not correct, and will cause errors.","Therefore there is a need for a technique to eliminate redundant or superfluous namespace declarations. There is also a need for a technique to undeclare inherited default namespaces for fragments or sub-trees which are constructed without a default namespace.","To overcome the limitations in the prior art described above, and to overcome other limitations that will become apparent upon reading and understanding the present specification, various embodiments of a method, apparatus, and article of manufacture for performing serialization for query processing are disclosed.","In one embodiment, during serialization of at least a portion of an object model having at least one namespace, a search is performed for an ancestor namespace based on a current namespace. The ancestor namespace is associated with an ancestor prefix and an ancestor uniform resource identifier (URI). The current namespace declaration is associated with a current prefix and current URI. A search is performed to find an ancestor prefix matches the current prefix. When the current namespace is an implicit no default namespace and the ancestor namespace is an explicit default namespace based on, at least in part, the current prefix, a serialized namespace declaration is generated for the current namespace.","In another embodiment, when no ancestor namespace has an ancestor prefix that matches the current prefix, or when an ancestor namespace matches the current prefix and the current URI is different from the ancestor URI, a serialized namespace declaration is generated for the current namespace.","In this way, inherited default namespaces for fragments or sub-trees which are constructed without a default namespace are undeclared. In addition, redundant or superfluous namespace declarations are eliminated.","After considering the following description, those skilled in the art will clearly realize that the teachings of the various embodiments of the present invention can be utilized to perform serialization for query processing. The various embodiments of the present inventive technique are suited to processing a query and generating serialized text using the SQL\/XML or XQuery language; however, some embodiments of the present inventive technique may also be applied to any XML serialization process.","In one embodiment, a portion of an object model is serialized. The object model has at least one namespace. A search is performed for an ancestor namespace based on a current namespace. The ancestor namespace is associated with an ancestor prefix and an ancestor URI. The current namespace is associated with a current prefix and current URI. The search is performed to find an ancestor prefix matches the current prefix. When the current namespace is an implicit no default namespace and the ancestor namespace is an explicit default namespace based on, at least in part, the ancestor prefix, a serialized namespace declaration is generated for the current namespace.","In another embodiment, when no ancestor namespace has an ancestor prefix that matches the current prefix, or when an ancestor namespace matches the current prefix and the current URI is different from the ancestor URI, a serialized namespace declaration is generated for the current namespace.","In a more particular embodiment, a technique performs serialization for an object model. When a current element has a namespace declaration comprising a current prefix and a current URI, the technique determines whether an ancestor namespace declaration, if any, has the same prefix and URI. When no ancestor namespace declaration has the same prefix, a serialized namespace declaration is generated for the current namespace declaration. When one or more ancestor namespace declarations that have the same prefix as the current namespace declaration, and when the closest ancestor namespace declaration with the same prefix also has the same URI as the current namespace declaration, no serialized namespace declaration is generated for the current namespace declaration. Otherwise, a serialized namespace declaration is generated for the current namespace declaration. In another embodiment, implicit no default namespace declarations are used to undeclare inherited default namespaces for fragments or sub-trees which are constructed without a default namespace. If an implicit no default namespace is not part of a subtree that contains a default namespace declaration, no serialized namespace declaration is generated for the implicit no default namespace.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1","b":["30","30","32","34","36","38","40","42","44","36","46","48","42","50","38","30","38","52","38","38"]},"The memory  generally comprises different modalities, illustratively semiconductor memory, such as random access memory (RAM), and disk drives. In some embodiments, the memory  stores an operating system , database management system  and database tables  used by the database management system . The database management system  comprises a query processor  and a serialization module . The computer system  receives a SQL\/XML query . For example, the SQL\/XML query  may have been sent from another application to the computer system  via the Internet. The query processor  retrieves the data  from the database tables  in response to the SQL\/XML query . The serialization module  generates serialized XML text  based on the SQL\/XML query  and the retrieved data .","Depending on the embodiment, the memory also stores data structures including, but not limited to, any one or combination of the following: an object model , a stack , a hash table , linked-list(s) , tagging template(s) , and calling stack . These data structures will be described in further detail below.","In some embodiments, the specific software instructions, data structures and data that implement various embodiments of the present inventive technique are incorporated in the database management system . However, the present invention is not meant to be limited to use in database management systems, in other embodiments, the present inventive technique can be used in other applications for XML serialization. Generally, an embodiment of the present invention  is tangibly embodied in a computer-readable medium, for example, the memory  and is comprised of instructions which, when executed by the processor , cause the computer system  to utilize the present invention. The memory  may store a portion of the software instructions, data structures and data for any of the operating system , database management system  and database tables  in semiconductor memory, while other portions of the software instructions and data are stored in disk memory.","The operating system  may be implemented by any conventional operating system, such as z\/OS\u00ae (Registered Trademark of International Business Machines Corporation), AIX\u00ae (Registered Trademark of International Business Machines Corporation), UNIX\u00ae (UNIX is a registered trademark of the Open Group in the United States and other countries), WINDOWS\u00ae (Registered Trademark of Microsoft Corporation) and LINUX\u00ae (Registered trademark of Linus Torvalds).","In various embodiments, the present invention may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term \u201carticle of manufacture\u201d (or alternatively, \u201ccomputer program product\u201d) as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier or media. In addition, the software in which various embodiments are implemented may be accessible through the transmission medium, for example, from a server over a network. The article of manufacture in which the code is implemented also encompasses transmission media, such as a network transmission line and wireless transmission media. Thus the article of manufacture may also comprise the medium in which the code is embedded. Those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention.","The exemplary computer system illustrated in  is not intended to limit the present invention. Other alternative hardware environments may be used without departing form the scope of the present invention.","In the SQL\/XML query language, an XMLELEMENT constructor creates an XML element; and the XMLFOREST constructor creates a forest of XML elements from a list of arguments. XML constructors, such as XMLELEMENT and XMLFOREST, can have XML namespace declarations inside them, using the XMLNAMESPACES constructor.","Namespaces are associated with a scope to which a namespace applies. Per the W3C Recommendation, \u201cNamespaces in XML\u201d, REC-xml-names-19990114, Jan. 14, 1999, a namespace declaration applies to the element where the namespace declaration is specified and to all elements within the content of that element, unless overridden by another namespace declaration with the same prefix.","XML namespaces declared by the XMLNAMESPACES constructor are considered to be \u201cin-scope\u201d based on the syntactic boundary of the immediately enclosing constructor. A reference to a namespace prefix is valid if there is a corresponding namespace declaration that is in-scope.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 2","b":["90","92","94","95"]},"For example, the namespace prefix \u201chr\u201d  is in-scope from the open parenthesis  following the first XMLELEMENT to the close parenthesis  at the end. There is no need to declare the namespace prefix \u201chr\u201d in any of the inner XMLELEMENTs, since the \u201chr\u201d namespace prefix with the XMLELEMENTS is declared within the scope of the namespace prefix \u201chr.\u201d In example one, conventional serialization does not produce redundant namespace declarations.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 3","FIG. 2","FIG. 3"],"b":["100","90","102","92","94","100"]},"In  and in subsequent examples of serialized XML text, namespace declarations and elements will typically be shown on different lines to improve readability. In practice, the serialized XML text may be a continuous stream without \u201ccarriage return\/line feeds\u201d at the end of the namespace and element declarations.","Using conventional processing for XML constructors, the same XML namespace declarations may be repeated many times in different places in the serialized XML text, because the sub-elements are not in each other's scopes.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 4","b":["110","112","114","116","118","122","124"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 5","FIG. 4"],"b":["130","132","134","136","138"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 6","FIG. 6","FIG. 2"],"b":["140","142"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 7","FIG. 6"],"b":"150"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 8","FIG. 8"],"b":["160","161","162","164","166","167","168","169","170","161","172","162","174"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 9","FIG. 8","FIG. 8"],"b":["180","182","184","186"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 10","FIG. 8"],"b":["190","192","194","192","194","186"]},"Referring back to , according to the rules of the SQL\/XML language, within the scope defined by  and  in the second query block, there is no namespace declaration. This lack of a namespace is referred to as an implicit no default namespace. The namespace associated with a no default namespace is the \u201cno namespace,\u201d which is associated with an empty prefix and an empty URI, (\u201c\u201d, \u201c\u201d).",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 11","FIG. 10"],"b":["200","202","202"]},"When users explicitly specify either of the following two forms for a constructed XML element, then that XML element has an explicit no default namespace declaration. The two forms for a constructed XML element are:\n\n","Various embodiments of the present inventive technique generate correctly serialized XML text for both implicit and explicit no default namespaces. Some embodiments of the present inventive technique eliminate superfluous namespace declarations, including default namespace declarations, which saves space.","Some embodiments of the present inventive technique are applied to the XQuery language. A similar problem to that described with respect to  also occurs in the XQuery language. In XQuery, namespaces are declared in a prolog. For simplicity, various embodiments of the present inventive technique will be described with respect to SQL\/XML; however, other embodiments can be applied to the XQuery language as well as any SQL\/XML serialization process.","Typically, processing comprises two phases\u2014a compilation phase and an execution phase. In the compilation phase, the query is analyzed and an execution plan is built. In the execution phase, an object model, typically a tree, containing retrieved data is generated and serialized text is generated based on the object model.","Some of the problems described above may appear to be solvable during the compilation phase. That is, superfluous namespace declarations could be removed internally from a query after semantic checking. Superfluous namespace declarations are not removed during the compilation phase because rewriting the query during compilation alone cannot achieve the goal of canonicalization in cases where the same XML data containing a namespace declaration is referenced in two places and one reference has the namespace declared while the other does not. For one reference, the namespace declaration can be removed but not according to the other reference. Referring back to , for example, if the element X.emplist were referenced in an XMLELEMENT in the top SELECT block which did not have namespace \u201chr\u201d declared, then the namespace declaration  inside XMLAGG cannot be removed. Using a copying technique, the constructor can be copied and replicated in the query block containing it, and the namespace declaration can be removed from one copy and kept in the other copy. However, the copying technique results in multiple evaluations of the same constructor, which incurs substantial execution time. Moreover, if the constructor contains non-deterministic functions or external actions, two copies will produce different results or side effects. Therefore, in general, making copies is undesirable.","In addition, the constructed XML data (in internal tree or other format), that is, the object model, should contain all the namespace declaration information. Removing namespaces from fragments or sub-trees too soon may cause semantic problems during processing of the data. Therefore, various embodiments of the present inventive technique do not remove namespace declarations during the compilation phase. In some embodiments, the present inventive technique performs pre-processing during the compilation phase to undeclare default namespaces as will be described below in further detail with reference to . Other embodiments, described below with reference to , remove superfluous namespace declarations and\/or undeclare default namespaces based on the preprocessing during the execution phase.",{"@attributes":{"id":"p-0075","num":"0076"},"figref":["FIG. 12","FIG. 1"],"b":["204","66"]},"In the execution phase as indicated by dashed block , in step , the object model  () containing the retrieved data is generated in accordance with the execution plan. The object model is a representation of the constructed data. In some embodiments, the object model is a tree. In other embodiments, the object model is a logical tree comprising templates with data records. In yet other embodiments, the object model is a well-known W3C Document Object Model, or, alternately, the XQuery data model. Typically, the query processor  () generates the object model as part of the query evaluation performed at execution time.","In step , serialized XML text is generated based on the object model. Typically, the serialization module  () traverses the object model and generates serialized XML text. In some embodiments, default namespaces are undeclared in accordance with the identified implicit-no-default namespaces, and superfluous namespace declarations are eliminated.",{"@attributes":{"id":"p-0078","num":"0079"},"figref":["FIG. 13","FIG. 12"],"b":"204"},"In various embodiments, the flowchart of  is applied in the compilation phase, during traversal of the parse tree of a query, when a constructor with potential namespace declarations is encountered. Alternately, the flowchart of  may be applied outside the compilation phase, but prior to invoking the serialization module.","In , the following steps are applied to an XMLELEMENT or XMLFOREST constructor. In some embodiments, an XMLFOREST declaration is converted into an equivalent list of XMLELEMENTs. In step , an implicit-no-default indicator is cleared. The implicit-no-default indicator is associated with the constructor and will be used to indicate whether there is an implicit no default namespace associated with the constructor. Step  determines whether the constructor is at the top query block. When the constructor is not at the top query block, step  determines whether the constructor has an explicit default or an explicit no-default namespace declaration. When the constructor does not have an explicit default or an explicit no-default namespace declaration, step  determines whether the constructor is at the top of a nested constructor. When step  determines that the constructor is at the top of a nested constructor, , the implicit-no-default indicator is set for that constructor. In step , the pre-processing continues.","When step  determines that the constructor is in the top query block, the processing continues to step . When step  determines that the constructor does have an explicit DEFAULT or explicit NO DEFAULT namespace declaration, the processing continues to step . When step  determines that the constructor is not at the top of a nested constructor, processing continues at step .","For example, referring also to , if the NO DEFAULT namespace declaration  were removed, the pre-processing would identify that there should be an implicit no default namespace.","In an alternate embodiment, in step , a no default namespace is also added to provide an implicit no default namespace. The no default namespace is represented as a namespace having an empty prefix and empty URI.","In yet another embodiment, for a namespace with an expressly declared prefix, the implicit-no-default indicator is not set. Alternately, for a namespace with an expressly declared prefix, the implicit-no-default indicator is set, and subsequently ignored for the expressly declared prefix during serialization. In some embodiments, the implicit-no-default indicator is a flag.",{"@attributes":{"id":"p-0085","num":"0086"},"figref":["FIG. 14","FIGS. 2 and 3","FIG. 14"],"b":["230","232","234","232","235","234","238","240","242","232","232","238","240","242","238","240","242","232","242","246","248"]},{"@attributes":{"id":"p-0086","num":"0087"},"figref":["FIGS. 15A and 15B","FIG. 1","FIGS. 15A and 15B"]},"In some embodiments, the stack  () is used to store the namespace scoping. Various embodiments of the present inventive technique will now be described with respect to the stack. In some embodiments, the technique of  is applied to a tree that contains the retrieved data in accordance with a query, for example, the tree of . During serialization the tree is traversed in pre-order. Typically, when a new element is processed, namespace declarations associated with the element are pushed onto the stack, as a list of pairs comprising the prefix and URI for the namespaces, (prefix, namespace URI).","During the execution phase, logically, the stack stores in-scope namespace declarations. The stack is searched for a current namespace prefix from the top to the bottom. If the same namespace prefix as the current namespace prefix appears in the stack, the namespace prefix closer to the top of the stack overrides the namespace prefix closer to the bottom of the stack. When a namespace declaration is encountered, whether to generate the namespace declaration in the serialized XML text depends on whether the same namespace declaration is in-scope. When the same namespace appears in-scope, the current namespace declaration is superfluous, and serialized XML text is not generated. When the same namespace is not in-scope, various embodiments determine if the namespace declaration is an implicit no default namespace. For an implicit no default namespace, a serialized namespace declaration is not generated. For any other namespace declaration, a serialized namespace declaration is generated. After the processing for an element is completed, when leaving the element, any associated namespace declaration entries for that element in the stack are popped off. If an element has no namespace declaration, the namespace declaration entry for that element in the stack will be an empty list.","To maintain in-scope namespaces, when an element is encountered, a namespace declaration list associated with the element is pushed onto the stack. An empty list is pushed if there are no namespace declarations for the element. The namespace declaration list is typically represented by a list header, followed by a list of prefix and URI pairs. An empty namespace declaration list has a header without any prefix and URI pairs. When the serialization for the element is complete, that is, an end of element, or end-tag has been output as serialized XML text, the namespace declaration list associated with that element is popped off the stack.","In , in block , the serialization module is invoked and a current node is passed as an argument. Initially, the current node is the root node.","Step  determines whether the current node is an ELEMENT node. When step  determines that the current node is not an ELEMENT node, in step  serialized XML text is generated for the current node, and in step  returns to the invoking module. When step  determines that the current node is an ELEMENT node, step  determines whether any namespace declarations are associated with the current ELEMENT node. For example, referring back to , the namespace declaration associated with an element is shown as a separate node; however, the processing for a namespace node is performed with the processing of the namespace node's associated ELEMENT node. In some embodiments, the namespace node may not be considered to be a node in the same sense as other nodes.","When step  determines that a namespace declaration is associated with the ELEMENT node, in step , a namespace declaration list of the namespace declarations, nto n, for the element node is retrieved. The process continues via continuator A to step  of .","In , in step , a counter, i, is set equal to one to reference the first namespace declaration in the namespace declaration list. The counter is used to track the namespace declaration that is being processed from the namespace declaration list. The current namespace declaration being processed is referred to as namespace declaration n. One of the namespaces in the namespace declaration list may be an implicit no default namespace with the implicit-no-default indicator from the pre-processing.","In step , the stack is searched from top to bottom for a namespace declaration having the same prefix as namespace declaration n. For the search, an implicit no default namespace or an explicit no default namespace declaration is considered to be the empty namespace (\u201c\u201d, \u201c\u201d). When an explicit default namespace is encountered, the prefix for that namespace is the empty prefix, \u201c\u201d. In some embodiments, the implicit-no-default indicator associated with the current namespace is checked to identify an implicit no default namespace. The search ends when a prefix matching the prefix for namespace declaration nis found or when the entire stack has been searched without finding a matching prefix for namespace declaration n. Step  determines whether the prefix for namespace declaration nis in the stack. In another embodiment, steps  and  are combined.","When step  determines that the prefix for namespace declaration nis in the stack, step  determines if the URI associated with the prefix in the stack is the same as the URI for namespace declaration n.","When step  determines that the URI associated with the prefix for namespace declaration nis not the same as the URI associated with the prefix in the stack, in step , serialized XML text is generated. When the namespace declaration is not DEFAULT or NO DEFAULT, the following text stream is generated: xmlns:prefix=\u201cURI\u201d. When the namespace declaration is DEFAULT, the following text stream is generated: xmlns=\u201cURI\u201d. When the namespace is explicit NO DEFAULT or implicit no default, the following text stream is generated: xmlns=\u201c\u201d. In step , the counter i is incremented by one to reference the next namespace declaration in the namespace declaration list.","When step  determines that the URI associated with the prefix in the stack is the same as the URI for namespace declaration n, the process continues to step , and no serialized XML text is generated. In this way, superfluous namespace declarations are not generated.","When step  determines that the prefix for namespace nis not in the stack, step  determines whether the namespace nis an implicit no default namespace. In various embodiments, the serialization module determines whether a namespace is implicit no default when the implicit-no-default indicator is set. When step  determines that namespace nis an implicit no default namespace, step  proceeds to step  and no serialized XML text is generated because there is no DEFAULT namespace in scope to undeclare.","When step  determines that namespace declaration nis not an implicit no default namespace, in step , serialized XML text is generated.","Step  determines whether the value of the counter i is greater than the value of n, where n represents the number of namespace declarations in the namespace declaration list. In other words, step  determines whether all the namespace declarations in the namespace declaration list for an element have been processed. When the value of i is less than or equal to the value of n, step  proceeds to step  to process the next namespace declaration in the namespace declaration list. Although the processing of the namespace declaration list has been described with respect to a counter, other well-known list processing techniques could be used. For example, each element in the namespace declaration list could be associated with a pointer to the next element in the namespace declaration list and an end-of-list indicator could be used to mark the end of the namespace declaration list.","In step , the namespace declaration list typically is pushed onto the stack. However, an implicit-no-default namespace for which no serialized text was generated is not pushed onto the stack. In some embodiments, another indicator, for example, a text-generated indicator, indicates whether serialized text was generated for the implicit no default namespace. In these embodiments, the text-generated indicator is set in step  after the serialized text is generated, and step  pushes the text-generated indicator on the stack as part of the namespace declaration list. In this way, the stack is used to store the ancestor namespace declarations for an element.","In step , for the child elements of the current node, any attribute and content nodes associated with the current ELEMENT node are serialized. To serialize any child elements, the traversal of the object model is in pre-order. In some embodiments, the object model is a tree which will be traversed starting at the current node and proceeding from left to right for the child nodes. Processing will be completed on a left sub-tree or node prior to processing the node to the right. When any child node of the current node is an ELEMENT node, the serialization module is invoked for that child element. In this way, the serialization process is recursive.","When step  completes, the child nodes of the current node will have been processed, serialized text for an end tag for the element node will have been generated, it is time to leave the current node. In step , the associated namespace declaration list for the current ELEMENT node, when previously pushed onto the stack, is popped off the stack. In some embodiments that use a text-generated indicator, step  will pop off the namespace declaration list with a text-generated indicator in it from the stack. In step , the serialization module returns to the invoking module. Because the serialization module is invoked recursively, the return ends the current invocation of the serialization module.","When step  of  determines that a namespace declaration is not associated with the ELEMENT node, processing continues via continuator B to step  of .","Typically, in , the serialization process is recursive and begins at the root node. The sub-elements of an ELEMENT are processed prior to completing the processing for that ELEMENT. In some embodiments, for example, except for a namespace node, the serialization module is invoked each time a new node is to be processed.","In another alternate embodiment which uses the text-generated indicator, in step , when searching through the ancestor namespaces in the stack for a matching prefix, when the text-generated indicator associated with an implicit default namespace is not set, the search skips that namespace.","An embodiment of the undeclaring of default namespaces will now be described. A no default namespace, both explicit and implicit, is represented as an empty pair (\u201c\u201d, \u201c\u201d); and, therefore, the following text stream is generated: xmlns=\u201c\u201d. A default namespace has an empty prefix, \u201c\u201d. If a parent, or alternately, an ancestor, node has a default namespace, in the stack, the namespace declaration list for the parent node will contain an empty prefix \u201c\u201d, and a non-empty URI. If the child element node has an implicit-no-default namespace, as indicated by the implicit-no-default indicator, in step , the stack is searched for an empty prefix. In this example, the empty prefix is found in step , and step  determines whether the URIs are the same. In this example, the implicit-no-default namespace is associated with an empty URI, while the empty prefix on the stack is associated with a non-empty URI. Therefore step  continues to step  and the following serialized text is generated: xmlns=\u201c\u201d. In this way, default namespaces are undeclared.","Referring back to , for example, a representation of the tree  is received. The stack is empty. Starting at the root node , processing starts with the leftmost branches before proceeding to the right. The root node  is an element node which has an associated namespace declaration as shown by the node  labeled \u201cxmlns\u201d.","Since the root node  is an element node, serialized XML text for a start tag is generated as follows: <hr:emp. Since there is a namespace declaration node  associated with the element node , a namespace declaration list containing the one namespace declaration is generated. In this example, the namespace declaration list has one entry. The stack is searched for the namespace declaration. Since the stack is empty, the prefix and URI for the node is not in the stack, and the namespace declaration is not an implicit no default namespace. Therefore, serialized XML text is generated using the prefix and URI. The counter i is incremented by one. Since the value of the counter i (2) is greater than the value of n (1), the namespace declaration, (prefix, URI), is pushed onto the stack. Any attribute and content nodes associated with the element node  are serialized.","The next node to process is the element node for \u201chr:empno\u201d  which has an associated text node . Since there is no associated namespace declaration (step ) the following XML text is generated: <hr:empno>1A7168<\/hr:empno>. The \u201chr:name\u201d and \u201chr:expertise\u201d element nodes,  and , respectively, are similarly processed. After the \u201chr:expertise\u201d node  is processed, since there are no more nodes to process for this \u201chr:emp\u201d element , the associated namespace declaration for the \u201chr:emp\u201d node is popped off the stack, and since there are no further nodes to process for , an end-tag is generated as follows: <\/hr:emp>. The process ends.",{"@attributes":{"id":"p-0111","num":"0112"},"figref":["FIG. 16","FIG. 14","FIG. 16","FIG. 14"],"b":["310","312","312","314","312"]},{"@attributes":{"id":"p-0112","num":"0113"},"figref":"FIG. 17","b":"320"},"In various embodiments, a tagging template is used to represent an element, and to form a chain of ancestor declarations rather than the stack. U.S. patent application Ser. No. 10\/325,781 teaches a method that uses tagging templates to represent the structures of the nested constructors, and intermediate records for the input data. Commonly assigned U.S. patent application Ser. No. 10\/325,781, titled, \u201cMethod, system, and program for optimizing processing of nested functions,\u201d is incorporated herein by reference in its entirety as background information. Another embodiment of the present inventive technique provides a new template structure for XML namespaces.",{"@attributes":{"id":"p-0114","num":"0115"},"figref":"FIG. 18","b":"330"},{"@attributes":{"id":"p-0115","num":"0116"},"figref":["FIG. 19A","FIG. 18"],"b":["340","330","341","1","341","2","341","3"]},"Referring also to , an exemplary intermediate record  containing data associated with the tagging template  is depicted. The intermediate record  has a reference - to the tagging template . The intermediate record also has data fields -, - and - corresponding to the numbers -, - and -, respectively, of the tagging template .","In various embodiments, the tagging templates form a logical tree. During traversal of the tree in , a tagging template is treated as a node or a sub-tree of nodes.","In another embodiment of the flowchart of , for the template-based implementation of the constructors, the template  has a pointer  to a previous XMLNAMESPACES template structure. The pointer  is used to create a chain of ancestor namespace declarations, rather than using the explicit stack. The template-based technique avoids the use of a stack which uses dynamic memory management. The template-based technique also avoids processing empty namespace declaration lists. Empty namespaces are skipped because they are not in the chain. In the template-based technique, a head pointer to the current XMLNAMESPACES template structure provides the top entry to the chain, and the list formed by the previous pointers provides all the in-scope namespace declarations.","In other embodiments, to use the tagging template, the flowchart of  is modified. In the embodiment using the tagging template, in step  of , the technique searches for an ancestor namespace declaration using the pointer  to search through the chain. In step  of , when processing an XMLELEMENT template, if there is an associated XMLNAMESPACES template, its pointer to a previous XMLNAMESPACES template structure is set to a head pointer and the head pointer points to the current XMLNAMESPACES template, to equivalently push the current namespace declaration list, rather than using the stack. In step  of , when other templates associated with the XMLELEMENT have been serialized, and the XMLELEMENT is being left, the head pointer is set to the previous pointer, to equivalently pop off the current namespace list. Since the template is possibly to be reused, the previous pointer is also reset to zero.","In another embodiment, during the pre-processing of , an implicit-no-default indicator  is set in the XMLNAMESPACES template, or alternately the XMLELEMENT template, to indicate that there is an implicit no default namespace declaration. In some embodiments, in step , of , the implicit-no-default indicator of the current namespace is checked to identify an implicit no default namespace. In step  of , the implicit-no-default indicator of the template is checked for an implicit no default condition. Typically, the implicit-no-default indicator is a flag.","In another embodiment, the hash table  () and linked list(s)  () are used to efficiently maintain and search in-scope ancestor namespaces. In an embodiment for constructors without tagging templates, or in an embodiment that constructs tree instances conforming to the XQuery or Document Object Model (DOM) data model, no templates exist, and nodes corresponding to XML element, XML namespace, XML attribute and Text are used. For example, the DOM is described in W3C, \u201cDocument Object Model (DOM) Level 1 Specification\u201d, version 1.0, W3C Recommendation 1, October, 1998, REC-DOM-Level-1-19981001. In other embodiments, the template-based technique described above is used with the hashing technique.",{"@attributes":{"id":"p-0122","num":"0123"},"figref":"FIG. 20","b":["350","352","354","356","358","360","362","356","358","360","358","360"]},"In various embodiments using the hash table, the flowchart of  is modified. In step  of , the current prefix is hashed to provide a hash index into the hash table. A linked-list associated with the hash index, if any, is searched. When searching for a prefix, the closest to the head, that is, the most recent, in-scope prefix is retrieved. In step  of , insertion of a new (prefix, URI) pair into a linked list is always at the link head. In step  of , when deleting a namespace declaration, an entry is removed from the list head.","One of the advantages of the hashing technique is efficient lookup, especially when there are a large number of namespaces. Otherwise, a stack may be similarly efficient.","The template-based technique described above does not apply to SQL\/XML queries with constructors in recursion. Various embodiments of a technique will be described below to process XML functions with namespace declarations in recursive queries using a template-based approach, and these techniques also process non-recursive queries.",{"@attributes":{"id":"p-0126","num":"0127"},"figref":["FIG. 21","FIG. 1","FIG. 15B"],"b":["350","350","1","2","352","354","88","282"]},{"@attributes":{"id":"p-0127","num":"0128"},"figref":"FIG. 22","b":["360","362","364","360","360"],"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"myxmlnsentry.prev=prevptr; \/* prevptr is the address of previous xmlnsentry, i.e. *\/\n    \n    "}},{"@attributes":{"id":"p-0128","num":"0131"},"figref":["FIG. 23","FIG. 21","FIG. 15B"],"b":["370","372","1","372","2","350","2","1","2","1","370","370","284","370","370"]},"In the local structures  of the linked-list stack , a structure pointer field  has the pointer to the previous local structure, and a namespace pointer field  has the pointer to XMLNAMESPACES in the tagging template. Local structure - is close to the bottom of the stack, and local structure - is at the top of the stack. The arrows  represent the order in which the structures were created and linked. This structure allows namespace prefix search to be performed equivalently.","In various embodiments using the calling stack,  are modified. In step  of , the calling stack is searched for an ancestor prefix that matches the current prefix using with the pointer to the local structure that was received when the serialization module was invoked. When no ancestor prefix match is found, the pointer to the previous local structure is retrieved from the local structure, and the namespace associated with the previous local structure is checked. In this matter, the chain of previous local structures can continue to be accessed until a match is found or the entire calling stack is searched. In step  of , a current local structure is initialized. Structure pointer field  of the current local structure is set equal to the pointer that was received when the serialization module was invoked. Namespace pointer field  is set to point to XMLNAMESPACES in the current tagging template. In step , when the serialization module is invoked, a pointer to the current local structure is also passed as an argument. Because the calling stack is automatically popped when returning from an invocation of the serialization module, step  of  is omitted.","In another embodiment in which the serialization module is implemented as an iterative procedure, a stack is used to keep track of nested tagging templates, and that stack can also contain the \u201clocal\u201d structure variable for the namespaces.","The foregoing description of the preferred embodiments of the inventions has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 14","FIG. 2"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 15A and 15B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 16","FIG. 14"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 19A","FIGS. 15A and 15B"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 19B","FIG. 19A"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 20","FIGS. 15A and 15B"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 23","FIGS. 15A and 15B","FIG. 22"]},"To facilitate understanding, identical reference numerals have been used, where possible, to designate identical elements that are common to some of the figures."]},"DETDESC":[{},{}]}
