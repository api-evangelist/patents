---
title: Systems and methods for planning a solution to a dynamically changing problem
abstract: A plan representing a final solution to a problem is obtained efficiently, if the problem changes while being solved, by identifying the solution elements not affected by the change, and by reusing those solution elements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08892483&OS=08892483&RS=08892483
owner: Reservoir Labs, Inc.
number: 08892483
owner_city: New York
owner_country: US
publication_date: 20110531
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","GOVERNMENT INTERESTS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is related to and claims the benefit of priority to U.S. Provisional Application Ser. No. 61\/350,443, titled \u201cMETHOD OF SAT-BASED ITERATIVE REPAIR,\u201d filed Jun. 1, 2010, the entirety of which is hereby incorporated by reference.","Portions of this invention were made with U.S. Government support under contract number W31P4Q-05-C-R171 awarded by Defense Advanced Research Projects Agency and contract number W9113M-10-C-0089 awarded by the Missile Defense Agency. The U.S. Government has certain rights in the invention","The invention relates generally to the field of planning solutions to problems involving dynamically changing requirements (i.e., constraints), and in particular to solving such problems using satisfiability algorithms.","This section is intended to provide a background or context to the disclosed embodiments. The description herein may include concepts that could be pursued, but are not necessarily ones that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, what is described in this section is not prior art to the description and claims in this application and is not admitted to be prior art by inclusion in this section.","Boolean Satisfiability (SAT) solvers are useful in a variety of problems. SAT problems arise in a number of arenas, the field of planning being an example of an important arena. As the demand for more efficient use of heterogeneous and interdependent resources has increased, so has the complexity of the constraint problems that must be solved to assign and employ those resources. With the increase in the complexity of the constraint problems that must be solved there have been significant increases in the challenges within the problem of finding feasible plans that make a highly efficient use of the available resources.","In the planning process a number of computerized techniques have been employed. For example, a common technique is to reduce the planning problem to the combination of a set of constraints and a fitness metric. The constraints capture plans that are consistent with the rules of the world in which the plan is to takes place. The fitness metric provides a means of ordering feasible plans based on desirability. In general, SAT solvers have long provided a means to find solutions to the constraint component. SAT solvers can also be used to find plans that satisfy constraints while meeting a certain fixed threshold of fitness.","However, a SAT solver typically lacks the ability to find an optimal solution, i.e., one that maximizes or minimizes a specified fitness metric while satisfying the constraints system, in a single step. Generally, a SAT solver is configured to find a solution at one fitness level, and is then repeatedly executed anew by requiring a higher fitness threshold in each iteration until a fitness level is reached for which the constraint system is satisfiable at that level, but unsatisfiable at any higher level. The solution that satisfies the constraints at the highest fitness level is determined to be the optimal solution.","SAT solvers typically require the constraint formulae to be expressed in the conjunctive normal form (CNF), which is a conjunction of clauses, where a clause is a disjunction of literals. A literal is either a variable name or its negation. A satisfying assignment of variables returned by the SAT solver corresponds to a plan of fitness greater than or equal to k. If the problem is unsatisfiable at fitness k, the SAT solver returns a proof that there are no plans of fitness greater than or equal to k.","Iterative Repair (IR) is a general mechanism that extends the normal capability of a SAT-solver so that it may address several additional application problem domains. For example, the IR capability is beneficial for applying a SAT solver in a domain where the environment may change. Changes in the environment are reflected as changes in the constraint system embodied in a logic formula being solved. The changes are typically provided by a driver application.","In many defense and commercial applications, the solution to a planning problem automatically rendered by a SAT solver is subject to manual review before a commitment to apply or execute the solution is made. The IR capability provides a mechanism for replanning, in part or in whole, if a change introduced by a manual review. However, SAT is an NP-complete problem (i.e., a class of problem for which only the solutions requiring exponential time are currently known). Solved iteratively for increasing fitness values, k, the IR can produce provably optimal solutions for NP-hard k-optimization problems (i.e., problems that are as hard as NP-complete problems). In this method, a SAT instance is modified for each k and is resolved producing a better solution until k reaches a level at which the problem is unsatisfiable, thus providing a proof of optimality. As described above, changing a fitness level can be analogized to modifying the problem in terms of its constraints. Managing the fitness levels to be tested and translating those levels into a modified problem is generally performed by a driver application. In these examples, the driver application interacts with the IR-enabled SAT solver.","The Davis-Putnam-Logemann-Loveland (DPLL) algorithm is a complete backtracking-based algorithm for deciding the satisfiability of propositional logic formulae in conjunctive normal form, i.e., for solving the CNF-SAT problem. The basic backtracking algorithm runs by choosing a branching literal, assigning a truth value to it, simplifying the formula, and then recursively checking if the simplified formula is satisfiable. If this is the case, the original formula is satisfiable; otherwise, the same recursive check is done assuming the opposite truth value. This is known as the splitting rule, as it splits the problem into two simpler sub-problems. The simplification step normally removes all clauses from the formula that become true under the assignment being tested, and all literals that become false from the remaining clauses.","Various improvements of the DPLL are known in the field. One such improvement is defining variants of the basic backtracking algorithm. Techniques in this area include non-chronological backtracking and clause learning. These refinements describe a method of backtracking after reaching a conflict which \u201clearns\u201d the root causes of the conflict (i.e., conflicting assignments to variables) in order to avoid reaching the same conflict again. Intuitively, backtracking can be viewed as jumping back to the root problem in a sequence of decisions and making the opposite decision.","In finding an optimal plan, updating a fitness threshold in each successive iteration, as described above, is equivalent to changing an original clause. An original clause may also be changed in response to a change in constraints resulting from a change in the environment of the problem. The SAT solver attempts to find a new plan by resolving the changed and unchanged original clauses. To this end, the present back-tracking algorithms assume that the root conflict clauses (i.e., the learned clauses that can avoid repeating a conflict) are logical implications of the original clauses of the formula being solved. Therefore, when one or more original clauses are changed, in a subsequent iteration all conflict causes are relearned, requiring significant time. As such, in complex resource assignment and employment problems, existing planning approaches may need to search a large space of several potentially feasible plans. Accordingly, planning at each level of fitness by resolving the modified and unmodified clauses can take a significant time, rendering the back-tracking method impractical or unusable in situations requiring a rapid solution.","In various embodiments of the present invention, a plan representing a final solution to a modified problem is determined efficiently by reusing elements (i.e., portions) of previously obtained partial solutions to the problem prior to its modification. This is achieved, in part, by analyzing the modification, and identifying elements of solutions that are not invalidated by the modification of the problem.","Often, planning at closely related fitness levels can result in the rediscovery of large numbers of learned clauses that are unaffected by the change in fitness. This rediscovery represents redundant work that increases the time to find an optimal solution. By identifying and retaining the unaffected learned clauses, the subsequent iteration of the problem solving process can adapt efficiently to the changed fitness thresholds. The root causes of any conflict introduced by the modified clauses representing the updated fitness and\/or constraint change are identified, and the learned information based only on the modified, obsolete clauses is removed. However, the learned information based on the unmodified original clauses is retained as solution elements, and even the information based on the removed clauses is reused as potentially valid solution elements, which can improve performance of the solution-finding process.","In particular, in various embodiments the present invention enables dynamically adding and removing both variables and clauses during and\/or after the process of solving a SAT problem. The implication graph that shows which learned clauses are implied from which original and previously learned clauses is retained. The resulting relation is a directed acyclic graph (DAG) rooted in the original clauses. The output of the solver includes not only the final solution but also the learned clauses, the clause implication graph, variable scores, and the decision stack (with antecedent clause references, as described below). This information is also available in memory during the solution process and is updated continuously. The final state of the solving process can be restored from the additional retained information, and a modification to the problem can be accepted. Then, from the restored state based on the retained information the problem is resolved to find a final solution efficiently.","Accordingly, in one aspect, a computer-implemented method is provided for solving a planning problem. The method includes receiving in memory a formula that includes a number of original clauses, and represents the planning problem. The method also includes configuring a processor to solve the formula, so as to generate a final solution to the planning problem. The final solution may include several solution elements. Moreover, the method includes receiving a modification to the formula prior to generating the final solution and analyzing the modified formula, so as to identify the solution elements that have been invalidated by the modification. Finally, the processor is reconfigured to resolve the modified formula, such that the solution elements that have not been invalidated are reused in generating the final solution. Such reuse can increase the performance of the process of finding a solution to the problem.","The generation of the final solution may include learning a first clause based on an original clause belonging to the various original clauses included in the formula, and associating a set of antecedent clauses with the learned first clause. The set of antecedent clauses may include the original clause. The generation of the final solution may also include recording for the learned first clause the associated set of antecedent clauses, such that they may be reused while resolving the problem.","In some provided embodiments, the learning process includes reverse Boolean constraint propagation, and the recording includes tagging the learned first clause and each clause belonging to the associated set of antecedent clauses, and saving the tagged clauses. Accordingly, the learned first clause can be traced back to the corresponding original clause.","The method may include learning a second clause based on the learned first clause and associating a set of antecedent clauses with the learned second clause. The set of antecedent clauses may include the learned first clause and the original clause. The method may further include recording for the learned second clause the associated set of antecedent clauses.","In some provided embodiments the learned first clause and all antecedent clauses belonging to the associated set of antecedent clauses include a number of literals. In these embodiments, the method further includes assigning a value to one of the literals, and associating the assignment with the learned first clause. The method may also include outputting the learned first clause and the associated set of antecedent clauses.","In some provided embodiments, the formula includes a first literal belonging to one of the several original clauses, and the generation of the final solution includes assigning a value to the first literal, implying an assignment of a value to a second literal via Boolean constraint propagation, and recording for the implied assignment, a set of antecedent clauses associated with a clause to which the second literal belongs. The implied assignment, the clause to which the second literal belongs, and the set of antecedent clauses associated with that clause may be output for subsequent reuse.","In some provided embodiments, reconfiguring the processor includes identifying one or more learned clauses associated with a first original clause belonging to the several original clauses. The reconfiguration also includes removing each of the one or more learned clauses associated with the first original clause, removing the first original clause, and retaining as solution elements, the learned clauses associated with a second original clause belonging to the several original clauses. Reconfiguring the processor may also include identifying assignments of values to the literals associated with each of the identified learned clauses, and storing the identified assignments as candidate solution elements. Furthermore, the reconfiguration may include removing the assignments and retaining as solution elements, the assignments of values to the literals associated with the learned clauses that may be associated with the second original clause.","The formula may include variables, and the modification may include removing a variable belonging to the plurality of variables. Accordingly, the analyzing includes identifying an original clause that include a literal corresponding to the removed variable, and removing the learned clauses associated with the identified original clause. The modification may also include adding a new variable and\/or adding a new original clause to the several original clauses.","If a new clause is added, the analyzing process may include identifying by testing whether a current variable assignment conflicts with the new original clause, and, if the assignment is conflicting, identifying a latest non-conflicting decision level resulting, in part, the current variable assignment. The analyzing process may also include removing assignment of value to each variable occurring at a subsequent decision level. The analyzing process may further include saving the removed assignments, and reconfiguring the processor may include testing the saved assignments as solution elements.","In another aspect, an apparatus that includes a processor and a memory is provided for solving a planning problem. The memory includes processor-executable instructions that, when executed by the processor, configure the apparatus to receive in memory a formula that includes a number of original clauses, and represents the planning problem. The instructions also include configuring a processor to solve the formula, so as to generate a final solution to the planning problem. The final solution may include several solution elements. Moreover, the instructions configure the apparatus for receiving a modification to the formula prior to generating the final solution and analyzing the modified formula, so as to identify the solution elements that have been invalidated by the modification. Finally, the instructions reconfigure the processor to resolve the modified formula, such that the solution elements that have not been invalidated are reused in generating the final solution. Such reuse can increase the performance of the process of finding a solution to the problem.","The generation of the final solution may include learning a first clause based on an original clause belonging to the various original clauses included in the formula, and associating a set of antecedent clauses with the learned first clause. The set of antecedent clauses may include the original clause. The generation of the final solution may also include recording for the learned first clause the associated set of antecedent clauses, such that they may be reused while resolving the problem.","In some provided embodiments, the learning process includes reverse Boolean constraint propagation, and the recording includes tagging the learned first clause and each clause belonging to the associated set of antecedent clauses, and saving the tagged clauses. Accordingly, the learned first clause can be traced back to the corresponding original clause.","The instructions may configure the apparatus to learn a second clause based on the learned first clause and associating a set of antecedent clauses with the learned second clause. The set of antecedent clauses may include the learned first clause and the original clause. The apparatus may further be configured by the instructions to record, for the learned second clause, the associated set of antecedent clauses.","In some provided embodiments the learned first clause and all antecedent clauses belonging to the associated set of antecedent clauses include a number of literals. In these embodiments, the instructions further configure the apparatus to assign a value to one of the literals, and associating the assignment with the learned first clause. The apparatus may also be configured by the instructions to output the learned first clause and the associated set of antecedent clauses.","In some provided embodiments, the formula includes a first literal belonging to one of the several original clauses, and the generation of the final solution includes assigning a value to the first literal, implying an assignment of a value to a second literal via Boolean constraint propagation, and recording for the implied assignment, a set of antecedent clauses associated with a clause to which the second literal belongs. The implied assignment, the clause to which the second literal belongs, and the set of antecedent clauses associated with that clause may be output for subsequent reuse.","In some provided embodiments, reconfiguring the processor includes identifying one or more learned clauses associated with a first original clause belonging to the several original clauses. The reconfiguration also includes removing each of the one or more learned clauses associated with the first original clause, removing the first original clause, and retaining as solution elements, the learned clauses associated with a second original clause belonging to the several original clauses. Reconfiguring the processor may also include identifying assignments of values to the literals associated with each of the identified learned clauses, and storing the identified assignments as candidate solution elements. Furthermore, the reconfiguration may include removing the assignments and retaining as solution elements, the assignments of values to the literals associated with the learned clauses that may be associated with the second original clause.","The formula may include variables, and the modification may include removing a variable belonging to the plurality of variables. Accordingly, the analyzing includes identifying an original clause that include a literal corresponding to the removed variable, and removing the learned clauses associated with the identified original clause. The modification may also include adding a new variable and\/or adding a new original clause to the several original clauses.","If a new clause is added, the analyzing process may include identifying by testing whether a current variable assignment conflicts with the new original clause, and, if the assignment is conflicting, identifying a latest non-conflicting decision level resulting, in part, the current variable assignment. The analyzing process may also include removing assignment of value to each variable occurring at a subsequent decision level. The analyzing process may further include saving the removed assignments, and reconfiguring the processor may include testing the saved assignments as solution elements.","In another aspect, an article of manufacture, comprising a non-transitory machine-readable medium storing instructions is provided for solving a planning problem. The stored instructions when executed by the machine, configure the machine to receive in memory a formula that includes a number of original clauses, and represents the planning problem. The instructions also include configuring a processor included in the machine to solve the formula, so as to generate a final solution to the planning problem. The final solution may include several solution elements. Moreover, the instructions configure the machine for receiving a modification to the formula prior to generating the final solution and analyzing the modified formula, so as to identify the solution elements that have been invalidated by the modification. Finally, the instructions reconfigure the processor to resolve the modified formula, such that the solution elements that have not been invalidated are reused in generating the final solution. Such reuse can increase the performance of the process of finding a solution to the problem.","The generation of the final solution may include learning a first clause based on an original clause belonging to the various original clauses included in the formula, and associating a set of antecedent clauses with the learned first clause. The set of antecedent clauses may include the original clause. The generation of the final solution may also include recording for the learned first clause the associated set of antecedent clauses, such that they may be reused while resolving the problem.","In some provided embodiments, the learning process includes reverse Boolean constraint propagation, and the recording includes tagging the learned first clause and each clause belonging to the associated set of antecedent clauses, and saving the tagged clauses. Accordingly, the learned first clause can be traced back to the corresponding original clause.","The instructions may configure the machine to learn a second clause based on the learned first clause and associating a set of antecedent clauses with the learned second clause. The set of antecedent clauses may include the learned first clause and the original clause. The machine may further be configured by the instructions to record, for the learned second clause, the associated set of antecedent clauses.","In some provided embodiments the learned first clause and all antecedent clauses belonging to the associated set of antecedent clauses include a number of literals. In these embodiments, the instructions further configure the machine to assign a value to one of the literals, and associating the assignment with the learned first clause. The machine may also be configured by the instructions to output the learned first clause and the associated set of antecedent clauses.","In some provided embodiments, the formula includes a first literal belonging to one of the several original clauses, and the generation of the final solution includes assigning a value to the first literal, implying an assignment of a value to a second literal via Boolean constraint propagation, and recording for the implied assignment, a set of antecedent clauses associated with a clause to which the second literal belongs. The implied assignment, the clause to which the second literal belongs, and the set of antecedent clauses associated with that clause may be output for subsequent reuse.","In some provided embodiments, reconfiguring the processor includes identifying one or more learned clauses associated with a first original clause belonging to the several original clauses. The reconfiguration also includes removing each of the one or more learned clauses associated with the first original clause, removing the first original clause, and retaining as solution elements, the learned clauses associated with a second original clause belonging to the several original clauses. Reconfiguring the processor may also include identifying assignments of values to the literals associated with each of the identified learned clauses, and storing the identified assignments as candidate solution elements. Furthermore, the reconfiguration may include removing the assignments and retaining as solution elements, the assignments of values to the literals associated with the learned clauses that may be associated with the second original clause.","The formula may include variables, and the modification may include removing a variable belonging to the plurality of variables. Accordingly, the analyzing includes identifying an original clause that include a literal corresponding to the removed variable, and removing the learned clauses associated with the identified original clause. The modification may also include adding a new variable and\/or adding a new original clause to the several original clauses.","If a new clause is added, the analyzing process may include identifying by testing whether a current variable assignment conflicts with the new original clause, and, if the assignment is conflicting, identifying a latest non-conflicting decision level resulting, in part, the current variable assignment. The analyzing process may also include removing assignment of value to each variable occurring at a subsequent decision level. The analyzing process may further include saving the removed assignments, and reconfiguring the processor may include testing the saved assignments as solution elements.","These and other features and advantages of the present invention will be appreciated from review of the following detailed description of the invention, along with the accompanying figures in which like reference numerals refer to like parts throughout.","It will be recognized that some or all of the Figures are schematic representations for purposes of illustration and do not necessarily depict the actual relative sizes or locations of the elements shown. The Figures are provided for the purpose of illustrating one or more embodiments with the explicit understanding that they will not be used to limit the scope or the meaning of the claims.","In the following paragraphs, the present invention will be described in detail by way of example with reference to the attached drawings. While this invention is capable of embodiment in many different forms, there is shown in the drawings and will herein be described in detail specific embodiments, with the understanding that the present disclosure is to be considered as an example of the principles of the invention and not intended to limit the invention to the specific embodiments shown and described. That is, throughout this description, the embodiments and examples shown should be considered as exemplars, rather than as limitations on the present invention. Descriptions of well-known components, methods and\/or processing techniques are omitted so as to not unnecessarily obscure the invention. As used herein, the \u201cpresent invention\u201d refers to any one of the embodiments of the invention described herein, and any equivalents. Furthermore, reference to various feature(s) of the \u201cpresent invention\u201d throughout this document does not mean that all claimed embodiments or methods must include the referenced feature(s).","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem,\u201d and the like are intended to refer to a computer-related entity, either hardware, firmware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, an integrated circuit, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a computing device and the computing device can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers. In addition, these components can execute from various computer-readable media having various data structures stored thereon. The components can communicate by way of local and\/or remote processes such as in accordance with a signal having one or more data packets (e.g., data from one component interacting with another component in a local system, distributed system, and\/or across a network such as the Internet with other systems by way of the signal).","Moreover, various functions described herein can be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions can be stored on or transmitted over as one or more instructions or code on a computer-readable medium. Computer-readable media is non-transitory in nature and includes both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media can be any available media that can be accessed by a computer. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM, or other optical disk storage, magnetic disk storage, or other magnetic storage devices, or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any physical connection is properly termed a computer-readable medium. For example, if the software is transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk, and blu-ray disc (BD), where disks usually reproduce data magnetically and discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.","Additionally, in the subject description, the word \u201cexemplary\u201d is used to mean serving as an example, instance, or illustration. Any embodiment or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other embodiments or designs. Rather, use of the word exemplary is intended to present concepts in a concrete manner.","Iterative Repair (IR) generally refers to a technique in propositional constraint solving in which elements of the formula being tested for satisfaction change, either during the solution process or after a first solution has been returned. In the context of a Boolean Satisfiability (SAT) solver, IR refers to a change, either in the number of variables in the formula being evaluated or the addition or subtraction of clauses to the formula. The goal of a typical IR is to redirect the solution process, subject to the modified problem definition and the need to keep the algorithm in a consistent state, with the least possible loss of intermediate information that is not invalidated. For SAT, this intermediate information usually takes the form of the current assignment stack (i.e., partial assignment), Variable State Independent Decaying Sum (VSIDS), or other heuristic scores for variables, and learned conflict clauses retained in the clause database.","Referring to , in an exemplary process  a problem represented as a formula including set of original clauses is received in memory in step . Each original clause includes literals that correspond to a number of variables. A variable is chosen for assignment called a decision assignment, and a true or false value is assigned to the variable in step .","In step , the logical implications of that assignment are discovered through a process called Boolean Constraint Propagation (BCP). These implications become additional assignments which are then also propagated serially using a work queue. An iteration of the process  is completed when it is determined in step  that all variables are assigned, indicating that the problem as described by the current formula is solved. If it is determined in step  that the formula need not be adjusted in response to a received modification, the solution to the problem (e.g., a plan) is output in step .","In some instances, however, there are no more assignments to propagate in step , yet all variables of the formula are not assigned. Within the current partial assignment, if no conflicting assignment is found in step , the process  is repeated with a new decision assignment in step . Prior to repeating the process , the processor (e.g., a solver) executing the process  may check in step  if the formula has been modified, and if so, may receive the modification in step . In step , the processor is reconfigured, as more fully explained below, and then the process  is repeated starting from step  in which a new variable is selected for assignment.","The various assignments described in the process  occur sequentially and may be referred to as the assignment stack. As used herein, the \u201cassignment stack\u201d may also mean a data structure that enables recording and accessing assignments. The decision assignments in the stack, i.e., the assignments performed in step  partition the stack into decision levels. The assignments that are discovered to be absolute are said to be decision-level zero (DL ). The first decision made at step  marks the beginning of DL . This decision level includes that decision assignment, and in addition all of the BCP-implied assignments discovered from that assignment, such as those made in steps , . As described above, if the BCP process neither solves the problem, nor ends in a conflict, the next decision assignment made by returning to step  as described above, marking the beginning of DL .","If a conflict is discovered in step  (i.e., a variable is assigned both true and false values), a sub-process referred to as reverse BCP is invoked in which, in step , the assignment stack is rolled back to some earlier decision level (one or more levels). In effect one or more assignments previously made in steps , , or  are undone, i.e., the variables to which values were assigned are marked as unassigned. The number of decision levels rolled back, and, accordingly, the number of assignments that may be undone is determined by the number of roll backs necessary to resolve and avoid reoccurrence of the conflict. A conflict caused by DL  assignments, i.e., a situation in which the level zero is reached while resolving conflict but the conflict still exists, results in a return of UNSAT for the problem. This implies that under the specified constraints, no solution exits to the problem.","One or more learned conflict clauses may also be generated in step . These clauses are logical implications of the original and previously learned clauses, and they avoid re-generating the conflict that was discovered during the last execution of step . All clauses, both original and learned, are stored in a list-based data structure referred to as the clause database. The clause database includes a system of pointers referred to as watch lists accessing relevant clauses during the BCP process. Clauses can be added to and removed from this data structure. Finally in step , learning a conflict clause (in step ) may also add an assignment to the new top-of-stack decision level (i.e., the decision level reached after roll back in step  that eliminated the conflict is completed) as a logical implication of the clause learned. This assignment is then propagated by the BCP similarly as in step . Any new conflict discovered can be resolved as described above.","In one embodiment, the BCP operates by repetitive application of a single rule referred to as the unit clause rule. This rule says that if all but exactly one of the variables appearing as literals of a clause have been assigned, and the clause is still not satisfied (i.e., none of the literals is true), then the assignment to the remaining variable is forced such that the remaining literal is true. Thus, the assignment to the remaining variable is an implied assignment. An assignment implied via BCP can be traced to a single clause called an antecedent clause, and to the earlier assignments in the assignment stack. The assignment stack includes a reference to the antecedent clause corresponding to each implied assignment. This reference, in part, enables the reverse-BCP sub-process shown as steps - in the process . The clauses in the clause database and the assignments in the assignment stack may be tagged (e.g., using flags, pointers, etc.) to identify the corresponding antecedent clauses.","As part of the BCP, information based on memory-access patterns is collected and condensed into a score for each variable (e.g., via the VSIDS heuristic). This information is then used to influence which variable should be chosen whenever a new (otherwise unbound) decision needs to be made in the step .","The formula received in step  may be modified in step  in response from some external request, such a user request to add a new constraint or to remove an existing one, or a request to change the required fitness of the solution. In response to a formula modification, the processor is reconfigured in step  to resolve the modified problem (also called repairing the solution). The state of the processor and the solution or partial solution in step  is stable in that all clauses and assignments that may result from the application of BCP and reverse BCP as described above have been explored.","One of the various modifications to the formula that may be received in step  includes removing an original clause from the formula. The removal of a clause generally implies the removal of one or more constrains of the problem, and may affects both the assignment stack and the clause database. Accordingly, the reconfiguration of the processor, as described with reference to  includes selecting the original clause to be removed in step . In step  all learned clauses reachable from the selected original clause in the directed, acyclic clause implication graph are selected and removed from the clause database. In one embodiment, this is achieved by removing all nodes corresponding to the removed clauses and all edges incident upon those nodes from the clause implication graph. The original clause may also be removed.","In step  the assignment stack is inspected, beginning from the lowest decision level, until an assignment is found whose antecedent clauses is one that was removed in step , i.e., the antecedent clause is no longer in the clause database. The decision level is then rolled back to the highest complete decision level such that each assignment in the assignment stack still has its antecedent clause in the clause database. In general, this level is one level below the level at which the search described above stopped. If no such assignment was found, then the assignment stack is determined to be unaffected by the modification. If such an assignment was found at DL , then the assignment stack is rolled back to DL . All of the assignments at DL  are inspected, and all assignments whose antecedent clause is no longer in the clause database are removed. DL  is then compacted to the remaining set of assignments.","In step , the other learned clauses, i.e., the learned clauses derived from other original clauses not removed by the modification are retained in the clause database for use in the subsequent iterations of the steps of the process  depicted in . The assignments corresponding to the retained learned clauses are also retained in the assignment stack. Moreover, as part of rolling back the decisions stack in the step , the sequence of decision assignments and other assignments whose antecedent clause have been removed is saved for reuse in step . These assignments are saved in the order in which they appear in the assignment stack i.e., from lowest decision level to highest.","The process  described above with reference to  resumes from step  using the saved set of assignments as the next sequence of decisions to be made. In this, the influence of the VSIDS scores may be overridden. The modified formula may not imply these assignments as they may have resulted solely from the removed original clause. Nevertheless, reusing the stored assignments to guide assignment decisions, e.g., in step  can yield significant performance improvements. The stored sequence is used for subsequent decisions (e.g., in steps , ,  of the process ) until the sequence is exhausted or any conflict is found through the BCP in step . In that event, the algorithm resumes with making decisions according to the default method such as that based on the VSIDS scores.","The removal of an original clause may not invalidate a partial assignment, but may leave the assignment stack in an inconsistent state. By inconsistent state it is meant that the removed antecedent clause references may block the correct execution of the reverse BCP process, if it were necessary to resolve a conflict. The rollback in step , saving learned clauses and assignments in step , and reusing them in the steps of process  can ensure that each assignment in the assignment stack is properly supported by an antecedent clause in the clause database.","Another modification to the formula that may be received in step  includes removing a variable, which is considered to be equivalent to the removal of all clauses that include the variable to be removed. Therefore, the clause database is inspected, all clauses referencing the variable are enumerated, and the clauses are removed sequentially using steps - shown in  along with the process  shown in . Clauses removed as a consequence of removing a clause earlier in the enumeration are skipped. Any VSIDS score associated with the variable removed is set to zero before the process  of  resumes in the step .","Yet another formula modification that may be performed in step  is adding an original clause, which generally indicates adding a constraint to the problem. The addition of an original clause affects both the assignment stack and clause database. With reference to , the new original clause is added to the clause database in step . In step , the new original clause is tested for certain conditions against the current partial assignment, i.e., against the variable assignments represented by the current decision level in the assignment stack. In one embodiment, if it is determined in step  that the clause has at least two unassigned literals, the modification (i.e., addition) of the new clause in the step  of  terminates as shown in step . Alternatively, if it is determined in step  that the clause is satisfied and has only a single unassigned literal, then also the modification operation in the step  of  terminates.","If the test are not met, in step  the assignments at the current decision level are stored, and the assignment stack is rolled back one complete decision level in step . The steps - are repeated until the assignment stack is rolled back to the highest complete decision level that meets the test conditions evaluated and verified in the steps ,  (i.e., the clause has at least two unassigned literals, or the clause is satisfied and has only a single unassigned literal).","During these iterations, if the decision level to which the assignment stack is rolled back in the step  is DL , additional tests take place. For example, if the number of unassigned literals is zero and the clause is unsatisfied, the algorithm terminates with the result UNSAT, indicating that the addition of the new clause in the step  of  rendered the problem unsolvable. If the number of unassigned literals is one and the clause is unsatisfied, the assignment implied by the unit clause rule is added to DL . Otherwise, if the decision level to which the assignment stack is rolled back in the step  is other than DL , the process  of  continues from the step . The assignments saved in each iteration of the step  are saved in the order in which they appear in the assignment stack, i.e., from the lowest decision level to the highest.","When the process  of  resumes at the step  the set of saved assignments is used as the next sequence of decisions to be made for the subsequent decisions (e.g., decisions in steps , , ), overriding, e.g., the influence of the VSIDS scores, until the sequence is exhausted or any conflict is found through the BCP in step . In that event, the algorithm resumes with making decisions according to the default method such as that based on the VSIDS scores.","The modification in the step  can also include adding a variable to the formula, which requires extending an array holding the current assignment by a single memory address. Typically, this modification is performed as a pre-step to the process  of adding a clause that references the added variable, as described above with reference to . The assignment stack and the clause database are otherwise unaffected, and the initial VSIDS score for an added variable is set to zero.","An exemplary system  that can solve planning problems by iterative repair includes a processor , a level-1 memory  (e.g., memory included in the processor , system RAM, etc.), and a level-2 memory  (e.g., hard disk, flash memory, etc). The formula representing the problem to be solved may be received in the level-1 memory . A set of instructions provided in the level-1 memory configure the processor  to solve the formula. The partial and final solutions, and elements of those solutions are generated by the processor  and are stored in the level-1 memory . The solution elements may include variable assignments, learned (e.g., conflict) clauses, and tagged clauses tracing back to the original clauses in the formula.","A modification to the formula, typically provided by an external driver, may also be received in the level-1 memory . Upon receiving a modification, the processor  analyzes the modified formula according to the set of instructions in the level-1 memory , and modifies (e.g., tags as invalid, removes, etc.) certain solution elements. The processor also stores into the level-2 memory  certain elements (e.g., learned clauses, assignments, etc.) that may have been removed from the level-1 memory .","The instructions in the level-1 memory  reconfigure the processor  to use certain solution elements retained in the level-1 memory , e.g., the solution elements that were unaffected by the formula modification. In addition, the instructions reconfigure the processor  to use certain solution elements stored in the level-2 memory as candidate solutions. Using these solution elements, the processor  efficiently finds a solution to the modified formula, in general as described above with reference to . Although the system  includes one processor and two levels of memory, it should be understood that this is illustrative only, and that systems including more then one processors, each operating on a subset of instructions, and more or fewer (i.e., single) memory units are within the scope of the invention. It should also be understood that in other embodiments, the various data generated by the processor  may be stored in configurations other than those described above.","In one provided embodiment, a system of iterative repair , illustrated with reference to , includes a formula receiver\/modifier module  for receiving a formula and its modification. The formula includes several original clauses, based on which a solver  generates various assignments and learned clauses. For example, the solver  may perform BCP and\/or reverse BCP. The assignments are recorded and retrieved by a stack manager  and the clauses, including the original and learned clauses are recorded and retrieved by a graph manager . A controller  configures and reconfigures the solver  to iteratively solve the problem.","If the formula is modified, a formula analyzer  analyzes the partial solution generated by the solver  and identifies the solution elements that may have been affected by the modification. In some embodiments, the formula analyzer  may not be provided separately, and the solver  may be configured by the controller  to perform the required analysis. The solutions determined to be affected by the formula analyzer  are stored by the data storage\/reload module . In subsequent iteration, the module  may reload the stored data, and the controller  may configure the solver  to use the reloaded data. The reloaded data may include assignments and clauses.","It is to be understood that the aspects described herein can be implemented by hardware, software, firmware, middleware, microcode, or any combination thereof. When the systems and\/or methods are implemented in software, firmware, middleware or microcode, program code or code segments, they can be stored in a machine-readable medium, such as a storage component. A code segment can represent a procedure, a function, a subprogram, a program, a routine, a subroutine, a module, a software package, a class, or any combination of instructions, data structures, or program statements. A code segment can be coupled to another code segment or a hardware circuit by passing and\/or receiving information, data, arguments, parameters, or memory contents. Information, arguments, parameters, data, etc. can be passed, forwarded, or transmitted using any suitable means including memory sharing, message passing, token passing, network transmission, etc.","For a software implementation, the techniques described herein can be implemented with modules (e.g., procedures, functions, and so on) that perform the functions described herein. The software codes can be stored in memory units and executed by processors. The memory unit can be implemented within the processor or external to the processor, in which case it can be communicatively coupled to the processor via various means as is known in the art.","Each functional component described above (e.g., the profiler module, the miner module, the databases, the inventory module, the analyzer module, and the installer) may be implemented as stand-alone software components or as a single functional module. In some embodiments the components may set aside portions of a computer's random access memory to provide control logic that affects the interception, scanning and presentation steps described above. In such an embodiment, the program or programs may be written in any one of a number of high-level languages, such as FORTRAN, PASCAL, C, C++, C#, Java, Tcl, PERL, or BASIC. Further, the program can be written in a script, macro, or functionality embedded in commercially available software, such as EXCEL or VISUAL BASIC.","Additionally, the software may be implemented in an assembly language directed to a microprocessor resident on a computer. For example, the software can be implemented in Intel 80\u00d786 assembly language if it is configured to run on an IBM PC or PC clone. The software may be embedded on an article of manufacture including, but not limited to, computer-readable program means such as a floppy disk, a hard disk, an optical disk, a magnetic tape, a PROM, an EPROM, or CD-ROM.","Thus, it is seen that a method and an apparatus for Planning a solution to a dynamically changing problem (i.e., a problem that may change while it is being solved) are provided. One skilled in the art will appreciate that the present invention can be practiced by other than the above-described embodiments, which are presented in this description for purposes of illustration and not of limitation. The specification and drawings are not intended to limit the exclusionary scope of this patent document. It is noted that various equivalents for the particular embodiments discussed in this description may practice the invention as well. That is, while the present invention has been described in conjunction with specific embodiments, it is evident that many alternatives, modifications, permutations and variations will become apparent to those of ordinary skill in the art in light of the foregoing description. Accordingly, it is intended that the present invention embrace all such alternatives, modifications and variations as fall within the scope of the appended claims. The fact that a product, process or method exhibits differences from one or more of the above-described exemplary embodiments does not mean that the product or process is outside the scope (literal scope and\/or other legally-recognized scope) of the following claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various embodiments taught herein are illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings, in which:",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
