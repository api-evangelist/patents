---
title: Method and system for apportioning changes in metric variables in an symmetric multiprocessor (SMP) environment
abstract: A method and system for monitoring performance of a program using global metric variables to provide the support in an symmetric multiprocessor (SMP) system. A Java virtual machine (Jvm) either calls the profiler whenever bytes are allocated or provides an interface to allow the profiler to determine the value of the change in the metric for the current thread. The profiler then applies the changes to a metric for the current thread. Alternatively, per processor data areas are maintained for storing per processor metric values. Whenever a thread switch occurs or there is a request for the metric on a specified thread, an operating system kernel updates the thread level metric values with changes in the values per processor metrics.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06904594&OS=06904594&RS=06904594
owner: International Business Machines Corporation
number: 06904594
owner_city: Armonk
owner_country: US
publication_date: 20000706
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT"],"p":["This application is a related to the following copending and commonly assigned applications entitled \u201cSYSTEM AND METHOD FOR PROVIDING TRACE INFORMATION REDUCTION\u201d, U.S. application Ser. No. 08\/989,725, now issued as U.S. Pat. No. 6,055,492, filed on Dec. 12, 1997, currently pending, \u201cA METHOD AND APPARATUS FOR STRUCTURED PROFILING OF DATA PROCESSING SYSTEMS AND APPLICATIONS\u201d, U.S. application Ser. No. 09\/052,329, currently pending, filed on Mar. 31, 1998, \u201cA METHOD AND APPARATUS FOR STRUCTURED MEMORY ANALYSIS OF DATA PROCESSING SYSTEMS AND APPLICATIONS\u201d, U.S. application Ser. No. 09\/052,331, currently pending, filed on Mar. 31, 1998, and \u201cMETHOD AND APPARATUS FOR PROFILING PROCESSES IN A DATA PROCESSING SYSTEM\u201d, U.S. application Ser. No. 09\/177,031, currently pending, filed on Oct. 22, 1998, \u201cPROCESS AND SYSTEM FOR MERGING TRACE DATA FOR PRIMARILY INTERPRETED METHODS\u201d, U.S. application Ser. No. 09\/343,439, currently pending, filed on Jun. 30, 1999; \u201cMETHOD AND SYSTEM FOR MERGING EVENT-BASED DATA AND SAMPLED DATA INTO POSTPROCESSED TRACE OUTPUT\u201d, U.S. application Ser. No. 09\/343,438 filed Jun. 30, 1999, now U.S. Pat. No. 6,513,155; \u201cMETHOD AND SYSTEM FOR SHADOW HEAP MEMORY LEAK DETECTION AND OTHER HEAP ANALYSIS IN AN OBJECT-ORIENTED ENVIRONMENT DURING REAL-TIME TRACE PROCESSING\u201dU.S. application Ser. No. 09\/589,798, filed Jun. 8, 2000, \u201cMETHOD AND SYSTEM FOR TRACING PROFILING INFORMATION IN AN APPLICATION USING PER THREAD METRIC VARIABLES WITH REUSED KERNEL THREADS, U.S. application Ser. No. 09\/612,349, now abandoned; \u201cMETHOD AND SYSTEM FOR TRACING PROFILING INFORMATION USING PER THREAD METRIC VARIABLES WITH REUSED KERNEL THREADS\u201d, U.S. application Ser. No. 09\/612,350, filed Jul. 6, 2000; and \u201cMETHOD AND SYSTEM FOR SMP PROFILING USING SYNCHRONIZED OR NONSYNCHRONIZED METRIC VARIABLES WITH SUPPORT ACROSS MULTIPLE SYSTEMS\u201d, U.S. application Ser. No. 09\/611,666, filed Jul. 6, 2000.","1. Technical Field","The present invention relates to an improved data processing system and, in particular, to a method and apparatus for optimizing performance in a data processing system. Still more particularly, the present invention provides a method and apparatus for a software program development tool for enhancing performance of a software program through software profiling.","2. Description of Related Art","In analyzing and enhancing performance of a data processing system and the applications executing within the data processing system, it is helpful to know which software modules within a data processing system are using system resources. Effective management and enhancement of data processing systems requires knowing how and when various system resources are being used. Performance tools are used to monitor and examine a data processing system to determine resource consumption as various software applications are executing within the data processing system. For example, a performance tool may identify the most frequently executed modules and instructions in a data processing system, or may identify those modules, which allocate the largest amount of memory or perform the most I\/O requests. Hardware performance tools may be built into the system or added at a later point in time. Software performance tools also are useful in data processing systems, such as personal computer systems, which typically do not contain many, if any, built-in hardware performance tools.","One known software performance tool is a trace tool. A trace tool may use more than one technique to provide trace information that indicates execution flows for an executing program. One technique keeps track of particular sequences of instructions by logging certain events as they occur, so-called event-based profiling technique. For example, a trace tool may log every entry into, and every exit from, a module, subroutine, method, function, or system component. Alternately, a trace tool may log the requester and the amounts of memory allocated for each memory allocation request. Typically, a time-stamped record is produced for each such event. Corresponding pairs of records similar to entry-exit records also are used to trace execution of arbitrary code segments, starting and completing I\/O or data transmission, and for many other events of interest.","In order to improve performance of code generated by various families of computers, it is often necessary to determine where time is being spent by the processor in executing code, such efforts being commonly known in the computer processing arts as locating \u201cshot spots.\u201d Ideally, one would like to isolate such hot spots at the instruction and\/or source line of code level in order to focus attention on areas, which might benefit most from improvements to the code.","Another trace technique involves periodically sampling a program's execution flows to identify certain locations in the program in which the program appears to spend large amounts of time. This technique is based on the idea of periodically interrupting the application or data processing system execution at regular intervals, so-called sample-based profiling. At each interruption, information is recorded for a predetermined length of time or for a predetermined number of events of interest. For example, the program counter of the currently executing thread, which is a process that is part of the larger program being profiled, may be recorded during the intervals. These values may be resolved against a load map and symbol table information for the data processing system at post-processing time, and a profile of where the time is being spent may be obtained from this analysis.","For example, isolating such hot spots to the instruction level permits compiler writers to find significant areas of suboptimal code generation at which they may thus focus their efforts to improve code generation efficiency. Another potential use of instruction level detail is to provide guidance to the designer of future systems. Such designers employ profiling tools to find characteristic code sequences and\/or single instructions that require optimization for the available software for a given type of hardware.","When profiling includes gather profiling information at the processor level, the profiler must rely on the operating system for the profile information. The profiler cannot know if the change in a global variable returned by the operating system is the change from two or more processors concurrently executing code. A non-SMP enabled profiler would capture the values at thread switches and at entries and exits and apply the change to the method on the specified thread.","In the SMP case, if two processors update the same global variable simultaneously, it is impossible to apportion the change in a global variable between two processors. Individual values from each SMP processor are impossible to determine because an SMP-enabled profiler would capture values for processors from the operating system kernel concurrently. If two processors update the same global variable concurrently, it cannot be determined how much of the change is due to a thread on a first processor and how much of the change is due to a second thread on a second processor.","Therefore, it would be advantageous to provide a system in which the contribution from each processor on the change of a variable can ascertained.","A method and system for monitoring performance of a program using global metric variables to provide the support in a symmetric multiprocessor (SMP) system. In one embodiment a Java virtual machine (Jvm) either calls the profiler whenever bytes are allocated or provides an interface to allow the profiler to determine the value of the change in the metric for the current thread. The profiler then applies the changes to a metric for the current thread. In another embodiment, per processor data areas are maintained for storing per processor metric values. Whenever a thread switch occurs or there is a request for the metric on a specified thread, an operating system kernel updates the thread level metric values with changes in the values per processor metrics.","With reference now to the figures, and in particular with reference to , a pictorial representation of a distributed data processing system in which the present invention may be implemented is depicted.","Distributed data processing system  is a network of computers in which the present invention may be implemented. Distributed data processing system  contains a network , which is the medium used to provide communications links between various devices and computers connected together within distributed data processing system . Network  may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone connections.","In the depicted example, a server  is connected to network  along with storage unit . In addition, clients , , and  also are connected to a network . These clients , , and  may be, for example, personal computers or network computers. For purposes of this application, a network computer is any computer, coupled to a network, which receives a program or other application from another computer coupled to the network. In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to server . Distributed data processing system  may include additional servers, clients, and other devices not shown. In the depicted example, distributed data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the TCP\/IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational, and other computer systems, that route data and messages. Of course, distributed data processing system  also may be implemented as a number of different types of networks, such as, for example, an Intranet or a local area network.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 1"},"With reference now to , a block diagram of a data processing system which may be implemented as a server, such as server  in , is depicted in accordance to the present invention. Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors  and  connected to system bus . Alternatively, a single processor system may be employed. Also connected to system bus  is memory controller\/cache , which provides an interface to local memory . I\/O Bus Bridge  is connected to system bus  and provides an interface to I\/O bus . Memory controller\/cache  and I\/O Bus Bridge  may be integrated as depicted.","Peripheral component interconnect (PCI) bus bridge  connected to I\/O bus  provides an interface to PCI local bus . A modem  may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to network computers - in  may be provided through modem  and network adapter  connected to PCI local bus  through add-in boards.","Additional PCI bus bridges  and  provide interfaces for additional PCI buses  and , from which additional modems or network adapters may be supported. In this manner, server  allows connections multiple network computers. A memory mapped graphics adapter  and hard disk  may also be connected to I\/O bus  as depicted, either directly or indirectly.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drive and the like also may be used in addition or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.","The data processing system depicted in  may be, for example, an IBM RISC\/System  system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system.","With reference now to , a block diagram of a data processing system in which the present invention may be implemented is illustrated. Data processing system  is an example of a client computer. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Micro Channel and ISA may be used. Processor  and main memory  are connected to PCI local bus  through PCI Bridge . PCI Bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter , SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter (A\/V)  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM  in the depicted example. Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in FIG. B. The operating system may be a commercially available operating system such as JavaOS for Business\u2122 or OS\/2\u2122, which are available from International Business Machines Corporation\u2122. JavaOS is loaded from a server on a network to a network client and supports Java programs and applets. A couple of characteristics of JavaOS that are favorable for performing traces with stack unwinds, as described below, are that JavaOS does not support paging or virtual memory. An object-oriented programming system such as Java may run in conjunction with the operating system and may provide calls to the operating system from Java programs or applications executing on data processing system . Instructions for the operating system, the object-oriented operating system, and applications or programs are located on storage devices, such as hard disk drive  and may be loaded into main memory  for execution by processor . Hard disk drives are often absent and memory is constrained when data processing system  is used as a network client.","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. For example, other peripheral devices, such as optical disk drives and the like may be used in addition to or in place of the hardware depicted in FIG. B. The depicted example is not meant to imply architectural limitations with respect to the present invention. For example, the processes of the present invention may be applied to a multiprocessor data processing system.","The present invention provides a process and system for profiling software applications. Although the present invention may operate on a variety of computer platforms and operating systems, it may also operate within a Java runtime environment. Hence, the present invention may operate in conjunction with a Java virtual machine (JVM) yet within the boundaries of a Jvm as defined by Java standard specifications. In order to provide a context for the present invention, portions of the operation of a Jvm according to Java specifications are herein described.","With reference now to , a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. Java-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. Jvm  is one software application that may execute in conjunction with the operating system. Jvm  provides a Java run-time environment with the ability to execute Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which Jvm  operates may be similar to data processing system  or computer  described above. However, Jvm  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core.","At the center of a Java run-time environment is the Jvm, which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence.","The Jvm is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every Jvm must implement, with some range of design choices that may depend upon the platform on which the Jvm is designed to execute. For example, all Jvms must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A Jvm may be implemented completely in software or somewhat in hardware. This flexibility allows different Jvms to be designed for mainframe computers and PDAs.","The Jvm is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the Jvm, which is itself a piece of software running on the processor. The Jvm allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the Jvm. In this, manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format. The compiled code is executable on many processors, given the presence of the Java run-time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent-code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the Jvm that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Byte codes may be translated into native code by a just-in-time compiler or JIT.","A Jvm must load class files and execute the bytecodes within them. The Jvm contains a class loader, which loads class files from an application and the class files from the Java application programming interfaces (APIs), which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.","One type of software-based execution engine is a just-in-time compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. Jvms usually interpret bytecodes, but Jvms may also use other techniques, such as just-in-time compiling, to execute bytecodes.","Interpreting code provides an additional benefit. Rather than instrumenting the Java source code, the interpreter may be instrumented. Trace data may be generated via selected events and timers through the instrumented interpreter without modifying the source code. Profile instrumentation is discussed in more detail further below.","When an application is executed on a Jvm that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With reference now to , a block diagram of a Jvm is depicted in accordance with a preferred embodiment of the present invention. Jvm  includes a class loader subsystem , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. Jvm  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java interpreter  or just-in-time compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, a Java native interface. Runtime data areas  contain native method stacks , Java stacks , PC registers , method area , and heap . These different data areas represent the organization of memory needed by Jvm  to execute a program.","Java stacks  are used to store the state of Java method invocations. When a new thread is launched, the Jvm creates a new Java stack for the thread. The Jvm performs only two operations directly on Java stacks: it pushes and pops frames. A thread's Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method, the Jvm pushes a new frame onto the Java stack of the thread. When the method completes, the Jvm pops the frame for that method and discards it. The Jvm does not have any registers for holding intermediate values; any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java instruction set is well defined for a variety of platform architectures.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register (program counter) and Java stack. If the thread is executing a Jvm method, the value of the PC register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the PC register are undefined. Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some Jvm implementations, native method stacks  and Java stacks  are combined.","Method area  contains class data while heap  contains all instantiated objects. The Jvm specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which are shared by all threads running inside the JVM. When the Jvm loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area. Each time a class instance or array is created, the memory for the new object is allocated from heap . Jvm  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory. Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector, which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","The processes within the following figures provide an overall perspective of the many processes employed within the present invention: processes that generate event-based profiling information in the form of specific types of records in a trace file; processes that generate sample-based profiling information in the form of specific types of records in a trace file; processes that read the trace records to generate more useful information to be placed into profile reports; and processes that generate the profile reports for the user of the profiling utility.","With reference now to , a block diagram depicts components used to profile processes in a data processing system. A trace program  is used to profile processes . Trace program  may be used to record data upon the execution of a hook, which is a specialized piece of code at a specific location in a routine or program in which other routines may be connected. Trace hooks are typically inserted for the purpose of debugging, performance analysis, or enhancing functionality. These trace hooks are employed to send trace data to trace program , which stores the trace data in buffer . The trace data in buffer  may be stored in a file for post-processing. With Java operating systems, the present invention employs trace hooks that aid in identifying methods that may be used in processes . In addition, since classes may be loaded and unloaded, these changes may also be identified using trace data. This is especially relevant with \u201cnetwork client\u201d data processing systems, such as those that may operate under JavaOS, since classes and jitted methods may be loaded and unloaded more frequently due to the constrained memory and role as a network client.","With reference now to , a diagram depicts various phases in profiling the processes active in an operating system. Subject to memory constraints, the generated trace output may be as long and as detailed as the analyst requires for the purpose of profiling a particular program.","An initialization phase  is used to capture the state of the client machine at the time tracing is initiated. This trace initialization data includes trace records that identify all existing threads, all loaded classes, and all methods for the loaded classes. Records from trace data captured from hooks are written to indicate thread switches, interrupts, and loading and unloading of classes and jitted methods. Any class, which is loaded, has trace records that indicate the name of the class and its methods. In the depicted example, four byte IDs are used as identifiers for threads, classes, and methods. These IDs are associated with names output in the records. A record is written to indicate when all of the start up information has been written.","Next, during the profiling phase , trace records are written to a trace buffer or file. Trace records may originate from two types of profiling actions-event-based profiling and sample-based profiling. In the present invention, the trace file may have a combination of event-based records, such as those that may originate from a trace hook executed in response to a particular type of event, e.g., a method entry or method exit, and sample-based records, such as those that may originate from a stack walking function executed in response to a timer interrupt, e.g., a stack unwind record, also called a call stack record.","For example, the following process may occur during the profiling phase if the user of the profiling utility has requested sample-based profiling information. Each time a particular type of timer interrupt occurs, a trace record is written, which indicates the system program counter. This system program counter may be used to identify the routine that is interrupted. In the depicted example, a timer interrupt is used to initiate gathering of trace data. Of course, other types of interrupts may be used other than timer interrupts. Interrupts based on a programmed performance monitor event or other types of periodic events may be employed.","In the post-processing phase , the data collected in the buffer is sent to a file for post-processing. In one configuration, the file may be sent to a server, which determines the profile for the processes on the client machine. Of course, depending on available resources, the post-processing also may be performed on the client machine. In post-processing phase , B-trees and\/or hash tables may be employed to maintain names associated with the records in the trace file to be processed. A hash table employs hashing to convert an identifier or a key, meaningful to a user, into a value for the location of the corresponding data in the table. While processing trace records, the B-trees and\/or hash tables are updated to reflect the current state of the client machine, including newly loaded jitted code or unloaded code. Also, in the post-processing phase , each trace record is processed in a serial manner. As soon as the indicator is encountered and all of the startup information has been processed, event-based trace records from trace hooks and sample-based trace records from timer interrupts are then processed. Timer interrupt information from the timer interrupt records are resolved with existing hash tables. In addition, this information identifies the thread and function being executed. The data is stored in hash tables with a count identifying the number of timer tick occurrences associated with each way of looking at the data. After all of the trace records are processed, the information is formatted for output in the form of a report.","Alternatively, trace information may be processed on the fly so that trace data structures are maintained during the profiling phase. In other words, while a profiling function, such as a timer interrupt, is executing, rather than (or in addition to) writing trace records to a buffer or file, the trace record information is processed to construct and maintain any appropriate data structures.","For example, during the processing of a timer interrupt during the profiling phase, a determination could be made as to whether the code being interrupted is being interpreted by the Java interpreter. If the code being interrupted is interpreted, the method ID of the method being interpreted may be placed in the trace record. In addition, the name of the method may be obtained and placed in the appropriate B-tree. Once the profiling phase has completed, the data structures may contain all the information necessary for generating a profile report without the need for post-processing of the trace file.","With reference now to , a flowchart depicts a process used by a trace program for generating trace records from processes executing on a data processing system.  provides further detail concerning the generation of trace records that were not described with respect to FIG. .","Trace records may be produced by the execution of small pieces of code called \u201chooks\u201d. Hooks may be inserted in various ways into the code executed by processes, including statically (source code) and dynamically (through modification of a loaded executable). This process is employed after trace hooks have already been inserted into the process or processes of interest. The process begins by allocating a buffer (step ), such as buffer  in FIG. . Next, in the depicted example, trace hooks are turned on (step ), and tracing of the processes on the system begins (step ). Trace data is received from the processes of interest (step ). This type of tracing may be performed during phases  and\/or . This trace data is stored as trace records in the buffer (step ). A determination is made as to whether tracing has finished (step ). Tracing finishes when the trace buffer has been filled or the user stops tracing via a command and requests that the buffer contents be sent to file. If tracing has not finished, the process returns to step  as described above.","Otherwise, when tracing is finished, the buffer contents are sent to a file for post-processing (step ). A report is then generated in post-processing (step ) with the process terminating thereafter.","Although the depicted example uses post-processing to analyze the trace records, the processes: of the present invention may be used to process trace information in real-time depending on the implementation.","With reference now to , a flowchart depicts a process that may be used during an interrupt handler trace hook.","The process begins by obtaining a program counter (step ). Typically, the program counter is available in one of the saved program stack areas. Thereafter, a determination is made as to whether the code being interrupted is interpreted code (step ). This determination may be made by determining whether the program counter is within an address range for the interpreter used to interpret bytecodes. If the code being interrupted is interpreted, a method block address is obtained for the code being interpreted. A trace record is then written (step ). The trace record is written by sending the trace information to a trace program, such as trace program , which generates trace records for post-processing in the depicted example. This trace record is referred to as an interrupt record, or an interrupt hook.","This type of trace may be performed during phase . Alternatively, a similar process, i.e. determining whether code that was interrupted is interpreted code, may occur during post-processing of a trace file.","In addition to event-based profiling, a set of processes may be employed to obtain sample-based profiling information. As applications execute, the applications may be periodically interrupted in order to obtain information about the current runtime environment. This information may be written to a buffer or file for post-processing, or the information may be processed on the fly into data structures representing an ongoing history of the runtime environment.  describe sample-based profiling in more detail.","A sample-based profiler obtains information from the stack of an interrupted thread. The thread is interrupted by a timer interrupt presently available in many operating systems. The user of the trace facility selects either the program counter option or the stack unwind option, which may be accomplished by enabling one major code or another major code, as described further below. This timer interrupt is employed to sample information from a call stack. By walking back up the call stack, a complete call stack can be obtained for analysis. A \u201cstack walk\u201d may also be described as a \u201cstack unwind\u201d, and the process of \u201cwalking the stack\u201d may also be described as unwinding the stack\u201d. Each of these terms illustrates a different metaphor for the process. The process can be described as \u201cwalking\u201d as the process must obtain and process the stack frames step-by-step. The process may also be described as \u201cunwinding\u201d as the process must obtain and process the stack frames that point to one another, and these pointers and their information must be \u201cunwound\u201d through many pointer dereferences.","The stack unwind follows the sequence of functions\/method calls at the time of the interrupt. A call stack is an ordered list of routines plus offsets within routines (i.e. modules, functions, methods, etc.) that have been entered during execution of a program. For example, if routine A calls routine B, and then routine B calls routine C, while the processor is executing instructions in routine C, the call stack is ABC. When control returns from routine C back to routine B, the call stack is AB. For more compact presentation and ease of interpretation within a generated report, the names of the routines are presented without any information about offsets. Offsets could be used for more detailed analysis of the execution of a program, however, offsets are not considered further herein.","Thus, during timer interrupt processing or at post-processing, the generated sample-based profile information reflects a sampling of call stacks, not just leaves of the possible call stacks, as in some program counter sampling techniques. A leaf is a node at the end of a branch, i.e. a node that has no descendants. A descendant is a child of a parent node, and a leaf is a node that has no children.","With reference now to , a diagram depicts the call stack containing stack frames. A \u201cstack\u201d is a region of reserved memory in which a program or programs store status data, such as procedure and function call addresses, passed parameters, and sometimes local variables. A \u201cstack frame\u201d is a portion of a thread's stack that represents local storage (arguments, return addresses, return values, and local variables) for a single function invocation. Every active thread of execution has a portion of system memory allocated for its stack space. A thread's stack consists of sequences of stack frames. The set of frames on a thread's stack represent the state of execution of that thread at any time. Since stack frames are typically interlinked (e.g., each stack frame points to the previous stack frame), it is often possible to trace back up the sequence of stack frames and develop the \u201ccall stack\u201d. A call stack represents all not-yet-completed function calls\u2014in other words, it reflects the function invocation sequence at any point in time. Call stack  includes information identifying the routine that is currently running, the routine that invoked it, and so on all the way up to the main program. Call stack  includes a number of stack frames , , , and . In the depicted example, stack frame  is at the top of call stack BOO, while stack frame  is located at the bottom of call stack . The top of the call stack is also referred to as the \u201croot\u201d. The timer interrupt (found in most operating systems) is modified to obtain the program counter value (pcv) of the interrupted thread, together with the pointer to the currently active stack frame for that thread. In the Intel architecture, this is typically represented by the contents of registers: EIP (program counter) and EBP (pointer to stack frame). By accessing the currently active stack frame, it is possible to take advantage of the (typical) stack frame linkage convention in order to chain all of the frames together. Part of the standard linkage convention also dictates that the function return address be placed just above the invoked-function's stack frame; this can be used to ascertain the address for the invoked function. While this discussion employs an Intel-based architecture, this example is not a restriction. Most architectures employ linkage conventions that can be similarly navigated by a modified profiling interrupt handler.","When a timer interrupt occurs, the first parameter acquired is the program counter value. The next value is the pointer to the top of the current stack frame for the interrupted thread. In the depicted example, this value would point to EBP in stack frame . In turn, EBP  points to EBP in stack frame , which in turn points to EBP in stack frame . In turn, this EBP points to EBP in stack frame . Within stack frames - are EIPs -, which identify the calling routine's return address. The routines may be identified from these addresses. Thus, routines are defined by collecting all of the return addresses by walking up or backwards through the stack.","With reference now to the , an illustration of a call stack is depicted. A call stack, such as call stack  is obtained by walking the call stack. A call stack is obtained each time a periodic event, such as, for example, a timer interrupt occurs. These call stacks may be stored as call stack unwind trace records within the trace file for post-processing or may be processed on-the-fly while the program continues to execute. In the depicted example, call stack  contains a pid , which is the process identifier, and a tid , which is the thread identifier. Call stack  also contains addresses addr, addr . . . addrN . In this example, addr represents the value of the program counter at the time of the interrupt. This address occurs somewhere within the scope of the interrupted function. addr represents an address within the process that called the function that was interrupted. For Intel-processor-based data processing systems, it represents the return address for that call; decrementing that value by 4 results in the address of the actual call, also known as the call-site. This corresponds with EIP in ; addrN  is the top of the call stack (EIP ). The call stack that would be returned if the timer interrupt interrupted the thread whose call stack state is depicted in  would consist of: a pid, which is the process id of the interrupted thread; a tid, which is the thread id for the interrupted thread; a pcv, which is a program counter value (not shown on ) for the interrupted thread; EIP ; EIP ; EIP ; and EIP . In terms of , pcv=addr, EIP =addr, EIP =addr, EIP =addr, EIP =addr.","With reference now to , a diagram of a program execution sequence along with the state of the call stack at each function entry\/exit point is provided. The illustration shows entries and exits occurring at regular time intervals, but this is only a simplification for the illustration. If each function (A, B, C, and X in the figure) were instrumented with entry\/exit event hooks, then complete accounting of the time spent within and below each function would be readily obtained. Note in  that at time , the executing thread is in routine C. The call stack at time  is C. At time , routine C calls routine A, and the call stack becomes CA and so on. It should be noted that the call stack in  is a reconstructed call stack that is generated by processing the event-based trace records in a trace file to follow such events as method entries and method exits.","The accounting technique and data structure is described in more detail further below. Unfortunately, this type of instrumentation can be expensive, can introduce bias, and in some cases, can be hard to apply. Sample-based profiling, by sampling the program's call stack, helps to alleviate the performance bias (and other complications) that entry\/exit hooks produce. Consider , in which the same program is executed but is being sampled on a regular basis (in the example, the interrupt occurs at a frequency equivalent to two timestamp values). Each sample includes a snapshot of the interrupted thread's call stack. Not all call stack combinations are seen with this technique (note that routine X does not show up at all in the set of call stack samples in FIG. B). This is an acceptable limitation of sampling. The idea is that with an appropriate sampling rate (e.g., 30-1000 times per second), the call stacks in which most of the time is spent will be identified. Although some call stacks are omitted, it is a minor issue provided these call stacks are combinations for which little time is consumed.","In the event-based traces, there is a fundamental assumption that the traces contain information about routine entries and matching routine exits. Often, entry-exit pairs are nested in the traces because routines call other routines. Time spent (or memory consumed) between entry into a routine and exit from the same routine is attributed to that routine, but a user of a profiling tool may want to distinguish between time spent directly in a routine and time spent in other routines that it calls.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 10C"},"A fundamental concept in the output provided by the methods described herein is the call stack. The call stack consists of the routine that is currently running, the routine that invoked it, and so on all the way up to main. A profiler may add a higher, thread level with the pid\/tid (the process IDs and thread IDs). In any case, an attempt is made to follow the trace event records, such as method entries and exits, as shown in , to reconstruct the structure of the call stack frames while the program was executing at various times during the trace.","The post-processing of a trace file may result in a report consisting of three kinds of time spent in a routine, such as routine A: (1) base time\u2014the time spent executing code in routine A itself; (2) cumulative time (or \u201ccum time\u201d for short)\u2014the time spent executing in routine A plus all the time spent executing every routine that routine A calls (and all the routines they call, etc.); and (3) wall-clock time or elapsed time. This type of timing information may be obtained from event-based trace records as these records have timestamp information for each record.","A routine's cum time is the sum of all the time spent executing the routine plus the time spent executing any other routine while that routine is below it on the call stack. In the example above in , routine A's base time is 2 ms, and its cum time is 10 ms. Routine B's base time is 8 ms, and its cum time is also 8 ms because it does not call any other routines. It should be noted that cum time may not be generated if a call stack tree is being generated on the fly\u2014cum time may only be computed after the fact during the post-processing phase of a profile utility.","For wall-clock or elapsed time, if while routine B was running, the system fielded an interrupt or suspended this thread to run another thread, or if routine B blocked waiting on a lock or I\/O, then routine B and all the entries above routine B on the call stack accumulate elapsed time but not base or cum time. Base and cum time are unaffected by interrupts, dispatching, or blocking. Base time only increases while a routine is running, and cum time only increases while the routine or a routine below it on the call stack is running.","In the example in , routine A's elapsed time is the same as its cum time\u201410 ms. Changing the example slightly, suppose there was a 1 ms interrupt in the middle of B, as shown in FIG. D. Routine A's base and cum time are unchanged at 2 ms and 10 ms, but its elapsed time is now 11 ms.","Although base time, cum time and elapsed time were defined in terms of processor time spent in routines, sample based profiling is useful for attributing consumption of almost any system resource to a set of routines, as described in more detail below with respect to FIG. B. Referring to  again, if routine A initiated two disk I\/O's, and then routine B initiated three more I\/O's when called by routine A, routine A's \u201cbase I\/O's\u201d are two and routine A's \u201ccum I\/O's\u201d are five. \u201cElapsed I\/O's\u201d would be all I\/O's, including those by other threads and processes, which occurred between entry to routine A and exit from routine A. More general definitions for the accounting concepts during profiling would be the following: base\u2014the amount of the tracked system resource consumed directly by this routine; cum\u2014the amount of the tracked system resource consumed by this routine and all routines below it on the call stack; elapsed\u2014the total amount of the tracked system resource consumed (by any routine) between entry to this routine and exit from the routine.","As noted above,  describe the process by which a reconstructed call stack may be generated by processing the event-based trace records in a trace file by following such events as method entries and method exits. Hence, although  describe call stack trees that may be applicable to processing sample-based trace records, the description below for generating or reconstructing call stacks and call stack trees in  is mainly directed to the processing of event-based trace records.","With reference now to , a diagram depicts a tree structure generated from trace data. This figure illustrates a call stack tree  in which each node in tree structure  represents a function entry point. Additionally, in each node in tree structure , a number of statistics are recorded. In the depicted example, each node, nodes -, contains an address (addr), a base time (BASE), cumulative time (CUM) and parent and children pointers. As noted above, this type of timing information may be obtained from event-based trace records as these records have timestamp information for each record. The address represents a function entry point. The base time represents the amount of time consumed directly by this thread executing this function. The cumulative time is the amount of time consumed by this thread executing this function and all functions below it on the call stack. In the depicted example, pointers are included for each node. One pointer is a parent pointer, a pointer to the node's parent. Each node also contains a pointer to each child of the node.","Those of ordinary skill in the art will appreciate that tree structure  may be implemented in a variety of ways and that many different types of statistics may be maintained at the nodes other than those in the depicted example.","The call stack is developed from looking back at all return addresses. These return addresses will resolve within the bodies of those functions. This information allows for accounting discrimination between distinct invocations of the same function. In other words, if function X has 2 distinct calls to function A, the time associated with those calls can be accounted for separately. However, most reports would not make this distinction.","With reference now to , a call stack tree which reflects call stacks observed during a specific example of system execution will now be described. At each node in the tree, several statistics are recorded. In the example shown in , the statistics are time-based statistics. The particular statistics shown include the number of distinct times the call stack is produced, the sum of the time spent in the call stack, the total time spent in the call stack plus the time in those call stacks invoked from this call stack (referred to as cumulative time), and the number of instances of this routine above this instance (indicating depth of recursion).","For example, at node  in , the call stack is CAB, and the statistics kept for this node are 2:3:4:1. Note that call stack CAB is first produced at time  in , and is exited at time . Call stack CAB is produced again at time , and is exited at time . Thus, the first statistic indicates that this particular call stack, CAB; is produced twice in the trace. The second statistic indicates that call stack CAB exists for three units of time (at time , time , and time ). The third statistic indicates the cumulative amount of time spent in call stack CAB and those call stacks invoked from call stack CAB (i.e., those call stacks having CAB as a prefix, in this case CABB). The cumulative time in the example shown in  is four units of time. Finally, the recursion depth of call stack CAB is one, as none of the three routines present in the call stack have been recursively entered.","Those skilled in the art will appreciate that the tree structure depicted in  may be implemented in a variety of ways, and a variety of different types of statistics may be maintained at each node. In the described embodiment, each node in the tree contains data and pointers. The data include the name of the routine at that node, and the four statistics discussed above. Of course, many other types of statistical information may be stored at each node. In the described embodiment, the pointers for each node include a pointer to the node's parent, a pointer to the first child of the node (i.e. the left-most child), a pointer to the next sibling of the node, and a pointer to the next instance of a given routine in the tree. For example, in , node  would contain a parent pointer to node , a first child pointer to node , a next sibling pointer equal to NULL (note that node  does not have a next sibling), and a next instance pointer to node . Those skilled in the art will appreciate that other pointers may be stored to make subsequent analysis more efficient. In addition, other structural elements, such as tables for the properties of a routine that are invariant across instances (e.g., the routine's name), may also be stored.","The type of performance information and statistics maintained at each node are not constrained to time-based performance statistics. The present invention may be used to present many types of trace information in a compact manner, which supports performance queries. For example, rather than keeping statistics regarding time, tracing may be used to track the number of Java bytecodes executed in each method (i.e., routine) called. The tree structure of the present invention would then contain statistics regarding bytecodes executed rather than time. In particular, the quantities recorded in the second and third categories would reflect the number of bytecodes executed rather than the amount of time spent in each method.","Tracing may also be used to track memory allocation and deallocation. Every time a routine creates an object, a trace record could be generated. The tree structure of the present invention would then be used to efficiently store and retrieve information regarding memory allocation. Each node would represent the number of method calls, the amount of memory allocated within a method, the amount of memory allocated by methods called by the method, and the number of methods above this instance (i.e., the measure of recursion). Those skilled in the art will appreciate that the tree structure of the present invention may be used to represent a variety of performance data in a manner which is very compact, and allows a wide variety of performance queries to be performed.","The tree structure shown in  depicts one way in which data may be pictorially presented to a user. The same data may also be presented to a user in tabular form as shown in FIG. .","With reference now to , a call stack tree presented as a table will now be described. Note that  contains a routine, pt_pidtid, which is the main process\/thread, which calls routine C. Table 12 includes columns of data for Level , RL , Calls , Base , Cum , and Indent . Level  is the tree level (counting from the root as level. 0) of the node. RL  is the recursion level. Calls  is the number of occurrences of this particular call stack, i.e., the number of times this distinct call stack configuration occurs. Base  is the total observed time in the particular call stack, i.e., the total time that the stack had exactly these routines on the stack. Cum  is the total time in the particular call stack plus deeper levels below it. Indent  depicts the level of the tree in an indented manner. From this type of call stack configuration information, it is possible to infer each unique call stack configuration, how many times the call stack configuration occurred, and how long it persisted on the stack. This type of information also provides the dynamic structure of a program, as it is possible to see which routine called which other routine. However, there is no notion of time-order in the call stack tree. It cannot be inferred that routines at a certain level were called before or after other routines on the same level.","The pictorial view of the call stack tree, as illustrated in , may be built dynamically or built statically using a trace text file or binary file as input.  depicts a flow chart of a method for building a call stack tree using a trace text file as input. In , the call stack tree is built to illustrate module entry and exit points.","With reference now to , it is first determined if there are more trace records in the trace text file (step ). If so, several pieces of data are obtained from the trace record, including the time, whether the event is an enter or an exit, and the module name (step ). Next, the last time increment is attributed to the current node in the tree (step ). A check is made to determine if the trace record is an enter or an exit record (step ). If it is an exit record, the tree is traversed to the parent (using the parent pointer), and the current tree node is set equal to the parent node (step ). If the trace record is an enter record, a check is made to determine if the module is already a child node of the current tree node (step ). If not, a new node is created for the module and it is attached to the tree below the current tree node (step ). The tree is then traversed to the module's node, and the current tree node is set equal to the module node (step ). The number of calls to the current tree node is then incremented (step ). This process is repeated for each trace record in the trace output file, until there are no more trace records to parse (step ).","With reference now to , a flow chart depicts a method for building a call stack tree dynamically as tracing is taking place during system execution. In , as an event is logged, it is added to the tree in real time. Preferably, a call stack tree is maintained for each thread. The call stack tree reflects the call stacks recorded to date, and a current tree node field indicates the current location in a particular tree. When an event occurs (step ), the thread ID is obtained (step ). The time, type of event (i.e., in this case, whether the event is a method entry or exit), the name of the module (i.e., method), location of the thread's call stack, and location of the thread's \u201ccurrent tree node\u201d are then obtained (step ). The last time increment is attributed to the current tree node (step ). A check is made to determine if the trace event is an enter or an exit event (step ). If it is an exit event, the tree is traversed to the parent (using the parent pointer), and the current tree node is set equal to the parent node (step ). At this point, the tree can be dynamically pruned in order to reduce the amount of memory dedicated to its maintenance (step ). Pruning is discussed in more detail below. If the trace event is an enter event, a check is made to determine if the module is already a child node of the current tree node (step ). If not, a new node is created for the module, and it is attached to the tree below the current tree node (step ). The tree is then traversed to the module's node, and the current tree node is set equal to the module node (step ). The number of calls to the current tree node is then incremented (step ). Control is then passed back to the executing module, and the dynamic tracing\/reduction program waits for the next event to occur (step ).","One of the advantages of using the dynamic tracing\/reduction technique described in  is its enablement of long-term system trace collection with a finite memory buffer. Very detailed performance profiles may be obtained without the expense of an \u201cinfinite\u201d trace buffer. Coupled with dynamic pruning, the method depicted in  can support a fixed-buffer-size trace mechanism.","The use of dynamic tracing and reduction (and dynamic pruning in some cases) is especially useful in profiling the performance characteristics of long running programs. In the case of long running programs, a finite trace buffer can severely impact the amount of useful trace information that may be collected and analyzed. By using dynamic tracing and reduction (and perhaps dynamic pruning), an accurate and informative performance profile may be obtained for a long running program.","Many long-running applications reach a: type of steady-state, where every possible routine and call stack is present in the tree and updating statistics. Thus, trace data can be recorded and stored for such applications indefinitely within the constraints of a bounded memory requirement using dynamic pruning. Pruning has value in reducing the memory requirement for those situations in which the call stacks are actually unbounded. For example, unbounded call stacks are produced by applications that load and run other applications.","Pruning can be performed in many ways, and a variety of pruning criteria is possible. For example, pruning decisions may be based on the amount of cumulative time attributed to a subtree. Note that pruning may be disabled unless the amount of memory dedicated to maintaining the call stack exceeds some limit. As an exit event is encountered (such as step  in FIG. ), the cumulative time associated with the current node is compared with the cumulative time associated with the parent node. If the ratio of these two cumulative times does not exceed a pruning threshold (e.g., 0.1), then the current node and all of its descendants are removed from the tree. The algorithm to build the tree proceeds as before by traversing to the parent, and changing the current node to the parent.","Many variations of the above pruning mechanism are possible. For example, the pruning threshold can be raised or lowered to regulate the level of pruning from very aggressive to none. More global techniques are also possible, including a periodic sweep of the entire call stack tree, removing all subtrees whose individual cumulative times are not a significant fraction of their parent node's cumulative times.","Data reduction allows analysis programs to easily and quickly answer many questions regarding how computing time was spent within the traced program. This information may be gathered by \u201cwalking the tree\u201d and accumulating the data stored at various nodes within the call stack tree, from which it can be determined the amount of time spent strictly within routine A, the total amount of time spent in routine A and in the routines called by routine A either directly or indirectly, etc.","With reference now to , a flowchart depicts a process for creating a call stack tree structure from call stack unwind records in a trace file.  above primarily showed the processes involved in generating a call stack tree from event-based trace records, which show events such as method entries and method exits. These types of trace records allow a call stack to be generated, usually during a postprocessing phase of the profile tool or utility. Using timer interrupts, a profiling function may walk an active call stack to generate a call stack unwind trace record.  describes a process for combining the information in a call stack unwind trace record into a call stack tree. The call stack tree may have been previously constructed from other call stack unwind trace records or from event-based trace records according to the methods described in .","The process begins by reading a call stack unwind record (step ). This step processes the call stack information in the record to determine what routines are or were executing when the timer interrupt occurs or occurred, depending on whether the call stack unwind record is being processed on-the-fly or is being postprocessed. A sample-based profiling function avoids, through the call stack unwind, the need for adding additional instructions to the program, which affects the performance and time spent in routines. Next, the tree structure for this process\/thread (pid, tid) is located (step ). Then, the pointer (PTR) is set to the root of this tree structure by setting PTR=root(pid, tid) (step ). The index is set equal to N, which is the number of entries in the call stack (step ).","A determination is made as to whether the index is equal to zero (step ). If the index is equal to zero, the process then returns to determine whether additional call stack unwind trace records are present for processing (step ). If additional call stack unwind trace records are present, the process then returns to step  to read another call stack unwind trace record. Otherwise, the process terminates.","On the other hand, if the index is not equal to zero, the process then sets sample_address equal to the call_stack_address[index] (step ). The B-tree is then used to lookup the address to get a routine name (step ). Next, a determination is made as to whether PTR.child.name for any child of PTR is equal to the looked-up routine name (step ). In other words, this step determines whether the routine name has ever been seen at this level in the tree structure. If the address has never been seen at this level in the tree structure, a new child of PTR is created and the PTR.child.name is set equal to the routine name, the variable PTR.child.BASE for the node is set equal to zero, and the variable PTR.child.CUM for the node is set equal to zero (step ). Thereafter, the cumulative time for the node is incremented by incrementing the variable PTR.child.CUM (step ). The process also proceeds to step  from step  if the address has been seen at this level. In the case of sample-based trace records, the \u201ccumulative\u201d time represents the number of times that this particular call stack configuration has been processed.","Next, a determination is made as to whether the sample address, sample_address, is equal the last address in the call stack sample, call_stack_address[1] (step ). If the sample address is equal to the address being processed, the base time for the node is incremented by incrementing the variable PTR.child.BASE (step ). The pointer PTR is then set equal to the child (step ), and the index is decremented (step ) with the process then returning to step  as previously described. With reference again to step , if the sample address is not equal to the address being processed, the process then proceeds to step . In the depicted example in , the process is used to process call stack unwind records recorded during execution of a program. The illustrated process also may be implemented to dynamically process call stack unwind records during execution of a program. For example, step  may be modified to wait until the next timer interrupt occurs and then continue to loop back to step  at the next interrupt.","The addresses obtained during sampling are used to identify functions. The functions are identified by mapping these addresses into functions.","With reference now to , a flowchart depicts a process for identifying functions from an address obtained during sampling. The process begins by reading a program counter value that is obtained during sampling of the call stack (step ). A determination is made as to whether the end of file has been reached (step ). If the end of the file has not been reached, the program counter value is looked up in a global map (step ). A global map in the depicted example is a map of system and per process symbols that are generated from system loader information and application, library, and system symbol tables. A process plus function id is obtained from the global map in response to looking up the program counter value (step ). Thereafter, the process returns to step . The function information may be used in generating reports, such as those described below. The process in  also may be used during execution of a program that is sampled.","With reference now to , a diagram of a record generated using the processes of present invention is depicted. Each routine in record  is listed separately, along with information regarding the routine in FIG. . For example, Calls column  lists the number of times each routine has been called. BASE column  contains the total time spent in the routine, while CUM column  includes the cumulative time spent in the routine and all routines called by the routine. Name column  contains the name of the routine. With reference now to , a diagram of another type of report that may be produced is depicted. The report depicted in  illustrates much of the same information found in , but in a slightly different format. As with , diagram  includes information on calls, base time, and cumulative time.",{"@attributes":{"id":"p-0141","num":"0140"},"figref":["FIG. 17","FIG. 17"]},"Looking now at the second stanza, we see that routine C called routine B and routine A once each. All the numbers on \u201cChild\u201d rows are subsets of numbers from the child's profile. For example, of the three calls to routine A in this trace, one was by routine C; of routine A's seven microsecond total base time, three microseconds were while it was called directly by routine C; of routine A's fourteen microsecond cum time, seven microseconds was on behalf of routine C. Notice that these same numbers are the first row of the third stanza, where routine C is listed as one of routine A's parents.","The four relationships that are true of each stanza are summarized at the top of FIG. . First, the sum of the numbers in the Calls column for parents equals the number of calls on the self row. Second, the sum of the numbers in the Base column for parents equals Self's base. Third, the sum of the numbers in the Cum column for parents equals Self's Cum. These first three invariants are true because these characteristics are the definition of Parent; collectively they are supposed to account for all of Self's activities. Fourth, the Cum in the Child rows accounts for all of Self's Cum except for its own Base.","Program sampling contains information from the call stack and provides a profile, reflecting the sampling of an entire call stack, not just the leaves. Furthermore, the sample-based profiling technique may also be applied to other types of stacks. For example, with Java programs, a large amount of time is spent in a routine called the \u201cinterpreter\u201d. If only the call stack was examined, the profile would not reveal much useful information. Since the interpreter also tracks information in its own stack, e.g., a Java stack (with its own linkage conventions), the process can be used to walk up the Java stack to obtain the calling sequence from the perspective of the interpreted Java program.","With reference now to , a figure depicts a report generated from a trace file containing both event-based profiling information (method entry\/exits) and sample-based profiling information (stack unwinds).  is similar to , in which a call stack tree is presented as a report, except that  contains embedded stack walking information. Call stack tree  contains two stack unwinds generated within the time period represented by the total of 342 ticks. Stack unwind identifier  denotes the beginning of stack unwind information , with the names of routines that are indented to the right containing the stack information that the stack walking process was able to discern. Stack unwind identifier  denotes the beginning of stack unwind information . In this example, \u201cJ:\u201d identifies an interpreted Java method and \u201cF:\u201d identifies a native function, such as a native function within JavaOS. A call from a Java method to a native method is via \u201cExecuteJava.\u201d Hence, at the point at which the stack walking process reaches a stack frame for an \u201cExecuteJava,\u201d it cannot proceed any further up the stack as the stack frames are discontinued. The process for creating a tree containing both event-based nodes and sample-based nodes is described in more detail further below. In this case, identifiers  and  also denote the major code associated with the stack unwind.","With reference now to , a table depicts major codes and minor codes that may be employed to instrument software modules for profiling. In order to facilitate the merging of event-based profiling information and sample-based profiling information, a set of codes may be used to turn on and off various types of profiling functions.","For example, as shown in , the minor code for a stack unwind is designated as 0\u00d77fffffff, which may be used for two different purposes. The first purpose, denoted with a major code of 0\u00d740, is for a stack unwind during a timer interrupt. When this information is output into a trace file, the stack information that appears within the file will have been coded so that the stack information is analyzed as sample-based profiling information. The second purpose, denoted with a major code of 0\u00d741, is for a stack unwind in an instrumented routine. This stack information could then be post-processed as event-based profiling information.","Other examples in the table show a profile or major code purpose of tracing jitted methods with a major code value of 0\u00d750. Tracing of jitted methods may be distinguished based on the minor code that indicates method invocation or method exit. In contrast, a major code of 0\u00d730 indicates a profiling purpose of instrumenting interpreted methods, while the minor code again indicates, with the same values, method invocation or method exit.","Referring back to , the connection can be made between the use of major and minor codes, the instrumentation of code, and the post-processing of profile information. In the generated report shown in , the stack unwind identifiers can be seen to be equal to 0\u00d740, which, according to the table in , is a stack unwind generated in response to a timer interrupt. This type of stack unwind may have occurred in response to a regular interrupt that was created in order to generate a sampled profile of the executing software.","As noted in the last column of the table in , by using a utility that places a hook into a software module to be profiled, a stack unwind may be instrumented into a routine. If so, the output for this type of stack unwind will be designated with a major code of 0\u00d741.","When gathering profile information using an symmetric multiprocessing (SMP) system, if two processors update the same metric variable concurrently, it is impossible to apportion the change in a metric variable between two processors. If two processors update the same global variable concurrently, it cannot be determined how much of the change is due to a thread on a first processor and how much of the change is due to a second thread on a second processor.","Profile information is gathered about the execution of a particular program or routine by accumulating changes in specific metric values and analyzing the execution performance from those accumulated metric values. In order for a profiler to apply the changes to a metric, such as, bytes allocated to a method, the Jvm must either call the profiler whenever a metric event occurs or an interface must be to allow the profiler to determine the value of the change in the metric for the current thread. Two methodologies are identified below to provide this support in an SMP system.  depict a first approach wherein the profiler to keep track of the changes itself on a per thread basis as the changes are being made.  depict a second approach in which individual processors maintain per processor data areas. There, the kernel or a kernel device driver updates metric values for a thread whenever a thread switch occurs or there is a request for the metric on a specified thread.","With reference now to , a block diagram depicts the relationship between a profiler and other software components in a data processing system capable of application level thread oriented process for tracking metrics on a per thread basis. The process of the present embodiment tracks metrics equally well regardless whether processing is provided by a uniprocessor or SMP architecture.","Operating system kernel  provides native support for the execution of programs and applications, such as Jvm , in a data processing system. Jvm  executes Java programs, possibly by compiling the program via a just in time (JIT) compiler (not shown). As Java applications execute, objects are allocated and deallocated in a heap, and Jvm  maintains heap information  concerning the objects, such as heap  shown in FIG. . Profiler  accepts events from Jvm  instrumentation through Jvm Profiling Interface (JVMPI) , and returns information as required by Jvm. Preferably, profiler  is a set of native runtime DLLs (dynamic link libraries) supported by operating system kernel . Profiler  generates call stack trees, trace output , etc. as necessary to provide a runtime profile to an application developer monitoring the execution of a profiled program.","In a preferred embodiment profiler  allocates memory space in its own buffer for metrics (M) being tracked. Here, the notation \u2018M\u2019 represents values for individual metrics m, m, m. . . m. It should be understood that reference to metrics (M) refers to any one or all of individual metrics m, m, m. . . m, where M=m, m, m. . . m. An individual metric (m) is any metric normally tracked for monitoring method execution, performance optimization or memory leak detection, such as number of allocated objects or bytes to a method or execution time. Metrics values may be tracked as variables, for example the accumulated value of metrics (M) is represented as Cum (M), while the accumulated value of metrics (M) for thread (t) is represented as variable Cum (M,t) and the last accumulated value of metrics (M) accumulated in response to the last metric changing event for thread (t) is represented as LastCum (M,t).","Profiler  may use a variety of data structures for maintaining the metric values, such as, a linked list. As a new thread is launched, a new element may be added to the linked list for storing metric values for that thread. Alternatively, the profiler has its own buffer area or \u201cmini-heap\u201d from which it may allocate space for each metric data area. Profiler  allocates data areas in its buffer and stores values for: a global variable representing the total value of all metrics (M) for all threads, Total (M) ; variables representing the accumulated values of all metrics (M) for all active threads (t-t), Cum (M,t)  to Cum (M,t) ; and variables representing the last accumulated values of all metrics (M) for all active threads (t-t) at the time of the last Jvm event, LastCum (M,t)  to LastCum (M,t) .","Jvm  utilizes operating system kernel  for processing support. Operating system  controls one or more processes for processing threads for Jvm . In a uniprocessor environment, the profiler captures variable values for a metric at thread switches and at entries and exits and applies the change to the method on the specified thread. However, in the depicted example, operating system kernel  supports symmetric multiprocessing (SMP) which allows multiple processors to operate simultaneously. In this case, processors P-P are supported by operating system kernel  in a multiprocessing fashion. In the SMP case, if two processors update the same global variable concurrently, it is impossible to apportion the change in a metric to the correct thread without somehow SMP enabling the profiler. While a non-SMP enabled profiler would capture metric values for an individual processor at thread switches and at entries and exits for a method on a specified thread, individual values from each SMP processor are impossible to determine.","In accordance with a preferred embodiment of the present invention, profiler  accurately tracks metric values regardless of the type of processor architecture. For example, operating system kernel  may utilize a single processor (uniprocessor architecture) or may instead utilize multiple processors in a symmetrical multiprocessor (SMP) architecture as depicted in the present figure by processors P to P. Each time a thread is launched, Jvm  creates a new Java stack for the thread. The thread's Java stack stores the state of the Java method invocations for the thread. Jvm  also calls operating system kernel  for processor support for the new thread. Operating system kernel  dispatches the thread to any one of processors P to P which perform the necessary thread processing completely hidden from Jvm  and profiler . However, profiler  need not receive any metric information from operating system kernel  because Jvm  communicates events which result in a change in any metric value directly to profiler  through JVMPI . Thus, profiler  can calculate the value of any metric being tracked without communicating with operating system kernel . Jvm  merely sends metric events and method entry and exit events to profiler  when calling operating system kernel  for processor support. Profiler  can then update the metric values for the current thread as well for the current method based on information provided by Jvm . On the occasion when Jvm  needs metric values for a specific variable and\/or thread, the Jvm merely requests the needed metric variable from profiler  through JVMPI .","With reference to , flowcharts depict the initialization process necessary for performing an application level thread-oriented approach for tracking metrics in accordance with a preferred embodiment of the present invention.  is a flowchart illustrating a process for initializing the profiler for performing the application level thread-oriented approach for tracking metrics (M) in accordance with a preferred embodiment of the present invention. The process begins with the Jvm being called by a method for processing current thread (t)(step ). Prior to current thread (t) being launched the profiler had not been tracking any metric variables. Therefore, the profiler must be initialized for tracking specific metrics. The Jvm then initializes the profiler, via JVMPI by sending a list of the specific metrics for the profiler to track (step ). These metrics might include, for example, object and byte allocations for a method, active objects, live bytes or execution time. The profiler then allocates data areas within its buffer for tracking the metric variables total (M), Cum (M,t) and LastCum (M,t) on current thread (t) (step ). The process for initializing the profiler for metrics (M) on current thread (t) is then complete.",{"@attributes":{"id":"p-0160","num":"0159"},"figref":"FIG. 21B","sub":["new","new","new","new","new"],"b":"2110"},"Once the data area has been allocated for metrics (M), the profiler is enabled to track metrics saved in the profiler's data areas. Metric values are updated in two basic ways, first in response to a method entry or exit event. There all metrics (M) are updated with respect to the current method on the basis of a thread event occurring on the current thread (t). The second is in response to a single metric (m) event. There, an individual metric (m) is updated on the basis of the an individual metric event occurring.","Referring to , a flowchart depicting a process for tracking an individual metric in response to a metric event in accordance with a preferred embodiment of the present invention. The process begins with the Jvm having a metric event (step ). In this case, the metric event refers to an event associated with any single metric (m), such as number of objects allocated or deallocated, number of bytes allocated or deallocated, time, et cetera. Of course a metric event may involve a plurality of metrics (M) being tracked, in that case the process is duplicated for each metric (m). The process continues with the Jvm sending a notification of the metric event to the profiler including the change in the value of metric (m), MDelta (m)(step ). The profiler receives the metric event and the change in the metric's value, (MDelta (m)) (step ). The profiler applies the metric value, MDelta (m), to the appropriate Total and Cum metric values (step ). For example, Total (m) is increased by the amount MDelta (m).\n\nTotal()+=() \n\nAdditionally, the Cum value of the metric (m) on each thread (t) is increased by MDelta (m).\n\n()+=() \n","With the Total and Cum values for metrics (M) being updated for the metric event, the process is complete. With reference to , a flowchart depicting a process for tracking metrics in response to a method entry or exit event occurring on current thread (t) in accordance with a preferred embodiment of the present invention. The process begins with the profiler receiving an entry or exit event on currently running thread (t) from the Jvm through JVMPI (step ). Here it is assumed that more than a single metric (m) will change as result of the event, however, depending on the individual metrics selected for tracking, it may be the case that only an individual metric (m) changes its value. As the process continues, the profiler must calculate a change in the value of metrics (M) being tracked, Delta (M), since the last method entry or exit event. Delta (M) is the portion of Cum (M,t) which has accumulated since the last method entry or exit event. Finding the value of Delta (M) is possible because the value of LastCum (M,t) was set at the last entry or exit event. Thus Delta (M) is the difference of Cum (M,t) and LastCum (M,t). Delta (M) can be determined from:\n\nDelta()=()\u2212() \n\nfor current thread (t) (step ). The profiler then must reset LastCum (M,t) to Cum (M,t) in order that Delta (M) can be calculated for subsequent method entry and exit events (step ). LastCum (M,t) is reset by:\n\n()=() \n","Next, the accumulated metric value for the current method, Method (M), must be updated by the value of the change in metrics (M), Delta (M) (step ). The method running on thread (t) is updated by the value of Delta (M) by:\n\nMethod()+=Delta() \n","The process for updating a metrics (M) in response to a method entry or exit event is complete.","From time-to-time, the Jvm may need the current value of metrics (M). However, Jvm does not track the metrics themselves and must rely on the profiler for the metric values. Thus, when the Jvm has need for a metric, the Jvm must get that value from the profiler. With reference to , a flowchart depicting a simplified application programming interface (API) is depicted for retrieving metric values in accordance with a preferred embodiment of the present invention. The process begins with the Jvm requesting metric variable values from the profiler (step ). The metric variable may be either the accumulated value of the metrics, Cum (M,t) or the total value of the metrics, Total (M) is the total value of the metrics being tracked for all active threads (t-t). The profiler then returns requested value(s) to the Jvm (step ). The process is now complete with respect to a simplified application programming interface (API) for retrieving metric values.","The above-described embodiment has an advantage of accurately tracking metrics for either uniprocessor or SMP architectures at the application level. Little or no modifications are needed to the operating system kernel as the profiler does the work. Each time an event occurs, the Jvm communicates the event directly to the profiler, and thus operating system kernel support is not needed. An alternative to the above-described embodiment is having the operating system kernel calculate and store the metric values for active threads. the operating system kernel then returns the metric values to the profiler in response to a request from the profiler. The operating system kernel must be modified to provide metric tracing support to the profiler.","With respect to , a diagram illustrating the relationship of the Jvm, profiler and an operating system kernel for tracking metrics using an operating system kernel level per processor based approach in accordance with a preferred embodiment of the present invention. Jvm  utilizes operating system kernel  for processing support as described above of processing threads launched by Jvm . Operating system  controls one or more processors for that function. In contrast with the above-described embodiment, here profiler  relies on operating system kernel  to calculate the accumulated values of metrics (M). Thus, operating system kernel  must allocate memory space for tracking metrics (M).","However, because operating system kernel  utilizes processors P through P in a symmetrical multiprocessor (SMP) fashion, changes in metrics (M) must be computed and stored on a per processor basis and then applied to a per thread metric. By first computing the changes in a metric due to a processor (p) for the thread running on processor (p), each SMP processor's contribution can be accurately reflected in the value of the metric for a thread. Thus, operating system kernel  stores the per processor accumulated values of metrics (M) in a data area associated with each processor, PCum (M,p)  through PCum (M,p) . Additionally, operating system kernel  stores the value of the last accumulated metric variable for each processor, LastCum (M,p)  through LastCum (M,p) . LastCum values are reset for each processor every time PCum (M,p) is used to update the value of a per thread accumulated metric variable. This may occur when a thread is dispatched to processor (p), at method entry or exit events while a thread is being processed on processor (p) or any time the profiler calls for a current value of a metric variable for a thread running on processor (p). PLastCum (M,p)  through PLastCum (M,p)  are needed for computing the change in the value of metrics (M), Delta (M) on a processor. Additionally, operating system kernel  maintains a data area for value of per thread accumulated metric variables, TCum (M,t), for active threads (t-t). These variables are depicted in the diagram as TCum (M,t)  through TCum (M,t) .","Thus, in accordance with a preferred embodiment of the present invention, profiler  is relieved of the responsibility for computing the accumulated values of metrics (M) for any thread. Instead profiler  merely calls operating system  for the current value of per thread accumulated metric variables, TCum (M,t), for any active thread (t-t). Therefore, it is only necessary for profiler  to provide data areas for storing the accumulated values of the metrics variables for active threads (t-t), ProfCum (M,t)  through ProfCum (M,t) .","With reference to , a flowchart depicting the initialization process for tracking metrics on a per processor basis in accordance with a preferred embodiment of the present invention. The process begins with the Jvm being called by a method for processing current thread (t)(step ). Prior to current thread (t) being launched neither the profiler or the operating system kernel had been tracking any metric variables. It is assumed that no data areas had been allocated for any metric variable in either the profiler or the operating system kernel. The Jvm then passes parameters to the profiler, including the identity of current thread (t) (step ). The profiler then calls the Jvm to indicate identity of metrics variables being tracked (step ). The profiler then allocates a data area for the accumulated value of metrics (M) for current thread (t), ProfCum (m,t) and initializes the metric variable ProfCum (M,t) to zero (step ). ProfCum (M,t) is initialized by:\n\n()=0 \n","Next, the operating system kernel allocates and initializes data areas for metric variables to be tracked (step ). The operating system kernel allocates data areas needed for tracking metrics (M), if necessary, and initializes the value of each data area to zero for each processor and the current thread (t). One of ordinary skill in the art would be familiar with operating systems in which per processor data areas are predefined. In those environments the operating system has a pointer to each per processor data area. The per processor data area pointers can be used by the Jvm, for example, to directly access the per processor data areas an update metric variables contained within those data areas.","The operating system kernel sets to zero the value of the per processor accumulated metric variables, Pcum (M,p), for each processor. The metric variables are stored in each processor's data area. Pcum (M,p) is set by:\n\n()=0 \n\nNext, the operating system kernel sets the value of the per processor last accumulated metric variables, PLastCum (M,p) to zero for each processor. These metric variables are also stored in each processor's data area. PLastCum (M,p) is set by:\n\n()=0 \n","Additionally, operating system kernel: sets the accumulated value of the metric for the current thread (t) to zero.\n\n()=0 \n","The process is now complete for the initialization process for tracking metrics on a per processor basis.","With reference to , a flowchart depicting a process for initializing the operating system kernel in response to the kernel recognizing a new thread in accordance with a preferred embodiment of the present invention. Each time a new thread is launched, a data area must be allocated for the metric variables associated with that thread. Of course, the per processor data areas for the metric variables have already been allocated. Additionally, since the new launched thread has not previously been processed, its metric values are nulled (step ). Thus, the operating system kernel initializes the per processor accumulated value of the metric variable, PCum (M,p), by setting PCum(M,p) to zero for the processor that will process thread (t), processor (p). The metric variable is stored in processor (p)'s data area. PCum (M,p) is set by:\n\n()=0 \n\nNext, the operating system kernel sets the value of the per processor last accumulated metric variable, PLastCum (M,p) to zero for processor (p). This metric variable are also stored in processor (p)'s data area. PLastCum (M,p) is set by:\n\n()=0 \n","Additionally, operating system kernel allocates a new data area for an accumulated metric variable, TCum (M,t) for the newly launched thread (t). The operating system kernel then initializes that variable by setting it to zero. TCum (M,t) is set by:\n\n()=0 \n","The process for initializing the operating system kernel in response to the kernel recognizing a new thread is complete.","However, whenever a new thread is launched the profiler must also recognize the new thread and create a data area for storing that thread's metrics. With reference to , a flowchart depicting a process for initializing the profiler in response to the profiler recognizing a new thread in accordance with a preferred embodiment of the present invention. The profiler maintains its own accumulated metric variable values, ProfCum (M,t), for each active thread. Therefore, each time a new thread is launched, the profiler must allocate a data area for the metric variables associated with that thread. Additionally, since the new launched thread has not previously been processed, its metric values are nulled (step ). The profiler initializes the per thread accumulated value of the metric variable, ProfCum (M,t), by setting ProfCum(M,t) to zero for the newly launched thread (t). The metric variable is stored in the profiler's data area. ProfCum (M,t) is set by:\n\n()=0 \n","The process for initializing the profiler in response to the profiler recognizing a new thread is complete.","Metric variable values must maintain an accurate count of the metrics being tracked. The metric variable values must be responsive to a variety of events in order to accurately reflect the metric. Because the present embodiment employs an operating system kernel level per processor oriented approach for tracking metric variables, changes in a metric being tracked must be applied at the processor level. The per processor metric variable values can be then used to update the thread level metric variable values.","A change in value of each per processor accumulated metric variable, PCum (M,p), is in response to a variety of events related to the metrics being tracked. Many of these events are recognized by the processor that is processing the thread. For example, the real time clock or performance counters are updated by the operating system kernel. The change in the metric, MDelta (m) is then applied to PCum (M,p) by that processor. However, other events are not recognized by the processor running the thread and therefore the processor cannot apply MDelta (m) to PCum (M,p) due to those events. In that case, for example, the Jvm must update the metric (m) being tracked to reflect the change in the metric, MDelta (m). One event is when a change in the value of a metric, MDelta (m), occurs at the Jvm. The Jvm is then responsible for updating PCum (m,p) to reflect MDelta (m).","With reference to , a flowchart depicting a process for the operating system kernel updating a per processor metric variable being tracked, in response to a Jvm request in accordance with a preferred embodiment of the present invention. The process begins with the Jvm recognizing that the value of a metric being tracked, metric (m), has changed by MDelta (m) (step ). In this case, the metric being tracked is an individual metric (m). The Jvm tracks the Total (m) which is the total accrued value of metrics (m). Therefore, the Jvm must update Total (m) each time the Jvm senses that the value of metric (m) has changed by MDelta (m), whenever MDelta (m)\u22600. The metric variable Total (m) is updated by:\n\nTotal()+=() \n\nThe Jvm then updates the value of the per processor accumulated metric variable, PCum (m,p) by adding the value of the change in the metric variable, MDelta (m) (step ). The metric variable PCum (m,p) is updated by:\n\n()+=() \n\nWhile the above-described process is in progress, a thread dispatch may occur. The operating system kernel stops executing the current thread on a first processor and eventually executes the thread on a second processor. In response to a thread dispatch during the process, the value of MDelta (m) may be applied to either the first or second processor's data area as the operating system kernel handles the thread dispatch in accordance with a preferred embodiment described below with respect to FIG. . Updating base metric values with processor accumulated metric values requested from the kernel may be accomplished by the profiler in accordance with a preferred embodiment described below with respect to FIG. . The methods described below for thread dispatch handling and updating base metric values assure that the MDelta (m) is applied as appropriately during a thread dispatch. The process is now complete with respect to the Jvm changing a per processor metric value.\n","Depending on the type of operating system, the process for updating the value of processor level accumulated metric variable, PCum (m), stored in a processor's data area, may be performed by using one of two updating processes. Indirectly, by the Jvm relying on the operating system kernel to update PCum (m) or directly by the Jvm accessing the processor's data area for the processor that is processing current thread (t) and directly updating the metric variable PCum (m).","With reference to , a flowchart depicting a process for the Jvm directly updating the value of a per processor metric variable in accordance with a preferred embodiment of the present invention. As mentioned above, certain operating systems utilize predefined processor data areas that may be used for storing per processor metrics. These operating systems provide the Jvm with a data area pointer with which to access per processor data areas. With the data area pointer stored in the Jvm's register, the Jvm can directly access a per processor data area and update a per processor metric in a single atomic instruction.","The process begins with the Jvm recognizing that a metric (m) being tracked has changed an amount represented by MDelta (m) (step ). Next, the Jvm accesses the data area of the processor processing the current thread (t) and directly updates the accumulated value of a metric, PCum (m,p) stored in the processor's data areas (step ). The Jvm utilizes the data area pointer in its register for accessing the processor's data area. One of ordinary skill in the art would realize that updating a per processor variable must be performed as a single atomic instruction before releasing the processor. The metric variable PCum (m,p) is updated by:\n\n()+=() \n\nThe process of the Jvm directly updating a per processor metric variable is now complete.\n","With reference to , a flowchart depicting a process for the operating system kernel updating the value of a per processor metric variable in response to a request from the Jvm in accordance with a preferred embodiment of the present invention. As mentioned above, not all operating systems provide a predefined per processor data area for storing processor related data. Those operating systems must allocate data areas for storing processor related information, such as, the value of per processor metric variables, Pcum (M,p), for example. In this case the Jvm is not able to directly access the operating system kernel allocated per processor data areas. Therefore, the Jvm must rely on the operating system kernel for updating the value of per processor metric variables stored in those data areas.","The process begins with the Jvm recognizing that a metric (m) being tracked for a current thread (t) has changed by an amount represented by MDelta (m) (step ). The Jvm then requests the operating system kernel update the metric (m) in response to MDelta (m) (step ). Finally, the operating system kernel ensures that the value of the metric variable, PCum (M,p), is updated without releasing the current processor (step ). The operating system kernel knows which processor the current thread (t) is running on. The operating system kernel then accesses the data area for that processor and updates the value of the accumulated per processor metric variable, PCum (m,p), using the value of the change in the metric variable MDelta (m). The metric variable Pcum (m,p) is updated by:\n\n()+=() \n\nThe process of the operating system kernel updating a per processor metric variable in response to a request from the Jvm is now complete.\n","With reference to , a flowchart depicting the operating system kernel updating a metric variable value in response to a thread dispatch event in accordance with a preferred embodiment of the present invention. Each time a new thread is dispatched, the value of the per processor metric variable for the old thread running on processor (p), TCum (M,p) and maintained in processor (p)'s data area, must be used to update the value of the thread accumulated metric variable for thread. (t), TCum (M, t), held in the operating system kernel's data area. Thereafter, the value of the last accumulated metric variable for processor (p), PLastCum (M,p), which will be used to start new thread (t), is replaced by the current value of the accumulated metric variable, PCum (M,p), being held in processor (p)'s data area. Processor (p) can then proceed in processing new thread (t) while accurately tracking metrics for the new thread (t).","The process begins when processor (p) determines that a thread switch is necessary. Thread (t) on processor (p) is stopped and thread (t) is dispatched to processor (p) (step ). The operating system kernel then calculates the value of the change in metrics (M), Delta (M) (step ). The value of the change in metric, Delta (M), is found by decreasing the value of the accumulated metric variable for processor (p), PCum (M,p), by the value of the last accumulated metric variable for processor (p), PLastCum (M,P). The metric variable Delta (M) is calculated by:\n\nDelta()=()\u2212() \n\nNext, the operating system kernel resets the value of the last accumulated metric variable for processor (p), PLastCum (M,p) (step ). The value of the last accumulated metric variable for processor (p), PLastCum (M,p), is replaced by the current value of the accumulated metric variable for processor (p), PCum (M,p). The metric variable PLastCum (M,p) is reset by:\n\n()=() \n\nFinally, the operating system kernel updates the value of the accumulated metric variable for thread (t), TCum (M, t) (step ). The current value of TCum (M, t) held in the operating system kernel's data area must be increased to accurately reflect the change in the value of the metric, Delta (M), which was acquired from the metric values held in processor (p)'s data area, as described in step  above. The metric variable TCum (M,) is updated by:\n\n()+=Delta() \n\nThe process is now complete for updating a metric in response to a thread being dispatched to processor (p).\n","With respect to , a flowchart depicting the process for updating metric variable values in response to method entry or exit event in accordance with a preferred embodiment of the present invention. The process begins with the profiler receiving a entry or exit event for a method on thread (t) from the Jvm (step ). The profiler then requests the current value of the accumulated metric variable for thread (t), TCum (M,t) from the operating system kernel (step ). In response to the request from the profiler, the operating system kernel calculates the value of the change in metrics (M), represented by Delta (M), from processor (p) which is currently running thread (t) (step ). The value of the change in metrics (M), Delta (M), is the difference between the present per processor value of the accumulated metric variable for processor (p) was processing thread (t), PCum (M,p), and the per processor value of the last accumulated metric variable for that processor, PLastCum (M,p). The metric variable Delta (M) is calculated by:\n\nDelta()=()\u2212() \n\nHaving used the value of PLastCum (M,p) for calculating Delta (M), the kernel resets PLastCum (M,p), to the current value of the accumulated metric variable on processor (p), Pcum (M,p) (step ). The metric variable PLastCum (M,p) is reset by:\n\n()=()>\n\nThe operating system kernel then updates the value of the accumulated metric variable for thread (t), TCum (M,t) (step ). The metric variable TCum (M,t) is held in the operating system kernel's data area and must be increased by the value of the change in the metric variable on processor (p), Delta (M), in order to reflect the change in the value of metrics (M) attributed to processor (p). The metric variable TCum (M,t) is updated by:\n\n()+=Delta() \n\nNext, the value of the accumulated metric variable for thread (t), TCum (M,t), is sent to the profiler. The profiler can now calculate the change in metrics (M), ProfDelta (M), due to the new accumulated metric variable for thread (t) (step ). The change in metrics (M), ProfDelta (M), can be determined from the difference in the value the accumulated metric variable, Tcum (M,t), received from, the operating system, and the value of the accumulated metric variable for thread (t), ProfCum (M,t), held by the profiler. The metric variable ProfDelta (M) is calculated by:\n\n()=()\u2212() \n\nNext, the profiler uses the change in metrics (M), ProfDelta (M) to update the base value of the current method metric variable, Method (M,t). Method (M,t) updates the base value of the current method by:\n\nMethod()+=() \n\nFinally, the profiler sets the old value of the accumulated metric variable for thread (t), ProfCum (M,t), held by the profiler with the value of the accumulated metric variable for thread (t), Tcum (M,t), received from the operating system kernel. The metric variable ProfCum (M,t) is set by:\n\n()=() \n\nThe process for the profiler updating a base metric variable in response to method entry or exit event is now complete.\n","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in a form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such as a floppy disc, a hard disk drive, a RAM, and CD-ROMS and transmission-type media, such as digital and analog communications links.","It is important to note that while the present invention has been described in the context of a single active Jvm within an operating system, there are no constraints to its application to multiple Jvms. This generalization is well within the means of those with ordinary skill in the art.","The description of the present invention has been presented for purposes of illustration and description, but is not limited to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. For example, the present invention may be applied to other interpreted programming systems and environments other than Java. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 2A-B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 10B","FIG. 10A"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 10C-D"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 15A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 15B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 17","FIG. 12"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 21B","sub":"new"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 26A"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 26B"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 26C"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 31"}]},"DETDESC":[{},{}]}
