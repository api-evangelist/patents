---
title: System and method for annotating graphical user interface
abstract: A system and method of creating annotations for graphical user interface (GUI) objects is provided. The annotations may be based on best candidate GUI objects that are in the vicinity of GUI objects that need annotation. The best candidate GUI object may be selected based on the position of an unannotated GUI object, a position of candidate GUI objects, a role of the unannotated GUI object, and a precedence criteria of the unannotated GUI object. The precedence criteria may include a position preference for candidate GUI objects in relation to unannotated GUI objects. The annotations may also be based on information within a self-described GUI object. Options can be specified to define how the annotations are extracted from candidate GUI objects and self-described GUI objects. The annotation of GUI objects can assist non-technical users in the automated testing and documentation of GUIs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08745521&OS=08745521&RS=08745521
owner: The Original Software Group Limited
number: 08745521
owner_city: 
owner_country: GB
publication_date: 20110921
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND AND SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a non-provisional of U.S. Patent Application No. 61\/521,327 filed on Aug. 8, 2011, which is incorporated herein by reference in its entirety.","This invention relates to a system and method for annotating graphical user interface objects. More particularly, the present invention provides a system and method of identifying graphical user interface objects by providing an annotation for the objects, based on the properties and positions of the surrounding objects in a graphical user interface.","Before a software application can be deployed, it is typically tested to be sure it behaves as the developer intended. Where the application requires user input, such as through a graphical user interface (GUI), various input possibilities must be tested to ensure the application responds appropriately to the information provided. This also must be done if a GUI is changed, or added to the application by developers or by users that may need to tailor the application to suit their particular needs. One method of testing involves manual interaction with the GUI and\/or supplying inputs to GUI objects to test their response. However, manual testing can be highly inefficient, especially where a large number of input possibilities are involved. Thus, in a field known as testing automation, software testers develop test scripts to automatically cycle through and provide numerous inputs in order to analyze the functionality of an application. Unfortunately, these test scripts can become as complex as the application source code they are testing and to reference GUI objects within the application requires knowledge of, and access to the source code underlying the application.","The challenge is communicating to the application what it is to do in a non-technical manner. Manually, a user can do this by interacting with the GUI objects, such as by entering data in a textbox or clicking on a command button. However, to automate this process so that it can cycle through a series of inputs without manual entry, test scripts have traditionally been required to identify the specific GUI object that is to be selected or that is to receive input by using the name given that GUI object within the application source code. For example, if a test script is to cycle through a series of numbers from 1 to 100 entered into a text box, the script must reference the text box with its name in the source code, which may be assigned according to a programming lexicon known only to the original programmer. If the source code is not available, as is typically the case, testing automation becomes complicated and requires a technically savvy tester.","The present invention is provided to create annotations for each unannotated GUI object based on the properties and positions of other GUI objects in a GUI. The GUI objects can include the unannotated GUI objects, candidate GUI objects, redundant GUI objects, and self-described GUI objects. The candidate GUI objects will contain text strings which can be used as the basis for creating annotations for the unannotated GUI objects. Nearby candidate GUI objects that are in the vicinity of an unannotated GUI object can be determined by the present invention, based on the locations and bounding rectangles of the unannotated GUI object and the candidate GUI objects, and the role and a precedence criteria of the unannotated GUI object. A best candidate GUI object can be selected from the nearby candidate GUI objects based on the precedence criteria. The text string included in the best candidate GUI object can then be used as the annotation for the unannotated GUI object.","By creating annotations for the unannotated GUI objects, the present invention can be used in conjunction with automated testing and documentation of a GUI, particularly by non-technical users. For instance, the present invention can help non-technical users test and document browser and legacy applications written in a variety of programming languages without reference to or needing access to the underlying source code, such as through the use of software including TestDrive from Original Software, for example. The present invention can simplify the commands used by non-technical users in creating a series of test automation steps in a test script, or in generating documentation of a GUI. Other features and advantages are provided by the following description and drawings.","While this invention is susceptible of embodiments in many different forms, there is shown in the drawings and will herein be described in detail preferred embodiments of the invention with the understanding that the present disclosure is to be considered as an exemplification of the principles of the invention and is not intended to limit the broad aspect of the invention to the embodiments illustrated.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 2","FIG. 2"],"b":["300","100","300","210","220","230","300","304","304","200","300","100","200","300","310","310","100"]},"In some embodiments, the GUI object annotation system facilitator  is implemented in software as an executable program, and is executed by one or more special or general purpose digital computer(s), such as a mainframe computer, a personal computer (desktop, laptop or otherwise), personal digital assistant, or other handheld computing device. Therefore, computing device  may be representative of any computer in which the GUI object annotation system facilitator  resides or partially resides, such as the GUI object annotation system server  of .","Generally, in terms of hardware architecture as shown in , computing device  includes a processor , a memory , and one or more input and\/or output (I\/O) devices  (or peripherals) that are communicatively coupled via a local interface . Local interface  may be one or more buses or other wired or wireless connections, as is known in the art. Local interface  may have additional elements, which are omitted for simplicity, such as controllers, buffers (caches), drivers, transmitters, and receivers to facilitate external communications with other like or dissimilar computing devices. Further, local interface  may include address, control, and\/or data connections to enable internal communications among the other computer components.","Processor  is a hardware device for executing software, particularly software stored in memory . Processor  can be any custom made or commercially available processor, such as, for example, a Core series processor made by Intel Corporation, or a Phenom, Athlon or Sempron series processor made by Advanced Micro Devices, Inc. In the case where computing device  is a server, the processor may be, for example, a Xeon or Itanium series processor from Intel, or an Opteron series processor from Advanced Micro Devices, Inc. Processor  may also represent multiple parallel or distributed processors working in unison.","Memory  can include any one or a combination of volatile memory elements (e.g., random access memory (RAM, such as DRAM, SRAM, SDRAM, etc.)) and nonvolatile memory elements (e.g., ROM, hard drive, flash drive, CDROM, etc.). It may incorporate electronic, magnetic, optical, and\/or other types of storage media. Memory  can have a distributed architecture where various components are situated remote from one another, but are still accessed by processor . These other components may reside on devices located elsewhere on a network or in a cloud arrangement.","The software in memory  may include one or more separate programs. The separate programs comprise ordered listings of executable instructions for implementing logical functions. In the example of , the software in memory  may include the GUI object annotation system facilitator  in accordance with the present invention, and a suitable operating system (O\/S) . Examples of suitable commercially available operating systems  are Windows operating systems available from Microsoft Corporation, Mac OS X available from Apple Inc., a Unix operating system, or a Unix-derivative such as BSD or Linux. The operating system O\/S  will depend on the type of computing device . For example, if the computing device  is a PDA or handheld computer, the operating system  may be iOS for operating certain devices from Apple Inc., PalmOS for devices from Palm Computing, Inc., Windows Phone 7 from Microsoft Corporation, Android from Google, Inc., Symbian from Nokia Corporation, or BlackBerry OS from Research in Motion Limited. Operating system  essentially controls the execution of other computer programs, such as the GUI object annotation system facilitator , and provides scheduling, input-output control, file and data management, memory management, and communication control and related services.","If computing device  is an IBM PC compatible computer, Wintel computer, or the like, the software in memory  may further include a basic input\/output system (BIOS). The BIOS is a set of essential software routines that initialize and test hardware at startup, start operating system , and support the transfer of data among the hardware devices. The BIOS is stored in ROM so that the BIOS can be executed when computing device  is activated.","The GUI object annotation system facilitator  may be a source program, executable program (object code), script, or any other set of instructions to be performed. The GUI object annotation system facilitator  can be written in an object-oriented programming language or other type of programming language, such as, for example, Java, C, C++, C#, Visual Basic, Visual Basic .NET, Python, Ruby, or ColdFusion. Components of the system facilitator  may also be written in a proprietary language developed to interact with these known languages.","I\/O device  may include input devices such as a keyboard, a mouse, a scanner, a microphone, a touch screen, a bar code reader, or an infra-red reader. It may also include output devices such as a printer, a video display, an audio speaker or headphone port or a projector. I\/O device  may also comprise devices that communicate with inputs or outputs, such as a short-range transceiver (RFID, Bluetooth, etc.), a telephonic interface, a cellular communication port, a router, or other types of network communication equipment. I\/O device  may be internal to computing device , or may be external and connected wirelessly or via connection cable, such as through a universal serial bus port.","When computing device  is in operation, processor  is configured to execute software stored within memory , to communicate data to and from memory , and to generally control operations of computing device  pursuant to the software. The GUI object annotation system facilitator  and operating system , in whole or in part, may be read by processor , buffered within processor , and then executed.","In the context of this document, a \u201ccomputer-readable medium\u201d may be any means that can store, communicate, propagate, or transport data objects for use by or in connection with the GUI object annotation system . The computer readable medium may be for example, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, propagation medium, or any other device with similar functionality. More specific examples (a non-exhaustive list) of the computer-readable medium would include the following: an electrical connection (electronic) having one or more wires, a random access memory (RAM) (electronic), a read-only memory (ROM) (electronic), an erasable programmable read-only memory (EPROM, EEPROM, or Flash memory) (electronic), an optical fiber (optical), and a portable compact disc read-only memory (CDROM) (optical). Note that the computer-readable medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, via, for instance, optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and stored in a computer memory. The GUI object annotation system facilitator  can be embodied in any type of computer-readable medium for use by or in connection with an instruction execution system or apparatus, such as a computer.","For purposes of connecting to other computing devices, computing device  is equipped with network communication equipment and circuitry. In a preferred embodiment, the network communication equipment includes a network card such as an Ethernet card, or a wireless connection card. In a preferred network environment, each of the plurality of computing devices  on the network is configured to use the Internet protocol suite (TCP\/IP) to communicate with one another. It will be understood, however, that a variety of network protocols could also be employed, such as IEEE 802.11 Wi-Fi, address resolution protocol ARP, spanning-tree protocol STP, or fiber-distributed data interface FDDI. It will also be understood that while a preferred embodiment of the present invention is for each computing device  to have a broadband or wireless connection to the Internet (such as DSL, Cable, Wireless, T-1, T-3, OC3 or satellite, etc.), the principles of the present invention are also practicable with a dialup connection through a standard modem or other connection means. Wireless connections using infrared and radio frequency networks are also contemplated.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 3"],"b":["100","210","220","230","230","325","220","200","210","210","325","200","205"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 4"],"b":["400","210","230","400","412","412","412","412","400","402","404","406","408","410","414"]},"GUI objects may be categorized as including unannotated GUI objects, candidate GUI objects, redundant GUI objects, and self-described GUI objects. An unannotated GUI object can include a GUI object that may be uniquely identified by creating an annotation through use of the present invention. The annotation for an unannotated GUI object may be used, for example, by non-technical users to assist them in creating test scripts or documentation of a GUI. A candidate GUI object may include a GUI object that contains a text string, such as static text, labels, constants, and read-only edit windows. Candidate GUI objects can be used as the basis for creating an annotation for an unannotated GUI object. A maximum text length may be set when determining candidate GUI objects so that descriptive paragraphs are not considered a candidate GUI object. A redundant GUI object may include a GUI object that is used to control the layout of the GUI, such as a pane. Redundant GUI objects are typically not apparent to the user of the GUI and do not need an annotation. A self-described GUI object may include a GUI object that contains sufficient textual content to create an annotation without reference to candidate GUI objects. Self-described GUI objects may include, for example, a push button with a text caption, a radio button with a text caption, menus, and menu items.","An embodiment of a process  is shown in  for creating annotations for GUI objects in a GUI. The GUI object annotation system application  can process a GUI of a GUI application  using the process  to result in the creation and assignment of unique annotations for unannotated GUI objects and self-described GUI objects. These GUI objects can subsequently be referred to in a test script or in documentation by the annotation assigned to the GUI object. For example, a text box GUI object with a nearby caption of \u201cAge\u201d could have the annotation \u201cAge\u201d assigned to it. The text box GUI object may then be referred to as \u201cAge\u201d and provided with a varying input in a test script. As another example, a push button with a caption of \u201cLast Name\u201d could have the annotation \u201cLast Name\u201d assigned to it. The push button may then be referred to as \u201cLast Name\u201d in documentation.","At step , each GUI object in the GUI, properties of the GUI objects, and containers of the GUI can be extracted. As described above, a GUI may contain one or more containers, each of which includes one or more GUI objects. The GUI objects may include unannotated GUI objects that need annotation, candidate GUI objects that can serve as the basis for annotations for unannotated GUI objects, redundant GUI objects that do not need annotation, and self-described GUI objects that have sufficient textual content allowing annotation without reference to candidate GUI objects. The extraction performed at step  may result in a hierarchical list of GUI objects, including the containers and GUI objects within each of the containers, and a role, a descriptor, a location, and a bounding rectangle for each of the GUI objects. Each of the containers and the GUI objects can exist in a parent\/child relationship with one another. In particular, a container or a GUI object has a parent GUI object, except for the top-level container, and a GUI object may or may not have a child container or GUI object. The hierarchical list of GUI objects may assist in determining candidate GUI objects by limiting a search around a particular GUI object that needs to be annotated.","Each GUI object will have a role assigned to it during the extraction performed at step . The role of a GUI object describes the purpose and function of the GUI object in the GUI. Roles may be defined by an application programming interface (API), such as Microsoft Active Accessibility, or other APIs. A role may include, for example, an alert, an animation, an application, a border, a caret, a cell, a character, a chart, a check box, a client, a clock, a column, a column header, a combo box, a cursor, a diagram, a dial, a dialog box, a document, a drop list, an equation, a graphic, a grid expansion button, a grip, a grouping, a help balloon, a hotkey field, an indicator, an IP address box, a link, a list box, a list expansion button, a list item, a menu bar, a menu expansion button, a menu item, an outline, an outline control button, an outline item, a page tab, a page tab list, a pane, a popup menu, a progress bar, a property page, a push button, a radio button, a row, a row header, a scroll bar, a separator, a slider, a sound, a spin box, a split button, static text, a status bar, a table, text, a toolbar, a tooltip, a title bar, unknown, whitespace, and a window. Other roles may include roles exposed by other technologies, such as Java, and may include a date\/time representation, a division, a document object model list item, a document object model table item, a document object model element, a PDF, and a document object model. The role extracted for an unannotated GUI object can be used later in the process  to determine whether a nearby candidate GUI object should serve as the basis for an annotation for the unannotated GUI object.","The descriptor of a GUI object can include a caption, description, or value of the GUI object, depending on the role of the GUI object. For example, a push button  in  may have the descriptor \u201cClear\u201d. As another example, static text  may have the descriptor \u201cBranch\u201d. The location and bounding rectangle of a GUI object will describe the position of the GUI object in the GUI. An X-Y coordinate can specify the location of the GUI object's upper left corner relative to the upper left corner of the GUI or container. The GUI object can also be specified in relation to other GUI objects or other origins in the GUI or container. The bounding rectangle can specify the boundaries of the GUI object. The location and bounding rectangle can be specified in pixel units or other appropriate units. For example, a text box whose upper left corner is at 20 pixels right and 30 pixels down from the upper left corner of the GUI can have its location specified as (20, 30). If the text box has a size of 40 pixels wide by 15 pixels high, then its bounding rectangle can be specified as (40, 15).","The particular method of extraction performed at step  may vary depending on the operating environment that the GUI application  is executing on or the technology which the GUI application  is built. Methods of extraction can include Microsoft Active Accessibility, Microsoft UI Automation for .Net and Silverlight applications, IBM Enhanced High Level Language Application Program Interface (EHLLAPI) for IBM 3270 and IBM 5250 data streams, SAP Scripting Interface for SAP applications rendered without a browser, IAccessible2 for Mozilla Firefox browser, Java Accessibility Bridge for Java applications, and Microsoft Windows 32-bit Application Program Interface (API) for Microsoft Windows 32-bit applications.","As an example, extraction of GUI objects from a Microsoft Windows application at step  can use functions and constants of the Microsoft Windows 32-bit API. First, the EnumWindows function can be used to produce a list of top level windows and their handles from the desktop of the computer being analyzed. Next, the caption of each top level window can be retrieved using the GetWindowText function. The captions can be presented as a list so that a user can select which GUI application to perform extraction on. A list of child windows of the selected GUI application can be obtained using the EnumChildWindows function. For each child window, a class can be created to hold the child window and the properties of the window, including the class, location and size, visibility, and handle of the parent window, using the GetClassName, GetWindowPlacement, IsWindowVisible, and GetParent functions, respectively.","The GUI objects in each window can be retrieved by calling functions in the Microsoft Windows 32-bit API or by sending a Window Message to the window handle of the GUI object, depending on the class being analyzed. For example, if the class is WindowsForm*STATIC*, the GetWindowTextLength function can be called to determine the length of text available, followed by calling the GetWindowText function to retrieve the text string up to the length of the text found by the previous function. A role of static text can be assigned to the GUI object. As another example, if the class is WindowsForm*BUTTON*, the GetWindowTextLength function determines the length of text available, and the GetWindowText function retrieves the text string up to the length of the text found by the previous function. The GUI object in this example can be assigned a role of push button. As a further example, if the class is WindowsForm*EDIT* (single line), then the SendMessage function can be called with a Message ID of WM_GETTEXTLENGTH to determine the length of text available. The SendMessage function can then be called with a Message ID of WM_GETTEXT to retrieve the text string up to the length of the text found by the previous function. The GUI object in this example can be assigned the role of text.","Following extraction of the GUI objects, properties, and containers at step , the process  continues to step  to select a container for processing. If more than one container was extracted from the GUI at step , then each container will be processed in turn by the process . A class for the selected container may be created, such as by using a Dictionary data structure in the C# programming language, for example. At step , the unannotated GUI objects in the selected container may be sorted by their position in the GUI, or alternately, by their position in the selected container. The sorted list of unannotated GUI objects excludes redundant GUI objects and self-described GUI objects, both of which do not need annotations created for them. At step , the candidate GUI objects in the selected container may be sorted by their position in the GUI, or alternately, by their position in the selected container. The sorting of the unannotated GUI objects and candidate GUI objects at steps  and , respectively, may be in order of left to right, top to bottom, and\/or other orderings. The sorted lists of steps  and  may be implemented in a SortedList data structure in the C# programming language, for example.","A GUI object in the selected container may be selected for processing at step . An unannotated GUI object from the sorted list of unannotated GUI objects, a redundant GUI object, or a self-described GUI object may be selected for processing at step . If more than one GUI object is within the selected container, then each GUI object will be processed in turn by the process . At step , it is determined whether the selected GUI object is a redundant GUI object that does not need an annotation. If the selected GUI object is a redundant GUI object, then the process  continues to step  to determine whether there are remaining GUI objects to process. If the selected GUI object is not a redundant GUI object at step , then the process  continues to step  to determine whether the selected GUI object is a self-described GUI object. If the selected GUI object is a self-described GUI object, then at step , an annotation can be created and assigned for the self-described GUI object based on the textual content present within the self-described GUI object itself. An embodiment of step  in the process  is discussed in more detail below in reference to .","If the selected GUI object is not a self-described GUI object at step , then the process  continues to step . At step , it is determined whether the role of the selected GUI object is permitted to be annotated, based on user or default options. At this point in the process , the selected GUI object can be presumed to be an unannotated GUI object because redundant and self-described GUI objects have already been processed at steps  and , respectively. A user can set which roles of GUI objects are permitted to be annotated by the process . Alternately, the user can set which roles of GUI objects are not permitted to be annotated by the process . If the unannotated GUI object is not permitted to be annotated, then the process  continues to step  to determine whether there are remaining GUI objects to process. However, if the unannotated GUI object is permitted to be annotated at step , then the process  continues to step .","At step , one or more nearby candidate GUI objects are determined that are in the vicinity of the unannotated GUI object being processed. The determination of the nearby candidate GUI objects can be based on the location and bounding rectangle of the unannotated GUI object, the location and bounding rectangle of the candidate GUI objects, and a precedence criteria of the unannotated GUI object. The precedence criteria can be set by the user to denote a ranking of position preferences of candidate GUI objects relative to the unannotated GUI object being processed. The position preference may be set for all unannotated GUI objects of a certain role and\/or for individual unannotated GUI objects. The position preferences may include near left, left, left and above, left and below, above, below, near right, right, right and above, or right and below. For example, if the precedence criteria includes position preferences for left, above, and left and below, then candidate GUI objects that are in the vicinity of the unannotated GUI object and that are left, above, and left and below of the unannotated GUI object will be determined at step . In addition, the user can set a vertical and\/or horizontal search range about the unannotated GUI object in order to limit the search for candidate GUI objects. Setting a search range may optimize the performance of the process  in the case when a large number of potential candidate GUI objects are present in a GUI. In one embodiment, if no search range is set, then all candidate GUI objects in the selected container will be considered.","The best candidate GUI object can be determined from the nearby candidate GUI objects at step , based on the precedence criteria of the unannotated GUI object being processed. The text string in the best candidate GUI object can be the basis for the annotation for the unannotated GUI object. The nearby candidate GUI object that matches the position preference may be selected as the best candidate GUI object at step . If there is more than one nearby candidate GUI object that matches the position preference, then the nearby candidate GUI object that is closest to the unannotated GUI object may be selected as the best candidate GUI object at step . At step , an annotation based on the best candidate GUI object is assigned to the unannotated GUI object. An embodiment of step  in the process  is discussed in more detail below in reference to .","Following annotation of the unannotated GUI object, the process  continues to step . At step , it can be determined whether there are remaining GUI objects to process in the selected container. Step  is also performed, as described above, after a redundant GUI object is processed or if the role of a particular GUI object is not set to be annotated. If GUI objects remain to be processed at step , then the process  returns to step  to select another GUI object to process. However, if no GUI objects remain to be processed at step , then at step , it is determined whether there are remaining containers to be processed. If there are remaining containers to be processed at step , then the process  returns to step  to select another container to process. However, if no containers remain to be processed at step , then the process  is complete.","An embodiment of a process  for annotating GUI objects is shown in . The process  may be implemented when creating an annotation for a self-described GUI object or creating an annotation based on a candidate GUI object to an unannotated GUI object. At step , it is determined whether the GUI object having an annotation created is a self-described GUI object. If the GUI object is a self-described GUI object, the process  continues to step  to determine annotation options, which is described in further detail below. If the GUI object is not a self-described GUI object, it can be presumed that the GUI object having an annotation created is an unannotated GUI object and the process  continues to step .","At step , it is determined whether a best candidate GUI object was selected at step  for the unannotated GUI object. A best candidate GUI object may not have been selected if there were no candidate GUI objects that met the search range, role, and\/or precedence criteria requirements, for example. If a best candidate GUI object was not selected, then at step , a technical annotation will be created for the unannotated GUI object instead of being based on a best candidate GUI object. The technical annotation may include information based on the role of the unannotated GUI object and a unique count for duplicate technical annotations within the role. In one embodiment, a technical annotation may be created for the unannotated GUI object even if an annotation has been created based on a best candidate GUI object. However, if a best candidate GUI object was selected at step , then the process  continues to step .","At step , annotation options can be retrieved that may be defaults or may have been set by a user. The annotation options can control how the annotation for the unannotated GUI object is created from the text string of the best candidate GUI object or from the text string attached to the self-described GUI object. Such options may include specifying a number of words to extract from the text string, specifying whether to extract leading words or trailing words of the text string, specifying whether to include or remove specific numbers, letters, and\/or special characters from the text string, specifying a regular expression to match portions of the text string for the annotation, and other options.","After retrieving the annotation options, at step , text can be extracted from the text string in the best candidate GUI object or self-described GUI object for the annotation that is to be assigned to the unannotated GUI object. In the case of a self-described GUI object, the extraction of the text from the text string is from the textual content present in the self-described GUI object itself. The extraction of the text from the text string can be based on the annotation options that were retrieved at step . If one of the annotation options specifies removing specific characters from the text string, the extracted text at step  may result in a reduced text string or an empty string. At step , the extracted text is examined to determine whether it is an empty string. An empty string may occur, for example, if unwanted characters, such as specific numbers, letters, or special characters, were removed from the text string based on an annotation option and if those unwanted characters comprised the entire extracted text. If the extracted text is an empty string at step , then the unwanted characters are re-included in the extracted text at step  so that the annotation will not be an empty string.","Following inclusion of the unwanted characters at step  or if the extracted text is not an empty string at step , it is determined at step  whether the extracted text is a duplicate of an existing annotation for another GUI object. The existing annotation may be for a GUI object with the same or a different role as the unannotated GUI object being processed. If the extracted text is a duplicate of an existing annotation, then a unique index may be assigned to the unannotated GUI object being processed at step . The unique index may be an incremented number that is assigned for GUI objects that have the same annotation and that have the same role. After the unique index is assigned, the annotation is created and assigned at step . The annotation including the extracted text is also created and assigned at step , if the extracted text is not determined to be a duplicate annotation at step .","An example of the results of the process  for creating annotations for GUI objects is detailed with reference to , which includes the exemplary GUI  shown in . In this example, options have been set to control the determination of nearby candidate GUI objects and the extraction of text from the text string of candidate GUI objects and self-described GUI objects for annotations. For the determination of nearby candidate GUI objects, the options that have been set include a vertical search range of 50 pixels; roles of GUI objects not to be annotated including client, table, row, and cell; and precedence criteria for graphic GUI objects and other GUI objects. The precedence criteria for the graphic GUI objects include position preferences of right, below, and below and right. The precedence criteria for other GUI objects include position preferences of left, above, above and left, right, and above and right. For the extraction of text from a text string, the options that have been set include that the number of words to include in the annotation is two, and that the words to include in the annotation are leading words of the text string. For purposes of clarity, the exemplary annotations described below are limited to a subset of the GUI objects in GUI .","The graphic  can have an annotation of \u201cOrder Entry\u201d. The \u201cOrder Entry\u201d annotation can be created based on the candidate GUI object  with static text of \u201cOrder Entry Header Details\u201d. The first two words of the text can be used for the annotation because of the annotation options that two of the leading words should be extracted from the text string of the best candidate GUI object. Also, because the precedence criteria for a graphic GUI object includes a first position preference of right of the graphic GUI object, the candidate GUI object  is selected as the best candidate GUI object for the annotation of the graphic . Other candidate GUI objects in the vicinity of the graphic  that are left of the graphic , for example, would not have been selected as the nearby candidate GUI objects or as the best candidate GUI object.","The combo box  can have an annotation of \u201cUnit Id\u201d. The \u201cUnit Id\u201d annotation can be created based on the candidate GUI object  with static text of \u201cUnit Id\u201d. Due to the precedence criteria for non-graphic GUI objects including a first position preference of left of the GUI object, the candidate GUI object  is selected as the best candidate GUI object for the annotation of combo box . Similarly, the text box  can have an annotation of \u201cCustomer Type\u201d due to the candidate GUI object  with static text of \u201cCustomer Type\u201d, and the push button  can have an annotation of \u201cCustomer\u201d because of the candidate GUI object  with static text of \u201cCustomer\u201d.","The graphic , combo box , text box , and push button  can be considered unannotated GUI objects in the context of the process , and are annotated based on text strings of the best candidate GUI objects that are nearby. In contrast, the static text  and , and the push button  can be considered self-described GUI objects that have sufficient textual content within their properties to be annotated without needing to find and select a best candidate GUI object. In particular, the static text  can be annotated with \u201cBranch\u201d and the static text  can be annotated with \u201cCustomer\u201d because they are self-described GUI objects. The static text  can also be assigned a unique index of 2 to differentiate the static text  from the push button  that also has an annotation of \u201cCustomer\u201d. The push button  can have an annotation of \u201cForward\u201d because the text \u201cForward\u201d is within the push button  itself.","Any process descriptions or blocks in figures should be understood as representing modules, segments, or portions of code which include one or more executable instructions for implementing specific logical functions or steps in the process, and alternate implementations are included within the scope of the embodiments of the present invention in which functions may be executed out of order from that shown or discussed, including substantially concurrently or in reverse order, depending on the functionality involved, as would be understood by those having ordinary skill in the art.","It should be emphasized that the above-described embodiments of the present invention, particularly, any \u201cpreferred\u201d embodiments, are possible examples of implementations, merely set forth for a clear understanding of the principles of the invention. Many variations and modifications may be made to the above-described embodiment(s) of the invention without substantially departing from the spirit and principles of the invention. All such modifications are intended to be included herein within the scope of this disclosure and the present invention and protected by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 7","FIG. 4"]}]},"DETDESC":[{},{}]}
