---
title: Method and system for monitoring encrypted data transmissions
abstract: A method for efficiently decrypting asymmetric SSL pre-master keys is divided into a key agent component that runs in user mode, and an SSL driver running in kernel mode. The key agent can take advantage of multiple threads for decoding keys in a multi-processor environment, while the SSL driver handles the task of symmetric decryption of the SSL encrypted data stream. The method is of advantage in applications such as firewalls with deep packet inspection in which all encrypted data traffic passing through the firewall must be decrypted for inspection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898451&OS=08898451&RS=08898451
owner: Trend Micro Incorporated
number: 08898451
owner_city: Tokyo
owner_country: JP
publication_date: 20130821
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE EMBODIMENTS OF THE INVENTION"],"p":["The present application is a Continuation application of U.S. application Ser. No. 11\/766,976 filed on Jun. 22, 2007, entitled \u201cMETHOD AND SYSTEM FOR MONITORING ENCRYPTED DATA TRANSMISSION\u201d, the entire contents of all applications and issued patent being incorporated herein by reference.","The present invention relates to the decryption of encrypted data packets, specifically for the purpose of monitoring the packet payload contents.","The encryption of data that is transmitted through the Internet has become common place. Data messages may be encoded by a protocol known as SSL (Secure Socket Layer) which is intended to render the encoded data unintelligible to any recipient or eavesdropper, unless they are in possession of the key (decryption key) necessary for decoding the data. SSL was developed by Netscape Communications Corporation for securing data transmission in commercial transactions on the Internet. Using public-key cryptography, SSL provides server authentication, data encryption, and data integrity for client\/server communications.","The SSL protocol has evolved over the years, and has become standardized, the term \u201cSSL\u201d being generally used to refer to any version of the protocol. The specification of a recent version of SSL may be found in the IETF (Internet Engineering Task Force) document RFC (Request For Comment) 4346, entitled \u201cThe Transport Layer Security (TLS) Protocol Version 1.1\u201d. The TLS protocol is thus a recent specification of the SSL protocol.","Briefly, the SSL includes a handshake protocol for setting up an encrypted session, methods for the authentication of messages, and methods for encrypting\/decrypting the data.","The Internet also has become a place over which unwanted, potentially harmful, and otherwise unsolicited data traffic is transmitted. This phenomenon has given rise to an industry providing various tools for \u201cdefending\u201d networks, servers and computer work stations against such traffic, while allowing legitimate traffic to pass unhindered. A \u201cfirewall\u201d is typically software that is installed in a network node; traffic passing through a firewall is inspected by inspecting each packet and applying a set of rules to determine whether the packet should pass or be stopped. A firewall may be implemented in a networked computer such as a server or a work station, as well as in dedicated nodes such as network access nodes and routers.","The functionality of a firewall may range from simple address filtering in which packets with predetermined source addresses or ranges of addresses are discarded, to more complex processes which include: discriminating traffic on the basis of the protocol, for example ICMP (Internet Control Message Protocol), UDP (User Datagram Protocol), TCP (Transmission Control Protocol), etc; filtering based on source and destination ports of each packet; tracking the connection state to determine protocol violations; and the like. Even more sophisticated filtering may be done on the basis of the message content itself, so called \u201cdeep\u201d packet inspection.","An added complication arises when the firewall is also required to guard against, and identify for discarding, unwanted messages that are encrypted. In the case of a network node that is flooded with a large amount of unwanted messages that are encrypted, it is very important to ensure that the filtering of such messages is performed efficiently and expeditiously. When deep packet inspection is required, each session comprising a stream of ultimately perhaps unwanted packets must first be set up according to the specified protocol, and packets decrypted correctly before a decision regarding the session's validity can be made.","While the specification, as well as much of the necessary software to handle SSL, are publicly available, the existing software is designed to deal with the traditional case of server to client communication, but is inadequate to process unwanted traffic efficiently enough to be used in a firewall that includes deep packet inspection.","Consequently there is a need for the development of improved techniques to efficiently enable monitoring the packet payload contents of encrypted data traffic, for example, for the purpose of monitoring and filtering of unwanted data traffic.","It is therefore an objective of the invention to develop a method and system that can be used to enable the decryption of encrypted data packets, specifically for the purpose of monitoring the packet payload contents.","According to one aspect of the invention there is provided a method for decrypting a Secure Socket Layer (SSL) pre-master key in a computing environment having a user mode and a kernel mode, comprising steps of:\n\n","The step (a) of the method comprises:\n\n","The step (b) of the method comprises:\n\n","In the embodiment of the invention, the steps (ii) and (iii) of the method comprise selecting one of a plurality of key decryption threads for decrypting different decryption request records.","Conveniently, the step (c) of the method comprises sending an error response to the driver indicating that the agent request queue is full; sending an error response to the driver indicating that the private key is not available; and sending an error response to the driver indicating that the decryption did not succeed.","According to another aspect of the present invention there is provided a method of inspecting an encrypted packet in a computing environment having a user mode and a kernel mode, the method comprising the steps of\n\n","The method further comprises the step (5) repeating the steps (3) and (4) until the encrypted session is terminated.","The method further comprises terminating the encrypted session based on the content of the decrypted packets.","According to yet another aspect of the invention there is provided a method of initiating a Secure Socket Layer (SSL) session using a handshake protocol, in a computing environment having a user mode and a kernel mode, the method comprising steps of:\n\n","In the method described above, the step of decrypting is performed in one of a plurality of decryption threads of the key agent.","According to one more aspect of the invention there is provided a system for decrypting a Secure Socket Layer (SSL) pre-master key in a computing environment having a user mode and a kernel mode, comprising a memory comprising the following components:\n\n","In the system described above, the driver comprises:\n\n","In the system described above, the key agent further comprises:\n\n","According to one more aspect of the invention there is provided a system for inspecting an encrypted packet in a computing environment having a user mode and a kernel mode, the system comprising a memory including:\n\n","The passive SSL engine further comprises means for continuing to decrypt packets and to inspect the decrypted packets until the encrypted session is terminated.","The system further comprises means for terminating the encrypted session based on the content of the decrypted packets.","According to yet one more aspect of the present invention, there is provided a system for initiating a Secure Socket Layer (SSL) session using a handshake protocol, in a computing environment having a user mode and a kernel mode, the system comprising a memory including:\n\n","The progress of a typical SSL session may be divided into two phases, a handshake phase for setting up the session, and a stream decryption phase. In the handshake phase, public key technology is used to derive secret session keys to be used in the decryption of the encrypted SSL data streams.","The cryptographic operations that deal with the public keys will be referred to collectively as \u201casymmetric cryptographic operations\u201d because their efficacy is based on the public key premise under which it is \u201ceasy\u201d to encrypt data using the public key, but for all practical purposes impossible to decrypt unless one has the private key. The computational effort to perform the asymmetrical cryptographic operations is high due to the use of very large keys which are typically 128 of bytes or larger. Because the asymmetrical cryptographic operations are only used in setting up a cryptographic SSL session, the computational expense is normally accepted, but even so, hardware accelerators and key stores are sometimes used to offload the central processor.","A purpose of the SSL handshake phase is for the two ends of the connection, that is a client and a server, to negotiate a secret pre-master key. From the pre-master, a master key (a \u201cmaster secret\u201d in the terminology of [1]) is derived with which the subsequent SSL data stream is encoded at one end of the connection and decoded at the other. The same key is used in both operations, which are referred as \u201csymmetric cryptographic operations\u201d. The pre-master key and the master key are typically much shorter, than the public keys, and the symmetric cryptographic operations are very efficiently performed by modern processors.","Network protocol operations are commonly performed by the kernel of modern operating systems that follow the UNIX\u2122 model, such as Linux\u2122, Mac\u2122 OSX (Object Linking and Embedding Control Extension), and Windows\u2122. The kernel is generally reliable and handles hardware\/software interactions, such as network interfaces. It communicates with application software that normally runs in user space, through software interfaces or APIs (Application Process Interface). Some kernel modules are also referred to as \u201cdrivers\u201d, with a simple API or an Input\/Output Control Interface (IOCTL). Relevant to the present discussion is the fact that context switching between user processes and kernel processes is time consuming, and to allow responsive multi-process operation of the computer system, no process can be allowed to run uninterruptedly for long periods of time.",{"@attributes":{"id":"p-0041","num":"0077"},"figref":"FIG. 1","b":["100","100","100","102","104","106","108"]},"All, much, or only some of the data to be processed by the \u201cDeep Packet Inspection Engine\u201d  may be in the form of encrypted SSL data streams, but only encrypted packets are of interest here. Packets arriving from a network interface  are passed into the \u201cSSL Handshake\u201d  which performs the standard SSL handshake protocol to initiate an encrypted session. The \u201cSSL Driver\u201d  participates in the SSL handshake by receiving key requests  and passing asymmetric encrypted pre-master keys  to the \u201cKey Agent\u201d . The \u201cKey Agent\u201d  performs the compute-intensive operations that are required to decrypt each asymmetric encrypted pre-master key  and sends a corresponding decrypted pre-master key  back to the \u201cSSL Driver\u201d . The \u201cSSL Driver\u201d  then generates a secret master key  from the decrypted pre-master key  according to the standard specification, and sends the secret master key  to the \u201cDeep Packet Inspection Engine\u201d . Details of the SSL handshake including key exchanges are described in the RFC 4346 cited above, only a cursory description being offered here for convenience.","Encrypted SSL data streams are then passed to the \u201cDeep Packet Inspection Engine\u201d  where they may be decrypted using the secret master key  in a standard manner, for analysis including deep packet inspection, in the same way as other (non-SSL) data streams would be analyzed.","With the \u201cDeep Packet Inspection Engine\u201d  and other functionality (not shown) the software package  provides firewall functions such as intrusion detection, including the capability that encrypted data streams be decrypted for inspection before either suppressing or passing the encrypted data stream on to the intended recipient, for example, an HTML server or client application on the same host, or to a local network.","The embodiment of the invention provides offloading the kernel mode from the asymmetric cryptographic operations that are required for deriving secret SSL master keys to be used in the decryption and subsequent inspection of encrypted SSL data streams, as well as the design of the kernel mode driver.","The passive SSL decryption of data streams requires symmetric cryptographic keys, i.e. the master keys that are derived using pre-master keys, which, in turn, are generated with asymmetric cryptographic methods. For reasons such as code size, lengthy decryption times, possible support of third party hardware acceleration, and key stores, in the embodiment of the present invention the asymmetric part of the process is implemented as a user mode software process in the form of the \u201cKey Agent\u201d , coupled to the \u201cSSL Driver\u201d  that is implemented as a kernel mode software process.","Asymmetric decryption is a computationally heavy process that is not well suited for implementation within an operating system kernel mode driver for the following reasons:\n\n","Thus, in the present the invention the asymmetric decryption operations are implemented as a user mode software component (the \u201cKey Agent\u201d ), and the symmetric decryption operations are implemented in an operating system kernel mode driver (the \u201cSSL Driver\u201d ).","This requires that the asymmetrically encrypted key information (i.e. the asymmetric encrypted pre-master key ) is communicated from the kernel mode driver to the user mode software component, and the decrypted key information (i.e. the decrypted pre-master key ) is communicated back from the user mode component (i.e. the \u201cKey Agent\u201d ) to the kernel mode driver (i.e. the \u201cSSL Driver\u201d ).","In this way it is possible to take advantage of facilities such as threading, concurrency, and preemptive symmetric multi-processing (SMP) processing that are available in the user mode of operating systems.","Although the software package  (the Third Brigade \u201cDeep Security Agent\u201d software package) includes of a number of components, only the kernel mode driver (the \u201cSSL Driver\u201d ) and the user mode agent (the \u201cKey Agent\u201d ) and the interaction therebetween are directly of interest with respect to the present invention.","Roles of the \u201cSSL Driver\u201d  include intercepting network traffic at the network transport layer, modifying, inserting, and deleting packets at its discretion based upon well defined rules, thus implementing a network security device.","As indicated earlier, a common method of protecting network data transmitted between hosts is to encrypt the data via the SSL protocol (RFC 4346) at the application layer. In contrast, in order to secure a host against unwanted network intrusion, the Driver component must be able to analyze the raw or unencrypted form of the data.","The \u201cSSL Driver\u201d  implements a Passive SSL Engine, which besides ensuring the validity of the SSL protocol, is also used to decrypt the SSL traffic stream for analysis by the Payload Engine in the \u201cDeep Packet Inspection Engine\u201d . The deep packet inspection is the reason why SSL decryption is required.",{"@attributes":{"id":"p-0055","num":"0093"},"figref":"FIG. 2","b":["200","102","106","202","204","206","208"]},"The \u201cSSL request device\u201d  is a virtual device that is dynamically created to be used by the \u201cKey Agent\u201d  for acquiring the asymmetric encrypted SSL pre-master key(s) ; the \u201cSSL Response Device\u201d  is a virtual device by which the \u201cKey Agent\u201d  communicates the results of the decryption(s), i.e. the decrypted pre-master key , back to the \u201cSSL Driver\u201d . Virtual devices are commonly known software structures used as a convenience to provide a simple interface between the \u201cKey Agent\u201d  and the \u201cSSL Driver\u201d .","The \u201cKey Agent\u201d  opens, and executes a blocking read on the \u201cSSL request device\u201d , unblocking only when the \u201cSSL Driver\u201d  inserts one or more encrypted keys into the \u201cDecryption Request Queue\u201d  associated with the \u201cSSL request device\u201d .","The \u201cSSL State Machine\u201d  monitors the traffic stream (implied, not shown in ) for SSL protocol messages. When triggered by the \u201cClientKeyExchange\u201d handshake message of the SSL protocol (see [1] for protocol details), the \u201cSSL State Machine\u201d  adds encrypted keys into the \u201cDecryption Request Queue\u201d .","The \u201cKey Agent\u201d , when unblocked will read one or more encrypted keys from the \u201cDecryption Request Queue\u201d  through the \u201cSSL Request Device\u201d , i.e. the \u201casymmetric encrypted pre-master key\u201d .","The \u201cKey Agent\u201d  will then attempt to decrypt \u201casymmetric encoded pre-master key\u201d , using a provided asymmetric private key, as described in [1]. In both instances of a successful or an unsuccessful decryption of the \u201casymmetric encrypted pre-master key\u201d , the \u201cKey Agent\u201d  will send a response, that is either the decrypted pre-master key  or an error indicator respectively, into the \u201cSSL Driver\u201d  via the \u201cSSL Response Device\u201d  which makes the decrypted key available to the \u201cSSL State Machine\u201d.","The \u201cKey Agent\u201d  obtains asymmetric encrypted pre-master keys  from the \u201cSSL Driver\u201d . The asymmetric encrypted pre-master keys  are contained in data records known as \u201cdecryption requests\u201d or \u201cdecryption request records\u201d. The methods for passing the decryption requests from the \u201cSSL Driver\u201d  to the \u201cKey Agent\u201d  are described in more detail in the following , , and .",{"@attributes":{"id":"p-0062","num":"0100"},"figref":"FIG. 3","b":["300","208","106","208","300","106","202","204","206","208"],"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":{"@attributes":{"id":"ul0027-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":["\u201cAnalyze SSL handshake protocol\u201d ;","\u201cSSL ClientKeyExchange?\u201d  (a decision step);","\u201cAdd Encrypted Pre-master key to Request Queue\u201d ;","and","\u201cPass the decrypted pre-master key\u201d ."]}}}},"The \u201cSSL State Machine\u201d  further includes a \u201cPassive SSL Engine\u201d  that includes common SSL protocol and decryption functions that are outside the scope of the invention.","The \u201cPassive SSL Engine\u201d  of the \u201cSSL State Machine\u201d  monitors the traffic stream for SSL protocol messages and passes such messages to the step  \u201cAnalyze SSL handshake protocol\u201d. Each SSL protocol message is compared with the ClientKeyExchange message type. If it is not a ClientKeyExchange message, as indicated by the decision step  \u201cSSL ClientKeyExchange?\u201d determination \u201cNo\u201d, the analysis of the SSL Handshake protocol continues and loops back to the step  \u201cAnalyze SSL handshake protocol\u201d, otherwise the step  \u201cAdd Encrypted Pre-master key to Request Queue\u201d is executed which adds the encrypted keys of the ClientKeyExchange message into the \u201cDecryption Request Queue\u201d . The encrypted keys (i.e. the asymmetric encrypted pre-master keys) that are queued in the \u201cDecryption Request Queue\u201d  are then available to be passed through the \u201cSSL Request Device\u201d  to the \u201cKey Agent\u201d  as described above. After a successful decryption of the encrypted pre-master keys, the decrypted pre-master key is forwarded from the \u201cKey Agent\u201d  to the \u201cSSL State Machine\u201d  via the \u201cSSL Response Device\u201d , and to the \u201cPassive SSL Engine\u201d  in the step \u201cPass the decrypted pre-master key\u201d . Subsequent processing of the decrypted pre-master key in the \u201cPassive SSL Engine\u201d  is beyond the scope of the present invention.",{"@attributes":{"id":"p-0065","num":"0108"},"figref":"FIG. 4","b":["400","106","102","402","404","406"]},"Key decryption requests, i.e. the asymmetric encrypted pre-master keys , are passed from the \u201cSSL Driver\u201d  to the \u201cDecryption Request Reader Thread\u201d  of the \u201cKey Agent\u201d . The received encrypted pre-master keys are stored in the \u201cAgent Request Queue\u201d  by the \u201cDecryption Request Reader Thread\u201d . Concurrently, \u201cKey Decryption Threads\u201d  service the \u201cAgent Request Queue\u201d , decrypt the pre-master keys, and forward the decrypted pre-master key  back to the \u201cSSL Driver\u201d . It may be noted that the \u201cAgent Request Queue\u201d  has a finite capacity, and it is possible that the queue becomes full because the \u201cKey Agent\u201d  may have been preempted by other tasks and not been able to service the queue in time before additional decryption requests arrive. In this case an \u201cError Response\u201d  is transmitted from the \u201cDecryption Request Reader Thread\u201d  to the \u201cSSL Driver\u201d  to indicate that a request could not be stored. In the preferred embodiment of the invention, the \u201cSSL Driver\u201d  then cancels the corresponding attempt to set up an SSL session.","Flow charts of the \u201cDecryption Request Reader Thread\u201d  and the \u201cKey Decryption Threads\u201d  are shown in the following  respectively. The \u201cKey Agent\u201d  may operate in a multi-thread environment in order to take advantage of multi-CPU machines and so achieve higher performance than a single-thread design.",{"@attributes":{"id":"p-0068","num":"0111"},"figref":"FIG. 5","b":["500","406","406","500","202","204","402"]},"The \u201cDecryption Request Reader Thread\u201d  includes functionality to perform steps of:\n\n","The decryption request records which include the asymmetric encrypted pre-master keys  are received from the \u201cSSL Request Device\u201d  of the \u201cSSL Driver\u201d  (), in the step  \u201cRead decryption request records from driver\u201d. The next step is  \u201cIs Queue full?\u201d in which the state of the \u201cAgent Request Queue\u201d  is determined. If the queue is full (\u201cYes\u201d from the step  \u201cIs Queue full?\u201d), the step  \u201cSend error response to driver\u201d is executed in which the \u201cError Response\u201d  is sent to the \u201cSSL Response Device\u201d  of the \u201cSSL Driver\u201d , and execution flow returns to the step  \u201cRead decryption request records from driver\u201d. As long as the queue is full, additional decryption requests continue to be denied, until such time as room becomes available in the queue, i.e. until the \u201cKey Decryption Threads\u201d  have serviced the queue and removed at least one decryption request record (see  below).","If the queue is not full (\u201cNo\u201d from the step  \u201cIs Queue full?\u201d), the step  \u201cAdd decryption request record to queue\u201d is executed in which the decryption request record obtained in the step  \u201cRead decryption request records from driver\u201d is put into the \u201cAgent Request Queue\u201d .",{"@attributes":{"id":"p-0072","num":"0119"},"figref":"FIG. 6","b":["600","404","404","600","204","402"]},"The \u201cKey Decryption Thread\u201d  includes functionality to perform steps of:\n\n","Execution of the step  \u201cRemove one decryption request record from queue\u201d is performed whenever a decryption request is available in the \u201cAgent Request Queue\u201d , otherwise the thread sleeps until it is awakened by the operating system in a standard manner. The methods by which different computer operating systems handle threads vary, and are outside the scope of the present invention. It may be recalled that decryption requests which include encrypted pre-master keys  were put into this queue in the step  \u201cAdd decryption request record to queue\u201d of the \u201cDecryption Request Reader Thread\u201d , ().","According to the SSL standard, decryption can only be performed when the appropriate private key is available, see the RFC 4346 cited above. Following removal of the decryption request from the queue in the step , a search and determination is made in the following step  \u201cIs private key available?\u201d. If the required private key is not available (exit \u201cNo\u201d from the step  \u201cIs private key available?\u201d) execution is directed to the step  \u201cSend error response to driver\u201d in which the error response  is sent to the \u201cSSL Response Device\u201d  (in the \u201cSSL Driver\u201d , ). After the step  \u201cSend error response to driver\u201d execution returns to the step  \u201cRemove one decryption request record from queue\u201d in which the thread fetches the next decryption request if one is available.","The determination of \u201cIs private key available\u201d may be handled as a configuration issue. In the preferred embodiment of the invention, the agent and driver are configured via user-supplied configuration data which specifies which SSL key to use for a particular TCP port on the local machine.","If the required private key is available (exit \u201cYes\u201d from the step  \u201cIs private key available?\u201d) execution continues with the step  \u201cDecrypt SSL pre-master key using standard APIs\u201d in which the pre-master key is computed according to standard practice, i.e. by calling routines in a decryption library using standard APIs (Application Programming Interfaces). At this stage, decryption may fail due to any of a number of reasons. In the next step  \u201cDid decryption succeed?\u201d such a determination is made. If decryption did not succeed (exit \u201cNo\u201d from the step  \u201cDid decryption succeed?\u201d) execution is directed to the step  \u201cSend error response to driver\u201d in which the error response  is sent to the \u201cSSL Response Device\u201d . If decryption did succeed (exit \u201cYes\u201d from the step  \u201cDid decryption succeed?\u201d) execution continues with the step  \u201cSend pre-master key to driver\u201d in which the pre-master key  is sent to the \u201cSSL Response Device\u201d  of the \u201cSSL Driver\u201d  (). After the step  \u201cSend pre-master key to driver\u201d execution returns to the step  \u201cRemove one decryption request record from queue\u201d in which the thread fetches the next decryption request if one is available.","Multiple instances of \u201cKey Decryption Threads\u201d  may be active simultaneously to advantage (for example in a multiprocessor host), each thread to take a decryption record off the shared \u201cAgent Request Queue\u201d  to decrypt the included asymmetric encrypted pre-master key  into the decrypted pre-master key  to be sent to the \u201cSSL Response Device\u201d , using the steps outlined in the . An advantage of the present invention with multiple instances of \u201cKey Decryption Threads\u201d , is due to the fact that the high computational effort to decrypt a pre-master key, an effort that is considerably higher than the comparatively trivial computational effort required to receive and queue the key, can be performed efficiently by threads potentially running in parallel in multiple processors or multiple processor cores.","The system for decrypting a Secure Socket Layer (SSL) pre-master key in a computing environment having a user mode and a kernel mode of the embodiment of the present invention comprises a computer having a computer readable means in the form, for example, of a memory for storing instructions to cause the computer to perform the steps of the methods of the present invention as described above.","The system and methods of the invention have been devised to efficiently handle the computationally expensive decryption of the pre-master keys that are used in the SSL session initiation, thus enabling the subsequent decryption and monitoring of the payload contents of the SSL packet streams.","Although the embodiment of the invention has been described in detail, it will be apparent to one skilled in the art that variations and modifications to the embodiment may be made within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["An embodiment of the invention will now be described, by way of example, with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0031","num":"0067"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0032","num":"0068"},"figref":["FIG. 2","FIG. 1"],"b":["200","102","106","100"]},{"@attributes":{"id":"p-0033","num":"0069"},"figref":["FIG. 3","FIG. 2"],"b":["300","208","106"]},{"@attributes":{"id":"p-0034","num":"0070"},"figref":"FIG. 4","b":["400","106","102"]},{"@attributes":{"id":"p-0035","num":"0071"},"figref":"FIG. 5","b":["500","406","102"]},{"@attributes":{"id":"p-0036","num":"0072"},"figref":"FIG. 6","b":["600","404","102"]}]},"DETDESC":[{},{}]}
