---
title: Systems, methods, and computer-readable media for measuring quality of application programming interfaces
abstract: A system, computer-implemented method, and computer-readable medium for determining the quality of an API includes receiving documentation of the API, determining one or more characteristics of the API based at least in part on the documentation of the API, determining or more measurement values based at least in part on the one or more characteristics of the API, and computing a quality score for the API based at least in part on the one or more measurement values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656365&OS=08656365&RS=08656365
owner: Infosys Limited
number: 08656365
owner_city: Bangalore
owner_country: US
publication_date: 20110901
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["In software engineering, gone are the days when software was usually built from scratch and worked in insolated environments. Open platforms and open systems have become the norm. Interoperability has become the mantra and systems are expected to expose Application Programming Interfaces (\u201cAPIs\u201d) such that they can be used in various contexts by multiple client applications. Moreover, modern software is generally built by assembling various software packages (e.g., libraries, modules, etc.) that may be developed by third parties. This may be especially true in the context of service oriented software. Software may be created principally in the form of modules, with each module characterized by its API. This module based development is exacerbated by the current trend of globally distributed software development.","At its most general, an API can be thought of as a focused representation of the overall functionality of a software module. The representation is focused in the sense that the functionality declared in the API provides a specific set of services for a certain target usage. It would not be uncommon for the same module to have multiple APIs, each intended for a specific use of that module. For the purposes of this disclosure, an API may be whatever the designer of a software module has specified it to be, without any judgment regarding what functionality the API offers. In other words, an API of a system may be a set of methods that are listed in the API documentation for the system.","For example, an interest-calculation module in a financial software system may contain multiple user-directed APIs. There could be an API designed specifically for regular banking applications, another for co-op banking applications, yet another for banking-like financial services provided by mutual-fund operators, and so on. While the basics of interest calculations for all these related applications are likely to be the same, different uses of the software may entail using a method name vocabulary particular to that application. In addition to vocabulary differences, the different APIs for the same module may also differ with regard to the functionality offered.","The central role played by the APIs in modern software engineering makes it all the more important that, to the maximum extent possible, they be easy to comprehend. Ideally, the users of a module\/library need look no further than its API. That is, ideally there should never be a reason to examine the implementation code in a module itself. Unfortunately, the quality of APIs varies significantly. Often a user must carefully study example code, when it is even supplied, before they can figure out how and when to use an API method. Additionally, example code may be poorly written and poorly documented, which may increase the user's level of frustration with an API. As one might expect, such frustrations often translate into reduced productivity when it comes to writing code using such APIs. APIs that are hard to understand, remember, and use are more prone to misuse and may inadvertently introduce subtle, hard to debug bugs in a system. More importantly, low quality APIs discourage reuse of software.","While systems, methods, and computer-readable media are described herein by way of examples and embodiments, those skilled in the art recognize that measuring quality of APIs is not limited to the embodiments or drawings described. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to) rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","As described in the background, it is widely accepted that APIs play a vital role in software development where software is developed by assembling plural software modules and libraries. Developers depend on APIs and their documentation for understanding how and when to use the API methods of a module or library. Given this importance, it may be useful to gauge the quality of an API. However, currently no tools exist for quantitatively measuring the quality of an API. In contrast, those in the business of designing libraries and large systems curently manually examine APIs to get a qualitative feel for the quality of the APIs. The trend in the area has been to lay down generic guidelines for good API design. Given two APIs today, the best one can do to compare the quality of each of the two is to provide subjective judgments based on manual examination. Moreover, in an API with hundreds of API methods, discerning which of these are inconsistent, discerning which of these should have been grouped together, and performing similar analysis is difficult to do manually.","Embodiments disclose methods, systems, and computer-readable media that may quantitatively measure the quality of an API. Embodiments may measure and evaluate the quality of an API from various perspectives according to plural metrics. Embodiments may diagnose flaws in an API and pinpoint structural defects. As used herein, quality of an API may be limited to the structural properties of the method declarations of the API. Structural properties may be, for example, properties of parameter lists, runs of parameters of the same data type, consistency in the data types returned by methods with similar names, consistent grouping of methods of similar functionality, and the like. While an API must obviously function correctly, must be memory efficient, must be secure, and the like to be useful, quality of an API as used herein addresses only the usability and structure of an API. In other words, quality as used in this disclosure may not encompass functional correctness, completeness, memory management, and similar performance-related issues involved in using a set of method declarations in an API.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","110","110"]},"At step , one or more computing devices may determine, based on the API documentation, values that indicate at least one of names of methods of the API, parameters of the methods of the API, functions of methods of the API, and the like. At step , one or more computing device may determine one or more measurement values. The measurement values may include a complexity of the API, a consistency of the parameters of the API, a level of confusion of the API, a logical grouping of methods of the API, a thread-safety characteristic of the API, an exception notification characteristic of the API, and a documentation quality of the API. At step , one or more computing devices may specify a quality score of the API based on the one or more measurement values.","Process flow  may be useful for identifying characteristics of method declarations in an API that may be considered to be sources of frustration for client programmers who whish to interact with the API. These sources of frustration include having methods with similar names returning different types of values, methods with parameter lists containing runs of the same type, methods with long parameter lists, methods with similar looking parameters but inconsistent sequencing of parameter names, numerous methods with nearly identical names, conceptually similar methods grouped separately, methods devoid of a thread-safe indicator, methods using exception throwing classes that are too general with respect to error conditions that result in the respective exceptions, and methods having poor quality API documentation. The following description addresses how process flow  may be useful for pinpointing sources of frustration with the API and for specifying a quality score for the API.","As mentioned earlier, a common source of frustration for client programmers using an API is method name overloading. Method name overloading, often more simply referred to as \u201cmethod overloading\u201d or \u201cfunction overloading,\u201d is a feature common to most object-oriented languages. This allows for the use the same method name for different purposes. That is, a single API may contain multiple methods with the same name but with different types and\/or numbers of parameters. These methods may be locally defined or inherited.","When the overloaded methods return different types, a client programmer using the method must remember the associations between the return types and the method signatures for the different overloadings. For example consider the following two methods defined for the class javax.naming.directory.Attribute in Java 5\u2122.\n\n","The first method add( ) assumes an ordered list of attribute values; this method inserts the attribute value supplied through the second argument at the location specified by the first argument. On the other hand, the second method is based on the assumption that the attribute values are unordered and it appends the attribute value supplied through the only argument at the end of the attribute list. While the first add( ) returns void, the second returns a Boolean value. One can easily imagine how these methods would be a source of confusion for both a client programmer and for someone trying to understand the code in which one or both of these methods is used. Depending on the compiler used, the discrepancy in the return value could even become a source of a hidden bug.","Indeed, the Sun Java\u2122 tutorial on method overloading warns about excessive and inappropriate use of overloading which can make the API code less readable and usable. As the above example illustrates, this is especially the case if different overload definitions have different return types. Of course, there are a few valid exceptions to this guideline. For instance, to emulate generics in languages that do not support it there may exist overloaded methods with different return types. However, this is not a commonly used case of method overloading and in most cases the guideline is applicable.","In some embodiments, step  of process flow  may include determining the extent to which the different overload definitions for the same method name do not return the same type (i.e., determining a method name overload index (\u201cAMNOI\u201d) metric). In such a step , a computing device may let all the overloaded API methods in a given API be partitioned into N disjoint sets.\n\n}\n\nwhere Gis the set of overloaded API methods having the same name. Name(m) and Returns(m) may be functions that return the name and return type, respectively, for a given method m. The set of all methods in the API may be represented by M.\n\n\u00b7Name()=Name()}\n","An API Method Name Overload Index metric for a given overloaded API method set G(AMNOI) may be defined in the following manner:",{"@attributes":{"id":"p-0029","num":"0030"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"ANMNOI","msub":{"mi":["G","j"]}},"mo":"=","mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mrow":{"mo":["\uf603","\uf604"],"mrow":{"mo":["{","}"],"mrow":{"mrow":[{"mi":"Returns","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mi":"m","mo":"\u2208","msub":{"mi":["G","j"]}}],"mo":"\u2758"}}},"mo":"-","mn":"1"},{"mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["G","j"]}},"mo":"-","mn":"1"}]}}}}}},"In the above equation, the set membership discipline ensures that, when Returns(m) is the same for more than one m, there is only one entry in the set {Returns(m)} for all of those m. Therefore, the cardinality of the set {Returns(m)} must equal the total number of distinct return types for the methods in the set G. One may be subtracted from both the numerator and denominator to bound the metric value between zero and one. In the best case, all of the overloaded methods have the same return type, which would cause the numerator to become zero and the AMNOI metric value for Gto become one. In the worst case where each of the overloaded methods has a different return type, the numerator may be equal to the denominator and the value of the AMNOI for Gmay become zero.","AMNOI for the API may be defined as:",{"@attributes":{"id":"p-0032","num":"0033"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"AMNOI","mo":"=","mfrac":{"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"mi":["j","N"],"mo":"="}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"AMNOI","msub":{"mi":["G","j"]}}},"mi":"N"}}}},"br":{}},"Another common source of frustration for client programmers include method declarations in an API that contain several parameters of the same type. It is more difficult for a client programmer to remember which argument goes with what parameter in such cases. For illustration, consider the following method declaration for the class TPASupplierOrderXDE in Petstore.\n\n","Similarly, unreasonably long parameter lists tend to cause frustration and confusion. The following method in \u201cLiferay,\u201d which is an open-source enterprise portal, exemplifies a method likely to cause frustration for this reason:\n\n","In contrast to these exemplary methods having sequences of parameters of the same type or unreasonably long parameter lists, API method declarations that involve only a small number of parameters that are \u201cwell-ordered\u201d are easier to understand, remember, and use.","Embodiments may determine an API Parameter List Complexity Index (\u201cAPXI\u201d) metric in step  that measures the overall usability of an API with respect to the lengths of parameter sequences and the extent to which parameters occur in runs of data objects of the same type. The APXI metric may contain two components, one for analyzing the method declarations for the lengths of the parameter sequences and another for analyzing the method declarations for variations in the parameter types.","In such embodiments, A(m)={a, a, . . . , a} may represent the sequence of parameters in a given method declaration m. The notation Cmay be used to measure the relative quality, averaged over all of the API methods, of the lengths of the parameter sequences in the individual methods. Cmay be calculated by:",{"@attributes":{"id":"p-0038","num":"0041"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["C","l"]},"mo":"=","mrow":{"mfrac":{"mn":"1","mrow":{"mo":["\uf603","\uf604"],"mi":"M"}},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"m"},"mo":"\u2062","mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["N","d"]},"mo":",","mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}}}}}}}}},"br":{}},{"@attributes":{"id":"p-0039","num":"0042"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"msup":{"mi":"\u2147","mrow":{"mi":["x","y"],"mo":"-"}}},{"mrow":{"mrow":{"mi":["if","y"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2264","mi":"x"}}]},{"mtd":[{"mn":"1"},{"mi":"otherwise"}]}]}}],"mo":"="}}}},"In the formula for C, Nmay be the desired best choice for the number of parameters in a method. As mentioned earlier in this section, a value of four or five may be what most seasoned developers would recommend for N(i.e., a list of parameters greater than four or five may be an unreasonably long parameter list). However, any value may be selected for N. Cmay be referred to as the parameter length complexity of an API.","In such embodiments T(a) may represent the type of a given parameter a. S(m) may be the set of the parameters in the method declaration m when the next parameter in the parameter list is of the same type. The following expression can be written for S(m):\n\n()={()|()\u039b1()=()}\n\nThe notation Cmay be used to represent the extent, averaged over all the methods, to which the parameter types do not stay the same for consecutive runs of the parameter types in a parameter list. In terms of S, Cmay be given by:\n",{"@attributes":{"id":"p-0042","num":"0045"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Cs","mo":"=","mrow":{"mfrac":{"mn":"1","mi":"M"},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"m"},"mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"msub":{"mi":["S","pt"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":"A","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},"mo":"-","mn":"1"}]}}}}}}}},"br":{},"sub":["s ","l ","s"]},{"@attributes":{"id":"p-0043","num":"0046"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"APXI","mo":"=","mfrac":{"mrow":{"msub":[{"mi":["C","l"]},{"mi":["C","s"]}],"mo":"+"},"mn":"2"}}}}},"The APXI value may be bounded between zero and one. The APXI value is likely to be lower the longer the lengths of the parameter lists in an API. When parameter lists become long it becomes more likely that such lists will contain multiple runs of parameters of the same type.","Structural consistency facilitates API usability. API documents that are inconsistent in the sense that the methods with similar functionality have their parameters (that may take arguments that are similar or identical) arranged inconsistently create frustration and confusion.","By way of example, consider the API for the class javax.xml.stream. XMLStreamWriter in Java 1.5\u2122. This API lists a number of methods such as writeStartElement, writeEmptyElement, and writeAttribute for writing extensible markup language (\u201cXML\u201d) to an output stream. The parameter lists for all these methods include the local name of the XML element to be written out (formal parameter name being localName) and the namespace universal resource identifier (\u201cURI\u201d) (formal parameter name being namespaceURI). One would expect that the order in which the two parameter names show up in the method declarations would be consistent across the methods that do more or less similar things. That is, one would either want to see namespaceURI before localName in all such method declarations in the API or vice versa. That is unfortunately not the case. The API declarations for the methods writeStartElement and writeAttribute list the parameter namespaceURI before the parameter localName, whereas the declaration for the method writeEmptyElement lists these two parameters in the opposite order. This is a recipe for trouble because it may cause a client programmer to inadvertently call the method writeEmptyElement while passing the namespaceURI before localName. Of particular importance, because both of these parameters are of type String, the code with writeEmptyElement called incorrectly likely still compiles without problems. The code would even run without problems as long as the method writeEmptyElement is not actually invoked at runtime. But if this method should get called at runtime, a client programmer can only guess as to what the outcome will be, ranging from program misbehavior to the program crashing. Inconsistencies in the sequencing of similar parameters in the method signatures may also sow doubt in the mind of a client programmer at the time of writing code as to whether he\/she truly remembers the correct method signature for a given method call.","Embodiments may determine an API Parameter List Consistency Index (\u201cAPLCI\u201d) metric in step  that quantitatively measures the parameter list consistency of methods of an API. In embodiments, P may be the set of all parameter names used in all the methods of an API. M may be the set of all API methods. A set of methods may be considered to be of related functionality if the methods in the set share at least two parameter name labels. Pmay denote the ordered set of parameter names for a method m. For every pair of parameter names p, p\u03b5P, Mmay be the set of all methods whose parameter lists contain the parameter names pand pin any order. That is,\n\n}\n","For a given pair of parameter name labels pand pfrom the set P, the set Mmay be empty. The set Mmay additionally be partitioned into two disjoint subsets:\n\n\n\nwhere Mis the subset in which the parameter name pappears before pand Mthe subset where the order of the two names is reversed. For the set Mof methods to be considered consistent with regard to the listing of the parameters, the cardinality of the set must be at least two and one of the two subsets Mand Mmust be empty. Otherwise, the set Mmay be considered to be inconsistent.\n","According to embodiments, the APLCI metric for an API may be defined as the ratio of number of consistent method sets to the total number of such sets that are allowed to be tested for consistency:",{"@attributes":{"id":"p-0050","num":"0053"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"APLCI","mo":"=","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mrow":[{"mo":["{","\uf604"],"msub":{"mi":"M","mrow":{"msub":[{"mi":["p","i"]},{"mi":["p","j"]}],"mo":","}}},{"msub":{"mo":"\u2200","mrow":{"msub":[{"mi":"p","mrow":{"mi":"i","mo":","}},{"mi":["p","j"]}],"mo":"\u2062"}},"mo":"\u2062","mrow":{"mo":["\uf603","}"],"mrow":{"mo":"\u2265","mrow":{"mrow":{"mn":"2","mo":"\u22c0","msub":{"mi":"M","mrow":{"msub":[{"mi":["p","i"]},{"mi":["p","j"]}],"mo":"\u2062"}}},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["is","consistent"]}}}}],"mo":"\u2062"}},{"mo":["\uf603","\uf604"],"mrow":{"mrow":[{"mo":["{","\uf604"],"msub":{"mi":"M","mrow":{"msub":[{"mi":["p","i"]},{"mi":["p","j"]}],"mo":","}}},{"msub":{"mo":"\u2200","mrow":{"msub":[{"mi":"p","mrow":{"mi":"i","mo":","}},{"mi":["p","j"]}],"mo":"\u2062"}},"mo":"\u2062","mrow":{"mo":["\uf603","}"],"mrow":{"mo":"\u2265","mn":"2"}}}],"mo":"\u2062"}}]}}}}},"The value of APLCI may be bounded between zero and one. If all the subsets of the API methods that have at least two common parameter names are consistent, the APLCI value may equal one. Conversely if all such subsets are inconsistent, the value may equal zero.","As mentioned above, structural consistency adds to API usability and quality. However, APIs that have evolved through multiple version changes commonly contain similar API method names whose functionalities are more or less the same. Programmers are often frustrated when there is a need to invoke such methods since they must frequently refer to other sources to ascertain the subtle differences between the behaviors associated with such method names. The following three abuse patterns illustrate potential confusion arising from the structural inconsistency of API method names.","First, consider an I\/O module designed for an embedded application. For example, the API for the module may list the following method for writing an array of bytes to the flash memory of the module:\n\nwriteByteArray(byte[ ] byte )\n","Assuming that the execution speed is critical because of real-time constraints on the application, the writers of the module may forgo any checks on the availability of the needed memory before the above method is invoked at run time. Such a check may not really be necessary for the embedded device for which the software is originally written, for example, on account of how the memory may be made available to the application. Subsequently another client may express interest in the same library but for a different embedded application for which the memory-management assumptions made at the time the software was first written do not hold. The new client may want the writers of the software to either alter the implementation of the above method or to provide another similar method whose overall functionality is the same but that includes certain checks on the available memory. For business reasons the supplier of the software library may not want to create two separate modules for these two clients. Thus, the writers of the software may be left with no choice but to expand the API with another version of the writeByteArray( )method that may be \u201cconveniently\u201d named as:\n\n","The may create obvious confusion for future client programmers who may use the API. The API would now include two method declarations with names that are more or less identical with the two methods offering the same functionality. While a careful reading of the associated documentation may, in most cases, clarify the role played by each method, the potential for such an API to lead to coding errors is high. Calling the first version of writeByteArray( ) when the second one is actually needed could result in a run-time abort of the application under certain data conditions, and calling the second version when it was the first one that was really needed could unnecessarily slow down an application.","By way of alternative example, take the case of Xalan-Java\u2122, an extensible stylesheet language transformation (\u201cXSLT\u201d) processor for transforming XML documents into HTML, text, and other XML document types. The API of the class PrintTraceListener in the package org.apache.xalan.trace of this software library includes two method declarations with names_trace( ) and trace( ) the difference between the two being merely the prefix \u2018_\u2019 for one of the names. The API documentation does not indicate anything about the difference in the functionality offered by these two methods. The users of this API have no choice but to look at the source code in order to figure out as to which of the two methods to call. And, as it turns out in this case, both these methods are functionally equivalent, with one merely redirecting to the other. Such duplicate names may cause a programmer confusion and frustration.","As a further example, consider the case when there exists two or more method names in an API that differ only with regard to the case used for some of the characters. When API method names differ only with regard to the capitalizations, those method names are confusing and frustrating to use. For instance, the API of the class javax.xml.datatype.XMLGregorianCalendar in Java 2\u2122 includes two methods that are named getTimeZone( ) and getTimezone( ). Except for the fact that the character \u2018z\u2019 appears uppercase in one and lowercase in the other, the two names are identical. What is particularly troublesome here is that a programmer may completely overlook the difference in the method names in a quick perusal of the API because the two names appear to be very nearly the same to the human eye. In such a case, a programmer is just as likely to use the right method as the wrong one when wanting the functionality offered by either of the two methods named here.","The three abuse patterns described above demonstrate that a metric may be helpful that gives a quantitative assessment of the usability of an API with regard to its potential to confuse the programmers because some of the method names used in the API are too similar. However, such a metric must account for the practice of method name overloading in object-oriented programming. Method name overloading allows a programmer to equip a class with different versions of the same method called (e.g., print( ) with each version meant for a different type of argument, with the method overload resolution algorithm of the compiler deciding which specific executable to invoke for a given method call. When method names are overloaded, the different versions of the method will possess different signatures (i.e., the name of the method followed by an ordered list of the parameter types in the parameter list of the method). Since method name overloading serves an important purpose in object-oriented programming, measuring method name similarities that could confuse clients may expressly discount those similarities that are a result of method name overloading.","In some embodiments, step  of process flow  may include determining an API Method Name Confusion Index (\u201cAMNCI\u201d) metric. The AMNCI may measure the usability of an API from the standpoint of the three name-abuse patterns disclosed above while accounting for the similarity of the names that can be attributed to method name overloading.","The AMNCI metric may be based on the notion of a canonical form for a method name. A set of API methods may be considered confusing if the canonical form of the method names is exactly the same with the caveat that such a set does not include the overloaded versions of the same method name. This caveat is implemented by limiting each method name (as it appears in the API method declaration as opposed to a canonical form of the method name) to appearing only once in the set.","The canonical form may be acquired by erasing or modifying certain characters that may correspond to the three above-described abuse patterns. Exemplary character erasure rules are illustrated by the search and replace regular expressions shown below:",{"@attributes":{"id":"p-0062","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$MethodNameString = ~ s\/\\d*$\/\/ ;","#(remove numerical suffix )"]},{"entry":["$MethodNameString = ~ s\/ _\/\/ ;","#(remove {grave over (\u2009)}_{grave over (\u2009)})"]},{"entry":["$MethodNameString = ~ tr\/[a-z]\/[A-Z]\/ ;","#(Convert to UpperCase )"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In these exemplary regular expressions, using Perl's s\/\/\/ syntax, the first statement indicates that the canonical form of a method name stored in the variable $MethodNameString may be obtained by erasing any numeric suffixes sticking to the end of the string. The s\/\/\/ operator will cause the string value of $MethodNameString to be replaced by its canonical form. Similarly, the second statement indicates that the canonical form of a method name may be obtained by erasing all occurrences of an underscore. Finally, the third statement tells us that the canonical form of a method name may be obtained by converting all characters into their uppercase forms.","Of course, these canonical form rules are exemplary only and any others may be used. For example, in addition to, or as an alternative to, removing an underscore, other special characters (e.g., hyphens, periods, etc.) may be removed. By way of further examples, numerical characters appended to a method name may be removed, the letters of a name string may be converted to lowercase, and so on.","In embodiments, m may denote the name of a method as listed in the API and CF(m) may be the name's canonical form as obtained by the application of one or more canonical form rules, such as the three character-erasure rules shown above. M may be the set of all method names listed in the API. The set membership discipline may guarantee that all overloaded versions of the same method name will make only one appearance in the set. Mmay be a list of method names obtained after the canonical form rules are applied to each member of the set M. C, defined below, may thus denote the list of confusing method names in the API. An API method named may be considered confusing, and therefore placed in the list C, if there exist two or more members of the set M that yield different identical canonical forms in the list C. That is:\n\n()=()}\n\nThe AMNCI for a given API may thus be defined as:\n",{"@attributes":{"id":"p-0066","num":"0070"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"AMNCI","mo":"=","mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mi":"C"},{"mo":["\uf603","\uf604"],"mi":"M"}]}}}}},"br":{}},"In alternative embodiments, the AMNCI metric may be determined in other ways. For example, the AMNCI metric may alternatively be based on the Levenstein edit distance that can be used to measure the extent of dissimilarity between two strings. However, such embodiments may results in greater false positives. For example, the method names getMinLabel( ) and setMinLabel( ) may be identified as confusing. While the two names differ in only one character position, most programmers likely would not consider them to be confusing.","Structural quality of an API may further be reduced if conceptually and\/or functionally similar API methods are not grouped together. Given a small API containing, for example, approximately one dozen methods, it may be relatively easy for a programmer to commit to memory all of the methods and what each method does. However, that would cease to be the case as the size of an API increases.","It is common for a programmer to be looking for an API method with a particular functionality and, for example, the API may contain several methods with related functionality that happen to be listed together somewhere at the beginning of the API document. However, the perfect method may be listed all by itself somewhere near the end. In such a case, it would not at all be unusual for the programmer to miss the method that would be a perfect match for what the programmer wants. After quickly scanning through the related methods at the beginning of the API document, the programmer would likely assume that they had checked all of those kinds of methods in the API.","Also, confronted with a large API, the programmer must consult the documentation frequently to determine whether or not the API offers a particular functionality and how to invoke the method that implements that functionality. As the programmer uses methods from the API, the programmer will gradually form a mental landscape of how the API is organized with regard to the packaging of the services it offers. So when most of the methods offering a certain kind of functionality are grouped together and the rest of the methods offering the same kind of functionality tucked away elsewhere; the latter may get overlooked.","As a case in point, shown below is the order in which the methods are declared in the API of the class HtmlForm of the HtmlUnit application (a GUI-less browser for Java programs):",{"@attributes":{"id":"p-0072","num":"0076"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"getInputByName","mo":["(",")"]}}},{"mtd":{"mrow":{"mi":"getInputByValue","mo":["(",")"]}}},{"mtd":{"mrow":{"mi":"getInputsByValue","mo":["(",")"]}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"mrow":{"mi":"getAllInputsByName","mo":["(",")"]}}}]}}}},"While getInputByName( ) appears at the very beginning of the API document, the closely related getAllInputsByName( ) appears at the very end. This creates the possibility that a programmer needing the functionality of getAllInputsByName( ) may assume its absence in the API after seeing the ByName to ByValue change in the method listings. Subsequently, the programmer could try to create his\/her own implementation for what he\/she needs by making iterative invocations of the getInputByName( )method. Hence, when methods of similar names and similar functionality are scattered all over in a large API, it can seriously impinge on the usefulness of the API.","In some embodiments, step  of process flow  may include determining an API Method Grouping Index (\u201cAMGI\u201d) metric. The AMGI may measure the extent to which an API groups conceptually related method declarations together. To develop this metric, a computing device may infer the semantic relationships between method declarations on the basis of the semantically significant keywords extracted from the method names used in the declarations. Methods whose names contain the same keyword(s) may be considered to be semantically related. For example, the string \u201cphone\u201d may be a semantically significant keyword in plural method names and therefore a computing device may consider the declarations for the methods getPhoneNumbers( ), setPhoneNumbers( ), addPhoneNumber( ), and removePhoneNumber( ) to be semantically related.","The following steps may be used for extracting the semantically significant keywords from a set of method names. First, a computing device may remove commonly occurring prefixes and suffixes from the names of the methods in the API. For example, \u2018get\u2019, \u2018set\u2019, and the like may be removed. Next, what remains of the method names may be split into plural substrings on the basis of commonly occurring connectors. Commonly occurring connectors may be, for example, \u201c_\u201d, \u2018\u2014\u2019, \u2018by\u2019, \u2018of\u2019, \u2018and\u2019, \u2018to\u2019, etc. and case changes as in \u2018CamelCase\u2019. Finally, a computing device may determine if the total number of occurrences of a given name fragment in the set of name fragments returned by the previous step exceeds a threshold \u03b8 and, if so, consider that name fragment as a significant keyword. The threshold may be, for example, predetermined or manually set. Of course, these steps are exemplary only and additional or different steps may be performed to extract semantically significant keywords from a set of method names.","S={s|i=1 . . . N} may be the set of significant keywords obtained as described above for a given API. For each keyword s, a computing device may substring-match the keyword sequentially with all the method names in the API in the order in which the methods are declared. A successful match with one or more API methods may be considered as a \u2018run\u2019. A sequence of run-lengths may be constructed where each run-length value is the number of times a substring match between consecutively occurring method declarations and the keyword occurs. The notation L(s)=(r|=i . . . R) to represent the sequence of non-zero run-lengths, where Ris the number of such runs for the keyword s.","To clarify with an example, suppose the keyword sis \u201cphone\u201d. As a computing device substring-matches this keyword with every method name in the API, a run of four method names occurring consecutively that all contain the keyword \u201cphone\u201d may be determined. Subsequently, another run of three methods that also contain the same keyword may be determined. Finally, there yet another run of five method declarations that also contain \u201cphone\u201d in the method names may be determined. In this case, L(\u201cphone\u201d)=(4, 3, 5) and R=3.","The notation rmay represent the irun-length value in L(s). The total number of method declarations which match the keyword smay be represented by O. Since each run captures the consecutively occurring method declarations that match the keyword, the sum of the run lengths yields the total number of matching method declarations as specified below.",{"@attributes":{"id":"p-0079","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"O","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["s","j"]}}},{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":"i","mo":"=","msub":{"mi":["R","j"]}}]},"mo":"\u2062","msub":{"mi":["r","i"]}}],"mo":"="}}}},"The notation AMGI(s) may represent the API method name grouping index for a given keyword sand may be defined as follows:",{"@attributes":{"id":"p-0081","num":"0085"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"AMGI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["s","j"]}}},{"mn":"1","mo":"-","mfrac":{"mrow":[{"msub":{"mi":["R","j"]},"mo":"-","mn":"1"},{"mrow":{"mi":"O","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["s","j"]}}},"mo":"-","mn":"1"}]}}],"mo":"="}}}},"For a given keyword s, the value of AMGI(s) may equal one when all of the method declarations whose names contain the keyword exist in a single run in the API as this would be considered to be ideal with regard to method grouping. In this case, the value of Rmay equal one. At the other extreme, if the method declarations that contain a given keyword are all completely scattered, all of the elements rin the sequence L(s) may equal one and the value of Rmay be the same as that of O(s). Thus, the value of AMGI(s) may be zero in this case.","The AMGI metric for a given API may be defined as the average of AMGI(s) values for all the keywords in the set S as shown in the following equation:",{"@attributes":{"id":"p-0084","num":"0088"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"AMGI","mo":"=","mfrac":{"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mi":"AMGI","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["s","j"]}}}},"mi":"N"}}}},"br":{},"sub":"j"},"Given the growing importance of multithreading, especially on modern multi-core platforms, thread-safe methods and programs may be deemed to have higher quality than non-thread-safe methods and programs. Almost all the major programming languages provide thread synchronization primitives that can be used to suppress thread interference when multiple threads must share data objects in the memory. However, if not careful it can be easy for a programmer to make mistakes that will produce erroneous results.","Ensuring sufficient synchronization may become more difficult when a programmer depends on a third-party API. Ideally, when a function is made thread-safe by the use of the synchronization and other such primitives provided by a language, that fact should be declared in the API of the module. Conversely, when a function is not inherently thread-safe and the client programmer of the module should make sure that the function is invoked in a thread-safe manner in the client programmer's own code, that should also be declared in the API. Unfortunately, it is not uncommon to see APIs that offer no clues regarding the thread-safety of the methods. This is generally either because the providers of the API did not anticipate the use of the library in a multithreaded scenario or because they were just not being careful enough. Nonetheless, the result is that clients of the API have to resort to extensive testing to make sure that the provided functionality can be implemented in multithreaded manner.","In some embodiments, step  of process flow  may include determining an API Thread Safety Index (\u201cATSI\u201d) metric. The ATSI may measure the extent to which the method declarations of an API satisfy potential clients' needs regarding the presence and\/or absence of thread safety statements.","Although Java annotations are recommended for documenting thread-safety and synchronization policies for API method declarations, unfortunately such annotations are not processed by Javadoc and hence are not visible to users who do not have access to the source code. Therefore, embodiments may make a reasonable assumption that if an API method declaration contains the words \u201cthread\u201d and \u201csafe\u201d then, in all likelihood, the method declaration explicitly conveys to the programmer the needed information on the thread safety of the method.","Embodiments may determine the ATSI by letting T be the set of method declarations in the API that contain the strings \u201cthread\u201d and \u201csafe\u201d. As before, M may be the set of all method declarations in the API. The API thread safety thus may be determined according to the equation:",{"@attributes":{"id":"p-0090","num":"0094"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"ATSI","mo":"=","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mi":"T"},{"mo":["\uf603","\uf604"],"mi":"M"}]}}}}},"Obviously, even a declaration that mentions that a method is \u201cunsafe\u201d for multithreading or \u201cnot\u201d thread-safe will meet the requirement even though the declaration likely indicates that the method is not thread-safe. Similarly, a declaration containing strings such as \u201cmultithread ready\u201d may indicate that a method is thread-safe but not meet the requirement. Thus, alternative embodiments may include lookup tables, fuzzy logic, natural-language analysis or other mechanisms to determine to a greater degree whether a method declaration indicates the thread-safety of a method.","Instead of throwing exception classes that are specific to the data type that generated the run-time fault, developers sometimes throw exceptions that are general. This mistake or shortcut is commonly made by the developers during software development because it requires less work. Throwing exception classes specific to each data type will, in general, require that new exception classes be defined by extending the system supplied exception classes.","Object-oriented exception-handling frameworks typically define a hierarchy of exception classes, each class in the hierarchy tailored to a specific type of error. Consider, for example, a hierarchy of input\/output (\u201cIO\u201d) classes in some object-oriented language. One may define a general IOException class for catching all anticipated runtime IO errors, such as missing files, incorrect data in files, etc., but then one may also define more specific exception classes such as FileIOException, SocketIOException, TerminalIOException, etc., all descendents of the parent IOException class but each geared to catching errors in a specific IO mode. Since object-oriented exception handling systems exhibit polymorphism, an exception of type, for example, FileIOException may be caught by a catch block whose parameter is of the more general type IOException, but not the other way around. Thus, exception handling works best if the thrown exception is specific to the context at hand, rather than a more general version. So, if file IO is the context and an exception needs to be thrown, it should be of type FileIOException, and not its more general parent IOException, although, on account of polymorphism, it would be legal to throw and catch the more general exception.","When a developer uses the system-supplied general exception classes for throwing exception objects when run-time faults occur during the execution of API methods, those exception classes become a part of the API documentation. Subsequently, the clients of the API document have to live with the resulting inefficiencies in tracing run-time faults.","In some embodiments, step  of process flow  may include determining an API Exception Specificity Index (\u201cAESI\u201d) metric. The AESI may measure the extent of the generality and\/or specificity of the method declarations of the API.","In embodiments, E(m) may be a function that returns the set of exceptions thrown by a given method m in the API. The inheritance hierarchy of the exception classes may be represented by a tree T=(N, V) where N is the set of exception classes represented as nodes and V is the set of edges which represent the inheritance relation between the exception classes. Henceforth, for lucidity, the terms \u2018exception class\u2019 and \u2018node\u2019 may be used synonymously.","For an exception e, D(e) may be the depth of the node e in the tree T. H(e) may be the height of the node e in the tree T. AESI(e) may denote the specificity of a given exception e according to the formula:",{"@attributes":{"id":"p-0098","num":"0102"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"AESI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}},"mo":"=","mfrac":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}}},{"mo":["(",")"],"mrow":{"mrow":[{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}},{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}}],"mo":"+"}}]}}}}},"AESI(e) may be directly proportional to the \u201cdistance\u201d of the exception class from the root and, at the same time, inversely proportional to its height from the leaf nodes in the exception class hierarchy. Therefore, an exception class at the bottom of the class hierarchy (i.e, the most specific exception class that could be used) may have a height of zero, which would cause AESI(e) to become one. By the same token, for an exception class that is more general and situated near the root of the hierarchy, the AESI(e) value may tend towards zero. If the exception class is at the root, its depth is zero; in this case the value of AESI(e) may equal zero. Thus, the value of AESI(e) may be bound between zero and one, with one denoting the most specific exception class and zero denoting the most generic exception class.","For a given method m, the API exception specificity index AESI(m) may be given by the average API exception specificity index AESI(e) for all the exceptions thrown by the method.",{"@attributes":{"id":"p-0101","num":"0105"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"AESI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mo":"{","mtable":{"mtr":[{"mtd":{"mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"mo":"\u2200","mrow":{"mi":"e","mo":"\u2208","mrow":{"mi":"E","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}}},"mo":"\u2062","mrow":{"mi":"AESI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"E","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}}]}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mo":"-","mn":"1"},{"mi":"E","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"when"},"mo":"=","mi":"\u03d5"}}}]}}],"mo":"="}}}},"The value returned by the above expression is bounded by zero and one. If a majority of the exceptions thrown by the API methods are specific, the value of the metric tends toward one. Conversely, if a major proportion of the exceptions thrown are generic, the value of the metric tends toward zero.","The AESI for a given API may be the arithmetic mean of the AESI values for all the method declarations in the API that are described as throwing exceptions. M may denote the set of all method declarations in the API. The API level AESI thus may be defined by:",{"@attributes":{"id":"p-0104","num":"0108"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"AESI","mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"mrow":[{"mo":"\u2200","mrow":{"mi":["m","M"],"mo":"\u2208"}},{"mrow":{"mi":"AESI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mo":"\u2260","mn":"1"}],"mo":"|"}},"mo":"\u2062","mrow":{"mi":"AESI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mo":["\uf603","\uf604"],"mrow":{"mo":["{","}"],"mrow":{"mrow":[{"mi":"m","mo":"\u2208","mrow":{"mi":"M","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}},{"mrow":[{"mi":"AESI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mo":"-","mn":"1"}],"mo":"\u2260"}],"mo":"|"}}}]}}}}},"As with the other metrics, AESI may be bounded between zero and one, with a value of one when all the applicable method declarations in the API throw the most specific exception classes and zero when all the applicable method declarations throw the root exception class.","Even when the API method declarations, in and of themselves, do not suffer from the structural shortcomings listed above, the rest of the documentation associated with the API, if of substandard quality, could still make it challenging for a client to use the API effectively. For a well designed API, the documentation will present information related to any constraints that must be satisfied before a method can be invoked, any side effects associated with the method invocations, any default values associated with the parameters, and the like.","In some embodiments, step  of process flow  may include determining an API Documentation Index (\u201cADI\u201d) metric. Almost all major programming languages now provide support for embedding documentation in the source code through a system of tags inside specially designated comment blocks to indicate which source-code elements are being documented. For instance, Javadoc provides tags, such as returns, for documenting a method. If the source-code is available, embodiments may use these tags to measure the quality of API documentation. Alternatively, some embodiments may omit such a feature, instead having the goal to discern issues directly from the API documentation, without examining the source code.","With regard to documentation, as a general rule, the longer the documentation associated with a source code file, the more useful the documentation. While the precise content of documentation may be much more important than its length, a metric for the quality of documentation based on length may still provide a useful estimate of the quality of API documentation. L(m) may be the length of the documentation in number of words for a given method m. The comment block, including any specially-designated comment blocks for various documentation generators, documentation just before a method header or just after will be considered to be the documentation associated with that method. ADI(m) may be used to denote the ADI for a given method m. It may be defined by the following formula:",{"@attributes":{"id":"p-0109","num":"0113"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"ADI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"msub":{"mi":["L","d"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},"mo":">","mi":"\u03a8"}}]},{"mtd":[{"mfrac":{"mrow":{"msub":{"mi":["L","d"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}},"mi":"\u03a8"}},{"mi":"otherwise"}]}]}}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0110","num":"0114"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"ADI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}},"mo":"=","mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"mo":"\u2200","mrow":{"mi":"m","mo":"\u2208","mrow":{"mi":"M","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}}},"mo":"\u2062","mrow":{"mi":"ADI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"m"}}},{"mo":["\uf603","\uf604"],"mrow":{"mi":"M","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"i"}}}]}}}},"br":{}},"As motioned above, in addition to the length of an API's documentation, the content of the documentation may greatly bear the quality of the API. Alternative embodiment may utilize natural language processing and may analyze the API's documentation for its semantic content.","These embodiments may be implemented with software, for example modules executed on computing devices such as computing device  of . Of course, modules described herein illustrate various functionalities and do not limit the structure of any embodiments. Rather the functionality of various modules may be divided differently and performed by more or fewer modules according to various design considerations.","Computing device  has one or more processing device  designed to process instructions, for example computer readable instructions (i.e., code) stored on a storage device . By processing instructions, processing device  may perform the steps and functions disclosed herein. Storage device  may be any type of storage device (e.g., an optical storage device, a magnetic storage device, a solid state storage device, etc.), for example a non-transitory storage device. Alternatively, instructions may be stored in one or more remote storage devices, for example storage devices accessed over a network or the internet. Computing device  additionally may have memory , an input controller , and an output controller . A bus  may operatively couple components of computing device , including processor , memory , storage device , input controller , output controller , and any other devices (e.g., network controllers, sound controllers, etc.). Output controller  may be operatively coupled (e.g., via a wired or wireless connection) to a display device  (e.g., a monitor, television, mobile device screen, touch-display, etc.) in such a fashion that output controller  can transform the display on display device  (e.g., in response to modules executed). Input controller  may be operatively coupled (e.g., via a wired or wireless connection) to input device  (e.g., mouse, keyboard, touch-pad, scroll-ball, touch-display, etc.) in such a fashion that input can be received from a user.","Of course,  illustrates computing device , display device , and input device  as separate devices for ease of identification only. Computing device , display device , and input device  may be separate devices (e.g., a personal computer connected by wires to a monitor and mouse), may be integrated in a single device (e.g., a mobile device with a touch-display, such as a smartphone or a tablet), or any combination of devices (e.g., a computing device operatively coupled to a touch-screen display device, a plurality of computing devices attached to a single display device and input device, etc.). Computing device  may be one or more servers, for example a farm of networked servers, a clustered server environment, or a cloud network of computing devices.","The following presents experimental validation of the exemplary metrics and indexes according to the disclosure herein. Of course, alternative embodiments may deviate from those validated herein while remaining within the scope of this disclosure. The following validation of the API usability metrics is based on measuring and analyzing the metrics on the following seven software systems: (1) Java Platform\u2122 JDK 2 (to be referred to as Java 2\u2122 henceforth); (2) Java Platform JDK\u2122 5 (to be referred to as Java 5 henceforth); (3) Eclipse Java Developer Toolkit\u2122 (JDT), a popular IDE for Java (to be referred to as Eclipse henceforth); (4) Petstore, a reference J2EE implementation; (5) Hibernate, a software system for creating object-oriented interfaces for relational databases; (6) Compiere, a system for enterprise resource planning and customer relationship management; and, finally, (7) a large legacy proprietary financial software system (to be referred to as \u2018Financial\u2019 henceforth).","Except for the last, these are all freely-available software libraries. For the experiments, all public methods of all public classes are considered as API methods. For the case of Java 2\u2122 and Java 5\u2122, only those packages that appear in the online API documentation provided at the java.sun.com website were considered. All the deprecated methods from the API were excluded in the analysis. For the case of Eclipse JDT, all the internal packages (that is, package names containing the string internal) were excluded from the analysis.","Validation consists of comparing, for each software system listed above, the metric values measured for the APIs of the system with a quantitative assessment the general state of the APIs from the standpoint of the property that the metric is supposed to measure. So if it can be shown that a particular metric increases or decreases in roughly the same manner as the API property that the metric is supposed to capture, that would indicate that the metric is indeed behaving as it should. What lends a measure of statistical validity of such comparisons is the fact that the metric for each software system will actually be the average of the metric values obtained for hundreds and sometimes thousands of the class APIs in each system. To explain this with an analogy, to test the predictive power of a function which can predict the score that the students in a class may be expected to achieve in an examination, one may compare the prediction not against the actual score of the first student come across, but against the average over all the students in the class.","The validation obtained as explained above will be further bolstered, whenever possible, by comparing the computed metric values with the general beliefs held by the developer community regarding the software systems. However, one would only be able to do so when such beliefs are available either directly or can be inferred from the circumstances related to the development of a software system. When available directly, these general beliefs may be obtained from the commentaries in various forums and newsgroups devoted to the software systems.",{"@attributes":{"id":"p-0119","num":"0123"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 3"]},"Looking at the software systems, the API of the class javax.naming.directory.Attribute in Java 5\u2122 yields a low value of 0.333 for the AMNOI metric. An examination of this API class shows that it has three groups of overloaded methods, of which two are inappropriate. The fact that two out of three method groupings are unacceptable from the standpoint of overloading is confirmed by the metric value of 0.333 for this API. The three groups of overloaded methods in this API are:\n\n","In Group 1, the method add( ) assumes an ordered list of attribute values; this method inserts the attribute value supplied through the second argument at the location specified by the first argument. On the other hand, the second method in Group 1 is based on the assumption that the attribute values are unordered and it appends the attribute value supplied through the only argument at the end of the attribute list. Whereas the first add( ) in Group 1 returns void, the second returns a boolean value. It may be an error to overload the method name add( ) in this manner. Thus, the quality of the API may have increased if the developers had defined two separate methods named according to their functionality. The former could, for example, have been named insert and latter append. The two methods listed under Group 2 above have a similar problem. The first remove( ) returns a boolean whereas the second method of the same name returns an Object.","For APXI related experiments, value of the parameter Nmay set to four. Thus an API method potentially suffers from a structural issue when the number of parameters is greater than four.  shows experimental results reflecting exemplary average parameter list complexity metric values for the class APIs for all seven software systems. These metric values are supported by the exemplary experimental data presented in . That figure displays a distribution showing the number of methods for the different parameter lengths in each software system. As mentioned above, with the value of Nset to four for the APXI metric only those methods whose parameter lengths are greater than four were considered. From , it is clear that Petstore has the lowest APXI value. This is because Petstore, despite its being a relatively small system, has a disproportionately large number of methods with parameter lengths exceeding four, as is evident in . On the other hand, Hibernate has a somewhat better APXI value of 0.76. All of the API methods in Hibernate have parameter lengths of seven or less. As shown in , two Java libraries in Java 2\u2122 and Java 5\u2122 each have two API methods with eighteen parameters.","For an example of an API that suffers from the structural issues relating to parameter lists containing runs of the same type and long parameter lists that are difficult to remember, consider the class com.sun.j2ee.blueprints.catalog.model.Item in Petstore. This API has a low APXI value of 0.041728. The constructor of this API class has the following signature:\n\n","As explained above, the APXI metric may have two parts, one being a measure of the appropriateness of the parameter length and the other the extent of the variability in the parameter types. The measure related to parameter length for the Item constructor works out to 0.0001 since it has thirteen parameters. The other measure for the same method works out to 0.0833 since eleven out of twelve parameter types are the same. When the two contributions are averaged for the Item method, the APXI metric value for this API is 0.041728, which is the value that was actually measured for this particular API.",{"@attributes":{"id":"p-0125","num":"0139"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0126","num":"0140"},"figref":"FIG. 6"},"To illustrate the behavior of this metric, any of the APIs in the software systems could be selected for the validation study. For example, the API of the class org.compiere.model.MPrivateAccess in Compiere is examined in this case, for which the computed value for APLCI is zero. This indicates that this API is particularly poor with regard to the structural issue of consistent sequencing of parameter types. A manual examination of this class API reveals that it has four method declarations that are declared as follows:","MPrivateAccess get(Properties ctx, int AD_User_ID, int AD_Table_ID, int Record_ID) Void MPrivateAccess (Properties ctx, int AD_User_ID, int AD_Table_ID, int Record_ID) String getLockedRecordWhere (int AD_Table_ID, int AD_User_ID) Void MPrivateAccess (Properties ctx, ResultSet rs)\n\nOf these four method declarations, the first three share a pair of common parameter names, AD_User_ID and AD_Table_ID. Note that even though the first two method declarations share the parameter names AD_Table_ID and Record_ID, they do not form a valid set for the measurement of this metric since the cardinality of such a set would be less than three. However, the set of the first three method declarations is inconsistent since the order of the parameters AD_User_ID and AD_Table_ID are not preserved across all the methods in the set. So it is expected that the APLCI value for this API to be zero and that fact is borne out by actual measurement.\n",{"@attributes":{"id":"p-0129","num":"0143"},"figref":["FIG. 7","FIG. 7","FIG. 7"]},"It is interesting to note that all the software systems in the validation study have good values for this metric. This is to be expected as the method name confusion of the type addressed by the structural issue related to existence of too many methods with nearly identical names is usually introduced when a software package is changed to meet the evolving needs of its customers. Most of the open source systems considered, such as Petstore and Hibernate, have not undergone significant API changes since they were first introduced. So it is not surprising that, Petstore has only 12 method names (spread over 3 class APIs). By the same token, Java 2\u2122 has 84 confusing method names and Java 5\u2122 has 90. On the other hand, the proprietary financial system that has been constantly evolving to meet the varying business needs of the customers has 632 confusing API methods.","To consider a specific API to further illustrate the behavior of this metric, the API for class javax.swing.event.ListDataEvent in Java 5\u2122 is examined. The AMNCI metric value for this API is 0.6. A manual examination of this API reveals that it consists of five method declarations, of which two declarations with method names getIndex0( ) and getIndex1( ) are confusing in the sense captured that too many methods with nearly identical names exist. The documentation associated with this API mentions that the method getIndex0( ) is supposed to return the lower index of a range and the method getIndex1( ) the upper index. There is no way a user of the API can realize this by just looking at the names of the two methods. The user is forced to also look at the additional API documentation to resolve the confusion. Since two method declarations out of five are confusing, it is not surprising that the AMNCI value calculates out to be 0.6. Let's next consider the API for the class org.apache.xalan.trace.PrintTraceListener in Java 5\u2122. The metric calculation for this API returned an AMNCI value of 0.7141. A manual examination of the API shows that two out of seven method declarations, these being_trace( ) and trace( ) are confusing in the sense that they have nearly identical names. That is indeed a confirmation for the calculated value of 0.7141 for the metric.","The method grouping index metric values for the APIs of the different software systems are shown in . The AMGI value for the financial system is a relatively low value of 0.6749. This can be explained by the fact that this legacy system has evolved haphazardly over a span of 10 years. As various methods were added to this software library, not much attention was given to how the various related methods were grouped together in the API. Therefore the circumstances of the evolution of this software should lead one to expect a low value for a metric such as AMGI, which indeed turns out to be the case.","The API for the class org.compiere.util.ZipUtil in the Compiere library has a low AMGI value of 0.3958. A manual examination of this API reveals that its important keywords are zip, jar, manifest, and entry and we must determine the AMGI contribution made by each. For the keyword manifest, none of the related methods getManifest( ), getManifest(String filename), and dumpManifest( ) are grouped together. As a consequence, the keyword manifest should contribute zero to the metric. For the keyword entry, two of the methods whose names contain the keyword, getEntry( ) and getEntryInfo( ) are consecutive, but the other three, getEntry( ) getJarEntry( ) and getEntryTime( ) are at three different locations in the API. As a result, the keyword entry contributes a value of 0.25 to the metric. Similar manual examination of the method declarations that contain the keyword jar reveals that it should make a contribution of 0.33 to the metric. Finally, the keyword zip can be seen to show up in a consecutive sequence of three methods, indicating that it should contribute one to the metric. Averaging all of these expected values gives 0.3958, which is the value actually computed for the metric.","Two special circumstances pertain to the validation of the thread safety index metric. First, vis-\u00e0-vis the validations we have presented so far, a slightly different \u201cprotocol\u201d for the validation of ATSI is used since not all seven software systems support multithreading. Validation for this metric will be based on a comparison of Java 2\u2122 with Java 5\u2122. Second, for the calculation of ATSI, all the API methods are considered to have been documented for thread safety if such documentation exists at the class level. This was made necessary by the fact that developers sometimes lump together the thread-safety statements for all the method declarations and place them at the head of the API document.","In order to appreciate the values of this metric for the two Java platforms, note the widely-held belief in the Java developer community that the Java 2\u2122 APIs were found by the developers to be seriously wanting with regard to thread-safety declarations. This was especially true of the Swing classes. Many of the class methods of the Swing library are not meant to be invoked concurrently by multiple threads in a multithreaded GUI program. For illustration, a multithreaded access to the TextArea GUI widget could cause one thread to write new information in the TextArea window while the other thread was in the middle of clearing up the old content of the window. This could lead to the visible information in the GUI to be partially old and partially new. To forestall such consequences of concurrency, the invocation of thread-unsafe class methods was meant to be regulated by their placement in the special Event Dispatch Thread.","But the Java 2\u2122 platform often failed to inform the users of the API as to which methods were thread-safe and which are not. The resulting frustrations experienced by the programmers of the Java 2\u2122 libraries, especially the programmers using the Swing packages, are well documented in the numerous posts at the Java Developers Forum. Comparatively speaking, the APIs of the same libraries in Java 5\u2122 are much better documented with regard to the thread safety issue. Wherever applicable, Java 5\u2122 mentions explicitly that Swing was not designed with multithreaded applications in mind and its use in such scenarios is discouraged.","One should expect the ATSI metric to produce a relatively low value for the Java 2\u2122 Swing package and high value for the same package in Java 5\u2122.  shows a comparison of the ATSI metric values for the different packages in Java 2\u2122 and in Java 5\u2122. As shown, the metric indeed produces a higher metric value of 0.094 for the Java 5\u2122 Swing package and a lower value of 0.030 for the Java 2\u2122 Swing package. This is in accordance with expectations.","The ATSI value being higher for Java 5\u2122 Swing package does speak to the metric behaving as it should. However, the fact that the ATSI value for this package is as low as 0.094 may give pause. This metric is nonetheless useful, because a manual examination of the Java 5\u2122 Swing package reveals too many methods for which no thread-safety declarations have been made. As a case in point, consider the API for the class XMLEncoder. The various postings in the Java Developers Forum clearly indicate that the various methods listed in this API are not thread-safe. However, there is no mention of this fact in the API itself or in the documentation associated with the API. Even though the ATSI metric values for Java 5\u2122 are better than those for Java 2\u2122, there is still considerable room for improvement in the former with regard to the adequacy of thread-safety documentation for the various methods declared in the APIs.",{"@attributes":{"id":"p-0139","num":"0153"},"figref":"FIG. 10"},"To take up a specific API for further illustrating this metric, the API for the class java.lang.reflect.InvocationHandler in Java 5\u2122 is examined. The calculated value of AESI for this API is zero. A manual examination of this API reveals that it has only one method declaration with the exception throwing clause. However, the exception class used in the clause happens to be Throwable, the base class of the exception hierarchy in Java. So one would expect this API to result in zero for the AESI metric, which is indeed the case.",{"@attributes":{"id":"p-0141","num":"0155"},"figref":"FIG. 11"},"The metric values shown in  bear out one more commonly-held belief in the developer community: the APIs for the open-source software packages that are used as building blocks in larger systems are generally better documented compared to the APIs of proprietary software or stand-alone software. Eclipse, a very popular open source software system, has a metric value of 0.9 for ADI. On the other hand, the APIs of the financial system yield a low ADI value of 0.18.","To focus on a specific API for a better understanding of the metric, consider the API for the class java.util.logging.StreamHandler in Java 5\u2122. The ADI for this API has a reasonably high value of 0.88. However, given that it is not a perfect 1.0 points to the possibility that there might still be a residual documentation-related issue in this API. A manual examination reveals that this API has seven method declarations. These are for the methods setEncoding( ), publish( ), is Loggable( ), flush( ), close( ) and two constructors. Five of these seven method declarations have associated with them more than ten words of documentation related to the parameter usage and functionality. For instance, the documentation that accompanies the declaration of the method setEncoding( ) not only describes the parameter but also the possible values that can be passed. It also provides adequate documentation on the exceptions thrown. So we should expect these method declarations to make a large contribution to the ADI value for the API. Since ten words are considered as the minimal extent of documentation that should accompany a method declaration, all these five methods contribute a value of one to the overall ADI for the API. However, the declarations for the methods flush( ) and StreamHandler( ) carry reduced documentation, only four and eight words, respectively. These fall below our acceptance thresholds for the size desired for documentation. These two method declarations should contribute values of only 0.4 and 0.8, respectively, to the ADI. When all of the different contributions to the metric are averaged, a value of 0.88 should be expected, which is indeed the case.","The next analysis is determining the level of confidence that can be placed in the experimental validation of the metrics presented in the previous section. Addressing such a question usually comes under the \u201cThreats to Validity\u201d rubric in modern research literature. It is important to ensure that the various potential threats to the validity of the experiments used for supporting the metrics have been considered. These threats are usually investigated from the following three perspectives: the construct validity, the internal validity, and the external validity.","The construct validity questions involve whether an experiment is really measuring what it is supposed to measure. Construct validity in the experiments is taken care of by an actual examination of the APIs that yield values that are either too low or too high. For example, the APIs of the financial system yields a value of only 0.3597 for the AESI metric. This value has been verified by actually examining the APIs for the exception declarations of the methods in the APIs. The same is true for all of the other instances of such manual examinations listed in the previous section.","The internal validity questions the design of the experiment itself. With regard to this threat to validity, the presentation of just the average values for the metrics and the manual examination of the APIs for the low\/high values of the metrics could be criticized as not being sufficiently sophisticated from the standpoint of modern statistical data analysis. With regard to the presentation of \u201cdeeper\u201d statistical analysis of the metric values, there are two issues to consider: it would take the focus away from the conceptual construction of the metrics, and issues of space limitations.","As for the external validity, the question here is as to what extent the metrics can be generalized and used for API usability assessment for other object-oriented software systems considering that all the validation studies have been carried out on just the Java based systems. In response, note that, the metric formulations use only the method signatures in the API documents. Since the metrics do not need to examine the implementation code, the formulations are language independent. Therefore, there is strong confidence that the metrics would also apply to API specifications of the software systems in other languages.","This disclosure generally refers to \u201cclients\u201d, \u201cclient programmers\u201d, \u201cprogrammers\u201d, \u201cdesigners\u201d, and other similar terms for those who use an API. These and similar terms are intended to be used interchangeably to refer to any person or entity that interacts with an API.","Embodiments have been disclosed herein. However, various modifications can be made without departing from the scope of the embodiments as defined by the appended claims and legal equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
