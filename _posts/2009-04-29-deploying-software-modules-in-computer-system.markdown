---
title: Deploying software modules in computer system
abstract: Methods and systems are disclosed herein for deploying software modules in a computer system. In one embodiment, a number of containers are registered with a deployer. At least one container provides runtime environment for a corresponding type of software module in the computer system. The software modules are one of standalone software modules and components of software applications. From an archive file a number of files that include deployable software modules are extracted. The software modules corresponding to at least one of the containers are detected based on container specific detecting mechanisms. The detected software modules are validated in order to test their functionality and interoperability. When the software modules are validated, they are distributed for implementation in the corresponding containers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869140&OS=08869140&RS=08869140
owner: SAP SE
number: 08869140
owner_city: Walldorf
owner_country: DE
publication_date: 20090429
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is related to U.S. Provisional Patent Application Ser. No. 61\/051,692, entitled \u201cJava EE 5 Deployment in Application Server Java\u201d, filed May 9, 2008, from which priority is claimed, and which is hereby incorporated by reference.","The field of the invention relates generally to electronic data processing and to software installation and management. More specifically, a method and a system for deploying software modules in a computer system are described.","Due to the growing complexity of software solutions, software lifecycle management has become a critical task. The number of requirements associated with the software lifecycle management is increasing. This is especially true with respect to the development and maintenance of large enterprise computer systems. The modern enterprise computer systems run software applications that are built from a number of separate, sometimes independent, software components or modules. Thus, the deployment of a software application in an enterprise computer system involves installation and integration of a number of smaller software modules. At the same time, the maintenance of enterprise computer systems has to comply with tight operational requirements to ensure minimum downtime, high availability and cost efficiency. Accordingly, the lifecycle of every software module in the computer system is managed individually to retain the operability of the rest of the software components, if possible.","The existing enterprise computer systems are developed based on variety of architecture models. Traditional client-server computer systems employ a two-tiered architecture model, such as model  illustrated in . One or more software applications  are executed on client  of the two-tiered architecture model . Application  is developed as a monolithic set of program code that includes a graphical user interface (GUI) component, presentation logic, business logic, etc.","Typically, \u201cbusiness logic\u201d component of a software application represents the core functionality of the application, i.e., the rules governing the underlying process or services provided by this application. Whereas, a \u201cpresentation logic\u201d component of a software application describes the specific manner in which the results of business logic processing are formatted and presented to the user.","Furthermore, application  has a network interface that enables client  to communicate with one or more servers  over network . Network  could be dedicated to connecting client  with server  within local area network (LAN) or wide area network (WAN). Alternatively, network  could be operable for connecting a group of computer systems within an intranet or Internet environment. Finally, network  could apply any of the existing network communication protocols, including transmission control protocol\/internet protocol (TCP\/IP).","Client  represents one of the tiers of the two-tier computer system architecture model. Client  provides an environment for executing application . Server  represents the other tier. Database  is maintained on server  to provide storage for application . Database  may store various types of business and system data depending on the functionality of application . For example, on database , application  could save, extract and process data for customers, inventory records, transaction logs, etc. Furthermore, database  may hold source code files of the software modules on application . Database  may also include data access logic used by the business logic of application  to store and retrieve data.","The two-tier architecture model for building computer systems can be effective but has certain limitations. These limitations become apparent when employed within large enterprise computer systems. For example, even with the aid of automated administration tools, the lifecycle management of two-tiered applications on a large number of different clients is a difficult task. Moreover, the tightly integrated business logic, presentation logic and user interface logic make the program code of such applications very complex, hard to maintain, and prone to errors. For example, a change to the user interface would require changes in business logic and presentation logic, and vice versa.","In the enterprise world, the established business rules change dynamically due to factors such as changes in statutory requirements, market developments, etc. Consequently, there are frequent requirements to change the existing software applications or install new software applications that provide certain enterprise services or that support specific business processes. Therefore, a more flexible architecture for building computer systems is appropriate.","To overcome the limitations associated with the two-tiered client-server architecture model, a multi-tiered architecture model for building computer systems has been developed, as illustrated in . In a computer system with multi-tiered architecture, the presentation logic and the business logic are separated from each other and from the user interface. User interface  in client  is connected to presentation layer  via network . Presentation layer  is responsible for the definition and execution of the presentation logic and could be implemented on separate presentation server . Presentation layer  communicates with business layer  that could be implemented on business layer server . Database  provides storage on database server  for data relevant to the application including, user interface , presentation layer  and business layer . Presentation server , business layer server  and database server  could be implemented into one or more dedicated physical servers connected from client  via physical network .","The separation between the logic components and the user interface provides more flexible and scalable architecture for building computer systems, compared to the two-tiered model. For example, if business rules change, only the business logic implemented in business layer  could be changed to a new version without touching the program code on the rest of the levels. In another example, presentation layer  may provide support for a variety of third party user interfaces , e.g., popular browsers such as Internet Explorer\u2122 or Mozilla Firefox\u2122.","The multi-tiered architecture model illustrated in  may be implemented using a variety of different software technologies at each layer or tier, including Microsoft.NET\u2122 technology by Microsoft Corporation, Advanced Business Application Programming (ABAP) technology by SAP AG, etc. One of the most popular software technologies for developing multi-tiered software applications is Java Enterprise Edition\u2122 (Java EE) technology initially introduced by Sun Microsystems Inc. Java EE technology has been further co-developed by many other software vendors, and described in a special set of documentation that is referred to as Java EE Specification in this document. Due to its popularity and extensive use, Java EE Specification is publicly recognized as a standard. Therefore, different software developers could build applications compliant with Java EE Specification, and these applications could be executed on computer systems that are compliant with Java EE Specification, e.g., those that provide Java EE environment.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1C","b":["148","142","146","142","132","110","144","142","128"]},"As enterprise application development projects grow larger and more diverse, deployment and maintenance of applications becomes increasingly important. For example, it is useful to have software lifecycle management involving a variety of container services, application programming interfaces (API), transaction management modules, notification systems, resource pooling, and security policy providers. Therefore, software vendors develop deployment tools to ensure such means of lifecycle management of the software applications and their components such as software modules.","In this document, the term \u201cdeploy tool\u201d refers to administrative software application operable to deploying software application components to one or more destination computer systems, such as application server or cluster of application servers running on one or more physical computer servers. There are various requirements for deployment of software applications on particular application servers. These requirements depend on the software technology upon which the application server is built. Respectively, deployment tools may have to comply with the requirements of a certain application server software technology specification. For example, to deploy software applications on Java EE application server, a deployment tool may have to comply with the deployment requirements established in Java EE Specification.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 2"],"b":["200","203","202","201","213","202","201"]},"In the example illustrated with , various source code files  of modules of an application are passed to archive builder . Archive builder  creates two separate types of archive files. The first type of archive files are with extension \u201c.jar\u201d to indicate Java\u2122 archive (JAR) files that contain business logic software modules. The second type of archive files are with extension \u201c.war\u201d to indicate Web archive (WAR) files that contain World Wide Web (Web) application software modules. JAR files  and WAR files  are then combined into an enterprise archive (EAR) file  by assembler . An archive file is a file that contains other files, e.g., file entries. The file entries in an archive file could be distributed within a directory structure.","Deployer  receives EAR file , analyzes its content, and sends the various pieces to their appropriate destinations. In the simplified illustration of , the content of JAR files  is sent to EJB container , and the content of WAR files  is sent to Web container  of application server . Application server  is assumed to have base environment  that provides a set of services . Containers  and  themselves can be viewed as subordinate environments of base environment , each having additional layer of services , according to Java EE Specification. Additionally, different vendors could introduce containers other than those described by Java EE Specification to provide runtime environment for various other modules of a software application.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2","b":["206","208","209","206","207","209","210","207","210","208","209"]},"The Java EE compliant software applications are deployed on Java EE compliant application servers with the help of a compatible deploy tool. The compatibility of a deploy tool, either vendor specific (e.g., proprietary) or standardized (e.g., publicly recognized), could be ensured by adding a plug-in component. Such plug-in component provides functionality that is required by a deploy tool in order to follow a specific software deployment process. In , for instance, deployer  could be a plug-in component to a third party deploy tool .","The vendors of application servers have to provide reliable and efficient deploy framework for installation and integration of software components. An application server developed by an independent vendor could comply with an established application server specification, but in addition, could include features that are not included in the specification. Accordingly, deploy framework of such an application server has to ensure compliance with deployment requirements of the adopted technology specification, and with the features that are not part of the specification. Based on the specified deployment requirements, and the additional features, different application server vendors provide various proprietary deployment solutions.","Methods and systems for deploying software modules in a computer system are described herein. A number of containers are registered with a deployer. At least one of the containers provides runtime environment for a specific type of software module in the computer system. From an archive file a number of files that contain deployable software modules are extracted. The software modules that correspond to one of the containers are detected based on container specific detecting mechanisms. The detected software modules are validated in order to test their functionality and interoperability. When the software modules are validated, they are distributed for installation in the corresponding containers.","Described below are methods and systems for deploying software modules in a computer system. Throughout the description, for the purpose of explanation, many details pertinent to Java EE Specification are provided. However, as one skilled in the art will understand the principles of the invention may be applied to other software technologies as well.","Software deployment processes typically aim to meet requirements as specified in recognized standards or specifications, e.g., Java EE Specification. The deployment of software components in a computer system ensures efficient implementation and integration of the components within a runtime environment provided by the computer system. The runtime environment of the computer system may be provided by one or more application servers. In one embodiment of the invention, a dedicated deploy service (Deploy Service) of an application server within the computer system conducts the whole process of deployment. Deploy Service preferably complies with the deployment requirements of a recognized specification.","Using Java EE Specification for illustration, Deploy Service could be a core service within a Java EE compatible application server. This core service is responsible for the deployment of Java EE applications and for the distribution of their modules to the corresponding containers of the application server. Deploy Service controls actions that are performed on the software applications during their lifecycle, including requesting containers for information about deployed software components, or initiating a demand to modify deployed software component.","Deploy process may allow using third party deploy tools to deliver software modules for deployment in a computer system. The computer system hosts one or more application servers built upon a standard specification (e.g., Java EE Specification) to provide running environment for the delivered software modules. Deploy Service receives the software modules and conducts the deploy process within an application server. As an application server service, Deploy Service may utilize various mechanisms provided by other services or system components of the application servers (e.g., containers, interfaces, libraries, etc.) during the deploy process. Further, the deploy process may allow deployment of software modules that are developed under different versions of the specification. The detecting and generating mechanisms could handle the discrepancies between versions.","In one embodiment of the invention, the deploy framework can be implemented as a part of SAP NetWeaver\u2122 application server Java\u2122 (AS Java). AS Java is an application server that is compliant with Java EE Specification and includes certain vendor specific features. This deploy framework and the realized deployment process are described in detail in the following paragraphs. Different solutions based either on Java EE Specification or on other application development technologies that embody the invention are also possible and obvious for one of ordinary skill in the art.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["300","305","305"]},"At block , Deploy Service receives an archive file. For example, a user provides an archive file, e.g., an EAR file or standalone module (WAR file, JAR file, etc.) for deployment. Archive files are user entries for Deploy Service. At block , the contents of the received archive file is initially analyzed. As part of this analysis, Deploy Service decides how to handle the deployment of the archive. Furthermore, Deploy Service parses the available metadata that describes the software modules included in the archives Based on the analysis and the parsed metadata, Deploy Service extracts file entries from the archive in a temporary folder in a file system accessible by the application server. The extracted file entries contain the source code of the software modules to be deployed.","Once extracted, the source files describing the software modules could be distributed to the registered containers for deployment. At block , a correspondence is identified between the registered containers and the software modules in the archive. For each container, corresponding software modules are detected. The detection of corresponding software modules could include various methods, e.g., based on metadata provided by deployment descriptors or file annotations, based on file names or file name extensions, based on software module type, etc. Each or some of the registered containers may provide module detector mechanism. Such mechanism is used by Detect Service to check the contents of the extracted files in order to establish correspondence between the container providing the module detector, and a software module.","Additionally, each or some of the registered containers could define a mechanism for generating software modules. At block , Deploy Service generates software modules for each container that have implemented such mechanism, when required. Whether a generation of a module is required or not is determined by one or more logical conditions established by a module generator mechanism implemented in a container. For example, if the received EAR file contains certain type of software modules, additional software modules are created. More specifically, an EJB software module providing Web service could be included in a JAR file, however, a servlet should be available for the Web service to be accessible. Since EJB modules do not contain servlets originally, a new WAR file is generated with the servlet in it. All this logic can be fulfilled with the mechanism for generating a new module. Furthermore, generating mechanism could include logic for removing certain software modules from the deployment process.","After determining the module that have to be deployed in the registered containers, at block , a validation of every module is performed. Validated modules are distributed to their corresponding containers for installation, e.g. technical or actual deployment. The validation of the determined modules includes tasks as checking the correspondence between the metadata and the class files of the software modules. For this purpose, the metadata coming from deployment descriptors have to be merged with the metadata coming from annotations, according to one embodiment of the invention. The output of this merge activity is a container specific model incorporating all descriptive data of the deployable archives Validity checks are executed over the model and once they have passed, the validated model can be given to containers for further usage. An advantage is the fact that model is built and validated once and then simply handed over to containers. Model representations are specific for each container, accordingly each container provides a logic for building the model which is invoked by Deploy Service or by a separate service or library dedicated to software module validation.","To continue with describing the deployment process, a better understanding of the role and structure of the software modules is useful. The software modules are the simplest atomic units that can be deployed on an application server. Java EE Specification identifies four standard module types: \u201cWeb\u201d, \u201cEJB\u201d, \u201cjava\u201d and \u201cconnector\u201d modules. The standard modules to be deployed could be described by metadata included in a deployment descriptor, according to the specification. There are two additional types of standard modules defined in Java EE Specification, i.e. \u201cpersistent unit\u201d and \u201cWeb service\u201d modules. The software modules from the later two types are not described in deployment descriptors. They have to be detected at deploy time based on certain rules. For example, based on file names matching rules.","Additionally, AS Java supports proprietary containers that deploy other module types. Such proprietary containers are not described in Java EE Specification, and therefore are referred to as non-Java EE containers. Respectively, the deployable modules of types that are not defined in Java EE Specification are referred to as non-Java EE modules. There large number of containers that can deploy anything ranging from extensible markup language (XML) configuration files to music files of different formats.","Software modules typically characterized by two common properties: a container type, and a file. During deployment, a software module is distributed to a corresponding container type. One file can contain more than one software module. The software modules of a single file can be deployed on one or more containers of different container types. Hence, it is possible to have one or more software modules with the same file property but with different container types. In general, the software modules define many-to-many relationships between the files within a deployable archive and the containers of one or more application servers in a computer system.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":["400","400","203","425","425","425","425"]},"Application server  could be realized as a standalone system module working on a single physical server. Alternatively, computer system  could include a number of application servers  working simultaneously on one or more physical servers, as illustrated in . Application servers  in computer system  may have similar configuration and all or part of application servers  could operate as a cluster.  illustrates the structure of only one of application servers .","Deploy tool  could be a third party administrative client tool that is operable for a user to deploy software applications. Deploy tool  includes deploy manager  to integrate deploy tool  with application server  to manage the deployment of software modules. Deploy manager  could be a plug-in provided by the vendor of application server to enable third party administrative tools to integrate with the deploy framework. From a user's perspective, deploy manager  handles the lifecycle management of software modules on application servers  in computer system .","Deploy tool  connects to application server  via network , e.g., intranet, Internet, etc. When there are more than one application servers  as illustrated in , the deployment requests of deploy tool  are routed to one of application servers  by load balancer . Application servers  could store shared data on storage . For example, such shared data are the code files of the software modules. Thus, when a software module is deployed on one of application servers , the rest of the clustered application servers  could execute the module from the code files stored on storage . Additionally, each application server could store private data on storage  as well.","The software applications or the software modules to be deployed on application server  are delivered in the form of archive . Archive  could be an enterprise archive (EAR) file. EAR files have extension \u201c.ear\u201d. The deployable software modules are included in one or more file entries  in archive . Archive  also contains other deployment information that is also included as file entries . According to one embodiment, file entry refers to a file that is packed in an archive together with other files. File entries  are packed in archive  within directory structure . Respectively, the packed files are placed in one or more folders within archive .","The software modules delivered with archive  as file entries  are deployed on application servers  by one or more containers  as modules . Containers  provide runtime environment where the deployed software modules are executed. As there are different types of software modules, preferably each container  provides specific environment for a specific type of software module. The Java EE Specification defines several types of containers to provide runtime environment for the specified types of software modules. However, the architecture of application server  could be enhanced by including containers  that are not originally defined in Java EE Specification, e.g., non-Java EE containers. Such non-Java EE or non-standard containers could deploy non-standard software modules, e.g., software modules of types that are not defined in Java EE Specification (non-Java EE).","In order to deploy the software modules in archive  to their corresponding containers , application server  utilizes functionality provided by a deploy framework, according to one embodiment of the invention. The deploy framework of application server  comprises a Deploy Service . Deploy Service  serves to extend and enhance the Java EE compliant architecture of application server . Deploy Service  along with container API  help to deploy the various deployable J2EE and non-J2EE software modules using J2EE and non-J2EE containers , respectively.","Deploy Service  is a core service of application server  and manages containers  via container interface  provided by container API . Container API  could be represented on application server  as an interface defined as a development component. There is a contract established between containers  and Deploy Service  defined by container interface . Deploy Service  conducts deployment process. Generally, Deploy Service  receives archive  for deployment from deploy manager . Then, Deploy Service  invokes and controls the particular steps of the deployment process. The deployment logic as specified is carried out before software modules have actually reached containers .","According to one embodiment of the invention, container API  provides container interface  that is implemented by container services associated with containers . Such implementation facilitates Deploy Service  to identify containers  and to invoke various functionalities of containers . Container API  provides a container management for registration of containers  with Deploy Service . Accordingly, the container services may register their corresponding containers  with Deploy Service  through container API  when containers  become available and are ready to deploy software modules. Additionally, containers  may be unregistered when they stop or become unavailable.","With the registration of container , an object is instantiated to provide information about the registered container. In one embodiment of the invention, such object is \u201ccontainerInfo\u201d. The \u201ccontainerInfo\u201d object instantiated for particular container  may include information for identifying container . Furthermore, \u201ccontainerInfo\u201d object instance may have set of properties with \u201cset\u201d and \u201cget\u201d methods. Some of the properties include:\n\n","During the deployment process, Deploy Service  analyzes the content of archive  to determine the software modules to be deployed and to extract the corresponding file entries. According to one embodiment, such analysis is called byte code analysis and in order to perform it, Deploy Service invokes byte code analyzer . The determination of the relevant software modules could depend on various factors, including Java EE Specification definitions, subscriptions of containers  for files with specific names or extensions, descriptive data, etc. Archive  could contain metadata that is parsed by byte code analyzer . The metadata could provide information about the software modules in archive . Furthermore, metadata could provide important configuration information for the corresponding software modules. The metadata could be extracted from file entries .","After determining software modules to be deployed, Deploy Service  may extract file entries  that represent the determined software modules. The software modules are then delivered for deployment to corresponding containers . According to one embodiment of the invention, file names and file extensions of file entries  may be used by Deploy Service  to identify correspondence between the different software modules and containers . Accordingly, Deploy Service  may automatically recognize container  to which a software component should be distributed based on the data in \u201ccontainerInfo\u201d instances. For example, if a software module file has an extension \u201c.war\u201d (WAR file), and the Java EE \u201cWeb\u201d container  has specified this extension in its \u201ccontainerInfo\u201d instance, Deploy Service  may distribute the WAR file to \u201cWeb\u201d container.","Some containers  define a more complex mechanism for detecting corresponding software modules for deployment. Such containers  implement module detector . Module detector  is a mechanism that, when invoked by Deploy Service , performs predefined dynamic analysis of file entries  to identify corresponding software modules. In addition to module detector , some containers  may further implement module generator . Module generator  is a mechanism to generate one or more additional software modules, e.g., class files, under predefined conditions. Module generator  could also be used for removing or ignoring, software modules from the deployment process. When available, module generator  is invoked by Deploy Service . Generating and removing follow predefined logic of module generator . For example, the predefined logic is based on characteristics of a detected software module.","The detected software modules are distributed by Deploy Service  to corresponding containers  for deployment. Before this final step, according to one embodiment of the invention, Deploy Service  invokes validator  to validate each of the detected software modules. Deploy Service  collects data that is required for the tests of validator . Such data includes parsed metadata, e.g., descriptive information and annotations, the detected software modules, and all outside resources referenced by the software modules or the location of these resources. Validator  provides a report showing any encountered error or warning concerning the functionality of the software modules. For each correct software module, Validator  outputs a validated model that is distributed to corresponding container  during deployment of the module.","According to one embodiment of the invention, the deploy framework of application server  is provided by integration between Deploy Service , byte code analyzer , validator , container interface  and registered containers . In addition to container interface , container API  may provide deploy communicator . Deploy communicator  allows bi-directional communication between Deploy Service  and containers . Thus, each container , during registration with Deploy Service , may obtain an instance of deploy communicator  to communicate back with Deploy Service .","Using deploy communicator , containers  may send to Deploy Service  information about their status, to request runtime information, to initiate operations, etc. Such information allows the Deploy Service  to be more efficient in managing the lifecycle of modules  deployed in containers . For example, through deploy communicator , containers  may request Deploy Service  to lock or stop any of modules  when required by a system process by a running software application.","The integration between the elements of the deploy framework of application server  allows the deployment of the software modules included in archive . Software modules  are deployed in containers  as a result of a deployment process that is conducted by Deploy Service  an element of deploy framework.",{"@attributes":{"id":"p-0065","num":"0073"},"figref":"FIG. 5A","b":["500","505"]},"At block , the received archive file is analyzed. The aim of this analysis is to obtain necessary information for the deployment of the application or of the standalone module. Deploy Service performs the analysis and, based on the collected data, decides how to handle the deployment of the archive, e.g., whether annotations should be sought, what data to supply software modules validation, how to distribute software modules to containers, etc. Deployment process  continues at block  with parsing deployment descriptors that are included in the received archive file. For example, Deploy Service parses files \u201cMETA-INF\/application.xml\u201d and \u201cMETA-INF\/application-j2ee-engine.xml\u201d. These files are application deployment descriptors for deploying software modules in Web AS, where the first file is defined by Java EE Specification, and the second file is Web AS specific (e.g., vendor specific).","Deployment descriptors provide configuration information, which is often referred to as metadata. The metadata is parsed to objects for further processing during the deployment. The metadata may describe one or more software modules that are included in the received archive file. Additionally, each container of the application server that is registered with the Deploy Service may subscribe for files with a specific file name or extension, or subscribe for software modules of a specific type.","When a deployment descriptor is not present, and when no container has subscribed for particular software modules, the deployable software modules may be determined according to the following algorithm:\n\n","According to Java EE Specification, \u201cMANIFEST.MF\u201d is a special file that can contain information about the files packaged in a JAR file. By checking the metadata stored in this file, the purpose of the instant JAR file could be identified. The file \u201capplication-client.xml\u201d is a deployment descriptor file for a Java EE client-side software module. The file \u201cEJB-jar.xml\u201d is a deployment descriptor that provides persistence metadata necessary for container managed persistence of EJBs. The path to the metadata files in the JAR or EAR archives compatible with Java EE Specification is \u201cMETA-INF\/\u201d. In other words, the different deployment descriptor files and the manifest file for an application or for a standalone software module could be found in \u201cMETA-INF\u201d directory of the corresponding EAR file or JAR file, respectively.","Determining modules is preferably a functionality of the deploy framework, and more specifically of the Deploy Service. In the described exemplar embodiment, Deploy Service holds information for modules in instance of \u201ccom.sap.engine.services.deploy.ear.Module\u201d class. Going in detail, there are two generic types of software modules: class \u201cJ2EEModule\u201d for the standard software modules types described in Java EE Specification (Web, EJB, Java and Connector) and defined in \u201ccom.sap.engine.services.deploy.ear.J2EEModule.Type\u201d enum (enumerated type); and class \u201cModule\u201d for the other modules.","For a software module from any of the standard types, the class \u201cJ2EEModule\u201d is abstract because one of its successors \u201cJava\u201d, \u201cEJB\u201d, \u201cConnector\u201d or \u201cWeb\u201d classes is instantiated. The software modules represented with instances of \u201cJ2EEModule\u201d class have constructors with parameters \u201cparentTmpDir\u201d and \u201caUri\u201d. The first parameter provides a temporary directory where all module files of the deployable archive should be extracted. The second parameter provides a directory path from the temporary folder \u201cparentTmpDir\u201d to the instant module file. The modules represented with instances of \u201cJ2EEModule\u201d class originating from Web standard module type have constructors with additional parameter \u201caContextRoot\u201d providing reference to the context root.","The modules that are not from one of the four standard types are represented with instances of \u201ccom.sap.engine.services.deploy.ear.Module\u201d class. The class \u201cModule\u201d has constructor with parameters \u201cparentTmpDir\u201d, \u201caUri\u201d and \u201caModuleType\u201d. The parameter \u201caModuleType\u201d provides the name of a container that will deploy the software module represented by a specific instance of the \u201cModule\u201d class. The container has to be registered with the Deploy Service. Table 1 shows example code snippets for defining classes representing deployable software modules:",{"@attributes":{"id":"p-0073","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Module Type","Example Code Snippet"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EJB","public EJB(File parenturiDir, String aUri) {"]},{"entry":[{},"\u2003\u2002..."]},{"entry":[{},"\u2003}"]},{"entry":["Web","public Web(File parentTmpDir, String aUri,"]},{"entry":[{},"String aContextRoot)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2002..."]},{"entry":[{},"\u2003}"]},{"entry":["Non-standard","public Module(File aParentTmpDir, String aUri, String"]},{"entry":["type","aModuleType) {"]},{"entry":[{},"\u2003\u2002..."]},{"entry":[{},"\u2003}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A container subscribes for software modules with particular file names or particular extensions by providing appropriate information (e.g., code) in the configuration information of the container in class \u201ccontainerInfo\u201d. Table 2 shows example code snippets for \u201ccontainerInfo\u201d class, providing subscription for software modules with particular file names and extensions:",{"@attributes":{"id":"p-0075","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Files if present",{}]},{"entry":["in the archive","Example code snippets"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u201cconfiguration\/config.xml\u201d;","ContainerInfo containerInfo = ...."]},{"entry":["\u201cMETA-","containerInfo.setFileNames(new"]},{"entry":["INF\/MANIFEST.MF\u201d;","String[ ]{\u201cconfiguration\/config.xml\u201d,"]},{"entry":["\u201canymodule.mod\u201d;","\u201cMETA-INF\/MANIFEST.MF\u201d, \u201ca\/b\/c\/d.e\u201d,"]},{"entry":["\u201ca\/b\/c\/d.e\u201d","\u201canymodule.mod\u201d});"]},{"entry":["\u201c*.mp3\u201d;","containerInfo.setFileExtensions(new"]},{"entry":["\u201c*.sda\u201d;","String[ ]"]},{"entry":["\u201c*.jar\u201d;","{\u201c.mp3\u201d, \u201c.sda\u201d, \u201c.jar\u201d, \u201c.war\u201d});"]},{"entry":"\u201c*.war\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Another mechanism for determining software modules in a deployable archive is based on rules related to software types, according to an embodiment of the invention. For a particular software module, the Deploy Service tries to determine all containers where the module will be deployed. When such a software module is delivered packed in an SDA file, it might contain additional manifest file in the meta folder of the SDA file \u201cMETA-INF\u201d. In the particular embodiment of the invention within Web AS environment, the additional manifest file is \u201cSAP_MANIFEST.MF\u201d. The file \u201cSAP_MANIFEST.MF\u201d contains many properties, including \u201csoftwaretype\u201d and \u201csoftwaresubtype\u201d.","Containers subscribe for software modules with particular \u201csoftwaretype\u201d or \u201csoftwaresubtype\u201d or both in a way that is similar to the subscriptions for particular file names or extensions. Software modules that have a particular value corresponding to \u201csoftwaretype\u201d or \u201csoftwaresubtype\u201d or both in \u201cSAP_MANIFEST.MF\u201d will be deployed in a container with corresponding configuration information in its \u201ccontainerInfo\u201d class. Table 3 shows an example for a subscription for software modules having particular \u201csoftwaretype\u201d:",{"@attributes":{"id":"p-0078","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Software modules with",{}]},{"entry":["attributes:","Example code snippets"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u201csoftwaretype\u201d set to \u201cFS\u201d:","ContainerInfo containerInfo = ..."]},{"entry":["\u201csotwaretype: FS\u201d","containerInfo.setSoftwareTypes(new"]},{"entry":[{},"String[ ]"]},{"entry":[{},"{\u201cFS\u201d});"]},{"entry":["\u201csoftwaretype\u201d and","ContainerInfo containerInfo = ... {"]},{"entry":["\u201csoftwaresubtype\u201d that cause","\u2003\u2002public boolean"]},{"entry":["method","isSoftwareTypeSupported(String softType,"]},{"entry":["\u201cisSoftwareTypeSupported\u201d","String softSubType) {"]},{"entry":["to return true","\u2003\u2003return"]},{"entry":[{},"\u201cMyPreferedSoftwaresubtype\u201d.-"]},{"entry":[{},"equals(softSubType);"]},{"entry":[{},"\u2003\u2002}"]},{"entry":[{},"\u2003};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Referring back to , at block , deployment process  continues with extracting all software module entries that are determined either based on the metadata stored in the deployment descriptors and the manifest files, or based on the established naming rules based on the subscriptions of the containers for software modules with certain file names and software types. The determined software modules entries or files are extracted in a temporary folder in the computer system where the archive is deployed.","In version 5 of the Java EE Specification a mechanism for adding annotations to the software modules class files is introduced. With the help of the annotations, the developers of Java EE applications can provide the same metadata provided by the deployment descriptors. For the software modules where annotations are allowed, deployment descriptors are optional. When both annotations and deployment descriptors are provided for a software module, the metadata in the deployment descriptors have priority over the annotations.","At block , a decision is taken whether to parse the deployable archive files for annotations. The decision depends on the version of the deployable application or standalone module packed in the received archive. The version of the application, or the standalone module respectively, could be identified from a corresponding deployment descriptor. For applications with Java EE version of the application deployment descriptor (e.g., \u201capplication.xml\u201d) less than version 5, no annotations processing is performed. If application deployment descriptor does not exist or exists with Java EE version 5 or higher, then version checks are performed for each JAR format file with extensions \u201c.war\u201d or \u201c.jar\u201d. Only files with no module deployment descriptor or with module deployment descriptor with Java EE version 5 or higher are sought for annotations. If a module contains a deployment descriptor with Java EE version less than version 5, no annotations are sought in it.","Standalone modules with file extension \u201c.war\u201d or \u201c.jar\u201d may contain annotations. If such a module does not contain a module deployment descriptor or contains one with Java EE version 5 or higher, this module should be processed for annotations. Still, if a module contains two module deployment descriptors and one of them is an old one, no annotations are sought in it.","When the decision is to parse for annotations, the class files in the received archive or the class file for a particular software module, deployment server calls an AS Java library at block , according to one embodiment of the invention. This library is named \u201cByte Code Analysis\u201d (BCAnalysis) and is integrated with the deploy framework. Searching for annotations is an expensive operation that could consume a high amount of time and machine resources. There are several ways to optimize the parsing of annotations during deploy process. For example, BCAnalysis is called once at most for a deployable archives Deploy Service could pass all found annotations to the containers, saving the additional calls which would be performed by each interested container invoking the library on its own. Furthermore, the Container Interface could provide detailed checks which application and standalone modules need for annotations processing. BCAnalysis could search only for a limited set of annotation types, thus saving extra resources for finding annotation types unnecessary for the deployment process.","BCAnalysis library is the component where annotation processing is centralized for all containers and modules. It builds up a tree containing the result for the whole application. Deploy Service creates a class loader for all standard, predefined annotations. Then it creates an instance of \u201cReaderFactory\u201d object and initializes it with the created class loader. The instance of \u201cReaderFactory\u201d object could be supplied with a filter for annotation types to be processed. On deployment, Deploy Service instantiates \u201cClassInfoReader\u201d object from the factory and provides it one or more software modules files. As an output an instance of \u201cReadResult\u201d object is produced, which keeps the whole processed information into a tree structure. The \u201cReadResult\u201d instance is returned to Deploy Service at block . Objects \u201cReaderFactory\u201d, \u201cClassInfoReader\u201d and \u201cReadResult\u201d are classes of AS Java engine.","When the decision at block  is not to parse annotations, the BCAnalysis is not invoked and respectively, deploy server does not receive any additional metadata.",{"@attributes":{"id":"p-0086","num":"0100"},"figref":["FIG. 5B","FIG. 5A"],"b":"540"},"At block , the deployment process continues with selecting a container from the containers that are registered with Deploy Service. For the selected container, a check is performed at block  whether it is a container defined by Java EE Specification, or a vendor specific container, e.g., whether it is a standard or non-standard container. Standard containers deploy standard Java EE software modules, including \u201cEJB\u201d, \u201cWeb\u201d, \u201cJava\u201d and \u201cConnector\u201d modules. All other containers are referred as non standard or non Java EE containers, no matter to what extent they follow the definitions of Java EE Specification.","If the selected container is a Java EE container, the received archive is checked for existing deployment descriptor (DD) at block . In one embodiment of the invention, the folder \u201cMETA-INF\u201d of the received archive is searched for file \u201capplication.xml\u201d. According to Java EE Specification, standard deployment descriptor \u201capplication.xml\u201d, if present, specifies all software modules in the application to be deployed. Respectively, there is no need to detect the software modules to be deployed in a Java EE container if they are specified in an available deployment descriptor.","If the selected container is not a Java EE container, or if there is no deployment descriptor in the received archive, deployment process continues at block . For each container there are software modules matching rules defined either by Java EE specification or by a subscription. The matching rules could define correspondence between the selected container and software modules having class files with specific names or extensions, or having predefined software types. Based on the matching rules, at block , a set of software modules from the received archive is determined.","At block , a check is performed on whether the selected container has a module detecting mechanism. In this document, module detecting mechanism is also called \u201cmodule detector\u201d. If the selected container has implemented a module detector, at block , Deploy Service invokes module detector to perform its detecting logic for each determined software module. The operations of blocks  through  are executed repeatedly for all registered containers, until, at block , it is confirmed that all registered containers are processed.","Other containers may require more elaborate dynamic checks over archive contents and would examine the archive based on predefined logic implemented in such containers as a mechanism for detecting software modules. For example, a non Java EE container may deploy music files. Existing matching rules may define correspondence between the container and files with extension \u201c.jar\u201d. However, the container is not interested in every file with extension \u201c.jar\u201d in the received archive, but only in those that contain an \u201cmp3\u201d directory. This additional check could be performed by the logic of a module detector implemented in the container.","In another example, to two different Java EE containers correspond to software modules both with extension \u201c.jar\u201d, according to the specified matching rules. The first Java EE container deploys \u201cEJB\u201d Java EE modules. The second Java EE container deploys \u201cjava\u201d Java EE modules. Therefore, a second dynamic check over the contents of the received archive is necessary in order to detect when a software module with a file entry with extension \u201c.jar\u201d have to be deployed on the first or on the second container. A module detector implemented in either of the two containers may check for a presence of a specific deployment descriptor for the module, e.g., check for \u201cMETA-INF\/EJB-jar.xml\u201d for \u201cEJB\u201d module, and \u201cMETA-INF\/application-client.xml\u201d for the \u201cjava\u201d module, respectively. Furthermore, in case a deployment descriptor for a \u201c.jar\u201d module does not exist, the module detector mechanism of one of the containers may check for specific annotations, if present, to decide about the correspondence between the software module and the container.","According to the example embodiment of the invention in AS Java, detailed implementation of a module detector can be found in a container interface class, as shown in table 4:",{"@attributes":{"id":"p-0094","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Class \u201ccom.sap.engine.services.deploy.container.rtgen.ModuleDetector\u201d"},{"entry":"public interface ModuleDetector extends java.io.Serializable {"},{"entry":"\/**"},{"entry":"\u2002\u2009* @param tempDir root dir of extracted EAR file. The detector"},{"entry":"should read its module file from <code>relativeModuleUri<\/code>"},{"entry":"from this dir."},{"entry":"\u2002\u2009* @param moduleRelativeFileUri The relative module file URI."},{"entry":"Detector should read and analyze that file in order to determine"},{"entry":"if this file is a module."},{"entry":"\u2002\u2009* @return The detected module or null."},{"entry":"\u2002\u2009* @throws GenerationException"},{"entry":"\u2002\u2009*\/"},{"entry":"\u2009public abstract Module detectModule(File tempDir, String"},{"entry":"moduleRelativeFileUri) throws GenerationException;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Table 5 illustrates a simple implementation of a module detector for a Java EE container that deploy \u201cWeb\u201d Java EE modules:",{"@attributes":{"id":"p-0096","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class WebModuleDetector implements ModuleDetector {"]},{"entry":[{},"\u2003public\u2003Module\u2003detectModule(File\u2003aTempDir,"]},{"entry":[{},"\u2003String\u2003aModuleRelativeFileUri)"]},{"entry":[{},"throws GenerationException {"]},{"entry":[{},"\u2003\u2003if (!aModuleRelativeFileUri.endsWith(\u201c.war\u201d)) return null;"]},{"entry":[{},"\u2003\u2003StringBuffer contextRoot = new"]},{"entry":[{},"\u2003\u2003StringBuffer(aModuleRelativeFileUri);"]},{"entry":[{},"\u2003\u2003contextRoot.delete(contextRoot.length( ) \u2212 \u201c.war\u201d.length( ),"]},{"entry":[{},"\u2003\u2003contextRoot.length( ));"]},{"entry":[{},"\u2003\u2003return new Web(aTempDir, aModuleRelativeFileUri,"]},{"entry":[{},"\u2003\u2003contextRoot.toString( ));"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The \u201cWeb\u201d Java EE modules reside in JAR compatible archives in file entries with \u201c.war\u201d extension. Hence, the Java EE container that is interested in such software modules should set corresponding matching rule by subscribing for software modules with \u201c.war\u201d file extension. In its module detector implementation, container may incorporate logic for defining a default context root for a \u201cWeb\u201d module. Integrating the module detector of the container could be done by setting it to the \u201cContainerInfo\u201d, as shown in table 6:",{"@attributes":{"id":"p-0098","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ContainerInfo WebInfo = ..."]},{"entry":[{},"WebInfo.setFileExtensions(new String[ ] {\u201c.war\u201d});"]},{"entry":[{},"WebInfo.setModuleDetector(new WebModuleDetector( ));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An example of a module detector that utilizes annotations is illustrated with snippets of pseudo code in table 7. The module detector provides an implementation of a \u201cAnnotationsSupportingModuleDetector\u201d class:",{"@attributes":{"id":"p-0100","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Class"},{"entry":"\u201ccom.sap.engine.services.deploy.container.rtgen.AnnotationsSupportingModuleDetector\u201d"},{"entry":"public\u2003\u2002abstract\u2003\u2002class\u2003\u2002AnnotationsSupportingModuleDetector\u2003\u2002implements"},{"entry":"ModuleDetector{"},{"entry":"\u2003public final Module detectModule(File tempDir, String moduleRelativeFileUri)"},{"entry":"throws GenerationException {"},{"entry":"\u2003\u2003return\u2003\u2003\u2003detectModule(tempDir,\u2003\u2003\u2003moduleRelativeFileUri,"},{"entry":"((DirAnnotation)tempDir).getAnnotations( ));"},{"entry":"\u2003}"},{"entry":"\u2003\/**"},{"entry":"\u2003\u2009* @param tempDir root dir of extracted EAR file. The detector should read its"},{"entry":"module file from <code>relativeModuleUri<\/code> from this dir."},{"entry":"\u2003\u2009* @param moduleRelativeFileUri The relative module file URI. Detector should"},{"entry":"read and analyze that file in order to determine if this file is a module."},{"entry":"\u2003\u2009* @param parsedAnnotations The result from the parsed annotations. If there is no"},{"entry":"need for parsing annotations (J2EE 1.4 and less applications)"},{"entry":"\u2003\u2009*\u2003the\u2003<code>parsedAnnotations<\/code>\u2003will\u2003not\u2003be\u2003null\u2003but\u2003empty"},{"entry":"<code>com.sap.lib.javalang.tool.ReadResult<\/code> object."},{"entry":"\u2003\u2009* @return The detected module or null."},{"entry":"\u2003\u2009* @throws GenerationException"},{"entry":"\u2003\u2009*\/"},{"entry":"\u2003public\u2003\u2003abstract\u2003\u2003Module\u2003\u2003detectModule(File\u2003\u2003tempDir,\u2003\u2003String"},{"entry":"moduleRelativeFileUri,\u2003\u2003ReadResult\u2003\u2003parsedAnnotations)\u2003\u2003throws"},{"entry":"GenerationException;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A module detector as the one illustrated with Table 7 could be used when simple checks over the content of the received deployable archive are not sufficient to determine a correspondence between a container and a software module. For example, when deploying \u201cEJB\u201d modules, a module detector of a Java EE container would check if \u201cMETA-INF\/EJB-jar.xml\u201d module deployment descriptor is present in a JAR file of a module. If the deployment descriptor is present, then the module is regarded as \u201cEJB\u201d. However, if such deployment descriptor does not exist, the software module with file with extension \u201cjar\u201d could be either \u201cEJB\u201d or \u201cJava\u201d module, or just a class library which is not an application software module. To determine if there is a correspondence between the software module and the Java EE container, the module detect mechanism may check the parsed annotations for specific entries, as illustrated in table 8:",{"@attributes":{"id":"p-0102","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class EJBModuleDetector extends AnnotationsSupportingModuleDetector {"},{"entry":"\u2003private static final String[ ] EJBJARXML = new String[ ] { \u201cMETA-INF\/EJB-"},{"entry":"jar.xml\u201d, \u201cmeta-inf\/EJB-jar.xml\u201d };"},{"entry":"\u2003\/**"},{"entry":"\u2003\u2009* Checks whether the given archive contains any Enterprise Java Beans. If so -"},{"entry":"\u2003\u2009* generates the corresponding J2EEModule descriptor."},{"entry":"\u2003\u2009*"},{"entry":"\u2003\u2009* @param tempDir"},{"entry":"\u2003\u2009*\u2003\u2003the temporary folder where the .ear file is extracted"},{"entry":"\u2003\u2009* @param moduleRelativeFileUri"},{"entry":"\u2003\u2009*\u2003\u2003the name of the module file"},{"entry":"\u2003\u2009*\/"},{"entry":"\u2003public Module detectModule(File tempDir, String moduleRelativeFileUri,"},{"entry":"ReadResult annotationsMetadata)"},{"entry":"\u2003\u2003\u2003\u2003\u2002throws GenerationException {"},{"entry":"\u2003\u2002try {"},{"entry":"\u2003\u2003\/\/ check for EJB-jar.xml"},{"entry":"\u2003\u2003JarFile jar = new JarFile(tempDir + File.separator + moduleRelativeFileUri);"},{"entry":"\u2003\u2003for (String EJBjar : EJBJARXML) {"},{"entry":"\u2003\u2003\u2002ZipEntry entry = jar.getEntry(EJBjar);"},{"entry":"\u2003\u2003\u2002if (entry != null) {"},{"entry":"\u2003\u2003\u2003return new EJB(tempDir, moduleRelativeFileUri);"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003FileInfo moduleFile = getModuleAnnotations(annotationsMetadata, tempDir,"},{"entry":"moduleRelativeFileUri);"},{"entry":"\u2003\u2003if (moduleFile == null)"},{"entry":"\u2003\u2003\u2002return null;"},{"entry":"\u2003\u2003if"},{"entry":"(moduleFile.getClassLevelAnnotations(AnnotationFilters.STATEFUL).values( ).size( ) > 0"},{"entry":"\u2003\u2003\u2003||"},{"entry":"moduleFile.getClassLevelAnnotations(AnnotationFilters.STATELESS).values( ).size( ) > 0"},{"entry":"\u2003\u2003\u2003||"},{"entry":"moduleFile.getClassLevelAnnotations(AnnotationFilters.MESSAGE_DRIVEN).values ( ).size( ) >"},{"entry":"0) {"},{"entry":"\u2003\u2003\u2002\/\/ workaround for CTS 5 because the application client JAR also contains"},{"entry":"\u2003\u2003\u2002\/\/ classes with the same annotations"},{"entry":"\u2003\u2003\u2002String mainClass = null;"},{"entry":"\u2003\u2003\u2002try {"},{"entry":"\u2003\u2003\u2003mainClass = jar.getManifest( ).getMainAttributes( ).getValue(\u201cMain-Class\u201d);"},{"entry":"\u2003\u2003\u2002} catch (NullPointerException exc) {\/\/$JL-EXC$"},{"entry":"\u2003\u2003\u2003\/\/ nothing to do, probably no manifest"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002if (mainClass == null) { \/\/ no app client"},{"entry":"\u2003\u2003\u2003return new EJB(tempDir, moduleRelativeFileUri);"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return null;"},{"entry":"\u2003\u2002} catch (IOException ioexc) {"},{"entry":"\u2003\u2003throw new GenerationException(\u201cCannot get \u201d + moduleRelativeFileUri + \u201c"},{"entry":"module.\u201d, ioexc);"},{"entry":"\u2003\u2002}"},{"entry":"\u2003}"},{"entry":"\u2003\/**"},{"entry":"\u2003\u2009* @deprecated use filters for module files within EAR file when they are"},{"entry":"\u2003\u2009*\u2003\u2003\u2003\u2003implemented"},{"entry":"\u2003\u2009* @param tempDir"},{"entry":"\u2003\u2009* @param moduleRelativeFileUri"},{"entry":"\u2003\u2009* @param files"},{"entry":"\u2003\u2009* @return"},{"entry":"\u2003\u2009*\/"},{"entry":"\u2002private FileInfo getModuleAnnotations(ReadResult annotationsMetadata, File"},{"entry":"tempDir, String moduleRelativeFileUri) {"},{"entry":"\u2003\u2002FileInfo[ ] files = ((FolderInfo)"},{"entry":"annotationsMetadata.getProcessedFiles( )[0]).getFiles( );"},{"entry":"\u2003\u2002FileInfo moduleFile = null;"},{"entry":"\u2003\u2002String moduleFullPath = new File(tempDir,"},{"entry":"moduleRelativeFileUri).getAbsolutePath( );"},{"entry":"\u2003\u2002for (FileInfo fileInfo : files) {"},{"entry":"\u2003\u2003if (moduleFullPath.equals(fileInfo.getFullPath( ))) {"},{"entry":"\u2003\u2003\u2002moduleFile = fileInfo;"},{"entry":"\u2003\u2003\u2002break;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002return moduleFile;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"For the Java EE container implementing the module detector shown in Table 8, the class \u201cContainerInfo\u201d may contain definitions illustrated with the code snippets in the following Table 9:",{"@attributes":{"id":"p-0104","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ContainerInfo EJBInfo = ..."]},{"entry":[{},"EJBInfo.setFileExtensions(new String[ ] {\u201c.jar\u201d});"]},{"entry":[{},"EJBInfo.setModuleDetector(new EJBModuleDetector( ));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In addition to module detectors, some of the registered containers may implement mechanisms for generating new modules during the deployment process, according to one embodiment of the invention. In this document, a mechanism for generating new software modules is called \u201cmodule generator\u201d. In addition to generating modules, a module generator implemented in a container may remove some of the modules delivered with the received archive.","For example, according to Java EE Specification, Web services container deploy software modules containing Web services. Web services could be provided with \u201cEJB\u201d software modules and with \u201cWeb\u201d software modules. Therefore, the module detector of the Web services container would detect correspondence between the container and modules with files with extensions \u201c.war\u201d and \u201cjar\u201d containing Web services. A servlet should be available for the Web services included in the detected WAR and JAR files to be accessible. Each WAR file containing \u201cWeb\u201d software module provides such a servlet originally. However, JAR files that contain \u201cEJB\u201d modules do not contain servlets. Therefore, for each \u201cEJB\u201d software module, a new WAR file is generated containing \u201cWeb\u201d module with the necessary servlet in it to provide access to the Web service in the \u201cEJB\u201d module.",{"@attributes":{"id":"p-0107","num":"0121"},"figref":["FIG. 5C","FIG. 5A","FIG. 5B","FIG. 5C"],"b":["580","500","540","581","583","585"]},"For the selected module, Deploy Service utilizes the module generator to check if generation of a new software module is necessary. This check is illustrated with block  of . If the deployment of the selected software module requires one or more new software modules, the new software modules are generated at block . At block , Deploy Service utilizes module generator to check whether the selected module still have to be deployed or needs to be removed from the deployment process. If the selected module should not be deployed, it is removed at block . According to one embodiment of the invention, the class file specifying the module is removed from the temporary folder where it was previously extracted. The module is not removed from the original archive file.","For example, a vendor specific Web services container has deployed a different, e.g., old versioned, type of files before a certain change in the software versions of Java EE Specification. The old versioned files may be provided with files with extensions \u201c.wsar\u201d. With the adoption of a newer version of Java EE Specification, the vendor specific container have to deploy Web services delivered in files with different format, e.g., WAR files and JAR files. However, it would be desirable if the container continues to be able to deploy Web services delivered with old versioned files. For this reason, according to one embodiment of the invention, container has to detect the software modules in such old versioned files, generate new software modules in new format files from them, and remove the original files. This process is similar to a migration that is implemented in the very beginning of the deployment. Thus, the rest of the deployment logic is cleared from additional checks and different treatments for the different file versions.","Table 10 provides technical details of how modules generator mechanism is implemented in a container in AS Java, according to one embodiment of the invention. In the provided example, the main interface of the module generator is in container interface:",{"@attributes":{"id":"p-0111","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Class \u201ccom.sap.engine.services.deploy.container.rtgen.Generator\u201d"},{"entry":"public interface Generator extends Serializable {"},{"entry":"\u2003\/**"},{"entry":"\u2003\u2009*"},{"entry":"\u2003\u2009* @param tempDir root dir of extracted ear file. The generator should read its"},{"entry":"module file under <code>relativeModuleUri<\/code> from this dir."},{"entry":"\u2003\u2009* <p>The result module files should be written to this folder."},{"entry":"\u2003\u2009* @param moduleRelativeFileUri The relative module file URI triggered this"},{"entry":"generation. Generator should read and analyze that file in order to determine what to"},{"entry":"generate."},{"entry":"\u2003\u2009* @param parsedAnnotations The result from parsed annotations. If there is no need"},{"entry":"for parsing annotations (J2EE 1.4 and less applications)"},{"entry":"\u2003\u2009* the <code>parsedAnnotations<\/code> will be not null but empty"},{"entry":"<code>com.sap.lib.javalang.tool.ReadResult<\/code> object."},{"entry":"\u2003\u2009* @return Description of the generation result. Array of"},{"entry":"<code>com.sap.engine.services.deploy.ear.Module<\/code> objects each of them"},{"entry":"containing the container that should process the generated module"},{"entry":"\u2003\u2009* and relative to <code>tempDir<\/code> URI where module file was generated."},{"entry":"\u2003\u2009* @throws GenerationException"},{"entry":"\u2003\u2009*\/"},{"entry":"\u2003Module[ ] generate(File tempDir, String moduleRelativeFileUri) throws"},{"entry":"GenerationException;"},{"entry":"\u2003\/**"},{"entry":"\u2003\u2009* Called in order to determine is generation needed for the given file corresponding"},{"entry":"to Generators container."},{"entry":"\u2003\u2009* @param moduleRelativeFileUri one of the files corresponding to the Generators"},{"entry":"container."},{"entry":"\u2003\u2009* @return is generation required for this file."},{"entry":"\u2003\u2009* @throws GenerationException"},{"entry":"\u2003\u2009*\/"},{"entry":"\u2003boolean supportsFile(String moduleRelativeFileUri);"},{"entry":"\u2003\/**"},{"entry":"\u2003\u2009* Determines whether file triggered generation should be removed from result EAR"},{"entry":"file"},{"entry":"\u2003\u2009* @param moduleRelativeFileUri one of the files corresponding to the"},{"entry":"<code>Generator<\/code>s container."},{"entry":"\u2003\u2009* @return Whether module corresponding to this file should be removed from result"},{"entry":"EAR file"},{"entry":"\u2003\u2009* @throws GenerationException"},{"entry":"\u2003\u2009*\/"},{"entry":"\u2003boolean removeModule(String moduleRelativeFileUri);"},{"entry":"}"},{"entry":"\u2003\u2002public boolean supportsFile(String filePath) {"},{"entry":"\u2003\u2003return filePath.endsWith(\u201c.bot\u201d) || filePath.endsWith(\u201c.bot1\u201d) ||"},{"entry":"filePath.endsWith(\u201c.bot2\u201d);"},{"entry":"\u2003\u2002}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In example code snippets provided in Table 10, the generator mechanism of a container utilizes a function to check whether a file is supported by the container. It can be a file name or an extension check in the simplest case. However, more specific checks could be added, if the container requires it. The example implementation in Table 10 above shows a case of a container that supports all files with extensions: \u201c.bot\u201d, \u201c.bot1\u201d, \u201c.bot2\u201d.","The logic of the implemented generate mechanism in a container determines whether to perform wither \u201cgenerate\u201d or \u201cremove\u201d scenarios, or both. Table 11 below illustrates an example where \u201cgenerate\u201d scenario is supported for files with extensions \u201c.bot\u201d and \u201c.bot1\u201d. If such files exist in the deployable archive, Deploy Service utilized the module generator mechanism of the container to physically create new files and to return modules for them. These new modules are then added to the list of modules designated for the container:",{"@attributes":{"id":"p-0114","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003public Module[ ] generate(File tempDir, String moduleRelativeFileUri)"},{"entry":"throws GenerationException {"},{"entry":"\u2003\u2002Module[ ] result = new Module[0];"},{"entry":"\u2003\u2002try {"},{"entry":"\u2003\u2003if (moduleRelativeFileUri.endsWith(\u201c.bot\u201d)) {"},{"entry":"\u2003\u2003\u2002result = new Module[2];"},{"entry":"FileUtils.copyFile(test.getFile(\u201cresources\/Deploy\/PreprocessGeneration-"},{"entry":"Test\/EJB.jar\u201d), new File(tempDir,"},{"entry":"\u2003\u2003\u2003\u2002pathToGeneratedEJB));"},{"entry":"\u2003\u2003\u2002result[0] = new Module(tempDir, pathToGeneratedEJB,"},{"entry":"mContainer.getName( ));"},{"entry":"FileUtils.copyFile(test.getFile(\u201cresources\/Deploy\/PreprocessGeneration-"},{"entry":"Test\/Web.war\u201d ), new File(tempDir,"},{"entry":"\u2003\u2003\u2003\u2002pathToGeneratedWeb));"},{"entry":"\u2003\u2003\u2002result[1] = new Module(tempDir, pathToGeneratedWeb,"},{"entry":"mContainer.getName( ));"},{"entry":"\u2003\u2003} else if (moduleRelativeFileUri.endsWith(\u201c.bot1\u201d)) {"},{"entry":"\u2003\u2003\u2002result = new Module[1];"},{"entry":"FileUtils.copyFile(test.getFile(\u201cresources\/Deploy\/PreprocessGeneration-"},{"entry":"Test\/EJB.jar\u201d), new File(tempDir,"},{"entry":"\u2003\u2003\u2003pathToGeneratedEJB1));"},{"entry":"\u2003\u2003\u2002result[0] = new Module(tempDir, pathToGeneratedEJB1,"},{"entry":"mContainer.getName( ));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2002} catch (IOException e) {"},{"entry":"\u2003\u2003throw new GenerationException(e.getLocalizedMessage( ), e);"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002return result;"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment of the invention, when a container expects annotations to be present in its corresponding modules, the implemented module generator mechanism may use an abstract class to provide annotations sensitive generate method, as illustrated with the sample code snippets in Table 12 below. Via this method, during \u2018generate\u2019 phase parsed annotations are available to the container and it may decide what modules to generate on this basis:",{"@attributes":{"id":"p-0116","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Class"},{"entry":"\u201ccom.sap.engine.services.deploy.container.rtgen.AnnotationsSupportingGenerator\u201d"},{"entry":"\/**"},{"entry":"\u2002\u2009*"},{"entry":"\u2002\u2009* @param tempDir root dir of extracted ear file. The generator should read its"},{"entry":"module file under <code>relativeModuleUri<\/code> from this dir."},{"entry":"\u2002\u2009* <p>The result module files should be written to this folder."},{"entry":"\u2002\u2009* @param moduleRelativeFileUri The relative module file URI triggered this"},{"entry":"generation. Generator should read and analyze that file in order to determine what to"},{"entry":"generate."},{"entry":"\u2002\u2009* @param parsedAnnotations The result from parsed annotations. If there is no need"},{"entry":"for parsing annotations (J2EE 1.4 and less applications)"},{"entry":"\u2002\u2009* the <code>parsedAnnotations<\/code> will be not null but empty"},{"entry":"<code>com.sap.lib.javalang.tool.ReadResult<\/code> object."},{"entry":"\u2002\u2009* @return Description of the generation result. Array of"},{"entry":"<code>com.sap.engine.services.deploy.ear.Module<\/code> objects each of them"},{"entry":"containing the container that should process the generated module"},{"entry":"\u2002\u2009* and relative to <code>tempDir<\/code> URI where module file was generated."},{"entry":"\u2002\u2009* @throws GenerationException"},{"entry":"\u2002\u2009*\/"},{"entry":"public abstract Module[ ] generate(File tempDir, String moduleRelativeFileUri,"},{"entry":"ReadResult parsedAnnotations) throws GenerationException;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The implementation of a \u201cremove\u201d scenario in an exemplar module generator is illustrated below with the code snippets in Table 13. The \u201cremove\u201d mechanism of module generator does not remove the files of the selected modules physically from the archive, but just ignores them for the particular container. The example logic would remove \u201c.wsar\u201d file of a software module containing Web services:",{"@attributes":{"id":"p-0118","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Class \u201ccom.sap.engine.services.deploy.container.rtgen.Generator\u201d"},{"entry":"\/**"},{"entry":"\u2002\u2009* Determines whether file triggered generation should be removed"},{"entry":"from result EAR file"},{"entry":"\u2002\u2009* @param moduleRelativeFileUri one of the files corresponding to the"},{"entry":"<code>Generator<\/code>s container."},{"entry":"\u2002\u2009* @return Whether module corresponding to this file should be"},{"entry":"removed from result EAR file"},{"entry":"\u2002\u2009* @throws GenerationException"},{"entry":"\u2002\u2009*\/"},{"entry":"\u2003public boolean removeModule(String filePath) {"},{"entry":"\u2003\u2002return filePath.endsWith(\u201c.wsar\u201d);"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Having providing detailed examples for the different cases of module generate mechanism implementation, Table 14 illustrates an assembled example of a module generator:",{"@attributes":{"id":"p-0120","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003private final class FullGenerator implements Generator {"},{"entry":"\u2003\u2002private ContainerInfo mContainer;"},{"entry":"\u2003\u2002public FullGenerator(ContainerInfo aContainer) {"},{"entry":"\u2003\u2003mContainer = aContainer;"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002public Module[ ] generate(File tempDir, String"},{"entry":"moduleRelativeFileUri) throws GenerationException {"},{"entry":"\u2003\u2003Module[ ] result = new Module[0];"},{"entry":"\u2003\u2003try {"},{"entry":"\u2003\u2003\u2002if (moduleRelativeFileUri.endsWith(\u201c.bot\u201d)) {"},{"entry":"\u2003\u2003\u2003result = new Module[2];"},{"entry":"FileUtils.copyFile(test.getFile(\u201cresources\/Deploy\/PreprocessGeneration-"},{"entry":"Test\/EJB.jar\u201d), new File(tempDir,"},{"entry":"\u2003\u2003\u2003\u2003pathToGeneratedEJB));"},{"entry":"\u2003\u2003\u2003result[0] = new Module(tempDir, pathToGeneratedEJB,"},{"entry":"mContainer.getName( ));"},{"entry":"FileUtils.copyFile(test.getFile(\u201cresources\/Deploy\/PreprocessGeneration-"},{"entry":"Test\/Web.war\u201d), new File(tempDir,"},{"entry":"\u2003\u2003\u2003\u2003pathToGeneratedWeb));"},{"entry":"\u2003\u2003\u2003result[1] = new Module(tempDir, pathToGeneratedWeb,"},{"entry":"mContainer.getName( ));"},{"entry":"\u2003\u2003} else if (moduleRelativeFileUri.endsWith(\u201c.bot1\u201d)) {"},{"entry":"\u2003\u2003\u2002result = new Module[1];"},{"entry":"FileUtils.copyFile(test.getFile(\u201cresources\/Deploy\/PreprocessGeneration-"},{"entry":"Test\/EJB.jar\u201d), new File(tempDir,"},{"entry":"\u2003\u2003\u2003\u2002pathToGeneratedEJB1));"},{"entry":"\u2003\u2003\u2002result[0] = new Module(tempDir, pathToGeneratedEJB1,"},{"entry":"mContainer.getName( ));"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003} catch (IOException e) {"},{"entry":"\u2003\u2003\u2002throw new GenerationException(e.getLocalizedMessage( ), e);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return result;"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002public boolean supportsFile(String filePath) {"},{"entry":"\u2003\u2003return filePath.endsWith(\u201c.bot\u201d) || filePath.endsWith(\u201c.bot1\u201d) ||"},{"entry":"filePath.endsWith(\u201c.bot2\u201d);"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002public boolean removeModule(String filePath) {"},{"entry":"\u2003\u2003return filePath.endsWith(\u201c.bot1\u201d) || filePath.endsWith(\u201c.bot2\u201d);"},{"entry":"\u2003\u2002}"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Once a container has implemented a module generator mechanism as shown in Table 14, the ContainerInfo class of the container could be set. The code snippets of Table 15 below illustrate an example of such definition of ContainerInfo. Thus the module generation mechanism of the container is available to the deploy process through Deploy Service:",{"@attributes":{"id":"p-0122","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 15"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ContainerInfo mInfo = ..."]},{"entry":[{},"mInfo.setFileExtensions(new String[ ] {\u201c.bot\u201d, \u201c.bot1\u201d, \u201c.bot2\u201d});"]},{"entry":[{},"mInfo.setGenerator(new FullGenerator(mContainer));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Referring back to , the operations of the deployment process illustrated with blocks  through  are executed repeatedly for all detected software modules that correspond to the selected container, until, at block  it is confirmed that all such modules are processed. Respectively, the operations of the deployment process illustrated with blocks  through  of flowchart  are executed repeatedly for all registered containers, until, at block , it is confirmed that all such containers are processed.","The deploy process continues at block  with validation of the software modules of the received archives According to one embodiment of the invention, after all deployable software modules are determined and the correspondence between the software modules and the containers is detected, the software modules have to be validated by a validation framework. The validation framework could be a library developed in accordance with the requirements of Java EE Specification. In the example implementation of the invention in AS Java, the validation framework is provided by JLinEE class library. JLinEE is a framework for performing validation tests over software modules. The goal is to check their correctness and report problems if there are any. Tests are specific for the different containers, and are usually provided by container developers. JLinEE tests are executed before the deployable modules have been distributed to containers for actual deployment. This way, errors and warnings are issued earlier and without redundant data flow and transactions roll backs.","Deploy Service gathers all data required for the validation and passes it to the validation framework at block . The gathered data may include descriptive information about the software modules or about the application itself, parsed annotations, the software modules of the application, the version of Java EE Specification of the application, the resources rendered from the application, e.g., outside classpath, etc. Furthermore, each container registered with Deploy Service may provide tests for validation of deployment descriptors, parsed annotations, and merged model. Through the validation framework, some of the registered containers will have to perform tests over descriptors and annotations, then merge the metadata coming from both, validate it and check it for correspondence with class files from the archive.","The output form software modules validation is a report with all warnings and errors that have been encountered during the tests. A result info contains errors and warnings, if there any. In case of no errors, a validated model is returned for each deployable software module. The validated models are cached and available to Deploy Service to obtain them, according to one embodiment of the invention. If there are errors, deployment process could be aborted.","After the deployable software modules delivered with the received archive have been validated, their real deployment in the corresponding containers is processed. At block , Deploy Service distributes the software modules files together with the validated models and the metadata for the software modules to the corresponding containers.","Systems and methods consistent with the present invention also include computer readable media that include program instruction or code for performing various computer-implemented operations based on the methods and processes of the invention. The media and program instructions may be those specially designed and constructed for the purposes of the invention, or they may be of the kind well known and available to those having skill in the computer software arts. Examples of program instructions include, for example, machine code, such as produced by a compiler, and files containing a high level code that can be executed by the computer using an interpreter. In this document, the meaning of the term \u201ccomputer readable media\u201d is limited to an article of manufacture for tangibly storing computer-readable instructions.",{"@attributes":{"id":"p-0129","num":"0143"},"figref":"FIG. 6","b":["600","600","605","650","600","640","650","610","615","610","610","615","605","615"]},"According to one embodiment of the invention, computer system  further includes display  to provide visual information to users, input device  to provide a user with means for entering data and interfere with computer system , one or more additional peripherals  to further expand the capabilities of computer system , and network communicator  to connect computer system  to network . The modules of computer system  are interconnected via a bus .","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least embodiment of the invention. Thus, the appearance of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined in any suitable manner in one or more embodiments."],"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
