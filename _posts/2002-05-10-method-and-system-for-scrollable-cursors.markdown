---
title: Method and system for scrollable cursors
abstract: A method and system for implementing scrollable cursors is described. A multi-tier caching structure is maintained, in which a partial result set is cached at the client computer and a more-complete result set is cached at the server computer. If the cursor is scrolled in either the forward or backward directions, the partial result set cached at the client computer is first checked to see if requested data is present. If so, then the requested data is fetched from the client cache and the current position of the cursor is moved to the appropriate position in the result set. If the requested data is not present in the client cache, then those data items are fetched from the cache at the server computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06973457&OS=06973457&RS=06973457
owner: Oracle International Corporation
number: 06973457
owner_city: Redwood shores
owner_country: US
publication_date: 20020510
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND AND SUMMARY","DETAILED DESCRIPTION OF EMBODIMENT(S)","System Architecture Overview"],"p":["Many operations performed on information in a database system are executed using database query language statements, such as statements in the structured query language (SQL). SQL is a non-procedural language for accessing and manipulating data in a relational or object-relational database. Procedural languages, such as PL\/SQL, may also be used to perform operations in a database system. For purpose of illustration, and not by way of limitation, the rest of this document will be explained with reference to SQL statements and relational database structures such as tables and rows. It is noted, however, that the inventive concepts disclosed herein are applicable to other types of objects, structures, and operations in a database.","A cursor is a handle to a query execution area, e.g., an area in memory in which a parsed SQL statement and other information for processing the SQL statement is stored. In many database systems, a cursor is an available resource for accessing or parsing SQL statements embedded within an application. Cursors enable a SQL statement to retrieve rows from a database table into a given result set, which can then be accessed, displayed, or operated upon.","Typically, a defined sequence of actions is performed to execute a SQL query statement. To execute a SQL query statement, the cursor is first created, either in conjunction with the SQL query or independently. The cursor may be automatically handled by the database system, or manually controlled by a programmer through an application programming interface. The SQL statement is thereafter parsed, optimized, and executed to produce a set of rows called the result set. The rows in the result set are retrieved (\u201cfetched\u201d) either a row at a time or in groups. The cursor can be considered the database query and its result set. A final stage for processing the SQL query statement is to close the cursor.","A cursor can often be utilized like a pointer to a specific row in a result set. When the cursor is active, operations can be performed against the specific row or group of rows at which the cursor is pointing. Traditionally, the only allowed movement of the cursor was sequential, starting at the first row retrieved by the query expression and ending with the last row. Each row of data in this approach is fetched, operated upon, and then released in sequential order. This was the approach adopted by the SQL-86 and SQL-89 standards.","The SQL-92 standard describes a type of cursor that can be scrolled in the forward direction. This permits rows in the result to be fetched out-of-order in the forward direction. A recent advance is the backwards scrollable cursor (SQL-99 standard), which allows movement of the cursor in either the forward and backward directions, thereby permitting rows to be accessed in any order. In this approach, the cursor can be moved in any direction to access a row of data, even for data that was earlier fetched. For example, Microsoft Corporation provides an ODBC cursor library for the SQL Server product that allows backward scrolling of a cursor. However, to allow backward scrolling, this approach requires the entire contents of the result set to be cached at the client computer. The drawback is that since the entire result set is cached at the client computer, a large amount of memory is consumed and performance speed is reduced to allow the backward scrolling functionality. This memory overhead can significantly affect performance and scalability at the client computer.","The present invention provides an improved method and system for implementing scrollable cursors. In an embodiment, a multi-tier caching structure is maintained, in which a partial result set is cached at the client computer and a more-complete result set is cached at the server computer. If the cursor is scrolled in either the forward or backward directions, the partial result set cached at the client computer is first checked to see if requested data is present. If so, then the requested data is fetched from the client cache and the current position of the cursor is moved to the appropriate position in the result set. If the requested data is not present in the client cache, then those data items are fetched from the cache at the server computer. In one embodiment, the server computer is itself a client for another server computer, in which each server computer maintains a cache to store a full and\/or partial result set. An indefinitely long chain of server devices can be maintained, corresponding to a chain of caches for storing full or partial result sets.","Further details of aspects, objects, and advantages of the invention are described in the detailed description, drawings, and claims.","The present invention provides an improved method and system for implementing scrollable cursors. According to an embodiment of the invention, a scrollable cursor is implemented using multiple levels of caching to store a result set from a SQL operation. shows an architecture for implementing scrollable cursors according to one embodiment of the invention. In the system shown in , a user at a client computer  initiates a SQL query that is executed at a server . The server  accesses a database  to retrieve data responsive to the SQL query. A server cache  stores a result set for the query. As rows are sent from the server  to client , rows from the result set are also locally cached in client cache . In one embodiment, the server cache  stores at least all the rows seen by the client computer . Some or all of the result set may be cached in client cache , depending upon the size of client cache  and the amount of data in the result set. If the result set is sufficiently large, then only a portion of the result set is cached in client cache . Similarly, some or all of the result set may be cached in server cache . In an embodiment, server cache  is configured to be significantly larger than the client cache. Thus, depending upon the size of the server cache  and any particular result set, it is contemplated that the server cache  may be configured to store an entire result set. Alternatively, server cache  may also be configured to store only a portion of a result set on an as-needed basis.","According to an embodiment, a scrollable cursor provides support for forward and backward access into a result set from a given current position, using either absolute or relative row number offsets into the result set. Consider if the user views the result set in a scrollable window  at client display , in which scrolling the display window causes a corresponding movement for the cursor position. This type of situation exists, for example, in systems configured to conserve network bandwidth by allowing request and transmission of only enough information to be sent that can fit onto a client's display device, page, window, or screen at a particular instance in time. In these systems, additional portions of the requested data are retrieved only if specifically requested, e.g., based upon the user scrolling or paging through the data displayed in the display window.","When the user at client  accesses the result set, the current position of the cursor points at a row or set of rows in the result set. In one embodiment, the current position points at the last row fetched by the client in the fetch call. In practice, this may result from the user viewing that particular row or set of rows on the scrollable display window . There may be additional rows of data in the result set both before and after the current cursor position. The cursor is scrolled in the backward direction to view rows in the result set from before the current position. The cursor is scrolled in the forward direction to view rows in the result set after the current position. It is noted that scrolling a display window is only one of many possible ways to scroll a cursor; another possible approach to make explicit API calls to a database to reposition the cursor.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","i":"b ","b":["140","104","142","104","114","144","104","146","148","106","150","154","152","154","158","160"]},"The advantage of the present approach is that scrollable cursors are enabled while locally caching only a partial result set at the client device . If the partial result set in the client cache  contains rows of data from before and after the current cursor position, both forward and backward scrolling can be immediately satisfied for the locally cached data without requiring the overhead of sending\/receiving roundtrip messages between the client  and server  to fetch additional rows of data. Additional rows of data are fetched from server  only if the appropriate rows of data from the result set are not presently cached in client cache . Since the server  also maintains a full cache for the result, the required rows from the result set can be immediately transmitted to the client, without requiring re-execution of the query to generate data that was previously provided to the client . This is in contrast to database systems that discard data at the server  after it has been sent to the client .","Because memory usage is reduced using the present invention, scrollable cursors are enabled for objects that may require greater memory consumption requirements. For example, many types of complex data objects and user-defined datatypes cause rows in a result set to be significantly larger than for more typical data objects. Under these circumstances, it is impractical to enable scrollable cursors by storing an entire result set into client-side memory. However, the present invention can be utilized to enable scrollable cursors by caching only a portion of the result set in local memory at client cache , with the rest of the result cache remotely cached at the server.","The amount of data to locally store in client cache  is subject to design choice. One factor that can be used to limit or control the amount of data to store in client cache  is to set a maximum number of rows for client cache . Another approach is to limit the amount of memory that can be used in the client cache  to store the partial result set. A combination of these two factors can be used to decide upon the contents of the local client cache .","In one embodiment of the invention, the quantity of data to cache at the server  is also subject to variation. Because of the memory consumption burdens that may be imposed if the entire result set is stored at the server cache , the system can be configured to store only a portion of the result set at the server . Heuristics may be employed to determine the exact portion of the result set that should be cached at server , rather than being discarded. A distribution plan can be implemented to coordinate storing the portion of the result set that is located at the client side versus the portion that is located at the server side. This allows specific partitioning of the result set, e.g., based upon percentage of the entire result set, that should be stored at the various cache locations.","In yet another embodiment, the invention may be configured to entirely discard data at the server once it has been sent to the client , thereby not caching any portion of the result set at the server . This approach may be taken, for example, if the entire result set fits into the allotted space for storing rows in the client cache . It is noted, however, that if data corresponding to a scrolled cursor position is not located in either the client cache  or server cache , then that portion of the result set may have to be re-generated by the SQL execution engine before being fetched, creating additional levels of delay and overhead.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 2","FIG. 2","FIG. 2"],"i":["a ","b ","a ","b"],"b":["2","202","20","24","208","20","30","15","19","202"]},"As previously noted, the client cache  only contains rows  to  of the result set. Here, the display range  corresponding to the new cursor position (rows  to ) falls outside the set of rows that are locally cached in client cache . Therefore, rows  to  must be fetched from the server before the cursor is scrolled to the appropriate position in the result set. Since the entire result set is already cached at the server cache , the specified rows  can be immediately sent from the server to the client without regenerating the data.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 3","FIG. 3","FIG. 3"],"i":["a ","b ","a ","b"],"b":["3","302","20","24","308","18","28","15","19","302"]},"In this example, the client cache  contains rows  to  of the result set. The display range  corresponding to the new cursor position (rows  to ) partially overlaps the set of rows that is locally cached in client cache . In particular, rows  to  of the result set to be displayed are not locally cached at client cache , while rows  and  from display range  are locally cached. Therefore, rows  and  do not have to be fetched from the server since they already exist in the local cache. However, rows  to  must be fetched from the server before the cursor is scrolled to the appropriate position in the result set. Since the entire result set is already cached at the server cache , the specified rows  can be immediately sent from the server to the client, without re-generating the data.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIGS. 4","FIG. 4","FIG. 4"],"i":["a ","b ","a ","b"],"b":["4","402","10","14","408","10","20","15","19","402"]},"The client cache  presently contains rows  to  of the result set, as shown in . Here, the display range  corresponding to the new cursor position (rows  to ) completely overlaps the set of rows that is locally cached in client cache . Therefore, the cursor position can be immediately re-positioned relative to the current position, as appropriate, to form the display range  and the modified display window \u2032. Since the client cache  currently includes all of the rows in the result set necessary to scroll the cursor, no additional rows need to be fetched from the server cache .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIGS. 5","FIG. 5","FIG. 5"],"i":["a ","b ","a ","b"],"b":["5","502","16","18","508","16","18","15","19","502"]},"In this example, the client cache  contains rows  to  of the result set, as previously indicated. The display range  corresponding to the new cursor position (rows  to ) partially overlaps the set of rows that is locally cached in client cache . In particular, row  and row  of the result set to be displayed are not locally cached at client cache , while rows  to  are locally cached. Therefore, rows  and  are fetched from the server before the cursor is scrolled to the appropriate position in the result set. If the entire result set is already cached at the server cache , then the specified rows  and  can be immediately sent from the server to the client. If either row  or row  do not exist in the server cache , e.g., because they have not previously been fetched or server-side cache logic discarded these rows, then the missing row will be generated before being sent to the client.","In this scenario, it can be seen that the display range  completely envelops the set of rows in the client cache , such that rows from both before and after the rows in the client cache  must be fetched from the server before the cursor can be re-positioned. A first approach to handle this situation is to issue two separate fetch statements to the server, with a first fetch to retrieve the rows corresponding to the missing row from before the cache range (row ) and second fetch to retrieve the missing row from after the cache range (row ). A second approach is to issue a single fetch command to retrieve all the rows in the display range, including the rows that already exist in the local client cache . The advantage of the first approach is that since rows \u2013 are not being fetched, less data is transmitted over the network from the server to the client than occurs in the second approach. The disadvantage of the first approach is that two separate fetch commands are issued as opposed to the single fetch command for the second approach, which may result in more roundtrip messaging. Variable system conditions, such as the amount of network traffic, amount of data to retrieve for each approach, the amount of exact fetch commands needed, and the exact quantity of data already cached, will determine which approach provides the greatest benefits.","The range of rows to locally cache at client  may be modified, e.g., if a cache miss occurs. Various approaches may be employed to determine the range of rows to keep in local cache . One approach is to anticipate the possibility that a user will always seek to scroll forward or backward from a current cursor position by a given offset. Under this approach, the ideal range of rows in the local client cache  will extend from the current cursor position and extend at least as far as the anticipated offset in both the forward and backward direction, within the size limitations of the local cache. Another approach assumes that it is more likely that the user will scroll in the forward direction. Under this approach, the range of rows to keep in the local cache will ideally extend at least in the forward direction from the current cursor position. Under either approach, prefetching can be used to retrieve rows of data into client cache , as described in more detail below.","In a scrollable display window, a vertical scrollbar may exist along an outer edge of the display window. Within the scrollbar is a tab that indicates the relative position of the display within the entire result set. In addition, the size of the tab is often configured to reflect the relative size of the display window compared to the entire result set. In conventional systems, two separate operations are typically performed to obtain the relevant information needed to size and position a scrollbar tab. A first SQL statement is used to obtain the size (number of rows) of the result set (e.g., \u201ccount *\u201d) and a second SQL statement is used to actually retrieve the rows in the result set (e.g., \u201cselect *\u201d). Using the present invention, only a single operation is required, since the entire result set is being cached at the server cache . Here, only the operation to retrieve the rows is needed. Once the rows have been cached, the cursor can be positioned at the final row in the result set. By identifying the cursor position at the last row, the count of the number of rows can be inherently made, without performing a separate SQL operation upon the result set. The semantics of the fetching could be either a set of rows or just the last N rows of the result set.","At the server , the rows of the result set can be maintained in a manner that optimizes use of secondary storage. In an embodiment, when the row data overflows from the cache at server , the overflow data is stored in temporary LOBs (large objects that use temporary segments) on disk which do not incur transactional overhead such as redo and undo logging or minimizes the use of such transaction logging. In one embodiment, the duration of this storage is only until the cursor is active on the client. In an embodiment, a B-tree index is employed to track the information stored on the temporary LOBs. If the B-tree index overflows to disk, then the index information can itself be maintained in their own temporary segments.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 6","FIG. 6"],"b":["602","606","610","604","605","602","606","606","610","608","612"]},"Consider the following query, in which first server  issues its own query  to second server  in response to receiving query  from client :\n\n","In an embodiment of the invention, this type of query can be satisfied by either moving the cursor to where the data is located or by moving the data to where the cursor is located. Various efficiency measures may be considered in determining whether the data or the query should be sent to a remote location, e.g., network efficiency or cache usage measures. For example, if the volume of data to be evaluated by the query is much smaller at first server  than at second server , it is likely to be more efficient to send the query and the data from first server  to the second server  for processing. On the other hand, if the volume of data is much greater at first server , then it is likely more efficient to send the data to be considered from second server  to first server  to process the query.","In the embodiment of the invention shown in , first server  requires access to data from second server  to process query . If the query is to be processed at second server  (i.e., a corresponding query  is sent from first server  to second server ), then first server  essentially becomes a client to second server . It is noted that second server  may itself seek to remotely map a query to another server to process the query, which remotely maps the query to another server, etc., in an indefinite chain of remotely mapped queries. When processing remote query , rows of result set  are sent from second server  to first server . The rows in result set  are ultimately sent to client  as part of result set , with additional sorting, ordering, or processing possibly being performed at first server  depending upon the exact requirements of query . Therefore, it is very possible that the fetch commands issued to retrieve rows in result set  will cause corresponding fetch commands sent to second server  to retrieve rows in result set . These fetch commands may occur as a result of manipulating a scrollable cursor at client .","As noted in the previous section, scrollable cursors can be implemented with a two-level cache, in which a partial result set is stored at the client and a full or partial result set is stored at the server. In the example of , since first server  may become a client to second server , a similar multi-level caching arrangement may be implemented between these two servers. In particular, cache  at first server  is configured to store a portion of result set , while cache  at second server  is configured to store part or all of the result set .","If the cursor position is scrolled\/moved at client  beyond the boundaries of cache , then a fetch command may be issued to server . If the fetch command and\/or cursor scroll command extends beyond the data stored in cache  at first server , then first server  could issue another fetch command to second server . Since server second  maintains its own cache  for result set , the requested data can be immediately sent from second server  to first server . If query  causes second server  to issue a query against yet another server, then the above procedure is repeated to this additional server. Potentially, an indefinitely long chain of servers, queries, caches, and cursors could be linked together in this manner.","In one embodiment, cache  is used to store data for both result set  as well as result set . In an alternate embodiment, first server  maintains separate cache areas for these result sets  and .",{"@attributes":{"id":"p-0044","num":"0047"},"figref":["FIG. 7","FIG. 7"],"b":["702","702","702","702","10","12","704","1","14"],"i":["a","a ","a","a ","a "]},"Consider if the user desires to scroll forward through the contents of display window such that rows \u2013 are displayed. Modified display window depicts the effects of this scrolling operation through the result set, in which rows \u2013 are displayed. Internally, the cursor will attempt to move its current position by \u201cfetching\u201d to the appropriate position in the result set.","As before, the client device will first determine whether the client cache contains the appropriate rows from the result set that will allow the cursor to be re-positioned in the desired manner. Here, the client cache does not presently contain the rows from the result set (rows \u2013) that would allow this scrolling operation to proceed. Hence, these needed rows  will be retrieved from the server. Once these rows are retrieved, they can be displayed in display window and the cursor position can be moved to correspond to the new configuration of the display window ","If prefetching is performed, then additional rows  are also retrieved or \u201cprefetched\u201d from the server, even if not explicitly requested at the present time. The rationale is that the present request for a portion of the result set results in a certain amount of overhead, including a given quantity of network roundtrips for the request from client to server as well as the data transmission from server to client. It can be anticipated that at a later point in time, the client will request another portion of the result set to be transmitted from server to client, resulting in further overhead to be expended. This process of making separate requests for data is inefficient if the overhead of separately requesting and sending data in multiple portions is higher than if the data is requested and sent at one time. Moreover, a delay in displaying data exists whenever a cache miss occurs, and this delay\/cache miss can be avoided if the required data was already prefetched and stored in cache.","In the example of , it can be reasonably anticipated that after viewing rows \u2013, the user will scroll through to the next page of results to view rows \u2013, as shown in the modified display window . Therefore, when fetching rows \u2013 () from the server, rows \u2013 () may also be prefetched from the server. These additional rows will be cached in modified client cache . When the user eventually decides to view rows \u2013 in display window , the cursor can be scrolled into the appropriate position and the requested rows immediately displayed, without incurring any additional delays or requiring any additional network roundtrips.","One approach to implement prefetching is to designate a \u201cprefetch count\u201d for a given connection or session from server to client. The prefetch count represents the number of additional rows of data to prefetch in response to an explicit fetch command. For example, if a prefetch count of one is established, then each request for a row from the server results in one additional row being returned, with the prefetched row being the row immediately following the explicitly requested row. If the prefetch count is set to 2, then each request for a row is increased by an additional 2 rows of data, etc. In an embodiment, the prefetch count is a tunable value that can be adjusted based upon current system and network conditions.","One approach for prefetching that can be advantageously used in conjunction with the present invention is disclosed in U.S. patent application Ser. No. 08\/873,644, filed on Jun. 11, 1997, which is hereby incorporated by reference in its entirety. Other approaches to prefetching are described in U.S. application Ser. No. 10\/144,083, entitled \u201cMETHOD AND MECHANISM FOR PIPELINED PREFETCHING\u201d, filed on even date herewith, which is incorporated herein by reference in their entirety.","The execution of the sequences of instructions required to practice the invention may be performed in embodiments of the invention by a computer system  as shown in . In an embodiment of the invention, execution of the sequences of instructions required to practice the invention is performed by a single computer system . According to other embodiments of the invention, two or more computer systems  coupled by a communication link  may perform the sequence of instructions required to practice the invention in coordination with one another. In order to avoid needlessly obscuring the invention, a description of only one computer system  will be presented below; however, it should be understood that any number of computer systems  may be employed to practice the invention.","A computer system  according to an embodiment of the invention will now be described with reference to , which is a block diagram of the functional components of a computer system  according to an embodiment of the invention. As used herein, the term computer system  is broadly used to describe any computing device that can store and independently run one or more programs.","Each computer system  may include a communication interface  coupled to the bus . The communication interface  provides two-way communication between computer systems . The communication interface  of a respective computer system  transmits and receives electrical, electromagnetic or optical signals, that include data streams representing various types of signal information, e.g., instructions, messages and data. A communication link  links one computer system  with another computer system . For example, the communication link  may be a LAN, in which case the communication interface  may be a LAN card, or the communication link  may be a PSTN, in which case the communication interface  may be an integrated services digital network (ISDN) card or a modem.","A computer system  may transmit and receive messages, data, and instructions, including program, i.e., application, code, through its respective communication link  and communication interface . Received program code may be executed by the respective processor(s)  as it is received, and\/or stored in the storage device , or other associated non-volatile media, for later execution.","In an embodiment, the computer system  operates in conjunction with a data storage system , e.g., a data storage system  that contains a database  that is readily accessible by the computer system . The computer system  communicates with the data storage system  through a data interface . A data interface , which is coupled to the bus , transmits and receives electrical, electromagnetic or optical signals, that include data streams representing various types of signal information, e.g., instructions, messages and data. In embodiments of the invention, the functions of the data interface  may be performed by the communication interface .","Computer system  includes a bus  or other communication mechanism for communicating instructions, messages and data, collectively, information, and one or more processors  coupled with the bus  for processing information. Computer system  also includes a main memory , such as a random access memory (RAM) or other dynamic storage device, coupled to the bus  for storing dynamic data and instructions to be executed by the processor(s) . The main memory  also may be used for storing temporary data, i.e., variables, or other intermediate information during execution of instructions by the processor(s) .","The computer system  may further include a read only memory (ROM)  or other static storage device coupled to the bus  for storing static data and instructions for the processor(s) . A storage device , such as a magnetic disk or optical disk, may also be provided and coupled to the bus  for storing data and instructions for the processor(s) .","A computer system  may be coupled via the bus  to a display device , such as, but not limited to, a cathode ray tube (CRT), for displaying information to a user. An input device , e.g., alphanumeric and other keys, is coupled to the bus  for communicating information and command selections to the processor(s) .","According to one embodiment of the invention, an individual computer system  performs specific operations by their respective processor(s)  executing one or more sequences of one or more instructions contained in the main memory . Such instructions may be read into the main memory  from another computer-usable medium, such as the ROM  or the storage device . Execution of the sequences of instructions contained in the main memory  causes the processor(s)  to perform the processes described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and\/or software.","The term \u201ccomputer-usable medium,\u201d as used herein, refers to any medium that provides information or is usable by the processor(s) . Such a medium may take many forms, including, but not limited to, non-volatile, volatile and transmission media. Non-volatile media, i.e., media that can retain information in the absence of power, includes the ROM , CD ROM, magnetic tape, and magnetic discs. Volatile media, i.e., media that can not retain , information in the absence of power, includes the main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise the bus . Transmission media can also take the form of carrier waves; i.e., electromagnetic waves that can be modulated, as in frequency, amplitude or phase, to transmit information signals. Additionally, transmission media can take the form of acoustic or light waves, such as those generated during radio wave and infrared data communications.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example, the reader is to understand that the specific ordering and combination of process actions shown in the process flow diagrams described herein is merely illustrative, and the invention can be performed using different or additional process actions, or a different combination or ordering of process actions. The specification and drawings are, accordingly, to be regarded in an illustrative rather than restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of the invention and, together with the Detailed Description, serve to explain the principles of the invention.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 2","i":["a","b","a","b","a","b","a","b "],"b":["2","3","3","4","4","5","5"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
