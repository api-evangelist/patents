---
title: Computer system operable to revert to a trusted state
abstract: When software is loaded into an operating system kernel and so has access the same memory space as the operating system a problem occurs if the operating system cannot determine in advance whether the operating system will afterwards be in a suitably trusted state or not. By using a high availability cluster in which each System Processing Unit (S, S) has a trusted device, it is possible to gain more trust and a more flexible approach to trust whilst maintaining the high availability properties of the cluster. Software can be loaded onto one of at least two computing platforms (S) of a computing system. Another of the platforms (S) performs integrity tests on the platform (S) carrying the new software to check whether the platform (S) is still in a trusted state. If the tests are passed, then the test results are signed and sent to the platform (S) with the new software and the new software is copied onto the other computing platform (S). If the tests are failed, then the first platform (S) can either be rebooted or returned to the state of the testing platform (S).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06986042&OS=06986042&RS=06986042
owner: Hewlett-Packard Development Company, L.P.
number: 06986042
owner_city: Houston
owner_country: US
publication_date: 20010817
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This invention relates to a computer system operable to perform an operation and revert to a trusted state and to a method of operating a computer system to achieve the same.","A prior patent application, International Patent Application Publication No. WO 00\/48063, entered into the US national phase as U.S. patent application Ser. No. 09\/913,452 and incorporated herein by reference described the use of a Trusted Device (TD) or Trusted Platform Module (TPM) to enable verification of the integrity of computing apparatus by the reliable measurement and reliable reporting of integrity metrics. A TD\/TPM conforms to the Trusted Computing Platform Alliance (TCPA) specification. Extracts of the above patent specification are included in the description. The description enables the verification of the integrity of the apparatus by either a local user or a remote entity. That prior patent application described a general method of reporting integrity metrics and verifying the correctness of the integrity of the computing apparatus by comparing reported values of metrics with proper values of metrics.","A \u201chigh availability cluster\u201d is a grouping of servers having sufficient redundancy of software and hardware components that a failure will not disrupt the availability of computer services. The result of eliminating single points of failure in power, disk, System Processing Unit (SPU), networking, and software is a true high availability cluster, shown in  of the extract from \u201cClusters for High Availability\u201d, annexed hereto at pages 30 to 43 which describes the MC\/ServiceGuard product from Hewlett-Packard which implements a high availability cluster.","A problem arises in cases where software is loaded into an operating system kernel, and so has access to the same memory space as the Operating System (OS), e.g. a kernel-level driver for a peripheral device. The problem occurs if the OS cannot determine in advance (i.e. before loading the software) whether the OS will afterwards be in a suitably trusted state or not. If the OS simply loads the software, the software may infect or cause damage to the running OS, such that the OS cannot detect the damage and can no longer be trusted. The damage cannot be undone, because there is no reliable way to roll back or revert to the previous trusted state of the OS, and the potentially damaged OS could not be trusted to make the decision to roll back or revert even if that were possible.","In the situation described above, a system with a TD cannot load the software without running the risk of ending up in an untrusted state.","It is an object of the present invention to address the problem set out above.","According to a first aspect of the present invention a computer system comprises at least two computing platforms each having a trusted device (TD), the computing platforms having a communications link therebetween, wherein the system is operable","to move one or more applications from a first of the computing platforms to a second of the computing platforms;","to load software onto said first computing platform;","to perform integrity tests on the first platform; and","if the integrity tests are passed the system is operable to move the applications back to the first computing platform and load the software on the second platform; and","if the integrity tests are failed the system is operable to return the first computing platform to the state of the second platform.","The system may be operable to load software unknown to the computer system, which may be unknown in that the software does not have a trusted status with the computer system. The software may be a kernel driver.","The computer system may be operable to perform the integrity tests with the second platform.","The computer system is advantageously operable to load unknown or untrusted software onto one of the computing platforms and to assess the trustworthiness of the software without compromising the trusted state of the computer system as a whole. The trusted state of one of the computing platforms is potentially sacrificed, albeit temporarily, whilst maintaining the functioning capability of the other computing platform. Nevertheless, all clients of the [applications running on the] whole system are directed to the one computing platform which is known to be in a trusted state.","The second computing platform may be operable to digitally sign the results of the integrity tests with its TD, and may be operable to send those results to the first computing platform. The signed results may include the status of the second platform at the time of signing. The first computing platform may be operable to provide the digitally signed results to a third party, on receipt of a request for the digitally signed results.","A third party can thus verify the trustworthiness of the computer system, in particular the first computing platform.","In the event of the first computing platform failing the integrity tests, the first computing platform may be operable to be rebooted. Alternatively, the system may be operable to complete open transactions between third parties and the second computing platform, to save a copy of the active state of the second computing platform and restore that active state to the first computing platform.","According to a second aspect of the present invention a method of maintaining a trusted state in a computer system comprises:","moving one or more applications from a first computing platform having a trusted device (TD) to a second computing platform having a TD via a communications link of the computer system;","loading software onto the first computing platform;","performing integrity tests on the first computing platform; and","if the integrity tests are passed the applications are moved back to the first computing platform and the software is loaded onto the second platform;","if the integrity tests are not passed the first computing platform is returned to the state of the second computing platform.","The software may be unknown to the computer system.","The integrity tests may be performed by the second computing platform.","The tests may involve a comparison with previous results obtained from the first computing platform, or may involve a comparison with the results of the same tests run on the second platform, which is in a trusted state.","The second computing platform may digitally sign the results of the integrity tests with its TD, and may send those results to the first computing platform. The first platform may use the signed results as an integrity metric.","The invention extends to a computer system programmed to perform the method of the second aspect.","A recordable medium carries a program operable to perform the method of the second aspect.","All of the features disclosed herein can be combined with any of the above aspects, in any combination.","The following sections discuss a particular embodiment of the invention with respect to . It should be noted that the architecture described in FIGS. 1 to 6 inclusive is that described in WO 00\/48063 and is not part of this invention: these are included in order to understand better the invention itself.","The embodiment of a trusted platform as described in the prior patent application mentioned above, WO 00\/48063, has as its central feature the incorporation into a computing platform of a physical trusted device (TD) whose function is to bind the identity of the platform to reliably measured data that provides an integrity metric of the platform. The identity and the integrity metric are compared with expected values provided by a trusted party (TP) that is prepared to vouch for the trustworthiness of the platform. If there is a match, the implication is that at least part of the platform is operating correctly, depending on the scope of the integrity metric.","A user verifies the correct operation of the platform before exchanging other data with the platform. A user does this by requesting the trusted device to provide its identity and an integrity metric. The identity metric of the platform as a whole can be obtained by obtaining the identity metric of the individual critical components of the platform from their respective CCRs. (Optionally the trusted device will refuse to provide evidence of identity if it itself was unable to verify correct operation of the platform.) The user receives the proof of identity and the identity metrics of the individual components, and compares them against values which it believes to be true. Those proper values are provided by the TP or another entity that is trusted by the user or can be set by the user himself. If data reported by the trusted device is the same as that provided by the TP, the user trusts the platform. This is because the user trusts the entity. The entity trusts the platform because it has previously validated the identity and determined the proper integrity metric of the platform.","Once a user has established trusted operation of the platform, he exchanges other data with the platform. For a local user, the exchange might be by interacting with some software application running on the platform. For a remote user, the exchange might involve a secure transaction. In either case, the data exchanged is \u2018signed\u2019 by the trusted device. The user can then have greater confidence that data is being exchanged with a platform whose behaviour can be trusted.","The trusted device uses cryptographic processes but does not necessarily provide an external interface to those cryptographic processes. Also, a most desirable implementation would be to make the trusted device tamperproof, to protect secrets by making them inaccessible to other platform functions and provide an environment that is substantially immune to unauthorised modification. Since tamper-proofing is impossible, the best approximation is a trusted device that is tamper-resistant, or tamper-detecting. The trusted devices, therefore, preferably consists of one physical component that is tamper-resistant. Techniques relevant to tamper-resistance are well known to those skilled in the art of security. These techniques include methods for resisting tampering (such as appropriate encapsulation of the trusted device), methods for detecting tampering (such as detection of out of specification voltages, X-rays, or loss of physical integrity in the trusted device casing), and methods for eliminating data when tampering is detected. It will be appreciated that, although tamper-proofing is a most desirable feature of the present invention, it does not enter into the normal operation of the invention and, as such, is beyond the scope of the present invention and will not be described in any detail herein.","The trusted device is preferably a physical one because it must be difficult to forge. It is most preferably tamper-resistant because it must be hard to counterfeit. It typically has an engine capable of using cryptographic processes because it is required to prove identity, both locally and at a distance, and it contains at least one method of measuring some integrity metric of the platform with which it is associated.","A trusted platform  is illustrated in the diagram in . The platform  includes the standard features of a keyboard , mouse  and visual display unit (VDU) , which provide the physical \u2018user interface\u2019 of the platform. This embodiment of a trusted platform also contains a smart card reader \u2014a smart card reader is not an essential element of all trusted platforms, but is employed in various preferred embodiments described below. Along side the smart card reader , there is illustrated a smart card  to allow trusted user interaction with the trusted platform as shall be described further below. In the platform , there are a plurality of modules : these are other functional elements of the trusted platform of essentially any kind appropriate to that platform (the functional significance of such elements is not relevant to the present invention and will not be discussed further herein).","As illustrated in , the motherboard  of the trusted computing platform  includes (among other standard components) a main processor , main memory , a trusted device , a data bus  and respective control lines  and lines , BIOS memory  containing the BIOS program for the platform  and an Input\/Output (IO) device , which controls interaction between the components of the motherboard and the smart card reader , the keyboard , the mouse  and the VDU . The main memory  is typically random access memory (RAM). In operation, the platform  loads the operating system, for example Windows NT\u2122, into RAM from hard disk (not shown). Additionally, in operation, the platform  loads the processes or applications that may be executed by the platform  into RAM from hard disk (not shown).","Typically, in a personal computer the BIOS program is located in a special reserved memory area, the upper 64K of the first megabyte do the system memory (addresses F\u00d8\u00d8\u00d8h to FFFFh), and the main processor is arranged to look at this memory location first, in accordance with an industry wide standard.","The significant difference between the platform and a conventional platform is that, after reset, the main processor is initially controlled by the trusted device, which then hands control over to the platform-specific BIOS program, which in turn initialises all input\/output devices as normal. After the BIOS program has executed, control is handed over as normal by the BIOS program to an operating system program, such as Windows NT (\u2122), which is typically loaded into main memory  from a hard disk drive (not shown).","Clearly, this change from the normal procedure requires a modification to the implementation of the industry standard, whereby the main processor  is directed to address the trusted device  to receive its first instructions. This change may be made simply by hard-coding a different address into the main processor . Alternatively, the trusted device  may be assigned the standard BIOS program address, in which case there is no need to modify the main processor configuration.","It is highly desirable for the BIOS boot block to be contained within the trusted device . This prevents subversion of the obtaining of the integrity metric (which could otherwise occur if rogue software processes are present) and prevents rogue software processes creating a situation in which the BIOS (even if correct) fails to build the proper environment for the operating system.","Although, in the preferred embodiment to be described, the trusted device  is a single, discrete component, it is envisaged that the functions of the trusted device  may alternatively be split into multiple devices on the motherboard, or even integrated into one or more of the existing standard devices of the platform. For example, it is feasible to integrate one or more of the functions of the trusted device into the main processor itself, provided that the functions and their communications cannot be subverted. This, however, would probably require separate leads on the processor for sole use by the trusted functions. Additionally or alternatively, although in the present embodiment the trusted device is a hardware device that is adapted for integration into the motherboard , it is anticipated that a trusted device may be implemented as a \u2018removable\u2019 device, such as a dongle, which could be attached to a platform when required. Whether the trusted device is integrated or removable is a matter of design choice. However, where the trusted device is separable, a mechanism for providing a logical binding between the trusted device and the platform should be present.","The trusted device  comprises a number of blocks, as illustrated in . After system reset, the trusted device  performs a secure boot process to ensure that the operating system of the platform  (including the system clock and the display on the monitor) is running properly and in a secure manner. During the secure boot process, the trusted device  acquires an integrity metric of the computing platform . The trusted device  can also perform secure data transfer and, for example, authentication between it and a smart card via encryption\/decryption and signature\/verification. The trusted device  can also securely enforce various security control policies, such as locking of the user interface.","Specifically, the trusted device comprises: a controller  programmed to control the overall operation of the trusted device , and interact with the other functions on the trusted device  and with the other devices on the motherboard ; a measurement function  for acquiring the integrity metric from the platform ; a cryptographic function  for signing, encrypting or decrypting specified data; an authentication function  for authenticating a smart card; and interface circuitry  having appropriate ports (,  & ) for connecting the trusted device  respectively to the data bus , control lines  and address lines  of the motherboard . Each of the blocks in the trusted device  has access (typically via the controller ) to appropriate volatile memory areas  and\/or non-volatile memory areas  of the trusted device . Additionally, the trusted device  is designed, in a known manner, to be tamper resistant.","For reasons of performance, the trusted device  may be implemented as an application specific integrated circuit (ASIC). However, for flexibility, the trusted device  is preferably an appropriately programmed micro-controller. Both ASICs and micro-controllers are well known in the art of microelectronics and will not be considered herein in any further detail.","One item of data stored in the non-volatile memory  of the trusted device  is a certificate . The certificate  contains at least a public key  of the trusted device  and an authenticated value  of the platform integrity metric measured by a trusted party (TP). The certificate  is signed by the TP using the TP's private key prior to it being stored in the trusted device . In later communications sessions, a user of the platform  can verify the integrity of the platform  by comparing the acquired integrity metric with the authentic integrity metric . If there is a match, the user can be confident that the platform  has not been subverted. Knowledge of the TP's generally-available public key enables simple verification of the certificate . The non-volatile memory  also contains an identity (ID) label . The ID label  is a conventional ID label, for example a serial number, that is unique within some context. The ID label  is generally used for indexing and labelling of data relevant to the trusted device , but is insufficient in itself to prove the identity of the platform  under trusted conditions.","The trusted device  is equipped with at least one method of reliably measuring or acquiring the integrity metric of the computing platform  with which it is associated. In the present embodiment, the integrity metric is acquired by the measurement function  by generating a digest of the BIOS instructions in the BIOS memory. Such an acquired integrity metric, if verified as described above, gives a potential user of the platform  a high level of confidence that the platform  has not been subverted at a hardware, or BIOS program, level. Other known processes, for example virus checkers, will typically be in place to check that the operating system and application program code has not been subverted.","The measurement function  has access to: non-volatile memory  for storing a hash program  and a private key  of the trusted device , and volatile memory  for storing acquired integrity metric in the form of a digest . In appropriate embodiments, the volatile memory  may also be used to store the public keys and associated ID labels \u2013of one or more authentic smart cards that can be used to gain access to the platform .","In one preferred implementation, as well as the digest, the integrity metric includes a Boolean value, which is stored in volatile memory  by the measurement function , for reasons that will become apparent.","A preferred process for acquiring an integrity metric will now be described with reference to .","In step , at switch-on, the measurement function  monitors the activity of the main processor  on the data, control and address lines (,  & ) to determine whether the trusted device  is the first memory accessed. Under conventional operation, a main processor would first be directed to the BIOS memory first in order to execute the BIOS program. However, in accordance with the present embodiment, the main processor  is directed to the trusted device , which acts as a memory. In step , if the trusted device  is the first memory accessed, in step , the measurement function  writes to volatile memory  a Boolean value which indicates that the trusted device  was the first memory accessed. Otherwise, in step , the measurement function writes a Boolean value which indicates that the trusted device  was not the first memory accessed.","In the event the trusted device  is not the first accessed, there is of course a chance that the trusted device  will not be accessed at all. This would be the case, for example, if the main processor  were manipulated to run the BIOS program first. Under these circumstances, the platform would operate, but would be unable to verify its integrity on demand, since the integrity metric would not be available. Further, if the trusted device  were accessed after the BIOS program had been accessed, the Boolean value would clearly indicate lack of integrity of the platform.","In step , when (or if) accessed as a memory by the main processor , the main processor  reads the stored native hash instructions  from the measurement function  in step . The hash instructions  are passed for processing by the main processor  over the data bus . In step , main processor  executes the hash instructions  and uses them, in step , to compute a digest of the BIOS memory , by reading the contents of the BIOS memory  and processing those contents according to the hash program. In step , the main processor  writes the computed digest  to the appropriate non-volatile memory location  in the trusted device . The measurement function , in step , then calls the BIOS program in the BIOS memory , and execution continues in a conventional manner.","Clearly, there are a number of different ways in which the integrity metric may be calculated, depending upon the scope of the trust required. The measurement of the BIOS program's integrity provides a fundamental check on the integrity of a platform's underlying processing environment. The integrity metric should be of such a form that it will enable reasoning about the validity of the boot process\u2014the value of the integrity metric can be used to verify whether the platform booted using the correct BIOS. Optionally, individual functional blocks within the BIOS could have their own digest values, with an ensemble BIOS digest being a digest of these individual digests. This enables a policy to state which parts of BIOS operation are critical for an intended purpose, and which are irrelevant (in which case the individual digests must be stored in such a manner that validity of operation under the policy can be established).","Other integrity checks could involve establishing that various other devices, components or apparatus attached to the platform are present and in correct working order. In one example, the BIOS programs associated with a SCSI controller could be verified to ensure communications with peripheral equipment could be trusted. In another example, the integrity of other devices, for example memory devices or co-processors, on the platform could be verified by enacting fixed challenge\/response interactions to ensure consistent results. Where the trusted device  is a separable component, some such form of interaction is desirable to provide an appropriate logical binding between the trusted device  and the platform. Also, although in the present embodiment the trusted device  utilises the data bus as its main means of communication with other parts of the platform, it would be feasible, although not so convenient, to provide alternative communications paths, such as hard-wired paths or optical paths. Further, although in the present embodiment the trusted device  instructs the main processor  to calculate the integrity metric in other embodiments, the trusted device itself is arranged to measure one or more integrity metrics.","Preferably, the BIOS boot process includes mechanisms to verify the integrity of the boot process itself. Such mechanisms are already known from, for example, Intel's draft \u201cWired for Management baseline specification v 2.0-BOOT Integrity Service\u201d, and involve calculating digests of software or firmware before loading that software or firmware. Such a computed digest is compared with a value stored in a certificate provided by a trusted entity, whose public key is known to the BIOS. The software\/firmware is then loaded only if the computed value matches the expected value from the certificate, and the certificate has been proven valid by use of the trusted entity's public key. Otherwise, an appropriate exception handling routine is invoked.","Optionally, after receiving the computed BIOS digest, the trusted device  may inspect the proper value of the BIOS digest in the certificate and not pass control to the BIOS if the computed digest does not match the proper value.","Additionally, or alternatively, the trusted device  may inspect the Boolean value and not pass control back to the BIOS if the trusted device  was not the first memory accessed. In either of these cases, an appropriate exception handling routine may be invoked.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 6"],"b":"24"},"At the first instance, a TP, which vouches for trusted platforms, will inspect the type of the platform to decide whether to vouch for it or not. This will be a matter of policy. If all is well, in step , the TP measures the value of integrity metric of the platform. Then, the TP generates a certificate, in step , for the platform.","The certificate is generated by the TP by appending the trusted device's public key, and optionally its ID label, to the measured integrity metric, and signing the string with the TP's private key.","The trusted device  can subsequently prove its identity by using its private key to process some input data received from the user and produce output data, such that the input\/output pair is statistically impossible to produce without knowledge of the private key. Hence, knowledge of the private key forms the basis of identity in this case. Clearly, it would be feasible to use symmetric encryption to form the basis of identity. However, the disadvantage of using symmetric encryption is that the user would need to share his secret with the trusted device. Further, as a result of the need to share the secret with the user, while symmetric encryption would in principle be sufficient to prove identity to the user, it would insufficient to prove identity to a third party, who could not be entirely sure the verification originated from the trusted device or the user.","In step , the trusted device  is initialised by writing the certificate  into the appropriate non-volatile memory locations  of the trusted device . This is done, preferably, by secure communication with the trusted device  after it is installed in the motherboard . The method of writing the certificate to the trusted device  is analogous to the method used to initialise smart cards by writing private keys thereto. The secure communications is supported by a \u2018master key\u2019, known only to the TP, that is written to the trusted device (or smart card) during manufacture, and used to enable the writing of data to the trusted device ; writing of data to the trusted device  without knowledge of the master key is not possible.","At some later point during operation of the platform, for example when it is switched on or reset, in step , the trusted device  acquires and stores the integrity metric  of the platform.","When a user wishes to communicate with the platform, in step , he creates a nonce, such as a random number, and, in step , challenges the trusted device  (the operating system of the platform, or an appropriate software application, is arranged to recognise the challenge and pass it to the trusted device , typically via a BIOS-type call, in an appropriate fashion). The nonce is used to protect the user from deception caused by replay of old but genuine signatures (called a \u2018replay attack\u2019) by untrustworthy platforms. The process of providing a nonce and verifying the response is an example of the well-known \u2018challenge\/response\u2019 process.","In step , the trusted device  receives the challenge and creates an appropriate response. This may be a digest of the measured integrity metric and the nonce, and optionally its ID label. Then, in step , the trusted device  signs the digest, using its private key, and returns the signed digest, accompanied by the certificate , to the user.","In step , the user receives the challenge response and verifies the certificate using the well known public key of the TP. The user then, in step , extracts the trusted device's  public key from the certificate and uses it to decrypt the signed digest from the challenge response. Then, in step , the user verifies the nonce inside the challenge response. Next, in step , the user compares the computed integrity metric, which it extracts from the challenge response, with the proper platform integrity metric, which it extracts from the certificate. If any of the foregoing verification steps fails, in steps , ,  or , the whole process ends in step  with no further communications taking place.","Assuming all is well, in steps  and , the user and the trusted platform use other protocols to set up secure communications for other data, where the data from the platform is preferably signed by the trusted device .","Further refinements of this verification process are possible. It is desirable that the challenger becomes aware, through the challenge, both of the value of the platform integrity metric and also of the method by which it was obtained. Both these pieces of information are desirable to allow the challenger to make a proper decision about the integrity of the platform. The challenger also has many different options available\u2014it may accept that the integrity metric is recognised as valid in the trusted device , or may alternatively only accept that the platform has the relevant level of integrity if the value of the integrity metric is equal to a value held by the challenger (or may hold there to be different levels of trust in these two cases).","The techniques of signing, using certificates, and challenge\/response, and using them to prove identity, are well known to those skilled in the art of security and therefore need not be described in any more detail herein.","As indicated above,  shows the flow of actions in an example of verification of platform integrity by a user interacting with the trusted platform with a smart card . As will be described, the process conveniently implements a challenge\/response routine. There exist many available challenge\/response mechanisms. The implementation of an authentication protocol used in the present embodiment is mutual (or 3-step) authentication, as described in ISO\/IEC 9798-3, \u201cInformation technology\u2014Security techniques\u2014Entity authentication mechanisms; Part 3; Entity authentication using a public key algorithm\u201d, International Organization for Standardization, November 1993. Of course, there is no reason why other authentication procedures cannot be used, for example 2-step or 4-step, as also described in this reference.","By using a high availability cluster in which each System Processing Unit (SPU) has a TD, we can gain more trust and a more flexible approach to trust, while maintaining the high availability properties of the cluster. In particular we can\n\n","One of the advantages of this solution is that it exploits the high availability features to improve the trust of the overall system, whereas normally high availability and trust or security features do not interact well and tend to interfere with each other's operations.",{"@attributes":{"id":"p-0093","num":"0095"},"figref":"FIG. 7","b":["1","2","10"],"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":{"@attributes":{"id":"ul0002-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["Additional integrity metrics beyond those described in the TCPA specification. These metrics are determined by a separate platform-in a cluster with two SPU's, S and S, some integrity metrics for S are determined by S. These are heuristic, not absolute tests. Some examples are given below. S digitally signs its test results with its TPM, including the state of S at the time the tests were carried out. S can report the results from S as part of its integrity metrics, when queried by a client.","MC\/ServiceGuard supports \u201crolling upgrades\u201d, see section entitled \u201cRolling Upgrades\u201d in the annexed supporting information on pages 30 to 47."]}}}},"To achieve the roll-back referred to above the following steps are taken.","This can be under the control of S or a management station or a human administrator.\n\n","The result of this sequence is that the cluster, which supports TCPA, is able to load the unknown software (kernel-level driver) into one of its SPUs' OS kernels, run some tests to determine the integrity of that SPU, and depending on the results of that test either effectively roll the whole cluster forward so that software is loaded on all SPUs or roll back to the previous state where the software was not loaded. In either case, at the end of the sequence, all SPUs are able to use the normal TCPA mechanisms to report integrity metrics to a client to prove they are in a suitably trusted state.","The particular relevance of the kernel driver is that it is loaded into a running OS kernel, and that this gives it access to kernel memory, where (if it is malicious or badly designed) it might be able to interfere with data in the kernel and with the kernel's operation and also to interfere with any tests the kernel or applications might carry out to check that the OS and the overall system are in a trusted state and operating correctly. Thus once an untrusted kernel driver is loaded the system must be considered in an untrusted state, and cannot be normally brought back to a trusted state (short of rebooting), even by unloading the untrusted driver (because that wouldn't undo any damage).","As shown in , there must be a communication link  between S and S, and S must be in a known trusted state. The following are heuristic tests-they are not guaranteed to catch all malicious software, and they can be improved upon. Nevertheless, they may provide useful metrics to judge whether or not to trust the platform for certain applications or contexts.","The first test is as follows. Nominate or create a user level service  on S. The test process on S connects to the service and makes a series of requests. The results are compared either with the results from an identical service running on S or with results from running the same test previously when S was in a known trusted state. If the results are significantly different, or the time taken to respond is significantly different, or if S makes network connections or sends network traffic to an unexpected destination (or perhaps to any destination other than S) during or after the test, we may say that S has failed the test and is considered untrusted. As an alternative, if a third machine is available and in a trusted state, it may make the requests to S and S may observe the results and the network traffic.","The second test is as follows. A very simple service  is embedded in the OS kernel  of S. It has direct access to kernel memory, and it responds to a request simply by recovering the value stored in a specific area in kernel memory or a specific table in kernel memory, or by computing a cryptographic hash on an area or table in kernel memory, or by executing the code in a particular area in kernel memory. The area or table or position of the code is contained in the request to the service. The test comprises a number of requests from the test process on S to the embedded kernel service on S. For reasons of speed, the test process may not request all of kernel memory or all tables, but choose a random subset. The results are compared either with results for the same requests on S or with results for the same requests previously sent to S when it was in a known trusted state. In either case, if the unknown software has interfered with sensitive areas of kernel memory on S after being loaded, there is a high probability of detecting this. Since the information about what parts of kernel memory will be checked is nowhere stored on S, it is not possible for the unknown software to have this information and not simple for it to subvert this test. Again, the test process may want to compare not only the results of requests, but also the time taken to respond, and even the time taken to respond to requests to the user level service. This helps to detect when the unknown software has tried to subvert the embedded kernel service and made copies of any area of kernel memory it has interfered with, because we would expect kernel memory to expand and the response time to be different.","Although the above has been described with the TCP patent specification and the TCPA specification as an example of a trusted device, the invention is also applicable to other types of trusted computing device.","Annex with Supporting Information","Creating a High Availability Cluster","Eliminating the SPU as a Single Point of Failure","The SPU in an HP 9000 system consists of a group of elements, any of which can fail. The most important are:\n\n","If a failure in one of these components takes place, the system typically undergoes a reboot, after which a system start-up test will map out any failed components. Thus, even the stand-alone system has a degree of availability provided by this self-diagnosis. However, the loss of service during this reboot time may be unacceptable. Moreover, the system must eventually be brought down for repairs, which require additional downtime.","The use of cluster architecture lets you eliminate the SPU as a single point of failure. A cluster eliminates the downtime associated with SPU failure, allowing you to repair or replace failed components without losing service. In an HA duster, one or more systems act as backups to the SPU's of the system on which the application primarily runs. These backup systems can be either active or standby systems. Active systems run their own applications while serving as the backup for another system. Standby systems may be idle until a failover occurs, or they can be used for other processing.",{"@attributes":{"id":"p-0108","num":"0128"},"figref":"FIG. 8"},"The two nodes are connected to each other by a local area network, which allows them to accept client connections and to transmit messages that confirm each other's health. If one node's SPU should fail, the other node can start up after only a brief delay, in a process known as failover. After the failover, clients can access the second node as easily as the first.","The process of failover is handled by special high availability software running on all nodes in the cluster. Different types of clusters use different cluster management and failover techniques. The specific differences in cluster types and their HA software are described in more detail in the chapter \u201cHP's High Availability Cluster Solutions.\u201d","Creating a High Availability Cluster","Note that the data disks are physically connected to both nodes, so that data is also accessible by the other node in the event of failover. Each node in a cluster has its own root disks, but each node may also be physically connected to several other disks in such a way that multiple nodes can access the data. On HP systems, this cluster-oriented access is provided by the Logical Volume Manager. Access may be exclusive or shared, depending on the kind of cluster you are creating. All disks that are intended for cluster use must be connected to the primary node and to all possible alternate nodes.","Implementing the High Availability Cluster","A high availability cluster is a grouping of servers having sufficient redundancy of software and hardware components that a failure will not disrupt the availability of computer services. The result of eliminating single points of failure in power, disk, SPU, networking, and software is a true high availability cluster, shown in .","Creating a High Availability Cluster","In this composite figure (), we see a two-node configuration with a two-LAN grouped subnet and mirrored individual root and data disks. Application programs run as part of packages on each node. If there is a failure of a component on one node, the package may start up on the other node.","The task of implementing this cluster is a fairly straightforward process of configuring hardware and software components. The details vary somewhat, depending on the components you select. Most of the products described in the rest of this book were developed to support this fairly simple cluster model. Although there are differences in the way different kinds of failover behaviour are implemented, the cluster configuration itself remains common to all HA cluster types.","Complete High Availability Solution","To develop a complete high availability solution, you need to maintain high availability within a hierarchy of system levels, some of which go beyond the cluster level. Failures at all levels must be detected quickly and a fast response provided. At the same time, planned maintenance events at all levels must be possible with minimum disruption of service.","The following table shows a hierarchy of system levels where HA planning is necessary.",{"@attributes":{"id":"p-0121","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2.2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Levels of Availability"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["System Level","How High Availability is Achieved"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Cluster Level","Communication among nodes must be highly"]},{"entry":[{},"available. Data must be protected. There"]},{"entry":[{},"must be multiple nodes capable of running"]},{"entry":[{},"applications."]},{"entry":["Server (Host) Level","SPU must be redundant; dual I\/O paths to"]},{"entry":[{},"the data must be provided."]},{"entry":["Operating System Level","Mirroring of system software must be"]},{"entry":[{},"implemented."]},{"entry":["System and Network","Distributed system administration and"]},{"entry":["Management Level","network monitoring tools must be made highly"]},{"entry":[{},"available."]},{"entry":["Transaction Processing","Transaction monitors and all the services they"]},{"entry":["Level","use must be highly available."]},{"entry":["Database Level","Database must be capable of starting up on a"]},{"entry":[{},"different node or must run on more than on"]},{"entry":[{},"node at the same time."]},{"entry":["Application Level","Applications must be robust and capable of"]},{"entry":[{},"recovering from errors. Applications and\/or"]},{"entry":[{},"TP monitors must be capable of switching to"]},{"entry":[{},"another processor."]},{"entry":["Firmware Level","Error correction must be incorporated."]},{"entry":["Hardware Component","Switching techniques must be provided."]},{"entry":"Level"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"HP's High Availability Cluster Components","Choosing HA Architectures and Cluster Components","The cluster shown so far in this book is a generic loosely coupled grouping of HP 9000 systems. In fact, each SPU can be connected to another SPU in a variety of highly available cluster configurations. Three basic types are:\n\n","The following sections describe HP's implementations of each of these cluster architectures.","Active\/Standby Configurations Using MC\/ServiceGuard","A flexible active\/standby configuration is provided by MC\/ServiceGuard, which allows the application to start on the standby node quickly, without the need for a reboot. In addition, non-MC\/ServiceGuard applications run on the alternate system and continue running after failover.  shows a two-node active\/standby configuration using MC\/ServiceGuard. Applications are running on node , and clients connect to node  through the LAN.","In this configuration, the first node is running the application, having obtained exclusive access to the data disks. The second node is essentially idle, though the operating system and the high availability software are both running.","The state of the system following failover is shown in . After failover, the applications start up on node  after obtaining access to the data disks. Clients can reconnect to node .","Note that failure is not necessary for a package to move within the cluster. With MC\/ServiceGuard, the system administrator can move a package from one node to another at any time for convenience of administration. Both nodes remain up and running following such a voluntary switch.","Choosing HA Architectures and Cluster Components","The primary advantage of the active\/standby configuration is that the performance of the application is not impaired after a switch to the standby node; all the resources of the standby node are available to the application.","Active\/Active Configurations Using MC\/ServiceGuard","In the active\/active configuration, two or more SPUs are 0\u2014physically connected to the same data disks, and if there is a failure of one SPU, the applications running on the failed system start up again on an alternate system. In this configuration, application packages may run on all nodes at the same time.  shows a two-node active\/active configuration before the failure of one host. Different applications are running on both nodes.",{"@attributes":{"id":"p-0135","num":"0158"},"figref":"FIG. 13","b":"1"},"In the active\/active configuration, MC\/ServiceGuard does not use a dedicated standby system. Instead, the applications that were running on the failed node start up on alternate nodes while other processing on those alternate nodes continues.","How MC\/ServiceGuard Works","Applications, together with disk and network resources used by applications, are configured in packages which can run on different systems at different times. Each package has one or more application services which are monitored by MC\/ServiceGuard; in the event of an error in a service, a restart or a failover to another node may take place. A particular benefit of MC\/ServiceGuard is that you can configure failover to take place following the failure of a package, or following the failure of individual services within a package. You can also determine whether to try restarting services a number of times before failover to a different node.","With MC\/ServiceGuard there need not be any idle systems; all of the nodes can run mission critical applications If one node fails, the applications it supports are moved and join applications that are in progress on other other nodes.","Under normal conditions, a fully operating MC\/ServiceGuard cluster simply monitors the health of the cluster's components while the packages are running on individual nodes. Any node running in the MC\/ServiceGuard cluster is called an active node. When you create the package, you specify a primary node and one or more adoptive nodes. When a node or its network communications fails, MC\/ServiceGuard can transfer control of the package to the next available adoptive node.","The primary advantage of the active\/active configuration is efficient use of all computing resources during normal operation. But during a failover, performance of applications on the failover node will be somewhat impacted. To minimize the impact of failover on performance, ensure that each node has the appropriate capacity to handle all applications that might start up during a failover situation.","Use of Relocatable IP Addresses","Clients connect via LAN to the server application they need. This is done by means of IP addresses: the client application issues a connect ( ) call, specifying the correct address. Ordinarily, an IP address is mapped to an individual hostname that is, a single HP-UX system. In MC\/ServiceGuard, the IP address is assigned to a package and is temporarily associated with whatever host system the package happens to be running on. Thus the client's connect ( ) will result in connection to the application regardless of which node in the cluster it is running on.",{"@attributes":{"id":"p-0144","num":"0167"},"figref":"FIG. 14","b":["1","1"]},"After a failure on node , the package moves over to node . The resulting arrangement of packages is shown in . Note that the IP address of the package is the same.","The key benefit of using relocatable IP addresses with packages is transparency. The client is unconcerned with which physical server is running a given application. In most cases, no client or server code changes are needed to take advantage of relocatable IP addresses.","Application Monitoring","Central to the functioning of MC\/ServiceGuard is the monitoring of user applications. When a package starts, its applications are started with a special cluster command that continues to monitor the application as long as it is running. The monitor immediately detects any error exit from the application and alerts MC\/ServiceGuard. Depending on the kind of error condition, MC\/ServiceGuard can restart the application, halt the application, or fail it over to a different node.","Fast Recovery from LAN Failures","MC\/ServiceGuard monitors the status of the LANs used within each node of the enterprise cluster. If any problem affects the LAN, MC\/ServiceGuard will quickly detect the problem and activate a standby LAN within the same node. This detection and fast switch to an alternate LAN is completely transparent to the database and attached clients. This feature eliminates the downtime associated with LAN failures and further strengthens the enterprise cluster environment for supporting mission critical applications.","Workload Balancing","The use of application packages provides an especially flexible mechanism for balancing workload within the cluster after a node failure. Individual application packages within a single node can be moved to different alternate nodes, distributing the workload of one node across the surviving nodes of the cluster. For example, a cluster with four nodes is configured and each node is running three packages. If a node fails, each of the three packages running on that node can be moved to a different node. This distributes the workload of the failed node among all of the remaining nodes of the cluster and minimizes the performance impact on the other applications within the cluster.","This same package capability also allows the workload of a cluster to be balanced according to the processing demands of different applications. If the demand of one application package becomes too high, the system administrator can move other application packages on the same node to different nodes in the cluster by using simple commands, thus freeing processing power on that node for meeting the increased demand.","Workload tuning within individual nodes of an enterprise cluster can be further refined by using HP's Process Resource Manager (HP PRM), described in a later section.","Rolling Upgrades","Another useful feature of MC\/ServiceGuard is the ability to upgrade the software on a given node including the operating system and the high availability software\u2014without bringing down the cluster. You carry out the following steps for every node in the cluster:\n\n","When using this feature of MC\/ServiceGuard, you must carefully plan the capacity of the nodes in the cluster so that moving an application from one node to another during upgrades will not degrade performance unacceptably.","Parallel Database Configuration Using MC\/LockManager","In the parallel database configuration, two or more SPUs are running applications that read from and write to the same database disks concurrently. This is the configuration used on HP clusters by Oracle Parallel Server (OPS), a relational database product provided by Oracle Corporation. OPS works in conjunction with HP's MC\/LockManager software.","In the event one MC\/LockManager node fails, another is still available to process transactions while the first is serviced."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Preferred embodiments of the present invention will now be described, by way of example only, with reference to the accompanying drawings, of which:",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
