---
title: Communication protocol between a high-level language and a native language
abstract: A system and a method are disclosed for communicating between two programming languages on a client device. Commands in a high-level language are encoded as character string containing a series of numbers separated by delimiters, with each component of the command encoded as a different number. The encoded character strings are passed to compiled code that runs natively on the client device, and the native code decodes the character strings into corresponding native commands and executes the native commands. This communication protocol allows applications written in high-level code to perform functions that are typically set aside for native code, such as communicating with web servers and modifying files saved in memory. High-level code may also be transferred to client devices without being subjected to the restrictions that some operating systems place on the transfer for application binaries, which allows application developers to automatically send application updates to users.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959492&OS=08959492&RS=08959492
owner: NgMoco, LLC
number: 08959492
owner_city: San Francisco
owner_country: US
publication_date: 20111213
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/422,843, filed Dec. 14, 2010, which is incorporated by reference in its entirety.","1. Field of Art","The disclosure generally relates to the field of programming languages and more specifically to communicating between two different programming languages.","2. Description of the Related Art","Software applications are typically released and distributed as binary executable files. Developers compile code into a binary executable file, and users download and run the compiled application binary on their client devices. A similar process of compiling before public release is used to distribute updates and patches to software application. While this process allows developers to protect their source code and provides users with an executable that runs natively on their client devices, the process also comes with a number of restrictions and drawbacks that make it unappealing for certain platforms.","One drawback is that some operating systems place restrictions on the transfer of executable binaries to client devices as a method of preventing users from running unauthorized code. Operating system developers may put these restrictions in place as a safeguard against the spread of viruses or other malicious code, or they may simply use these restrictions as a way of exerting more control over the operating system. In some cases, the operating system may include a centralized distribution service to manage the distribution of executable binaries, and the binaries being distributed may be subject to review and approval by administrators of the distribution service. For example, the APPLE iOS mobile operating system includes an APP STORE for distributing applications and updates, and content posted to the APP STORE undergoes an approval process before being distributed to users. In other cases, the operating system allows the user to freely download executable binaries, but the operating system may prompt the user for an administrator password or some other sort of authorization before executing a new application or applying an update to an existing application.","These restrictions make it difficult for software developers to distribute executable binaries. In particular, the process of releasing and distributing updates and patches may become significantly slower if the update is subject to a review process or if the update requires user authorization before being applied. As a result, it is difficult to rapidly distribute updates to users. In addition, if a developer wishes to distribute an update that is customized to a user's device configuration, location, or demographic information, each permutation of the customized update may have to undergo the review process before being distributed.","The Figures (FIGS.) and the following description relate to preferred embodiments by way of illustration only. It should be noted that from the following discussion, alternative embodiments of the structures and methods disclosed herein will be readily recognized as viable alternatives that may be employed without departing from the principles of what is claimed.","Reference will now be made in detail to several embodiments, examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality. The figures depict embodiments of the disclosed system (or method) for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein.","Configuration Overview","Instead of distributing executable binaries, applications and updates may be written and distributed to client devices in a high-level language, such as JavaScript. To run the high-level applications, users install an application client module on their client devices. The application client module implements a communication protocol that allows the high-level language to communicate with compiled code that runs natively on the client device. The communication protocol allows high-level applications to access system resources that are typically reserved for native code, such as networking devices and physical sensors. As a result, applications written in the high-level language may perform tasks that are normally restricted to an executable application binary, which allows a high-level application to provide a user experience that is similar to the user experience of a binary application.","The communication protocol operates by encoding high-level commands as character strings containing a series of numbers and control characters. Each number represents a different component of a command, such as a class identifier, a method identifier, and one or more parameters that are passed into the method. Encoded character strings are sent to a different component of the application client module that decodes the character strings into native commands and executes the commands. To reduce the complexity of the high-level code and thus reduce the computing resources that are used to operate the communication protocol, the application client module also contains several application programming interfaces (APIs) that allow provide simplified commands for accessing system resources such as the graphics processor, physical sensors, and network interface. The native code may also use the communication protocol to issue commands to the high-level code.","Since the encoding and decoding processes for a command use a significant amount of computing resources, the application client module may also implement a queuing mechanism to encode and decode several commands at once. In one embodiment, high-level commands that are issued during a predetermined time interval, called a processing frame, are added to a queue in the order in which the commands are issued. At the end of the processing frame, the commands in the queue are encoded as character strings. The character strings are subsequently decoded into native commands and the native commands are executed in the same order in which the corresponding high-level commands were added to the queue. This queuing mechanism allows the application client module to improve performance by encoding and decoding multiple commands at once while still preserving the original order of the high-level commands.","By distributing executable content in a high-level language, the content is not subject to restrictions that an operating system may place on the distribution of binary applications and updates. When an application or update is transferred to a client device in the high-level language, the operating system interprets the activity as a transfer of data, not a transfer of executable code, and allows the transfer to proceed without imposing the restrictions associated with transferring executable code. As a result, it is possible for high-level applications to check for and apply updates during the application boot process, and it is also possible for developers to provide a customized user experience by automatically distributing high-level updates that are tailored to a user's geographic location, demographic group, device configuration, and other personal information. Although this process of downloading and executing high-level applications may bypass some of the security measures that are integrated into the application distribution system or the operating system, the application client module contains features that preserve the security of the client device by restricting the level of privilege that is granted to individual high-level applications.","Overview of System Architecture",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["102","104","100","100","104","102"]},"The application server  operates server-based services that support the application client module  and any high-level applications that may be saved on the client device . In particular, the application server  makes high-level applications and updates available for distribution to users, so the application client module  may retrieve updates and new applications from the application server  either automatically or in response to a user request. The application server  may also provide additional application-related services, such as application-integrated social networking or data collection and analysis. Although the application server  is depicted as a single entity, the functions of the application server  may be spread over multiple computing devices, computing clusters, or data centers, and the components of the application server  may reside in multiple geographic locations.","The application server  communicates with a plurality of client devices  over the network . The network  may comprise any combination of standard communication technologies and protocols as well-known in the art. For example, communications may be carried over the network  by link technologies such as Ethernet, 802.11, CDMA, 3G, 4G, or digital subscriber line (DSL). The network  may support a plurality of networking protocols, including the hypertext transfer protocol (HTTP), the transmission control protocol\/internet protocol (TCP\/IP), or the file transfer protocol (FTP), and any of the data transferred over the network  may be encrypted with technologies such as transport layer security (TLS), secure sockets layer (SSL), and internet protocol security (IPsec).",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","100","106","108","110","112","114","116","106","108","110","112","114","116","100","118","100","106","108","110","112","114","116"]},"The processor  executes computer-readable instructions. The processor  may access the memory , either to retrieve instructions for execution or to read or write data. Although only a single processor  is shown in , the client device  may contain multiple processors  that may operate in parallel. The client device  may also contain dedicated processors  for graphics processing or audio processing. The memory  is any non-transitory computer-readable storage medium capable of storing data and computer-readable instructions that may be executed by the processor . The memory  may comprise a combination of volatile memory (e.g., random access memory) and non-volatile memory (e.g., hard disk drive, solid state drive, compact discs, magnetic tape). The network interface device  connects to the network  and exchanges data between the network  and the other components of the client device .","The physical sensors  may include any device that monitors the client device's orientation or surroundings. For example, sensors may include an accelerometer, gyroscope, global positioning service (GPS) receiver, compass, or ambient light detector. The physical sensors  may also include devices to record user input to the client device , such as external buttons, a keyboard, a mouse, a touchscreen, or a microphone.","The operating system may provide one or more client device application programming interfaces (APIs)  that allow binary software applications to interact with the physical components of the client device . The operating system may include APIs for interacting with the physical sensors , the network interface device , or output devices such as screens or speakers that may be controlled by dedicated graphics or audio processors .","The application client module  implements a communication protocol that allows one or more applications written in a high-level programming language to communicate with native code. One benefit of the communication protocol is that the protocol allows the high-level applications to perform tasks that are normally reserved for native code, such as modifying other applications saved in the memory  or communicating with the application server  through the network interface device . To streamline the communication between the high-level applications and native code, the application client module  also contains a set of application client APIs that simplify the interaction between the high-level applications and the APIs  provided by the operating system. Although the application client module  is shown as a separate entity, the logic to perform the functions of the application client module  may reside in whole or in part on the processor  or the memory . In addition, all or part of the application client module  may be embodied as a separate hardware device, such as an application specific integrated circuit (ASIC) or field programmable gate array (FPGA).","Application Client Module","Referring now to , illustrated is a detailed view of the application client module  shown in , according to one embodiment. The application client module  may contain, among other components, a boot application , one or more additional high-level applications , a high-level API , a native API , a high-level object registry , a native object registry , an interpreter , and a set of simplified device APIs . Other embodiments of the application client may contain additional, fewer, or different components.","The boot application  is an application written in an interpreted high-level programming language (e.g., JavaScript) that receives a reference to a high-level application ,  and attempts to update the referenced application. After receiving a referenced application, the boot application  queries the application server  to determine whether an updated version of the referenced application is available for download. If the boot application  finds an update on the application server , then the boot application  automatically retrieves and applies the update. The update can be retrieved and applied without any intervention or authorization from the user or the operating system because the update is also written in the high-level language.","When the application client module  receives a request to launch an application , the native API  issues two commands to the boot application . The first command contains a reference to the boot application , which causes the boot application  to update itself. The second command contains a reference to the requested application , which causes the boot application  to update the requested application . The process of updating the boot application  and the requested application  is described in detail with reference to .","The high-level applications  are software applications such as games, image editors, or multimedia playback programs that may be downloaded to the client device . The download may be initiated by a user of the client device  or by another application  within the application client module . Similar to the boot application , the high-level applications  are also written in an interpreted high-level programming language. As used herein, a high-level programming language is any programming language that may be executed by the interpreter  on the client device instead of being compiled before being distributed to the client device (e.g., JavaScript). In addition to the high-level code, applications  may also contain other data items, such as images, videos, audio clips, or plaintext. Since the high-level applications  are written in the high-level programming language, the operating system interprets the download of a high-level application  as the download of a data file. As a result, the download is not subjected to any restrictions that the operating system may place on the download of executable binary applications. Although this might bypass some security functions that may be integrated into the operating system, the interpreter  and the native API  contain security functions that regulate the level of access granted to the downloaded high-level application .","The high-level API  and native API  are application programming interfaces (APIs) that provide a unified interface for the functions in the simplified device APIs . While the APIs ,  contain matching classes and methods, the high-level API  is written in the same high-level language as the boot application  and the other applications , whereas the native API  is a binary that runs natively on the client device . The high-level API  and native API  also contain logic to arrange the commands for a single processing frame in a queue, send the queue to the interpreter  to be encoded as character strings, and decode the character strings back into commands. The encoding functions are described in detail with reference to , and the queuing mechanism is described with reference to . By unifying the functions of the individual simplified device APIs , developers can refer to a single API to interact with the hardware on the client device . This simplifies the development process and reduces the possibility of classes or methods being attributed to the wrong API.","The high-level object registry  and the native object registry  maintain mirrored registries of the live objects in running applications . In one embodiment, objects are initially registered in the high-level object registry  and the entries are subsequently mirrored to the native object registry . The process of registering new objects and mirroring objects between the two registries ,  is described in detail with reference to .","The interpreter  loads and executes high-level code, such as the code in the boot application , the other applications , and the high-level API . When an application ,  includes a command that is to be executed by native code, the interpreter  encodes the command and sends the command to the native API  to be decoded and executed. There are two separate instances of the interpreter . An application interpreter A has low privilege access to the client device . For example, the application interpreter A may be able to access on-screen graphics, user interface (UI) and audio functions, and other application-related functions. Meanwhile, a system interpreter B has high privilege access to the client device , including access to parts of the client device  that may cause system instability. For example, the system interpreter B may use the network interface  to transfer authentication credentials to the application server  or modify the boot application  or the other applications  that are stored in the memory .","Since the boot application  makes frequent use of high-privilege functions, such as accessing the application server  and modifying the applications ,  stored in the memory , the boot application  is executed by the system interpreter B. Other applications  are executed by the application interpreter A. If one of the other applications  includes a command that is to be executed with high privilege, the application interpreter A sends the command to the native API , and the native API  determines whether the command should be allowed. For example, the native API  may allow the execution of a command to retrieve social networking data from the application server , but the API  may not allow an application  to execute a command to arbitrarily modify or erase another application . If the native API  allows a high privilege command to execute, then the command is routed to the system interpreter  for execution. This configuration allows the applications  to access high privilege functions of the client device  while still maintaining the security of the client device  by providing protection against improper and potentially harmful high privilege commands.","The simplified device APIs  provide a simplified interface that high-level applications , can use to interact with the client device APIs  provided by the operating system. For example, the simplified graphics API A may provide a simple way to position an image on the screen with a single command, whereas placing the same image in the same position on the screen may require a complex series of calls to the appropriate graphics API in the client device APIs . In addition, the application client module  may implement different versions of the simplified device APIs  to interact with the client device APIs  on different client devices . For example, the graphics API in APPLE iOS may require a first series of commands to position an image on the screen, whereas positioning the image using the graphics API in the GOOGLE ANDROID operating system may require a second series of commands that is different from the first series of commands. In this case, the simplified positionImage command in iOS version of the simplified graphics API A would perform the first series of commands, and the positionImage command in the ANDROID version of the simplified graphics API A would perform the second series of commands. As a result, the simplified device APIs  provide a standard set of commands that can be used to interact with the hardware, firmware, and software layers of different devices  and different operating systems, which allows the same high-level code in the boot application , other applications , and high-level API  to function across different device configurations.","Together, the mirrored APIs , , the mirrored object registries , , the interpreter , and the simplified APIs  provide a standardized interface between the high-level applications  and the operating system's built-in APIs . This means the same high-level applications  may be executed on different operating systems and different client devices  as long as an application client module  is installed on the device. Consequently, developers may reach a wider audience of users across multiple operating systems and devices without writing multiple OS- or device-specific versions of an application .","Applying Automatic Updates",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["102","206","212","212","200","116","300","112","116","206","302","212","200"]},"To update the boot application , the system interpreter B loads and executes the boot application  with an instruction to update itself. The high-level code in the boot application  causes the system interpreter B to check  the application server  to determine whether a newer version of the boot application is available. The system interpreter B is able to access  the application server  by using the interpreter's B higher access privileges to interact with the network interface device  and send the proper authentication credentials to the application server .","If no update is found on the application server , then the system interpreter B skips the update process  and closes  the boot application. If an update to the boot application  is found, then the system interpreter B receives  the update from the application server  and applies  the update. In one embodiment, the system interpreter B replaces the entire boot application  with the updated version during the update process . Alternatively, the system interpreter B may replace a subset of the high-level code in the boot application  (e.g., only the lines of code that are new or different) during the update process . Again, the system interpreter B is able to modify the boot application  because the system interpreter B has higher privileges than the application interpreter A.","After the system interpreter B updates  the boot application , the system interpreter B closes the boot application  and uses a return statement to return  to the native API. Next, the native API  issues  a second command that instructs the system interpreter B to update the application  that was requested. The system interpreter B uses a similar process to update the requested application . First, the system interpreter B loads the boot application  with an instruction to update the requested application . The high-level code in the boot application  causes the system interpreter B to check  for an updated version of the requested application  on the application server . Again, if no update is available on the application server , the system interpreter B skips the update process  and closes  the boot application without modifying the requested application . If an update is available, then the system interpreter B receives  and applies  the update. In addition to new or different high-level code, the update for the requested application  may also include additional data objects, such as movies, audio clips, images, or plaintext.","When updating the requested application , the system interpreter B may receive  an update that is customized to the user's personal information (e.g., the user's geographic location, demographic information, device configuration, etc). The application server  may obtain the user's personal information from the various sensors  on the client device  (e.g., a GPS receiver) at the time of the update request . Alternatively, the user may have voluntarily provided the information to the application server  beforehand (e.g., when using the application server's social networking functions). After applying the update, the system interpreter A closes  the boot application  and uses a second return statement to return to the native API . Finally, the native API  issues  a third command instructing the low-privilege application interpreter A to load and execute  the requested application.","This configuration is advantageous for several reasons. By automatically updating the boot application  and the requested application  before the application  is launched, both the boot application  and the requested application  remain up to date without requiring the user to manually request updates. In addition, the ability to customize application updates based on a user's personal information also allows application developers to provide a richer and more personalized user experience.","Encoding Commands as Character Strings",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4","b":["400","410","212","400","410","206","410"]},"The command  in the high-level language may comprise, for example, a class , a method , and four input parameters . The encoded character string  may comprise, for example, a numerical class identifier  corresponding to the class , a numerical method identifier  corresponding to the method , and the values  of the input parameters . The interpreter  and the native API  predetermine the order of the input parameters  for each method so that the numbers  in the character string  representing the values of the parameters  may be mapped to the correct parameters when the native API  decodes the character string . In alternative embodiments, the command  and the encoded character string  may include additional, fewer, or different components. For example, the command  may include additional parameters , which would cause the encoded character string to include additional parameter values .","In addition to the numbers representing the class, method, and parameters of the high-level command, the encoded character string  also contains two types of control characters. A first type of control character (the colon)  indicates the beginning of a command, and a second type of control character (the comma)  separates different entries in the character string . Although spaces are added throughout the character string  as shown in  to improve readability, the spaces have no function and may be omitted. The encoded character string  also contains an instance identifier  referring to a specific instance of an object within a class. The high-level API  assigns an instance identifier  to an instance of an object when the object is registered in the high-level object registry , and the interpreter  retrieves the instance identifier  from the high-level object registry  when encoding the command . In the embodiment shown in , the instance identifier  is placed between the numerical method identifier  and the values of the parameters .","The mapping between the class  and method  and their respective numerical identifiers ,  is configured so that the original command  can be recreated as a native command using the encoded character string . In one embodiment, the mapping from the text identifiers ,  to the numerical identifiers ,  is predetermined, but the mapping may also be randomly generated and reproduced between the interpreter  and the native API . In addition, the mapping between the method  and the numerical method identifier  may not be a one-to-one mapping. Methods  with similar functions may be mapped to the same numerical method identifier . For example, methods  to rotate, translate, and scale a sprite on the screen may be mapped to a numerical method identifier  corresponding to a generalized method in the native API  to transform a sprite on the screen. In an alternative embodiment, the class  and the method  may be mapped to a single composite numerical identifier instead of two separate numerical identifiers , . Again, the mapping need not be a one-to-one mapping. Any other changes may be made to the mapping process as long as the native API  is able to reproduce the high-level command  as a native command.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 5","FIG. 6","FIG. 4"],"b":["212","500","204","212","505","212"]},"After receiving  the queue of high-level commands and encoding  the commands as character strings, the interpreter  sends  the encoded commands to the native API . The native API  decodes  the character strings into native commands by reversing the mapping process that was performed during the encoding process . Finally, the native API  executes  the decoded native commands using the matching classes and objects in the native API  and the native object registry .","Interactions Between a High-Level Scripting Language and Native Code","Referring now to , illustrated are two examples of how a high-level application may use the communication protocol shown in  to interact with resources on the client device  and within the application client module .  is an interaction diagram illustrating a process for processing a series of commands in a single processing frame, in accordance with one embodiment. At a high level, an application  issues one or more commands during a fixed time interval, and the high-level API  adds the commands to a queue. The fixed time interval is called a processing frame. At the end of the processing frame, the commands in the queue are encoded using the communication protocol described with reference to , transferred to the native API , and decoded as native commands. The queuing mechanism maintains the order of the original high-level commands throughout the encoding and decoding processes so the native commands may be executed in the same order in which the application  issued the corresponding high-level commands.","The process begins when the native API  requests  the commands for the next processing frame. The request is encoded as a character string and sent to the interpreter , which decodes the request and passes  it to the high-level API . The high-level API  analyzes the high-level code in the application  and retrieves a first command  to be encoded. The retrieved command may perform any function that is typically reserved for native code, such as displaying or modifying a sprite on the screen, playing back audio clips, reading or writing to files in the memory , or monitoring input from the physical sensors . After retrieving  the first command, the high-level API adds  the first command to a queue.","After retrieving  and queuing  the first command, the high-level API  performs the same process to retrieve  and queue  additional commands. Although the retrieval and queuing processes are only shown for a total of two commands, the high-level API  may continue adding additional high-level commands to the queue for the duration of the processing frame. At the end of the processing frame, the high-level API  sends  the queue of high-level commands to the interpreter , and the interpreter  encodes  each queued command as a character string according to the communication protocol described with reference to .","The interpreter  sends  the encoded queue of character strings to the native API , which decodes  the character strings into native commands and executes ,  the native commands. Since the order of the original high-level commands was preserved while the commands were queued , , encoded , transferred , and decoded , the native commands are executed ,  in the same order in which the high-level commands were queued. Preserving the order of the commands is important because commands that are performed in an incorrect order may yield incorrect results. For example, a series of commands to place an image on the screen, translate the image, and rotate the image about an origin would yield a different result if the translation and rotation steps were performed in the opposite order.","The queuing mechanism reduces processing overhead and improves the performance of the applications  because the process of crossing the processing boundary between high-level and native code (e.g., the process of encoding , sending , and decoding  a command) may be relatively resource-intensive. This is especially important if the client device  is a mobile device with limited processing power and battery life. By processing the commands of an entire processing frame at once, the application client module crosses the processing boundary once per processing frame rather than once per command.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 7","FIG. 6"],"b":["208","210","116","206","700","206","212","702","204","204","202","704","704","204","706","208","708"]},"In one embodiment, the high-level API  assigns an instance identifier to the new object when registering  the object in the high-level registry . The registration command may also contain a class identifier to identify the type of object being registered. Together, the class identifier and the instance identifier allow the high-level API  to uniquely identify the object, and both identifiers are saved in the object registry. In alternative embodiments, the class identifier and the instance identifier may be merged into a single composite identifier that may be used to uniquely identify the object.","At the end of the processing frame, the high-level API  sends  the queued commands to the interpreter  and the commands in the queue are encoded , sent , and decoded  using the process described with reference to . As shown in , the instance and class identifiers are encoded and sent as part of the character string. Although only one register command is shown in , the high-level API  may retrieve and add additional commands to the queue during the processing frame, either before or after retrieving  and queuing  the object registration command that is shown. After the commands for the processing frame are decoded  into native commands, the native API  executes the object registration command and registers  the object in the native object registry . The same numerical instance identifier is used to register  the object in the native object registry . This process allows the application client module  to maintain two mirrored copies ,  of the object registry so that commands that reference one or more of the objects may be executed by the native code.","The disclosed configurations beneficially allow developers to write high-level software applications  that are indistinguishable to users from applications that run natively on a client device . The combination of the simplified device APIs  and the communication protocol implemented in the application client module  allow high-level applications  to access system resources, such as graphics functions, user interface functions, networking devices , and physical sensors , that are typically reserved for native applications. As a result, developers are able to write high-level applications  that perform the same functions as native applications. In addition, the disclosed configurations allow for high-level applications  to be updated without being subject to any restrictions that the operating system of a client device  may place on updates for native application. This allows the application client module  to automatically apply updates that may be tailored to a user's geographic location, demographic information, client device configuration, or other personal details, which results in a more customized user experience that enhances the value of the high-level application .","Additional Configuration Considerations","Throughout this specification, plural instances may implement components, operations, or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations (e.g., in ), one or more of the individual operations may be performed concurrently, and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the subject matter herein.","Certain embodiments are described herein as including logic or a number of components, modules, or mechanisms (e.g., in , , , , and ). Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal) or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., a standalone, client or server computer system) or one or more hardware modules of a computer system (e.g., a processor or a group of processors) may be configured by software (e.g., an application or application portion) as a hardware module that operates to perform certain operations as described herein.","In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software) may be driven by cost and time considerations.","The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.","The one or more processors may also operate to support performance of the relevant operations in a \u201ccloud computing\u201d environment or as a \u201csoftware as a service\u201d (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., application program interfaces (APIs).)","The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the one or more processors or processor-implemented modules may be located in a single geographic location (e.g., within a home environment, an office environment, or a server farm). In other example embodiments, the one or more processors or processor-implemented modules may be distributed across a number of geographic locations.","Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory (e.g., a computer memory). These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein, an \u201calgorithm\u201d is a self-consistent sequence of operations or similar processing leading to a desired result. In this context, algorithms and operations involve physical manipulation of physical quantities. Typically, but not necessarily, such quantities may take the form of electrical, magnetic, or optical signals capable of being stored, accessed, transferred, combined, compared, or otherwise manipulated by a machine. It is convenient at times, principally for reasons of common usage, to refer to such signals using words such as \u201cdata,\u201d \u201ccontent,\u201d \u201cbits,\u201d \u201cvalues,\u201d \u201celements,\u201d \u201csymbols,\u201d \u201ccharacters,\u201d \u201cterms,\u201d \u201cnumbers,\u201d \u201cnumerals,\u201d or the like. These words, however, are merely convenient labels and are to be associated with appropriate physical quantities.","Unless specifically stated otherwise, discussions herein using words such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining,\u201d \u201cpresenting,\u201d \u201cdisplaying,\u201d or the like may refer to actions or processes of a machine (e.g., a computer) that manipulates or transforms data represented as physical (e.g., electronic, magnetic, or optical) quantities within one or more memories (e.g., volatile memory, non-volatile memory, or a combination thereof), registers, or other machine components that receive, store, transmit, or display information.","As used herein any reference to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment.","Some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. For example, some embodiments may be described using the term \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other. The embodiments are not limited in this context.","As used herein, the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes,\u201d \u201cincluding,\u201d \u201chas,\u201d \u201chaving\u201d or any other variation thereof, are intended to cover a non-exclusive inclusion. For example, a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus. Further, unless expressly stated to the contrary, \u201cor\u201d refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).","In addition, use of the \u201ca\u201d or \u201can\u201d are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the invention. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.","Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for communicating between high-level and native code through the disclosed principles herein. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications, changes and variations, which will be apparent to those skilled in the art, may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The disclosed embodiments have other advantages and features which will be more readily apparent from the detailed description, the appended claims, and the accompanying figures (or drawings). A brief introduction of the figures is below.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
