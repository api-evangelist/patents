---
title: Pre-boot interpreted namespace parsing for flexible heterogeneous configuration and code consolidation
abstract: A system and method to interact with a hardware device of a processing system. An interpreted language code defining how to interact with the hardware device of the processing system is provided. The interpreted language code is interpreted to interact with the hardware device of the processing system prior to entering an operating system runtime mode of operation of the processing system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07107441&OS=07107441&RS=07107441
owner: Intel Corporation
number: 07107441
owner_city: Santa Clara
owner_country: US
publication_date: 20030521
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to using an interpreted language code to interact with hardware devices of a processing system during a pre-boot runtime, and in particular but not exclusively, relates to sharing advance configuration and power interface machine language control methods across a pre-boot runtime and an operating system runtime of a processing system.","Modern computers are complex computing systems, evolving at an ever-increasing rate. With rapid evolution of technologies, original equipment manufacturer (\u201cOEM\u201d) system builders are presented with the difficult task of providing seamless integration between cutting edge technologies and legacy technologies. As a result, these OEM system builders often resort to ad hoc methods to integrate the new with the old. These ad hoc methods, while often providing a sufficient solution, often fail to fully leverage the advantages of these new technologies.","One such new technology is the Advance Configuration and Power Interface (\u201cACPI\u201d), defined in the ACPI Specification, Revision 2.0a, Mar. 31, 2002 developed in cooperation by Compaq Computer Corp., Intel Corp., Microsoft Corp., Phoenix Technologies Ltd., and Toshiba Corp. The ACPI Specification was developed to establish industry common interfaces enabling robust operating system (\u201cOS\u201d) directed motherboard device configuration and power management of both devices and entire systems. ACPI evolves an existing collection of power management BIOS code, Advance Power Management (\u201cAPM\u201d) application programming interfaces (\u201cAPIs\u201d), and the like into a well-defined power management and configuration interface specification. ACPI provides a way for an orderly transition from existing legacy hardware to ACPI hardware, and allows for both ACPI and legacy mechanisms to simultaneously exist within a single processing system.","The ACPI specification further describes a programming language, called ACPI Source Language (\u201cASL\u201d), in which hardware designers can write device interfaces, called control methods. ASL is compiled into ACPI machine language (\u201cAML\u201d) and the AML control methods placed in ACPI tables within system memory for use by the OS to interact with hardware devices.","The basic input output system (\u201cBIOS\u201d) sets up the ACPI tables during the boot process (i.e., pre-boot runtime); however, the BIOS itself does not use the AML control methods to interact with the hardware devices of the processing system. Instead, the BIOS relies on BIOS APIs, generally stored in nonvolatile flash memory, to perform the very same interactions with hardware devices as are described by the AML control methods. These BIOS APIs are usually coded in C and compiled into machine language binaries for use by the BIOS.","Thus, OEM system builders must include two independent sets of coded device interfaces\u2014APIs for use by the BIOS and AML control methods for use by the OS\u2014to perform the same tasks. This ad hoc integration of the new ACPI technology with the old BIOS API legacy is wasteful both in terms of limited nonvolatile flash memory and OEM system builder time. Furthermore, this ad hoc integration fails to fully leverage the advantages of ACPI.","For example, AML is a declarative language which describes how a particular interaction with a hardware device may be accomplished and allows the entity calling the AML control method to decide whether or not it wishes to execute the particular tasks described. AML increases system reliability by bounding and guarding the operation of low-level management code. In other words, AML is transparent as to its internal or physical level operations. In contrast, BIOS APIs are defined by an imperative machine language called binaries. An entity calling a binary has no idea how or what the binary executes to accomplish the requested hardware task. Because BIOS APIs are manipulating hardware registers to control hardware devices, the computing system is particularly vulnerable to errant writes and other failures. Prior experience with BIOS APIs shows that they are a rich source of problems. Thus, API binaries do not provide the level of supervision and transparency of operation, as provided by AML control methods.","Another deficiency with API binaries is their lack of portability between software platforms. API binaries are compiled to execute within a particular platform environment. Where as AML control methods abstract the physical implementation through use of an OS interpreter. The OS interpreter interprets the AML control methods on the fly thereby accommodating various software platforms. The OS interpreter (a single entity) may need to be platform specific, but the multitudes of AML control methods are platform independent.","Embodiments of a system and method for using an interpreted language code to interact with hardware devices of a processing system during a pre-boot runtime are described herein. Although embodiments of the present invention may be extended for use with various types of interpreted languages, the present invention will primarily be described in connection with ACPI machine language (\u201cAML\u201d). In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Throughout this specification, several terms of art are used. These terms are to take on their ordinary meaning in the art from which they come, unless specifically defined herein or the context of their use would clearly suggest otherwise. An \u201cinterpreted language code\u201d is any program code that is translated and executed at the same time. A translator application translates one program statement of the interpreted language code into machine language, executes the machine language, and then proceeds to the next program statement. In contrast, imperative language code (e.g., a regular executable program) is presented to a computer as a binary-coded instruction. AML is an example of an interpreted language code. AML is an interpreted assembly-level machine language in which low-level sequences can be written. These sequences are interpreted and executed by an AML interpreter so they can be robustly checked and validated at each step of the sequence.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","100","100","105","110","105","115","120","125","130","135","137","140"]},"The elements of one embodiment of processing system  are interconnected as follows. System memory  and firmware unit  are communicatively coupled to processor  allowing processor  to execute software instructions received therefrom. Processor  is further communicatively coupled to each of hard disk controller , PS\/2 keyboard controller , serial port , and component X to receive data therefrom and to send data thereto. Hard disk controller  further couples processor  to hard disk . Optionally, software files stored on hard disk , such as OS files  and an OS interpreter  may be transferred via hard disk controller  into system memory  and may be executed from there by processor . Similarly, firmware instructions, such as interpreted language code , a pre-boot interpreter , and a setup display engine  may optionally be loaded from firmware unit  into system memory  and executed by processor  therefrom. It should be appreciated that various other elements of processing system , some optional and some necessary, have been excluded from  and this discussion for the purposes of clarity.","In one embodiment, hard disk  is an EIDE hard disk. In other embodiments, hard disk  may include an IDE hard disk, a SCSI hard disk, a tape drive, a CD-ROM drive, a ZIP drive or other similar nonvolatile storage devices. It should be appreciated that various other known or future arising implementations of storing data may replace hard disk  for storing OS files  and OS interpreter  within the scope of the present invention. Furthermore, OS files  and OS interpreter  may be stored over a number of storage devices, such as with a redundant array of independent disks (\u201cRAID\u201d). In one embodiment, system memory  is system random access memory. It should be appreciated that other known or after arising technology for storing applications executed by a processor may implement the functionality of system memory , within the scope of the present invention. In one embodiment, firmware unit  is flash memory. In other embodiments, firmware unit  may include read only memory (\u201cROM\u201d), programmable ROM, erasable programmable ROM, electrically erasable programmable ROM, or the like.","Turning now to , an embodiment of processing system  operates as illustrated by a process  to execute interpreted language code  to interact with hardware devices, in accordance with the teachings of the present invention. Processing system  may use the following method to interact with one or more of PS\/2 keyboard controller , serial port , and component X.","In a process block , processing system  is powered-on. A powered-on event may be the result of a user of processing system  turning processing system  on after being powered-off, or it may be the result of a reset of processing system . From process block , processing system  proceeds through early system initialization in a process block . This early system initialization includes processor  accessing firmware unit  to execute a pre-boot program called a basic input output system (\u201cBIOS\u201d), which may include a power on self test (\u201cPOST\u201d) among other tasks.","In a process block , processor  allocates a buffer in system memory  for an ACPI namespace . Reserving an empty location in system memory  where data objects can be stored creates this buffer.","In a process block , processor  loads pre-boot interpreter  stored in firmware unit  into system memory . In one embodiment, pre-boot interpreter  is an extensible firmware interface (\u201cEFI\u201d) driver compliant with the EFI Specification, Version 1.10, Dec. 1, 2002, developed by Intel Corporation. In one embodiment, pre-boot interpreter  is single-threaded, non-reentrant firmware code. Although pre-boot interpreter  is illustrated as residing in firmware unit , other embodiments of the present invention include pre-boot interpreter  being stored on hard disk  or other nonvolatile memory units communicatively coupled to processor . Pre-boot interpreter  is a program that when called by the BIOS or other programs, interprets and executes interpreted language code  to effect a desired interaction with hardware devices of processing system , such as PS\/2 keyboard controller , serial port , or component X. In the example where interpreted language code  is AML, pre-boot interpreter  is an AML interpreter.","In a process block , processor  loads non-ACPI compliant firmware components into system memory . In one embodiment, this may include executing one or more legacy application programming interfaces (\u201cAPIs\u201d). Collectively, process blocks \u2013 will be referred to as blocks .","In a process block , a differentiated definition block (\u201cDDB\u201d)  is loaded into, heretofore empty, ACPI namespace . DDB  contains information about hardware implementation and configuration details in the form of data and control methods encoded in AML. In one embodiment, DDB  is a portion of interpreted language code  stored in firmware unit .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["300","100","300","310"]},"In a decision block , the BIOS searches hardware devices coupled to motherboard  for ACPI compliant hardware devices. For example, if PS\/2 keyboard controller  is an ACPI compliant hardware device it will have an associated definition block A. Definition blocks  contain information about hardware implementation and configuration details in the form of the AML control methods described above. An OEM of PS\/2 keyboard controller  can provide one or more definition blocks , which can be dynamically inserted and removed from ACPI namespace . Prior to definition blocks  being inserted into ACPI namespace , they can be stored within firmware unit , as a portion of interpreted language code , or embedded within a driver image on an option ROM associated with the particular hardware device. Thus, in the case of PS\/2 keyboard controller , definition block A may be stored optionally within firmware unit  or option ROM .","In a process block , the BIOS inserts definition block A corresponding to PS\/2 keyboard controller  into ACPI namespace . As discussed above, definition block A contains one or more AML control methods for interacting (e.g., initializing, configuring, etc.) with PS\/2 keyboard controller . Process  then returns to decision block  to determine whether other hardware devices are ACPI compliant and have definition blocks to insert into ACPI namespace . Decision block  and process block  may be repeated for serial port  and component X, if they are ACPI compliant. When it is determined in decision block  that no further hardware devices of processing system  have definition blocks to insert into ACPI namespace , process  continues to a process block .","Process block , decision block , and process block  collectively will be referred to as blocks . In one embodiment, blocks  illustrate how DDB  and definition blocks  can be dynamically inserted into ACPI namespace . In an alternative embodiment, a memory image of ACPI namespace , including DDB  and all definition blocks , is stored as interpreted language code . In this alternative embodiment, blocks  would be replaced with a single act of loading this memory image of ACPI namespace  into the buffer allocated in system memory  in process block  above.","In process block , pre-boot interpreter  is called by the BIOS to parse ACPI namespace , interpret the AML control methods associated with DDB  and the various definition blocks , and execute the desired interactions with hardware devices of processing system . Exemplary interactions with hardware devices of processing system  include initialization or configuration of hardware data and status registers. In the example of PS\/2 keyboard controller , the BIOS may call pre-boot interpreter  to execute one or more AML control methods of definition block A to initialize PS\/2 keyboard controller .","It should be appreciated that the order of many of the process blocks in process  can be changed within the scope of the present invention. For instance, the order of the process blocks , , and  may be reordered in any desirable manner. Furthermore, process blocks  and  may be executed between process blocks  and , after ACPI namespace  is setup.","Once all initializations and\/or configurations of hardware devices are complete, in a process block , the BIOS launches the boot target, which takes control of processing system  and begins to load OS files  (e.g., IO.SYS in the case of a Microsoft Windows\u2122 OS) from hard disk . Once the OS files  begin to load into system memory , the pre-boot runtime terminates and the OS runtime begins.","Once processing system  is executing in OS runtime, processor  can load and execute OS interpreter  stored on hard disk . Thus, in one embodiment, OS interpreter  is an OS driver\/application. In one embodiment, OS interpreter  will parse and interpret the same ACPI namespace  during the OS runtime so that the OS can interact with hardware devices of processing system  (e.g., PS\/2 keyboard controller , serial port , component X, etc.). Thus, in this embodiment, both pre-boot interpreter  and OS interpreter  share the same ACPI namespace  across the pre-boot runtime and the OS runtime of processing system . Sharing ACPI namespace  across the pre-boot runtime and the OS runtime eliminates the need for redundant BIOS APIs. This frees up valuable memory in firmware unit  for other firmware code.","Turning now to , an embodiment of processing system  operates as illustrated by a process  to execute interpreted language code  for configuring hardware devices during the pre-boot runtime, in accordance with an embodiment of the present invention.","In a process block , processing system  is powered-on. Process block  is similar to process block  described above. Process  proceeds through blocks  and  as described above to setup and load ACPI namespace  with DDB  and definition blocks .","Next, process  executes the process blocks and decision blocks encompassed within a block . Block  corresponds to one embodiment of process block , discussed above, for configuring hardware devices of processing system  (e.g., PS\/2 keyboard controller , serial port , component X, etc.).","In a decision block , the BIOS determines whether a \u201chot key\u201d (e.g., F) was pressed by a user of processing system  during the pre-boot runtime. In one embodiment, pressing the hot key indicates to the BIOS to load and execute a setup display engine . In one embodiment, the setup display engine provides a graphical user interface for the user to make user-selectable changes and\/or view configuration settings of processing system . If the hot key is pressed during the pre-boot runtime, the BIOS loads and executes setup display engine  in a process block . If the hot key is not pressed during the pre-boot runtime, process  proceeds to a process block , wherein the boot target is launched and OS files  are loaded into system memory .","In a process block , pre-boot interpreter  parses and interprets ACPI namespace  to determine current resource settings (\u201cCRS\u201d) and possible resource settings (\u201cPRS\u201d) of processing system . The CRS and PRS are described by data and control methods encoded in interpreted language code  and enumerated in ACPI namespace . The CRS describe current configuration settings of processing system  and the PRS describe possible configuration settings of processing system .","Thus, pre-boot interpreter  passes the interpreted AML data to setup display engine , which displays the CRS and PRS on a display terminal in a user-friendly format.  illustrates three exemplary user-friendly displays that one embodiment of setup display engine  may provide. A display  may be the first image the user is shown after pressing the hot key during the pre-boot runtime. By moving a cursor on the screen to highlight \u201csystem setup\u201d and pressing \u201center\u201d, setup display engine  generates a display . Display  illustrates the CRS. For example, \u201cserial port \u201d is currently assigned to address \u201c0x2F8.\u201d By highlighting the \u201caddress\u201d with the cursor and pressing \u201center\u201d, setup display engine  generates a display . Display  illustrates the PRS for the serial port . Again, the user can effect a configuration change merely by moving the cursor over the desired resource setting and pressing \u201center\u201d. Upon pressing \u201center\u201d, setup display engine  calls pre-boot interpreter  to execute the appropriate AML control methods necessary to effect the configuration change to serial port .","Returning to , in a process block , setup display engine  determines whether a configuration change was requested by the user, such as described above. If a configuration change was requested, process  continues to a decision block . If a configuration change was not requested, process  proceeds to process block , described above.","In decision block , if the user requested a configuration change to an ACPI compliant hardware device, then process  continues to a process block  where setup display engine  calls pre-boot interpreter  to execute the requisite AML control methods to effect the changes in hardware. After effecting the requested change, the boot target is launched in process block .","On the other hand, if the user requested a configuration change to a non-ACPI compliant hardware device in decision block , process  proceeds to a process block . In process block , the BIOS executes the requisite legacy APIs to effect the changes in hardware. Once the APIs complete their task, the boot target is launched in process block .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":["600","160","600","605","610","615","620","605","625","630","635","640","645","650"]},"In one embodiment, a network interface card (\u201cNIC\u201d) (not shown) is coupled to an expansion slot (not shown) of motherboard . The NIC is for connecting computer system  to a network , such as a local area network, wide area network, or the Internet. In one embodiment network  is further coupled to a remote computer , such that computer system  and remote computer  can communicate.","Hard disk  may comprise a single unit, or multiple units, and may optionally reside outside of computer system . Monitor  is included for displaying graphics and text generated by software and firmware programs run by computer system . Mouse  (or other pointing device) may be connected to a serial port (e.g., serial port  described above), USB port, or other like bus port communicatively coupled to processor(s) . Keyboard  is communicatively coupled to motherboard  via a keyboard controller (e.g., PS\/2 keyboard controller  described above) or other manner similar as mouse  for user entry of text and commands.","In one embodiment, firmware unit  may store interpreted language code , pre-boot interpreter , and setup display engine  described above. In one embodiment, hard disk  may store OS files  and OS interpreter  described above. Similarly, system memory  may temporarily store ACPI namespace  while computer system  is in use.","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification and the claims. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the present invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
