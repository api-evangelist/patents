---
title: Determining system level dependencies
abstract: Techniques for co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution are provided. The techniques include obtaining at least one of a functional design and at least one implementation artifact of a solution, obtaining at least one infrastructure component of a target deployment environment for the solution, and co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution, wherein co-relating comprises discovering at least one system level dependency among the at least one of a functional design and at least one implementation artifact and the at least one infrastructure component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959481&OS=08959481&RS=08959481
owner: International Business Machines Corporation
number: 08959481
owner_city: Armonk
owner_country: US
publication_date: 20090430
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to information technology, and, more particularly, to enterprise systems.","Information technology (IT)-enabled enterprise solutions typically provide solutions to some enterprise problems for an organization. Such solutions typically involve a large number of software components deployed on a network of servers and work-stations. For example, a related enterprise solution is a claim processing solution used by an insurance company, where insured members or their authorized delegates can submit claims for covered expenses according to their subscribed benefit plans and get reimbursement payments. Such solutions may involve web-based interfaces for interactive access to claim submitters, several work-station-based desktop interfaces for insurance company's claim reviewer users, a workflow or process automation component to coordinate activities of these reviewer users, and a set of components to store and retrieve records of claims, insured members' benefit plans, pre-set payment schedules for covered expenses, etc. All of these functional components may be deployed on a server infrastructure including middleware systems software, database management system software and networking software which, in turn, can run on operating systems managing computer hardware.","Embodiments of the present invention provide techniques for determining system-wide dependencies in an enterprise information technology (IT) system.","An exemplary method (which may be computer-implemented) for co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution, according to one aspect of the invention, can include steps of obtaining at least one of a functional design and at least one implementation artifact of a solution, obtaining at least one infrastructure component of a target deployment environment for the solution, and co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution, wherein co-relating comprises discovering at least one system level dependency among the at least one of a functional design and at least one implementation artifact and the at least one infrastructure component.","At least one embodiment of the invention can be implemented in the form of a computer product including a computer usable medium with computer usable program code for performing the method steps indicated. Furthermore, at least one embodiment of the invention can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.","These and other objects, features and advantages of the embodiments of the invention will become apparent from the following detailed description, which is to be read in connection with the accompanying drawings.","Principles of the present invention include a systematic approach to automatically discover system level dependencies among applications and infrastructure components out of available heterogeneous information sources and constructing a multi-layered graph (referred to herein, for example, as an execution graph).","Additionally, principles of the invention include targeting the space of an enterprise computing environment involving a multitude of applications and heterogeneous infrastructural systems. One or more embodiments of the present invention synthesize multi-layered dependency models of such enterprise systems involving both models of already-deployed applications as well as applications not yet deployed. A meta-model stitching approach can be used, for example, to extend such a model synthesizer. Furthermore, synthesized models can be fed to multiple external tools for analyzing these models for quality of service (QoS) properties.","One or more embodiments of the present invention include co-relation of functional and\/or design implementation artifacts with infrastructure components of target deployment environment. Also, one or more embodiments of the invention include an open-ended extensible meta-model stitching-based technology for achieving a co-relation of functional and\/or design implementation artifacts with infrastructure components of target deployment environment, an aspect that can handle any type of target infra-structure environment. Additionally, one or more embodiments of the invention include execution models of middleware containers at multiple levels of granularity, an aspect that can extend from enterprise-level models through multiple layers of mapping to middleware and even deeper into an operating system (OS) and hardware.","While existing approaches model monitoring data of already deployed applications, one or more embodiments of the present invention include models of a system under observation. Also, in contrast to existing approaches, principles of the present invention relate application and infrastructure components, and reason about its run-time implications without even actually deploying the application. One or more embodiments of the invention consider the existing IT environment (for example, servers' topology, existing components deployed and running on those servers), which will share resources used by the new application. Additionally, unlike existing approaches, one or more embodiments of the invention are extensible, wherein one can specify a methodology to add new meta-models of any new infrastructure and stitching with existing ones. Also, in contrast to existing approaches, principles of the present invention span multiple levels of systems. This capability enables users to reason about the kind of queries that can be claimed across the execution stack.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["102","104","106","108","110","112","114","116","118"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["202","204","206","208","210"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 3","FIG. 3"],"b":["300","302","304","300","306","308"]},"In order to query the properties of the source components, their constituents and the relationships among them, one or more embodiments of the invention use an extensive knowledge base including models for each type of source component. By way of example, in , model of application component type l (that is, component ) represents a model for which the application component l (that is, component ) is an instance. Each model includes a set of element types and a set of relationship definitions among the element types. Additionally, the semantics of a relationship definition can be extended by one or more constraints between the participants of a relationship.","A constraint is a predicate relating the properties of the participating element types. A relationship between two elements in a source component is valid if and only if the types of the elements have a relationship definition in the model of the source component and all of the predicates in the constraints of the relationship definition are satisfied by the properties of the elements.","Locating source component instances for a given component type and querying the information of the instances from the model of the component type can be accomplished by source adapters. As depicted in , source adapter  can locate instances of the model of application component type l (that is, component ) in the enterprise IT environment. Moreover, a source adapter is capable of querying elements in the source instance. Similarly, other source adapters (for example, ,  and  in ) can connect models of component types to their source instances in an IT environment (such as, for example, environment  in ). As such, source adapters can connect models to actual sources.","In one or more embodiments of the invention, a model of a component can be defined in isolation as well as in relation to other existing models by stitching relationships, thereby extending an integrated model of an IT environment. In , stitching relationships  relate elements of model of application component type l (that is, component ) with elements of model of infrastructure component type m (that is, component ). Also, stitching relationships  relate elements of model of application component type l (that is, component ) with elements of model of application component type k (that is, component ). Stitching relationships  relate elements of model of application component type k (that is, component ) with elements of model of infrastructure component type l (that is, component ).","Further stitching relationships  relate elements of model of application component type k (that is, component ) with elements of model of infrastructure component type m (that is, component ). Stitching relationships  relate elements of model of application component type l (that is, component ) with elements of model of infrastructure component type l (that is, component ). Additionally, stitching relationships  relate elements of model of infrastructure component type  (that is, component ) with elements of model of infrastructure component type m (that is, component ).","The models of component types, the relationships within each model, the inter-model stitching relationships and the source adapter together include the ability to automatically discover and synthesize an integrated information base of applications and infrastructure in an enterprise IT environment. Out of such an integrated information base, several different types of queries can be answered. For example, finding all instance sources of a given component type or element thereof, and establishing relations between two instance level elements are typical queries of interest. Also, one or more embodiments of the invention include determining co-relations of design artifacts to their execution time implications. Likewise, observations from infrastructure can be co-related to their implications to functional design artifacts. As detailed herein,  provides techniques for computing the co-relations in terms of the schematic blocks of .","The techniques depicted in  compute a path from an instance element of a source component to another instance element of another source component, as an ordered list of instance-level relationships. By way of example, suppose that at the functional design level, one element of a design element calls another design element. For instance, a process step calls a web-service service, and one wants to know how the infrastructure level source components (for example, between a process server and an application server) will accomplish such a call. Given type models of processes, web-services, process servers and application servers, and the source adapters to find instances of these type models from the IT system, the techniques depicted in  will find one or more paths tracing how the call with be executed at run-time.","An illustrative embodiment of the invention includes semantic integration of information in design artifacts with information from deployment infrastructure. This not only provides a single place to access a total picture, but also queries like resource consumptions, and enables deployment decisions to be answered. One or more embodiments of the present invention also include open-ended extensible meta-model stitching techniques applied for analyzing QoS properties and system management concerns back to an enterprise level, as well as creating models of behavior of middleware containers.","As described herein, models of design artifacts can be semantically integrated with models of deployment infrastructure such that queries about resource consumption implementations of functional design artifacts and their deployment decisions can be answered, and queries about functional implementations of infrastructure problems or observations can be answered. As noted above, existing approaches contrastingly include design models and infrastructure models that are scattered all over in multiple design tools, middleware administration tools and deployment descriptors and in multiple forms.","One or more embodiments of the present invention include semantic integration achieved by a meta-model stitching approach where multiple meta-models for artifacts can be added. Multiple meta-models can be stitched by defining relationships among elements if elements from different meta-models are deemed to be semantically related. Additionally, one or more embodiments of the invention include an open-ended, extensible approach rather than enforcing a single standard. Meta-models can be, for example, fewer than the models in the presence of a multitude of system components and from multiple vendors and models of various design artifacts. Model-weaving papers can exist in a model-driven architecture community, but principles of the present invention uniquely adapt the techniques for analyzing QoS properties and mapping systems management concerns back to an enterprise level. Also, one or more embodiments of the invention create models of resources and behavior of middleware containers.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["402","410","422","424","426","410","412","434","414","416","418","420","404","406","408","432","428","430"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4","FIG. 4"],"b":["402","402","408","432","406","404"]},"The core tool  can be initialized, for example, with the following types of meta-models which are typically extensible markup language (XML) schema. Meta-models can be used to generate rules for accessing model elements (for example, a \u201cport\u201d element in a web service definition language (wsdl) file). Behavioral meta-models can be used to generate rules that capture run-time behavior (data and control flow) of middleware artifacts (such as execution containers). Performance models can also be included therein. Location meta-models can be used to generate rules that provide information about how to locate a model and\/or artifact in an IT infrastructure (for example, EAR packaging information).","Stitching relationships  are the rules that define semantic equivalence between meta-model elements (for example, \u201cport\u201d in a wsdl file is equivalent to \u201cport-component\u201d in webservices.xml). Meta-models and stitching relationships collectively define the basic concepts and their semantics. Higher level relationships and concepts, such as a web-service is \u201cimplementedBy\u201d an enterprise JavaBeans (EJB), can be added as implicational rules over the basic concepts and existing higher level concepts.","The executable rule language chosen in an illustrative embodiment can be, for example, Prolog. A generator  can be a program that translates meta-models into Prolog rules and loads them into Prolog rules engine (for example, ). As an illustration of an application on top the core tool , consider the visualizer application . For an SOA application targeted for a J2EE environment, some typical queries that the visualizer needs answers for can include, for example, ListOfAllWSDLs, ListOfAllServlets, ListOfAllPossibleRelationships, ListOfResourcesThatOccurOnPath, etc.","A query engine  can receive such queries from the applications (for example, visualizer ) and route them to the rules engine . A rules engine  can process the queries from the user against the loaded rules. If query processing in the rules engine results in a need to access model elements, then the request is routed to an appropriate source connector agent  which ultimately maps it to the appropriate query on the model (for example, Java management extensions (JMX) query, xQuery, etc.). Capabilities of a source connector agent  accessing server components can include, for example, finding value corresponding to given windows registry key (for example, used to find the software installation location), executing Xquery on an XML file, and executing a Java management extensions (JMX) query on a JMX engine. Examples of pieces of various components of core-tool architecture are detailed below.","Exemplary Prolog code to access element can include, for example:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"element(\u2018wsdl-file\u2019, Element, ElementShortName,"},{"entry":"model(\u2018Webservices.xml\u2019,"},{"entry":"ModelShortName, location(MachineName, PathToModel)))"},{"entry":"\u2003\u2003:- model(\u2018Webservices.xml\u2019, ModelShortName,"},{"entry":"location(MachineName, PathToModel)),"},{"entry":"\u2003\u2003\u2003XQuery = \u2018declare namespace"},{"entry":"j2ee=\u201chttp:\/\/java.sun.com\/xml\/ns\/j2ee\u201d; for $x in"},{"entry":"\/j2ee:webservices\/j2ee:webservice-description let $y:="},{"entry":"$x\/j2ee:webservice-description-name\/text( ) let $z:="},{"entry":"$x\/j2ee:wsdl-file\/text( ) return <data>\/webservices\/webservice-"},{"entry":"description[webservice-description-name={$y}]\/wsdl-file={$z}<\/data>\u2019,"},{"entry":"\u2003\u2003\u2003getXMLElement(Element, ElementShortName, MachineName,"},{"entry":"PathToModel, XQuery)."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Definitions of predicates can, for example, include:\n\n","Stitching between meta-models can include, for example, the following. Consider meta-models of wsdl and webservices.xml (both models can be found in any J2EE application package which provides web services). An element named \u2018port\u2019 in \u2018wsdl\u2019 and an element named \u2018port-component-name\u2019 in webservices.xml are related to each other under some conditions, which one can express as rule. Also, one can express that rule in prolog by the following example.","Exemplary Prolog code to access element can include, for example:",{"@attributes":{"id":"p-0056","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"relation( \u2018sameAs\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003element(\u2018port.name\u2019, Element1, ElementShortName1,"},{"entry":"\u2003\u2003\u2003\u2003\u2003model(\u2018wsdl\u2019, ModelShortName1, location(MachineName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003PathToModel1))), element(\u2018wsdl-port\u2019, Element2,"},{"entry":"\u2003\u2003\u2003\u2003\u2003ElementShortName2, model(\u2018Webservices.xml\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003ModelShortName2, location(MachineName, PathToModel2)))"},{"entry":"\u2003\u2003)"},{"entry":":- element(\u2018port.name\u2019, Element1, ElementShortName1, model(\u2018wsdl\u2019,"},{"entry":"ModelShortName1, location(MachineName, PathToModel1))),"},{"entry":"\u2003\u2003\u2003element(\u2018wsdl-port\u2019, Element2, ElementShortName2,"},{"entry":"model(\u2018Webservices.xml\u2019, ModelShortName2,"},{"entry":"location(MachineName, PathToModel2))),"},{"entry":"\u2003\u2003\u2003relation(\u2018belongsTo\u2019, model(\u2018wsdl\u2019, ModelShortName1,"},{"entry":"location(MachineName, PathToModel1)), model(\u2018Webservices.xml\u2019,"},{"entry":"ModelShortName2,"},{"entry":"location(MachineName, PathToModel2))),"},{"entry":"\u2003\u2003\u2003ElementShortName1 = ElementShortName2."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Definitions of predicates can, for example, include:\n\n",{"@attributes":{"id":"p-0058","num":"0062"},"figref":["FIG. 5","FIG. 5","FIG. 6","FIG. 6"],"b":["502","602"]},{"@attributes":{"id":"p-0059","num":"0063"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["702","704","706","708","710","712","714","716","718","720","722"]},"Higher level relationships, as described herein, can be expressed as rules. For example, Prolog code to access an element can include the following:",{"@attributes":{"id":"p-0061","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"relation( \u2018implementedBy\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003element(\u2018port.name\u2019, Element1, ElementShortName1,"},{"entry":"\u2003\u2003\u2003\u2003\u2003model(\u2018wsdl\u2019, ModelShortName1, location(MachineName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003PathToModel1))), element(\u2018servlet-link\u2019, Element2,"},{"entry":"\u2003\u2003\u2003\u2003\u2003ElementShortName2, model(\u2018Webservices.xml\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003ModelShortName2, location(MachineName, PathToModel2)))"},{"entry":"\u2003\u2003) :-"},{"entry":"relation( \u2018sameAs\u2019, element(\u2018port.name\u2019, Element1, ElementShortName1,"},{"entry":"model(\u2018wsdl\u2019, ModelShortName1, location(MachineName,"},{"entry":"PathToModel1))),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003element(\u2018wsdl-port\u2019, Element3, ElementShortName3,"},{"entry":"model(\u2018Webservices.xml\u2019, ModelShortName2, location(MachineName,"},{"entry":"PathToModel2)))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2009), element(\u2018servlet-link\u2019, Element2, ElementShortName2,"},{"entry":"model(\u2018Webservices.xml\u2019, ModelShortName2, location(MachineName,"},{"entry":"PathToModel2))),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2009relation(\u2018patentInTree\u2019, F, Element2),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2009relation(\u2018patentInTree\u2019, G, F),"},{"entry":"relation(\u2018patentInTree\u2019, G, Element3)."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Definitions of predicates can, for example, include:\n\n","Additionally, different granularities of behavior models of server components can be created.  is a diagram illustrating an exemplary execution model of an application server, according to an embodiment of the present invention. By way of example,  depicts the elements and\/or steps of start , request type , asking if web server is up , web server , reply message=\u201cweb server not available\u201d , asking if the JMS server is up , Java message service (JMS) server  and reply message=\u201cJMS server not available\u201d .","Illustrated in  is an example of a behavior model for an \u2018application server.\u2019 As illustrated in , oblong or circular nodes (for example, , , ,  and ) are the resources part of the application server container, and the diamond nodes (for example, ,  and ) are the decision boxes for deciding which path a particular request will execute. There is a \u2018start\u2019 node  and an \u2018end\u2019 node, and the edges correspond to the control flow.","One can construct a behavior model to whatever granularity is desired. For example, someone else (including creator of the model in ) may have more information about what happens when the request is processed in the web server component and that information can be added as well, as illustrated in . As described herein, the control and data flow information can be represented using many different models, but those models can be integrated with the rest of the system by defining an intermediate model (possibly in XML) that captures the essential information from the original model and then optionally defining rules that \u201cstitch\u201d (as noted above) concepts existing in the execution model with the concepts that are already part of the execution graph synthesizer.",{"@attributes":{"id":"p-0066","num":"0071"},"figref":["FIG. 9","FIG. 9"],"b":["902","904","906","908","914","910","912","916"]},{"@attributes":{"id":"p-0067","num":"0072"},"figref":"FIG. 9","b":["918","920","922","926","404","924","928","404","930","932","934","936","938"]},"As described herein, principles of the invention include an open framework for describing meta-models of platform or application components in isolation and semantically relating the meta-models using inter-model stitching relationships. The meta-models and stitching relationships can be translated into a set of executable rules. The resulting network of meta-models, together with querying mechanisms to discover instances of the meta-models from various sources in an IT environment, can synthesize automatically and on-demand, and integrate models of an IT environment as a multilevel graph (referred to herein, for example, as an execution graph).","In one or more embodiments of the present invention, one can allow experts to define meta-models of artifacts they deal with in their specific specialty. Also, these disparate meta-models can be semantically related by writing rules. Using the network of meta-models thus constructed, one can discover instances of these meta-models by querying multiple components across systems on-demand. The net result is the ability to automatically synthesize integrated models (the execution graph) of a whole system, applications and infrastructure together.","Also, one or more embodiments of the invention include exemplary queries and analyses that can be performed on execution graphs. An example of a possible analysis is the ability to trace how a business process execution language (BPEL) process execution will involve software resources (say a thread pool) in a middleware.","One or more embodiments of the present invention include the benefits of, for example, as described below. Automatically constructed execution graphs can feed queuing analysis tools and simulators for performance analysis. Creating realistic modeling of systems (for example, queuing models) by hand is difficult and labor-intensive. Automated construction models and analyzable information base created by one or more embodiments of the invention facilitate performance analysis.","Also, execution graphs can be constructed on-demand as needed by the analysis context due to the federated query based scheme described herein. On-demand construction results in more up-to-date information for analysis compared to existing approaches that discover the dependencies among installed components and store them in a repository, because the underlying infrastructure evolves due to updates and upgrades. Moreover, the on-demand construction of just the necessary parts of an execution graph can be more scalable for large enterprise infrastructure.","Additionally, one or more embodiments of the invention are open and can be extended incrementally by experts adding meta-models from their own specialty. In contrast, existing approaches are based on a single standard. A federated meta-model approach of one or more embodiments of the present invention can live with multiple standards as well as evolution of a standard.","Principles of the present invention, as described herein, include applying meta-modeling techniques for modeling deep inside servers in an IT infrastructure. Moreover, by integrating meta-modeling with mechanisms for actually discovering instances of theses meta-models in real enterprise systems, the techniques described herein are simultaneously simple as well as powerful in dealing with enterprise-level IT complexity.","One or more embodiments of the invention can be founded upon a network of meta-models, each describing the structure and behavior of a type of system component or an application component. Moreover, for each component type, a mechanism called the adapters, used to locate and query the instances of these meta-models in a given IT environment, can be defined.","In an illustrative embodiment of the invention, one can use a unified modeling language (UML) class diagram to define structural aspects in a meta-model and a UML activity diagram for behavioral aspects. The semantics of these meta-models lies in essence in defining the semantics of relationships. One or more embodiments of the invention use an executable rule language (for example, XSB prolog) to specify the semantics of relationships. Having the executable rules allows one to semantically query the instances of these meta-models. Furthermore, the techniques described herein allow interconnecting related concepts across meta-models by a special kind of relationship referred to as a stitching relationship.","As noted above, one or more embodiments of the present invention include rule-based machinery for meta-model semantics. When a new structural meta-model in the form of UML class diagram, along with adapter, is added to the system, one or more rules and generation algorithms result. Generated rules get added to the rules repository.","For each meta-model, at least one of the following rules gets generated according to the template.",{"@attributes":{"id":"p-0079","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Meta-Model Rules Template"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"model(M, \u2018$ModelType\u2019)"]},{"entry":[{},":-model(M1, \u2018$ModelType1\u2019),"]},{"entry":[{},"adapter(\u2018getModel\u2019, model(M, \u2018$ModelType\u2019), model( M1,"]},{"entry":[{},"\u2018$ModelType1\u2019))."]},{"entry":[{},"model(M, \u2018$ModelType\u2019)"]},{"entry":[{},":-element(E1, \u2018$ModelElementType1\u2019,model(M1,\u2018$ModelType1\u2019)),"]},{"entry":[{},"adapter(\u2018getModel\u2019, model(M, \u2018$ModelType\u2019), element( El,"]},{"entry":[{},"\u2018$ModelElementType1\u2019,model(M1, \u2018$ModelType1\u2019))."]},{"entry":[{},"\u2009model(M, \u2018$ModelType\u2019)"]},{"entry":[{},":- adapter(\u2018getModel\u2019, model(M, \u2018$ModelType\u2019), Props)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The placeholder \u2018$ModelType\u2019 in the template gets replaced by the name of the meta-model as the rules are added. When one of these rules is evaluated with given values to the variables used in RHS of the rule, each solution for variable M reflects one model of \u2018$ModelType.\u2019 The value of variable M could be, for example, a prolog list of binary functors containing the key-value pairs.","The adapter clauses in essence retrieve instances of the meta-models from actual source components and create ground facts in Prolog. As described herein, adapter clauses are implemented by a variety of query mechanisms such as, for example, an XQuery for XML files and JMX calls for querying collecting statistics of system resources, etc.","For each class in a UML class diagram, the following rule can be generated:",{"@attributes":{"id":"p-0083","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Class Rules Template"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"element(E, \u2018$ElementType\u2019, model(M, \u2018$ModelType\u2019))"]},{"entry":[{},"\u2009:- adapter(\u2018getElement\u2019, element(E, \u2018$ElementType\u2019, model(M,"]},{"entry":[{},"\u2018$ModelType\u2019)))."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The placeholder \u2018$Element Type\u2019 gets replaced by the name of the class. When this rule is evaluated with a given value of variable M, each solution for variable E reflects an instance of class \u2018$ElementType\u2019 in model M of \u2018$ModelType.\u2019 The value of variable E would be a prolog list of binary functors named \u2018attribute,\u2019 where each unique functor contains the name of one attribute defined in the class \u2018$ElementType\u2019 and its value (for example, if there is an instance of class C containing attributes a, and a with values v, and v, one solution to E would be [attribute(a, v), attribute(a, v)]).","For each association relationship in the UML class diagram, the following rules can be generated:",{"@attributes":{"id":"p-0086","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Relationship Rule Template"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"relation(\u2018$RelationType\u2019,"]},{"entry":[{},"element(E1, \u2018$ElementType1\u2019, model(M, \u2018$ModelType\u2019)),"]},{"entry":[{},"element(E2, \u2018$ElementType2\u2019, model(M, \u2018$ModelType\u2019)))"]},{"entry":[{},":- $Constraint"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The placeholder \u2018$Relation Type\u2019 gets replaced by the name of the relation, $ElementType and $ElementType get replaced by the name of the source and destination UML classes, respectively. Also, $ModelType gets replaced by the name with which the meta-model is added to the system. $Constraint gets replaced by the constraint expressed by rules mostly, but not limited to, in terms of E1, E2, and M. The constraint cannot be automatically generated by plain class diagram. It has to be augmented with constraint expressed in the rule language. In an illustrative embodiment of the invention, constraint can be assumed to be specified in prolog syntaxes. When this rule is evaluated with given values of any combination of variables E1, E2, and M, each solution to the unbounded variables, along with already bounded variables, reflects a relation between instances E1, and E2 of type $ElementType, and $ElementType, respectively, in model M of type $ModelType.","In the case of UML composition relationship and certain cases of association relationship, the evaluation of constraints may need to consider the conditions that are external to the meta-model. In other words, those properties are not captured in meta-model. In these cases, the responsibility can be delegated to figure out the relationship between model elements to the adapter of the meta-model by following rule:",{"@attributes":{"id":"p-0089","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Relationship Validation Template"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"relation(\u2018$RelationType\u2019,"]},{"entry":[{},"element(E1, \u2018$ElementType1\u2019, model(M, \u2018$ModelType\u2019)),"]},{"entry":[{},"element(E2, \u2018$ElementType2\u2019, model(M, \u2018$ModelType\u2019)))"]},{"entry":[{},":- adapter(\u2018getRelation\u2019, \u2018$RelationType\u2019"]},{"entry":[{},"element(E1, \u2018ElementType1\u2019, model(M, \u2018$ModelType\u2019)),"]},{"entry":[{},"element(E2, \u2018ElementType2\u2019, model(M, \u2018$ModelType\u2019)))."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Inheritance relation can be treated as a special case and can be handled at meta-level only because all of the instances are going to follow it. From instances, it is possible to check their type and get access to the attributes in the tree of inheritance hierarchy. One expedient way of defining meta-models within one or more embodiments of the invention is to start with XML schemas because most of the meta-models of application components in SOA environment are defined through specifications augmented by XML schemas and file system packaging instructions. Standard mechanisms can be used to represent XML schemas into UML class diagrams and generate corresponding Xqueries-based adapters to instantiate the model elements and relationships among them. These UML class diagrams can be further enhanced, for example, by adding more associations and semantic constraints.",{"@attributes":{"id":"p-0091","num":"0096"},"figref":["FIG. 10","FIG. 10"],"b":"1002"},{"@attributes":{"id":"p-0092","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"BPEL4WS MetaModel Rules"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"model(M, \u2018BPEL\u2019)"]},{"entry":[{},":- model(M1, \u2018SCAComponent\u2019),"]},{"entry":[{},"adapter(\u2018getModel\u2019, model(M, \u2018BPEL\u2019), model(M1,"]},{"entry":[{},"\u2018SCAComponent\u2019))."]},{"entry":[{},"element(E, \u2018partnerlink\u2019, model(M, \u2018BPEL\u2019))"]},{"entry":[{},":- adapter(\u2018getElement\u2019,element(E, \u2018partnerlink\u2019, model(M,"]},{"entry":[{},"\u2018BPEL\u2019)))."]},{"entry":[{},"element(E, ,\u2018invoke\u2019, model(M, \u2018BPEL\u2019))"]},{"entry":[{},":- adapter(\u2018getElement\u2019, element(E, \u2018partnerlink\u2019, model(M,"]},{"entry":[{},"\u2018invoke\u2019)))."]},{"entry":[{},"relation(\u2018uses\u2019,"]},{"entry":[{},"element(E1, \u2018invoke\u2019, model(M, \u2018BPEL\u2019)),"]},{"entry":[{},"element(E2, \u2018partnerlink\u2019, model(M, \u2018BPEL\u2019)))"]},{"entry":[{},":- member(attribute(\u2018partnerLink\u2019, X), E1),"]},{"entry":[{},"member(attribute(\u2018name\u2019, Y), E2),"]},{"entry":[{},"X=Y."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The structure of middleware components can be described in a UML class diagram, and the rules can be generated using similar techniques as used for meta-models of application components. For capturing the behavioral details of middleware components, one can use a UML activity diagram with following additions. Each data type associated with data pins should be one of the types defined in one of the structural meta-models. Also, if an action invokes the operation, it should be on one of the instances of a type defined in the structural meta-model. Additionally, several annotations can be used on different kind of elements in a UML activity meta-model for capturing properties that are of interest in a QoS analysis such as, for example, {upper Bound} for pins to indicate the buffer size of the pin, {reentrant} for action to indicate the parallel processing of action on data in a buffer at input pins, {resource} for a central buffer to differentiate the middleware resources from the data, etc.",{"@attributes":{"id":"p-0094","num":"0099"},"figref":["FIG. 11","FIG. 12","FIG. 11","FIG. 12","FIG. 12"],"b":["1102","1202"]},"The following are exemplary semantics that can be, for example, extracted out of the above activity diagram. The \u2018Establish TCP connection\u2019 action is activated when a \u2018TCP connect request\u2019 arrives at an input data pin of the action. The buffer size of an input data pin is specified by \u2018serverSocket.backlog\u2019 configuration (that is, if a \u2018TCP connect request\u2019 arrives while the buffer is full, it will be rejected). The action \u2018Establish TCP connection\u2019 works on \u2018TCP connect request\u2019 one by one and produces two outputs, one control output and one data output. The control output activates the \u2018Obtain Reader Thread\u2019 action and data output (that is, \u2018con:TCPConnection\u2019 flows to \u2018Read Request\u2019 action that also requires one \u2018Thread\u2019 in order to get activated). Many instances of the \u2018Read Request\u2019 action can execute concurrently to work on a buffer of \u2018TCPConnections\u2019 on its input pin because it is marked as <<reentrant>>. \u2018<<signal . . . >>\u2019 shows that if \u2018Obtain Reader Thread\u2019 does not finish after the \u2018ThreadPool.timeout\u2019 period of its start, it will finish the flow. The rest of the actions and control and data flow edges can be explained in a similar manner.","Each of the actions can be further explained in more granularities either with in-same behavioral model or in-separate suitable models. For example, \u2018Establish TCP Connection\u2019 and \u2018Obtain Reader Thread\u2019 actions can have detailed state machine-based models to explain the further internal details of the actions while the \u2018process request and write response\u2019 action can be better elaborated in an activity-based model to highlight the details of how a web resource requested is located and\/or instantiated and executed, as well as the role of cache and session management in the process, etc.","Similarly, behavior of other infrastructure components can be described using UML activity models. The semantics of UML activity meta-model can be captured, as shown partially in  using the same technique as described for the meta-models of application components.  is a diagram illustrating a meta-model  of an UML activity diagram, according to an embodiment of the present invention.","The generated rules can be universally applied to any activity diagram describing a middleware component. As described herein, only a few exemplary rules are discussed to demonstrate the semantics of behavior models of middleware containers, primarily those rules necessary to know the sequencing of resources consumed in processing of any activity model.",{"@attributes":{"id":"p-0099","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"UML activity meta-model rules"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"relation(\u2018follows\u2019,"]},{"entry":[{},"element(E1, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"element(E2, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019)))"]},{"entry":[{},":- relation(\u2018incomingEdge\u2019,"]},{"entry":[{},"\u2003\u2003element(E3, \u2018ControlFlow\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003\u2003element(E1, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019))),"]},{"entry":[{},"\u2003relation(\u2018outgoingEdge\u2019,"]},{"entry":[{},"\u2003\u2003\u2009element(E3, \u2018ControlFlow\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003\u2003\u2009element(E2, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019)))."]},{"entry":[{},"relation(\u2018incomingEdge\u2019,"]},{"entry":[{},"\u2003\u2009element(E1, \u2018ControlFlow\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003\u2002element(E2, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019)))"]},{"entry":[{},":- adapter(\u201cincomingEdge\u2019,"]},{"entry":[{},"\u2003\u2003\u2003element(E1, \u2018ControlFlow\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003\u2003\u2003element(E1, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019))))."]},{"entry":[{},"relation(\u2018obtains\u2019,"]},{"entry":[{},"\u2003element(E1, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003element(E2, \u2018CentralBuffer\u2019, model(M, \u2018UMLActivity\u2019)))"]},{"entry":[{},":- relation(\u2018belongsTo\u2019,"]},{"entry":[{},"\u2003\u2003element(E3, \u2018InputPin\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003\u2003element(E1, \u2018Action\u2019, model(M, \u2018UMLActivity\u2019))),"]},{"entry":[{},"\u2003relation(\u2018dataflow\u2019,"]},{"entry":[{},"\u2003\u2003\u2002element(E2, \u2018CentralBuffer\u2019, model(M, \u2018UMLActivity\u2019)),"]},{"entry":[{},"\u2003\u2003\u2002element(E3, \u2018InputPin\u2019, model(M, \u2018UMLActivity\u2019))),"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As described herein, a model adapter is a component in one or more embodiments of the invention that is responsible for creating instances of meta-models (that is, models, model elements, and basic relationships describing meta-model semantics). There are a variety of ways in the techniques described herein to locate and discover instances of models of different meta-models, and to extract the model elements represented by adapter rules starting with, for example, \u2018model\u2019, and \u2018element\u2019 predicates, respectively. For example, in order to locate an instance of \u2018J2EE application\u2019 meta-model, an adapter needs to know how to get the ear files on a J2EE application server, and given an ear file, how to extract instances of elements in the model following the packaging standards and XML schemas of descriptors of J2EE application.","In an illustrative embodiment of the invention, the adapter would accept the element \u2018ApplicationServer\u2019 in a model of type \u2018J2EE Application Server\u2019 meta-model and would be able to locate the models of type \u2018J2EE Application\u2019 corresponding to each application deployed on the server. Further, for each application model, the adapter would extract the instances of elements of \u2018module\u2019 by firing proper XQuery on application.xml found in a META-INF folder under the root folder of ear file. One of the adapter rules accepts the properties' object in place of any other model or model element. Such a provision can, for example, be used for bootstrapping the system to enable it find the models of at least one meta-model without depending on other models or model elements. In an illustrative embodiment of the invention, there can be such a bootstrapping adapter that accepts a list of IP addresses and locates the \u2018J2EE application server\u2019 models. Such a provision also enables the integration of external repositories into the framework (for example, a change and configuration management database (CCMDB)).","In one or more embodiments of the present invention, each of the meta-models can be combined to create a network of semantically integrated meta-models of a system. Stitching between meta-models can be defined as the process of capturing the relationship among different meta-models. The relationship can exist between elements of a meta-model and another meta-model, or between two elements from two separate meta-models. For example, whenever a new stitch with relationship name $RelationType is added into our framework one of the rules get generated as per the template described below.",{"@attributes":{"id":"p-0103","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Stitching Relationship Rule Template"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"relation(\u2018$RelationType\u2019,"]},{"entry":[{},"element(E1, \u2018$ElementType1\u2019, model(M1, \u2018$ModelType1\u2019)),"]},{"entry":[{},"model(M2, \u2018$ModelType2\u2019))"]},{"entry":[{},":- $Constraints"]},{"entry":[{},"relation(\u2018$RelationType\u2019,"]},{"entry":[{},"element(E1, \u2018$ElementType1\u2019, model(M1, \u2018$ModelType1\u2019)),"]},{"entry":[{},"element(E2, \u2018$ElementType2\u2019, model(M2, \u2018$ModelType2\u2019)))"]},{"entry":[{},":- $Constraints"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0104","num":"0109"},"figref":["FIG. 14","FIG. 14"],"b":"1402"},"Consider a composite SOA application where a BPEL process includes services from several web services, and the web services are implemented by J2EE components. Multiple layers of artifacts are involved. For example, process and web service components can be packaged as service component architecture (SCA) models where inter-component linkages are expressed as \u201cwires.\u201d An SCA component encapsulating a BPEL process refers to SCA components encapsulating web services as \u201cimport\u201d references. Inside BPEL components, the activities that invoke the services can be referred to as \u201cpartner links.\u201d The concept \u201cpartner link\u201d in BPEL models should advantageously be semantically linked with \u201creferences\u201d in SCA models. As shown in , this semantic relationship is expressed as a stitching relationship \u201cconnected.\u201d",{"@attributes":{"id":"p-0106","num":"0111"},"figref":["FIG. 14","FIG. 14"],"b":"19"},"An exemplary stitching rule for \u2018calls\u2019 relationship between \u2018invoke\u2019 element of BPEL meta-model and \u2018port\u2019 element of WSDL meta-model is also depicted in . The rule is defined in terms of other rules, including BPEL meta-model semantics rule as a \u2018uses\u2019 relationship between \u2018invoke\u2019 and \u2018partner link\u2019 elements, and other stitching rules such as a \u2018connectedTo\u2019 relationship between the \u2018partnerlink\u2019 element of BPEL meta-model and the \u2018reference\u2019 element of a SCA meta-model.",{"@attributes":{"id":"p-0108","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Rule for \u2018calls\u2019 relationship"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"relation(\u2018calls\u2019,"]},{"entry":[{},"element(E1, \u2018invoke\u2019, model(M1, \u2018BPEL\u2019)),"]},{"entry":[{},"element(E2, \u2018port\u2019, model(M2, \u2018WSDL\u2019)))"]},{"entry":[{},":- relation(\u2018uses\u2019,"]},{"entry":[{},"\u2003element(E1, \u2018invoke\u2019, model(M1, \u2018BPEL\u2019)),"]},{"entry":[{},"\u2003\u2003element(E3, \u2018partnerlink\u2019, model(M1, \u2018BPEL\u2019))),"]},{"entry":[{},"\u2009relation(\u2018connectedTo\u2019,"]},{"entry":[{},"\u2003element(E3, \u2018partnerlink\u2019, model(M1, \u2018BPEL\u2019)),"]},{"entry":[{},"\u2003element(E4, \u2018reference\u2019, model(M3, \u2018SCAModule\u2019))),"]},{"entry":[{},"\u2009relation(\u2018connectedTo\u2019,"]},{"entry":[{},"\u2003element(E4, \u2018reference\u2019, model(M3, \u2018SCAModule\u2019)),"]},{"entry":[{},"\u2003element(E5, \u2018import\u2019, model(M3, \u2018SCAModule\u2019))),"]},{"entry":[{},"relation(\u2018connectedTo\u2019,"]},{"entry":[{},"\u2003element(E5, \u2018import\u2019, model(M3, \u2018SCAModule\u2019)),"]},{"entry":[{},"\u2003element(E2, \u2018port\u2019, model(M2, \u2018WSDL\u2019)))."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Activity models of different infrastructure components can be related, as one activity of one component's activity model can be described in detail by another component's activity model. This provides an opportunity to describe activity models of different components independently, and subsequently link them. For example, in the activity model of application server, an activity corresponds to the request handling by a web-container, which is described in detail by the activity model of the web-container. This type of relationship is already captured as a \u2018call behavior\u2019 relationship between the action element and activity element in the meta-model of UML activity.","The relations between infrastructure structural meta-model elements and management meta-model elements can be captured using the same technique as described earlier for meta-model stitching. An example of this can be a \u2018sameAs\u2019 relationship between element \u2018ThreadPool\u2019 in a structural meta-model of \u2018Web Container\u2019 and a management meta-model of \u2018Web Container.\u2019","The execution of application components can be carried out by middleware containers. Such a relationship of application components to the middleware containers can be captured, for example, as stitching rule \u2018deployedOn\u2019 in the form as follows.",{"@attributes":{"id":"p-0112","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DeployedOn Relationship"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"relation(\u2018deployeOn\u2019"]},{"entry":[{},"element(A,\u2019servlet\u2019,model(M1,\u2019J2EE Application\u2019),"]},{"entry":[{},"element(W,\u2019WebContainer\u2019,model(M2,\u2019J2EE Application Server\u2019))"]},{"entry":[{},":- relation(\u2018DeployedOn\u2019,"]},{"entry":[{},"\u2003element(App,\u2019Application\u2019,model(M1,\u2019J2EE Application\u2019),"]},{"entry":[{},"\u2003element(S,\u2018ApplicationServer\u2019,model(M2, \u2019J2EE Application"]},{"entry":[{},"Server\u2019)),"]},{"entry":[{},"relation(\u2018belongsTo\u2019,"]},{"entry":[{},"\u2003element(A,\u2019Servlet\u2019,model(M1,\u2019J2EE Application\u2019),"]},{"entry":[{},"\u2003element(App,\u2019Application\u2019,model(M1, \u2019J2EE Application\u2019)),"]},{"entry":[{},"relation(\u2018belongsTo\u2019,"]},{"entry":[{},"\u2003element(W,\u2018WebContainer\u2019,model(M2, \u2018J2EE Application"]},{"entry":[{},"Server\u2019),"]},{"entry":[{},"\u2003element(S,\u2018Server\u2019,model(M2, \u2019J2EE Application Server\u2019))."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Additionally, the infrastructure management meta-model describes management aspects such as, for example, performance monitoring of application components (for example, average time spent in execution of a servlet). This relation can be described, for example, as stitching relation \u2018sameAs\u2019 between an element of application meta-model and a corresponding element of management meta-model (for example, the \u2018sameAs\u2019 relationship between \u2018servlet\u2019 elements in both meta-models for the servlet example).","An integrated model can be a multi-layered graph where model elements are treated as nodes and the relations between them is captured as edges among them. By following a path, one can trace how a new composite application will execute on a given platform, all the way down to resources in the underlying infrastructure. In order to query the integrated model, two types of queries can be supported on this data model. Meta-model queries are for finding the all-node types, and possible relationship types between them. Integrated model queries are for finding the actual instances of the discovered node types and the relation types among them. This also includes queries that are based on the semantics added to the rules repository, using the basic rules for getting nodes and relating them.","A complete graph need not, for example, be stored in a repository, but can be incrementally created by resolving the queries and using appropriate adapters to fetch the desired data at run-time. Additionally, caching can be used for performance, and a federated methodology makes the techniques described herein scalable.",{"@attributes":{"id":"p-0116","num":"0121"},"figref":["FIG. 15","FIG. 15"],"b":["1510","1508","1502","1504","1506","1510"]},"For example, instances of a \u2018J2EE application server\u2019 meta-model can be discovered via execution of a corresponding adapter. For each of these discovered models, an \u2018ApplicationServer\u2019 element is extracted and another adapter corresponding to the \u2018J2EE Application\u2019 meta-model is invoked by passing an \u2018ApplicationServer\u2019 element. Instances of \u2018J2EE Application\u2019 meta-model can also be discovered.","For each of the discovered \u2018J2EE Application\u2019 models, \u2018module\u2019 elements are extracted and using each of these, a \u2018J2EE Web Service\u2019 meta-model can be discovered by a corresponding adapter. Also, \u2018webservice\u2019 elements of each \u2018J2EE Web Service\u2019 model can give the desired answers for the mentioned query. In the exemplary , the result includes only one web service, W .","Explaining a particular step in the above mentioned process in more detail could include, for example, firing the XQuery and\/or application and\/or module on application.xml by an adapter corresponding to the \u2018J2EE Application\u2019 meta-model for instantiating the \u2018module\u2019 element for a discovered model instance of a \u2018J2EE Application\u2019 meta-model.","As depicted in , consider a complex query of finding the resources used while processing a request for web-service W . This query can be decomposed to several sub-queries including finding the application component call path, the \u2018hostedOn\u2019 relation between a component and container, and queries for finding the resources of the container, which in turn uses the structure model and the activity model of containers. In this example, because web service W  is implemented by servlet S , the component level call path includes servlet S . Web service W  and servlet S  both are deployed on web-container WC , as App.Ear  is deployed on AppServer AS , which contains Web Container WC . Using the activity diagram of Web Container , while handling the request, first a thread from Th:Reader  thread pool is obtained, the request is read, the thread is released, and a thread from Th:Worker  thread pool is obtained, the request is processed and the thread is released. So the ordered list of resources consumed inside WC  are Th:Reader  and Th:Worker .","One or more embodiments of the invention include a meta-model driven approach that is part of the model-driven architecture (MDA) movement. The techniques described herein extend the model-driven concepts from development tools to the arena of model-driven systems management. It is in the systems where enterprise IT complexity lies.",{"@attributes":{"id":"p-0122","num":"0127"},"figref":"FIG. 16","b":["1602","1604","1606"]},"The techniques depicted in  can also include answering a query of run-time implications of a design in terms of potential resources consumed by operations of a designed artifact. Additionally, the techniques depicted in  can include answering a query of enterprise implications of infrastructure observations and\/or issues including an exception, a monitored event and\/or a failure.","The techniques depicted in  can also, as described herein, be run on a system, wherein the system includes distinct software modules, each of the distinct software modules being embodied on a tangible computer-readable recordable storage medium.","Also, one or more embodiments of the invention include a system for co-relating at least one of a functional design and at least one implementation artifact of a solution with at least one infrastructure component of a target deployment environment for the solution. Such a system can include, for example, a synthesizer that integrates input models, source connectors that import respective models from a source and wherein the source is a design tool, a file system and\/or an infrastructure component. Such a system can also include meta-models, wherein each meta-model captures semantics of a corresponding model in terms of entity type, relationship type and\/or behavior of a given kind of model, as well as stitching relationships among elements of the meta-models that describe relationships among a set of meta-model elements from multiple meta-models that are semantically related.","Query mechanisms for source connectors can further be of several ways inclusive of, for example, Xquery\/Xpath for models expressed as XML files, and JMX, if it is supported in the infrastructure. The synthesizer (for example, an execution graph synthesizer) can, for example, process submitted queries by using information from multiple meta-models by traversing stitching relationships to decompose submitted queries into sub-queries on appropriate models. A synthesizer can also, for example, direct the sub-queries to at least one respective model via the source connectors to retrieve information from actual sources.","New meta-models can be added to the system and related to the meta-models by adding at least one appropriate stitching relationship, thereby making the system extensible. Also, the input models can include, for example, functional design and implementation artifacts, placement directives for deploying the functional artifacts on a target infrastructure, and\/or a model of properties and contents of components of the target infrastructure. Each model can include specific entities and relationships describing structure and\/or behavior of functional design artifacts, a target infrastructure component, and\/or placement directives.","The meta-models can include, for example, meta-models of structure and\/or behavior of typical development artifacts in an SOA system, meta-models of structure and behavior of infrastructure components, and\/or meta-models of structure and behavior of management facilities (including, for example, JMX, simple network management protocol (SNMP), etc.) for infrastructure components and functional components, wherein each meta-model describes structure and\/or behavior of models admitted by the meta-model. Structural meta-models can be further expressed by representations such as, for example, UML class diagrams, UML composite structure diagrams, and\/or XML schemas.","The meta-models of structure and behavior of typical development artifacts in an SOA system can include, for example, definitions of a BPEL process, web services and\/or implementation artifacts of the web services (such as, for example, enterprise JavaBeans (EJBs), servlets, etc.). The meta-models of structure and behavior of infrastructure components can include, for example, a process server, a web container and\/or a managed object container in an application server (which are typical of contemporary J2EE or .Net middleware environment) and resource sub-components of these infrastructure components. Behavioral meta-models can further include UML behavioral models such as activity diagrams, sequence diagrams and collaboration diagrams, and layered queuing networks.","Semantics of the stitching relationships and semantics of relationships used in the meta-models can be, for example, expressed in an executable rules language (including, for example, Prolog and\/or agent building and learning environment (ABLE) and interpreted by suitable forward and backward-chaining traversal algorithms implemented in a conventional programming language (including, for example, Java or C++ or C). Furthermore, implications of multiple relationships can also be expresses as higher level rules. A synthesizer, as detailed above, can include, for example, a rules execution engine to interpret and reason with rules to implement query decomposition processing. Additionally, the meta-models and stitching relationships can be translated into rules in an executable rules language (that can be, for example, inferences with and\/or by a rules execution engine).",{"@attributes":{"id":"p-0131","num":"0136"},"figref":["FIG. 17","FIG. 17"],"b":["1702","1","1","2","1","2"]},"As detailed herein, for example, path P can be an ordered list of relationship definitions of the form Rk(ETi, ETi+1), where the relationship Rk is between \/\/ element type ETi and element type ETi+1 in some model traversed during the construction of model level path P. Additionally, for every element type ETi in the model level path P, one or more embodiments of the invention can locate an element Ei of element type ETi in a source component Si such that ETi is in a model Mi, and wherein source Si is an instance of model Mi. Also, the source adapter for a model is capable of locating a source component instance of a model by searching an IT environment.","Further, as depicted in , one or more embodiments of the invention can include instantiating model level path P to get instantiated path P\u2032 by substituting E1 for ET and E2 for ET in the relationships in path P, and for all other intermediate element types ETi in the relationships in P, by substituting each element type ETi by a corresponding instance element Ei (as described herein). The techniques detailed herein also include checking the validity of the instantiated path P\u2032 such that the constraints of every relationship r(Ei,Ej) in path P\u2032 are satisfied by the properties of the elements Ei and Ej.","If the instantiated path P\u2032 is not valid, then one can find another model level path P and repeat the process. Also, one or more embodiments of the invention include returning instantiated path P\u2032 as result.",{"@attributes":{"id":"p-0135","num":"0140"},"figref":["FIG. 18","FIG. 18"],"b":["1804","1802","1806","1808","1806","1820","1822","1824"]},{"@attributes":{"id":"p-0136","num":"0141"},"figref":"FIG. 18","b":["1818","1814","1816","1814","1810","1808","1816","1812","1808"]},{"@attributes":{"id":"p-0137","num":"0142"},"figref":"FIG. 19","b":["1902","1904","1906","1908","1906","1908","1910"]},"Step  includes deciding whether to proceed to step  or  (both described herein). Additionally, step  includes generating executable rules from input model M, stitching relationships and mapping file MF into the knowledge-base. Step  includes generating programs for implementing a source adapter from mapping file MF.","A variety of techniques, utilizing dedicated hardware, general purpose processors, software, or a combination of the foregoing may be employed to implement the present invention. At least one embodiment of the invention can be implemented in the form of a computer product including a computer usable medium with computer usable program code for performing the method steps indicated. Furthermore, at least one embodiment of the invention can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.","At present, it is believed that the preferred implementation will make substantial use of software running on a general-purpose computer or workstation. With reference to , such an implementation might employ, for example, a processor , a memory , and an input and\/or output interface formed, for example, by a display  and a keyboard . The term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other forms of processing circuitry. Further, the term \u201cprocessor\u201d may refer to more than one individual processor. The term \u201cmemory\u201d is intended to include memory associated with a processor or CPU, such as, for example, RAM (random access memory), ROM (read only memory), a fixed memory device (for example, hard drive), a removable memory device (for example, diskette), a flash memory and the like. In addition, the phrase \u201cinput and\/or output interface\u201d as used herein, is intended to include, for example, one or more mechanisms for inputting data to the processing unit (for example, mouse), and one or more mechanisms for providing results associated with the processing unit (for example, printer). The processor , memory , and input and\/or output interface such as display  and keyboard  can be interconnected, for example, via bus  as part of a data processing unit . Suitable interconnections, for example via bus , can also be provided to a network interface , such as a network card, which can be provided to interface with a computer network, and to a media interface , such as a diskette or CD-ROM drive, which can be provided to interface with media .","Accordingly, computer software including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (for example, ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (for example, into RAM) and executed by a CPU. Such software could include, but is not limited to, firmware, resident software, microcode, and the like.","Furthermore, the invention can take the form of a computer program product accessible from a computer-usable or computer-readable medium (for example, media ) providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer usable or computer readable medium can be any apparatus for use by or in connection with the instruction execution system, apparatus, or device.","The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid-state memory (for example, memory ), magnetic tape, a removable computer diskette (for example, media ), a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read only memory (CD-ROM), compact disk-read and\/or write (CD-R\/W) and DVD.","A data processing system suitable for storing and\/or executing program code will include at least one processor  coupled directly or indirectly to memory elements  through a system bus . The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.","Input and\/or output or I\/O devices (including but not limited to keyboards , displays , pointing devices, and the like) can be coupled to the system either directly (such as via bus ) or through intervening I\/O controllers (omitted for clarity).","Network adapters such as network interface  may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening networks. Modems, cable modem and Ethernet cards are just a few of the currently available types of network adapters.","In any case, it should be understood that the components illustrated herein may be implemented in various forms of hardware, software, or combinations thereof, for example, application specific integrated circuit(s) (ASICS), functional circuitry, one or more appropriately programmed general purpose digital computers with associated memory, and the like. Given the teachings of the invention provided herein, one of ordinary skill in the related art will be able to contemplate other implementations of the components of the invention.","At least one embodiment of the invention may provide at least one beneficial effect, such as, for example, execution models of middleware containers at multiple levels of granularity.","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
