---
title: Shared memory based monitoring for application servers
abstract: A system and method to monitor application servers using shared monitoring memory. An application server includes worker nodes having Java virtual machines to process work requests received by the application server. Status information is generated for each of the worker nodes while processing the work requests. The status information for each of the worker nodes is then stored into the shared monitoring memory while the worker nodes operate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07562138&OS=07562138&RS=07562138
owner: SAP
number: 07562138
owner_city: Walldorf
owner_country: DE
publication_date: 20041228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to application servers, and in particular but not exclusively, relates to monitoring application servers using shared memory.","Enterprise software has transformed the way diverse enterprises, large and small a like, transact and manage day-to-day operations. Businesses use enterprise software (e.g., web based application servers) to control production planning, purchasing and logistics, warehouse and inventory management, production, vendor management, customer service, finance, personnel management, and other basic business activities. As the enterprise software industry continues to mature, the various application and hardware resources enlisted to facilitate this diverse set of tasks are being amalgamated into robust, highly integrated solutions (e.g., SAP NetWeaver, SAP xAPPs, mySAP Business Suite, etc.).","To integrate diverse hardware and software resources, developers of enterprise software have leveraged cross platform engines capable of minimizing or even severing platform dependencies from the enterprise solution. The Java 2 Platform, Enterprise Edition\u2122 (\u201cJ2EE\u201d) (e.g., J2EE Specification, Version 1.4) is a Java based solution supported by the Java Virtual Machine (\u201cJVM\u201d) engine. J2EE simplifies application development and decreases the need for programming and programmer training by creating standardized and reusable modular components. The popularity of Java based solutions is evident as the Information Technology (\u201cIT\u201d) world has gravitated to the Java language.","As enterprise software is woven into the fabric of modern business, failure of an enterprise solution may no longer be a mere nuisance, but has the potential to wreak catastrophic havoc on a business. As such, robust, reliable software is evermore critical. The enterprise software industry is marching toward the ultimate goal of self-healing software capable of sustainable, uninterrupted operation, without human intervention. In pursuit of this goal, IT technicians can benefit from convenient tools capable of monitoring the health of their enterprise software. With appropriate monitoring tools, IT technicians can take appropriate action in a timely manner to ensure a healthful state of their software or to spot delinquent applications and prevent repeat offenders. Currently, JVMs do not provide adequate mechanisms to monitor their internal operation on a real-time basis.","A system and method to monitor application servers using shared monitoring memory. An application server includes worker nodes having Java virtual machines to process work requests received by the application server. Status information is generated for each of the worker nodes while processing the work requests. The status information for each of the worker nodes is then stored into the shared monitoring memory while the worker nodes operate.","In one embodiment, if a worker node is terminated, the status information corresponding to the terminated worker node is copied into a log file from the shared monitoring memory. Once the log file is generated, portions of the shared monitoring memory occupied by the status information corresponding to the terminated worker node are reclaimed.","In one embodiment, the status information is retrieved from the shared monitoring memory and transmitted to a management console to display the status information.","Embodiments of the invention may include all or some of the above described features. The above features can be implemented using a computer program, a method, a system or apparatus, or any combination of computer programs, methods, or systems. These and other details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["100","100","105","110","105","115","120","120","120","125","130","105","125","130"]},"In the illustrated embodiment, worker nodes  each include a Java virtual machine (\u201cJVM\u201d) , one or more internal managers\/monitors (e.g., a virtual machine (\u201cVM\u201d) monitor , a thread manager , and a session manager ), and a shared memory application programming interface (\u201cAPI\u201d)  all supported within a native wrapper . JVMs  interpret and execute Java programs  while servicing work requests assigned to the particular worker node . Although  illustrates only two worker nodes  within AS instance , more or less worker nodes  may be established within AS instance  to service the work requests.","During operation of worker nodes , the internal managers\/monitors (e.g., VM monitor , thread manager , session manager , etc.) update shared monitoring memory  with status information. In one embodiment, the status information is logically organized into topic buffers A, B, and C (collectively ) containing topically related status information from each of worker nodes . Each topic buffer  may include multiple slots S-SN, each holding the topically related status information from a respective one of worker nodes . Once the status information is stored into shared monitoring memory , the status information may be retrieved from shared monitoring memory  by network interface  and transmitted to management console  for display thereon. Using management console , an information technology (\u201cIT\u201d) technician can remotely monitor the operational health of AS instance  in real-time to ensure AS instance  remains in a healthful state. Shared monitoring memory  working in concert with management console , enables the IT technician to make informed decisions when taking preventative and\/or remedial action to effectively maintain and manage an enterprise system.","JVMs  interpret Java programs  by converting them from an intermediate interpreted language (e.g., Java bytecode) into a native machine language, which is then executed. Java programs  may be interpreted and executed by JVMs  to provide the business, presentation, and integration logic necessary to process the work requests received at AS instance . As the work requests are serviced, sessions are setup and taken down, threads assigned, and memory and processor cycles consumed. Shared monitoring memory  provides a mechanism by which these operational characteristics of worker nodes , as well as others, may be monitored.","VM monitor , thread manager , and session manager  are generators of status information describing the operational status of various aspects of worker nodes . Although only three such generators are illustrated in , it should be appreciated that worker nodes  may include any number of generators of status information to monitor various aspects of worker nodes . In many cases, these generators of status information are event based, rather than polled. As such, shared monitoring memory  is updated with status information as it is generated, rather than shared monitoring memory  polling each worker node  for status information. For example, shared monitoring memory  may be updated each time a work request is assigned to a particular one of worker nodes , in response to session events, in response to thread events, and various other JVM  events. Event based updates are less processor intensive since they do not waste processor cycles querying for updates that do not yet exist. Furthermore, updates are more quickly published into shared monitoring memory  after the occurrence of an update event providing more up-to-date monitoring data.","Native wrapper  provides the runtime environment for JVM . In an embodiment where JVM  is a JVM compliant with the J2EE standard, native wrapper  is often referred to as \u201cJLaunch.\u201d Native wrapper  is native machine code (e.g., compiled C++) executed and managed by an operating system (\u201cOS\u201d) supporting AS instance . Once launched, native wrapper  establishes JVM  within itself. In one embodiment, the generators of status information (e.g., VM monitor , thread manager , session manager , etc.) are native code components of native wrapper . As such, even in the event of a failure of JVM , the generators of the status information can still operate providing updates on the failure status of the particular JVM . In other embodiments, a generator of status information may indeed be interpreted and executed on JVM , in which case a failure of JVM  would also terminate the particular generator.","While processing work requests, connections may be established between a client generating the work request and the particular worker node  servicing the work request. While the connection is maintained a session is established consisting of a series of interactions between the two communication end points (i.e., the worker node and the client). In one embodiment, session manager  is responsible for the overall managing and monitoring of these sessions, including setting up and taking down the sessions, generating session status information , and reporting session status information  to an appropriate one of topic buffers . For example, topic buffer A may be a \u201csession buffer\u201d assigned to store session related status information. In one embodiment, session manager  registers a different slot for each session currently open and active on its corresponding one of worker nodes .","As discussed above, Java programs  may be executed to provide the business, presentation, and integration logic necessary to process the work requests. During execution of Java programs , a thread may be assigned to act as a placeholder of information associated with each use of Java programs , thereby handling multiple concurrent users\/clients. If one of Java programs  initiates an input\/output (\u201cI\/O\u201d) request, such as accessing a database, a thread may be assigned to the particular Java program . Data kept as part of a thread allows the particular Java program  to be reentered at the right place when the I\/O operation complete. A pool of threads may be maintained and made available within each worker node  for use by Java programs  executing on the particular worker node . In one embodiment, this pool of threads and the threads themselves are managed by thread manager . In one embodiment, thread manager  generates thread status information  and reports thread status information  to an appropriate topic buffer . For example, topic buffer B may be a \u201cthread buffer\u201d assigned to store thread related status information. In one embodiment, thread manager  registers a different slot for each active thread on its corresponding one of worker nodes .","VM monitor  may monitor various internal activities of JVM . For example, VM monitor  may monitor the work load of JVM  and report overload situations into shared monitoring memory . VM monitor  may further monitor an internal heap of JVM  and report memory scarce situations into shared monitoring memory . VM monitor  may even monitor garbage collecting activity within JVM  and report over active garbage collecting situations into shared monitoring memory . It should be appreciated that any aspect of worker nodes  capable of monitoring may be monitored by a generator of status information and the status information copied into a relevant topic buffer  and associated slots S-SN.","The generators of the status information (e.g., session manager , thread manager , VM monitor , etc.) access shared monitoring memory  via shared memory API . In one embodiment, shared memory API  abstracts access to shared monitoring memory  through use of function calls. Each generator of status information that wishes to copy status information into shared monitoring memory  makes a \u201ccall\u201d to one or more functions published internally to worker nodes  by shared memory APIs . The generator then passes the generated status information to the called function. In turn, the called function copies the status information into the appropriate slots and topic buffers .","In one embodiment, shared monitoring memory  is a portion of system memory pre-reserved to store status information. Abstracting access to shared monitoring memory  with shared memory APIs  insulates and protects the contents of shared monitoring memory  from each worker node . Should a worker node  crash, enter an infinite loop, or otherwise fail, the status information saved into shared monitoring memory  may still be protected and preserved from corruption.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["200","115","105","205","125","115","210","125","115"]},"Once shared monitoring memory  is established and named, control unit  launches each of worker nodes . Control unit  is responsible for the life cycles of worker nodes . Control unit  can launch a new worker node , terminate an existing worker node  at an end of its useful life cycle, or restart a hung, or otherwise problematic, worker node .","After each worker node  is established, the worker node  attaches to shared monitoring memory  via shared memory API  (process block ) and register its resources within shared monitoring memory  (process block ). Registering resources may include registering a slot for each session and thread, registering the number of Java objects stored within an internal heap of the worker node, registering available memory within the heap, and the like. In one embodiment, the first worker node  to register within shared monitoring memory  may create topic buffers  to store its status information. Subsequent worker nodes  simply register a new slot within the existing topic buffers . In an alternative embodiment, control unit  creates topic buffers  when shared monitoring memory  is initially established.","Once worker nodes  have registered their initial resources within shared monitoring memory , worker nodes  are ready to receive and process work requests. Work requests are tasks to be performed and are assigned to the individual worker nodes  by a dispatcher or other load balancing mechanism. The tasks may be as simple as a request to retrieve data from a database to performing complex computations on the data retrieved from the database, and formatting the computational results for display on a client. If a request is received by one of worker nodes  (decision block ), process  continues to a process block .","In process block , the designated worker nodes  services the work request. In most cases, servicing a work request requires JVM  to execute one or more Java programs  providing the logic necessary to carry out the requested task. While executing Java programs , one or more update events may occur (decision block ). Update events are events that occur during operation of worker nodes  deemed important enough to report into shared monitoring memory  for the purpose of monitoring worker nodes . In the example of session manager , update events may include the creation of a new session and the termination of an existing session.","In a decision block , if the update event is not a terminated worker node , then process  continues to a process block . In process block , status information regarding the update event is reported into shared monitoring memory  within the appropriate topic buffer  and slot S-SN, as discussed above. Multiple update events may occur during the course of servicing a single work request. As such, process  may loop around loop  a number of times before the current work request is complete (decision block ). Once servicing a work request is complete, process  returns to decision block  to wait for the next work request.","Returning to decision block , if the update event is a termination of one of worker nodes , then process  continues to a process block . In process block , status information currently stored within shared monitoring memory  relating to the terminated one of worker nodes  is copied into a log file  by control unit . In one embodiment, control unit  may include final status information (e.g., termination time, termination reason, etc.) within log file . In a process block , control unit  reclaims the portions of shared monitoring memory  consumed by the status information relating to the terminated one of worker nodes  for future use by other ones of worker nodes .",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","b":["300","115","110","305","110","130","105","110","130","130","105"]},"Upon receipt, the status query is passed to a monitoring API . Monitoring API  accesses the requested portions of shared monitoring memory  via shared memory API  (process block ). In a process block , monitoring API  retrieves the requested portions of the status information from shared monitoring memory . Once retrieved, monitoring API  may use XML syntax to convey the retrieved status information back to management console  (process block ).","In a process block , management console  formats the received status information and renders it to a screen for review by an IT technician. Management console  may display status information received from a number AS instances  to monitor an entire cluster of AS instances . Management console  may further optionally generate log files to maintain long-term status reports on each AS instance  being monitored (process block ).","In addition to issuing status requests, management console  may negotiate a reporting contract with network interface  to serve up the status information on a regular or periodic basis, without need of status requests. As such, network interface  may be capable of pushing the status information to management console , as well as, management console  pulling the status information from network interface .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","b":["400","400","405","407","410","405","415","105","420","422","425","427","430"]},"AS instances  may be web application servers, such as Web AS by SAP, .NET by Microsoft, or the like. As discussed above, each AS instance  may include one or more worker nodes  to execute Java programs  and service work requests . It should be appreciated that various components of AS instances  have been excluded from  for the sake of clarity and so as not to obscure the invention. In one embodiment, worker nodes  may be compliant with the J2EE standard. In one embodiment, worker nodes  may be compliant with the .NET framework from Microsoft. Each AS instance  may even include worker nodes  compliant with both the J2EE standard and the .NET framework.","Web dispatcher  implements a load-balancing mechanism distributing work requests  from client nodes  among server nodes  within cluster . For example, web dispatcher  may implement a round-robin load-balancing mechanism or the like. Web dispatcher  may be one of server nodes  having the task of dispatching work requests  among server nodes  of cluster  or a stand alone hardware node. Work requests  are processed by server nodes  and may subsequently be provided to database node . Database node  offers up the requested data to server nodes , which in turn process and format the results for display on client nodes . Each AS instance  may further include its own dispatcher mechanism to distribute work requests  assigned to it among its individual worker nodes .","Java programs  (see ) executed by worker nodes  within AS instances  may collectively provide the logic for implementing various sub-layers (e.g., business layer, integration layer, presentation layer, etc.) of AS instances . For example, Java programs  may be servlets providing server-side logic to generate graphical user interfaces (\u201cGUIs\u201d) on clients nodes  and may further include JavaServer Page (\u201cJSP\u201d) extensions for providing dynamic content within the GUI. Java programs  may further include business applications providing the business logic of an Enterprise JavaBean (\u201cEJB\u201d), and on client nodes  may be applets providing client side logic, and the like.","One of client nodes  may execute management console  to provide remote monitoring of AS instances , and in particular, remote monitoring of each worker node . If an IT technician notices that one of the worker nodes  is overloaded with work requests , has scarce available memory, or the like, the IT technician can take appropriate action including resetting the problematic worker node .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 5","b":["500","105","110","200","300","410","415","420","425","500","505","510","515","520","525","530","500"]},"The elements of processing system  are interconnected as follows. Processor(s)  is communicatively coupled to system memory , NV memory , DSU , and communication link , via chipset  to send and to receive instructions or data thereto\/therefrom. In one embodiment, NV memory  is a flash memory device. In other embodiments, NV memory  includes any one of read only memory (\u201cROM\u201d), programmable ROM, erasable programmable ROM, electrically erasable programmable ROM, or the like. In one embodiment, system memory  includes random access memory (\u201cRAM\u201d), such as dynamic RAM (\u201cDRAM\u201d), synchronous DRAM, (\u201cSDRAM\u201d), double data rate SDRAM (\u201cDDR SDRAM\u201d) static RAM (\u201cSRAM\u201d), and the like. DSU  represents any storage device for software data, applications, and\/or operating systems, but will most typically be a nonvolatile storage device. DSU  may optionally include one or more of an integrated drive electronic (\u201cIDE\u201d) hard disk, an enhanced IDE (\u201cEIDE\u201d) hard disk, a redundant array of independent disks (\u201cRAID\u201d), a small computer system interface (\u201cSCSI\u201d) hard disk, and the like. Although DSU  is illustrated as internal to processing system , DSU  may be externally coupled to processing system . Communication link  may couple processing system  to a network such that processing system  may communicate over the network with one or more other computers. Communication link  may include a modem, an Ethernet card, a Gigabit Ethernet card, Universal Serial Bus (\u201cUSB\u201d) port, a wireless network interface card, a fiber optic interface, or the like.","It should be appreciated that various other elements of processing system  have been excluded from  and this discussion for the purposes of clarity. For example, processing system  may further include a graphics card, additional DSUs, other persistent data storage devices (e.g., tape drive), and the like. Chipset  may also include a system bus and various other data buses for interconnecting subcomponents, such as a memory controller hub and an input\/output (\u201cI\/O\u201d) controller hub, as well as, include data buses (e.g., peripheral component interconnect bus) for connecting peripheral devices to chipset . Correspondingly, processing system  may operate without one or more of the elements illustrated. For example, processing system  need not include DSU .","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Processes  and  explained above are described in terms of computer software and hardware. The techniques described may constitute machine-executable instructions embodied within a machine (e.g., computer) readable medium, that when executed by a machine will cause the machine to perform the operations described. Additionally, processes  and  may be embodied within hardware, such as an application specific integrated circuit (\u201cASIC\u201d) or the like. The order in which some or all of the process blocks appear in processes  and  should not be deemed limiting. Rather, one of ordinary skill in the art having the benefit of the present disclosure will understand that some of the process blocks may be executed in a variety of orders not illustrated.","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. In some examples above, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring certain aspects. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification and the claims. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the present invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
