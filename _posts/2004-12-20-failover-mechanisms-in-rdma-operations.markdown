---
title: Failover mechanisms in RDMA operations
abstract: In remote direct memory access transfers in a multinode data processing system in which the nodes communicate with one another through communication adapters coupled to a switch or network, failures in the nodes or in the communication adapters can produce the phenomenon known as trickle traffic, which is data that has been received from the switch or from the network that is stale but which may have all the signatures of a valid packet data. The present invention addresses the trickle traffic problem in two situations: node failure and adapter failure. In the node failure situation randomly generated keys are used to reestablish connections to the adapter while providing a mechanism for the recognition of stale packets. In the adapter failure situation, a round robin context allocation approach is used with adapter state contexts being provided with state information which helps to identify stale packets.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08023417&OS=08023417&RS=08023417
owner: International Business Machines Corporation
number: 08023417
owner_city: Armonk
owner_country: US
publication_date: 20041220
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority based upon Provisional patent application having Provisional Ser. No. 60\/605,659 filed on Aug. 30, 2004.","The present invention is generally directed to the transfer of information residing in one computer system or on one data processing node to another data processing node. The present invention is more particularly directed to data transfers in which data is transferred by the network adapter directly into the target user buffer in the address space of the receiving system or node from the address space of the sending system or node. This is referred to as remote direct memory access (RDMA). Even more particularly, the present invention is directed to systems and methods for carrying out RDMA without the automatic assumption that data which has been sent is data which has also been received. This assumption is referred to as reliable transport but which should really be thought of as the \u201creliable transport assumption.\u201d As used herein, the concept of reliable transport refers to a communication modality which is based upon a \u201csend and forget\u201d model for Upper Layer Protocols (ULPs) running on the data processing nodes themselves, as opposed to adapter operations. Correspondingly, the concept of unreliable transport refers to a communication modality which is not \u201csend and forget\u201d with respect to the ULP. Also, as used herein the term \u201cdatagram\u201d refers to a message packet that is both self-contained as to content and essential heading descriptions and which is not guaranteed to arrive at any given time.","For a proper understanding of the contributions made to the data communication arts by the present invention it should be fully appreciated that the present invention is designed to operate not only in an environment which employs DMA data transfers, but that this data transfer occurs across a network, that is, remotely. Accordingly, the context of RDMA data transfer is an important aspect for understanding the operation and benefits of the present invention. In the RDMA environment, the programming model allows the end user or middleware user to issue a read or write command (or request) directed to specific virtual memory locations defined at both a sending node and at a remote data processing node. The node issuing the command is called (for the purposes of the RDMA transaction) the master node; the other node is referred to as the slave node. For purposes of better understanding the advantages offered by the present invention, it is noted here that the existing RDMA state of the art paradigm includes no functionality for referencing more than one remote node. It is also understood that the RDMA model assumes that there is no software in the host processor at the slave end of the transaction which operates to affect RDMA data transfers. There are no intermediate packet arrival interrupts, nor is there any opportunity for even notifying the master side that a certain portion of the RDMA data sent has now been received by the target. There is no mechanism in existing RDMA transport mechanisms to accept out-of-order packet delivery.","An example of the existing state of the art in RDMA technology is seen in the Infiniband architecture (also referred to as IB).","The state of the art RDMA paradigm also includes the limitation that data packets sent over the communications fabric are received in the same order as they were sent since they assume the underlying network transport to be reliable for RDMA to function correctly. This means that transmitted packets can easily accumulate in the sending side network communications adapters waiting for acknowledgment. This behavior has the tendency to create situations in which, at any given time, there are a large number of \u201cpackets in flight\u201d that are buffered at the sending side network adapter waiting to be acknowledged. This tends to bog down adapter operation and produces its own form of bandwidth limiting effect in addition to the bandwidth limiting effect caused by the fact that the source and destination nodes are constrained by having all of the packets pass in order through a single communications path. In addition, adapter design itself is unnecessarily complicated since this paradigm requires the buffering of unacknowledged in-flight packets.","The DMA and RDMA environments are essentially hardware environments. This provides advantages but it also entails some risk and limitations. Since the RDMA function is provided in hardware, RDMA data transfers possess significant advantages in terms of data transfer rates and, as with any DMA operation, data transfer workload is offloaded from central processing units (CPUs) at both ends of the transfer. RDMA also helps reduce the load on the memory subsystem. Furthermore, the conventional RDMA model is based upon the assumption that data packets are received in the order that they are sent. Just as importantly, the \u201csend and forget\u201d RDMA model (RDMA with the underlying reliable network transport assumption) unnecessarily limits bandwidth and precludes the use of many other features and functions such as efficient striping multiple packets across a plurality of paths. These features also include data striping, broadcasting, multicasting, third party RDMA operations, conditional RDMA operations, half RDMA and half FIFO operations, safe and efficient failover operations, and \u201clazy\u201d deregistration. None of these functions can be carried out as efficiently within the existing state of the art RDMA \u201csend and forget\u201d paradigm as they are herein.","The RDMA feature is also referred to in the art as \u201cmemory semantics\u201d for communication across a cluster network, or as \u201chardware put\/get\u201d or as \u201cremote read\/write\u201d or as \u201cRemote Direct Memory Access (RDMA).\u201d","It should also be understood that the typical environment in which the present invention is employed is one in which a plurality of data processing nodes communicate with one another through a switch, across a network, or through some other form of communication fabric. In the present description, these terms are used essentially synonymously since the only requirement imposed on these devices is the ability to transfer data from source to destination, as defined in a data packet passing through the switch. Additionally the typical environment for the operation of the present invention includes communication adapters coupled between the data processing nodes and the switch (network, fabric). It is also noted that while a node contains at least one central processing unit (CPU), it may contain a plurality of such units. In data processing systems in the pSeries line of products currently offered by the assignee of the present invention a node possibly contains up to thirty-two CPUs on Power4 based systems and up to sixty-four CPUs on Power5 based systems. (Power4 and Power5 are microprocessor systems offered by the assignee of the present invention). To ensure good balance between computational and communication capacity, nodes are typically equipped with one RDMA capable network adapter for every four CPUs. Each node, however, possesses its own address space. That is, no global shared memory is assumed to exist for access from across the entire cluster. This address space includes random access memory (RAM) and larger scale, but slower external direct access storage devices (DASD) typically deployed in the form of rotating magnetic disk media which works with the CPUs to provide a virtual address space in accordance with well known memory management principles. Other nonvolatile storage mechanisms such as tape are also typically employed in data processing systems as well.","The use of Direct Memory Address (DMA) technology provides an extremely useful mechanism for reducing CPU (processor) workload in the management of memory operations. Workload that would normally have to be processed by the CPU is handled instead by the DMA engine. However, the use of DMA technology has been limited by the need for tight hardware controls and coordination of memory operations. The tight coupling between memory operations and CPU operations poses some challenges, however, when the data processing system comprises a plurality of processing nodes that communicate with one another over a network. These challenges include the need for the sending side to have awareness of remote address spaces, multiple protection domains, locked down memory requirements (also called pinning), notification, striping and recovery models. The present invention is directed to a mechanism for reliable RDMA protocol over a possibly unreliable network transport model.","If one wishes to provide the ability to perform reliable RDMA transport operations over a possibly unreliable underlying network transport path, there are many important issues that should be addressed. For example, how does one accomplish efficient data striping over multiple network interfaces available on a node by using RDMA? How does one provide an efficient notification mechanism on either end (master and slave) regarding the completion of RDMA operations? How would one define an RDMA interface that lends itself to efficient implementation? How does one design a recovery model for RDMA operations (in the event when a single network interface exists and in the event when multiple network interfaces exist)? How does one implement an efficient third party transfer model using RDMA for DLMs (Distributed Lock Managers) and other parallel subsystems? How does one implement an efficient resource management model for RDMA resources? How does one design a lazy deregistration model for efficient implementation of the management of the registered memory for RDMA? The answers to these questions and to other related problems, that should be addressed as part of a complete, overall RDMA model, are presented herein.","As pointed out above, prior art RDMA models (such as Infiniband referred to above) do not tolerate receipt of packets in other than their order of transmission. In such systems, an RDMA message containing data written to or read from one node to another node is segmented into multiple packets and transmitted across a network between the two nodes. The size of data blocks which are being transferred, together with the packet size supported by the network or fabric, are the driving force for the partitioning of the data into multiple packets. In short, the need to transmit multiple packets as the result of a single read or write request is important given the constraints and state of the art of existing communication network fabrics. Furthermore, at another level, it is advantageous in the method of the present invention to divide the transfer into several independent multi-packet segments to enable striping across multiple paths in the communication fabric. At the node receiving the message (the receiving node), the packets are then placed in a buffer in the order received and the data payload is extracted from the packets and is assembled directly into the memory of the receiving node. The existing state of the art mechanisms are built on the assumption that the receipt of packets occurs in the same order in which they were transmitted. If this assumption is not true, then the communication transport protocols could mistake the earlier arriving packets as being the earlier transmitted packets, even though earlier arriving packets might actually have been transmitted relatively late in the cycle. If a packet was received in a different order than it was transmitted, serious data integrity problems could result. This occurs, for example, if a packet containing data that is intended to be written to a higher range of addresses of a memory, is received prior to another packet containing data that is intended to be written to a lower range of addresses. If the reversed order of delivery went undetected, the data intended for the higher range of addresses could be written to the lower range of addresses, and vice versa, as well. In addition, in existing RDMA schemes, a packet belonging to a current more recently initiated operation could be mistaken for one belonging to an earlier operation that is about to finish.","Accordingly, prior art RDMA schemes focused on enhancing network transport function to guarantee reliable delivery of packets across the network. With reliable datagram and reliably connected transport mechanisms such as this, the packets of a message are assured of arriving in the same order in which they are transmitted, thus avoiding the serious data integrity problems which could otherwise result. The present invention provides a method to overcome this dependence on reliable transport and on the in-order delivery of packets requirements and is implemented over an unreliable datagram network transport.","The prior art \u201creliably connected and reliable datagram\u201d RDMA model also has many other drawbacks. Transport of message packets or \u201cdatagram\u201d between the sending and receiving nodes is limited to a single communication path over the network that is selected prior to beginning data transmission from one node to the other. In addition, the reliable delivery model requires that no more than a few packets (equal to the buffering capability on the sending side network adapter) be outstanding at any one time. Thus, in order to prevent packets from being received out of transmission order, transactions in existing RDMA technologies have to be assigned small time-out values, so that a time-out is forced to occur unless the expected action (namely, the receipt of an acknowledgment of the packet from the receiver to the sender) occurs within an undesirably short period of time. All of these restrictions impact the effective bandwidth that is apparent to a node for the transmission of RDMA messages across the network. The present invention provides solutions to all of these problems.","In accordance with a preferred embodiment of the present invention a mechanism is provided for the transfer of data from the memory space of one data processing node to the memory space of one or more other data processing nodes. In particular, the present invention provides a data transfer structure and mechanism in which the data is transferred in at least one and typically in many packets which are not constrained to arrive at the destination node in any given order. The presence of the potentially out-of-order aspect provides the ability to structure a number of other transfer modalities and to provide a number of ancillary advantages all of which are described below under their respective headings.","In a first example of these additional data transfer modalities, it is possible to provide transfer modalities which are not processed symmetrically on both sides of the transfer. For example, one side may operate in a standard mode where data is transferred out of a FIFO queue while the other side operates in a remote DMA fashion.","In accordance with this first example there is provided a method for performing a write operation from a source node to a destination node, said method comprising the steps of: transferring said data via a DMA operation from said source node to a first communications adapter, coupled to said source node; transferring said data via a network from said first communications adapter to a second communications adapter coupled to said destination node; and transferring said data into a storage queue in said destination node wherein said data is subject to subsequent transfer to specific target memory locations within said destination node under program control in said second node.","In further accordance with this first example there is provided a method for performing a write operation from a source node to a destination node, said method comprising the steps of: transferring said data into a storage queue in said source node wherein said data is subject to subsequent transfer to a first communications adapter coupled to said source node under program control in said source node; transferring said data via a network from said first communications adapter to a second communications adapter coupled to said destination node; and transferring said data via a DMA operation from said second communications adapter to specific target memory locations within said destination node.","In accordance with this first example there is provided a method for performing a read operation initiated by a destination node for data residing on a source node, said method comprising the steps of: transferring said data via a DMA operation from said source node to a first communications adapter, coupled to said source node; transferring said data via a network from said first communications adapter to a second communications adapter coupled to said destination node; and transferring said data into a storage queue in said destination node wherein said data is subject to subsequent transfer to specific target memory locations within said destination node under program control in said second node.","In still further accordance with this first example there is provided a method for performing a read operation initiated by a destination node for data residing on a source node, said method comprising the steps of: transferring said data into a storage queue in said source node wherein said data is subject to subsequent transfer to a first communications adapter coupled to said source node under program control in said source node; transferring said data via a network from said first communications adapter to a second communications adapter coupled to said destination node; and transferring said data via a DMA operation from said second communications adapter to specific target memory locations within said destination node.","In a second example of the additional transfer modalities provided, it is noted that insensitivity to out-of-order data arrival makes it possible to transfer multiple data packets over a multiplicity of paths thus rendering it possible to engage in the rapid transfer of data over parallel paths.","In accordance with this second example there is provided method for data transport from a source node to at least one destination node, said method comprising the step of: transferring said data, in the form of a plurality of packets, from said source node to said at least one destination node wherein said transfer is via remote direct memory access from specific locations within said source memory to specific target locations within destination node memory locations and wherein said packets traverse multiple paths from said source node to said destination node.","In a third example. out-of-order DMA transfers render it possible to provide RDMA operations in which initiation and control of the transfer is provided by a third party data processing node which is neither the data source nor the data sink. Another feature provided by the underlying structure herein is the ability to transfer data from a source node to a plurality of other nodes in either a broadcast or multicast fashion. Yet another feature along these same lines is the ability to condition the transfer of data on the occurrence of subsequent events.","In accordance with a broadcast example there is provided a method for data transport, in a network of at least three data processing nodes, from a source node to multiple destination nodes, said method comprising the step of: transferring said data from said source node to a plurality of destination nodes wherein said transfer is via remote direct memory access operation from specific locations within source node memory to specific target locations within destination node memory locations.","In accordance with a multicast example there is provided a method for data transport, in a network of at least three data processing nodes, from a source node to multiple destination nodes, said method comprising the step of: transferring said data from said source node to preselected ones of a plurality of destination nodes wherein said transfer is via remote direct memory access operation from specific locations within source node memory to specific target locations within destination node memory locations.","In accordance with a third party transfer example there is provided a method for data transport, in a network of at least three data processing nodes, from a source node to at least one destination node, said method comprising the step of: transferring said data from said source node to at least one destination node wherein said transfer is via remote direct memory access operation from specific locations within source node memory to specific target locations within destination memory locations and wherein said transfer is initiated at a node which is neither said source node nor said at least one destination node.","In accordance with a conditional transfer multicast example there is provided a method for data transport, in a network of at least three data processing nodes, from a source node to at least one destination node, said method comprising the step of: transferring said data from said source node to at least one destination node wherein said transfer is via remote direct memory access operation from specific locations within said source node memory to specific target locations within destination node memory locations and wherein said transfer is conditioned upon one or more events occurring in either said source node or in said destination node.","In a fourth example, the structure of the remote DMA provided herein permits the earlier processing of interrupts thus allowing the CPU to operate more efficiently by focusing on other tasks.","In accordance with the fourth example embodiment there is provided a method for data transport from a source node to at least one destination node, said method comprising the steps of: transferring said data, in the form of a plurality of packets, from said source node to said at least one destination node wherein said transfer is via remote direct memory access from specific locations within said source memory to specific target locations within destination node memory locations and wherein said transfer path includes communication adapters coupled to said source and destination nodes and wherein said destination side adapter issues an interrupt indicating completion prior to transfer of data into said specific target locations within said destination node memory locations.","In a fifth example, a process and system provide a snapshot interface in RDMA Operations.","In a sixth example, a process and system are provided for dealing with failover mechanisms in RDMA Operations.","In a seventh example, a process and system are provided for structuring and handling RDMA server global TCE tables.","In an eighth example, process and system are provided for the interface Internet Protocol fragmentation of large broadcast packets.","In a ninth example, process and system are provided for \u201clazy\u201d deregistration of user virtual Machine to adapter Protocol Virtual Offsets.","Accordingly, it is an object of the present invention to provide a model for RDMA in which the transfer of messages avoids CPU copies on the send and receive side and which reduces protocol processing overhead.","It is also an object of the present invention to permit jobs running on one node to use the maximum possible portion of the available physical memory for RDMA purposes.","It is a further object of the present invention to provide zero-copy replacement functionality.","It is a still further object of the present invention to provide RDMA functionality in those circumstances where it is particularly appropriate in terms of system resources and packet size.","It is a still further object of the present invention to allow users the ability to disable RDMA functionality through the use of job execution environment parameters.","It is another object of the present invention to keep the design for the adapter as simple as possible.","It is yet another object of the present invention to provide a mechanism in which almost all of the error handling functionality is outside the mainline performance critical path.","It is still another object of the present invention to provide a protocol which guarantees \u201cat most once\u201d delivery of an RDMA message.","It is yet another object of the present invention to minimize the performance and design impact on the other transport models that coexist with RDMA.","It is yet another object of the present invention to provide additional flexibility in the transfer of data packets within the RDMA paradigm.","It is still another object of the present invention to provide a mechanism for RDMA transfer of data packets in which packets are broadcast to a plurality of destinations.","It is also another object of the present invention to provide a mechanism for RDMA transfer of data packets in a multicast modality.","It is a further object of the present invention to provide a mechanism for third party transfer of data packets via RDMA.","It is a still further object of the present invention to provide a mechanism for the conditional transfer of data packets via RDMA.","It is a further object of the present invention to provide a mechanism in which it is possible to improve transmission bandwidth by taking advantage of the fact that the transport protocol now permits data packets to be transmitted across multiple paths at the same time.","It is another object of the present invention to provide efficient striping across multiple interfaces and failover mechanisms for use in RDMA data transfer operations.","It is yet another object of the present invention to provide improved optimistic methods for deallocating RDMA enabled memory resources following the end of a data transfer.","It is a still further object of the present invention to provide a mechanism for the transfer of data packets to receiving hardware without the need for software intervention or processing intermediate packet arrival interrupts on either the slave side or on the master side of the transaction.","Lastly, but not limited hereto, it is an object of the present invention to improve the flexibility, efficiency and speed of data packet transfers made directly from the memory address space of one data processing unit to the memory address space of one or more other data processing units.","The recitation herein of a list of desirable objects which are met by various embodiments of the present invention is not meant to imply or suggest that any or all of these objects are present as essential features, either individually or collectively, in the most general embodiment of the present invention or in any of its more specific embodiments.","In order to provide a more understandable description of the structure and operation of the present invention, it is useful to first describe some of the components that exist in the environment in which the invention is typically embodied. This environment includes at least two data processing systems capable of Remote Direct Memory Addressing (RDMA) operations. Each data processing system communicates to any other coupled data processing system through a switch (also termed herein a network, fabric or communications fabric). The switches hook up to the nodes via a switch adapter. Each data processing system includes one or more nodes which in turn may include one or more independently operating Central Processing Units (CPUs). Each data processing system communicates with the switch by means of a switch adapter. These adapters, such as those present in the pSeries of products offered by the assignee of the present invention, include their own memory for storage and queuing operations. These switch adapters may also include their own microcode driven processing units for handling requests, commands and data that flow via the adapter through the network to corresponding communication adapters. The corresponding communication adapters are associated in the same way with other data processing systems and may have similar capabilities.","An adapter window is an abstraction of a receive FIFO queue, a send FIFO queue and some set of adapter resources and state information that are mapped to a user process that is part of a parallel job. The FIFO queues are used for packet-mode messages, as well as for posting RDMA command and notification requests that help the ULP handshake with the adapter.","Each receive side FIFO queue is a structure in the form of one or more large pages. An even easier alternative is to always deploy the FIFO queue as a 64 MB memory page. The memory for the Receive FIFO, regardless of its size, is expected to be in contiguous real memory, and the real memory address of the start of the table is stored in the Local Mapping Table (LMT) for the given adapter window in adapter SRAM. Having the receive FIFO queues mapped to contiguous real memory eliminates the need for the network adapter to have to deal with TCE (translation tables) tables and for the driver to have to set these tables up during job startup. The contiguous real memory hence simplifies the adapter design considerably because it does not need to worry about TCE caching and its management in the critical data transfer paths. Regardless of the FIFO size, in the preferred implementation herein, the queue is comprised of fixed length (2 KB) data packet frames which is dictated by the maximum packet size handled by the switch. The concepts explained herein naturally extend to other possible packet sizes.","Packet arrival notification for packet mode operation is accomplished as follows. The microcode DMAs all but the first cache line of an arriving packet to system memory. It waits for that data to reach the point of coherence, and then DMAs the first cache line (the so-called header) into the appropriate packet header slot in the packet buffer in system memory. The ULP polls on the first cache line of the next packet frame to determine if a new packet has arrived. Upon consuming the packet, the ULP zeroes out the first line (or a word thereof) of the packet, to prepare the fifo slot for its next use. This zeroing out by the ULP allows the ULP to easily distinguish new packets (which never have the line zeroed out) from older packets already consumed by the ULP. For RDMA mode, the FIFO entry that is put into the FIFO is an RDMA completion packet, which as a header only entity, so is transferred as a single cache line DMA.","This FIFO queue structure is simple and it minimizes short-packet latency. Short packets (that is data packets less than 128 bytes) suffer only one system memory latency hit, as opposed to other mechanisms involving a separate notification array or descriptor. The present mechanism also enhances compatibility with the send-side interface, and is readily amenable to other variations based on the use of hardware as opposed to software as a design component of the FIFO queue model.","When the receive-side FIFO queue is full, incoming packet mode packets and RDMA completion packets are silently discarded. Interrupts are based on the FIFO queue count threshold for the given adapter window channel. For example, an interrupt is generated when the microcode writes the nreceive FIFO entry, where n is an integer previously provided by the higher level protocol as the next 18 item of interest. Note that interrupts can be disabled by the user space ULP by setting the count to some selected special value such as zero or all ones. Interrupt signals are generated upon triggering conditions, as perceived by the adapter. Incoming packets are validated on the basis of the protection key stamped in the packet header.","In the present invention, packets are potentially delivered to the FIFO queue system memory in an out-of-order sequence (that is, it is possible for completions to be marked out of order). The FIFO queue tail pointer in the Local Mapping Table is incremented as each entry is written to the receive FIFO. Multiple receive threads engines on the adapter, even if acting on behalf of the same window, require no additional synchronization with respect to each other allowing for significant concurrency in receipt of a message. Packet frames are returned by the adapter to the ULP by means of an MMIO command (see below). The total number of adapter receive tasks is preferably limited to the minimum number that keeps all pipelines full. In the presently preferred embodiments of the present invention this number is four and can be tuned to different settings for improved performance.","The current and preferred implementation of the present adapter uses MMIO commands for a number of commands from the ULPs to the adapter microcode and\/or hardware. The host code can access the registers and facilities of the adapter by reading or writing to specific addresses on the system bus. In the case of writes, depending upon the specific address, the data that is written can be either forwarded by the hardware interface to the microcode running on the adapter, or processed directly by the adapter hardware. When dealing with a command that is destined for the microcode, both the data written and the address used serve as input to the microcode to determine the exact operation requested. Among the operations utilized in the receive processing are:\n\n","Adapter SRAM accesses are also achieved using Memory Mapped I\/O (MMIO), but this is handled directly by the hardware without microcode support. The host side code may access, with proper authority which is setup during parallel job startup, the data stored in the adapter SRAM. This includes the LMTs for all of the windows and all of the RDMA Contexts (rCxt). Read LMT is an example of a specific device driver\/hypervisor implemented command that uses the adapter SRAM access MMIO to retrieve data from adapter SRAM. It works by passing the specific address of where the LMT is stored, within SRAM, as a part of the Adapter SRAM access MMIO. It is important to point out though that the LMT stored in the SRAM may not always be current. In the preferred implementation, the working copy of the LMT is cached closer to the adapter processor for improved performance in the mainline data transfer path.","The adapter microcode performs a number of different operations related to processing packets received from the network or switch. Below is a brief overview of this process. The microcode executes steps either as the result of receiving a MMIO command, passed through by the hardware, or an incoming packet from the network. It is noted that in the preferred implementation herein, there is provided a microcode engine running on the adapter. Other implementations which do not use a microcode engine are possible (for example, a complete state machine, an FPGA based engine, etc.). The concepts explained in this preferred embodiment extend to other possible implementations as well. The steps involved in processing a packet received from the network or switch are now considered:\n\n","It is noted that items c, d, and e in the list above are similar to items a and b, but that they can be driven by a different hardware event.","The real memory address of the transmit-side FIFO queue, like that of the receive side FIFO queue, is a contiguous section of real system memory whose real address is stored in the LMT for the adapter window. This queue also employs fixed length packet frames. In presently preferred embodiments of the present invention, each packet is up to 16 cache lines long. The destination node id (that is, the id for the destination node adapter), the actual length of the data in the packet, and the destination window are specified in a 16-byte header field (in the presently preferred embodiment) within the first cache line. The header is formatted so as to minimize the amount of shuffling required by the microcode. Note that the destination node id need not be checked by microcode; this protection is provided by the above-mentioned protection key.","For each outgoing packet, the adapter fetches the packet header into the Header Buffer (an array of memory in the memory of the adapter; there are 16 of these header buffers in the presently preferred embodiment). The microcode then modifies the packet header to prepare it for injecting the packet into the network, including adding the protection key associated with this adapter window from the LMT. The adapter also fetches the data payload from the send FIFO queue (for FIFO mode) or from the identified system memory for RDMA, into the Data Transfer Buffer, via local DMA (system memory into adapter). Once the header is prepared and the payload is in the DTB, the adapter can inject the packet into the network.","After transmitting the packet, the adapter marks completion by updating the header cache line of the frame in the send FIFO queue. This is done for every packet that the microcode processes so that the ULP can clearly see which packets have or have not been processed by the adapter.","This completion marking of the send FIFO queue entry is performed using a sync-and-reschedule DMA operation in the presently preferred embodiment. When this DMA operation completes, the task is ready to process a new send request.","The adapter maintains a bit vector of active adapter windows (hence the number of adapter windows is restricted). The bit vector is contained in either one of two global adapter registers. A bit is set by a system MMIO StartTransmit command; the command also includes a packet count which is added to the readyToSend packet count in the LMT. Each time a packet is processed, readyToSend is decremented. The ready bit is cleared when the adapter processes the last readyToSend packet.","Transmit threads proceed through the active adapter windows in a round robin fashion. We switch windows every k packets, even when k=1. Some efficiency (for example, fewer LMT fetches) is gained for k>1, for instance by reusing the register state. But that tends to optimizes the send side better than the receive side (which helps exchange bandwidth, but may cause congestion to increase). The actual selection of the value of k can be tuned based on the requirements for performance, fairness among all windows, and other policy controls selectable by the user or system administrator.","The total number of transmit tasks is limited to the minimum that keeps all pipes flowing (Typically there are four pipes in the presently preferred embodiment.) No attempt is made to maintain transmission order and to suffer with its associated overhead. This is, in fact, a key feature of the present invention in almost all of its embodiments.","Upon the issuance of a StartTransmit MMIO command, the adapter attempts to assign the work to forks off a pre-allocated Transmit task. If no Transmit tasks are currently available, then the readyToSend count in the appropriate LMT is updated, the bit that is associated with this adapter window is set in the bit vector and a work manager task is notified. The work manager task distributes transmit work to Transmit tasks as they become available. It is the work manager task's responsibility to update the readyToSend count in the LMT and the bit vector in the Global Registers (referred to also as \u201cGR\u201d; which are registers accessible to all adapter tasks) as the work is distributed.","On the \u201csend side,\u201d the transmit threshold interrupt behaves exactly like the receive side. The use of interrupts is optional, and in fact, are not typically used for send side operation. The use of send and receive interrupts is optional. MMIO commands used for send side operations include:\n\n","In addition, the host code may issue Adapter SRAM access MMIOs. However, they are of little value during normal operation.","One example of adapter operations involved in handling a request from the CPU to either transmit a data packet or begin an RDMA transfer is illustrated in , various features of which are discussed elsewhere herein. The process begins with arrival of an update FIFO slot count MMIO command, . Next, a command task is allocated, , followed by determination of an adapter window id, . At , a check is performed to determine whether the window is in a valid state. If it is determined that the window is not in a valid state, then the command is discarded, , and the command task is deallocated, , at which point the processing ends. If, however, the check determines that the window is in a valid state, a bit in the bit vector is set if the send count is greater than zero, . Next, inquiry  determines whether the work manager is suspended and send task resources are available. If NO, the work manager is woken up, if necessary, , the FIFO counters are updated and the task is deallocated. If, however, inquiry  is answered YES, the command is passed to the send task, , the FIFO counters are updated, , and the processing continues to , as if inquiry  was answered NO.","Presented below are the fields in the LMT data structure (in conceptual form) that are preferably employed.",{"@attributes":{"id":"p-0102","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/***********************************************************"},{"entry":"\/\/ LMT Definition"},{"entry":"\/\/***********************************************************"},{"entry":"Typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Recv_fifo_real_address","- Real address of the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"base of the Receive"]},{"entry":[{},"FIFO"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Window_state","- Window state (invalid,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"valid, etc)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Recv_fifo_size","- Size of the Receive"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"FIFO (encoded)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Window_id","- Window id"]},{"entry":[{},"Recv_mask","- Mask for current slot"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from the"]},{"entry":[{},"recv_current_cnt"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Recv_current_cnt","- Receive current count"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for interrupt threshold"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Recv_fifo_avail_slots","- Receive FIFO number of"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"slots available"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Recv_int_threshold","- Receive interrupt"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"threshold"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Window_key","- Window key (used for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"protection)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Rcxt_id","- rCxt id associated"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"with Window Fatal error"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Int_vect_data","- Interrupt vector entry"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"with Window Fatal error"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"send_fifo_real_address","- Real address of the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"base of the Send"]},{"entry":[{},"FIFO"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Config_parm_bcast","- Config parm - Enable"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sending broadcast pkts."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Send_fifo_size","- Size of the Send FIFO"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(encoded)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Send_quanta_value","- Count of send actions"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"remaining in quanta"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Send_mask","- Mask to get current"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"slot from"]},{"entry":[{},"send_current_cnt"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Send_current_cnt","- Send current count for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"interrupt threshold"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Send_fifo_ready_slots","- Send FIFO number of"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"slots ready to process"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Send_int_threshold_hi","- Send interrupt threshold"]},{"entry":[{},"Rcxt_head","- Head rCxt of RDMA send"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"queue for window"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Rcxt_tail","- Tail rCxt of RDMA send"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"queue for window"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Rcxt_count","- Count of rCxts on"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RDMA send queue"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} lmt_t;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"What follows now is a description of the RDMA architecture.","Memory regions are registered to a particular RDMA job. Protection granularity is per page. RDMA memory accesses, both local and remote, are validated by RDMA job id and buffer protection key. The job id is verified by comparing the job id (or window key) for the window with the job id assigned to the Translation Control Entry (TCE) Table (see below for a more detailed description of their use in the discussion for , ,  and ). The memory protection key, which insures that the request uses a current view of the memory usage, is validated by comparing the key in the Protocol Virtual Offset (PVO; see below) with the key for the particular TCE Table entry being referenced. This insures that only the authorized job accesses its data and also provides protection from stale packets in the network.","For a better understanding of the present invention, it is desirable to consider the general operation of RDMA systems and methods.  seeks to answer the question: \u201cWhat is RDMA?\u201d. In RDMA a master task running on one node is able to update or read data from a slave task running on another node. The exchange of information occurs through a switch or over a network. In RDMA the slave task executes no code to facilitate the data transfer.",{"@attributes":{"id":"p-0106","num":"0114"},"figref":["FIG. 1","FIG. 1","FIG. 1","FIG. 10","FIG. 1","FIG. 10"],"b":["101","102","103","104","101","102","103","104","103","104","103","104","106","105","109","101","102","107","108","1","2","107","107","108","108","1","2","1","2"],"i":["a","c ","a","c "]},{"@attributes":{"id":"p-0107","num":"0115"},"figref":"FIG. 2","b":["151","161","152","162","153","163"]},"MPI layers  and  are the layers that enforce MPI semantics. Collective communication operations are broken down by the MPI layer into point to point LAPI calls: data type layout definitions are translated into appropriate constructs understood by the lower layers like LAPI and High Availability; message ordering rules are managed at the MPI layer. Overall the MPI layer enforces MPI semantics.","LAPI layers  and  provide a reliable transport layer for point to point communications. The LAPI layers maintain state information for all \u201cin-flight\u201d messages and\/or packets and they redrive unacknowledged packets and\/or messages. For non-RDMA messages LAPI layers  and  packetize messages into HAL send FIFO buffers (see reference numeral  in , for example, and elsewhere). However, for RDMA messages, the LAPI layers use HAL and device drivers  and  to set up the message buffers for RDMA. That is, they pin the pages of the message buffers and translate them. On the receive side, for non-RDMA operations, message packets are read from receive-side HAL FIFO buffers (see reference numeral  in  and elsewhere) and are moved into target user buffers. For reliable RDMA over an unreliable datagram service this is an important point. The state which calls for the redriving of messages is maintained in the LAPI layer unlike other RDMA capable networks like Infinband (IB). This elegant breakup of functionality also lends itself to an efficient striping and failover model which are also part of the present inventive description.","HAL layers  and  provide hardware abstraction to Upper Layer Protocols (ULPs like LAPI and MPI). The HAL layers are stateless with respect to the Upper Layer Protocols. The only state that the HAL layer maintains is that which is necessary to interface with the adapter. HAL layers  and  are used to exchange RDMA control messages between the Upper Layer Protocols and adapter microcode (see reference numerals  and . The control messages include commands to initiate transfers, to provide notifications of completion, and to cancel in-flight RDMA operations.","Adapter microcode (reference numerals  and ) is used to interface with HAL layers  and  respectively for RDMA commands, and to exchange information regarding message completion and cancellation. In addition, adapter microcode is responsible for fragmentation and reassembly of RDMA messages directly from a source user buffer and to a target user buffer. The microcode fragments the packets of a message from the user buffer and injects them into switch network . On the receive side, adapter microcode reassembles incoming RDMA packets directly into target buffers. If necessary, adapter microcode ( and ) also generates interrupts through device drivers ( and , respectively) for appropriate ULP notification.","Device drivers  and  are used to setup the HAL FIFO queues for the user space Upper Layer Protocol to interact with switch  and adapters  and , respectively. Device drivers  and  also have the responsibility for fielding adapter interrupts, for opening, for closing, for initializing and for other control operations. Device drivers  and  are also responsible for helping to provide services to pin and translate user buffers to affect RDMA data transfer. Hypervisors  and  provide a layer which interacts with device drivers  and , respectively, to setup the address translation entries.","Besides simplifying adapter microcode design, the RDMA strategy of the present invention simplifies time-out management by moving it to a single place, namely to the Upper Layer Protocol (, ). As indicated earlier, it also improves large-network effective bandwidth by eliminating the locking of adapter resources until an end-to-end echo is received. The dynamically managed rCxt pool supports scalable RDMA, that is, allowing a variable number of nodes, adapter windows per node, and message transmissions per adapter window to be ongoing simultaneously without consuming the limited data transmission and receive resources of the adapter.","From the perspective of Upper Layer Protocol (, ), a write operation, using RDMA transfer, which is referred to herein as a \u201cRDMAW\u201d operation, begins with the posting of the RDMAW request to a adapter window send FIFO (that is, to a first-in-first-out queue; see reference numeral  in ). The request is marked completed once the adapter microcode has taken responsibility for the request and no longer needs the request to be in the send FIFO. Upon successful delivery the RDMAW data to system memory, a header-only completion packet is delivered. The initiating task selects whether this completion packet is required, and if so, whether this packet should go to the source, or target task. See reference numeral  in .","A RDMA Write (RDMAW) request is issued to a local adapter window; its target is a remote adapter window. The RDMAW request specifies local and remote rCxt's, a tid, a local and a remote Protocol Virtual Offset (PVO), and a length. The local address is translated by the local adapter; the remote address is translated by the remote adapter. The RDMAW operation is posted by Upper Layer Protocol (, ) to the local adapter window FIFO as a header-only \u201cpseudo packet.\u201d The rCxt, tid and PVO are important components in supporting not only the exactly-once delivery, but also in allowing out-of-order delivery of packets. The rCxt id identifies a particular transfer. The tid insures that the packets received belong to the current attempt to transfer this data (that is, that this is not a stale packet that somehow got \u201cstuck\u201d in the network). The data target PVO makes every packet self describing as to where in system memory the packet belongs, thus making out-of-order delivery possible. Further, the ULP never transmits two messages on the same window using the same tid, the adapter\/microcode never retransmits any packets, and the switch does not duplicate packets.","Upon processing the RDMAW request, the local adapter generates as many packets as are required to transport the payload. Each packet contains in its header the remote rCxt, the tid, the total transfer length, the length of the specific packet, and the destination Protocol Virtual Offset (PVO) of the specific packet. Thus each payload packet is \u201cself identifying,\u201d and the payload packets are processable at the target in any order. The local adapter considers the posted RDMAW to be completed when it transmits the last packet. At this point, the local adapter is free to mark the RDMAW as completed. Such completion does not signify that the payload has been delivered to the remote memory.","Upon receiving a RDMAW payload packet, the microcode at the target adapter validates the request (protection key, rCxt, tid, etc.). If the specified rCxt is invalid, the packet is silently discarded. The incoming tid is handled as follows. If it is less than the tid in the rCxt, the packet is discarded (that is, it is considered stale). If the incoming tid is greater than the tid in the rCxt, the incoming packet is treated as the first arriving packet of a new RDMAW. The specifics of the RDMAW request (including the tid, the total RDMA length and whether notification is requested at the master or slave ends) are copied to the rCxt the payload is DMAed into the appropriate offset in system memory, and the expected message length is decremented in the rCxt. If the incoming tid matches the rCxt tid, the payload is copied to system memory, and the expected length field is updated in the rCxt. If the rCxt remaining length is now zero, and the rCxt's outstanding DMA count is zero, the RDMAW operation is complete, and a completion packet is sent to the initiator window (if a completion notification was requested) after the data is successfully placed into system memory. The completion packet contains the rCxt number, and tid, and the packet is sent. If an arriving payload packet would cause a memory protection violation, the packet is discarded and a notification is sent to the ULP to assist program debugging (thereby ensuring that the RDMAW completion packet for that tid is never issued).","The delivery of the RDMAW (the RDMA Write) completion packet to either the initiator or target sides of an RDMAW operation only takes place after the payload has reached the point of coherence at the target. Therefore, the completion message is the only acceptable indicator that the data has been successfully transferred, and that the RDMA operation has completed successfully.","It should be noted that application programs have the responsibility of properly structuring RDMA transfer requests. If multiple RDMAWs, or RDMAWs and RDMARs, are issued concurrently with an overlapping target virtual Protocol Virtual Offset (PVO), no guarantees are made about the order in which the payloads are written to memory, and the results are undefined. However, a parallel job that does this should only impact itself. This result is not unique to the current implementation of RDMA.","Note that the switch adapter may concurrently process multiple posted operations (both RDMAW and packet-mode) even for the same window. Note, too, that the ULP (Upper Layer Protocol) is responsible for retrying failed RDMAW operations (based on a ULP time-out criteria). When reissuing the RDMAW, the ULP must specify a tid greater than the tid value last used. The ULP may use a progressive back off mechanism when reissuing large RDMAW operations. After reissuing an RDMAW, the ULP ignores subsequently arriving RDMAW completions with stale tids.",{"@attributes":{"id":"p-0121","num":"0129"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 3"],"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["1. The Upper Layer Protocol (MPI, LAPI) submits an RDMA request with respect to HAL FIFO send queue . For the present discussion of , it is assumed that this is a write operation from a user buffer in the master task to a user buffer in the slave task. The request includes a control packet which contains information that is used by adapter microcode  to affect the RDMA transfer of the user buffer. For example, the control packet includes such items as a starting address, length of message, the rCxt ids (session or connection identifiers; see below for a complete description of this structure) to be used for source and destination sides and the notification model (that is, which side should be notified for completion, etc.). The adapter microcode uses the rCxt ids to identify the specific control blocks being used by the adapter microcode to maintain state information about the transfer, including the starting address, total transfer size, source and destination identifiers, and such, while the upper layer protocols use the rCxt ids to track the outstanding requests.","2. HAL layer  handshakes with adapter  to tell adapter microcode  that there is a new request for the microcode to process. The microcode DMAs the RDMA request into the adapter and parses it. The microcode extracts those fields necessary to affect an RDMA transfer. The microcode extracts then copies relevant parameters into the rCxt structure. See also  discussed below. Then the microcode uses the data source PVO to access the specified TCE Table, and verifies that the request meets memory protection requirements associated with each specific page of real memory involved in the transfer.","3. The microcode then DMAs the data from user buffer  and packetizes the data and injects the packets into the network and updates the rCxt state appropriately. This constitutes the sourcing payload part of the operation.","4. The packets of the RDMA message arrive at target adapter . These packets may arrive out of order (see ) but are self describing packets with the appropriate PVO and payload length in each packet.","5. Receiving side microcode  reassembles the packets of the message in target user buffer  and updates the receive side rCxt appropriately. When the first packet of a new message arrives (identified by a new transaction identifier or tid in the packet) the appropriate rCxt is initialized. Subsequent packets of the message cause the microcode to update the appropriate rCxt on the receive side. This provides what is referred to herein as the \u201csinking payload\u201d aspect of the RDMA operation. The RDMA protocol uses transaction id values (tid's) to guarantee \u201cat most once\u201d delivery. This guarantee is provided to avoid accidental corruption of registered memory. A tid is specified by the ULP each time it posts an RDMA operation. That transaction id (tid) is validated against the tid field of the targeted rCxt. For each given target rCxt, the ULP chooses monotonically increasing tid values for each RDMA operation. The chief aim of the rCxt and tid concept is to move, as much as possible, the responsibility for exactly-once delivery from firmware to the ULP. The rCxt and tid are used by the adapter microcode to enforce at-most-once delivery and to discard possible trickle traffic. The ULP uses this microcode capability to guarantee overall exactly-once delivery. The microcode uses the data target PVO to access the specified TCE Table, and verifies that the request meets memory protection requirements associated with each specific page of real memory involved in the transfer.","6. Once all the packets of the message are received, microcode  waits for the DMA transfer to receive user buffer  to be completed and then DMAs (that is, transfers via a direct memory addressing operation) a completion packet into receive FIFO queue  (if such a completion is requested).","7. Receive side microcode  then constructs a completion packet and sends it to source adapter  (if such a completion is requested).","8. Adapter microcode  on the source side DMAs the completion packet from receive side adapter  into source side receive FIFO queue . Steps 6, 7 and 8 represent the transmission of indications related to operation completion.","9. The Upper Layer Protocol at the source (, ) and destination (, ) end reads the appropriate completion packets to clean up the state indications with respect to the RDMA operation. If the RDMA operations do not complete in a reasonable amount of time a cancel operation may be initiated by the ULPs to clean up the pending RDMA status in the rCxt structures, or the ULP may redrive messages transmission using an updated tid. This failover and redrive mechanism is also part of the overall RDMA transmission process over unreliable transport mechanisms that forms part of the inventive description herein."]}}}},"The RDMA read operation (RDMAR) is very similar to the RDMAW operation with the only real difference being where the request comes from. A RDMAR is equivalent to a RDMAW issued by the opposite side (the target rather than the source). From the ULP's perspective, an RDMAR begins with the posting of the RDMAR request to a adapter window send FIFO queue. The request is marked completed once the adapter microcode has accepted responsibility for the request and no longer requires the FIFO entry. Upon successful delivery of the RDMAR payload to local system memory, a header-only completion packet is delivered as requested by the initiator.","To post a RDMAR, the initiator specifies the local and remote PVO, the length, the rCxt ids for both the local and remote windows and a tid. Like RDMAWs, RDMARs are posted as header-only \u201cpseudo packets\u201d to the adapter window's send FIFO queue. It is the ULP's responsibility to ensure that the local and remote rCxts are not otherwise in use, and the ULP specifies a tid larger than the last used local rCxt and remote rCxt tids.","The initiator microcode transmits the RDMAR request to the data source adapter. After successful transmission of the RDMAR request, the initiator microcode may mark the send FIFO entry as complete. This completion indicates to the ULP that the operation has been successfully started; it does not signify that the payload has been delivered to local memory.","Upon receiving a RDMAR request, the target microcode validates the request (protection key, tid, etc.). If the rCxt is invalid, the request is silently ignored. If the rCxt is busy, the RDMAR request is silently dropped. The incoming rCxt tid is handled as follows. If it is less than or equal to the rCxt tid currently stored in the local rCxt, the request is silently ignored. Otherwise, if the incoming tid is greater than the rCxt tid, the specifics of the request (PVO, initiator id, initiator rCxt, and other relevant fields) are copied to the rCxt. The rCxt is added to a linked list of rCxts waiting to be sent for the adapter window (for which purpose the LMT contains a rCxt head pointer, tail pointer and count), and the adapter window is marked readyToTransmit (in much the same manner as would happen in response to a locally issued StartTransmit MMIO command).","The target adapter, that is, the slave side that received the RDMAR, request packet is now responsible for sending the RDMA payload. This payload is sent in much the same manner as are RDMAW payload packets.","At the initiator, incoming RDMAR payload packets are handled in exactly the same manner as are incoming RDMAW payload packets. A completion packet (carrying the rCxt and tid) is delivered to the appropriate side(s) once the data has reached coherence in system memory.","The ULP determines which RDMAR has completed by inspecting the rCxt number, tid, and protocol-specific tags carried in the completion packet.","Note that the target microcode may interleave the transmission of RDMAR payload packets with other transmissions.","Note that the ULP is responsible for retrying failed RDMAR operations based on ULP time-out criteria. When reissuing the RDMAR, the ULP should specify a tid greater than the tid value last used. The ULP is advised to use a progressive back off scheme when reissuing large RDMAR operations. After reissuing an RDMAR, the ULP must ignore subsequently arriving RDMAR completions with stale tids.","Attention is next directed to the process illustrated in  which is similar to  but which illustrates RDMA read operations over an unreliable datagram. Thus, , shows the equivalent flow for an RDMA read operation. As above and throughout, these steps are described below in paragraphs numbered to correspond with the numbered circles in .\n\n","Attention is now focused on the fact that packets may not arrive in the order in which they were sent. Accordingly,  is now considered. , shows that RDMA over an unreliable datagram (UD) mechanism takes advantage of the fact that between source node  and destination node , there may be multiple independent paths (a, b, c and d in ) through network . Packets of a message can be sent in a round robin fashion across all of the routes available which thus results in improved utilization of the switch and which also minimizes contention and hot spots within the switch. Packets arriving out of order at the receiving end are managed automatically due to the self-describing nature of the packets. No additional buffering is required to handle the out of order nature of the packet arrival. No additional state maintenance is required to be able to handle the out of order packets.","RDMA operations employ adapter state information. This state is contained in an RDMA context, called rCxt. RCxt's for example ,  of ) are stored in adapter SRAM. Each rCxt is capable of storing the required state for one active RDMA operation. This state includes a linked list pointer, a local adapter window id, two PVO addresses, the payload length, and the initiator adapter and adapter window id (approximately 32 bytes total in length). The rCxt structure declaration follows.",{"@attributes":{"id":"p-0134","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/***********************************************************"},{"entry":"\/\/ rCxt Structure"},{"entry":"\/\/***********************************************************"},{"entry":"typedef struct"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Lid","- source\/target Logical id"]},{"entry":[{},"Remote_window","- Remote window"]},{"entry":[{},"Rdma_usr_cookie","- RDMA user cookie"]},{"entry":[{},"Rcxt_assigned","- 0: rCxt is not assigned to a"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"window, 1: rCxt is assigned"]},{"entry":[{},"to a window"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Rcxt_key","- Key to protect rCxt from"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"trickle traffic on reuse"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Local_window","- Local window"]},{"entry":[{},"Pkt_type","- RDMAR, RDMAW, etc."]},{"entry":[{},"Complete_status","- Succeed or error (see below)"]},{"entry":[{},"Rcxt_direction","- 0: rCxt is being used for"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"send, 1: rCxt is being used"]},{"entry":[{},"for receive"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Rcxt_state","- 0: rCxt is free, no work"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"active or pending"]},{"entry":[{},"1: rCxt is on the LMT RDMA"]},{"entry":[{},"send queue"]},{"entry":[{},"2: rCxt is in process of"]},{"entry":[{},"receiving (at least one pkt"]},{"entry":[{},"rcvd, not complete)"]},{"entry":[{},"3: rCxt is on the send"]},{"entry":[{},"completion queue"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Notify_on_completion","- Identify all parties to get"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"notification after RDMA"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Payload_size","- Payload size"]},{"entry":[{},"Data_to_snd_rcv","- Amount of data remaining"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to send or receive"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Total_RDMA_size","- Total data size for RDMA"]},{"entry":[{},"RDMA_protocol_cookie","- ULP cookie"]},{"entry":[{},"Data_source_rCxt","- Data Source rCxt"]},{"entry":[{},"Data_target_rCxt","- Data Target rCxt"]},{"entry":[{},"Next","- Next rCxt in send chain"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"One of the goals in allocating rCxt's here ought to be to have enough rCxt's to keep the pipeline full.","The ULPs acquire rCxt's from the device driver (see reference numeral ). At the time of acquisition, the ULP specifies the adapter window for which the rCxt is valid. Upon acquisition (via privileged MMIO instruction or directly by device driver request) the adapter window number is put into the rCxt and the tid is set to zero. The pool of rCxt's is large (on the order of 100K), and it is up to the ULP to allocate local rCxt's to its communicating partners, according to whatever policy (static or dynamic) the ULP chooses. It is the ULP's responsibility to ensure that at most one transaction is pending against each rCxt at any given time.","The processes illustrated in  employ RDMA operations on each side of the link for both read and for write operations. However, it is possible to employ a FIFO queue on one side or the other of the transmission process. , ,  and  illustrate processes that are applicable to this mode of operation. This variation in the RDMA process has advantages with respect to both latency and bandwidth. They also avoid setup operations on the remote side.","Existing transport mechanisms provide FIFO (or packet) mode of transport or RDMA mode of transport between a sender and receiver. For these transport mechanisms the sender and receiver follow the same protocol (that is, either FIFO or RDMA). For many applications it is important to be able to take advantage of RDMA on one side (either the sender or the receiver) and FIFO on the other side. In this embodiment of the present invention, it is shown how the RDMA structure provided by herein permits this feature to be efficiently enabled through an intelligent structuring of the FIFO queue and RDMA structures and flow. Usage of these combination models is important in programming situations where RDMA can only be accomplished from\/to contiguous locations in memory and if one of the source or destination buffers is noncontiguous. In other situations the sender\/receiver protocol may not be able to specify a priori the location of the various buffers from\/to which the data transfer is to occur. In these situations the ability to issue a half RDMA operation allows the transport protocol to take advantage of RDMA on at least one end while exploiting the flexibility of using FIFO and parsing data as it is sent out (or absorbed from the network before scattering them into their respective target locations). This mode of operation also has value for operations like \u201caccumulate\u201d where the receiver of the data performs an accumulation operation on all of the data from the various senders participating in the accumulate reduction operation. In such cases the sending side can use RDMA since the CPU does not need to touch any of the data to effect the transfer, but on the receive side the data is better staged through a FIFO queue so that the receive side processors can parse the data packets in the FIFO queue and perform reduction operations like \u201caccumulate,\u201d as the packets of the reduction message arrive, or any other reduction operation (like max, min, or any other parallel prefix operation) which requires that, at the receiving end, the CPU has to operate on the incoming data and can take advantage of pipelining the reduction operation as it processes packets from the FIFO queue overlapping this operation with the rest of the arriving data. In addition we illustrate how this is accomplished reliably over a possible unreliable datagram transport.","With respect to , the process shown illustrates a half-send RDMA write operation over network . The process of transferring data in this fashion is illustrated in the following steps:\n\n","With respect to , the process shown illustrates a half-receive RDMA write operation over network . The process of transferring data in this fashion is illustrated in the following steps:\n\n","With respect to , the process shown illustrates a half-send RDMA read operation over network . The process of transferring data in this fashion is illustrated in the following steps:\n\n","With respect to , the process shown illustrates a half-receive RDMA read operation over network . The process of transferring data in this fashion is illustrated in the following steps:\n\n","It is noted that the half-receive RDMA read is one of many possible implementation options that extends the use of the other three half-RDMA approaches described above.","Attention is now turned to one other advantage provided by the mechanisms presented herein. More particularly, the ability to process read and write operations in an RDMA fashion without concern for the order of packet arrival provides an opportunity to use multiple paths for the transmission of data packets. This in turn provides the ability for the protocols to efficiently stripe a message (or different messages) from a single task across multiple network interfaces to exploit the available communication bandwidth in parallel.","For a programming model where there is one task of a parallel job per CPU, it is important for efficiency that the tasks run with minimal disruption of the CPU from interrupts and other tasks. This becomes a difficult problem to address when striping across multiple paths by each task becomes necessary to exploit the full bandwidth of the network. For such models, an efficient RDMA striping model with pipelined RDMA requests is described herein. This pipelined model has the following advantages:\n\n","An important component of the present usage model is that there is the option to present notification of the completion of RDMA operations at both ends. This is important for IP (Internet Protocol) transactions and for some user space programming models. It is also needed for the ULPs (user space and IP) to ensure cleanup of RDMA resources and possibly to redrive the transfer through non-RDMA paths in the event of failure.","With respect to striping, the IP transport layer has a reserved window in presently preferred embodiments of adapter systems attached to a node and can use multiple sessions (streams or sockets) to drive a significant portion of the IP stack in parallel realizing more bandwidth for the IP application than possible through a single session and adapter. For systems which are memory bandwidth limited this mechanism provides for possible increased bandwidth realized by IP.","Striping is now discussed in terms of its use with and its effects using the MPI (Message Passing Interface) and LAPI (Low-level Application Programming Interface) protocols. There are various options in the level of striping that can be supported:\n\n","The mechanism which enables an out-of-order data transfer RDMA system also provides a corresponding ability to carry out broadcast operations, multicast operations, third party operations and conditional RDMA operations. Each of these is now considered and the use of an out-of-order RDMA mechanism is described illustrating how it is used to carry out these various objectives and protocols.","Third party RDMA operations are considered first. The present invention provides the ability for a single central node in a cluster or network to be able to effectively and efficiently manage the transfer of data between other nodes, or to create a means for allowing a directed distribution of data between nodes. See . These sorts of situations have traditionally been solved using complex logic. The present approach allows these directed transfers to be made without the direct knowledge or involvement of either the data source or data target nodes. The concept here is for the managing node to send a special RDMA request to an adapter on the data source node requesting that an RDMA transfer be executed with a particular data target node. When the data transfer is complete, the third party controller is designated as the recipient of the completion notification. These kinds of third party transfers are very common in DLMs (Distributed Lock Managers) and elsewhere. An example of the usage of DLMs is in file systems. A node \u201cA\u201d in the cluster may make a file system read\/write request. The request gets forwarded to one of the DLM table manager nodes \u201cB.\u201d The DLM table manager handles the request, checks its tables and determines that Node \u201cC\u201d owns the blocks of data that node \u201cA\u201d requests access to. Node \u201cB\u201d can now send a third party RDMA transfer request to node \u201cC\u201d asking node \u201cC\u201d to send the requested data to node \u201cA\u201d and to notify node \u201cB\u201d when the transfer is complete. The ability to efficiently implement third party RDMA is central to such applications. Another example of a programming model of this kind is found elsewhere in certain applications which employ a \u201cping\u201d operation which has very similar semantics. Such models eliminate the need for node \u201cB\u201d to send information back to node \u201cA\u201d asking it to fetch the requested data from node \u201cC.\u201d Third party transfers thus help to cut down the number of handshake operations that must normally be performed to effect such transfer.","More particularly, this process involves controlling or managing a node so that it \u201cknows\u201d the available rCxt ids, current tids and the memory structure of the data source and data target nodes. The controlling or managing node constructs a Third Party RDMA Read Request packet, which is almost identical to a RDMA Read Request except for the new packet type and the inclusion of a new field that specifies the identity of the data target adapter. See .","When the data source adapter receives the Third Party RDMA Read Request packet and verifies the rCxt key, tid, etc., it swaps the node ids for the source and the data target, and initiates the operation to send the data to the data target adapter. Except for the initialization of the packet header, the operation is identical to any other RDMA send operation. All RDMA data packets sent contain the packet type of Third Party RDMA Write Request.","When the data target adapter receives the Third Party RDMA Write Request packets, they are processed just as the adapter would process any RDMA Write Request packet, by first setting up the local rCxt, and then by moving the data into the appropriate location in system memory. The only difference between a RDMA Write Request and a Third Party RDMA Write Request is with respect to the destination of the completion packet. Normally the adapter sends the completion packet to the data source adapter, but here it sends it to the controlling or managing adapter identified in the new field of the packet header.","The problem being solved by this aspect of the present invention is that of providing the efficient distribution of data to multiple nodes in a cluster or network. Although broadcast is not a new concept, broadcast RDMA is new since it allows for the data to be placed within specific ranges in target node memory.","The basis of this approach is to merge the RDMA operation with the ability of the hardware to support broadcast packets. In this process, a single data source within the network or cluster efficiently distributes large amounts of data to all of the other nodes in the system. If the transfers are done with target side notification, then the target side upper layer protocols send unicast acknowledgments to the data source indicating that they have successfully received the data. Failure to receive such unicast notification can then be employed to drive a retry targeted at the single failing recipient.","This operation is enabled by having RDMA Broadcast configurations, including rCxt ids and the system memory configurations to support the PVOs being used. The data source node uses a rCxt id, current tid and PVOs that be are acceptable to the target adapters.","When the data source adapter sends an RDMA broadcast packet, it sets up the packet header just as it would any RDMA Write Request packet, except that the target adapter id is set to the broadcast id, and it requests a completion packet to the data target side only (the packet type is set to RDMA Write Request). The completion packet that is passed to the data target receive FIFO queue identifies the source of the data to the protocol. It is then up to the upper level protocol (ULP) to manage any selective retransmission that may be required.","More particularly, the broadcast RDMA operation is performed by providing RDMA Broadcast configurations, including rCxt ids and system memory configurations to support the Protocol Virtual Offsets (PVOs) being used (see also below under Failover Mechanisms). The data source node uses an appropriate rCxt id, current tid and PVOs that are acceptable to the target adapters.","When the data source adapter sends a RDMA broadcast packet, it sets up the packet header just as it would any RDMA Write Request packet, except that the target adapter id is set to the broadcast id, and it requests a completion packet to the data target side only (the packet type is set to RDMA Write Request). The completion packet that is passed to the data target receive FIFO identifies the source of the data to the protocol. It is then up to the upper level protocol to manage any selective retransmission that may be required.","The problem being solved by this aspect of the present invention is the ability to provide support for things such as IPv6 on a cluster, where data needs to be distributed to multiple but not all nodes within a cluster. This approach provides such support by taking advantage of a special use of Broadcast RDMA.","In this aspect of the present invention, the underlying approach is to is to have special purpose RDMA Contexts that are reserved for this use. If the RDMA Contexts are defined and ready, then the node receiving these broadcast packets receive the data, otherwise they do not. These RDMA Contexts provide for the selective distribution of data in much the same way that a multicast address is used in network adapters. As with the Broadcast RDMA, the multicast RDMA uses unicast notifications from the data target to manage retransmissions.","The Multicast operation is identical to the broadcast operation described above, except that only a select subset of the data target adapters are provided with the RDMA Contexts (rCxts). Although the packet is seen by all adapters on the network, it is only processed by those which have the rCxt defined. All other adapters simply discard the packets.","The problem being addressed by this aspect of the present invention is the efficient management of a list of actions where later transactions are dependent upon the successful completion of earlier operations. This is traditionally managed by having the high level protocols coordinate such dependent operations, and only issue the dependent operation to the adapter once the earlier operations are completed.","In this aspect, the present invention also allows an application program to queue multiple related RDMA requests using multiple rCxts to the adapter, and to specify their relationship. This is performed by having the application program place a new RDMA Conditional entry in the Send FIFO command followed by the component RDMA requests.","One use for this operation is to perform a set of RDMA Write operations, followed by a signal to the data target that all of the set of RDMA Write operations have completed successfully. In this scenario, the data source adapter monitors RDMA Completion packets, and once all of the set of RDMA Write operations has completed, it starts an RDMA Write operation that acts to signal the data target.","The present invention also allows an application program to queue multiple related RDMA requests using multiple rCxts to the adapter and to specify their relationship. There are a variety of ways to implement dependent sets of operations of this kind. A preferred implementation works as follows:\n\n","This implementation is made more usable with the addition of send FIFO commands that allow conditional queues and counters to be manipulated (such as clearing or setting to some particular count) and queried under upper layer protocol (ULP) control.","One use for this operation is to perform a set of RDMA Write operations, followed by a separate RDMA operation to signal to the data target that the larger set of operations have completed successfully. In this scenario, the data source adapter monitors RDMA Completion packets, and only once all of the set of RDMA Write operations has completed will it start an RDMA Write operation that will act to signal the data target.","Interrupts are used by communications adapters to inform the device driver that there is something ready for it to process. Typically, the interrupt is generated only when the data or entry to be processed is already in system memory. The present invention is also advantageous in that improvements are provided in interrupt handling. In particular, the present invention enables significant improvements in the performance and flexibility of a clustered or network of data processing nodes by improving the interrupt handling abilities of the system. In this aspect of the present invention, the adapter generates an interrupt as soon as possible rather than waiting for all of the data to be in system memory. This allows the interrupt processing overhead to run in parallel with the movement of data, thus providing a significant performance benefit as long as there is a CPU which is free to process the interrupt code early, which is usually the case. The present invention is also particularly applicable and beneficial in the circumstance in which multiple interrupt handlers are present. The invention allows for multiple threads to be managing interrupts from a single adapter, so as to make overall system improvements possible. It should also be noted that processing of the interrupt table does not necessarily have to be done within the interrupt handler, but can be implemented as a function of the driver that is triggered by the interrupt handler. Therefore, what is thus provided is the ability to have multiple threads that allow multiple copies of the interrupt table being handled concurrently. Performance tuning is, however, desired to ensure that applications are structured in a manner that benefits from this optimization feature.","Considerations of early interrupt notification are presented first. In the interest of obtaining the best possible performance, especially with respect to latency, within a cluster environment, the need to overcome overhead associated with interrupt management stands out as a very desirable goal. Typically there is little that can be done to overcome this problem outside of attacking the interrupt management path itself. However, the present invention provides an alternative.","The interface between the adapter and the upper layer protocols uses send and receive FIFO queues which have a well defined structure. Each slot or entry in these FIFO queues is initialized to a known value by the upper layer protocol, and only once this value changes, does the upper layer protocol assume that the entry is complete. To ensure this, the adapter writes the first cache line of the entry (where this special signal is stored) after all other data in the entry has reached coherence in system memory.","In this aspect of the present invention the adapter generates an interrupt to indicate that the data is available prior to the data reaching coherence within the system. In this way, the system software overlaps processing of the interrupt itself with that of the adapter storing the remaining data into system memory. If the system software reaches the point of reading the FIFO queue before the first cache line has been successfully written, the system software can poll on the entry awaiting its completion, and there is no exposure to data corruption, but the interrupt overhead has been masked. The early interrupt notification mode is enabled only in the case that the CPU is not busy doing application work.","Attention is now directed to considerations present when Multiple Interrupt Handlers are involved. As mentioned above, the present invention is useful in overcoming some of the concerns relating to the latency associated with the handling of interrupts. There are multiple ways of addressing latency, including the early notification approach discussed above. An alternate approach is to provide multiple resources for managing interrupts. Since the hardware used in the adapter herein allows for multiple interrupt levels to be used concurrently for LPAR (Logical Partition) sharing support, the hardware is now used differently by registering multiple interrupt handlers from a single LPAR.","The system enables multiple interrupt levels using a configuration setting at adapter initialization. The adapter currently tracks the state of a single interrupt handler as either ready or not ready. Upon presenting an interrupt, the interrupt handler is assumed to be not ready. The interrupt handler notifies the adapter that it is ready for another interrupt via an MMIO. This concept is easily expanded to manage multiple interrupt handlers. As interruptable events occur, the adapter checks for an available interrupt handler, and provide that interrupt handler, or the next one to become available, with the latest information about events that are pending.","Attention is now directed to those aspects of the present invention which are related to the use of a snapshot interface. This aspect provides significant performance advantages in multiprocessor interfaces by introducing a nonblocking means for synchronizing operations between processors.","In terms of this present invention, a snapshot interface exists between processors, where one processor (the master) issues a command to another (the slave), and the master needs to determine when the slave has completed the requested operation. Although this is a common interface issue, it becomes more complex when:\n\n","An example of one situation where this invention is useful is when the device driver or hypervisor must know when a potentially disruptive command such as \u201cClose Window\u201d has completed before it performs some subsequent action such as releasing system memory that is associated with that Window. Another use for this invention occurs when there is a need for one task to ensure that all other tasks processing packets for the same message are completed before reporting message completion to the system processor.","This nonblocking mechanism operates by having the disruptive action, such as the \u201cClose Window\u201d command, produce a snapshot of the current state of the adapter microcode. Bits in the snapshot are cleared as ongoing activity completes. When the snapshot changes to all zeroes, then the device driver knows that all of the microcode tasks have seen or will see the new state.","The steps in this process may be understood with respect to . The Live Task View register tracks the state of each task running on the adapter. Whenever a task starts, whether processing a command, sending a packet, or handling a received packet, it sets the bit corresponding to its task id in the Live Task View register. When the task completes its operation, it clears that bit prior to moving on to another operation, suspending, or deallocating task.","When system software issues a disruptive command, such as a Close Window command, it needs to ensure that all tasks running on the adapter are aware of the change before it performs other operations such as releasing system memory associated with the window being closed. Therefore, when processing the Close Window and other disruptive commands, the command task copies the Live Task View register to the Snapshot View register. Whenever a task completes an operation, it clears the bit associated with its task id in both the Live Task View register and the Snapshot View register. Once all tasks that were active at the time of the disruptive command have completed the operations in progress at the time of the disruptive command, the Snapshot view register becomes all zeroes.","The system task can periodically issue a Read Snapshot command after having issued the disruptive command. The Read Snapshot command returns the current state of the Snapshot View register. When the Read Snapshot command returns a value of zero, the system task can then safely assume that no tasks on the adapter are still operating with old state information.","The use of various aspects of the present invention also introduces the additional concern of how to deal with so-called trickle traffic. Trickle traffic can be defined as data received from the network that is stale but may have all the signatures of a valid packet data. The present invention deals with RDMA trickle traffic for persistent subsystems after LPAR reboot and adapter recovery events. It is important to be able to eliminate trickle traffic for persistent subsystems that use RDMA since this can cause data integrity problems and\/or message passing failures. An LPAR reboot is considered to be a failure or administrative event that takes place within a node. An adapter recovery event is issued and executed in response to a failure within an adapter. Since out-of-order RDMA over an unreliable datagram transport is a novel approach to data transfer, there are no existing solutions to this problem. It is important to note that the solution to trickle traffic for Zero Copy data transport used by persistent subsystems in the past does not work for RDMA since they relied on a two sided protocol support. For RDMA since the problem is twofold (detailed below) the solution provided herein is also twofold:\n\n","As indicated above, these solutions are now described in greater detail:","Random PVO\/TCE key seed generation by the device driver provides one possible solution. When the persistent subsystems are initialized they have to register memory regions that they intend to use for RDMA operations with the device driver. The device driver calculates a PVO for each memory region registered. The PVO for each memory region contains enough information to allow the adapter to index into the correct TCE table and fetch the real page address of the ULP's memory region, calculate the offset into that real page address, and the PVO.key that is used to validate the PVO is not stale. The PVO.key is used to provide interapplication debug information and stale packet detection. At device driver configuration time the system's time base register is used to seed the generation of PVO\/TCE keys. This random seeding of the device drivers PVO\/TCE key generation insures that the keys generated are different for the same buffer across reboots. The adapter checks that the TCE.key saved in kernel (or hypervisor) memory matches the PVO.key in all RDMA packets. This check prevents packets sent to this adapter with a stale PVO (trickle traffic) from reaching the protocols.",{"@attributes":{"id":"p-0185","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":{"@attributes":{"id":"ul0032-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":["1. One solution is to use a round robin mechanism to assign rCxt (RDMA Contexts) to protocols: all protocols, including persistent subsystems, acquire rCxt, which are adapter resources needed for RDMA operations, from the device driver during initialization. The device driver maintains the available rCxt in a linked list. It hands out rCxt from this list when the protocols acquire them and then adds them back to this list when the protocols free them. If the device driver allocates the rCxt using the head of the linked list and then frees them using the tail of the linked list we can virtually guarantee (if we have a large number of rCxts) that the protocols never get the same set of rCxt. The adapter is designed to verify that the all rCxts used in RDMA operations are valid by conducting two checks. The first rCxt check is to insure that the rCxt is owned by the current window by checking the rCxt's rCxt.window field in adapter memory. The second check made by the adapter verifies that the rCxt_id.key for the RDMA operation matches the rCxt.key field in adapter memory. Both the rCxt.window and rCxt.key fields in adapter memory are initialized by the device driver when rCxts are assigned to windows. Since protocols are required to reacquire rCxts after any adapter recovery event, this round robin allocation mechanism guarantees a very high probability that they will get a disjoint set of rCxts, and that stale RDMA (trickle traffic) packets will fail the rCxt key check. In the presently preferred implementation we do not have a large enough set or rCxts for this round robin allocation method to guarantee all stale RDMA packets are detected. The number of rCxts needed for the round robin allocation method to guarantee protection requires two times (or more) rCxts in the rCxt pool as would ever be outstanding between adapter failures. Round robin allocation is used for rCxt in our implementation for debug ability reasons.","2. One solution is to provide persistent subsystems that deregister and reregister memory regions with the device driver: all persistent subsystems are required to deregister their memory regions when they are notified of an MP_FATAL event. After recovery is complete they can reregister their memory regions with the device driver causing the device driver to change the PVO and TCE keys for each of the memory regions. Any stale RDMA packets that reaches the adapter after the recovery will fail the PVO.key=TCE.key check and will be discarded by the adapter. However failing the PVO.key=TCE.key check also causes the adapter detecting the error to drive a window fatal error. If memory regions are common between adapters then the persistent subsystems are required to register them individually for all the adapters to prevent a MP_FATAL event on one adapter from impacting ongoing transfers on other adapters. The systems herein are optimized for the case where multiple adapter in the node share send and receive buffers so we have chosen not to implement this method for stale RDMA packet detection. Systems that are limited to supporting only one adapter, or where shared buffers are not needed should consider this solution.","3. Another solution is to add a key field to the rCxt ID: The rCxt_id in packet headers and the rCxt structure in adapter memory will be expanded by adding a key fields (rCxt_id.key and rCxt.key). The device driver will maintain a count of adapter recovery events for each adapter, and will use this count as the key for the rCxts when they are allocated. When stale RDMA packets show up at an adapter that has gone through an adapter recovery, they will be discarded because of the rCxt_id.key=rCxt.key check failure. The adapter will not drive a window error when a packet is discarded due to the rCxt_id.key check. This is important due to adapter recovery being fast relative to the in time needed to transfer a stream of RDMA packets. Our system implements rCxt key checking to guarantee detection of stale RDMA packets after adapter recovery events."]}}}},"Limited TCE table space available in kernel (or hypervisor) memory can limit the amount of memory that can be mapped for RDMA operations at any given time. The high cost of translating and mapping buffers accessed by more then one adapter and\/or task can also limit node performance unnecessarily. There is thus a need for the system to ensure efficient memory protection mechanisms across jobs. A method is thus desired for addressing virtual memory on local and remote servers that is independent or the process ID on the local and\/or remote node.","The use of node global TCE tables that are accessed\/owned by RDMA jobs and managed by the device driver in conjunction with the Protocol Virtual Offset (PVO) address format solves these problems.","Each node is configured with one or more adapters that supports RDMA communications. All of the RDMA capable adapters are configured to access a shared set of TCE tables that reside in kernel (or hypervisor) memory space in the node. Each TCE table is used to map buffers backed by any one of the system supported page sizes. In a preferred embodiment of this invention page sizes of 4 KB, 64 KB, and 16 MB are supported when available from AIX (the UNIX based operating system supplied by the assignee of the present invention). The ownership\/access to each TCE tables is granted by JOBID. The device driver is responsible for management of the TCE tables. In the presently preferred embodiment, the actual updates to the TCE tables in hypervisor memory are done through hypervisor services. When an RDMA job requests that a buffer be made available for communication the device driver updates TCEs for one of the tables assigned to that RDMA JOBID, and the buffer becomes addressable to all adapters on the node that are active for that RDMA JOBID.","The PVO format is used to encapsulate four pieces of information about a memory buffer that is prepared for RDMA communication: the index of the TCE table where real page address for the buffer are cached, the index into that TCE table, the interpage offset into the real page address (real page address is stored in the TCE) where the buffer starts, and a protection key used to detect programming errors and\/or stale RDMA packets.","Current solutions have one or more TCE table for each adapter. If a buffer is accessed by more then one adapter, that buffer is mapped by TCE tables specific to each adapter. In current designs, buffer ownership is tracked by process id or by window id. In a node where a buffer is shared by more then one process (or window) that buffer must be mapped into TCEs owned by each process, causing duplicate entries in each of the adapter specific TCE tables. There are no know solutions which provide node global TCE tables in combination with process independent virtual addressing support for local and remote adapter accesses to RDMA buffers in user space systems memory.","In systems where multiple RDMA capable adapters are used, it is desirable to avoid translating and mapping any given buffer more then one time if possible. Node global TCE tables setup and managed by the device driver are shared by all of the RDMA adapters in the node. With node global TCE tables an RDMA buffer that is accessed by tasks running over more than one adapter needs only to be mapped one time. In addition the ownership of the TCE is moved from process id (or window id) scope to RDMA JOBID scope so that multiple processes in an RDMA job can avoid TCE entry duplication. Buffer addressing for RDMA operations use the Protocol Virtual Offset (PVO) addressing format. The PVO address format allows tasks in an RDMA job to exchange buffer addressing information between tasks on different servers. The PVO format also allows the protocols to add byte offsets to PVO's to access any byte in a RDMA buffer. For example, if the protocol has a valid PVO for a 32 MB buffer it can manipulate the PVO (or a copy of the PVO) to address the data starting at PVO+2000 bytes. A protocol that makes a programming error when using an invalid PVO, or a valid PVO with an invalid transfer length is provided with a fatal error condition. One example of such an error is the use of a valid local PVO for a 4 KB memory region in an RDMA write operation with a transfer length of 16 KB, in this case the protocol that issued the invalid RDMA write operation would receive an asynchronous window fatal error. Note that addressing violations can only be detected when a page boundary is crossed because all memory access checks are page (and page size) biased.","The following steps are used by the adapter to validate the PVO in an incoming RDMA network packet and generate a real address:\n\n",{"@attributes":{"id":"p-0193","num":"0289"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE I"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PVO Format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Region Key","Table Index","Virtual Offset"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["17 bits","5 bits","42 bits"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0194","num":"0290"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE II"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TCE Format"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TCE Key","Real Addressing Bits"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"22 bits","42 bits"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0195","num":"0291"},"figref":"FIG. 15","b":["1008","1009","1","1005","2","1006","1000","1014","1015","1013","1010","1011","3","1007","1022","1016","1017","1012","1001","1002","1013","1003","1004","1018","1021","1000"]},{"@attributes":{"id":"p-0196","num":"0292"},"figref":["FIG. 16","FIG. 16"],"b":["1101","1102","1102"]},{"@attributes":{"id":"p-0197","num":"0293"},"figref":"FIG. 17","b":["1205","1","1206","1201","1202","1203","1204","1","2","3","4","1207","1210","1207","1211","1208","1212","1209","1213","1210","1214","1207","1210"]},{"@attributes":{"id":"p-0198","num":"0294"},"figref":["FIG. 18","FIG. 17"],"b":["1305","1","1306","1309","1310","1313","1310","1313","1301","1302","1303","1304"]},"Some details of the presently preferred embodiment with respect to node global TCE tables and PVO addressing are now provided. Each adapter can access 32 TCE tables in hypervisor memory. The device driver sets up 20 TCE tables for use with 16 MB pages, and 10 tables for use with 4 KB pages when the first SMA\/SMA+adapter device driver configures. The tables are then allocated to five RDMA job slots structures with for 16 MB tables, and two 4 KB tables assigned to each slot. As the device driver for each adapter is configured each of the 30 TCE tables used are registered with the adapter, but the table JOBID ownership for each table is forced to an invalid setting. When the system's parallel job scheduler sets up a RDMA job it makes a request to the device driver for each of the adapters that tasks are scheduled on to reserve RDMA TCE resources, and assigns a RDMA JOBID. At this time the device driver assigns one of the five RDMA job slots (if one is available) to that JOBID, and updates the selected adapter(s) to reflect that a valid RDMA JOBID has ownership of the selected set of TCE tables. When a protocol registers a buffer for use in RDMA operations it makes a call into the device driver with the virtual address and length of its buffer. The driver makes any needed access checks, and if everything looks good the buffer is pinned, translated and mapped into one of the TCE tables assigned to the caller RDMA JOBID. The device driver selects the first available TCE entrees from a TCE table for the correct page size (with respect to the page size backing the callers buffer). The TCE table index, and the index of the first TCE for the callers buffer, the buffers interpage offset, and a key are used to calculate the buffers PVO. The 17 bit PVO.key and the 5 bit PVO.table are combined to form the 22 bit TCE.key. The device driver updates the TCE table in hypervisor memory and returns the PVO to the caller. Once all of the adapters are selected, the system's parallel job scheduler sets up the RDMA job which now has access to the caller's buffer for RDMA operations.","In the latest adapter Internet protocol (IP) interface driver, the transmission of packets over a given size uses a remote DMA (RDMA) mechanism. This process utilizes a single destination in order to appropriately allocate memory and therefore is unavailable for broadcast traffic. In order to work around this problem, the interface of the present invention uses its FIFO mode transmission for all broadcast traffic regardless of the size of the packet, which could be problematic for packets larger than the memory space assigned to each FIFO slot.","The interface protocol does a fragmentation of large broadcast packets and adjusts the AIX Internet protocol (IP) header information accordingly. This offloads the broadcast reassembly into the AIX IP layer, and allows the adapter IP interface to transmit broadcast traffic larger than the size of the FIFO slot.","In the interface layer there are two transmission pathways available. For small packets of any destination type, the interface assigns a FIFO slot to the packet, copies the data into that slot, and transmits packets. For packets with more data than can fit into the FIFO slot, the interface sets up a remote DMA of the data across the network. This process can accommodate only a single destination, however, and is inappropriate for traffic intended for broadcast or multicast addresses.","For a packet with multiple destinations and more data than can fit into a single FIFO slot, the adapter IP interface layer then segments the packet into sections which can fit into FIFO slots. The interface then assigns the packet the appropriate number of FIFO slots, and copies the data into those slots just as it would with a small packet transfer.","However, these individual packets cannot then be simply transmitted to the broadcast address as is. To most efficiently reassemble these broadcast packets upon receipt at the destination, the interface adjusts the data in the AIX IP layer's header. The fields altered are those which indicate that this packet is part of a larger message and then sets the offset into the larger packet so that it can be properly reassembled. By offloading the reassembly to the AIX IP layer, the interface efficiently minimizes the processing time required for the large broadcast packets in the receive flow. This then frees up processing time in the interface receive handler for other packets which then could otherwise impact the performance of that receive flow. The interface thus efficiently processes the large packets while ensuring that broadcast traffic is not restricted to messages of the interface's FIFO size.",{"@attributes":{"id":"p-0205","num":"0301"},"figref":["FIG. 20","FIG. 20"]},"In order to arrange for AIX IP reassembly by the destination partitions, the interface then modifies the IP header data in order to ensure that the AIX IP layer processes the several fragmented packets accordingly. Thus, the diagram indicates that the IP header is in fact modified before transmission over the switch.",{"@attributes":{"id":"p-0207","num":"0303"},"figref":"FIG. 21"},"There are two alternative ways of handling this situation, each with their own set of issues.","The first alternative is to have a similar implementation which fragments the IP packets, but instead of reassembling them in the IP layer, they are reassembled in the interface layer. The drawback to this approach is the added complexity for reassembling and the time-out capability that would need to be added in the interface layer to handle the IP fragments of large broadcast IP datagram.","The second alternative is to force the maximum transfer unit (MTU) to be 2,048 bytes (equal to or less than the switch fragment size). This would severely limit the performance of whole TCP\/IP stack since the ULP would have to be invoked for every 2K byte chunk causing the per packet protocol processing to be much higher for larger transfers.","Thus, by manipulating the AIX IP header data for large broadcast packets to mimic a series of packets which has been segmented by the AIX IP layer itself, the adapter interface layer can ensure that the message is properly reassembled by the receiving adapters. This allows for broadcast messages of all sizes which use the FIFO mode of transfer and avoid conflicts with the RDMA mechanism commonly used for packets of that size.","In order to have the best performance for task to task data transfer, it is often useful to avoid copying data into and out of communication buffer, but rather have the data go directly into the user buffer from the communication hardware. This is the remote direct memory access (RDMA) capability implemented by IBM. However, there are a couple of problems with the use of RDMA which this invention intends to overcome. In order to use RDMA there must be some mapping between the Protocol Virtual Offset (PVO) for the pages and the real memory addresses were the data is stored. Currently, either the user is required to prepare any buffer before it is used with RDMA as is done with other interconnection vendors, or there must be hooks to into the Operating System (OS) so that the adapter can use the operating system's page tables to get the corresponding real addresses.","One of the core features of the present invention is to provide a mechanism to efficiently utilize the mapping between one or more task Protocol Virtual Offset (PVO) spaces and one of the Protocol Virtual Offset (PVO) spaces on the adapter that is described earlier. Here, the user's address space is fragmented into fixed size chunks or fragments, which are unrelated to the VM (Virtual Memory) page size. When an RDMA operation is attempted, the virtual memory address space range is checked to determine if it has already been mapped to an adapter's Protocol Virtual Offset (PVO) space. If it has already been mapped, then it reuses the previously obtained adapter virtual addresses to affect the data transfer using RDMA. If the check shows that the address range is not mapped then the protocol maps one or more of the fragments of the user's Protocol Virtual Offset (PVO) space to the adapter's Protocol Virtual Offset (PVO) space and use those adapter virtual addresses for the data transfer. These new mappings are then saved so that any subsequent transfers within the same chunk of virtual memory are accomplished with no additional setup overhead.","This mechanism provides advantages over other ways of solving this problem. When used for a two sided protocol, its use is completely transparent to the user. This means that application programs require no changes in order to enjoy the performance benefits of the smart reuse of the setup for RDMA across multiple RDMA transactions from\/to the same user buffers. The use of this invention permits very modular programming since there is no coupling of the operating system page tables and the user virtual memory. Finally this permits a server application to maintain separate mappings for multiple tasks and to affect data transfer on their behalf. This is very useful in a kernel context, but it can also be used by a root client.","Much of the overhead associated with RDMA transfer path is the setup cost of pinning and mapping the user buffers. Since the present \u201clazy\u201d deregistration model for RDMA supports persistent data translations and mappings, this overhead cost can be eliminated for most large transfers. Consider first the case of a 32 bit address space. The address space consists of 256 fragments of 16 Megabytes each. This fragmentation is by way of example only to illustrate the concepts that are embodied in the present invention. It should be noted though that this design does not require any specific fragment size. However, for the sake of simplicity, to explain the relevant concepts herein, a fragment size of 16 MB is used to explain the invention. The allocation is therefore done in a 16 MB fragment size.","First a bit vector is created to keep track of mapped fragments. See  which is limited for explanatory purposes to showing only the mappings between the virtual address space of a single task and the adapter PVOs. Each bit corresponds to a single 16 Megabyte fragment. This bit vector must be 8 unsigned integers in length (which is 256 [fragments in address space]\/32 [bits in integer]. If a bit in this bit vector is set, then there already exists a mapping between the task Protocol Virtual Offset (PVO) space and the adapter Protocol Virtual Offset (PVO) space.","The ULP library first checks if the 16 Megabyte fragment is mapped. If it is mapped, an auxiliary array, indexed by the bit number in the bit vector described above holds a pointer to a structure which has the PVOs. If it is not mapped, then the mapping is done and the map bit is set. If the Protocol Virtual Offset (PVO) is mapped, the protocol verifies that the mapped region corresponds to the existing virtual memory. If it does not, then the memory region is unmapped and remapped. This is necessary, under the following scenario. A user attaches a shared memory segment to some region of the address space. This buffer is used for communication for a while. Later this shared memory segment is detached from the user address space and a different shared memory segment is attached to the same Protocol Virtual Offset (PVO). Each time the fragment is referenced, the idle_count is set to zero. The idle_count is incremented once per second based on timer ticks. If the idle count reaches some tunable amount, the segment is unmapped, if not in use. The use_count is incremented each time the address is used in a bulk transfer and is decremented when the RDMA operation has completed. This simple mechanism allows for a LRU (least recently used) policy of reclaiming mapped regions. At the ULP level a message may be delivered more than once. In this respect it is also noted that there is no message delivered after notification.","For 64 bit address spaces, the address space is segmented into 4 GB segments and a hash table is created for the bit mappings described above. This is shown in .","This invention effectively allows fast and transparent access to the user memory from the communication hardware. The adapter mapping may be discarded either when the application ends or when the idle count is too large or when a mapping fails.",{"@attributes":{"id":"p-0220","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["BMR\u2014\u201cBuffer Manager Response Register\u201d: Contains information about a channel buffer (in particular the count of send and receive tasks bound to the adapter window).","CB\u2014\u201cChannel Buffer\u201d: A CB is cache for a LMT. A CB contains two pieces (each 256 bytes in length) called CB0 and CB1. The present adapter has 16 CBs, exactly as many as it (potentially) has tasks. Several tasks may be acting on behalf of a single adapter window; in that case those threads all share the same CB. The CBs are essentially microcode managed caches; in particular the microcode is responsible for flushing CBs to adapter SRAM.","CTR\u2014\u201cCurrent Task Register\u201d: Identifies currently active task (0 . . . 15).","DM\u2014\u201cData Mover\u201d: Adapter DMA engine for accessing system memory and adapter SRAM.","DTB\u2014\u201cData Transfer Buffer\u201d: An adapter buffer for holding packet payloads. The present adapter has 8 DTBs.","GR\u2014\u201cGlobal register\u201d: A register accessible to all adapter tasks.","LMT\u2014\u201cLocal Mapping Table\u201d: A data structure associated with, and governing the operation of, a adapter window. The data structure is provided in adapter SRAM. A small part of the data structure is \u201cunderstood\u201d by the device driver; most of the structure is for the private use of adapter microcode. An LMT entry may be cached in an adapter CB.","PM\u2014\u201cPacket Mover\u201d: DMA engine for transmitting and receiving packets.","PVO\u2014\u201cProtocol Virtual Offset\u201d: A data structure used to define portable address mappings between adapters for RDMA.","TR\u2014\u201cTask register\u201d: A task-private register.","ULP\u2014Upper Layer protocol which in the presently preferred embodiment includes HAL (Hardware Abstraction Layer), LAPI (Low Level Application Programming Interface), and MPI (Message Passing Interface)."]}},"While the invention has been described in detail herein in accordance with certain preferred embodiments thereof, many modifications and changes therein may be effected by those skilled in the art. Accordingly, it is intended by the appended claims to cover all such modifications and changes as fall within the true spirit and scope of the invention."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","The Concept of a Window","The Receive Side","The Send Side","LMT Contents","Memory Protection Model","RDMA Write","Ordering Semantics and Usage Model","RDMA Read","RDMA Context (rCxt) Structure","Half RDMA and Half FIFO Operations","Remote Direct Memory Access with Striping over an Unreliable Datagram Transport","Third Party, Broadcast, Multicast and Conditional RDMA Operations","Broadcast RDMA Operations","Multicast RDMA Operations","Conditional RDMA Operations","Early Interrupt Notification in RDMA Operations","Snapshot Interface in RDMA Operations","Failover Mechanisms in RDMA Operations","Elimination of Trickle Traffic for a Persistent Subsystem after an LPAR Reboot","Elimination of Trickle Traffic for a Persistent Subsystem after Adapter Failure","Node Global TCE Tables and Protocol Virtual Offset Addressing Method","Interface Internet Protocol Fragmentation of Large Broadcast Packets in RDMA Environment","Lazy Deregistration of User Virtual Machine to Adapter Protocol Virtual Offsets","BRIEF GLOSSARY OF TERMS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention, however, both as to organization and method of practice, together with the further objects and advantages thereof, may best be understood by reference to the following description taken in connection with the accompanying drawing in which:",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 7","FIG. 3"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 9","FIG. 3"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
