---
title: System and method for on-the-fly file folding in a replicated storage system
abstract: A file folding technique reduces the number of duplicate data blocks of the file consumed on a storage device of a file server. According to the file folding technique, the “old” data blocks are being overwritten with “new” data and that new data is identical to the data of the “old” data, no write operation occurs. The invention reduces disk space consumption in a file server and also reduces the number of write operations directed to disks associated with the file server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07437523&OS=07437523&RS=07437523
owner: Network Appliance, Inc.
number: 07437523
owner_city: Sunnyvale
owner_country: US
publication_date: 20030425
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["This application is related to the following United States patent applications:","Ser. No. 10\/100,950 entitled, SYSTEM AND METHOD FOR ASYNCHRONOUS MIRRORING OF SNAPSHOTS AT A DESTINATION USING A PURGATORY DIRECTORY AND INODE MAPPING, by Stephen L. Manley, et al. the teachings of which are expressly incorporated herein by reference;","Ser. No. 10\/100,434, entitled SYSTEM AND METHOD FOR REDIRECTING ACCESS TO A REMOTE MIRRORED SNAPSHOT, by Raymond C. Chen, et al., the teachings of which are expressly incorporated herein by reference;","Ser. No. 10\/100,879, entitled FORMAT FOR TRANSMISSION OF FILE SYSTEM INFORMATION BETWEEN A SOURCE AND A DESTINATION, by Stephen L. Manley, et al., the teachings of which are expressly incorporated herein by reference;","Ser. No. 10\/100,967, entitled SYSTEM AND METHOD FOR DETERMINING CHANGES IN TWO SNAPSHOTS AND FOR TRANSMITTING CHANGES TO A DESTINATION SNAPSHOT, by Michael L. Federwisch, et al., the teachings of which are expressly incorporated herein by reference; and","Ser. No. 10\/126,822, entitled SYSTEM AND METHOD FOR CHECKPOINTING AND RESTARTING AN ASYNCHRONOUS TRANSFER OF DATA BETWEEN A SOURCE AND DESTINATION SNAPSHOT, by Michael L. Federwisch, et al., the teachings of which are expressly incorporated herein by reference; and","Ser. No. 10\/104,694, entitled FILE FOLDING TECHNIQUE, by Andy C. Kahn, et al., the teachings of which are expressly incorporated herein by reference.","This invention relates to file systems and more particularly to a technique for reducing disk write operations of a file server.","A file server is a computer that provides file service relating to the organization of information on storage devices, such as disks. The file server or filer includes a storage operating system that implements a file system to logically organize the information as a hierarchical structure of directories and files on the disks. Each \u201con-disk\u201d file may be implemented as a set of data structures, e.g., disk blocks, configured to store information. A directory, on the other hand, may be implemented as a specially formatted file in which information about other files and directories are stored.","A filer may be further configured to operate according to a client\/server model of information delivery to thereby allow many clients to access files stored on a server, e.g., the filer. In this model, the client may comprise an application, such as a database application, executing on a computer that \u201cconnects\u201d to the filer over a direct connection or computer network, such as a point-to-point link, shared local area network (LAN), wide area network (WAN), or virtual private network (VPN) implemented over a public network such as the Internet. Each client may request the services of the file system on the filer by issuing file system protocol messages (in the form of packets) to the filer over the network.","A common type of file system is a \u201cwrite in-place\u201d file system, an example of which is the conventional Berkeley fast file system. By \u201cfile system\u201d it is meant generally a structuring of data and metadata on a storage device, such as disks, which permits reading\/writing of data on those disks. In a write in-place file system, the locations of the data structures, such as inodes and data blocks, on disk are typically fixed. An inode is a data structure used to store information, such as metadata, about a file, whereas the data blocks are structures used to store the actual data for the file. The information contained in an inode may include, e.g., ownership of the file, access permission for the file, size of the file, file type and references to locations on disk of the data blocks for the file. The references to the locations of the file data are provided by pointers in the inode, which may further reference indirect blocks that, in turn, reference the data blocks, depending upon the quantity of data in the file. Changes to the inodes and data blocks are made \u201cin-place\u201d in accordance with the write in-place file system. If an update to a file extends the quantity of data for the file, an additional data block is allocated and the appropriate inode is updated to reference that data block.","Another type of file system is a write-anywhere file system that does not overwrite data on disks. If a data block on disk is retrieved (read) from disk into memory and \u201cdirtied\u201d with new data, the data block is stored (written) to a new location on disk to thereby optimize write performance. A write-anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations, particularly for sequential read operations, directed to the disks. A particular example of a write-anywhere file system that is configured to operate on a filer is the Write Anywhere File Layout (WAFL\u2122) file system available from Network Appliance, Inc. of Sunnyvale, Calif. The WAFL file system is implemented within a microkernel as part of the overall protocol stack of the filer and associated disk storage. This microkernel is supplied as part of Network Appliance's Data ONTAP\u2122 software, residing on the filer, that processes file-service requests from network-attached clients.","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable on a computer that manages data access and may, in the case of a filer, implement file system semantics, such as the Data ONTAP\u2122 storage operating system, implemented as a microkernel, and available from Network Appliance, Inc. of Sunnyvale, Calif., which implements a Write Anywhere File Layout (WAFL\u2122) file system. The storage operating system can also be implemented as an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows NT\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","Disk storage is typically implemented as one or more storage \u201cvolumes\u201d that comprise physical storage disks, defining an overall logical arrangement of storage space. Currently available filer implementations can serve a large number of discrete volumes (150 or more, for example). Each volume is associated with its own file system and, for purposes hereof, volume and file system shall generally be used synonymously. The disks within a volume are typically organized as one or more groups of Redundant Array of Independent (or Inexpensive) Disks (RAID). RAID implementations enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate caching of parity information with respect to the striped data. In the example of a WAFL file system, a RAID 4 implementation is advantageously employed. This implementation specifically entails the striping of data across a group of disks, and separate parity caching within a selected disk of the RAID group. As described herein, a volume typically comprises at least one data disk and one associated parity disk (or possibly data\/parity partitions in a single disk) arranged according to a RAID 4, or equivalent high-reliability, implementation.","In order to improve reliability and facilitate disaster recovery in the event of a failure of a filer, its associated disks or some portion of the storage infrastructure, it is common to \u201cmirror\u201d or replicate some or all of the underlying data and\/or the file system that organizes the data. In one example, a mirror is established and stored at a remote site, making it more likely that recovery is possible in the event of a true disaster that may physically damage the main storage location or it's infrastructure (e.g. a flood, power outage, act of war, etc.). The mirror is updated at regular intervals, typically set by an administrator, in an effort to catch the most recent changes to the file system. One common form of update involves the use of a \u201csnapshot\u201d process in which the active file system at the storage site, consisting of inodes and blocks, is captured and the \u201csnapshot\u201d is transmitted as a whole, over a network (such as the well-known Internet) to the remote storage site. Generally, a snapshot is an image (typically read-only) of a file system at a point in time, which is stored on the same primary storage device as is the active file system and is accessible by users of the active file system. By \u201cactive file system\u201d it is meant the file system to which current input\/output operations are being directed. The primary storage device, e.g., a set of disks, stores the active file system, while a secondary storage, e.g. a tape drive, may be utilized to store backups of the active file system. Once snapshotted, the active file system is reestablished, leaving the snapshotted version in place for possible disaster recovery. Each time a snapshot occurs, the old active file system becomes the new snapshot, and the new active file system carries on, recording any new changes. A set number of snapshots may be retained depending upon various time-based and other criteria. The snapshotting process is described in further detail in U.S. patent application Ser. No. 09\/932,578, entitled INSTANT SNAPSHOT by Blake Lewis et al., which is hereby incorporated by reference as though fully set forth herein. In addition, the native Snapshot\u2122 capabilities of the WAFL file system are further described in 3002 by David Hitz et al., published by Network Appliance, Inc., and in commonly owned U.S. Pat. No. 5,819,292 entitled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER-ACCESSIBLE READ-ONLY COPIES OF A FILE SYSTEM by David Hitz et al., which are hereby incorporated by reference.","The complete recopying of the entire file system to a remote (destination) site over a network may be quite inconvenient where the size of the file system is measured in tens or hundreds of gigabytes (even terabytes). This full-backup approach to remote data replication may severely tax the bandwidth of the network and also the processing capabilities of both the destination and source filer. One solution has been to limit the snapshot to only portions of a file system volume that have experienced changes. Hence,  shows a prior art volume-based mirroring where a source file system  is connected to a destination storage site  (consisting of a server and attached storage\u2014not shown) via a network link . The destination  receives periodic snapshot updates at some regular interval set by an administrator. These intervals are chosen based upon a variety of criteria including available bandwidth, importance of the data, frequency of changes and overall volume size.","In brief summary, the source creates a pair of time-separated snapshots of the volume. These can be created as part of the commit process in which data is committed to non-volatile memory in the filer or by another mechanism. The \u201cnew\u201d snapshot  is a recent snapshot of the volume's active file system. The \u201cold\u201d snapshot  is an older snapshot of the volume, which should match the image of the file system replicated on the destination mirror. Note, that the file server is free to continue work on new file service requests once the new snapshot  is made. The new snapshot acts as a checkpoint of activity up to that time rather than an absolute representation of the then-current volume state. A differencer  scans the blocks  in the old and new snapshots. In particular, the differencer works in a block-by-block fashion, examining the list of blocks in each snapshot to compare which blocks have been allocated. In the case of a write-anywhere system, the block is not reused as long as a snapshot references it, thus a change in data is written to a new block. Where a change is identified (denoted by a presence or absence of an \u2018X\u2019 designating data), a decision process , shown in , in the differencer  decides whether to transmit the data to the destination . The process  compares the old and new blocks as follows: (a) Where data is in neither an old nor new block (case ) as in old\/new block pair , no data is available to transfer (b) Where data is in the old block, but not the new (case ) as in old\/new block pair , such data has already been transferred, (and any new destination snapshot pointers will ignore it), so the new block state is not transmitted. (c) Where data is present in the both the old block and the new block (case ) as in the old\/new block pair , no change has occurred and the block data has already been transferred in a previous snapshot. (d) Finally, where the data is not in the old block, but is in the new block (case ) as in old\/new block pair , then a changed data block is transferred over the network to become part of the changed volume snapshot set  at the destination as a changed block . In the exemplary write-anywhere arrangement, the changed blocks are written to new, unused locations in the storage array. Once all changed blocks are written, a base file system information block, that is the root pointer of the new snapshot, is then committed to the destination. The transmitted file system information block is committed, and updates the overall destination file system by pointing to the changed block structure in the destination, and replacing the previous file system information block. The changes are at this point committed as the latest incremental update of the destination volume snapshot. This file system accurately represents the \u201cnew\u201d snapshot on the source. In time a new \u201cnew\u201d snapshot is created from further incremental changes.","Approaches to volume-based remote mirroring of snapshots are described in detail in commonly owned U.S. patent application Ser. No. 09\/127,497, now issued as U.S. Pat. No. 6,604,118 entitled FILE SYSTEM IMAGE TRANSFER by Steven Kleiman, et al. and U.S. patent application Ser. No. 09\/426,409, now issued as U.S. Pat. No. 6,574,591 entitled FILE SYSTEM IMAGE TRANSFER BETWEEN DISSIMILAR FILE SYSTEMS by Steven Kleiman, et al., both of which patents are expressly incorporated herein by reference.","This volume-based approach to incremental mirroring from a source to a remote storage destination is effective, but may still be inefficient and time-consuming as it forces an entire volume to be scanned for changes and those changes to be transmitted on a block-by-block basis. In other words, the scan focuses on blocks without regard to any underlying information about the files, inodes and data structures, which the blocks comprise. The destination is organized as a set of volumes so a direct volume-by-volume mapping is established between source and destination. Again, where a volume may contain a terabyte or more of information, the block-by-block approach to scanning and comparing changes may still involve significant processor overhead and associated processing time. Often, there may have been only minor changes in a sub-block beneath the root inode block being scanned. Since a list of all blocks in the volume is being examined, however, the fact that many groupings of blocks (files, inode structures, etc.) are unchanged is not considered. In addition, the increasingly large size and scope of a full volume make it highly desirable to sub-divide the data being mirrored into sub-groups, because some groups are more likely to undergo frequent changes, it may be desirable to update their replicas more often than other, less-frequently changed groups. In addition, it may be desirable to mingle original and replicated (snapshotted) sub-groups in a single volume and migrate certain key data to remote locations without migrating an entire volume.","One such sub-organization of a volume is the well-known qtree. Qtrees, as implemented on an exemplary storage system such as described herein, are subtrees in a volume's file system. One key feature of qtrees is that, given a particular qtree, any file or directory in the system can be quickly tested for membership in that qtree, so they serve as a good way to organize the file system into discrete data sets. The use of qtrees as a source and destination for snapshotted data is desirable. Where a number of sub-organizations such as qtrees reside on a volume, it is common to store critical tree attributes\/information in the qtree root directory inode of the tree structure in metadata, that is accessible to the file system. Such information may include security information and various system\/qtree management information. This information can consume significant storage space. Because every inode needs to be set up with similar space, the required size of the root inode governs the size of all inodes. This translates into significant wasted storage space assigned to \u201cordinary\u201d inodes so that the root's needs are satisfied. A more efficient location for storing sub-organization\/qtree metadata information that allows the storage size of root inodes to be reduced is desirable. In addition a metadata location that allows for expansion space for future improvements is also desirable.","However, the use of qtrees, snapshot comparisons and volume implementation specific details on the source of a mirroring\/replication data backup system requires that both the source and destination utilize the same or otherwise compatible file systems. In a modern heterogeneous network environment, the network may comprise of a variety of differing computer architectures including, for example, Windows 2000 computers, various versions of the Unix operating system, Linux or other operating systems. Each of these various operating systems may not support qtrees or other sub-volume characteristics.","It is desirous to provide an incremental backup\/replication system and method that is operating system (OS) and file system (FS) independent. This OS and FS independence will enable the backup system to operate in modern heterogeneous networking environments. As these various operating systems may not support the file system sub-volume characteristics utilized by the storage system acting as a remote backup destination, conventional block-by-block or snapshot comparison techniques may not be utilized.","The disadvantages of the prior art are overcome by providing a system and method for on-the-fly file folding in a replicated storage system. The system and method transfers complete or whole files from a source to a destination. At the destination, a real-time file folding procedure is performed that only generates write operations for disk blocks that would be modified. This reduces substantially the processing and system overhead required in a replicated backup system and enables a destination server to interact with a variety of source systems, including those source systems that utilize file systems differing from that of the destination.","In accordance with the illustrative embodiment, the destination periodically polls the source system for modified files. In response to the polling, a replication agent, executing on the source system, checks for modified files and, if modified files are found, generates a data stream comprising of metadata and the data contained in the modified files to be sent to the destination system. This data stream is then transmitted over a network to the destination. At the destination, an on-the-fly file folding procedure is executed that forms a appropriately sized data blocks from the whole file data from the data stream and compares the data blocks to the blocks stored on disk. In the event that no change has occurred, i.e., the received data block and the block stored on disk are identical, then no write operation occurs. However, should the incoming data stream identify a modified block, the procedure writes the new data block to disk and unlinks the previously written or stored data block from the destination's disk. Thus, in the illustrative embodiment the destination only performs write operations when changed data is received.","A. Network and File Server Environment","By way of further background,  is a schematic block diagram of a storage system environment  that includes a pair of interconnected computers including a source system  and a destination file server  that may be advantageously used with the present invention. For the purposes of this description, the source system is a networked computer that manages storage one or more storage disks . The source system  executes an operating system . The operating system  may be, for example, the commercially available Sun Microsystem's Solaris\u00ae, Microsoft Windows\u00ae 2000, HP\/UX or AIX. The operating system  implements an OS-specific file system on the disks  connected to the source system .","The destination filer  manages one or more destination volumes , comprising arrays of disks . The source and destination are linked via a network  that can comprise a local or wide area network, such as the well-known Internet. An appropriate network adapter  residing the source and destination ,  facilitates communication over the network . As used herein, the term \u201csource\u201d can be broadly defined as a location from which the subject data of this invention travels and the term \u201cdestination\u201d can be defined as the location to which the data travels. While a source system and a destination filer, connected by a network, is a particular example of a source and destination used herein, a source and destination could be computers\/filers linked via a direct link, or via loopback (a \u201cnetworking\u201d arrangement internal to a single computer for transmitting a data stream between local source and local destination), in which case the source and the destination may comprise the same filer.","The destination filer  comprises a processor , a memory , a network adapter  and a storage adapter  interconnected by a system bus . Filer  also includes a storage operating system  () that implements a file system to logically organize the information as a hierarchical structure of directories and files on the disks.","It will be understood to those skilled in the art that the inventive technique described herein may apply to any type of special-purpose computer (e.g., file serving appliance) or general-purpose computer, including a standalone computer, embodied as a storage system. To that end, the filer  can be broadly, and alternatively, referred to as a storage system. Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client\/host computer. The term \u201cstorage system\u201d should, therefore, be taken broadly to include such arrangements.","In the illustrative embodiment, the memory  comprises storage locations that are addressable by the processor and adapters for storing software program code. The memory comprises a form of random access memory (RAM) that is generally cleared by a power cycle or other reboot operation (i.e., it is \u201cvolatile\u201d memory). The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system , portions of which are typically resident in memory and executed by the processing elements, functionally organizes the filer by, inter alia, invoking storage operations in support of a file service implemented by the filer. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the inventive technique described herein.","The network adapter  comprises the mechanical, electrical and signaling circuitry needed to connect the filer  to the network , which may comprise a point-to-point connection or a shared medium, such as a local area network. Moreover the source  may interact with the destination filer  in accordance with a client\/server model of information delivery. That is, the client may request the services of the filer, and the filer may return the results of the services requested by the client, by exchanging packets  encapsulating, e.g., the TCP\/IP protocol or another network protocol format over the network .","The storage adapter  cooperates with the operating system  () executing on the filer to access information requested by the client. The information may be stored on the disks  that are attached, via the storage adapter  to the filer  or other node of a storage system as defined herein. The storage adapter  includes input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, Fibre Channel serial link topology. The information is retrieved by the storage adapter and processed by the processor  as part of the snapshot procedure, to be described below, prior to being forwarded over the system bus  to the network adapter , where the information is formatted into a packet and transmitted to the destination server as also described in detail below.","The filer may also be interconnected with one or more clients  via the network adapter . The clients transmit requests for file service to the filer  respectively, and receive responses to the requests over a LAN or other network (). Data is transferred between the client and the filer  using data packets  defined as an encapsulation of the Common Internet File System (CIFS) protocol or another appropriate protocol, such as NFS.","In one exemplary filer implementation, the filer  can include a non-volatile random access memory (NVRAM)  that provides fault-tolerant backup of data, enabling the integrity of filer transactions to survive a service interruption based upon a power failure, or other fault. The size of the NVRAM depends in part upon its implementation and function in the file server. It is typically sized sufficiently to log a certain time-based chunk of transactions (for example, several seconds worth). The NVRAM is filled, in parallel with the buffer cache, after each client request is completed, but before the result of the request is returned to the requesting client.","In an illustrative embodiment, the disks  are arranged into a plurality of volumes (for example, source volumes  and destination volumes ), in which each volume has a file system associated therewith. The volumes each include one or more disks . In one embodiment, the physical disks  are configured into RAID groups so that some disks store striped data and some disks store separate parity for the data, in accordance with a preferred RAID 4 configuration. However, other configurations (e.g. RAID 5 having distributed parity across stripes) are also contemplated. In this embodiment, a minimum of one parity disk and one data disk is employed. However, a typical implementation may include three data and one parity disk per RAID group, and a multiplicity of RAID groups per volume.","B. Storage Operating System","To facilitate generalized access to the disks , the storage operating system  () implements a write-anywhere file system that logically organizes the information as a hierarchical structure of directories and files on the disks. Each \u201con-disk\u201d file may be implemented as a set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which references to other files and directories are stored. As noted and defined above, in the illustrative embodiment described herein, the storage operating system is the NetApp\u00ae Data ONTAP\u2122 operating system available from Network Appliance, Inc., of Sunnyvale, Calif. that implements the Write Anywhere File Layout (WAFL\u2122) file system. It is expressly contemplated that any appropriate file system can be used, and as such, where the term \u201cWAFL\u201d is employed, it should be taken broadly to refer to any file system that is otherwise adaptable to the teachings of this invention.","The organization of the preferred storage operating system for each of the exemplary filers is now described briefly. However, it is expressly contemplated that the principles of this invention can be implemented using a variety of alternate storage operating system architectures. As shown in , the exemplary storage operating system  comprises a series of software layers, including a media access layer  of network drivers (e.g., an Ethernet driver). The operating system further includes network protocol layers, such as the Internet Protocol (IP) layer  and its supporting transport mechanisms, the Transport Control Protocol (TCP) layer  and the User Datagram Protocol (UDP) layer . A file system protocol layer provides multi-protocol data access and, to that end, includes support for the CIFS protocol , the NFS protocol  and the Hypertext Transfer Protocol (HTTP) protocol . In addition, the storage operating system  includes a disk storage layer  that implements a disk storage protocol, such as a RAID protocol, and a disk driver layer , that implements a disk control protocol such as the small computer system interface (SCSI).","Bridging the disk software layers with the network and file system protocol layers is a file system layer  of the storage operating system . Generally, the layer  implements a file system having an on-disk format representation that is block-based using, e.g., 4-kilobyte (KB) data blocks and using inodes to describe the files. In response to transaction requests, the file system generates operations to load (retrieve) the requested data from volumes if it is not resident \u201cin-core\u201d, i.e., in the filer's memory . If the information is not in memory, the file system layer  indexes into the inode file using the inode number to access an appropriate entry and retrieve a volume block number. The file system layer  then passes the volume block number to the disk storage (RAID) layer , which maps that volume block number to a disk block number and sends the latter to an appropriate driver (for example, an encapsulation of SCSI implemented on a fibre channel disk interconnection) of the disk driver layer . The disk driver accesses the disk block number from volumes and loads the requested data in memory  for processing by the filer . Upon completion of the request, the filer (and storage operating system) returns a reply, e.g., a conventional acknowledgement packet  defined by the CIFS specification, to the client  over the respective network connection .","It should be noted that the software \u201cpath\u201d  through the storage operating system layers described above needed to perform data storage access for the client request received at the filer may alternatively be implemented in hardware or a combination of hardware and software. That is, in an alternate embodiment of the invention, the storage access request data path  may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the file service provided by the filer  in response to a file system request packet  issued by the client .","Overlying the file system layer  is the snapshot mirroring (or replication) application . This application is responsible for the generation of the updated mirror snapshot from received information from the source. The snapshot mirroring application  operates outside of the storage access request path , as shown by the direct links  and  to the TCP\/IP layers ,  and the file system snapshot mechanism ().","In accordance with an embodiment of the present invention, within the snapshot mirroring application  is a block coalescing process  that implements the novel block coalescing function, described further below.","C. Remote Mirroring of Non-File Server Based File Systems","1. Source Processing","In accordance with an illustrative embodiment, the source system must identify and transfer modified files to the destination filer for backup\/replication purposes. In the illustrative embodiment, this procedure is performed by a replication agent  executing on the source system. As noted above, the replication agent may be implemented in a variety of forms including, for example, a daemon, a background process, or as a user-executed backup command.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5","b":["500","505","510","515","505"]},"2. Communication Between Source and Destination","The format of the data stream between the source and destination is described further below. In general, its use is predicated upon having a structure that supports multiple protocol attributes (e.g. Unix permissions, NT access control lists (ACLs), multiple file names, NT streams, file type, file-create\/modify time, etc.). The format should also identity the data in the stream (i.e. the offset location in a file of specific data or whether files have \u201choles\u201d in the file offset that should remain free). The names of files should also be relayed by the format. More generally, the format should also be independent of the underlying network protocol or device (in the case of a tape or local disk\/non-volatile storage) protocol and file system\u2014that is, the information is system \u201cagnostic,\u201d and not bound to a particular operating system software, thereby allowing source and destination systems of different vendors to share the information. The format should, thus, be completely self-describing requiring no information outside the data stream. In this manner a source file directory of a first type can be readily translated into destination file directory of a different type. It should also allow extensibility, in that newer improvements to the source or destination operating system should not affect the compatibility of older versions. In particular, a data set (e.g. a new header) that is not recognized by the operating system should be ignored or dealt with in a predictable manner without triggering a system crash or other unwanted system failure (i.e. the stream is backwards compatible). This format should also enable transmission of a description of the whole file system, or a description of only changed blocks\/information within any file or directory. In addition, the format should generally minimize network and processor overhead required for transferring modified file data.","The format into which source file changes are organized is shown schematically in . In the illustrative embodiment, the format is organized around 4 kilobyte (KB) blocks. The header size and arrangement can be widely varied in alternate embodiments, however. There are 4 KB headers ( in ) that are identified by certain \u201cheader types.\u201d Basic data stream headers (\u201cdata\u201d) are provided for at most every 2 megabytes (MB) of changed data. With reference to , the 4 KB standalone header includes three parts, a 1 KB generic part , a 2 KB non-generic part , and an 1 KB expansion part . The expansion part is not used, but is available for later versions.","The generic part  contains an identifier of header type . Standalone header types (i.e. headers not followed by associated data) can indicate a start of the data stream; an end of part one of the data stream; an end of the data stream; a list of deleted files encapsulated in the header; or the relationship of any NT streamdirs. Later versions of Windows NT allow for multiple NT \u201cstreams\u201d related to particular filenames. A discussion of streams is found in U.S. patent application Ser. No. 09\/891,195, now issued as U.S. Pat. No. 6,446,653 entitled SYSTEM AND METHOD FOR REPRESENTING NAMED DATA STREAMS WITHIN AN ON-DISK STRUCTURE OF A FILE SYSTEM, by Kayuri Patel, et al, the teachings of which are expressly incorporated herein by reference. Also in the generic part  is a checksum  that ensures the header has not been corrupted during the data transfer. In addition other data such as a \u201ccheckpoint\u201d  used by the source and destination to track the progress of replication is provided. By providing a list of header types, the destination can more easily operate in a backwards-compatible mode\u2014that is, a header type that is not recognized by the destination (provided from a newer version of the source) can be more easily ignored, while recognized headers within the limits of the destination version are processed as usual.","In addition, the generic part  includes a flag identifying whether the data to follow are whole files  or not. The whole files flag  is, in the illustrative embodiment, set to a value of TRUE when the data being sent in the data stream comprises whole files instead of only changed blocks. The whole files flag  alerts the destination that it should utilize the teachings of the present invention in file folding the modified files instead of performing the conventional incremental block update procedure.","The kind of data in the non-generic part  of the header  depends on the header type. It could include information relating to file offsets () in the case of the basic header, used for follow-on data transmission, deleted files (in a standalone header listing of such files that are no longer in use on the source or whose generation number has changed) (), or other header-specific information ( to be described below). Again, the various standalone headers are interposed within the data stream format at an appropriate location. Each header is arranged to either reference an included data set (such as deleted files) or follow-on information (such as file data).",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 7","b":["702","604"]},"Next a series of headers and follow-on data in the format define various \u201cpart 1\u201d information (). Significantly, each directory data set being transmitted is preceded by a basic header with no non-generic data. Only directories that have been modified are transmitted, and they need not arrive in a particular order. Note also that the data from any particular directory need not be contiguous. Each directory entry is loaded into a 4 KB block. Any overflow is loaded into a new 4 KB block. Each directory entry is a header followed by one or more names. The entry describes an inode and the directory names to follow. NT stream directories are also transmitted.","The part 1 format information  also provides ACL information for every file that has an associated ACL. By transmitting the ACLs before their associated file data, the destination can set ACLs before file data is written. ACLs are transmitted in a \u201cregular\u201d file format. Deleted file information (described above) is sent with such information included in the non-generic part  of one or more standalone headers (if any). By sending this information in advance, the directory tree builder can differentiate between moves and deletes.","The part 1 format information  may also carry, in alternate embodiments, NT stream directory (streamdir) relationship information. One or more standalone-headers (if any) notifies the destination file server of every changed file or directory that implicates NT streams, regardless of whether the streams have changed. This information is included in the non-generic part  of the header  ().","Finally, the part 1 format information  includes special files for every change in a symlink, named pipe, socket, block device, or character device in the replicated data stream. These files are sent first, because they are needed to assist the destination in building the infrastructure for creation of the replicated file system before it is populated with file data. Special files are, like ACLs, transmitted in the format of regular files.","Once various part 1 information  is transmitted, the format calls for an \u201cend of part 1 of the data stream\u201d header . This is a basic header having no data in the non-generic part . This header tells the destination that part 1 is complete and to now expect file data.","After the part 1 information, the format presents the file and stream data . A basic header  for every 2 MB or less of changed data in a file is provided, followed by the file data  itself. The files comprising the data need not be written in a particular order, nor must the data be contiguous. In addition, referring to the header in , the basic header includes a block numbers data structure , associated with the non-generic part  works in conjunction with the \u201choles array\u201d  within (in this example) the generic part . The holes array denotes empty space. This structure, in essence, provides the mapping from the holes array to corresponding blocks in the file. This structure instructs the destination where to write data blocks or holes.","In general files () are written in 4 KB chunks with basic headers at every 512 chunks (2 MB), at most. Likewise, streams (also ) are transmitted like regular files in 4 KB chunks with at most 2 MB between headers.","Finally, the end of the replicated data stream format  is marked by a footer  consisting of standalone header of the type \u201cend of data stream.\u201d This header has no specific data in its non-generic part  ().","3. Destination","When the remote destination receives the formatted data stream from the source via the network, it creates a new file or modifies an existing mirrored file (or another appropriate organizational structure) and fills it with changed data.","In accordance with the illustrative embodiment, the destination performs a file folding technique to reduce the amount of disk space occupied and to reduce the number of write operations that must occur. This increases both the amount of usable disk space and improves system performance by reducing the need for unnecessary write operations. This file folding procedure  is shown in a flow chart in . The procedure begins in step  and proceeds to step  where the procedure checks the whole files flag in the header of the beginning of a transmission. The procedure then, in decision block , decides if the whole files flag is set. If it is not set, the procedure branches to step  where it performs the conventional snapshot block-by-block update as described in the above-incorporated patent application. However, if the whole files flag is set, the procedure continues to step  where the whole file data is placed in a queue for later processing.","The destination continuously reads data blocks from the queue in step . In the illustrative embodiment, these data blocks will be four kilobyte (KB) blocks that correspond to the blocks of the file system associated with the destination file server. In alternate embodiments, these data blocks may be of varying sizes to correspond to the appropriate sized blocks of the destination file server. The procedure then, in step , compares the received input data block with its corresponding block stored on the remote destination file server. In decision block  a determination is made whether the data matches from that received from the source and the data stored on the destination. If the data does not match, the procedure then branches to step , where the data block that was received is written to the destination and the data block that was previously stored in the destination is released. Thus, the new file will no longer contain pointers to the previously stored data block but will include pointers to the newly written data block that contains changed information. After the data block has been written to the destination, the procedure continues to step . Similarly, should the blocks match in step , which indicates that no changes occurred to that data block, the procedure will also proceed to step  with no write operation occurring. In step  a determination is made if there are more blocks to be read in the queue. If no more blocks are to be read in the queue, the transfer is complete () and appropriate clean up operations occur. However, if additional blocks are to be read, the procedure loops back to step  and reads an additional data block from the queue.","In the illustrative embodiment, a file is represented in the exemplary destination file system as an inode data structure adapted for storage on disks.  is a schematic block diagram illustrating an inode , which preferably includes a metadata section  and a data section . The information stored in the metadata section  of each inode  describes the file and, as such, includes the type (e.g., regular or directory)  of file, the size  of the file, time stamps (e.g., creation, access and\/or modification)  for the file and ownership, i.e., user identifier (UID ) and group ID (GID ), of the file. The contents of the data section  of each inode, however, may be interpreted differently depending upon the type of file (inode) defined within the type field . For ex-ample, the data section  of a directory inode contains metadata controlled by the file system, whereas the data section of a regular inode contains user-defined data. In this latter case, the data section  includes a representation of the data associated with the file.","Specifically, the data section  of a regular on-disk inode may include user data or pointers, the latter referencing 4 KB data blocks on disk used to store the user data. Each pointer is preferably a logical VBN to thereby facilitate efficiency among the file system and the disk storage (RAID) layer when accessing the data on disks. Given the restricted size (e.g., 128 bytes) of the inode, user data having a size that is less than or equal to 64 bytes is represented, in its entirety, within the data section of that inode. However, if the user data is greater than 64 bytes but less than or equal to 64 KB, then the data section of the inode (e.g., a first level inode) comprises up to 16 pointers, each of which references a 4 KB block of data on the disk.","Moreover, if the size of the data is greater than 64 KB but less than or equal to 64 megabytes (MB), then each pointer in the data section  of the inode (e.g., a level 2 inode) references an indirect block (e.g., a level 1 block) that contains 1024 pointers, each of which references a 4 KB data block (e.g., a level 0 block) on disk. For user data having a size greater than 64 MB, each pointer in the data section  of the inode (e.g., a third level inode) references a double-indirect block (e.g., a level 2 block) that contains 1024 pointers, each referencing an indirect, level 1 block. The indirect block, in turn, contains 1024 pointers, each of which references a 4 KB direct level 0 data block on disk. Each data block is loaded from disk into the buffer cache in order to access the data.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 10","b":["1000","900","1002","1005","1004","1002"]},"Thus, in operation, the present invention may have a stored copy of a file, represented by file , stored at the destination. When the incoming data stream is received by the destination, the system and method will progress through the various data blocks  -and compare the stored data blocks to the data blocks received from the input data stream. For example, the first received data block would be compared against data block , the second against data block , etc.","To again summarize, the system and method of the present invention enables on-the-fly file folding to reduce the number of write operations in a file system. In the illustrative embodiment, the on-the-fly file folding is implemented at a destination of a replicated storage system. A replication agent, executing on the source system, identifies, in response to polling from the destination, modified files and transmits the modified files in a data stream to the destination. On the destination side, the input data stream is parsed and individual data blocks are taken from the modified files that are being transmitted. These received data blocks are then compared against its corresponding data block stored on the destination. If the received data block and the destination data block are identical then no write operation occurs. However, should the received data block differ from the stored data block, then the received data block is written to disk and the appropriate pointers in indirect blocks and inodes are updated to point to the newly written data block. In the illustrative embodiment, the file system utilizes a WAFL file system cover which eliminates the need to overwrite the previously written block as the newly written data block may be written any place on the disk's surface that is free.","The foregoing has been a detail description of illustrative embodiments of the invention. Various modifications and additions can be made without departing form the spirit and scope of the invention. For example, the number of interconnected source and\/or destination computers depicted can be varied. In fact, the source and destination servers can be the same machine. It is expressly contemplated that a plurality of sources can transfer data to a destination and vice versa. Likewise, the internal architecture of the servers or their respective storage arrays, as well as their network connectivity and protocols, are all highly variable. The operating systems used on various source and destination servers can differ. More generally, the teachings of the present invention may be utilized with reference to any data container embodied in a storage system having an active store and one or more reference stores. The term data container generally refers to a unit of storage for holding data, such as a file, a volume or a logical unit number (LUN), which is addressable by, e.g., its own unique identification. Thus, while the illustrative embodiment is written with reference to files contained within a file system, the teachings of the present invention may be implemented using any data container, including, for example, a volume. In addition, it is expressly contemplated that any of the operations and procedures described herein can be implemented using hardware, software comprising a computer-readable medium having program instructions executing on a computer, or a combination of hardware and software."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
