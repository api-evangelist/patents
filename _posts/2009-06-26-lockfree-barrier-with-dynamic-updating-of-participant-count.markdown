---
title: Lock-free barrier with dynamic updating of participant count
abstract: A method of executing an algorithm in a parallel manner using a plurality of concurrent threads includes generating a lock-free barrier that includes a variable that stores both a total participants count and a current participants count. The total participants count indicates a total number of threads in the plurality of concurrent threads that are participating in a current phase of the algorithm, and the current participants count indicates a total number of threads in the plurality of concurrent threads that have completed the current phase. The barrier blocks the threads that have completed the current phase. The total participants count is dynamically updated during execution of the current phase of the algorithm. The generating, blocking, and dynamically updating are performed by at least one processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924984&OS=08924984&RS=08924984
owner: Microsoft Corporation
number: 08924984
owner_city: Redmond
owner_country: US
publication_date: 20090626
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","PSEUDO CODE EXAMPLE I"],"p":["Software programs have been written to run sequentially since the beginning days of software development. Steadily over time, computers have become much more powerful, with more processing power and memory to handle advanced operations. This trend has recently shifted away from ever-increasing single-processor clock rates towards an increase in the number of processors available in a single computer resulting in a corresponding shift away from sequential execution toward parallel execution. Software developers want to take advantage of improvements in computer processing power to enable their software programs to run faster as new hardware is adopted. With parallel hardware, software developers arrange for one or more tasks of a particular software program to be executed in parallel (also referred to as concurrently), so that, for example, the same logical operation can utilize many processors at one time to thereby deliver better performance as more processors are added to the computers on which such software runs.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A barrier is a type that blocks all threads that have reached the end of a phase until a specified number of threads have reached the end of the phase, and then atomically releases these blocked threads. A barrier can be used to help multiple concurrent threads cooperatively work on an algorithm in parallel.","One embodiment provides a method of executing an algorithm in a parallel manner using a plurality of concurrent threads. A lock-free barrier is generated that includes a variable that stores both a total participants count and a current participants count. The total participants count indicates a total number of the threads that are participating in a current phase of the algorithm, and the current participants count indicates a total number of the threads that have completed the current phase. The barrier blocks the threads that have completed the current phase. The total participants count is dynamically updated during execution of the current phase of the algorithm.","In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.","One embodiment provides a lock-free barrier application with dynamic updating of participant counts, but the technologies and techniques described herein also serve other purposes in addition to these. In one implementation, one or more of the techniques described herein can be implemented as features within a framework program such as Microsoft\u00ae.NET Framework, or within any other type of program or service.","A barrier can be used to help multiple participants (e.g., threads) cooperatively work on an algorithm in parallel. Computations that use barriers are typically called phased computations. Algorithms that use barriers are typically divided into separate phases, which are sometimes cyclic, and each participating thread waits for all of the participating threads to reach the end of the current phase before moving to the next phase. A barrier according to one embodiment is a type that blocks all threads that reach the end of a phase until a specified number of threads have reached the end of the phase, and then atomically releases these threads. A barrier according to one embodiment may be defined as a synchronization primitive that enforces the stopping of execution between a number of threads or processors at a given point and prevents further execution until all threads or processors have reached the given point.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","100","102","104","104"]},"Computing device  may also have additional features\/functionality. For example, computing device  may also include additional non-transitory storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media includes volatile and nonvolatile, non-transitory removable and non -removable media implemented in any suitable method or technology for non-transitory storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage  and non-removable storage  are all examples of computer storage media (e.g., non-transitory computer-readable storage media storing computer-executable instructions for performing a method). Computer storage media includes RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices. Any such non-transitory computer storage media may be part of computing device .","Computing device  includes one or more communication connections  that allow computing device  to communicate with other computers\/applications . Computing device  may also include input device(s) , such as keyboard, pointing device (e.g., mouse), pen, voice input device, touch input device, etc. Computing device  may also include output device(s) , such as a display, speakers, printer, etc.","In one embodiment, computing device  includes a lock-free barrier application . Lock-free barrier application  is described in further detail below with reference to .",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","100","200","100","200","200","104","115"]},"Lock-free barrier application  includes program logic , which is responsible for carrying out some or all of the techniques described herein. Program logic  includes logic  for constructing a lock-free barrier; logic  for dynamically updating a total participants count of the barrier; logic  for signaling and waiting for threads; logic  for dynamically adding threads to the barrier; logic  for dynamically removing threads from the barrier; logic  for tracking whether a current phase of an algorithm being executed by concurrent threads is even or odd; and other logic  for operating the application.","Turning now to , techniques for implementing one or more embodiments of lock-free barrier application  are described in further detail. In some implementations, the techniques illustrated in  are at least partially implemented in the operating logic of computing device .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["300","300","302","304","306","308","316","318","320","308","310","312","314","0","14","308","312","300","15","308","16","30","308","310","31","308","314","300","308","300","316","318","320"]},"The signal and wait method  is called by each thread when the thread reaches the end of a phase to indicate its arrival to the other threads. The signal and wait method  compares the current participants count  and the total participants count  (to determine if this is the last remaining thread to arrive), and updates the current participants count . The add participants method  is called to add one or more threads to the barrier  and increase the total participants count  accordingly. The remove participants method  is called to remove one or more threads from the barrier  and decrease the total participants count  accordingly. The lock-free barrier  according to one embodiment supports dynamic updating of the total participants count , so the total participants count  can be changed (e.g., increased or decreased) at any given time after the barrier object is created. In one embodiment, the signal and wait method , the add participants method , and the remove participants method  are each configured to update the current total count variable  using a single CAS operation (e.g., Interlocked.CompareExchange).","In one embodiment, the current phase variable  is a 32-bit integer variable that stores a value representing the current phase. The odd event synchronization object  and the even event synchronization object  according to one embodiment are each ManualResetEventSlim synchronization objects. A ManualResetEventSlim synchronization object is an event that allows threads to wait on it, and supports event functionalities such as Set, Reset, and Wait. For example, when a thread begins an activity that is to be completed before other threads proceed, the thread calls Reset to put ManualResetEventSlim in a non-signaled state. Threads that call Wait on the ManualResetEventSlim will block and wait for a signal. When a thread calls Set on the ManualResetEventSlim, the blocked threads are signaled and released.","In one embodiment, barrier  is implemented with a class that has public application programming interfaces (APIs) as shown in the following Pseudo Code Example I:",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class Barrier : IDisposable"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/** Constructors **\/"},{"entry":"\u2003\u2003public Barrier(Int32 participantCount);"},{"entry":"\u2003\u2003public Barrier(Int32 participantCount, Action<Barrier>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003postPhaseAction);"},{"entry":"\u2003\u2003\/** Methods **\/"},{"entry":"\u2003\u2003public Int32 AddParticipant( );"},{"entry":"\u2003\u2003public Int32 AddParticipants(Int32 participantCount);"},{"entry":"\u2003\u2003public void RemoveParticipant( );"},{"entry":"\u2003\u2003public void RemoveParticipants(Int32 participantCount);"},{"entry":"\u2003\u2003public void SignalAndWait( );"},{"entry":"\u2003\u2003public void SignalAndWait(CancellationToken cancellationToken);"},{"entry":"\u2003\u2003public Boolean SignalAndWait(Int32 millisecondsTimeout);"},{"entry":"\u2003\u2003public Boolean SignalAndWait(TimeSpan timeout);"},{"entry":"\u2003\u2003public Boolean SignalAndWait(Int32 millisecondsTimeout,"},{"entry":"CancellationToken cancellationToken);"},{"entry":"\u2003\u2003public void Dispose( );"},{"entry":"\u2003\u2003protected virtual void Dispose(Boolean disposing);"},{"entry":"\u2003\u2003\/** Properties **\/"},{"entry":"\u2003\u2003public Int32 ParticipantsRemaining { get; }"},{"entry":"\u2003\u2003public Int32 ParticipantCount { get; }"},{"entry":"\u2003\u2003public Int32 CurrentPhaseNumber { get; }"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["302","402","302","404","310","312","404","310","312","302","406","406","310","408","318","320","314","314","318","408","314","320","408"]},"If it is determined at  that the current participants count  plus one equals the total participants count , which indicates that the arrival thread is the final thread, the method  moves to . At , the arrival thread sets the current participants count  to zero and reverses the sense flag . At , the arrival thread calls a post phase action (e.g., set by the caller in the barrier constructor). At , the arrival thread increments the current phase variable  by one. At , the arrival thread sets the event  or  representing the current phase, thereby signaling all of the blocked threads, and resets the event  or  representing the next phase. For example, if the current sense flag  indicates that the current phase is odd, the arrival thread would set the odd event  and reset the even event , and if the current sense flag  indicates that the current phase is even, the arrival thread would set the even event  and reset the odd event .","In one embodiment of method , a blocked thread will awaken when the final arrival thread sets the event  or  representing the current phase at  in method , or when a timeout expires. As indicated at  in method , when a timeout of a blocked thread expires, the thread awakens and checks the current sense flag  and potentially decrements the current participants count . In one embodiment, if the state of the current sense flag  does not match the observed state before blocking, this indicates that the current phase has just finished and true is returned, otherwise the current participants count  is decremented by one and false is returned.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5","b":["304","502","304","316","314","312","504","312","312","312","506","316","314","506","316","314","304","514","516"]},"If it is determined at  that the current phase variable  and the current sense flag  do not match, the method  moves to , which indicates that the current phase is finished, but post phase action is being executed and the current phase variable  has not been updated yet. At , the event  or  for the current phase is selected, which is opposite to the current sense flag , and the threads to be added wait on it. At , the current phase is completely finished, and the threads to be added join the next phase.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6","b":["306","602","306","312","312","312","604","312","310","604","312","310","306","606","312","310"]},"If it is determined at  that the total participants count  is not less than the current participants count , the method  moves to , where it is determined whether the total participants count  (after decrementing at ) is equal to the current participants count . If it is determined at  that the total participants count  is equal to the current participants count , the method  moves to , which indicates that the current phase is finished. In one embodiment, finishing of the current phase at  involves setting the current participants count  to zero, flipping the current sense flag , and setting and resetting the events  and  based on the current sense flag . If it is determined at  that the total participants count  is not equal to the current participants count , the method  moves to , which indicates that the current phase is continued.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 7","b":["700","702","300","308","312","310","312","310","704","706","312","308"]},"In one embodiment, the barrier  in method  is a sense-reversing barrier that tracks whether the current phase is odd or even, and the variable  in method  is a thirty-two bit integer variable that also stores a flag  for indicating whether the current phase is an odd phase or an even phase. The barrier  in method  according to one embodiment includes a signal and wait method  configured to be called by each thread that completes the current phase to indicate its completion to other threads, and configured to cause each thread that completes the current phase to wait for all threads to complete the current phase.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 8","b":["800","802","300","308","312","310","312","310","804","806","808","806","806","810","812","814","816","312","818","312","310","820","818"]},"Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated, as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
