---
title: Managing XPath expressions in a database system
abstract: First data that represents a level associated with an element within an expression, such as an XPath expression, is generated from the expression, and stored in one or more columns of a table. Second data that represents a condition on an attribute of the element is generated from the expression, and stored in one or more columns of the same or a different table. A plurality of expressions can be processed as such, and a determination made whether any of the expressions match with a given hierarchical data item, such as an XML document, that includes a value that corresponds to an attribute that is associated with an element that resides at a particular level within the data item. Such determination is made based on whether the particular level matches the first data and the value satisfies the second data associated with a given expression.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07107282&OS=07107282&RS=07107282
owner: Oracle International Corporation
number: 07107282
owner_city: Redwood Shores
owner_country: US
publication_date: 20030212
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","Filtering Expression Sets","XPath Expressions","DETAILED DESCRIPTION","Overview","Managing Expressions in a Database System","Pre-Processing a Set of Expressions","XPath Expression Filter","XPath Expression Filter Index","Indexing XPath Expression Predicates","Example Predicate Table","Predicate Evaluation","Hardware Overview","Extensions and Alternatives","APPENDIX A"],"p":["This application is a continuation-in-part application and claims the benefit of domestic priority under 35 U.S.C. \u00a7120 from U.S. patent application Ser. No. 10\/254,383 entitled \u201cManaging Expressions In A Database System,\u201d filed on Sep. 24, 2002; and claims the benefit of domestic priority under 35 U.S.C. \u00a7119(e) from U.S. Provisional Patent Application No. 60\/378,018 entitled \u201cManaging Expressions In A Database System,\u201d filed on May 10, 2002; and is related to U.S. Pat. No. 6,502,093 issued Dec. 31, 2002, and U.S. Pat. No. 6,405,191 issued Jun. 11, 2002; all of which are incorporated by reference in their entirety for all purposes, as if fully set forth herein.","The present invention relates generally to database management systems and, more specifically, to techniques for managing conditional expressions in database systems.","In the context of event and content-based subscription systems, events are defined which, when met, trigger an action. For example, a subscriber can define rules in the form of expressions that specify a state of content that, when met, trigger transmission of content to the subscriber. Using a database management system as an underlying engine for an event-based subscription system, a subscriber can register queries with the system that represent conditional expressions on the content of the events. Generally in this context, an event refers to some quantifiable set of information and the expressions are related to the content of such document. In such a subscription or similarly functioning system, a potentially very large set of queries, i.e., an expression set on the content, are registered to manage the publication of desired content data. When a given data item becomes available, these conditional expressions are filtered to find those expressions that match the given data item. The data for which the expressions are filtered could be, for example, a set of name-value pairs, an XML (Extensible Markup Language) document, or a combination of both.","A simple but inefficient approach to the task of filtering expression sets is to test all of the expressions in a given set for each data item. However, this approach is scalable neither for a large set of expressions nor for a high rate of events. Therefore, most commercial systems pre-process the expression set and create in-memory matching networks (i.e., specialized data structures) that group matching predicates in the expression set and share the processing cost across multiple expressions.","Matching networks rely on the fact that a conditional expression on scalar data can be decomposed into independent predicates and a decision tree can be constructed by assigning each predicate to a node in the tree. Thus, matching networks are decision trees in which each node represents a predicate group in a given expression set. Data flows from a parent node to its children only if the data evaluates to true for the predicate representing the parent node. A path from the root of the decision tree to a leaf node represents all the conjunctions in an expression. The leaf nodes in the tree are labeled with expression identifiers and if a data item passes the predicate test on a leaf node, the corresponding expressions are considered true for that data item. Many variants of the matching networks (like RETE, TREAT and Gator networks) are in use for existing systems.","In existing systems, any operation requiring filtering of expressions and related information requires significant custom coding and reduces performance characteristics. Furthermore, the number of expressions is limited in size as the corresponding matching networks must fit in main-memory, changes in expressions are costly, and users are unable to adjust filtering strategies to the structure and use of the expressions and related data.","XPath is a language for addressing XML documents. XPath also provides basic facilities for manipulation of strings, numbers and booleans. XPath uses a compact, non-XML syntax to facilitate use of XPath within URIs and XML attribute values. XPath operates on the abstract, logical structure of an XML document, rather than its surface syntax. XPath gets its name from its use of a path notation as in URLs for navigating through the hierarchical structure of an XML document.","XPath models an XML document as a tree of nodes. There are different types of nodes, including element nodes, attribute nodes and text nodes. The XPath data model is described in detail in Section 5 (\u201cData Model\u201d) of \u201cXML Path Language (XPath)\u201d (version 1.0), a W3C (World Wide Web Consortium) Recommendation dated 16 Nov. 1999.","The primary syntactic construct in XPath is the expression, which is evaluated to yield an object. XPath expressions are described in Section 3 (\u201cExpressions\u201d) of \u201cXML Path Language (XPath)\u201d (version 1.0). One important kind of expression is a location path. A location path selects a set of nodes relative to a context node. The result of evaluating an expression that is a location path is the node-set containing the nodes selected by the location path. Location paths can recursively contain expressions that are used to filter sets of nodes. The semantics of location paths are described in Section 2 (\u201cLocation Paths\u201d) of \u201cXML Path Language (XPath)\u201d (version 1.0).","In the case of content-based subscription systems, the techniques used for constructing decision trees for expressions on non-XML data are not accurately applicable to XPath expressions defined on XML data. In the absence of an efficient evaluation engine, each XPath expression has to be tested on each XML data item separately to determine whether it evaluates to true or not. However, this approach also is not scalable for a large set of expressions or for a high rate of events.","One approach to grouping a large set of XPath expressions defined for expected XML data and for sharing the evaluation costs across multiple expressions is described in \u201cEfficient Filtering of XML Documents for Selective Dissemination of Information\u201d (Mehmet Altinel and Michael J. Franklin; Proceedings of the 26VLDB Conference, Cairo, Egypt, 2000), in which in-memory finite state machines are built for each XPath expression.","To build such a finite state machine, each XPath expression is decomposed into a set of path nodes that correspond to elements in an XML document, which serve as states in the state machine. The state information also includes the relative and\/or absolute level of the path node (element) within the XML document. A hash index is built on a set of states corresponding to multiple XPath expressions using the element name as the hash key. For each hash key, the states are maintained as one or more linked lists. In order to match an XML document for a set of XPath expressions, a document parser looks up the element name in the hash index every time a new element is encountered and a list of corresponding nodes are checked for a match with respect to the level of the element. For each node that succeeds the check, the next node in the corresponding state machine is activated. If the node that succeeded the check is a last node in a state machine for an XPath expression, then the expression is considered a match for the XML document.","The evaluation techniques used in the preceding approach rely on the level of the elements in the XML document and not on any predicates on the attributes in the elements. Therefore, any predicates on one or more attributes of an element are checked linearly when the node for the corresponding element is active in the state machine. Hence, for a large set of XPath expressions that differ from each other only in the predicate on the attribute, this approach is equivalent to evaluating each XPath expression on the XML document linearly. For example, two XPath expressions, \/PUBLICATION\/AUTHOR[@name=\u201cSCOTT\u201d] and \/PUBLICATION\/AUTHOR[@name=\u201cANDY\u201d], are grouped only based on <publication> and <author> elements and the predicate on the \u2018name\u2019 attribute is checked linearly for both the expressions.","Due to the extensive use of main memory and many data movement operations during evaluation, this technique may not scale well. Also, the existence of element node filters that contain path expressions, i.e., an XPath expression nested within an attribute predicate of an XPath expression, further complicates the prior evaluation process.","Based on the foregoing, it is clearly desirable to provide an improved mechanism for managing expressions, such as XPath expressions, in a database system. In addition, there is a need for a mechanism that provides the ability to filter XPath expressions in conjunction with predicates on non-XML data.","A method and system are described for managing expressions in a database system. In addition, and more specifically, methods and systems are described for managing XPath expressions in a database system.","In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","Conditional expressions on hierarchically structured information are often presented in a path format in which an element of interest within the information is identified, and a value of interest associated with an attribute of the element is identified. Such expressions can be applied to the hierarchical information to determine whether matches between the expressions and the information exist. For example, XPath expressions can be used to establish conditional predicates in relation to an XML document.","According to one embodiment, a specialized filter is built on a set of expressions, which are stored in a data table. The specialized filter is used to filter the relatively large set of expressions to identify particular expressions that are relevant to a given data item. Further, such a filter is used as an index into another table that associates expressions with owners or users of such expressions, thus identifying owners of expressions that match a given data item so that the data item can be served to interested owners.","In an embodiment, first data that represents a level associated with an element within an expression is generated from the expression, and stored in one or more columns of a table. Second data that represents a condition on an attribute of the element is generated from the expression, and stored in one or more columns of the same or a different table. If the first and second data are stored in the same table, then according to an embodiment, a bitmap index is generated for the columns storing the first and second data. A plurality of expressions can be processed in this manner. A determination is made whether any of the expressions match with a given hierarchical data item that includes a value that corresponds to an attribute that is associated with an element that resides at a particular level within the data item. Such determination is made based on whether the particular level matches the first data and the value satisfies the second data associated with a given expression. Determination of a match between the particular level and the first data can occur upon the particular level having a particular logical relationship to the level represented by the first data, such as being greater than or equal to (i.e., \u2267) the level represented by the first data.","Typically, in event and content-based subscription systems, a set of expressions or rules (e.g., Event-Condition-Action (ECA) rules) is defined for an event structure or context, and the structure of the event determines the elementary attributes that can be used in the expressions. The term \u201cevent\u201d is used in this context to refer to the data item for which expressions, or \u201cconditions\u201d, are evaluated. For example, an event, in the context of stock trading, might be a publicly-traded stock attaining a particular price, which is represented as a data item. Thus, elementary attributes of expressions associated with such an event could include, for example, SYMBOL, PRICE, and CHANGE. For another example, an event might be information embodied in a hierarchical data item, such as an XML document, or the arrival of such a data item. An ECA rule lies dormant until it is triggered by the occurrence of an Event.","A set of expressions defined for an event structure or context is called an expression set. For example, Subscriber A may be interested in an event expressed as SYMBOL=ORCL, PRICE>30, and CHANGE>5; Subscriber B may be interested in an event expressed as SYMBOL=CSCO, and PRICE>25; and Subscriber C may be interested in an event expressed as SYMBOL=INTC, and CHANGE\/PRICE>0.1.","In a typical system based on rules, efficient filtering of a large set of conditional expressions is critical for the scalability of the system. Unlike a typical database design, where a few queries are executed on a large set of rows in a table, a rules-based system has a large number of expressions (similar to WHERE clause of a query) operating against a single data item.","The expressions defined for a given application are relatively static and the rate at which the new data should be processed against these expressions is high. Therefore, according to one aspect, pre-processing of the expressions is performed to build specialized data structures and data access mechanisms such as indexes, to allow fast filtering with a new data item.","Non-XML Expressions","Given a large number of non-XML conditional expressions in a system, the expressions tend to have similarities at the elementary predicates level. That is, two expressions, each with one or more elementary predicates joined by conjunctions, may have a common predicate. Thus, expression evaluation costs are shared among multiple expressions, thereby leveraging the foregoing similarities. In an embodiment, a library of functions, the Expression Type Library, supports the pre-processing of a set of expressions.","The Expression Type Library includes routines that provide the basic functionality required for building a matching network for non-XML expressions. The routines in this library are supplied as a set of Java classes which are capable of converting an expression string into an expression tree containing elementary predicates, joined by conjunctions and disjunctions. This library can be used by any indexing scheme for pre-processing the expressions in an expression set and during incremental modifications to these expressions.","This library includes routines for parsing the non-XML expressions and processing them as follows:","(1) Normalize the non-XML expression, for example, by rearranging the predicates in an expression to rewrite it in a disjunctive normal form (DNF), that is, an OR list of AND sub-clauses. For example, an expression of form\n\nSYMBOL=\u2018\u2019 and (PRICE<25 or PRICE>35)\n\nis rewritten as follows after a DNF conversion:\n\n(SYMBOL=\u2018\u2019 and PRICE<25) or (SYMBOL=\u2018GE\u2019 and PRICE>35).\n","(2) Normalize the predicates, by rewriting each predicate in a non-XML expression such that it has a pure constant on the right-hand side. For example, a predicate of form\n\nPRICE>27+CHANGE\n\nis rewritten as:\n\nPRICE\u2212CHANGE>27\n","(3) Decode the predicate, by resolving it as follows:","left-hand side (LHS): an expression or a function of one or more attributes (e.g., PRICE\u2212CHANGE from the predicate PRICE\u2212CHANGE>27);","right-hand side (RHS): a constant (e.g., the \u201c27\u201d from the predicate PRICE\u2212CHANGE>27); and","relational operator: the relational operator joining the LHS and RHS (e.g., the \u201c>\u201d from the predicate PRICE\u2212CHANGE>27).","The left-hand side of a predicate, for example, the attribute SYMBOL, is also referred to as a complex attribute. It could also be a sub-expression involving one or more elementary attributes or user-defined functions, for example, CHANGE\/PRICE. The operators of a predicate are mapped to a predetermined integer value, however, embodiments are not limited to such a mapping. The mapped operators and associated predicate constants (RHS) are stored in a predicate table.","An attribute set that captures the event structure or context is created. The attribute set has a list of elementary attributes used in a non-XML expression set, and their data types. In its simplest form, the attribute set resembles an abstract type definition in the database.","The non-XML expression set is stored in a column of a table. For example, expressions can be stored in a VARCHAR2 or a CLOB column in a database table. Such a column can be recognized as a column of EXPRESSION data type by, for example, associating some expression set metadata to the column. Furthermore, the column storing the non-XML expression set is associated with the attribute set created for the expression set.","A VARCHAR2 or a CLOB column associated with an attribute set constitutes an EXPRESSION column. The values stored in an EXPRESSION column are treated as expressions and they are initially expected to adhere to SQL-WHERE clause format. These expressions can use all the attributes defined in the attribute set along with any system variables and user-defined functions that are valid in the user environment.","XPath Expressions","SQL-WHERE clause expressions may contain XPath predicates on one or more elementary attributes for an event structure. In one commercial database implementation, an XMLType data type is used to create the elementary attributes for an event structure. Furthermore, the XPath predicates on these attributes are specified using the operators supplied with the XMLType attribute.","For example, in an event structure that includes definition of a \u201cresume\u201d attribute of XMLType or similar data type (hereinafter referred to as XMLType), XPath predicates on this attribute are specified in SQL-WHERE clause format as follows:\n\n","In general, the existsNode ( ) function returns true if the input document contains a node specified by the XPath expression supplied to the function. The extract ( ) function is often used when the XPath expression will result in a collection of nodes being returned, with the results of the function being either a document or a document fragment.","By allowing XPath predicates in SQL-WHERE clauses, embodiments support multiple XPath predicates as well as predicates on non-XML data and XML data in the same expression. An example is as follows:\n\n","A set of expressions defined on a common event structure can be stored in a database table in a column of VARCHAR2 or CLOB data type, for example. Refer to U.S. patent application Ser. No. 10\/254,383 entitled \u201cManaging Expressions In A Database System\u201d for a description of one method for storing a set of expressions as data in a database table. Expressions in an expression set can then be evaluated for a data item with the use of standard SQL syntax, for example, as follows:\n\n","Typically, the left-hand-sides of XPath predicates contain XPath expressions as an argument to the existNode( ) or extract( ) operators. Due to the nature of XPath expressions, these left-hand-sides are quite unique and, unlike in the case of non-XML predicates described above, XPath predicates may not be grouped efficiently. For example, a large number of unique XPath expressions are possible with a small number of XML elements\/nodes in an XML document. Thus, when predicates are grouped based on common left-hand-sides, a large number of groups are possible due to differences in the XPath expressions. Furthermore, there is a practical limit to the number of attributes that can be stored and indexed in a predicate table, thus not all of the unique left-hand-sides can be stored efficiently. Still further, processing cost is not shared across multiple predicates with partially matching XPath expressions. Hence, according to an aspect of the invention, a unique index can be configured for XPath expressions and associated predicates. The index is referred to herein as an \u201cExpression Filter\u201d index, and is described in detail below.","XPath expressions can appear in SQL-WHERE clauses along with other scalar predicates, such as A=10, B>20, and the like. In general and according to an aspect of the invention, the XPath expressions defined on a particular XMLType attribute are grouped together in a predicate table. Filtering parameters for the XMLType attribute can be set by recognizing some of the commonly appearing, or distinguishing, XML tags (i.e., XML Elements and XML Attributes) in the XPath expression set. These common XML tags can be configured to act as positional filters or value-based filters, as described in more detail below. Thus, for a set of XPath expressions, the positions of all the tags configured as positional filters and the constants appearing for all the predicates involving tags configured as value-based filters are determined and these positions and values are applied to an XML document, as described in more detail below.","In general, in order to create a specialized filter (sometimes referred to herein as an index) for XPath expressions, a user should identify the XMLType elementary attribute for which the XPath expressions are expected and a list of common XML elements and XML attributes expected in the expression set. In relation to the example above, the \u201cresume\u201d XMLType may be identified as an elementary attribute for which expressions are expected, \u201cEDUCATION\u201d may be identified as a common XML element associated with the \u201cresume\u201d XMLType, and \u201cdegree\u201d may be identified as a common XML attribute associated with the \u201cEDUCATION\u201d element.","Tags in XPath expressions are in one of three categories: (1) XML Elements with simple types; (2) XML Elements with complex types; and (3) XML Attributes (with simple types). For a typical XPath expression set, this information is available from the XML schema corresponding to the expression set.","For an XPath filter, the XML elements and XML attributes are in one of three categories: (1) XML elements with complex types, or simple types that cannot be mapped to database types VARCHAR2, NUMBER, or DATE; (2) XML elements and attributes with simple types that can be mapped to database types VARCHAR2, NUMBER, or DATE; and (3) all other XML elements and attributes, including attributes with types that do not map to simple database types. Within an XPath Expression Filter, according to one embodiment, the XML tags that fall in category 1 are used as positional filters and the tags that fall in category 2 are used as value filters. The filtering based on the remainder of the tags is performed during a separate predicate evaluation phase, wherein they are evaluated linearly with respect to a given set of information. Refer to U.S. patent application Ser. No. 10\/254,383 entitled \u201cManaging Expressions In A Database System\u201d for a description of one method for evaluating what are referred to as sparse predicates.",{"@attributes":{"id":"p-0054","num":"0061"},"figref":["FIG. 1","FIG. 1"]},"At block , an attribute set for the expression set is created. An attribute set is created in an attempt to capture the event structure or context. The attribute set has a list of elementary attributes used in an expression set, and their data types. For example, an attribute set for an expression set relating to the \u201cresume\u201d XMLType might include attributes such as \u201cdegree,\u201d \u201ccollege\u201d, \u201chonors,\u201d and the like. In its simplest form, the attribute set resembles an abstract type definition in the database. One non-limiting technique for creating an attribute set is expressed in Statement 1 of Appendix A.","At block , default index parameters are assigned for the attributes that do not involve attributes with XMLType datatype. For example, the default parameters preferably represent common left-hand sides of predicates from the expression set and their associated common operators. For example, \u201csource\u201d may be a common left-hand side and \u201c=\u201d may be a common operator associated with the \u201csource\u201d attribute. One non-limiting technique for assigning default index parameters for non-XML data is expressed in Statement 2 of Appendix A.","At block , XPath filter parameters are assigned to the attribute set. In one aspect, a predicate table is created based on these parameters, as described in detail below. One non-limiting technique for assigning XPath filter parameters to the attribute set is expressed in Statement 3 of Appendix A.","The XML document bound to the \u201cnews\u201d attribute is not tied to a particular XML schema. Hence, any valid XML document can be bound to this attribute. Therefore, if a particular XML element with a particular name is expected in more than one context with different simple datatypes, the datatype of the element should preferably not be specified. When a datatype of an element is not specified, it is only used for positional filtering, not value filtering. Similarly, when an attribute with a same name (element name extended) appears in different contexts with different datatypes in a document, this element should preferably not be used as an XPath filtering parameter. These attributes can be evaluated as a sparse predicate by the expression filter process.","When an element with no value attribute is expected in almost every XPath expression, adding such element to the XPath filtering parameters will degrade performance because the element is not contributing to any filtering of expressions. An example of such an element is the \u201cworld\u201d tag in the expression set of Appendix A.","At block , the attribute set is associated to the expression set stored in a column of a database table. Although reference is made herein to a database table, embodiments are not limited to use of a data table as the logical construct for organization of data elements. For example, object classes and associated objects may also be used. The column in which the expression set resides is referred to herein as the EXPRESSION column (entitled \u201cInterest\u201d in the table of Appendix A). One non-limiting technique for associating the attribute set to an expression set in a database table named \u201cSUBSCRIBER\u201d is expressed in Statement 4 of Appendix A.","At block , an expression filter index is created on the EXPRESSION column of the database table. Details of an expression filter index for XPath expressions, according to embodiments, are described further below. One non-limiting technique for creating an expression filter index is expressed in Statement 5 of Appendix A.","Testing every expression for a data item is a linear time solution. When a large set of expressions are defined, this approach is not scalable for a high volume of data items. Therefore, in an embodiment, a new indexing mechanism is used to evaluate a large set of XPath expressions efficiently and, consequently, to quicken the evaluation of the expression set for a given data item or data string. This index can be defined on an EXPRESSION column, thus a query optimizer can determine the use of the index for the evaluation of an expression set, based on the index usage cost. In an implementation, persistent database objects are created to maintain the index for an expression set, where pre-processing the expressions set at the time of index creation populates these database objects. Additionally, the information stored in these objects is maintained to reflect any changes to the expression set using DML operations on the table storing the expressions.","According to an embodiment, an Expression Filter is a set of PL\/SQL packages and APIs to manage expressions in user tables, and to filter the expressions for a given data item, that is, to match criteria expressed in expressions with the given data item, using a standard SQL or other query language query. In a publication system, the expressions specify criteria that must be satisfied by data for the data to be of interest to a subscriber.","The Expression Filter comprises two components: an EVALUATE operator and an Expression Filter Indextype, which are described in detail below. The expression filter index created at block  refers to the Expression Filter Indextype, according to an aspect of the invention.","Expression Filter Index Type","In an embodiment, the indexing scheme is implemented as a new index type (\u201cINDEXTYPE\u201d), referred to as an Expression Filter (\u201cEXPFILTER\u201d), using an extensible indexing framework. In an implementation, the indexing scheme is implemented using the Oracle Extensible Indexing framework. The Expression Filter index type can be used to create an index on any set of expressions stored in a database column of type VARCHAR2, CLOB or BFILE. However, use of another index type other than the foregoing, which may be used on expressions stored as data types, is contemplated and therefore within the scope of embodiments of the invention. The expression set being indexed may include, for example, XPath expressions, non-XML expressions, and a combination of both types of expressions.","Returning to , at block , the expression set is filtered for an event, using the expression filter index created at block . Hence, for a given input set, or event, relevant expressions are identified for the event. For example, for a given input set defining one or more events, such as an XML document, a set of XPath expressions is evaluated, or filtered, in conjunction with the input set to identify expressions that are interested in a particular event. An example of a statement for filtering expressions for an event is expressed in Statement 6 of Appendix A.","EVALUATE Operator","An operator, EVALUATE, is introduced that processes the expression set stored in an EXPRESSION column. This operator can be used in the WHERE clause of a standard SQL, or a DML statement, to filter the expressions for a data item. The predicate on the expression set, using the operator EVALUATE, can be combined with any other predicate on the table. The EVALUATE operator accepts the name of the column storing the expressions, e.g., INTEREST, and a given data item as arguments. In the context of the example of Appendix A, the data item is \u201cnewsevent\u201d (an instance of the Abstract type associated with the attribute set). The EVALUATE operator internally uses the expression set metadata to evaluate expressions for data items passed in.","The query on the table in which expressions are stored can be extended to include multi-table joins and any other database query operations using GROUP BY clause, ORDER BY clause, HAVING clause etc. In addition, filtering a set of expressions for a batch of data items by joining the table in which expressions are stored with the table storing the data items being processed (i.e., the data, such as an XML document, to which the expressions are compared) is contemplated. In the example of Appendix A, such a query would include the database table named SUBSCRIBER and a table storing the data items (e.g., a table entitled WEEKLY_NEWS, which stores values for each of the source and news attributes)","Overview of XPath Expression Filtering","In an embodiment, the data structures used to group the predicates in an expression set are relational in nature. In an implementation in which persistent database objects are used for the Expression Filter index data structure, an example of such database objects are as follows:","Predicate Table: a relational table that stores the predicates appearing in the expressions;","Bitmap Indexes: one or more bitmap indexes on the predicate table; and","Access Function: a function that queries the predicate table to filter the expressions for a data item.","These objects collectively provide for efficient filtering of XPath expressions based on the position of XML elements in a given XPath expression as well as based on the values of XML attributes associated with XML elements. Furthermore, since the index structure objects are persistently stored in the database, memory constraints associated with the size of expression sets in prior approaches, which typically use main memory extensively, are not applicable to the present embodiments. By contrast, operations using the present embodiments can store the necessary database blocks into a database buffer cache as they are needed.","As described above, expressions from a given set of expressions refer to a set of elementary attributes with fixed data types. Further, a set of valid values for these attributes constitute a data item, which is evaluated against these expressions. Hence, to index a set of expressions with the Expression Filter index type, all the elementary attributes used in the expression set should be associated with the database column storing the expressions, such as at block  of . These elementary attributes, perhaps along with some optional complex attributes, constitute the attribute set for the expression set which are stored in one or more data dictionary tables.","Generally, utilization of the indexing scheme described herein, implemented as a new Indextype (i.e., Expression Filter index type) and applied to a column storing expressions as data, provides a method for efficiently evaluating large sets of XPath expressions by allowing the EVALUATE operator to use the Expression Filter index.","XPath Expression Index","Filtering a large set of expressions with XPath predicates necessitates different treatment for the XPath predicates on XML data than for predicates defined for non-XML data. Categorizing predicates with XPath expressions into two classes: (1) predicates in which the existence of an XML node is of interest, and (2) predicates in which the non-existence of an XML node is of interest; the predicates in the first class are considered primary candidates for indexing. The predicates in the second class are maintained in their original form and evaluated by submitting them to a database server.","An XPath expression that is a candidate for indexing may not filter a given expression based on all of the path nodes and path predicates in the index evaluation phase. Thus, during evaluation of data, which includes filtering expressions from an expression set, XPath expressions that evaluate to true with application of the index are, in one embodiment, further processed to check all of the path nodes and path predicates. To that end, the original forms of the XPath expressions are also maintained, but processed only if the indexed portion of the XPath expression evaluates to true for a given data item. In one embodiment, the expressions, or predicates, are maintained in their original form in a column of the predicate table. Furthermore, XPath expressions in their original form may be stored in the same column as non-XML predicates that are not indexed.","In one embodiment, predicates that appear in disjunctions are not indexed. Such predicates are evaluated in another phase if the indexed portion of the XPath expression evaluates to true. In another alternative embodiment, the XPath expressions are rewritten as a disjunction of two or more XPath expressions that do not contain disjunctions (equivalent to the Disjunctive Normal Form for conditional expressions), and each XPath expression is treated separately.","According to an aspect of the invention, multiple XPath expressions on an XMLType attribute are indexed based on (1) the level of the XML elements of interest, and (2) the value of the XML attributes of interest. A user could configure such an index by choosing the more distinguishing XML elements and attributes used in a set of XPath expressions for an XMLType attribute. If the XPath expressions for an XMLType attribute are available before index creation, statistics on the expression set can be collected to identify the distinguishing XML elements and attributes. A conventional data table, referred to as a predicate table, is used to maintain the index information for a set of XPath expressions. In addition, a given predicate table may also, or alternatively, include representations of non-XML expressions.","For every distinguishing XML element for which the index is configured, the level at which the XML element should appear in the hierarchy or tree that defines a given XML document, for the XPath expression to evaluate to true, is stored. In one embodiment, the level information for an XML element is stored in two parts: (1) a level constraint, and (2) a bounding level.","For example, the following XPath expression is interested in the XML element AUTHOR appearing at level , or the second level of the XML document hierarchy:","\/PUBLICATION\/AUTHOR[@name=\u201cSCOTT\u201d].","The following XPath expression is interested in the XML element AUTHOR appearing at level  or higher of the XML document, indicated by the double-slash after first level, which specifies all descendents of the context node PUBLICATION:","\/PUBLICATION\/\/AUTHOR[@name=\u201cSCOTT\u201d].","Hence, for the first expression, (\u2018=\u2019, 2) is stored in the index and for the second expression, (\u2018=>\u2019, 2) is stored in the index. The operator in each expression, such as \u2018=\u2019 and \u2018=>\u2019, are what is referred to above as level constraint, and the bounding level is \u20182\u2019 in both expressions. In one embodiment, the two pieces of information for each expression are collapsed by using an encoding scheme. For example, a negative number could be used to represent a range of levels, such as \u2018\u2212\u2019 representing \u201c=>2\u201d and a positive number could be used to indicate a particular range.","If an element appears at more than one level in an XPath expression, only the last occurrence is stored. Furthermore, if an XPath expression is interested in the existence of an element in a range of levels, such as with the use of ancestor\/descendent semantics in XPath, the level constraint of the element captures this information.","For a distinguishing XML attribute for which the index is configured, two pieces of information are stored for every XPath expression that includes a predicate on that attribute: (1) the relational operator used in the predicate, and (2) the constant in the predicate. In an implementation, XML attributes are, by default, considered to be of \u201cstring\u201d data type. However, as an implementation detail, the attribute definition can be overridden with a different data type to ensure correct range predicate results. For example, two Date fields defined as strings may not return the same results upon comparison.","Returning to the foregoing expressions for an example, (\u2018=\u2019, \u201cSCOTT\u201d) or a representation thereof is stored in reference to the \u201cname\u201d attribute of the AUTHOR element of such expressions.","In an embodiment, a predicate table comprises two dedicated columns for each XML element and XML attribute for which an index is configured. Each row in the predicate table corresponds to an XPath expression, hence, an identifier of each expression is also stored in such table. In the case of a tag configured as a positional filter, one column captures wildcard matches regarding positions (e.g., ANCESTOR, ANCESTOR-OR-SELF, DESCENDENT, DESCENDENT-OR-SELF). For example, logical relationships between positions of an element in an expression and a corresponding element in a data item include equal to, greater than, less than, greater than or equal to, and less than or equal to. The other column stores the position information for the tag in the XPath expression, which corresponds to the element's position within an XML document. In the case of a value-based filtering tag, one column stores the operator of the predicate and the other column stores the constant that appears in the predicate with the XML tag in the XPath expression. Encoding the two columns for XML elements into a single column and the two columns for XML attributes into a single column is specifically contemplated, but not required.","According to an embodiment, the predicate table further comprises a column that is defined with a VARCHAR2 data type, for storing XPath predicate expressions in their original form. Furthermore, storing indexing information for non-XML data in the same table as XPath expression indexing information is specifically contemplated.","A query, using SQL for example, can be issued against the predicate table to evaluate the expression set represented therein in conjunction with a data set, such as an XML document and\/or non-XML data. In an embodiment, a concatenated bitmap index is created on the columns of a predicate table that correspond to each XML attribute and XML element, to execute an evaluation query efficiently. Such bitmap indexes function as a multi-dimensional index during the expression set evaluation, and operate to filter expressions based on multiple elements and attributes simultaneously. Additionally, creating a concatenated bitmap index for the XPath columns and columns storing indexing information for non-XML data is specifically contemplated.","An example of a predicate table is illustrated below, based on the following scenario. Consider the following expressions defined on two variables, \u201csource\u201d and \u201cnews\u201d, where \u201csource\u201d is a text variable and \u201cnews\u201d a XML type variable.\n\n","For this expression set, \u201csource\u201d can be chosen as one of the predicate left-hand-sides that can be indexed according to techniques for non-XML data. Additionally, the XPath predicates on the \u201cnews\u201d XMLType data can be indexed by identifying the following filtering attributes:","Value Filter:\n\n","Positional Filters:\n\n",{"@attributes":{"id":"p-0095","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}},{"entry":["Row","G1","G1","G2","G2","G3","G3","G4","G4",{}]},{"entry":["Id","OP","CT","OP","CT","OP","CT","OP","CT","Sparse"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["r1","=","CNN","=","US","=","2","=","4","existsNode (news,"]},{"entry":[{},{},{},{},{},{},{},{},{},"\u2018\/world\/sports\/olympics\/football[team=US\u2019]\u2019) = 1"]},{"entry":["r2","=","CBS","=","JETS","=","3","=","4","existsNode (news,"]},{"entry":[{},{},{},{},{},{},{},{},{},"\u2018\/world\/us\/sports\/football[team=\u2018JETS\u2019]\u2019) = 1"]},{"entry":["r3","=","FOX","=","ENG","=","2","=","3","existsNode (news,"]},{"entry":[{},{},{},{},{},{},{},{},{},"\u2018\/world\/sports\/football[team=\u2018ENG\u2019]\u2019) = 1"]},{"entry":["r4",{},{},"=","TITANS",">=","1",">=","2","existsNode (news,"]},{"entry":[{},{},{},{},{},{},{},{},{},"\u2018\/\/sports\/football[teams=\u2018TITANS\u2019]\u2019) = 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}},{"entry":"Where,"},{"entry":"G1_OP: relational operator for predicates on the \u201csource\u201d variable;"},{"entry":"G1_CT: RHS (right-hand-side) constant for predicates on the \u201csource\u201d variable;"},{"entry":"G2_OP: relational operator for the value predicate on football @ team of the \u201cnews\u201d variable;"},{"entry":"G2_CT: RHS constant for the value predicate on football @ team;"},{"entry":"G3_OP: relational operator for the positional predicate on the \u201csports\u201d element of the \u201cnews\u201d variable;"},{"entry":"G3_CT: constant for the positional predicate on the \u201csports\u201d elements;"},{"entry":"G4_OP: relational operator for the positional predicate on the \u201cfootball\u201d element of the \u201cnews\u201d variable;"},{"entry":"G3_CT: constant for the positional predicate on the \u201cfootball\u201d elements; and"},{"entry":"Sparse: The sparse predicate column storing the XPath predicates in their original form, which are evaluated only when the positional and value-based filters evaluate to true for a given data item (e.g., an XML document as a value for \u201cnews\u201d variable). Numerical values can be used to represent the \u2018=\u2019 and \u2018>=\u2019 relational operators."}]}}}}},"In an embodiment, in analysis of predicates in XPath expressions, the predicates in an expression set can be classified into two sets as described below, with each set evaluated in turn.","(1) Predicates with indexed attributes (in reference to Statement 3 of Appendix A, examples include tag names \u2018sports\u2019, \u2018football\u2019 and \u2018football@team\u2019, for which tag_indexed =>\u2018YES\u2019), which are considered more selective and for which bitmap indexes are created; and predicates with stored attributes (in reference to Statement 3 of Appendix A, an example includes tag name \u2018world@pubdate\u2019, for which tag_indexed =>\u2018NO\u2019), which are considered less selective.Dedicated columns are created in the predicate table for the predicate groups belonging to this set. For example, predicates on distinguishing XML elements and attributes in XPath expressions fall into this first set.","(2) Predicates with other XML elements and attributes, which are only captured in the original form of XPath expressions, i.e., they are not considered necessarily selective and thus are not stored in the dedicated columns as with those in set (1).","The first phase of evaluation, with respect to the first set of predicates, narrows down the working set of expressions by eliminating the XPath expressions that are conclusively false for a given XML document. The second phase of evaluation, with respect to predicates stored in their original form, evaluates the complete XPath predicate for the smaller working set that was minimized via the first phase of evaluation.",{"@attributes":{"id":"p-0100","num":"0117"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 1"],"b":"112"},"At block , an expression filter index, configured as described above, is consulted to fetch the list of XML tags configured for the index. Recall that the list of XML tags may comprise tags associated with XML elements and XML attributes. Thus, the XPath expression information that resides in the special columns of the predicate table is extracted, that is, the positional and value-based filter information described above.","At block , an event input set, such as an XML document, is parsed to obtain the positions and values for tags in the document. In an embodiment, an XML DOM (Document Object Model) parser is used to obtain the elements, attributes, and the like from the document. At block , arrays are built which comprise the tag information of the document, obtained at block . In an embodiment, each tag information associated with a tag from the document comprises the tag name, tag type, a VARRAY of all the positions of the tag in the document, and the values that appear with the tag in the current document.","At block , the arrays are bound to an evaluation query that is issued on the predicate table. Relevant portions of a generalized example of such an evaluation query follows:\n\n","E_LVL_CNSTR and E_ABS_LVL are columns in the XPath predicate table, which map to level constraint and absolute level of an XML element (e.g., sports) configured for the index;",":E_LVLS_VARRAY is a VARRAY containing all the levels at which the XML element (e.g., sports) corresponding to E appears in the given XML document;\n\n",":A_VALS_VARRAY is a VARRAY of the values for all the occurrences of the XML attribute (e.g., football@team) in the given XML document.","At block , such an evaluation query is run to filter the expression set for the given XML document. The evaluation query returns a small list of XPath expressions that are potentially true for the XMLType instance (e.g., news) passed in. For these expressions, at block , the original form of the expressions is obtained. In an embodiment, the original expressions are obtained from a column of the predicate table in which they are stored in that form. At block , the original form of the expressions for the expressions that are returned by the evaluation query are submitted to a database server for further evaluation in relation to the given XML document.","To evaluate simple (i.e., non-XML) predicates in conjunction with XML predicates (e.g., XPath expressions) using the predicate table, the WHERE clause of the query on the predicate table is enhanced to include the evaluation of simple predicates. Furthermore, bitmap indexes can be created on the columns storing XML and non-XML predicates to provide faster evaluation.","The foregoing description is presented in the context of XPath expressions and XML documents for explanatory purposes; however, embodiments are not so limited. The methods and systems described herein may be applied to hierarchically structured data in general, in which elements or data items are identified through some type of path designation. For example, the teachings may be applied to name-value pairs that are represented or maintained in a hierarchical tree structure and located within the tree structure by a pathname, to filter a set of pathnames for a given hierarchical data item of name-value pairs.","The predicate table is described above as being used to filter an expression set and as being an index.  is a block diagram that depicts interaction between functional components in carrying out the process described in reference to .","In the context of filtering an expression set, the expression set is pared down to expressions that do or are likely to match a given hierarchical data item, based on the expressions. For example, the processes may be used in an event content subscriber-publisher context, in which arrival of a hierarchical data item  (e.g., an XML document) is an event  which is evaluated by a condition evaluation engine  to determine whether any expressions in the expression set match the data item based on the condition information provided by the expressions (i.e., element level and attribute value) as represented in a predicate table , for which a resultant action  is to provide the hierarchical data item to an entity (e.g., user, or subscriber) associated with a matching expression. In the context of an index, the predicate table , which comprises a set of expressions associated with entities, is used by the condition evaluation engine  to determine expressions in the expression set that match a given data item  which, once determined, are used to identify respective entities associated with the matching expressions wherein the entity-expression associations are stored in another table, such as entity-expression association table . In such a scenario, the predicate table  is used as an index to the entity-expression association table . Thus, action  can be performed by providing to the identified entities the data items in which they are interested.","The techniques described herein integrate expression filtering operations into database operations. In the context of an information subscription-publication system, as a result of the integration of expressions and filtering mechanisms into a database system, mutual filtering from both a subscriber and a publisher can be performed, and performed efficiently, through use of standard SQL statements. Therefore, multi-domain queries are possible, by joining tables and adding predicates to a query to further filter expressions. Furthermore, batch evaluation of expression sets for a given set of data is possible by joining the table storing the expressions with the table storing the data items. Still further, filtering can be performed on both XML and non-XML information in the same query and, thus, as part of the same evaluation process.",{"@attributes":{"id":"p-0113","num":"0146"},"figref":"FIG. 4","b":["400","400","402","404","402","400","406","402","404","406","404","400","408","402","404","410","402"]},"Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT) or a liquid crystal display (LCD), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The invention is related to the use of computer system  for implementing the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical, magnetic, or magneto-optical disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are means for transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution.","Alternative embodiments of the invention are described throughout the foregoing description, and in locations that best facilitate understanding the context of the embodiments. Furthermore, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example, implementations were presented in which SQL is used; however, the techniques described herein are not limited to use with SQL, for other data query languages may be applicable. For another example, implementations were presented in the context of a XML document; however, advantages and use of embodiments of the invention are not limited to this context. For one more example, implementations were presented in which a concatenated bitmap index is created on columns of a predicate table. However, embodiments are not limited to such an index, for other index types that are suitable for indexing multiple columns of data tables are also applicable. Therefore, the specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.","In addition, in this description certain process steps are set forth in a particular order, and alphabetic and alphanumeric labels may be used to identify certain steps. Unless specifically stated in the description, embodiments of the invention are not necessarily limited to any particular order of carrying out such steps. In particular, the labels are used merely for convenient identification of steps, and are not intended to specify or require a particular order of carrying out such steps.","The following abstract data type represents the structure of a data item for which a large set of expressions is defined, and is related to News subscriptions.",{"@attributes":{"id":"p-0125","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"APPENDIX A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The following abstract data type represents the structure of a data item"},{"entry":"for which a large set of expressions is defined, and is related to"},{"entry":"News subscriptions."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CREATE or REPLACE TYPE newsevent AS OBJECT("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"source VARCHAR2(30),","(comment: source of the News)"]},{"entry":[{},"news sys.XMLType.","(comment: the News)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Furthermore, a set of expressions defined for the foregoing data"},{"entry":"structure is stored in a SUBSCRIBER table as follows."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ID","INTEREST"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1","source = \u2018CNN\u2019 and existsNode(news,"]},{"entry":[{},"\u2018\/world\/sports\/olympics\/football[team=\u2018US\u2019]\u2019) = 1"]},{"entry":["2","source = \u2018CBS\u2019 and"]},{"entry":[{},"\u2003existsNode(news, \u2018\/world\/us\/sports\/football[team=\u2018JETS\u2019]\u2019) = 1"]},{"entry":["3","source = \u2018FOX\u2019 and existsNode(news,"]},{"entry":[{},"\u2018\/world\/sports\/football[team=\u2018ENG\u2019]\u2019) = 1"]},{"entry":["4","existsNode(news, \u2018\/\/sports\/football[teams=\u2018TITANS\u2019]\u2019) = 1"]},{"entry":". . ."},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Statement 1"},{"entry":"(Block 102 - Create attribute set for expression set):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EXECUTE dbms_expfil.create_attribute_set("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"attr_set => \u2018NEWSEVENT\u2019,"]},{"entry":[{},"from_type => \u2018YES\u2019)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Statement 2"},{"entry":"(Block 104 - Assign default index parameters for non-XML data):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EXECUTE dbms_expfil.default_index_parameters("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"attr_set => \u2018NEWSEVENT\u2019,"]},{"entry":[{},"attr_list => exf$attribute_list("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"exf$attribute(attr_name => \u2018SOURCE\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"attr_oper => exf$indexoper(\u2018=\u2019),"]},{"entry":[{},"attr_indexed => \u2018YES\u2019)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Statement 3"},{"entry":"(Block 106 - Assign XPath filter parameters to the attribute set):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EXECUTE dbms_expfil.xpath_filter_parameters("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"attr_set => \u2018NEWSEVENT\u2019,"]},{"entry":[{},"xml_attr => \u2018NEWS\u2019,"]},{"entry":[{},"tag_list => exf$xpath_tags("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"exf$xpath_tag(tag_name => \u2018sports\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tag_type => null,"]},{"entry":[{},"tag_indexed => \u2018YES\u2019),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"exf$xpath_tag(tag_name => \u2018football\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tag_type => null,"]},{"entry":[{},"tag_indexed => \u2018YES\u2019),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"exf$xpath_tag(tag_name => \u2018football@team\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tag_type => VARCHAR2(20),"]},{"entry":[{},"tag_indexed => \u2018YES\u2019),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"exf$xpath_tag(tag_name => \u2018world@pubdate\u2019,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tag_type => DATE,"]},{"entry":[{},"tag_indexed => \u2018NO\u2019)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},")."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Statement 4"},{"entry":"(Block 108 - Associate the attribute set with the expression set):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EXECUTE dbms_expfil.assign_attribute_set("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"attr_set => \u2018NEWSEVENT\u2019,"]},{"entry":[{},"tab_name => \u2018SUBSCRIBER\u2019"]},{"entry":[{},"exp_column => \u2018INTEREST\u2019)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Statement 5"},{"entry":"(Block 110 - Create an expression filter index on expression column"},{"entry":"of predicate table):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CREATE INDEX xpath_filter ON subscriber(interest)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"INDEXTYPE IS exfsys.EXPFILTER."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Statement 6"},{"entry":"(Block 112 - Filter the expressions for an event):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT * FROM subscriber WHERE EVALUATE (interest,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Sys.AnyData.convertObject(newsevent("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"source => \u2018CNN\u2019,"]},{"entry":[{},"news =>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"XMLType (\u2018<?xml version=\u201c1.0\u201d?>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<world pubdate=\u201c20-NOV-2002\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<sports>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<football team=\u00a2T1TANS\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<week10 opponent=\u00a2RAIDERS\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<stats> . . <\/stats>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/week10>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/football>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/sports>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/world>\u2019)))) = 1 AND . . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
