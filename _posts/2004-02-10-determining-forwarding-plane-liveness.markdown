---
title: Determining forwarding plane liveness
abstract: Forwarding liveness, such as the ability of an interface to send and receive packets and forwarding capabilities of the interface, is determined. The determined forwarding liveness may be sent in a single message, allowing forwarding liveness information to be sent more frequently which permits fast detection of failures. The message may also include aggregating liveness information for multiple protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07805536&OS=07805536&RS=07805536
owner: Juniper Networks, Inc.
number: 07805536
owner_city: Sunnyvale
owner_country: US
publication_date: 20040210
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["\u00a70. RELATED APPLICATIONS","\u00a71. BACKGROUND OF THE INVENTION","\u00a72. SUMMARY OF THE INVENTION","\u00a74. DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/472,859, entitled \u201cDETERMINING LIVENESS OF MULTIPLE PROTOCOLS AND\/OR INTERFACES,\u201d filed on May 23, 2003 and listing Kireeti Kompella as the inventor. That application is expressly incorporated herein by reference. The scope of the invention is not limited to any requirements of the specific embodiments in that application.","\u00a71.1 Field of the Invention","The invention concerns detecting errors in connections, protocols, data plane components, or any combination of these.","\u00a71.2 Background Information","The description of art in this section is not, and should not be interpreted to be, an admission that such art is prior art to the invention.","A protocol is a specific set of rules, procedures, or conventions relating to the format and timing of data transmission between two devices. Accordingly, a protocol is a standard set of procedures that two data devices use to work with each other. Nodes, such as routers, in communications networks may use protocols to exchange information. For example, routers may use routing protocols to exchange information used to determine routes.  illustrates two nodes , coupled via communications link . Node  includes various interfaces ,,, and supports protocols ,. Interface  terminates communications link . Similarly, node  includes interfaces ,,, and supports protocols ,. Interface  terminates communications link . Node  and node  can be considered \u201cneighbors\u201d or \u201cadjacencies\u201d since they each terminate communications link . As indicated by the dashed lines, an instance of protocol A  and an instance of protocol B  at node  may communicate with another instance of protocol A  and another instance of protocol B , respectively, at node . Although not shown, the communications between the protocols actually occur via interfaces , and communications link .","Conventional routing protocols may include some form of liveness detection. For example, the intermediate system-intermediate system protocol (IS-IS) and the open shortest path first protocol (OSPF) include a \u201chello\u201d mechanism that lets a router running IS-IS or OSPF know whether nodes sharing a communications link with the router are still up. Some protocols, such as a border gateway protocol (BGP), use the underlying transport to determine the liveness of their neighbors. In the case of BGP, transmission control protocol (TCP) keepalives are used. Other protocols, such as routing information protocols (RIP), have intrinsic liveness mechanisms. In most cases, once an adjacency with a neighbor node running the same protocol is established with an initial hello message, subsequent hello messages don't need to carry a lot of information.","In most, if not all, of these liveness detection mechanisms, the time needed to conclude that one's neighbor is down ranges from seconds, to tens, or even hundreds of seconds. For example, with IS-IS, hellos are normally sent every nine (9) seconds. A node determines a neighbor to be down only after three (3) consecutive hellos have been unanswered. Accordingly, a node running IS-IS normally needs at least 27 seconds before it determines that a neighbor node is down. Similarly, with the point-to-point protocol (PPP) hellos are normally sent every ten (10) seconds. A node determines a neighbor to be down only after three (3) consecutive hellos have been unanswered. Accordingly, a node running PPP normally needs at least 30 seconds before it determines whether a neighbor node is down.","Since routers and other nodes on the Internet are predominantly used for communicating data for applications (such as e-mail) that are tolerant of some delay or packets received out of sequence, the conventional liveness detection schemes are acceptable. However, as more demanding applications (such as voice over IP) use the Internet or other packet-switched networks, there are instances where detecting that a neighbor is down in a few tenths of a second, or even hundredths of a second may be necessary. Such fast liveness detection is needed, for example, where failover needs to occur quickly so that an end user doesn't perceive, or at least isn't unduly annoyed by, the failure of an adjacency (e.g., due to any one of a node failure, a link failure, or a protocol failure).","One approach to determining liveness faster is to allow faster (e.g., sub-second) protocol hello timers. This is feasible for some protocols, but might require changes to the protocol. Implementing these protocol changes on new nodes, and propagating these protocol changes to nodes previously deployed in a communications network is not trivial. Moreover, for some other protocols faster protocol hello timers are simply not feasible.","Even if all protocols could implement fast protocol hello timers, at least two additional issues make such a simple, brute force change unattractive. First, routers often implement multiple routing protocols, each having its own liveness detection mechanism. Consequently, updating each routing protocol to enable fast detection can lead to a considerable amount of work. Second, hello messages often carry more than just liveness information, and can therefore be fairly large and require non-trivial computational effort to process. Consequently, running fast liveness detection between a pair of neighbor nodes, each running multiple protocols, can be expensive in terms of communications and computational resources required to communicate and process the frequent, lengthy messages for liveness detection.","Additionally, it is desirable to check interface forwarding liveness (i.e., the ability to forward data over an interface). Forwarding liveness may be a function of various components in the \u201cdata plane\u201d of a data forwarding device such as a router. For example, data plane components may include a forwarding table (sometimes referred to as a forwarding information base), switch fabric, forwarding lookup engine, traffic scheduler, traffic classifier, buffers, segmenters, reassemblers, resequencers, etc. Such components may be embodied as memory, processors, ASICs, etc.","In view of the foregoing, there is a need to detect liveness faster that conventional liveness detection schemes. It is desirable that such liveness detection (i) have minimal impact on existing protocols, (ii) not waste communications resources, and (iii) not be computationally expensive.","Apparatus, data structures, and methods consistent with the principles of the invention may also be applied for determining liveness of a data plane used by, and including, an interface (simply referred to as \u201cinterface forwarding liveness\u201d). This is especially useful for interfaces whose failure detection mechanisms at the physical or link layer are slow (such as PPP) or presently non-existent (such as Ethernet).","Alternatively, or in addition, apparatus, data structures, and methods consistent with the principles of the invention may also be applied for determining interface forwarding liveness.","In one embodiment consistent with the principles of the present invention, a sending node may (a) accept forwarding liveness status information, (b) compose a message including the forwarding liveness status information, and (c) send the message towards a neighbor node. In at least one embodiment, the sending mode may further (d) maintain a first timer for tracking a send time interval, where the acts of composing a message and sending the message are performed after expiration of the first timer, and (e) restart the first timer after the message is sent.","In one embodiment consistent with the principles of the present invention, a receiving node may (a) receive a message including forwarding liveness status information and a time interval, and (b) update neighbor node forwarding liveness status information using the message. In at least one embodiment of the invention, the receiving node may update the neighbor node liveness status information by (a) setting a first timer to the time interval and starting the first timer, (b) if the first timer expires, setting a status of an interface of the neighbor node to down, and (c) if a further message is received, resetting the first timer to the new time interval and restarting the first timer.","Elements, apparatus, systems, computer-implemented code, data structures and methods consistent with the principles of the invention permit the liveness of protocols, interfaces, or both to be monitored. The following description is presented to enable one skilled in the art to make and use the invention, and is provided in the context of particular applications and their requirements. Various modifications to the disclosed embodiments will be apparent to those skilled in the art, and the general principles set forth below may be applied to other embodiments and applications. Thus, the invention is not limited to the embodiments shown and the inventors regard their invention as the following disclosed methods, apparatus and data structures and any other patentable subject matter.","An exemplary environment in which the invention may operate is described in \u00a74.1. Then, elements, apparatus, systems, computer-implemented code, methods and data structures that may be used to perform operations and store information in manners consistent with the principles of the invention are described in \u00a74.2. An example illustrating operations performed by an exemplary embodiment of the invention is then provided in \u00a74.3. Finally, some conclusions regarding the invention are set forth in \u00a74.4.","\u00a74.1 Environment in which the Invention May Operate","The invention may be used in communication systems including nodes for forwarding data, such as packets. Such nodes may be routers. For example, the invention may be used to quickly detect a down connection (e.g., a down link, node, or interface), protocol, or both. The invention may be used in conjunction with a fast reroute technique, a graceful (or hitless) restart technique, or some other failover technique.","The invention can be used in an exemplary communications environment, such as the one illustrated in . Referring to , suppose node  and node  are routers, and that protocol A is IS-IS and protocol B is resource reservation protocol (RSVP). Suppose further that node  and node  have established an IS-IS adjacency and one or more RSVP sessions. Consistent with the principles of the invention, both nodes , may be configured with a time interval (referred to as \u201cthe dead interval\u201d) in which to send a hello. If the IS-IS dead interval for node  is 27 seconds, then node  will declare its IS-IS adjacency with node  dead if it  doesn't receive an IS-IS hello from node  within 27 seconds of the previous hello. Typically, node  will send hellos more frequently than once every 27 seconds so that even if a hello or two are lost, the adjacency stays up.","Once node  and node  have established various routing protocol \u201csessions\u201d between themselves, they can begin exchanging aggregated protocol and\/or forwarding liveness (APFL) hellos in a manner consistent with the principles of the invention. In one embodiment of the invention, an APFL hello contains a list of protocols that it is reporting on (in this case, IS-IS and RSVP), as well as the status of those protocols (e.g., up or down). The APFL hello message may also contain a dead interval. Node  is essentially saying \u201cIf I don't send you an APFL hello within the dead interval of my previous APFL hello, declare all protocols reported in the last received APFL hello as dead.\u201d","Note that the regular IS-IS hellos should also be running. Thus, node  will declare its IS-IS adjacency with node  dead if any of the following occur:\n\n","Moreover, Node  may include means for monitoring forwarding liveness for each of one or more of its interfaces , , , . Similarly, Node  may include means for monitoring forwarding liveness for each of one or more of its interfaces , ,  and . Forwarding liveness refers to the ability to forward traffic over an interface.","\u00a74.2 Exemplary Methods, Elements, Apparatus, Systems and Data Structures","Exemplary methods, elements, apparatus, systems and data structures for performing APFL operations will now be described.",{"@attributes":{"id":"p-0036","num":"0038"},"figref":"FIG. 2","b":["240","260","270","260","262","264","240","266","268","240","270","272","274","240","276","278","240"]},"APFL operations  use hello interval information , protocols, interfaces, or both using aggregated liveness , {dead interval, neighbor node} pair information , and APFL neighbor information  to determine liveness of various peer protocols, forwarding liveness of interfaces of various neighbor nodes, or both. Configuration operations  may be used to configure hello interval information , protocols, interfaces, or both using aggregated liveness , and {dead interval, neighbor node} pair information .","\u00a74.2.1 Exemplary APFL Method",{"@attributes":{"id":"p-0039","num":"0041"},"figref":["FIG. 3","FIGS. 3A and 3B"],"b":["302","304","306","308","330","390"]},"Returning to block , if a lost hello timer has expired, the last received protocol status for each protocol in the last received protocol registration is set to \u201cdown\u201d and the protocol is notified (Loop -, including ). The lost hello timer is then stopped () and the method is left (, ).","Again referring back to block , if APFL information, such as a packet, is received from another node, it is determined whether or not to discard the information. This determination may be based on configuration or rate-limiting (). If it is decided to discard the APFL information, the APFL information is discarded () and the method is left ( and ). If, on the other hand, it is decided to not discard the APFL information, the contents of the APFL packet may be checked for sanity, such as self-consistency, as well as consistency with previously received APFL packets (). If sanity check fails, the APFL information should be discarded (). Stored neighbor information (described below with reference to ) is checked for a match ( and ). If a match is not found, the APFL information is discarded or a new entry in the stored neighbor information is created () before the method is left ( and ). If a match is found, it is determined whether the received information is newer than the matching information already stored. () If not, the information is stale and is therefore discarded () and the method is left ( and ). If, on the other hand, the received information is newer than the matching information already stored, it may be determined whether the new protocol registration is the same as a last received protocol registration ( and ). More specifically, if the received protocol registration is the same as the last received protocol registration, then the liveness information may have been aggregated from the same set of protocols. Otherwise, liveness information may be provided for a newly added protocol, or no longer provided from a removed protocol.","If the new protocol registration is the same as the last protocol registration, it is determined whether or not the status of any of the protocols has changed (Loop -). For each protocol with a changed status, it is determined whether the status of the protocol is up or down (). If the status of the protocol changed to \u201cdown,\u201d the last received protocol status for the protocol is set to down, and the local instance of the protocol is notified (). If, on the other hand, the status of the protocol changed to \u201cup\u201d, the last received protocol status for the protocol is set to up, and the local instance of the protocol is notified (). After any protocols with changed status are processed, the last received sequence number is set to the sequence number in the received information (). The lost hellos timer is set to the \u201cdead interval\u201d () and the method is left ().","Referring back to block , if the new protocol registration is not the same as the last received protocol registration (i.e., if the status for each of one or more protocols has been added and\/or removed), processing is performed for each newly added protocols, if any, and for each deleted protocol, if any. More specifically, for each added protocol (Loop -), the last received status for the protocol is set to \u201cdown\u201d () and it is determined whether the status of the new protocol is up or down (). If the status of the new protocol is determined to be up, the last received protocol status for the protocol is set to \u201cup\u201d and the local instance of the protocol is notified (). If, on the other hand, the status of the new protocol is determined to be down, the last received protocol status for the protocol is set to \u201cdown\u201d and the local instance of the protocol is notified (). For each deleted or removed protocol (Loop -), the last received protocol status is set to \u201cdown\u201d and the local instance of the protocol is notified (). Once processing is performed for each newly added protocol, if any, and for each deleted protocol, if any, as described above, the last received sequence number is set to the sequence number in the received information (). The lost hellos timer is set to the \u201cdead interval\u201d () and the method is left ().","Although the foregoing description referred to aggregated protocol status, the aggregated protocol status may include forwarding liveness status. Such forwarding liveness status may be tracked per interface. Thus, the forwarding liveness of an interface may be treated as just another protocol. Consistent with the principles of the invention, some embodiments may simply track forwarding liveness status, yet have utility even without tracking any protocol status information.","\u00a74.2.2 Exemplary APFL Information Messages","APFL information processed as described above may be carried in a packet, such as an Internet protocol (IP) packet.  illustrates an exemplary data structure , referred to as an APFL message, which may be used to communicate protocol status information in a manner consistent with the principles of the invention. An APFL message may include one or more APFL packets. In one embodiment consistent with the principles of the invention, APFL packets are IP (version 4 or version 6) packets with a new protocol identifier. This new protocol identifier may be defined by a standard body, such as the Internet Assigned Numbers Authority (IANA). An alternative to defining a new IP protocol identifier for APFL is to use a user datagram protocol (UDP) header and a well-defined port for APFL. Either of these techniques let a node receiving the packet know that the packet is carrying APFL information. Alternative techniques for accomplishing this are possible. Apart from the header, the packet format may be identical for both IPv4 and IPv6. Packets are sent to one or more neighbors. When the neighbors are directly attached, the source IP address is the sender's address on that interface, if any. Otherwise, the source IP address is the sender's router ID. The destination IP address is an ALL-ALP-ROUTERS multicast address defined by standards body by such as IANA, or the ALL-ROUTERS multicast address. When the APFL neighbor is not directly attached, the IP source address is the sender's router ID, and the destination address is a routable address belonging to the neighbor. The IP time-to-live (TTL) value should be set to 255, or some other predetermined value, so that a receiving node can check that an APFL packet came from an adjacent node and not from a node multiple hops away.","In one exemplary embodiment, all APFL packets contain a single APFL message, and each APFL message may include a common header , a message , and extensions . The total length of the APFL message, i.e., the sum of the lengths of all sections, may be provided in common header . Each section may be zero-padded so that its length is a multiple of four octets. Common header  has a length of 12 octets. The length of message section  may be fixed for each message type. The length of extensions section  may be inferred as the length of the APFL message  minus the lengths of the other sections  and . It is expected that APFL messages will be small enough so as not to require fragmentation. However, fragmentation and re-assembly should be supported. Naturally, the APFL information may be carried in ways other than the described APFL message in an APFL packet.","An exemplary format of common header  has the following structure. An R bit  indicates whether the APFL message is being sent to a directly attached node (R=0), or to a remote node (R=1). A Version field  (7 bits) indicates an APFL version number. A Message Type field  (8 bits) may include the following values:",{"@attributes":{"id":"p-0049","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Type","Message"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","Unused"]},{"entry":["1","Hello"]},{"entry":["2-255","Reserved for future use"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A Length field  (16 bits) indicates the combined lengths of common header , message  and extensions , if any, in octets. A Router ID field  (32 bits) is set to the sender's four octet router ID. APFL messages sent to directly attached neighbors (R=0) are associated with an interface. If the interface is numbered, i.e., configured with a unique IP address, an Interface Index field  (32 bits) may be set to zero, and the interface identified by the source IPv4 or IPv6 address in the IP header. Otherwise, Interface Index field  is set to the index allocated by the sending node for this interface, and the source IP address is an address identifying the sender. For APFL messages sent to a node not directly attached (R=1), Interface Index field  is set to zero, and the source IPv4 or IPv6 address is a routable address identifying the sending node.","An exemplary format of the message section  has the following structure. A Session field  (8 bits) can be used to identify several independent APFL sessions between a pair of nodes. Dead Interval field (24 bits)  is specified in microseconds. A node sending a Hello with a Dead Interval of N tells its APFL neighbor node to consider all the protocols that the node is reporting on as dead if the neighbor node doesn't receive another Hello from the sending node in N microseconds. (Recall, e.g., , , and  of .) A Sequence Number field  (64 bits) is a monotonically increasing number, with the first 4-octet word being the higher order word and the second being the lower order word. One possible implementation of sequence numbers is to use a 32-bit time-of-day (in seconds) for the first word, and a monotonically increasing counter, that resets to zero when the time-of-day changes, for the second word. One use of Sequence Number field  is to foil replay attacks in the context of some means of signing APFL messages. Providing Sequence Number in the Hello message might be less desirable if an alternative security mechanism is provided. A Protocol Registry field  is a 32-bit vector that indicates the protocols for which liveness reports will be sent in Hello messages. (Recall, e.g.,  of .) The semantics for the bit positions (bit  being the Most Significant Bit) of an exemplary Protocol Registry field  are as follows:",{"@attributes":{"id":"p-0052","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Bit position","Protocol"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","BGP"]},{"entry":["1","IS-IS"]},{"entry":["2","OSPF v2"]},{"entry":["3","OSPF v3"]},{"entry":["4","RIP v1\/v2"]},{"entry":["5","RIP NG"]},{"entry":["6","PIM"]},{"entry":["7","DVMRP"]},{"entry":["8","LDP"]},{"entry":["9","RSVP"]},{"entry":["10","LMP"]},{"entry":["11","Reserved (should be zero)"]},{"entry":["30","Forwarding liveness"]},{"entry":["31","Layer-2 (or interface liveness)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["425","424","425","424","425","424"],"sup":["th ","th "]},"Notice that the forwarding liveness of an interface, i.e., the ability of a node to forward packets received on that interface to other interfaces, or to forward packets received on other interfaces to that interface, may be indicated consistent with the principles of the invention. Forwarding liveness may include the ability to receive and process packets from an interface, the integrity and correct operation of forwarding (route lookup) tables, and the ability to rewrite and send packets on the interface.","Although message segment data structure is compact and permits a short simple message, the use of separate a protocol registry field  and a separate protocol status field  conveys three states\u2014(i) not reporting, (ii) reporting and up, and (iii) reporting and down\u2014for each protocol using two bits. In an alternative embodiment, two bits are provided per protocol to indicate one of four, not only three, possible states. These four states are (i) not reporting, (ii) reporting and up, (iii) reporting and down, (iv) reporting and up, but in restart mode. This fourth state can be used with so-called \u201cgraceful restart\u201d techniques, such as those described in U.S. patent application Ser. No. 10\/095,000 entitled \u201cGRACEFUL RESTART FOR USE IN NODES EMPLOYING LABEL SWITCHED PATH SIGNALING PROTOCOLS,\u201d filed on Mar. 11, 2002, and listing Kireeti Kompella, Manoj Leelanivas, Ping Pan, and Yakov Rekhter as inventors (incorporated herein by reference). More specifically, under some graceful restart techniques, a protocol may restart, but the node may continue forwarding data using existing forwarding information. If the restart of the protocol is not complete within a certain time however, the forwarding information may be considered too stale to be used. The fact that a node is restarting is known by a peer (e.g., an adjacent node), but is generally not distributed beyond peers so that the rest of the network is not aware that a node is restarting. This prevents a large number of nodes from updating network topology information, re-computing routes, and re-computing forwarding information when doing so may be unnecessary.","An exemplary format of extensions section  includes a list of type-length-value (TLV) triplets. Each TLV may include a Flags field , a Type field , a Length field  and a Value field . Each message type  defines the set of types it supports in Type field . That is, the message is parsed first in order to interpret Type. Each type defines its own flags found in Flags field . That is, Type field  is parsed first in order to interpret Flags field . Length field  indicates the length of Value field  in octets. Value field  is padded with octets of zero so that the total length of TLV is a multiple of four octets.","Extensions section  can have multiple TLV fields. If parsing the TLVs occurs beyond the end of message  (as defined by Length field  in common header ), it is assumed that the APFL message has been corrupted and is to be discarded. (Recall, e.g.,  of .)","Although the APFL packet and APFL message may be used to carry APFL information, alternatives are possible. Such alternatives may convey the status of multiple protocols in a compact form. In yet another alternative, the information may include interface forwarding liveness status information, without any protocol status information. In at least one embodiment, interface forwarding liveness status information may only convey whether the interface can forward data or not. In another embodiment, interface forwarding liveness status information may convey additional information such as (i) the integrity and correct operation of forwarding (route lookup) tables, (ii) the integrity and correct operation of switch fabric, (iii) the integrity and correct operation of a forwarding lookup engine, (iv) the integrity and correct operation of a traffic scheduler, (v) the integrity and correct operation of a traffic (flow) classifier, (vi) the integrity and correct operation of buffers in the data plane, (vii) the integrity and correct operation of packet segmentation modules, (viii) the integrity and correct operation of packet reassembly modules, (ix) the integrity and correct operation of packet re-sequencing modules, (x) whether or not a node is restarting, (xi) whether or not the forwarding plane is congested, (xii) the integrity and correct operation of fragmentation modules, (xiii) bit error rate at a link interface, (xiv) clock synchronization at a link interface, and\/or (xv) various quantitative values reflecting some quality of forwarding, or qualitative information derived therefrom. Alternatively, or in addition, interface forwarding liveness status information may convey when a data plane component is operating in a particular manner, such as at a predetermined capacity (e.g., buffers >75% full, N packets outstanding the switch fabric, etc.) Additional bits may be used to convey quantitative forwarding plane status information. Alternatively, or in addition, forwarding liveness status information may convey whether or not a link terminated by the interface can forward data, or whether or not the link can forward data under certain conditions.","\u00a74.2.3 Exemplary Neighbor APFL Information","Recall from  of  that received APFL information is checked against stored neighbor APFL information. Further recall from , , , , , ,  and  of  that such neighbor APFL information may be updated based on the expiration of a lost hello timer or based on newly received APFL information.  illustrates an exemplary data structure which may be used to store neighbor or peer information in a manner consistent with the principles of the invention. The neighbor or peer information may include a number of entries. Each entry may include a session field  (for storing session information ), a neighbor node identifier field  (for storing router ID information ), an interface index field  (for storing interface index information ), a last received sequence field  (for storing sequence number information  from the last received APFL message), a last received protocol registration field  (for storing protocol registry information  from the last received APFL message), a last received protocol status field  (for storing protocol status information  from a last received APFL message) and a lost hellos timer field  for storing the dead interval in the last received (or newest) APFL message.","\u00a74.2.4 Exemplary Apparatus",{"@attributes":{"id":"p-0061","num":"0063"},"figref":"FIG. 6","b":["600","600","610","630","620","640","632","634","630","610","620","630","600"]},"Machine  may be a router for example. In an exemplary router, processor  may include a microprocessor, a network processor, (e.g., custom) integrated circuits, or any combination of these. In the exemplary router, storage device  may include one or more ROM, RAM, SDRAM, SRAM, SSRAM, DRAM, flash drive, hard disk drive, flash card, other types of memory, or any combination of these. Storage device  may include program instructions defining an operating system (OS), a protocol module (e.g. daemon), other modules, or any combination of these. In one embodiment, methods of the invention may be performed by processor  executing stored program instructions (e.g., defining a part of the protocol module or daemon). At least a portion of the machine executable instructions may be stored (temporarily or more permanently) on storage device , may be received from an external source via an input\/output interface unit , or both. Finally, in the exemplary router, input\/output interface unit , input device  and output device  may include interfaces to terminate communications links.","Operations consistent with the principles of the invention may be performed on systems other than routers. Such other systems may employ different hardware, different software, or both. Exemplary machine  may include other elements in addition to, or in place of, the elements listed in  without departing from the principles of the invention. For example, there could be one or more additional processors, input devices, storage devices, etc. The components may be included on a single unit, or may be distributed over more than one unit.","\u00a74.2.5 Protocol Methods for Supporting APFL","Recall from  that each  of a number of protocol operations  may employ check status operations , down callback operations  and up callback operations  for purposes of \u201chooking\u201d APFL operations  with the protocols . Basically, one or more of protocol operations  may provide its status to APFL operations  (Recall, e.g.,  of ), and receive information about the status of each of its peers from APFL operations  (Recall, e.g., , , , , , and  of ).","In one embodiment of the invention, each of operations , ,  take two arguments\u2014the protocol P and the APFL neighbor Y. One exemplary status check operation \u2014Status_Check(P, Y)\u2014normally returns \u201cup,\u201d regardless of the current state of protocol P\u2032s adjacency with Y. Status_Check(P,Y) only returns \u201cdown\u201d when protocol P is not configured to run with neighbor Y; or if P is planning to go down shortly (graceful shutdown). If protocol P doesn't respond in a timely fashion to the Status_Check( ) query, APFL operations  may declare the status of protocol P as \u201cdown.\u201d In one exemplary down callback operations , a call Down(P, Y) should be treated by protocol P as if its regular hellos, if any, timed out. In one exemplary up callback operations , a call Up(P, Y) is generally ignored. The following sections provide protocol-specific details that may be implemented.","\u00a74.2.5.1 BGP v4","BGP should treat a Down(BGP, Y) callback just as if the Hold Timer of the session with neighbor Y had expired (See Section 6.5 of Rekhter, Y., and T. Li (Editors), \u201cA Border Gateway Protocol 4 (BGP-4)\u201d, RFC 1771, March 1995, incorporated herein by reference). Following a Down(BGP, Y) call, BGP may re-establish peers as usual. BGP should ignore Up(BGP, Y) callbacks.","\u00a74.2.5.2 IS-IS, OSPF v2 and OSPF v3","IS-IS, OSPF v2 and OSPF v3 should treat a Down(P, Y) callback (where P is one of IS-IS, OSPFv2 or OSPFv3) just as they would loss of hellos from neighbor Y. Following a Down(P, Y) callback, IS-IS, OSPF v2 and OSPF v3 should re-establish adjacencies as usual. IS-IS, OSPF v2 and OSPF v3 should ignore Up( ) callbacks.","\u00a74.2.5.3 RIP v1, RIP v2 and RIP ng","RIP should respond to a Down(P, Y) callback (where P is one of RIPv1, RIPv2 or RIP-ng) by immediately deleting all RIP routes received from Y, as if the \u201ctimeout\u201d timer in Section 3.8 of Malkin, G., \u201cRIP Version 2\u201d, STD 56, RFC 2453, November 1998 (or section 2.3 of Malkin, G., \u201cRIPng for IPv6\u201d, RFC 2080, January 1997, both incorporated herein by reference, expired for all those routes. RIP should ignore Up( ) callbacks.","\u00a74.2.5.4 RSVP","RSVP should respond to a Down(RSVP, Y) callback just as it would loss of hellos from neighbor Y, or some other indication that either Y or the interface to Y is no longer working. Following a Down(RSVP, Y) callback, RSVP should attempt to re-establish the state that it had held for neighbor Y by following its normal protocol operation. RSVP should ignore Up( ) callbacks.","\u00a74.2.5.5 Forwarding Liveness","As described earlier, APFL can be used to communicate, to a neighbor, one's ability to forward packets from or to a given interface, and to learn about a neighbor's ability for the same. An interface receiving a Down(P, Y) callback (where P is \u2018forwarding liveness\u2019) should inform all modules (such as routing protocols) interested in the forwarding capability status of neighbor Y that Y is no longer capable of forwarding packets received over the communication link attached to that interface. An interface receiving an Up(P, Y) callback should inform the modules interested in the forwarding capability status of neighbor Y that Y can forward packets received over the communication link attached to that interface.","\u00a74.2.6 Interface Methods for Supporting APFL","Without any protocols registered, APFL operations  can act as an interface liveness protocol for interfaces. Thus, the principles of the invention may be applied to test the liveness of interfaces that don't have layer 2 liveness mechanisms, such as Ethernet, and other interfaces whose layer 2 liveness mechanisms may be considered too slow for some purposes, such as the point-to-point protocol (PPP) for example. Recall from  that each  of a number of interface operations  may employ check status operations , down callback operations  and up callback operations  for purposes of \u201chooking\u201d aggregated liveness determination operations  with the interfaces .","For PPP interfaces, a Down(Layer-2, Y) callback should be ignored unless the PPP is in state 9 (\u201copened\u201d) for the interface. If the Down callback is received while in state 9, the following actions should be taken: (i) declare \u201cThis-Layer-Down\u201d; (ii) send a Configure Request, and (iii) transition to state 6 (in the notation of Section 4.1 of Simpson, W., (Editor), \u201cThe Point-to-Point Protocol (PPP)\u201d, STD 51, RFC 1661, July 1994, incorporated herein by reference. Up(Layer-2, Y) callbacks should be ignored on PPP interfaces.","Ethernet interfaces are a bit more complicated since they are multipoint interfaces. A Down(Layer-2, Y) callback should tell all modules interested in the layer-2 status of the interface (such as routing protocols, SNMP agents, etc.) that neighbor Y is no longer reachable, and appropriate action should be taken. For example, a routing protocol may recompute routing information to no longer use this interface. An implementation may declare that the Ethernet interface is itself down; however, this behavior should be configurable. An Up(Layer-2, Y) callback should tell all modules that neighbor Y is again reachable (or that the Ethernet interface is up).","\u00a74.2.6.1 Forwarding Liveness","Although forwarding liveness can be thought of as a protocol to be included in the protocol registration and status bit vectors, interface forwarding liveness status may be tracked and communicated independently of protocol status information. Such interface forwarding liveness status information may be used to communicate, to a neighbor, one's ability to forward packets from or to a given interface, and to learn about a neighbor's ability for the same. As was the case when this forwarding liveness status information is included with status information of protocols, an interface receiving a Down(P, Y) callback (where P is \u2018forwarding liveness\u2019) should inform all modules (such as routing protocols) interested in the forwarding capability status of neighbor Y that Y is no longer capable of forwarding packets received over the communication link attached to that interface. An interface receiving an Up(P, Y) callback should inform the modules interested in the forwarding capability status of neighbor Y that Y can forward packets received over the communication link attached to that interface.","\u00a74.2.7 Configuration","Recall from  that configuration operations  may be used to set a hello interface , a {dead interval, neighbor node} pair  and protocols, interfaces, or both using the aggregated liveness determination operations . In one exemplary implementation of the invention, the number of Hellos sent every Dead Interval  is limited. This limit should override any of what follows. Also, the Hello Interval  time and Dead Interval  can be set subject to some minimum limits. For example, in some implementations, although Hello Intervals  and Dead Intervals  may defined in microseconds, it may be desirable to set minimum limits of about 100 milliseconds, at least until there is sufficient operational experience to indicate that smaller intervals (e.g., 10 milliseconds) are scalable for the particular application in which the invention is used. One useful consequence of APFL operations  is that the times of \u201cnormal\u201d hellos (that is, hellos still used by the underlying protocols) can be made longer. The hello time should be no longer than the dead interval, and may be one-third, one-fourth or less of the dead time interval.","If the Hello Interval  or Dead Interval  change, APFL operations  may issue a Hello before hello timer T expires. If the protocols\/interfaces using aggregated liveness  to be reported on are changed such that the new set of protocols, interfaces, or both to be reported on is a superset of the old, APFL operations  may issue a Hello before hello timer T expires. However, if there is any other change in the protocols\/interfaces using aggregated liveness  to be reported on, APFL operations  should issue a Hello as soon as is reasonable. Moreover, multiple copies of this Hello should be issued to improve the chances of the neighbors receiving it correctly.","Configuration operations  should also permit authorized users to turn off reporting on any given protocol. Configuration operations  may also allow users to turn off running APFL operations over any given interface, or to any given neighbor node.","If APFL operations  can register to be notified by a protocol when the protocol's status changes, on receiving such a notification with a status transition from up to down, APFL operations  should rebuild the Hello with the latest values, and send it out as soon as is reasonable. If the status transition is down to up, APFL operations  may rebuild and send out a Hello before the timer T expires.","\u00a74.2.8 Aggregating Protocol Liveness Determinations with Protocols Supporting and\/or Running Graceful Restart","Graceful Restart (See, e.g., Sangli, S., Y. Rekhter, R. Fernando, J. Scudder and E. Chen, \u201cGraceful Restart Mechanism for BGP\u201d, work in progress; Berger, L., (Editor), \u201cGeneralized Multi-Protocol Label Switching (GMPLS) Signaling Resource ReserVation Protocol-Traffic Engineering (RSVP-TE) Extensions\u201d, RFC 3473; Shand, M., \u201cRestart signaling for ISIS\u201d, work in progress. Leelanivas, M., Y. Rekhter, and R. Aggarwal, \u201cGraceful Restart Mechanism for LDP\u201d, work in progress; Farrel, A. (Editor), \u201cFault Tolerance for the Label Distribution Protocol (LDP)\u201d, work in progress; and Moy, J., P. Pillay-Esnault, and A. Lindem, \u201cHitless OSPF Restart\u201d, work in progress, all incorporated herein by reference), also known as Hitless Restart, allows a protocol to restart while leaving the forwarding path undisturbed. If a node X and its neighbors can restart gracefully, it is not quite as urgent for X's neighbors to learn when X goes down. However, the principles of the invention can be used to assist the graceful restart process by, for example, pinpointing the time that the restarting protocol of node X goes down more accurately. This information can be used, for example, to begin restart procedures, and to permit more precise estimates of when to declare that (the protocol restarting on) node X is beyond recovery.","\u00a74.2.9 Security Considerations","APFL messages should be authenticated, because spoofing or replaying APFL messages may deceive a router about the state of all its protocol peers. Encrypting the contents of APFL messages is not as important, although doing so may be useful in certain applications. In any event, since the invention mainly serves to provide more frequent liveness information (e.g., via more frequent hellos), a part of which is achieved by minimizing processing overhead, adding strong authentication systems may impose severe processing burdens.","\u00a74.3 Illustrative Example",{"@attributes":{"id":"p-0093","num":"0095"},"figref":"FIG. 7","b":["710","770","730","780","750","712","710","732","730","752","750","714","710","734","730","754","750","710","716","724","728","730","750","736","756","722","724","712","714","716","722","724","726","728","712","714","716","744","742","732","734","736","764","762","752","754","756"]},"In the following example, it is assumed that liveness operations  on node A  sends liveness information about protocols S  and T  to node B . Thus, node A  acts as a sender and node B  acts as a receiver. Of course, when node B  acts as a sender, node A  will act as the receiver. It is assumed that the liveness operation  can access the protocol status of the protocols and interfaces that it has been configured to report on, as well as report back to the protocols any received change of state.","\u00a74.3.1 Sender Processing","Recall that the left branch of  illustrated an exemplary implementation of APFL sender processing. Suppose liveness operation  is configured to run with neighbor node B  with Dead Interval D (microseconds), Hello Time H (microseconds), and to report on protocols S, T, . . . . Note that H is local to a node\u2014this value is not transmitted to APFL neighbors. Also, H should be at most D. Typically, however, H would be D\/3 or D\/4. Node B  is a directly attached neighbor to node A  as indicated by interface A-B . In this example, an exemplary implementation consistent with the principles of the invention may operate as follows.","(Step 0): Liveness operation  creates an appropriate IP header.","(Step 1): Liveness operation  creates a Common Header with: R field  set to 0 if node B  is directly attached, else 1. Version field  is set to 1. Length field  is set to 28. Message Type field  is set to 1 (Hello). Interface Index field  is set to <index of interface A-B  or zero>. Common Header will not change unless the interface index of interface A-B  changes.","(Step 2): Liveness operation  creates a protocol registry vector PRV that consists of the bits corresponding to the configured protocols S, T . . . set and the leaves the rest unset. Liveness operation  queries each configured protocol for its status with neighbor node B , and creates a protocol status vector PSV. Finally, liveness operation  creates a Hello message with Session field  set to 0, Dead Interval field  set to D, Sequence Number field  set to <monotonically increasing number>, protocol registry field  set to PRV, protocol status field  set to PSV, builds an APFL packet with common header and Hello message , and sends it to the ALL-APL-ROUTERS multicast address. (Recall, e.g., the left branch in .)","(Step 3): Liveness operation  then sets a timer T to expire in H microseconds, and goes to sleep. (Recall, e.g.,  of .) When timer T expires, liveness operation  goes back to Step 1. Every time liveness operation  sends a Hello, it restarts the timer T (with the latest value of H).","\u00a74.3.2 Receiver Processing","Recall that the middle and right branches of  illustrated an exemplary implementation of APLF receiver processing. In the following, it is assumed that liveness operation  receives an APFL message from node B . Liveness operation  maintains a table of APFL neighbors keyed by <APFL Session, IP address, Interface Index>, and that contains:",{"@attributes":{"id":"p-0103","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field","Type","Initial Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Last_Received_Sequence_Number","64-bit integer","0"]},{"entry":["Last_Received_Protocol_Registry","32-bit vector","0"]},{"entry":["Last_Received_Protocol_Status","32-bit vector","all \u201cdown\u201d"]},{"entry":["Lost_Hellos_Timer","time","stopped"]},{"entry":"(Recall, e.g., FIG. 5.)"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"When liveness operation  gets an APFL packet, it may decide, for example based on configuration or rate-limiting, to discard the packet. (Recall, e.g.,  of .) Otherwise, liveness operation  does the following:"}}}},"(Step 0): Sanity-check the packet. (Recall, e.g.,  of ).","(Step 1): Identify the APFL neighbor B by looking up the key","<Session, Source IP Address, Interface Index> in a table. (Recall, e.g.,  of .) If no entry is found, liveness operation  may either discard the packet, or create a new entry for the key, with initial values as in the table above. (Recall, e.g.,  of .)","(Step 2): Liveness operation  may then check that the received Sequence Number is larger than the Last_Received_Sequence_Number for this key (Recall, e.g.,  of .). If not, it discards the packet. (Recall, e.g., .) Otherwise, it updates Last_Received_Sequence_Number, sets New_Registry to the received Protocol Registry, and sets New_Status to the received protocol status.","(Step 3): If New_Registry==Last_Received_Protocol_Registry, go to Step 4 below. Otherwise, for each protocol P that is in New_Registry and not in Last_Received_Protocol_Registry (added protocol):","set Last_Received_Protocol_Status[P] to down;","if (New_Status[P]==up)","call Up(P, B)","else","call Down(P, B)","(Recall, e.g., loop - of .) For each protocol P that is in Last_Received_Protocol_Registry and not in New_Registry (deleted protocol):\n\n","(Step 4): If the New_Status !=Last_Received_Protocol_Status\n\n","(Step 5): Set Last_Received_Sequence_Number=received Sequence Number; Last_Received_Protocol_Registry=New_Registry. (Recall  of .)","(Step 6): Reset the Lost_Hellos_Timer to fire after the received Dead Interval. (Recall  of .)","(Step 7): Done processing APFL Hello.","If the Lost_Hello_Timer fires, call Down(P, B) for each protocol P that is set in Last_Received_Protocol_Registry for node B  (Recall, e.g., loop - of ), and stop the timer. (Recall, e.g.,  of .)","Down(P, B) invokes protocol P\u2032s Down callback, and sets Last_Received_Protocol_Status[P] to down. Up(P, B) invokes protocol P\u2032s Up Callback. The number of times this callback is actually propagated to the protocol should be subject to some maximum limit. If Up(P, B) is sent to protocol P, then liveness operation  sets Last_Received_Protocol_Status[P] to up.","\u00a74.4 Conclusions","As can be appreciated from the foregoing disclosure, the principles of the invention may comprise elements, apparatus, systems, data structures, computer-implemented code and methods for permitting the liveness of various protocols to be determined quickly, in a scalable manner (e.g., in terms of message size, total message frequency and processing overhead). By providing a small number of bits per protocol, which relay a simple set of information (such as up, down, not reporting, restarting, etc.), a compact, simple message may be used for conveying liveness-related information. Since the messages are small and can aggregate information from more than one protocol, they can be sent frequently. Normal operations of the protocols, such as normal hellos, are not affected, but may be relaxed (i.e., run less frequently). Moreover, the APFL messages and processing of such messages are not subject to the constraints of the protocols being monitored. Furthermore, interface forwarding liveness status information may be included with the protocol status information, or may be provided independent of protocol status information.","The foregoing description of embodiments consistent with the principles of the invention provides illustration and description, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example, although a series of acts may have been described with reference to a flow diagram, the order of acts may differ in other implementations when the performance of one act is not dependent on the completion of another act. Further, non-dependent acts may be performed in parallel.","No element, act or instruction used in the description should be construed as critical or essential to the invention unless explicitly described as such. Also, as used herein, the article \u201ca\u201d is intended to include one or more items. Where only one item is intended, the term \u201cone\u201d or similar language is used. The scope of the invention is defined by the claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"\u00a73. BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIGS. 3A and 3B"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
