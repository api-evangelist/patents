---
title: Asynchronous conditional graphics rendering
abstract: A graphics processing unit implements conditional rendering by putting itself in a state in which it does not execute any rendering commands. Once the graphics processing unit is placed in this state, all subsequent rendering commands are ignored until another rendering command explicitly removes the graphics processing unit from this state. Conditional rendering commands enable the graphics processing unit to place itself in and out of this state based upon the value of a flag in memory. Conditional rendering commands can include conditions that must be satisfied by the flag value in order to change the state of the graphics processing unit. The value of the flag can be set by the graphics processing unit itself, a second graphics processing unit, a graphics coprocessor, or the central processing unit. This enables a wide variety of conditional rendering methods to be implemented.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07388581&OS=07388581&RS=07388581
owner: NVIDIA Corporation
number: 07388581
owner_city: Santa Clara
owner_country: US
publication_date: 20030828
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to the field of computer graphics. Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional scene from a given viewpoint. This process, called rendering, generates a two-dimensional image of the scene from the given viewpoint, and is analogous to taking a photograph of a real-world scene.","As the demand for computer graphics, and in particular for real-time computer graphics, has increased, computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems, the rendering process is divided between a computer's general purpose central processing unit (CPU) and the graphics processing subsystem. Typically, the CPU performs high level operations, such as determining the position, motion, and collision of objects in a given scene. From these high level operations, the CPU generates a set of rendering instructions and data defining the desired rendered image or images. For example, rendering instructions and data can define scene geometry, lighting, shading, texturing, motion, and\/or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering instructions and data.","To maximize rendering performance, it is generally desirable for the CPU and graphics processing subsystem to execute the minimum number of operations necessary to render the images. Geometry culling optimizes the number of rendering operations by bypassing rendering operations for geometry and objects that are not visible in a scene. Typically, geometry culling performs one or more visibility tests on the geometry or object to be rendered. If the visibility test fails, the geometry or object will not be visible in the final rendered image; thus, rendering of the object can be bypassed. Conversely, if the geometry or object passes the visibility test, the object or geometry must be rendered (though the object may turn out to be hidden in the final rendered image). A number of different visibility tests of varying complexity and accuracy exist.","Conditionally rendering objects and geometry in a graphics processing subsystem presents a number of difficulties. First, the visibility of one object is often dependent upon other objects within a scene. Previously, it has been difficult for a graphics processing subsystem to use the results from rendering one object to conditionally render a subsequent object. Second, it is difficult for the CPU to assist the graphics processing subsystem in conditionally rendering objects. Typically, the CPU and graphics processing subsystem operate asynchronously to maximize performance. Once the scene description (a collection of rendering commands) is sent to the graphics processing subsystem, it is very hard for the CPU, in response to a visibility test, to intervene and cancel some of the rendering commands.","Third, completely CPU-based culling solutions are difficult and time-consuming to implement. For example, applications can use vertex shader programs to modify geometry positions. A CPU-based culling solution would be required to fully execute a vertex shader in order to determine whether or not a block of geometry can be culled. This would effectively eliminate any potential benefits from graphics processing subsystem accelerated geometry processing as the graphics processing subsystem would effectively be bottlenecked by the CPU's ability to execute vertex programs on geometric data. In addition, computation of vertex programs on the CPU steals cycles that could be used for application computations such as AI and physics calculations.","It is therefore desirable for a graphics processing subsystem to perform conditional rendering efficiently without assistance from the CPU. It is further desirable to seamlessly integrate the conditional rendering capabilities of the GPU with the CPU or other graphics processing subsystems, such as a second GPU or a graphics coprocessor, to perform more complicated visibility determinations.","An embodiment of the invention implements conditional rendering by putting the graphics processing unit in a state in which it does not execute any rendering commands. Once the graphics processing unit is placed in this state, all subsequent rendering commands are ignored until another rendering command explicitly removes the graphics processing unit from this state. Conditional rendering commands enable the graphics processing unit to place itself in and out of this state based upon the value of a flag in memory. Conditional rendering commands can include conditions that must be satisfied by the flag value in order to change the state of the graphics processing unit. The value of the flag can be set by the graphics processing unit itself, a second graphics processing unit, a graphics coprocessor, or the central processing unit. This enables a wide variety of conditional rendering methods to be implemented.","An embodiment of the invention is a method for conditionally executing a rendering command by a graphics processing unit. In this embodiment, the graphics processing unit receives a conditional rendering command. In response to the conditional rendering command, the graphics processing unit retrieves a flag value. The graphics processing unit also receives a rendering command, and in response to the flag value, will disregard the rendering command.","In a further embodiment, the graphics processing unit disregards the rendering command in response to the flag value satisfying a condition. In one implementation, the condition is specified by the conditional rendering command. For example, a condition may be satisfied when the flag value matches a predetermined value, when the flag value is greater than a predetermined value, or when the flag value is less than a predetermined value.","In another embodiment, the graphics processing unit retrieves the flag value from a memory location. The memory location can be accessed using a memory address or a memory handle. In one implementation, the conditional rendering command specifies the memory location.","In yet another embodiment, the graphics processing unit receives a second conditional rendering command and a second rendering command. In response to the second conditional rendering command, the graphics processing unit executes the second rendering command. In an alternate embodiment, the graphics processing unit receives a second rendering command and executes the second rendering command when the second rendering command changes a state of the graphics processing unit.","In still another embodiment, the flag value is the result of a visibility determination of an object associated with the rendering command. In one implementation, the graphics processing unit determines the visibility of the object and stores a flag value in response to the result of the visibility determination of the object prior to receiving the conditional rendering command. In an embodiment, the flag value is a rendered pixel count. For example, the graphics processing unit may determine the visibility using a bounding box associated with the object, or by using a first rendering pass of the object. In alternate implementations, a second graphics processing unit, a graphics coprocessor, or central processing unit determines the visibility of the object and stores a flag value in response to the result of the visibility determination of the object.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","105","105","110","105","115","120","100","125","100","100","105","110","115","120","125","160"]},"A graphics subsystem  is further connected with data bus  and the components of the computer system . The graphics subsystem  includes a graphics processing unit (GPU)  and graphics memory. Graphics memory includes a display memory  (e.g., a frame buffer) used for storing pixel data for each pixel of an output image. Pixel data can be provided to display memory  directly from the CPU . Alternatively, CPU  provides the GPU  with data and\/or commands defining the desired output images, from which the GPU  generates the pixel data of one or more output images. The data and\/or commands defining the desired output images is stored in additional memory . In an embodiment, the GPU  generates pixel data for output images from rendering commands and data defining the geometry, lighting, shading, texturing, motion, and\/or camera parameters for a scene.","In another embodiment, display memory  and\/or additional memory  are part of memory  and is shared with the CPU . Alternatively, display memory  and\/or additional memory  is one or more separate memories provided for the exclusive use of the graphics subsystem . The graphics subsystem  periodically outputs pixel data for an image from display memory  and displayed on display device . Display device  is any device capable of displaying visual information in response to a signal from the computer system , including CRT, LCD, plasma, and OLED displays. Computer system  can provide the display device  with an analog or digital signal.","In a further embodiment, graphics processing subsystem  includes one or more additional GPUs , similar to GPU . In an even further embodiment, graphics processing subsystem  includes a graphics coprocessor . Graphics processing coprocessor  and additional GPUs  are adapted to operate in parallel with GPU . Additional GPUs  generate pixel data for output images from rendering commands, similar to GPU . Additional GPUs  can operate in conjunction with GPU  to simultaneously generate pixel data for different portions of an output image, or to simultaneously generate pixel data for different output images. In an embodiment, graphics coprocessor  performs rendering related tasks such as geometry transformation, shader computations, and backface culling operations for GPU  and\/or additional GPUs .","Additional GPUs  can be located on the same circuit board as GPU  and sharing a connection with GPU  to data bus , or can be located on additional circuit boards separately connected with data bus . Additional GPUs  can have their own display and additional memory, similar to display memory  and additional memory , or can share memories  and  with GPU . In an embodiment, the graphics coprocessor  is integrated with the computer system chipset (not shown), such as with the Northbridge chip used to control the data bus .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","205","210","205","210","215","215","205","210","215","110","215","205"]},"Command buffer  stores sets of rendering commands, such as rendering command , and sets of rendering data, such as rendering data . In one embodiment, a rendering command is associated with rendering data. The rendering command defines the set of rendering processes to be performed by the GPU on an associated rendering data. In a further embodiment, the rendering data is stored in the command buffer  adjacent to the corresponding rendering command.","The CPU  writes rendering commands and data sets to the command buffer . The command buffer  can include a number of rendering commands and data sets. The CPU  writes commands and data sets into the command buffer  at the location determined by \u201cput\u201d pointer . Following each CPU write into the command buffer , the CPU  increments the put pointer  to the next unused location in the command buffer . In an embodiment, a driver software program executed by the CPU  translates high-level rendering commands from a rendering application into commands and data sets, which are then written into the command buffer . In a further embodiment, the driver software program receives high-level rendering commands via an application programming interface, for example DirectX\u2122 or OpenGL\u2122.","The GPU  reads commands and data sets from the command buffer . The GPU  reads commands and data sets from the command buffer  at the location determined by \u201cget\u201d pointer . Following each GPU read from the command buffer , the GPU  increments the get pointer  to the location of the next command or data set in the command buffer .","The CPU  and GPU  can access the command buffer independently. In an embodiment, the CPU  periodically adds new commands and data sets to the command buffer . Simultaneously, the GPU  reads processes commands and data sets previously stored by the CPU  continuously. Provided the CPU  stays sufficiently far ahead of the GPU , the GPU  is able to render images without any idle time waiting for the CPU . In an embodiment, the CPU  writes commands and data sets for frames several frames ahead of the frame being rendered by the GPU .","In an embodiment, the command buffer is limited in size. As an example, a typical command buffer is five megabytes in size. When either the get pointer  or put pointer  reaches the end of the command buffer , the pointer is reset to the location of the beginning of the command buffer . In this manner, the command buffer  \u201cwraps around,\u201d enabling the CPU and GPU to access the command buffer  in a continuous loop.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","b":["305","310","315","320","330","330","325","300"]},"Upon retrieving RCB command , GPU  reads the value of a flag  stored in memory. In an embodiment, the flag  is stored in main system memory. In an alternate embodiment, flag  is stored in memory associated with the GPU . In an embodiment, RCB command  specifies the location of the flag . The location of flag  can be specified by all or part of a memory address, or alternatively by a memory handle. A memory handle typically is an index value into an array of memory pointers. Each array element points to the memory location containing the flag value.","In response to the value of flag , the GPU  either executes or ignores the rendering commands  between the RCB  and RCE  commands. It should be noted that the RCB command instructs the GPU  only to ignore rendering commands resulting in rendering output. Regardless of the value of flag , the GPU  will continue to process rendering commands determining program flow, such as jumping and branching operations, setting the state of the GPU , and other commands, such as additional RCB and RCE. This ensures that the GPU maintains a consistent operating state regardless of the value of the flag . In an embodiment, the GPU  will evaluate the value of flag  according to a condition specified by the RCB command  to determine whether to execute the set of rendering commands . The RCB command  can specify a number of different conditions that can be used for this determination.","For example, RCB command  can specify a \u201cEQUAL\u201d condition, which instructs the GPU  to render commands  if the flag  is equal to a number specified by RCB command . Similarly, RCB command  can specify a \u201cLESS THAN\u201d or \u201cGREATER THAN\u201d condition, which instructs the GPU  to render commands  if the flag  is less than or greater than, respectively, a number specified by RCB command . In a further embodiment, RCB command  can specify a \u201cFALSE\u201d condition, which instructs the GPU  to ignore rendering commands  regardless of the value of the flag , and a \u201cTRUE\u201d condition, which instructs the GPU  to execute any subsequent rendering commands until instructed otherwise, such as via another RCB command. In an embodiment, an RCE command  is equivalent to an RCB command with a \u201cTRUE\u201d condition.","As discussed below, the flag  can be set by the GPU , a second GPU or graphics coprocessor operating in parallel with GPU , or by the CPU running a rendering application or a device driver. The flexibility in setting the value of flag  enables the implementation of a number of different conditional rendering operations.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","400","405","410","400","410","415","420","425","420","425","425","415","410","400","420","425","420","425","420"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIG. 5A"]},"A command buffer  includes a sequence of rendering commands for execution by the GPU. A pixel count render begin (PCB) command  instructs the GPU to process subsequent rendering commands without writing to any color, depth, or alpha buffers, effectively making the subsequent rendering commands \u201cinvisible.\u201d However, the GPU will compare the output of subsequent rendering commands with the view frustum, the depth buffer, and any other visibility tests, such as a stencil buffer, as if the subsequent rendering commands were actually rendering to the color buffer. Additionally, the GPU still counts the number of pixels that would have been rendered to color buffer.","Following PCB command , rendering commands  defining a bounding box for an object are processed by the GPU. Because rendering commands  were preceded by PCB command , the bounding box will be rendered by the GPU, but not written to the color buffer or the depth buffer.","Following rendering commands , a pixel count render end (PCE) command  re-enables writes to the color and depth buffer, so that subsequent rendering commands will be rendered normally. PCE command  additionally writes the rendered pixel count (RPC) , which is the number of visible pixels, resulting from the rendering to flag . In an embodiment, PCE command  specifies the location of flag  using all or part of a memory address, or alternatively by a memory handle. If the RPC is zero following the processing of rendering commands , then the bounding box is completely obscured in the rendered scene; therefore, the object associated with the bounding box does not need to be rendered. In an alternate embodiment, rendering of an object is skipped if only a small number of pixels of the bounding box are visible.","The rendered pixel count value  stored in flag  can be used to enable or disable rendering of the object associated with the bounding box. A render conditional begin (RCB) command , similar to that described above, retrieves the value of flag . The RCB command  includes a condition adapted to disable rendering if the flag equals a given value, such as \u201cEQUALS 0.\u201d If the value of the flag  satisfies this condition, then the GPU will ignore rendering commands , which define the object associated with the bounding box. This results in the object not being rendered by the GPU. Conversely, if the value of flag  does not satisfy the condition specified by RCB , rendering commands  will be processed normally by the GPU, resulting in the rendering of the object. A RCE command  follows rendering commands  to re-enable all rendering regardless of the value of the flag .","In this manner, an object will not be rendered when its associated bounding box is not visible. An advantage of this implementation is that all of the commands in command buffer  can be sent to the GPU by the rendering application or device driver well in advance of the actual rendering. Neither the rendering application or device driver need to determine the visibility of the object, nor do they need to intervene during rendering to cancel unnecessary rendering commands.","For some rendering applications, two or more rendering passes are needed to render an object. For example, a first rendering pass may be used to fill a depth buffer and a stencil buffer. The values of the depth and stencil buffers are then used for a second rendering pass to fill a color buffer with the correct lighting and shading values for the objects.  illustrates another implementation of conditional rendering in which multiple rendering passes are used to determine an objects visibility.","A command buffer  includes a sequence of rendering commands for execution by the GPU. A z-pass render begin (ZPB) command  instructs the GPU to process subsequent rendering commands writing only to the depth buffer. This enables the GPU to fill the depth buffer with the appropriate values to be used in a second rendering pass for lighting and shading.","Following ZPB command , rendering commands  defining an object are processed by the GPU. Because rendering commands  were preceded by ZPB command , the object will be rendered by the GPU to the depth buffer, but not to the color buffer. Additionally, the GPU still counts the number of pixels rendered to depth buffer.","Following rendering commands , a z-pass render end (ZPE) command  re-enables writes to the color buffer, so that subsequent rendering commands will be rendered normally. ZPE command  additionally writes the rendered pixel count (RPC) , which is the number of visible pixels, resulting from the rendering to flag . In an embodiment, ZPE command  specifies the location of flag  using all or part of a memory address, or alternatively by a memory handle. If the RPC is zero following the processing of rendering commands , then the object is completely obscured in the rendered scene; therefore, the object does not need to be rendered for the second rendering pass.","The rendered pixel count value  stored in flag  can be used to enable or disable rendering of the object in the second rendering pass. A render conditional begin (RCB) command , similar to that described above, retrieves the value of flag . The RCB command  includes a condition adapted to disable rendering if the flag equals a given value, such as \u201cEQUALS 0.\u201d If the value of the flag  satisfies this condition, then the GPU will ignore rendering commands , which define the rendering of the object for the second rendering pass. This results in the object not being rendered by the GPU for the second rendering pass. Conversely, if the value of flag  does not satisfy the condition specified by RCB , rendering commands  will be processed normally by the GPU, resulting in the rendering of the object with its lighting and shading. A RCE command  follows rendering commands  to re-enable all rendering regardless of the value of the flag .","In this manner, an object will not be rendered in a second rendering pass when its is not visible in the first rendering pass. An advantage of this implementation is that all of the commands in command buffer  can be sent to the GPU by the rendering application or device driver well in advance of the actual rendering. Neither the rendering application or device driver need to determine the visibility of the object, nor do they need to intervene during rendering to cancel unnecessary rendering commands. Additionally, bounding boxes do not need to be created for each object. Moreover, because lighting and shading calculations in the second rendering pass can be very time-consuming compared with the rendering of depth only in the first rendering pass, the performance improvements from this implementation can be very substantial.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6","b":["620","615","630","625","635","600","625","630","635","615","620"]},"While GPU  is processing the commands preceding RCB command , the CPU performs a visibility determination  of the object. Any type of visibility algorithm can be used for the visibility determination , such as bounding boxes, frustum culling, octrees, or binary space partitioning (BSP) trees. Because the visibility determination  is performed by the CPU , rather than the GPU , complicated or highly specialized visibility algorithms can employed that would normally be impractical to implement with the GPU  alone.","Following the completion of the visibility determination  for an object, the CPU writes a value to the flag . The value written to flag  indicates the result of the visibility determination . For example, a zero may indicate that the object is not visible, while a non-zero value may indicate that the object is visible.","Upon executing RCB command , the GPU  retrieves the value of the flag . As discussed above, the RCB command  specifies the location of flag  using all or part of a memory address, or alternatively by a memory handle. This location is determined in advance when the CPU  sends the RCB command  to the command buffer . In response to the value of the flag , the GPU  will either ignore or execute rendering commands . Following rendering commands , a RCE command  re-enables all rendering regardless of the value of the flag .","In a further embodiment, the GPU  and CPU  operate asynchronously. In this embodiment, there is no way to ensure that the CPU finishes the visibility determination  and writes the appropriate value to the flag  prior to the GPU  executing the RCB command . To ensure that the final rendered image is always correct, the CPU  sets the flag  to an initial default value at the same time the RCB command  is sent to the command buffer . The initial default value is set so that the GPU  will execute rendering commands . If the GPU then executes RCB command  prior to the completion of the visibility determination , the value of the flag  will indicate that rendering commands  should be executed. If the CPU  finishes the visibility determination  prior to the execution of RCB command  and the object is not visible, then the CPU will change the value of the flag  so that the GPU will ignore rendering commands .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 7","b":["700","705","705","715","710","720"]},"While GPU  is processing the commands preceding RCB command , a second GPU or graphics coprocessor  operates in parallel to execute commands from command buffer . Command buffer  includes a set of rendering commands  defining either a copy of the object or a bounding box associated with the object. The set of rendering commands  is surrounded by PCB  and PCE  commands. The purpose of commands  and  is to determine the visibility of the object or bounding box rendered by the set of rendering commands . This is done by tracking the number of rendered pixels resulting from the execution of rendering commands . In an embodiment, other commands tracking the number of rendered pixels, such as the ZPB and ZPE commands discussed above, can be used for commands  and .","Following the completion of the visibility determination for the object or bounding box, the second GPU or graphics coprocessor  writes a value to the flag . Command  or  specifies the location of flag  using all or part of a memory address, or alternatively by a memory handle. The value written to flag  indicates the result of the second GPU or graphics coprocessor's  visibility determination. For example, a zero may indicate that the object is not visible, while a non-zero value may indicate that the object is visible.","Upon executing RCB command , the GPU  retrieves the value of the flag . As discussed above, the RCB command  specifies the location of flag  using all or part of a memory address, or alternatively by a memory handle. This location is determined in advance when the CPU programs both GPU  and GPU or graphics coprocessor . In response to the value of the flag , the GPU  will either ignore or execute rendering commands . Following rendering commands , a RCE command  re-enables all rendering regardless of the value of the flag .","In a further embodiment, the GPU  and GPU or graphics coprocessor  operate asynchronously. In this embodiment, there is no way to ensure that the second GPU or graphics coprocessor finishes the visibility determination and writes the appropriate value to the flag  prior to the GPU  executing the RCB command . To ensure that the final rendered image is always correct, the flag  is set to an initial default value at the same time the RCB command  is sent to the command buffer . The initial default value is set so that the GPU  will execute rendering commands . If the GPU or graphics coprocessor  finishes the visibility determination prior to the execution of RCB command  by GPU  and the object is not visible, then the value of the flag  will be changed so that the GPU  will ignore rendering commands .",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIGS. 8A and 8B","FIG. 8A"],"b":["800","805","810","805","815","810","820","800","815","820","800","805","810","815","820"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 8B","FIG. 8A"],"b":["820","820","800","800","830"]},"A RCB command at the beginning of the command set  reads the value of flag . If the value of the flag  indicates that bounding box  is not visible, for example if flag  equals zero, the GPU ignores the remaining commands in command set . This results in the objects  and  not being rendered.","Conversely, if the value of flag  indicates that bounding box  is visible, command set  determines the visibility of bounding box , in a manner similar to command set . The results of the visibility determination of bounding box  are written to flag . A RCB command at the beginning of the command set  reads the value of flag . If the value of the flag  indicates that bounding box  is not visible, the GPU ignores the remaining commands in command set . This results in the object  not being rendered. Otherwise, object  is rendered.","Regardless of the value of flag , command set  determines the visibility of bounding box , in a manner similar to command sets  and . The results of the visibility determination of bounding box  are written to flag . A RCB command at the beginning of the command set  reads the value of flag . If the value of the flag  indicates that bounding box  is not visible, the GPU ignores the remaining commands in command set . This results in the object  not being rendered. Otherwise, object  is rendered.","It should be noted that each flag can be addressed using a memory address or memory handle specified by the RCB and PCE or ZPE commands, as described above. In an alternate embodiment, the visibility of one or more of the bounding boxes can be determined using the implementations discussed in  or .","This invention provides a system for performing conditional rendering efficiently without assistance from the CPU. It is further allows for seamless integration of the conditional rendering capabilities of the GPU with the CPU or other graphics processing subsystems, such as a second GPU or a graphics coprocessor, to perform more complicated visibility determinations. Although the invention has been discussed with respect to specific examples and embodiments thereof, these are merely illustrative, and not restrictive, of the invention. Thus, the scope of the invention is to be determined solely by the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be described with reference to the drawings, in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 8A and 8B"}]},"DETDESC":[{},{}]}
