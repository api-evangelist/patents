---
title: Methods and systems for processing XML documents
abstract: An architecture for processing an Extensible Markup Language (XML) document converts schema elements in the XML document to data type definition (DTD) objects that can be used to validate data elements in the XML document. The architecture utilizes a node factory design in which an XML parser calls one or more node factory interfaces to construct an in-memory tree representation of an XML document. One of the node factory interfaces is a schema node factory, which is a thin layer that receives calls from the parser to build nodes in the tree representation and translates those calls to calls to a schema builder. The schema builder is a table driven interface that converts the schema elements in the XML document into DTD objects. The DTD objects are then used to validate the data elements as belonging to the schema. If valid, the data elements are used to construct the tree representation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07134072&OS=07134072&RS=07134072
owner: Microsoft Corporation
number: 07134072
owner_city: Redmond
owner_country: US
publication_date: 19991013
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This invention relates to methods and systems for processing Extensible Markup Language (XML) documents. More particularly, the invention concerns ways of validating XML data against a predetermined schema and building, from valid XML data, an in-memory tree representation of the XML document.","Extensible Markup Language (XML) is a meta-markup language that provides a format for describing structured data. XML is similar to HTML in that it is a tag-based language. By virtue of its tag-based nature, XML defines a strict tree structure or hierarchy. XML is a derivative of Standard Generalized Markup Language (SGML) that provides a uniform method for describing and exchanging structured data in an open, text-based format. XML utilizes the concepts of elements and namespaces. Compared to HTML, which is a display-oriented markup language, XML is a general-purpose language for representing structured data without including information that describes how to format the data for display.","XML \u201celements\u201d are structural constructs that consist of a start tag, an end or close tag, and the information or content that is contained between the tags. A \u201cstart tag\u201d is formatted as \u201c<tagname>\u201d and an \u201cend tag\u201d is formatted as \u201c<\/tagname>\u201d. In an XML document, start and end tags can be nested within other start and end tags. All elements that occur within a particular element must have their start and end tags occur before the end tag of that particular element. This defines a tree-like structure that is representative of the XML document. Each element forms a node in this tree, and potentially has \u201cchild\u201d or \u201cbranch\u201d nodes. The child nodes represent any XML elements that occur between the start and end tags of the \u201cparent\u201d node.","XML accommodates an infinite number of database schemas. A schema is a set of rules for constraining the structure and articulating the information set of XML documents. A schema describes what data structures, shape, and content of XML documents are valid for a given application. For example, one schema might describe how documents used in an online banking exchange are structured. Other schemas may describe XML documents for email, or XML documents for purchasing blue jeans or music over the Internet.","To illustrate a tree structure constructed from XML data, consider an exemplary XML data exchange between different entities, such as client and server computers, in the form of requests and responses. A client might generate a request for information or a request for a certain server action, and a server might generate a response to the client that contains the information or confirms whether the certain action has been performed. The contents of these requests and responses are XML documents. In many cases, the process of generating these XML documents involves building, in memory, a hierarchical tree structure. Once the hierarchical tree structure is built in its entirety, the actual XML document in proper syntactic form can then be assembled. Consider the following exemplary XML code:\n\n","This code includes three XML namespace declarations that are each designated with \u201cxmlns\u201d. A \u201cnamespace\u201d refers to a dictionary or set of element names defined by the schema. Namespaces ensure that element names do not conflict, and clarify who defined which term. They do not give instructions on how to process the elements. Readers still need to know what the elements mean and decide how to process them. Namespaces simply keep the names straight.","Within an XML document, namespace declarations occur as attributes of start tags. Namespace declarations are of the form \u201cxmlns:[prefix]=[uri]\u201d. A namespace declaration indicates that the XML document contains element names that are defined within a specified namespace or schema. \u201cPrefix\u201d is an arbitrary designation that will be used later in the XML document as an indication that an element name is a member of the namespace declared by universal resource indicator \u201curi\u201d. The prefix is valid only within the context of the specific XML document. \u201cUri\u201d is either a path to a document describing a specific namespace or schema or a globally unique identifier of a specific namespace or schema. Uri is valid across all XML documents. Namespace declarations are \u201cinherited\u201d, which means that a namespace declaration applies to the element in which it was declared as well as to all elements contained within that element.","With reference to the above XML code, the namespace declarations include a prefix, e.g. \u201cperson\u201d, \u201cdsig\u201d, and \u201ctrans\u201d respectively, and the expanded namespace to which each prefix refers, e.g. \u201chttp:\/\/www.schemas.org\/people\u201d, \u201chttp:\/\/dsig.org\u201d, and \u201chttp:\/\/www.schemas.org\/transactions\u201d respectively. This code tells any reader that if an element name begins with \u201cdsig\u201d its meaning is defined by whoever owns the \u201chttp:\/\/www.dsig.org\u201d namespace. Similarly, elements beginning with the \u201cperson\u201d prefix have meanings defined by the \u201chttp:\/\/www.schemas.org\/people\u201d namespace and elements beginning with the \u201ctrans\u201d prefix have meanings defined by the \u201chttp:\/\/www.schemas.org\/transactions\u201d namespace.","It is noted that another XML document that incorporated elements from any of the namespaces included in this sample might declare prefixes that are different from those used in this example. As noted earlier, prefixes are arbitrarily defined by the document author and have meaning only within the context of the specific element of the specific document in which they are declared.",{"@attributes":{"id":"p-0011","num":"0024"},"figref":"FIG. 1","b":"18"},"In XML 1.0, data types in the schemas are defined using a set of data type definitions (DTD). XML documents have two kinds of constraints: well-formedness and validity. The \u201cwell-formedness\u201d constraints are those imposed by the definition of XML itself (such as the rules for the use of the < and > characters and the rules for proper nesting of elements). The \u201cvalidity\u201d constraints are constraints on document structure provided by a particular DTD or XML-Data schema. Schema or DTD validation is very useful in the Internet realm, because entities are able to validate whether data structures received from random or anonymous sources are appropriate for a given context. Suppose, for example, that a company receives XML data from some random user. The company does not necessarily trust the data at this point, and hence utilizes a validation process to determine whether the XML data is good or whether it is noise that can be rejected outright or sent to a system administrator for special consideration.",{"@attributes":{"id":"p-0013","num":"0026"},"figref":"FIG. 2","b":["20","20","22"],"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":{"@attributes":{"id":"ul0006-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":["<Book>\n        \n        ","<\/Book>"]}}}},"The parser  parses the XML data and returns the following list:\n\n","As the parser  parses the XML data, it calls to one or more node factories. A \u201cnode factory\u201d is a callback interface that builds node objects used to construct an in-memory tree representation of the XML document. The node factory may also be used to search the XML document, without building a node object. Custom node factories can be constructed to build different kinds of object hierarchies that reflect the XML document.","In architecture , there are four node factories, including a namespace node factory , a DTD node factory , a tree builder node factory , and a validation node factory . The XML parser  calls the namespace node factory , which outputs a sequence of name tokens. DTD events are passed to the DTD node factory  and XML data events are passed to the validation node factory . The DTD node factory  builds DTD objects  from the DTD events. The DTD objects  are used in the validation process of validating the XML data. The DTD node factory  may also delegate to the tree builder node factory , which builds XML DOM (Document Object Model) fragments  for pieces of the tree structure, or XML DOM.","The validation node factory  receives the XML data events from the namespace node factory  and uses the DTD objects  to evaluate whether the data complies with certain constraints defined by the DTD objects. If the XML data is valid, the tree builder node factory  builds a complete XML DOM  for the XML data. Some elements of the XML DOM  may reference fragments .","The architecture  is configured for DTD-specific considerations. DTD objects have an advantage in that they are known and previously defined. DTD objects also have a drawback, however, in that they are not extensible. Thus, new data type definitions cannot be easily created. Due to this problem, more recent evolutions of XML are beginning to use XML-data schemas as an additional or alternative way to define data types in schemas. XML-data schemas are not restricted like DTD objects, but are extensible and new ones can be created as needed.","Thus, there is a desire to adapt the architecture of  to handle the more extensible XML-data schemas in addition to DTD objects. One problem with this adaptation is that the node factory interface provides a sequential ordered stream of XML tokens, whereas the XML-data schemas define items in a way that is order independent. This means that the node factory has to store certain states until it knows it can process those states.","Accordingly, there is a need for an improved architecture built around the node factory design, which handles XML-data schemas to build in-memory tree representations and DTD objects for validation purposes. More particularly, the improved architecture should leverage existing components (e.g., DTD validation, namespace node factory, and XML parser) for creating an in-memory representation of the schema and be roughly as fast as the existing architecture. The architecture should also maximize code reuse.","This invention concerns an architecture for processing XML documents and building in-memory tree representations of the XML documents. More particularly, the architecture accommodates XML-data schemas as a way of defining data types within schemas and converts the XML-data schemas to DTD objects that are used to validate the XML data in the XML document.","In the described implementation, the architecture utilizes a node factory design in which an XML parser calls one or more node factories to construct an in-memory tree representation of the XML document. One of the node factories is a schema node factory, which is a thin layer interface that is callable by the parser. The schema node factory translates the parser calls into calls to a schema builder, which is a table drive component that builds DTD objects used in validation of the XML data. If valid, the XML data is used to construct the in-memory tree representation of the XML document.","System",{"@attributes":{"id":"p-0031","num":"0059"},"figref":"FIG. 3","b":["40","42","44","46","42"]},"The client  implements an XML processing software architecture  that sends, receives, and processes XML documents. The server  is equipped with a similar architecture, but will not be described here for brevity purposes. The XML processing unit  has a network module  (e.g., TCP\/IP module) to facilitate connection to the network  and a transport object  (e.g., a Distributed Authoring and Versioning (WebDAV) transport object) to handle requests and responses over the network. Upon receipt of an XML document, the transport object  pushes the XML document into an XML parser , which in this example, is a so-called \u201cpush-model\u201d parser. The parser  parses the XML data stream into individual elements of schema and data. The schema elements establish a schema for an associated application (not shown), while the data element are validated against the schema and if valid, are used to form an in-memory tree representation of the XML document.","The parser  calls one or more node factories  to construct the in-memory tree representation of the XML document. One of the node factories is a \u201cschema node factory\u201d , which is a thin layer interface that receives calls from the parser  and delegates the work to another interface known as a \u201cschema builder\u201d . The schema builder  converts the schema elements contained in the calls to data type definition (DTD) objects. The DTD objects are then used to validate the XML data from the parsed XML document to determine whether the data is valid for the particular schema associated with the application. If valid, the XML data is used to form an in-memory tree representation, which is also known as an XML DOM (Document Object Model) .","Architecture",{"@attributes":{"id":"p-0035","num":"0063"},"figref":"FIG. 4","b":["50","42","50","56"]},"The parser  calls a namespace node factory  for both the schema(s) and data. A node factory is a callback interface that builds node objects used to construct an in-memory tree representation of the XML document. The general node factory interface (\u201cIXMLNodeFactory\u201d) has several methods, including those listed in Table 1.",{"@attributes":{"id":"p-0037","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Node Factory Interface"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method","What it does . . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["NotifyEvent","This method informs the node factory where an event"]},{"entry":[{},"occurs within the XML document"]},{"entry":["BeginChildren","This method is called when a node contains children."]},{"entry":["EndChildren","This method is called when all sub-elements of the given"]},{"entry":[{},"element are complete."]},{"entry":["Error","This method is called when the parser runs into an error"]},{"entry":[{},"in the XML document."]},{"entry":["CreateNode","This method is called during parsing for each and every"]},{"entry":[{},"element."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The name space node factory  outputs a sequence of name tokens. Tokens relating to the schema(s) are passed to the schema node factory , where as tokens pertaining to the data are passed to a validation node factory . The schema node factory  is a thin node factory interface that receives the schema-related tokens from the namespace node factory  and delegates work to a schema builder . The schema node factory  also passes the tokens onto the tree builder node factory  for construction of schema DOM fragments  for pieces of the tree representation.","The schema builder  is a table-driven schema interface that utilizes static tables  to build DTD objects . More particularly, the schema builder  includes a state machine that is table driven by values in the static tables . The static tables  contain information describing the schema schema if you will, including what elements and attributes are valid for XML-Data schemas and the associated functions to call when processing those elements. The static tables  are organized in a hierarchy, beginning with a schema root table and cascading down through element and attribute tables and event-to-function mapping tables. The schema builder  calls these functions at parse time to construct DTD objects used to test the XML data for validation.","The validation node factory  receives the data elements from the namespace node factory . The validation node factory  uses the DTD objects  built by the schema builder  to evaluate whether the data elements comply with the constraints set forth in the DTD objects. The validation node factory  passes the valid data elements to the tree builder node factory  to build the complete XML DOM  for the XML data. Some elements of the XML DOM  may reference fragments .",{"@attributes":{"id":"p-0041","num":"0069"},"figref":"FIG. 5","b":["80","62","82","82","84","86"]},"The element types table  contains one or more fields listing types of elements permitted in the schema and references to other tables containing information on specific types. The attribute types table  contains one or more fields listing types of attributes in the schema, corresponding functions for handling the attributes, and type descriptions.","The types tables  and  may further reference one or more function tables. In , the element types table  references (e.g., via a pointer) a function table  that contains functions pertaining to the IXMLNodeFactory events described in Table 1. The function table includes functions like ProcessElement, ProcessEndChildren, and ProcessBeginChildren.","The schema builder  exposes an API (application program interface) to make these and other functions available. In this example, the schema node factory  makes calls to the schema builder API, but this API is designed for more general use in other scenarios in addition to the context described here. The schema builder API has several methods, including the methods listed in Table 2.",{"@attributes":{"id":"p-0045","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Schema Builder Interface"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method","What it does . . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["void start( );","This method signals that a new schema is being"]},{"entry":[{},"processed and the internal state is reset"]},{"entry":[{},"accordingly."]},{"entry":["void finish( );","This method signals that an end of the schema"]},{"entry":[{},"has been reached. It checks whether all elements"]},{"entry":[{},"referenced in the schema have been declared."]},{"entry":["ProcessElementNode","This method is called for each schema element in"]},{"entry":["(Node * pNode);","the document. This occurs when the schema"]},{"entry":[{},"builder looks up the new schema element (e.g.,"]},{"entry":[{},"ElementType or AttributeType) in the element"]},{"entry":[{},"types table 84 or attribute types table 86 for the"]},{"entry":[{},"current schema element. If the element is"]},{"entry":[{},"allowed (i.e., listed in the table), the method"]},{"entry":[{},"pushes the current element onto a stack and calls"]},{"entry":[{},"the \u201cinit\u201d function defined in the function table"]},{"entry":[{},"88 for the new schema element. The \u201cinit\u201d"]},{"entry":[{},"function initializes one or more data structures"]},{"entry":[{},"for the new schema element and creates empty"]},{"entry":[{},"DTD objects for that element."]},{"entry":["ProcessAttributes","This method is called when all attributes are"]},{"entry":["(IXMLNodeSource *","ready to be processed for the current schema"]},{"entry":["pSource,","element. This occurs when the schema builder"]},{"entry":["Node * pNode);","walks through the attributes in the XML DOM 64"]},{"entry":[{},"for the schema, looks them up in the attribute"]},{"entry":[{},"types table 86 for the current schema element,"]},{"entry":[{},"parses the attribute value according to the"]},{"entry":[{},"attribute type, and calls the function for handling"]},{"entry":[{},"that attribute."]},{"entry":["ProcessPCDATA","This method is called for each Text node"]},{"entry":["(Node * pNode,","(including attribute values) in the XML"]},{"entry":["PVOID pParent);","document. This method determines whether it is"]},{"entry":[{},"valid to have text in the current position within"]},{"entry":[{},"the schema document and generates an error if it"]},{"entry":[{},"is not valid."]},{"entry":["ProcessEndChildren","This method is called when the end of all"]},{"entry":["(IXMLNodeSource *","children for the current schema is reached. This"]},{"entry":["pSource,","method determines if all content for the current"]},{"entry":["Node * pNode);","schema element has been correctly provided,"]},{"entry":[{},"along with any final default values. For"]},{"entry":[{},"ElementType elements, the method finishes the"]},{"entry":[{},"content model, which may involve creating a few"]},{"entry":[{},"more DTD content model nodes for describing"]},{"entry":[{},"certain default values."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Exemplary Computer System",{"@attributes":{"id":"p-0047","num":"0075"},"figref":"FIG. 6","b":["130","130","42","44"]},"Computer  includes one or more processors or processing units , a system memory , and a bus  that couples various system components including the system memory  to processors . The bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM .","Computer  further includes a hard disk drive  for reading from and writing to a hard disk (not shown), a magnetic disk drive  for reading from and writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the bus  by a SCSI interface  or some other appropriate interface. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROMs), and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM , or RAM , including an operating system , one or more application programs , other program modules , and program data . A user may enter commands and information into computer  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are connected to the processing unit  through an interface  that is coupled to the bus . A monitor  or other type of display device is also connected to the bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices (not shown) such as speakers and printers.","Computer  commonly operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to computer , although only a memory storage device  has been illustrated. The logical connections include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the bus  via a serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Generally, the data processors of computer  are programmed by means of instructions stored at different times in the various computer-readable storage media of the computer. Programs and operating systems are typically distributed, for example, on floppy disks or CD-ROMs. From there, they are installed or loaded into the secondary memory of a computer. At execution, they are loaded at least partially into the computer's primary electronic memory. The invention described herein includes these and other various types of computer-readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described below.","For purposes of illustration, programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized that such programs and components reside at various times in different storage components of the computer, and are executed by the data processor(s) of the computer.","Operation",{"@attributes":{"id":"p-0056","num":"0084"},"figref":["FIG. 7","FIG. 4"],"b":"50"},"At step , an XML document is received at the parser . The XML document consists of XML data that is articulated by and complies with a schema. The parser  parses the XML document to produce both data elements and schema elements (step ).","After parsing, the schema elements are converted to DTD objects , which are used to validate the XML data (step ). More particularly, the conversion step involves the parser  calling the schema node factory  (i.e., CreateNode) to create a node in the tree that represents the schema element (step ). The schema node factory  in turn calls the schema builder interface  (e.g., Table 2 calls) to process the individual elements and construct data type definition (DTD) objects used in validating the data elements (step ).","To illustrate how the schema node factory  and schema builder  operate, consider the oft-used CreateNode call (Table 1) made from the parser  to the schema node factory . The architecture translates the CreateNode calls into the DTD objects . For discussion purposes, suppose the following schema fragment is input:\n\n","Table 3 lists the series of calls made to the schema node factory  and schema builder  for this schema fragment.",{"@attributes":{"id":"p-0061","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Calls Generated In Response for"},{"entry":"Parser's CreateNode Call"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SchemaNodeFactory Call","SchemaBuilder Call","Resulting Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["NotifyEvent","Start","Initialize state and"]},{"entry":["STARTDOCUMENT",{},"create new empty"]},{"entry":[{},{},"DTD object."]},{"entry":["CreateNode ELEMENT","ProcessElementNode","Set current state to"]},{"entry":["\u201cSchema\u201d",{},"point to the Schema"]},{"entry":[{},{},"element state table."]},{"entry":["CreateNode","No operation"]},{"entry":"ATTRIBUTE \u201cxmlns\u201d"},{"entry":["CreateNode TEXT","ProcessPCDATA","Attribute text is a no"]},{"entry":["\u201curn: . . .\u201d",{},"operation."]},{"entry":["BeginChildren","ProcessAttributes","\u201cxmlns\u201d is a"]},{"entry":[{},{},"skippable attribute, so"]},{"entry":[{},{},"this is a no operation."]},{"entry":["CreateNode ELEMENT","ProcessElementNode","\u201cElementType\u201d is an"]},{"entry":["\u201cElementType\u201d",{},"allowable child of"]},{"entry":[{},{},"\u201cSchema\u201d so push"]},{"entry":[{},{},"\u201cSchema\u201d onto the"]},{"entry":[{},{},"stack and initialize a"]},{"entry":[{},{},"new ElementDecl"]},{"entry":[{},{},"DTD object with"]},{"entry":[{},{},"default content model"]},{"entry":[{},{},"EMPTY."]},{"entry":["CreateNode","No operation"]},{"entry":"ATTRIBUTE \u201cname\u201d"},{"entry":["CreateNode TEXT \u201cfoo\u201d","ProcessPCDATA","Attribute text is a no"]},{"entry":[{},{},"operation."]},{"entry":["CreateNode","No operation"]},{"entry":"ATTRIBUTE \u201cmodel\u201d"},{"entry":["CreateNode TEXT","ProcessPCDATA","Attribute text is a no"]},{"entry":["\u201copen\u201d",{},"operation."]},{"entry":["BeginChildren","ProcessAttributes.","Calls"]},{"entry":[{},{},"BuildElementName,"]},{"entry":[{},{},"which initializes"]},{"entry":[{},{},"name of the"]},{"entry":[{},{},"ElementDecl DTD"]},{"entry":[{},{},"object and validates"]},{"entry":[{},{},"that an ElementDecl"]},{"entry":[{},{},"named \u201cfoo\u201d has not"]},{"entry":[{},{},"already been"]},{"entry":[{},{},"declared."]},{"entry":[{},{},"Calls"]},{"entry":[{},{},"BuildeElementModel,"]},{"entry":[{},{},"which validates the"]},{"entry":[{},{},"value \u201copen\u201d and sets"]},{"entry":[{},{},"the model to open."]},{"entry":["EndChildren","ProcessEndChildren","Calls"]},{"entry":["\u201cElementType\u201d",{},"EndElementType,"]},{"entry":[{},{},"which determines that"]},{"entry":[{},{},"there are no child"]},{"entry":[{},{},"elements in the"]},{"entry":[{},{},"schema fragment and"]},{"entry":[{},{},"that the content"]},{"entry":[{},{},"model is open."]},{"entry":[{},{},"Changes the default"]},{"entry":[{},{},"content model from"]},{"entry":[{},{},"EMPTY to ANY."]},{"entry":[{},{},"Pops current state"]},{"entry":[{},{},"back to \u201cSchema\u201d"]},{"entry":[{},{},"State"]},{"entry":["EndChildren \u201cSchema\u201d","ProcessEndChildren","No cleanup function"]},{"entry":[{},{},"for \u201cSchema\u201d state."]},{"entry":[{},{},"Pops \u201cSchema\u201d state"]},{"entry":[{},{},"back to initial state."]},{"entry":["NotifyEvent","Finish","Checks for referenced"]},{"entry":["ENDDOCUMENT",{},"but undeclared"]},{"entry":[{},{},"element types-and"]},{"entry":[{},{},"there are none."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"With reference again to , the data elements from the parsed XML document are evaluated against the DTD objects  to determine whether the data elements are valid (step ). If valid, the tree builder node factory  constructs the in-memory tree representation of the XML data (step ).","Although the invention has been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0051"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0052"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0053"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0054"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0027","num":"0055"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0056"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0057"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
