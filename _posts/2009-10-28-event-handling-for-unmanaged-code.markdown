---
title: Event handling for unmanaged code
abstract: Many computer applications involve event driven programming. Unfortunately, it may be burdensome on application developers to develop event handlers in unmanaged code for all relevant events within their computer application. For example, when using COM objects in connection with event handling, the burden of lifetime management may be placed on the application developer. Accordingly, one or more systems and/or techniques for event handling in unmanaged code are disclosed herein. A delegate comprising a first interface and a second interface is provided. The delegate may receive event data from a software platform connected to the first interface and may notify a function of a process connected to the second interface. The delegate self destructs when both the computing platform and the process have released their connections to the respective interfaces, thus mitigating manual coding of lifetime management functionality within the process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08726237&OS=08726237&RS=08726237
owner: Microsoft Corporation
number: 08726237
owner_city: Redmond
owner_country: US
publication_date: 20091028
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Today, many applications, such as graphical user interface (GUI) programs and web applications, are event driven. A user may click a button or scroll within a window of an application, setting off a MouseClick event or a MouseScroll event within the application, for example. To facilitate developing these event driven applications, many application programming interfaces support event handlers. Event handlers allow developers to write functionality that executes in response to events. For example, a calculator application may be configured to execute an addition operation in response to a MouseClick event on an Addition Button within the calculator application. Unfortunately, programming event handlers can be burdensome in unmanaged code (e.g., a platform that does not support garbage collection, C++ utilizing Component Object Module (COM), etc.). That is, an application may support hundreds of different events, such that corresponding event handlers may each have many lines of code simply devoted to lifetime management. Thus, while utilizing event handlers can be a convenient and intuitive scheme to conceptualize programming, developing and executing event handlers in unmanaged code can be resource intensive.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Among other things, one or more systems and\/or techniques for event handling in unmanaged code (e.g., a programming language with minimal garbage collection) is disclosed herein. A delegate may be configured to expose a first interface to which a software platform (e.g., a user interface platform, a web browsing platform, etc.) may connect. In one example, a delegate may be a COM object component with one or more interfaces. The delegate may be configured to maintain a first independent reference count associated with the software platform. It may be appreciated that the first independent reference count may be used in determining whether the software platform is connected to or has released from the first interface. The delegate may be configured to expose a second interface to which a process (e.g., a user interface application written in unmanaged code or a portion thereof) may connect. The delegate may be configured to maintain a second independent reference count associated with the process. It may be appreciated that the second independent reference count may be used in determining whether the process is connected to or has released from the second interface.","The delegate may be configured to self destruct (e.g., release from memory) when both the first independent reference count indicates the software platform released a first connection to the first interface (e.g., the first independent reference count is zero) and the second independent reference count indicates the process released a second connection to the second interface (e.g., the second independent reference count is zero). That is, the delegate may be active if at least one of the software platform and the process is connected to the delegate, so that the delegate exists to mitigate the chance of bad pointers. If both the software platform and the process are not connected, then the delegate self destructs to free up memory. In this way, the delegate mitigates the need for manual coding of lifetime management of memory and objects that an application author would otherwise have to provide for every event handler.","The delegate may be configured through the first connection to receive event data from the software platform. It may be appreciated that in one example, the event data may be a notification of an event firing. In another example, the event data may comprise additional information regarding the firing of an event, such as, event arguments. For example, event data may be data associated with a MouseOver event that is wrapped in a COM object. The delegate may be configured through the second connection to notify a function (e.g., an event handler within the process) of the event data. This allows the function to execute code to handle the event data (e.g., highlight a button that the mouse was positioned over). Because the delegate is performing lifetime management of memory and objects (e.g., adhering to the guidelines of COM), the event handlers do not need manual programming of this functionality.","To the accomplishment of the foregoing and related ends, the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects, advantages, and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.","The claimed subject matter is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, structures and devices are illustrated in block diagram form in order to facilitate describing the claimed subject matter.","Event handling is germane to user interface programming. When a user interacts within a user interface application (e.g., moves the mouse, clicks buttons, scrolls the window, etc.), events (e.g., mouse click event, button down event, scroll event, etc.) occur. Usually, the user interface application is programmed to respond to events (as opposed to executing code the entire duration of the user interface's life without regard to events occurring) using event handlers. This provides a robust and interactive experience for the user, and a practical and intuitive scheme for programming.","Many of these event driven applications are developed using unmanaged code (e.g., C and\/or C++ programs compiled into machine language for particular platforms). Unfortunately, unmanaged code, such as C++, is limited in its ability to communicate across boundaries (e.g., communication between a music player application and an operating system or web browsing platform). To facilitate communication for these applications derived from unmanaged code, Component Object Module (COM) was created to, among other things, facilitate the communication across these barriers. Thus, many application program interfaces are COM based. One benefit of COM is that it has a robust functionality for managing lifetime of memory and objects to minimize memory leaks. By the same token, however, it can become tedious and burdensome to program event handlers because a single event handler takes many lines of code to create the appropriate COM object for that particular event handler. This does not scale well when many applications comprise hundreds of events with corresponding event handlers.","Accordingly, one or more systems and\/or techniques for event handling in unmanaged code are provided herein. A delegate may be provided to mitigate the burden on an application developer of managing the lifetime of an application object (e.g., memory, handles, etc.), which would otherwise be placed upon the application developer when utilizing COM. In one non-limiting example, the delegate may be implemented as a two-headed COM object. That is, the delegate may comprise a first interface to which a software platform may connect and a second interface to which a process (e.g., an application or a portion thereof) may connect. The delegate may be configured to receive event data from the software platform and notify an appropriate function (e.g., an event handler of a user interface application) specified by the process of the event data. Furthermore, the delegate may be configured to self destruct upon both the software platform and the process releasing their connections to the delegate, otherwise the delegate may remain active in memory to mitigate chances of bad pointers where either the software platform released and the process is still connected or visa versa.","One embodiment of event handling in unmanaged code is illustrated by an exemplary method  in . At , the method begins. At , a delegate comprising a first interface associated with a software platform and a second interface associated with a process is provided. The software platform may connect to the first interface, allowing the delegate to receive event data from the software platform. The process may connect to the second interface, allowing the delegate to notify a function (e.g., an event handler) specified by the process of the event data. It may be appreciated that a pointer from the delegate to the process may also be used to notify the function of the event data. In one example, the event data may be wrapped within a query enabled COM object.","At , a first independent reference count of the first interface may be maintained based upon a first connection between the software platform and the first interface. That is, the first independent reference count specifies whether the first connection to the first interface exists (e.g., the first independent reference count is a positive integer) or has been released (e.g., the first independent reference count is decremented to zero) by the software platform. At , a second independent reference count of the second interface may be maintained based upon a second connection between the process and the second interface. That is, the second independent reference count specifies whether the second connection to the second interface exists (e.g., the second independent reference count is a positive integer) or has been released (e.g., the second independent reference count is decremented to zero) by the process. If a pointer was created from the delegate to the process, then the pointer may cease to exist or be destroyed when the process releases the second connection to the second interface.","It may be appreciated that the delegate may remain in memory when the first connection exists and the second connection is released, thus mitigating the chance of bad pointers from the software platform to the disconnected process. It may be appreciated that the delegate may remain in memory when the first connection is released and the second connection exists, thus mitigating the chance of bad pointers from the process to the disconnected software platform.","At , the delegate is destroyed when both the first independent reference count indicates the software platform released the first connection to the first interface (e.g., the first independent reference count is zero) and the second independent reference count indicates the process released the second connection to the second interface (e.g., the second independent reference count is zero). This allows safe removal of the delegate from memory without leaving bad pointers because both the software platform and the process have disconnected. At , the method ends.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","200","202","210","212","204","210","202","204","210","202","210","214","204","214","210","214","214","204"]},"A process  may establish a second connection to the second interface . It may be appreciated that the delegate  may notify a function  specified by the process  of event data through the second interface  and\/or through a pointer . The delegate , through the second interface , may be configured to maintain a second independent reference count  associated with the process . That is, the second independent reference count  may be specified to indicate whether the second connection to the second interface  exists (e.g., the second independent reference count  is a positive integer such as 1) or has been released (e.g., the second independent reference count  is decremented to zero) by the process .","The delegate  may be configured to self destruct (e.g., be erased from memory) when both the first independent reference count  indicates the software platform  released the first connection to the first interface  and the second independent reference count  indicates the process  released a second connection to the second interface . This allows the delegate to safely remove itself from memory without leaving bad pointers.","The delegate  may be configured to address versioning. That is, event data passed from the software platform  through the delegate  to the function  may be wrapped within a COM object comprising event arguments. The event arguments may be queried through multiple interfaces. The delegate  may allow for registration of distinct event handlers for distinct argument interfaces. It may be appreciated that in an alternative example, the software platform  may allow for multiple delegates to be registered for distinct argument interfaces. For example the delegate  may support registration of one or more versions of the function . Based upon the registration, the delegate may select an appropriate second interface when an event fires. The delegate  may be configured to address run-time type verification. For example, the delegate  may leverage a QueryInterface functionality within COM to provide run-time type verification. The delegate  may be configured to provide templates for registering functions as event handlers in a manner appropriate for cross-binary calls.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["300","300","302","302","310","304","302","312","306","302","304","310","314","302","306","312","316"]},"In one example, a web browsing platform (e.g., the software platform ) may establish the first connection to the delegate  and a video player web application (e.g., the process ) may establish the second connection to the delegate . While the first connection exists (the web browsing platform is connected to the first interface ), the delegate  may be configured to keep a positive integer value within the first independent reference count  (e.g., 1). While the second connection exists (the video player web application is connected to the second interface ), the delegate may be configured to keep a positive integer value within the second independent reference count  (e.g., 1) and a pointer to an OnButtonClickEventHandler function (e.g., a function ) specified by the video player web application.","The first independent reference count=1 indicates to the delegate  that the web browsing platform is connected and may possibly send event data  through the first interface . The second independent reference count=1 indicates to the delegate  that the video player web application is connected and is ready to receive event data  through the pointer to the OnButtonClickEventHandler function. The delegate  may be configured to receive the event data  (e.g., a ButtonClickEvent along with arguments wrapped in a COM object) from the web browsing platform and send the event data  (e.g., a ButtonClickEvent along with arguments wrapped in a COM object) to the OnButtonClickEventHandler function when both the first independent reference count  and the second independent reference count  are positive integer values, indicating the respective connections exist.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4","b":["400","400","402","402","410","404","402","412","406","402","404","410","414","402","406","412","416","402","404","410","408","406"]},"In one example, a web browsing platform (e.g., the software platform ) may establish the first connection to the delegate  and a video player web application (e.g., the process ) may establish the second connection to the delegate . While the first connection exists (the web browsing platform is connected to the first interface ), the delegate  may be configured to keep a positive integer value within the first independent reference count  (e.g., 1). While the second connection exists (the video player web application is connected to the second interface ), the delegate may be configured to keep a positive integer value within the second independent reference count  (e.g., 1) and the pointer to an OnButtonClickEventHandler function (e.g., the function ) specified by the video player web application.","In the example of , the web browsing platform has disconnected from the first interface . For example, the web browsing platform may have been shutdown, suspended, etc. Because there is no connection, the delegate  may write a zero (0) value, for example, to the first independent reference count  to indicate the web browsing platform has released the first connection. It may be appreciated that the delegate  will not receive event data from the web browsing platform because there is no connection. Even though the web browsing platform is disconnected, the video player web application is still connected to the second interface . Because the connection still exists, the second independent reference count  has a one (1) value and the delegate  does not self destruct (e.g., the delegate  remains operable and in memory).",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5","b":["500","500","502","502","510","504","502","512","506","502","504","510","514","502","506","512","516","502","504","510","508","506","518"]},"In one example, a web browsing platform (e.g., the software platform ) may establish the first connection to the delegate  and a video player web application (e.g., the process ) may establish the second connection to the delegate . While the first connection exists (the web browsing platform is connected to the first interface ), the delegate  may be configured to keep a positive integer value within the first independent reference count  (e.g., 1). While the second connection exists (the video player web application is connected to the second interface ), the delegate may be configured to keep a positive integer value within the second independent reference count  (e.g., 1) and maintain the pointer  to an OnButtonClickEventHandler function (e.g., the function ) specified by the video player web application.","In the example of , the video player web application has disconnected from the second interface . For example, the video player web application may have been shutdown, suspended, etc. Because there is no connection, the delegate  may write a zero (0) value, for example, to the second independent reference count  to indicate the video player web application has released the second connection. It may be appreciated that the delegate  may destroy the pointer  to the OnButtonClickEventHandler function because the video player web application is disconnected, thus preventing bad pointers. Even though the web video player application has disconnected from the second interface , the web browsing platform is still connected to the first interface . Because the first connection still exists, the first independent reference count  has a one (1) value and the delegate  does not self destruct (e.g., the delegate  remains operable and in memory).",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 6","b":["600","600","602","602","610","604","602","612","606","602","604","610","614","602","606","612","616","602","604","610","608","606"]},"In one example, a web browsing platform (e.g., the software platform ) may establish the first connection to the delegate  and a video player web application (e.g., the process ) may establish the second connection to the delegate . While the first connection exists (the web browsing platform is connected to the first interface ), the delegate  may be configured to keep a positive integer value within the first independent reference count  (e.g., 1). While the second connection exists (the video player web application is connected to the second interface ), the delegate may be configured to keep a positive integer value within the second independent reference count  (e.g., 1) and maintain a pointer to an OnButtonClickEventHandler function (e.g., the function ) specified by the video player web application.","In the example of , the web browsing platform has disconnected from the first interface  and thus the first independent reference count is zero (0). Also, the video player web application has disconnected from the second interface  and thus the second independent reference count is zero (0). Upon determining both the first independent reference count indicates the web browsing platform has released its connection to the first interface  and the second independent reference count indicates the video player web application has released its connection to the second interface , the delegate self destructs  (e.g., releases from memory).","Still another embodiment involves a computer-readable medium comprising processor-executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer-readable medium that may be devised in these ways is illustrated in , wherein the implementation 700 comprises a computer-readable medium  (e.g., a CD-R, DVD-R, or a platter of a hard disk drive), on which is encoded computer-readable data . This computer-readable data  in turn comprises a set of computer instructions  configured to operate according to one or more of the principles set forth herein. In one such embodiment , the processor-executable instructions  may be configured to perform a method , such as the exemplary method  of , for example. That is, the processor-executable instructions  may implement the exemplary methods  as an application program interface (API) which may be executed via one or more processors. In another such embodiment, the processor-executable instructions  may be configured to implement a system, such as the exemplary system  of , for example. Many such computer-readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.","In one example, the method  may be configured to provide a delegate comprising a first interface associated with a software platform and a second interface associated with a process. The method  may be configured to maintain a first independent reference count of the first interface based upon a connection between the software platform and the first interface. The method  may be configured to maintain a second independent reference count of the second interface based upon a second connection between the process and the second interface. The method  may be configured to destroy the delegate when both the first independent reference count indicates the software platform released the first connection to the first interface and the second independent reference count indicates the process released a second connection to the second interface.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem\u201d, \u201cinterface\u201d, and the like are generally intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a controller and the controller can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 8","FIG. 8"]},"Although not required, embodiments are described in the general context of \u201ccomputer readable instructions\u201d being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media (discussed below). Computer readable instructions may be implemented as program modules, such as functions, objects, Application Programming Interfaces (APIs), data structures, and the like, that perform particular tasks or implement particular abstract data types. Typically, the functionality of the computer readable instructions may be combined or distributed as desired in various environments.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 8","FIG. 8"],"b":["810","812","812","816","818","818","814"]},"In other embodiments, device  may include additional features and\/or functionality. For example, device  may also include additional storage (e.g., removable and\/or non-removable) including, but not limited to, magnetic storage, optical storage, and the like. Such additional storage is illustrated in  by storage . In one embodiment, computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage  may also store other computer readable instructions to implement an operating system, an application program, and the like. Computer readable instructions may be loaded in memory  for execution by processing unit , for example.","The term \u201ccomputer readable media\u201d as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory  and storage  are examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also include communication connection(s)  that allows device  to communicate with other devices. Communication connection(s)  may include, but is not limited to, a modem, a Network Interface Card (NIC), an integrated network interface, a radio frequency transmitter\/receiver, an infrared port, a USB connection, or other interfaces for connecting computing device  to other computing devices. Communication connection(s)  may include a wired connection or a wireless connection. Communication connection(s)  may transmit and\/or receive communication media.","The term \u201ccomputer readable media\u201d may include communication media. Communication media typically embodies computer readable instructions or other data in a \u201cmodulated data signal\u201d such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.","Device  may include input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, infrared cameras, video input devices, and\/or any other input device. Output device(s)  such as one or more displays, speakers, printers, and\/or any other output device may also be included in device . Input device(s)  and output device(s)  may be connected to device  via a wired connection, wireless connection, or any combination thereof. In one embodiment, an input device or an output device from another computing device may be used as input device(s)  or output device(s)  for computing device .","Components of computing device  may be connected by various interconnects, such as a bus. Such interconnects may include a Peripheral Component Interconnect (PCI), such as PCI Express, a Universal Serial Bus (USB), firewire (IEEE 1394), an optical bus structure, and the like. In another embodiment, components of computing device  may be interconnected by a network. For example, memory  may be comprised of multiple physical memory units located in different physical locations interconnected by a network.","Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example, a computing device  accessible via a network  may store computer readable instructions to implement one or more embodiments provided herein. Computing device  may access computing device  and download a part or all of the computer readable instructions for execution. Alternatively, computing device  may download pieces of the computer readable instructions, as needed, or some instructions may be executed at computing device  and some at computing device .","Various operations of embodiments are provided herein. In one embodiment, one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media, which if executed by a computing device, will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further, it will be understood that not all operations are necessarily present in each embodiment provided herein.","Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as advantageous over other aspects or designs. Rather, use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application, the term \u201cor\u201d is intended to mean an inclusive \u201cor\u201d rather than an exclusive \u201cor\u201d. That is, unless specified otherwise, or clear from context, \u201cX employs A or B\u201d is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then \u201cX employs A or B\u201d is satisfied under any of the foregoing instances. In addition, the articles \u201ca\u201d and \u201can\u201d as used in this application and the appended claims may generally be construed to mean \u201cone or more\u201d unless specified otherwise or clear from context to be directed to a singular form.","Also, although the disclosure has been shown and described with respect to one or more implementations, equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components (e.g., elements, resources, etc.), the terms used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., that is functionally equivalent), even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition, while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes\u201d, \u201chaving\u201d, \u201chas\u201d, \u201cwith\u201d, or variants thereof are used in either the detailed description or the claims, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
