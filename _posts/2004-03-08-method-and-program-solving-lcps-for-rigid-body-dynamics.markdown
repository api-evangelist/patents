---
title: Method and program solving LCPs for rigid body dynamics
abstract: A projected iterative descent method is used to resolve LCPs related to rigid body dynamics, such that animation of the rigid body dynamics on a display system occur in real-time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07079145&OS=07079145&RS=07079145
owner: AGEIA Technologies, Inc.
number: 07079145
owner_city: Mountain View
owner_country: US
publication_date: 20040308
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Patent Application No. 60\/537,954 filed Jan. 22, 2004.","The present invention relates to a method and program for realistically animating the motion and interaction of rigid bodies in a display system. More particularly, the present invention relates to a method and program for solving a class of Linear Complementary Problems (LCPs) that arise during operation of a rigid body dynamics engine within the display system. The present invention finds application within conventional display systems, as well as within recently proposed display systems incorporating a hardware-based, physics processing unit.","Physics-based \u201canimations\u201d and \u201csimulations\u201d (hereafter these terms are used interchangeably regardless of application, specific method of display, or means of communicating related physics-based data) have been extensively investigated during the past three decades. Such animations are useful in a range of applications including virtual reality, electronic\/computer games, scientific simulations, and robotic motion planning. Game developers, for example, increasingly use real-time, physics-based animations to enhance the realism of game object interactivity. Integral to the development of real-time, physics-based animations is the dynamic simulation of rigid body movements and interactions.","The term \u201crigid body\u201d is used to describe animated objects that do not deform. They are said to be stiff even when colliding with other objects or with the environment defined by the animation. A rigid body simulation involves a complex sequence of computational steps causing animated bodies and related forces to interact in a realistic manner according to a set of defined physical rules, or so-called \u201cconstraints.\u201d One goal of a rigid body simulator is to minimize or prevent the penetration of objects. If a simulator were to allow large penetrations of objects, then the illusion of object rigidity would be lost.","The practical development of physics-based animations, including rigid body simulations, has proved quite difficult. For simple cases, continuous real life problems can be written using continuous mathematics and solved algebraically. This approach is to high school physics students. However, the set of cases which have algebraic solutions is very small and a rigid body simulator must be able to handle any configuration of contacting rigid bodies. For this reason, a discrete problem is chosen that approximates the continuous problem. A discrete problem can be represented with a finite amount of data and can be evaluated numerically (by a computer) at discrete time intervals. Given that frames of animation are only required at discrete time intervals, this is an acceptable limitation.","Selecting a discrete model that approximates a sufficiently large class of continuous problems and is solvable in real time by a computer is difficult. A poor choice of discrete model can result in behavior that diverges unacceptably from the original continuous problem. For example with a bad model, objects might jump around for no reason, penetrate unacceptably, fall through a floor, or fly off into infinity.","At least in the context of computer games, the accuracy of the discretization with respect to the continuous problem is not particularly important. This result arises because unlike simulations used in science and engineering, computer game simulations need not be predictive. Any plausible discrete model will do. However, although this relaxed requirement makes it easier to meet the real-time constraint, it unfortunately doesn't make the mathematics any easier.","Numerous issues must be addressed when building a display system adapted to run real-time, physics-based animations. For example, the geometry of objects plays an important role in determining the physics of motion, as well as the physics of contact between objects. An object may be a single rigid body such as a chair or house, or may consist of a number of connected (e.g., jointed) bodies, such as a human figure. Collision or contact between objects must be accurately determined. Solving the necessary equations of motion to realistically animate objects has proved to be a difficult problem since accuracy (i.e., realism) and computational speed are always at odds.","In addition to preventing object\/object or object\/environment penetration, a display system implementing rigid body simulation must also take various physical properties of the objects into account when determining their motion. An example of such a property is mass. Further, physics-based animations must faithfully track and account for forces, such as gravity, acting upon objects. A rigid body simulator, or \u201cengine,\u201d associated with the display system must also create the illusion that simulated objects have certain surface properties, such as friction.","As one might expect, the modeling and simulation of the complexities arising from varied object geometries, interacting objects and forces, and changing object constraints requires a great deal of sophisticated mathematics. However, the mathematics implicated in the present invention are conventional. That is, those of ordinary skill in the art will understand the mathematical bases upon which the present invention is predicated. It is neither appropriate nor required that this present description try to teach the entire body of implicated mathematics. Nevertheless, some discussion of a mathematical model is required in order to establish a common descriptive vocabulary for the teachings that follow.","The conventional resources typically available in a display system implementing physics-based animations are conceptually illustrated in . Within , resources primarily based in hardware are shown in solid outline while software resources are shown in dotted outline. Those of ordinary skill in the art will recognize that such hardware\/software designations are relatively arbitrary. For example, computational logic may be fully implemented in software or hardwired into a logic device at a system designer's discretion. However, some logical distinction between hardware and software, as exemplified by current best practices, is useful in the description that follows.","In , a Central Processing Unit (CPU) , such as a Pentium\u00ae microprocessor, together with its associated drivers and internal memory, access data from an external memory , and\/or one or more peripheral devices , typically including a display. The terms \u201cinternal\u201d and \u201cexternal\u201d are used to generally differentiate between various memories in relation to the other computational components in a system. Such differentiation is clearly relative, since most internal memory can be turned into external memory and vice verses. Generally speaking, however, an internal memory will typically be co-located on the same chip as related computational component(s), while external memory will typically be implemented using a separate chip or chip set.","A main application  is resident in external memory  and\/or peripheral  (e.g., a magnetic or optical disk, a solid-state memory device such as a PROM, EPROM, or EEPROM, a cartridge for a game console or similar device). Main program  typically uses one or more Application Programming Interfaces (APIs) to access blocks of specialty software associated with various program functions. An API is a well understood programming technique used to establish a lexicon of sorts by which one piece of software may \u201ccall\u201d another piece of software. The term \u201ccall\u201d as variously used hereafter broadly describes any interaction by which one piece of software causes the retrieval, storage, indexing, update, execution, etc., of another piece of software.","Data instructions, often in a prescribed packet form and referred to hereafter as \u201ccommands,\u201d are generally used to initiate calls between one or more software or hardware components. Execution (i.e., \u201crunning\u201d) of software, in any of its various forms including micro-code, occurs upon receipt of an appropriate command.","Conventional display systems implementing physic-based animations routinely include or incorporate by functional \u201ccall\u201d a related piece(s) of specialty software referred to generically hereafter as a \u201cphysics engine.\u201d A physics engine may be thought of as an operative collection of resources, including specialized software, implementing realistic, real-time (or near real-time) physics effects within a main application.","With the recent and growing appetite for realism, physics engines have been added to the program code implementing, for example, PC games. Indeed, a market has emerged directed to the development physics engines or so-called \u201cphysics middleware.\u201d Companies like HAVOK, MathEngine, Criterion, and Meqon Research have developed specialty software that may be called by a main application to better incorporate natural looking, physics-based interactions into a main application.","Prior to the use of physics engines in games, objects were animated by hand. These animations were triggered in response to input from the user. For example, if the user pressed a punch key, the game would play a corresponding punch animation. If the user pressed the punch key while standing next to a pile of boxes, then an animation of the pile of boxes falling over might have been played. If the user pressed the punch key while standing next to a game character, an animation of that character falling to the floor might have been played.","Since the animated motion displayed by the game was specified by a set of \u201cpre-drawn\u201d animations, the punch, the falling boxes, and the falling character would each move in the same manner every time. As well as being quite boring for the user, the animation could not take into account the context of the action. For example, if the user pressed the punch key next to a wall, there would often be nothing to stop the player's arm going through the wall. If the user had previously parked a car behind the pile of boxes, the boxes would typically fall through the car. If the user punched a character next to a cliff, the punched character would typically fall flat and lie in midair over the cliff rather than falling over the cliff ledge.","These problems were overcome to a certain extent by limiting the actions of the user, for example by not giving the user a car to drive, not allowing the user to walk within arm's length of a wall and not allowing fights next to cliffs. These restrictions were often frustrating to the user. Another way around the problem was to simply generate outcome animations for every possible combination of user actions. However, as the number of possible user actions grows, the number of outcome animations outcomes also grows. Thus, as game complexity increases the cost associated with the development of multiple animations becomes prohibitive.","Games designed using only animation start with a completely restricted environment where nothing unscripted can happen. This completely restricted environment is gradually made more interactive as an animator produces more and more animations. In contrast, games designed using physics-based approaches start with the opposite point of view, namely objects initially have complete freedom of motion. The game designer then, for example, designs a solid environment and adds a constraint that objects can still move with complete freedom, except that they must not fall through the solid environment. In a physics-based game, there is no reason why the user can't be given a car, or be allowed to punch a person next to a cliff, so those constraints are never introduced. As the game design progresses, some additional constraints are added however, as most fun games have rules.","Rather than supplying a set of animations for each object, the game designer specifies a set of physical properties for the object such as mass, friction, and in some cases even elasticity. The physics engine then uses the laws of physics to move the objects as if they had these properties such that they don't violate the specified constraints. The designer of a game incorporating physics-based animation decides which forces and torques should be applied to the objects in response to the user's input.","Of necessity, physics engines include a rigid body dynamics engine adapted to calculate the movement of rigid bodies within an animation. As will be appreciated by those of ordinary skill in the art, a rigid body dynamics engine will typically form one aspect of a larger physics engine. The exact programming and\/or resource boundaries between the rigid body dynamics engine and other effects engines within the physics engine are a matter of design choice, and it is expected that the rigid body dynamics engine will draw upon a library of functions and\/or a pool of common resources provided by the physics engine and\/or by the main application.","Unfortunately, contemporary physics engines have significant limitations as to the number of objects in an animated scene, and more particularly, the number of active (i.e., moving or interacting) objects. Realistic visual images of simulated physics interaction must account for constraints placed upon many or all of the objects. As noted above, a constraint is a restriction on the possible movement or interaction of an object (e.g., a door hinge, a knee joint, a dog on a leash). Increasing complexity of terrain geometry greatly increases the difficulty of simulating object interactions with the terrain. The complexity of collision detection and resolution also increases with the complexity of an object's surface geometry (i.e., its surface detail).","Along with an increasing number of active objects, cutting edge animations and simulations demand an increased number of forces being applied to the objects. These aggregate demands are further aggravated by the increasing number of \u201ctime steps\u201d per second being used in animations (i.e., the frequency with which the animated world with all its objects and forces is updated in real time).","However, among the factors challenging the realistic, real-time animation of objects in a physics-based application, the definition and incorporation of constraints upon the animated rigid body objects has proved most difficult. Indeed, it the existence of numerous constraints that makes the underlying mathematical (numerical analysis) problem much more difficult to resolve, as compared with a simple application of Newton's laws of motion.","One relatively older, conventional approach, generally referred to as the \u201cextended coordinates method,\u201d to the problem of solving physics-based constraint problems expresses constraints using Lagrange multipliers that correspond to forces that effectively maintain the constraints within the animated world space. See, for example, R. Bazel and A. Barr \u201cA modeling system based on dynamic constraints,\u201d 1988, Vol. 22, pp. 179\u2013188 (1988). In such an approach, the Lagrange multipliers result in a large number of variables being used\u2014nearly doubling the variables otherwise required to describe the animation. This increase in constraint-related variables results in an eight-fold increase in the quantity of computational resources required to resolve the animation, as compared with a similar animation lacking constraints.","Performance of the early \u201cconstraint-based\u201d approach to rigid body simulation was improved by the incorporation of mathematical techniques taking advantage of the \u201csparse\u201d nature of the matrixes used to express animation objects, forces, and constraints. See, for example, C. Lubich et al., \u201cMexx\u2014numerical software for the integration of constrained mechanical multi-body systems,\u201d 92-12, --, (1992).","Other approaches to physic-based, rigid body animation extended these constraint-base methods to handle contact between objects. Incorporating contact within an animation is typically done by formulating the constrained dynamics equations as a Linear Complementary Problem (LCP), which is essentially a problem of finding some solution to a linear system that satisfies certain inequality constraints. P. Lodestadt, \u201cMechanical systems of rigid bodies subject to unilateral constraints\u201d 42(2): 281\u201396 (1982), is exemplary of early papers expressing the contact problem as an LCP. D. Baraff, \u201cFast contact force computation for non-penetrating rigid bodies,\u201d 1994, Vol. 28, pages 23\u201334 (1994), later explained the use of an LCP solving algorithm developed by R. W. Cottle and G. B. Dantzig in \u201cComplementary pivot theory of mathematical programming,\u201d 1, (1968).","Early LCP methods proved unreliable because there was no guarantee of the existence of a solution in the presence of contact with Coulomb friction. Indeed, there are known configurations of rigid bodies for which no set of contact and friction forces satisfies all of the constraints. D. E. Stewart and J. C. Trinkle, \u201cAn implicit time-stepping scheme for rigid body dynamics with inelastic collisions and coulomb friction,\u201d , (1996), resolved this difficulty, at least in part, by proposing a scheme that combined acceleration-level LCP with time stepping to obtain an LCP expressed as velocity and impulse variables. This method guaranteed solvability for a larger class of LCPs, and was later modified by M. Anitescu and F. Potra, \u201cFormulating dynamic multi-rigid-body contact problems with friction as solvable linear complementary problems,\u201d 14:231\u201347 (1997). Both of these documents propose use of the Lemke algorithm to solve LCPs. However, both approaches are impractically slow for use within real-time animations and overly prone to large computational errors.","In a more recent work, U.S. patent application Ser. No. 2003\/0 179 205 A1 published Sep. 25, 2003 in the name of Smith et al., a rigid body simulator is proposed in which LCPs are solved using Murty's algorithm applied to velocity and position parameters instead of an acceleration parameter. Smith et al. further propose the use of a semi-implicit integration step in which constraint forces are determined by ensuring that the first derivative of the constraint function is zero, as compared with previous approaches which held the second derivative to zero.","Yet, all of the foregoing approaches to the resolution of LCPs arising from consideration of systems containing constrained, rigid bodies remain unsuited for real-time applications, unless such systems are greatly restricted in size and\/or complexity. The conventional approaches are simply too slow. This slowness generally results from the use inefficient computational methods and inappropriate data forms.","The present invention succeeds where all previous approaches to the real-time animation of physics-based interactions between rigid bodies have failed.","In one aspect, the present invention provides a method of operating a display system having a display, a processing unit and a memory. The method is adapted to animate on the display system n objects subject to constraints which remove m degrees of freedom (hereafter, \u201cm constrained degrees of freedom\u201d). The method is characterized by defining and storing system parameters in memory, wherein the system parameters define the objects and at least one constraint acting upon the objects. Following an increment in a defined time step, the method calculates updated system parameters in the processing unit using a projected iterative descent method applied to a Linear Complementarity Problem (LCP) defined in relation to the system parameters, such that animated motion of the objects is determined in relation to the updated system parameters.","In a related aspect, the present invention provides a computational method for solving a Linear Complementarity Problem (LCP) having a form f=LCP(b, JMJ), where the LCP is derived from a data set related to rigid body dynamics and the data set comprises vector b, Jacobian J and Mass matrix M.","The method initializes and maintains f\u2014a candidate solution to the LCP. At each iteration, the method modifies the candidate solution so that it is in some sense closer to a final solution to the LCP. In one preferred embodiment, the iterations continue until the candidate solution is sufficiently close to the final solution as determined by a predetermined difference threshold. In an alternate embodiment, a fixed number of iterations is executed.","Following initialization, the method assigns to f an arbitrary initial candidate solution fthat lies in the feasible region defined between limits lo and hi, or lo<f<hi. The method then checks for termination. It then modifies f using a projected iterative descent method. The method iterates until termination.","Termination may be defined by a fixed number of iterations, or by satisfaction of a set of boxed conditions related to the LCP.","In yet another related aspect, the present invention provides a computational method for resolving a Linear Complementarity Problem (LCP) derived from a data set. The data set is defined in relation to a plurality of rigid bodies and one or more constraints defining limitations upon the motion of the rigid bodies. The method applies a projected iterative descent method to data forms derived from the data set during a fixed maximum time period. Of note, the fixed maximum time period allows real-time animation of the dynamic interaction of the rigid bodies on a display system.","In yet another aspect, the present invention provides an iterative method for solving a Linear Complementarity Problem (LCP) having a form LCP (b+Cf, A), C being a constant and f being an arbitrary candidate solution for each method iteration. The LCP is derived from a data set related to rigid body dynamics. The method is characterized by steps that assign an arbitrary, non-negative vector as an initial candidate solution ffor an initial iteration 0. Then the method solves the LCP by defining a subsequent candidate solution ffor an iteration X+1, such that the subsequent candidate solution fis always closer to a final solution than a previous candidate solution f, for all fgreater than zero. Iteration continues until a termination test is passed\u2014either execution of a maximum number of iterations, or satisfaction of a set of boxed conditions for the LCP.","In still another aspect, the present invention provides a computational method solving a Linear Complementarity Problem (LCP) derived from a data set. The data set is related to a plurality of dynamically interacting rigid bodies and a plurality of constraints defining limitations on the motion of the plurality of rigid bodies. The computational method comprises defining LCP data from the data set, and solving the LCP by applying a projected iterative descent method to the LCP data.","In yet another aspect, the present invention provides a system comprising at least one processing unit, a memory, and a plurality of peripherals including a display. The system is adapted to animate the motion of a plurality of objects on the display. A program stored in memory causes the system to store a data set in memory. The data set defines physics-based characteristics for the plurality of objects and an initial state of an animation of the plurality of objects. The program also stores constraint parameters in memory. The constraint parameters define at least one constraint function constraining movement of at least one of the plurality of objects in the animation.","The program then calculates in the processing unit velocity and force parameters defining the state of the animation following a time step by applying a projected iterative descent method to the data set in accordance with the constraint parameters.","In a one related aspect, the processing unit calculating the velocity and force parameters comprises a general purpose Central Processing Unit (CPU) for the system. Alternatively, the processing unit comprises a dedicated Physics Processing Unit (PPU) associated with the system.","Some additional insight into the failure of previous approaches to the time efficient resolution of LCPs arising from physics-based data serves as a useful transition into a written description of several preferred embodiments of the present invention. As discussed above, many specialized LCP \u201csolvers\u201d have previously been proposed.","Consider, for example, the approach used by the Open Dynamics Engine (\u201cODE\u201d). See, http:\/\/opende.sourceforge.net\/. This approach is actually modified version of the computational method described by Dantzig. The animation of a 10 brick-by-10 brick wall collapsing after the impact of a cannon ball serves as a convenient performance benchmark. Unfortunately, such an animation typically takes several or even tens of seconds per animation frame (nominally 16 ms) to resolve using the ODE solver running on a PC having an Intel P4 2 GHz microprocessor. Clearly, such resolution precludes a realistic, real-time animation of the collapsing wall. The LCP's underlying a physics-based animation of the collapsing wall simply can not be resolved quickly enough using the ODE solver. This performance bottleneck will soon become even more serious as next generation physics animations contemplate LCPs ranging in size from 1 by 1, up to 15,000 by 15,000 (i.e., LCPs sufficient to simulate the collapse of32-by-32 brick wall).","The LCP is essentially a combinatorial problem, in that there are a discrete number of possibilities for the solution. For a boxed LCP of size m, the solution is one of 3possibilities. This is in contrast to most mathematical problems, for which the solution is one of an infinite number of possibilities. Given one of the possible solutions, a \u201ccandidate solution,\u201d it is possible to test whether the candidate solution is the solution or not using a computation that is simpler than solving the LCP. So, a very simple computational method adapted to resolve the LCP could just test each of the 3candidate solutions until it finds one that satisfies the test. While this na\u00efve approach conceptually illustrates the conventional \u201cactive set\u201d methods, it is not really a practical approach to the resolution of LCPs. This becomes clear when a worst case scenario is considered in which 3\u22121 candidate solutions are checked before a solution is found. More particularly, consider a problem size similar to those effectively resolved by the present invention, e.g., where m=10,000 a worst case number of tests would equal 3, or 1*10. If each test takes 1 ms to perform, then the computational method would take 5*10billion years to resolve the worst case scenario.","The reason there are 3candidate solutions for a boxed LCP is that one of three conditions must hold for each of the m row constraints. These conditions are referred to as \u201cclamped high\u201d, \u201cclamped low\u201d and \u201cunclamped.\u201d Each one of the 3candidate solutions may be assigned a unique label by specifying which of the three conditions hold for each of the m row constraints. For example, for an LCP with m=2, one possible label is (clamped high, unclamped). Such a unique label defines an active set.","Active set methods are similar to the naive method described earlier in that they test selected candidate solutions from the collection of 3candidate solutions until a solution is found. However, unlike the naive method, active set methods do not search through the collection of candidate solutions sequentially. At each step, active set computational methods use the label associated with the \u201ccurrent\u201d candidate solution under consideration to determine which candidate solution to test next.","Usually a heuristic is used to determine the next candidate solution to try given the label of the current candidate solution. Although the heuristics are chosen so that a small number of candidate solutions are tested in an average scenario, in a worst case scenario it is still necessary to test all of the 3candidate solutions.","In practical applications of a physics engine, the number of candidate solutions subject to testing is limited. This is particularly true where the maximum LCP resolution time is defined in relation to the frame rate of a real-time display. Accordingly, where the maximum resolution time is reached before resolution of the LCP, conventional active set methods typically use the last candidate solution tested as the solution. Unfortunately, with active set methods there is no guarantee that the next candidate solution will be any closer to the solution than the last candidate solution. Thus, if the search is terminated prematurely there is no guarantee that the candidate solution returned by the method will be anywhere close to the solution. Even worse, if the active set computational method is repeated with more iterations, there is no guarantee that the new solution will be any better than the original.","Another problem associated with active set methods is that each test typically involves a number of large (m) matrix operations. That is, if m=10,000, then the number of operations per iteration is proportional to 10,000, or one trillion. Although a designer has control over the run time of the method by varying the maximum number of iterations allowed, this is a very coarse control mechanism due to the large quantity of time taken by each iteration. Active set methods often require expensive data permutation such as principle sub-matrix operations. These data permutations make active set methods especially unsuitable for hardware implementation.","In contrast, our projected iterative descent method guarantees that every iteration will move the current candidate solution closer to a final solution. The more time a designer is able (or willing) to allocate to an LCP solver incorporating the method of the present invention, the better the final solution provided by the solver. A designer may choose to hold the number of iterations constant and let the quality of the solution vary, or hold the required quality constant and let the solution time vary.","Further, the number of operations performed per iteration by a method designed in accordance with the present invention is not related to m, and is relatively small\u2014generally less than a hundred. This allows a system designer very fine grained control over the trade-of between speed and quality.","Consider the conventional active set method used by the Open Dynamics Engine noted above. This method is an extension of Dantzig's method and makes use of the following three active sets:\n\n={()|0=lo},\n\n={()|0=hi}, and\n\n={()|0,lo<<hi}.\n","It can be shown mathematically that the computational use of these active sets is the equivalent of the LCP \u201cboxed\u201d (i.e., limiting) conditions shown below in equations (4) through (7). It is common to express the data defining a rigid body dynamics problem in matrix form. A matrix can be thought of as a collection of related data that expresses in mathematical terms the conditions defining an animation. That is, a matrix (or group of matrices) contains all the data sufficient to define the nature and characteristics of the objects, forces, and constraints making up an animated world space. It is common within this context, particularly in relation to constraints, to group closely related data into a matrix row, or a set of adjacent matrix rows.","Continuing with the ODE example, if a data row is found in any one of three active sets, a solution can be found that accurately defines the position and motion of an object related to the row of data. An accurate solution will properly account for all of the limiting conditions applied to objects in the animated world space. Thus, the ODE solver attempts to resolve the LCPs defining the position and motion of rigid bodies in an animated world space by placing all of the resulting data rows into one of the three active sets. The computational method works row by row sequentially defining each row as a \u201cworking row,\u201d and trying to solve each working row by properly placing it into one of the active sets.","Unfortunately the solving process is not at all straightforward due to the complexities introduced by the box conditions. (Recall that these box conditions arises from mathematical expressions of constraints placed upon the objects in the animation). Because of these complexities, the act of solving for a particular working row often requires a large re-working of sorts for previously resolved rows. In effect, previously resolved rows may need to the transferred between the three active sets in order to properly solve each new working row. This result creates a situation where the computational method used by the ODE solver to resolve LCPs actually runs in a non-linear manner.","Each transfer of a row between active sets requires resolution of another linear system. Solving a linear system can be a very time consuming process. Additionally, conventional approaches to LCP resolution require the definition (i.e., construction), storage, and mathematical use of very large, very dense matrices. For example, a very large system matrix A must be explicitly constructed and stored in memory. These large, complex data forms are thereafter used in computational operations. As a result, huge matrix\/vector multiplication operations must be repeatedly performed. Little wonder active set approaches to LCP resolution are incapable of acceptable performance within a real-time display system.","The foregoing discussion is drawn to the ODE solver, as an illustrative example. However, all computational methods relying on the use of active sets are similarly handicapped. Each variously requires resolution of a linear system during each iteration, explicit construction and storage of system matrices, and\/or complex computational operations. In contrast, the present invention does not suffer such disabilities. Lacking such time and memory space consuming requirements, a computational method defined according to the present invention is able to run in real-time while providing accurate resolution of LCPs, like those arising from the display of rigid body dynamics.","Calculating the motion of objects, such as rigid bodies, subject to bilateral constraints (e.g., joints, etc.) as well as unilateral constraints (e.g., friction, gravity, etc.) is one of the most time consuming, resource demanding, and intellectually challenging aspects of real-time, physics-based animations. Simply put, conventional approaches are too slow and too unreliable to create complex, real-time, realistic looking animations. As noted above, a collection (one or more) of rigid bodies (moving or at rest) and a collection of forces acting upon the rigid bodies can be effectively modeled as a set of bounded quadratic minimization problems, which when expressed with appropriate constraints are more routinely referred to as Linear Complementary Problems (LCPs).","LCPs are not exclusively found in physics-based animations. For example, LCPs find routine application in the field of economics. Multiple conventional algorithms have been applied to the resolution of LCPs across a number of technical fields.","In contrast to the active set methods previously used, the present invention makes use, at least in one presently preferred embodiment, of a \u201cprojected iterative descent\u201d method. The term \u201cgradient projection\u201d might also be used to described the presently preferred method for resolving physics-based LCPs.","As noted above, the resolution of active set methods is too slow because permutation of the working sets occurs slowly. For each iteration, at most one constraint (i.e., working row) is added to or dropped from an active set. Thus, if there are relatively few constraints active in an initial candidate solution for an LCP, yet there are many constraints active in the final solution, then numerous mathematical iterations are required to \u201cconverge\u201d from the initial candidate solution to an accurate final solution. So, if the composition of an active set at a starting point in a large LCP is vastly different from its composition at the final solution, convergence will be slow. What is needed is a computational method that allows a working solution to undergo radical changes, if necessary, during each iteration, and\/or a resolving computational method that doesn't require explicit maintenance of working set(s).","The present invention makes use of such a computational method. A number of exemplary, projected iterative descent methods for solving LCPs related to physics-based data are described more fully hereafter.","Returning to the description of an exemplary LCP, and assuming a square \u201csystem matrix\u201d, A, having \u201cn by n\u201d elements, and a real n-dimensional vector b (unconstrained velocities) (hereafter vectors are shown in bold text), the complementarily problem consists of finding the n-dimensional vectors x (forces) and u (velocities) that satisfy the conditions shown in equations (1) and (2) below.\n\n\u2003\u2003(1)\n\n\u22670\u22670=0or \u22001,2, . . . ,\u2003\u2003(2)\n\nThe LCP problem is given by the notation LCP(b,A).\n","As introduced above, a generalization of the LCP often used in rigid body dynamics is the boxed LCP. The boxed LCP problem starts from the definition of the standard LCP and adds two, additional n-dimensional limits lo and hi, the lower and upper bounds respectively, such that the following equations (3) through (7) below hold true. The lo and hi limits may be viewed as force boundaries or thresholds defined in relation to the specific physical phenomena applicable to a physics-based animation. U.S. patent application Ser. No. 2003\/0179205 to Smith et al. published Sep. 25, 2003, the subject matter of which is hereby incorporated by reference, describes one method by which lo and hi are selected.\n\nfor \u22001\u2003\u2003(3)\n\nlo\u2266x\u2266hi\u2003\u2003(4)\n\nx=lou\u22670\u2003\u2003(5)\n\nx=hiu\u22670\u2003\u2003(6)\n\nlo<x<hiu=0\u2003\u2003(7)\n\nSystem matrix A may be defined as A=JMJ, where J is the Jacobian (1derivative) calculated from the constraints, and M is the matrix of mass and moment of inertia for the objects in the system. Solving a LCP is essentially a problem of finding a solution to a linear system that satisfies the foregoing inequality and complementarity constraints\n","The explanation that follows draws upon a useful mathematics tool called \u201cdata refinement.\u201d See, C. C. Morgan and P. H. B. Gardiner, \u201cData refinement by calculation,\u201d 27: 481\u2013503, (1990). As will be seen below, data refinement may be used in several exemplary embodiments to progressively refine a more general computational method applicable to LCPs into a computational methodology adapted to the efficient resolution of rigid body dynamics. Accordingly, the present invention is described in some additional detail below within the context of a projected Gauss-Seidel LCP solver adapted to large scale, real-time, rigid body dynamics simulation. A description of the general Gauss-Seidel method may be found at R. W. Cottle et al., \u201cThe Linear Complementarity Problem,\u201d , Boston, (1992).","For purposes of illustration, a problem addressed by the present invention is one of accurately predicting or modeling the position and motion of \u201cn\u201d bodies, where one or more of the bodies have \u201cm\u201d degrees of freedom limited by constraints. Mathematically, this problem and its constituent data components may be expressed as a collection of matrix-arranged \u201crow constraints,\u201d where each joint or contact defines a constraint connecting (i.e., relating) two objects.  illustrates a single row constraint  selected from a collection of data expressing mathematically the physical relationship between a number of objects and related constraints. That is, if one is given a set of objects having assigned properties like mass and size, and a set of constraints (i.e., a set of rules defining how objects can move), a mathematical matrix (or collection of matrices) of descriptive data can be developed wherein row-wise values describe an object in one degree of freedom. ( only illustrates a row constraint related to data for x, u, b, and J. This collection of data is merely exemplary, not fully inclusive).","The full collection of physically descriptive \u201cphysics-based\u201d data is modeled as a LCP having the form LCP(b,A), where \u201csystem matrix\u201d A is defined as A=JMJ, where Jacobian J is an \u201cm\u201d by \u201c6 n,\u201d sparse matrix having two sets of 6 contiguous nonzero elements per constraint row, and Mass Matrix M is a \u201c6 n by 6 n\u201d block diagonal matrix with block size 6. System matrix A, which need not be explicitly calculated in the present invention, is preferably an \u201cm by m\u201d symmetric, positive, semi-definite matrix.","In one aspect, the present invention is said to be \u201cprojected,\u201d i.e., computationally applied to a LCP. In another aspect, the present invention is said to be \u201citerative.\u201d Generally speaking, iterative computational methods may be viewed as methods in which a candidate solution is progressively refined until it becomes sufficiently close to the final solution of the problem. In another aspect, the present invention is said to be a \u201cdescent method\u201d in that each iteration is guaranteed to take a current candidate solution closer to the final solution. Certain iterative computational methods are derived by considering \u201csplittings\u201d of the system matrix. As applied to a system matrix A, pair (B,C) is called a splitting of A, if A=B+C. For further background in matrix splitting algorithms and their application to LCPs, see the text by R. W. Cottle et al., , Academic Press, Boston (1992).","The \u201cprojected\u201d, \u201citerative\u201d and \u201cdescent natures of the present invention are further illustrated in the exemplary computational method described with respect to . The method shown in  is applied to splittings of LCP(b,A).","In the following example, a computational method is derived for a standard LCP. A modification gives the derivation for a boxed LCP. During an Initialization step , fis defined as an arbitrary, non-negative vector, where x is set to 0. A general iteration step  is defined as a computational, wherein for a given f\u22670, LCP (b+Cf, A) is solved by letting fbe an arbitrary solution. During a Test for Termination step , a determination is made as to whether fsatisfies a prescribed stopping rule, and if \u201cYes\u201d then the method terminates, but if \u201cNo\u201d the method returns to step  after incrementing a time step.","Different choices of the matrix splitting (B,C) lead to a different selection of the computational method applied to solving LCP(b,A). Where B is selected such that B=L+D, where L and D are, respectively, the strictly lower triangular and diagonal parts of A, and where the components of the iterate fare given recursively by,",{"@attributes":{"id":"p-0080","num":"0079"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msubsup":{"mi":["f","i"],"mrow":{"mi":"X","mo":"+","mn":"1"}},"mo":"=","mrow":{"mi":"max","mo":["(",")"],"mrow":{"mn":"0","mo":",","mrow":{"msubsup":{"mi":["f","i","X"]},"mo":"-","mrow":{"msubsup":{"mi":["a","ii"],"mrow":{"mo":"-","mn":"1"}},"mo":["(",")"],"mrow":{"mi":"b","mo":["+","+"],"mrow":[{"munder":{"mo":"\u2211","mrow":{"mi":["j","i"],"mo":"<"}},"mo":"\u2062","mrow":{"msub":{"mi":["a","ij"]},"mo":"\u2062","msubsup":{"mi":["f","j"],"mrow":{"mi":"X","mo":"+","mn":"1"}}}},{"munder":{"mo":"\u2211","mrow":{"mi":["j","i"],"mo":"\u2265"}},"mo":"\u2062","mrow":{"msub":{"mi":["a","ij"]},"mo":"\u2062","msubsup":{"mi":["f","j","X"]}}}]}}}}}},{"mi":"i","mo":"=","mn":"1"}],"mo":[",",",","\u2062",",",","],"mi":["\u2026","m"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}},{"mrow":{"mo":["(",")"],"mn":"8"}}]}}}},"br":{}},"The following pseudo-code is illustrative of a simple programming method adapted to implement a projected Gauss Seidel algorithm with fixed (maximum number) iterative steps (\u201cnumIterations\u201d):",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f, x := 0, 0"]},{"entry":[{},"while x \u2260 numIterations"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i:=0"]},{"entry":[{},"while i \u2260 m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f:= max(0, f\u2212 a(b+ (Af)))","(9)"]},{"entry":[{},"i := i + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},"x := x + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As can clearly be seen in equation (9) above, the projected iterative descent method is most computationally intense (or \u201cdominated\u201d by) the repeated multiplication of system matrix A by f. Thus, in so far as the this computational step can be simplified or reduced in iteration, the speed with which the LCP is resolved will be increased. Within the context of the present invention, the particular structure of system matrix A may be exploited by introducing an auxiliary variable which will significantly reduce the cost of the dominate computation noted above.","Although system matrix A is actually the mathematical product of three separate matrices, it is convenient to express A as the product of Jacobian, J, and the transpose of a \u201cJacobian\/Mass\u201d matrix J, where Jis defined as the product of J and the mass-inertia matrix M, or\n\n*(), where \u2003\u2003(10)\n","A new vector variable \u201cv\u201d preferably having a size of \u201c6 n\u201d and referred to as an \u201cauxiliary variable\u201d is now introduced. A coupling invariant defines auxiliary variable v in terms of Jacobian\/Mass matrix Jand the candidate solution f, as follows:\n\n=()\u2003\u2003(11)\n\nAuxiliary variable v may be thought of (i.e., interpreted) as the velocity of an object in animated world space. Rewriting equation (11) above (and remembering that Mis symmetric) yields:\n\n*(),\u2003\u2003(11\u2032)\n\nwhere Jf is the impulse applied to enforce the constraints. Of note in this particular example, the proper choice of coupling invariant dramatically improves the efficiency of a computational method designed in accordance with the present invention.\n","Pseudo-Code example 1 above may be modified as follows to incorporate the use of auxiliary variable v defined by the coupling invariant.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f, v, x := 0, 0, 0"]},{"entry":[{},"while w \u2260 numIterations"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i := 0"]},{"entry":[{},"while i \u2260 m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f:= max(0, f\u2212 a(b+ (Jv)))","(12)"]},{"entry":[{},"v := (J)f","(13)"]},{"entry":[{},"i := i + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},"x := x + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The term (b+(Jv)) in the computational step above also has a physical interpretation, i.e. constraint space velocity for a current constraint row i, or more correctly the rate of change of the constraint violation for row constraint i. Considering that only one element of f changes per iteration, auxiliary variable v can be updated in an incremental way. This recognition allows the working Pseudo-Code example to be further optimized as shown below.",{"@attributes":{"id":"p-0089","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f, v, x := 0, 0, 0"]},{"entry":[{},"while x \u2260 numIterations"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i := 0"]},{"entry":[{},"while i \u2260 m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"newf := max(0, f\u2212 a(b+ (Jv)))","(14)"]},{"entry":[{},"v := v + (J)(newf \u2212 f)","(15)"]},{"entry":[{},"f:= newf"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i := i + 1"]},{"entry":[{},"endwhile"]},{"entry":[{},"x := x + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As can be seen from (15) above, \u201cnewf\u201d is an intermediate value that will be assigned back into the current candidate solution \u201cf\u201d. The term \u201cnewf-f\u201d is thus used to incrementally update auxiliary variable v. Of note, equation (13) in Pseudo-Code example 2 requires the multiplication of a large matrix J(size=6 n by m) with a large vector, candidate solution f (size=m). However, use of auxiliary variable v allows equation (15) in Pseudo-Code example 3 to replace this complex multiplication step with a small vector scaling and addition. Replacement of the complex, large-matrix by large vector multiplication step with a simple, scaled vector addition step, (newf\u2212f), greatly reduces the number of floating point operations required to compute each iteration.","The projected iterative descent method according to the present invention may be further optimized by taking advantage of the sparsity of the constituent matrices forming much of the physics-based data expressed in the LCP. The Jacobian J and the Jacobian\/Mass matrix Jare ready examples of sparse matrices. It is convenient to consider each row of J and Jas a matrix of \u201c1 by 6\u201d data blocks, or\n\n=()1\n\n=()1\u2003\u2003(16)\n\nwhere Jand Jare 6 vectors, i and j denoting rows and columns respectively. For the physics-based data typically operated upon by the computational method according to the present invention, each row of J has at most 2 nonzero blocks, i.e. at most two of J,j=1, . . . n are not zero.\n","We will now introduce variables Jand Jto hold \u201ccompressed\u201d representations of J and J, respectively. Variables Jand Jare matrices with as many rows as Jacobian matrix J, but with only 12 columns\u2014the 12 columns being organized as 2 blocks of 6 columns. Thus, each row of the \u201ccompressed Jacobian matrix\u201d Jand \u201ccompressed Jacobian\/Mass matrix\u201d Jwill only store the two nonzero blocks of the corresponding row of Jacobian matrix J and J, as shown below:",{"@attributes":{"id":"p-0093","num":"0092"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msup":{"mi":["J","C"]},"mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msubsup":{"mi":["J","C"],"mn":"11"}},{"msubsup":{"mi":["J","C"],"mn":"12"}}]},{"mtd":[{"msubsup":{"mi":["J","C"],"mn":"21"}},{"msubsup":{"mi":["J","C"],"mn":"22"}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"msubsup":{"mi":["J","C"],"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"msubsup":{"mi":["J","C"],"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}]}]}}},{"msup":{"mi":["J","MC"]},"mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msubsup":{"mi":["J","MC"],"mn":"11"}},{"msubsup":{"mi":["J","MC"],"mn":"12"}}]},{"mtd":[{"msubsup":{"mi":["J","MC"],"mn":"21"}},{"msubsup":{"mi":["J","MC"],"mn":"22"}}]},{"mtd":[{"mi":"\u22ee"},{"mi":"\u22ee"}]},{"mtd":[{"msubsup":{"mi":["J","MC"],"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"msubsup":{"mi":["J","MC"],"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}]}]}}}],"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}}}},{"mrow":{"mo":["(",")"],"mn":"17"}}]}}}},"br":{},"sub":["ij","ij"],"sup":["C ","MC "]},"An index function I, where I=[1 . . . m]\u00d7[1, 2]\u2192N, that yields the indices of the 2 non-zero blocks for each row is required at this point in the data refinement to relate J to Jand I and to relate Jto Jand I. Using I as a notational shorthand of sorts allows the following abstraction function relating Jand I to J.",{"@attributes":{"id":"p-0095","num":"0094"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["J","ij"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"msubsup":{"mi":["J","C"],"mrow":{"mi":"i","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":",","mrow":{"mrow":[{"mi":["if","j"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"i","mo":",","mn":"1"}}}],"mo":"="}}}}},{"mtd":{"mrow":{"msubsup":{"mi":["J","C"],"mrow":{"mi":"i","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":",","mrow":{"mrow":[{"mi":["if","j"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"i","mo":",","mn":"2"}}}],"mo":"="}}}},{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mn":"0","mo":",","mi":"otherwise"}}}}]}}}},{"mrow":{"mo":["(",")"],"mn":"18"}}]}}}},"br":{},"sub":["M","M"]},{"@attributes":{"id":"p-0096","num":"0095"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["J","Mij"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"msubsup":{"mi":["J","C"],"mrow":{"mi":"Mi","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":",","mrow":{"mrow":[{"mi":["if","j"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"i","mo":",","mn":"1"}}}],"mo":"="}}}}},{"mtd":{"mrow":{"msubsup":{"mi":["J","C"],"mrow":{"mi":"Mi","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":",","mrow":{"mrow":[{"mi":["if","j"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"i","mo":",","mn":"2"}}}],"mo":"="}}}},{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mn":"0","mo":",","mi":"otherwise"}}}}]}}}},{"mrow":{"mo":["(",")"],"mn":"19"}}]}}}}},"Pseudo-code Example 3 may be further refined using these abstraction functions as follows.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f, v, x = 0, 0, 0"]},{"entry":[{},"while w \u2260 numIterations"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = 0",{}]},{"entry":[{},"while i \u2260 m"]},{"entry":[{},"newf := max(0, f\u2212 a(b+ J\u2022 v+ J\u2022 v))","(20)"]},{"entry":[{},"v:= v+ (newf \u2212 f)(J)","(21)"]},{"entry":[{},"v:= v+ (newf \u2212 f)(J)","(22)"]},{"entry":[{},"f:= newf"]},{"entry":[{},"endwhile"]},{"entry":[{},"x := x + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Of note, the computational method illustrated in Pseudo-Code Example 4 includes an inner WHILE loop that takes a constant time interval for execution. Further the only substantial computation step consists of two (2), six-term-wide dot products and two (2), six-term-wide scaled vector additions. The index function I(i,:n) actually has a very clear physical meaning within the context of a physics-based animation\u2014namely, the object IDs of the objects associated with the current constraint row. Practical implementations of a display system adapted to animate the movement of physics-constrained objects require use of a unique identification number (ID) for each object. By using the object ID within the foregoing index function, data associated with the object(s) may be efficiently retrieved from memory.","Within the context of the working example, this final refinement of the computational method allows LCP resolution using only 52 floating point operations (\u201cflops\u201d) per constraint, per iteration. Furthermore, many of these flops may be executed in parallel, where appropriate hardware is provided. (See, for example, commonly assigned and concurrently filed U.S. patent application Ser. No. 10\/815,721.","In real-time animations such as computer games, it is important that the computation of each animation frame (i.e., time step) take the same amount of time, or at least occur within a predetermined maximum amount of time. This condition allows the animation to proceed with a constant frame rate which gives a smooth quality to the animation. For this reason and unlike the generic computational method illustrated in , the methods illustrated by Pseudo-Code examples 1 through 4 do not perform a termination test. Instead, each of these exemplary methods uses a fixed (maximum) number of outer loop iterative steps, as defined by the value of \u201cnumIterations.\u201d","However, this approach may cause variations in the overall quality of the LCP solution on a frame by frame basis. Where such frame by frame variations in quality are unacceptable, an additional evaluation on termination step or condition may be added. The following Pseudo-code example shows how a further modification of Pseudo-code Example 5 can accomplish this.",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"f, v, x = 0, 0, 0"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Find initial maximum unclamped velocity"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"max_u = 0"]},{"entry":[{},"i=0"]},{"entry":[{},"while i \u2260 m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ((f= lo  b< 0)   (fi = hi  b> 0)  ",{}]},{"entry":[{},"(f< hi  f> lo  |b| > Thres))   |b| > max_u","(23)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"max_u = |b|"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endif"]},{"entry":[{},"i:= i + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endwhile"]},{"entry":[{},"while (Thres < max_u)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = 0",{}]},{"entry":[{},"max_u = 0"]},{"entry":[{},"while i \u2260 m"]},{"entry":[{},"u= b+ J\u2022 v+ J\u2022 v","(24)"]},{"entry":[{},"newf := med(lo,f\u2212 a* u,hi)","(25)"]},{"entry":[{},"v:= v+ (newf \u2212 f)(J)"]},{"entry":[{},"v:= v+ (newf \u2212 f)(J)"]},{"entry":[{},"f:= newf"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (( f= lo  u< 0)   (fi = hi  u> 0)  "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(f< hi  f> lo  |u| > Thres))   |u| > max_u","(23)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"max_u = |u|"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"endif"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"endwhile"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end while"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The termination condition evaluation in the foregoing method is based on boxed LCP conditions defined by equations (4) to (7) above. However, any similar conditions might be used in accordance with a competent termination test for a particular computational method.","To summarize the foregoing in selected illustrative aspects, the present invention uses a projected, iterative descent method to solve LCPs formed from physics-based simulation data. A projected Gauss-Seidel algorithm is described as a presently preferred embodiment.","In one related aspect, the projected iterative descent method is defined as having a fixed (or maximum) number of iterations. An outer WHILE loop is described as an example of a programming approach adapted to define the fixed number of computational iterations that ensures that a LCP computation occurs within a predetermined time step duration. Alternatively, a test for termination condition may be incorporated within the computational method.","In another related aspect the projected iterative descent method is refined using an auxiliary variable and coupling invariant to improve overall computational efficiency. With use of a properly selected coupling invariant and a corresponding definition of auxiliary variable, one or more dominate calculation step(s) within the method may be expressed as a relatively simple mathematical calculation\u2014a constant length, scaled vector addition in the foregoing example.","In yet another related aspect, the sparse nature of the physics-based data forming the LCP can be exploited to further simplify the calculations necessary for LCP resolution. Simplified expressions of commonly occurring matrix data forms allows effective use of one or more index functions. Where such index functions define data forms of fixed size, a computational method of fixed duration may be clearly defined.","As noted throughout, one important object of the present invention is the definition of efficient computational methods adapted to solve LCPs related to rigid body dynamics, such that real-time animations are possible. In other words, it is not sufficient to merely develop new computational methods that accurately solve LCPs arising from physics-based data. The computational methods must also operate with sufficient speed to enable real-time animations.","Thus, in the context of physics-based animations, every effort should be made to critically assess the nature of the data mathematically expressing the animated physical circumstances. Such assessment is made in relation to practical implementation considerations, such as coding efficiency, data storage requirements, and data transport limitations.","For example, the computational methods illustrated in Pseudo-Code examples 5 and 6 may be further refined by critically assessing the nature of the constituent physics data. Upon consideration of these examples, one will note that the calculation of intermediate value \u201cnewf\u201d requires repeated use of the system matrix A. System matrix A requires a large amount of memory for storage and is relatively slow to compute. However, only the inverses of the diagonal elements of system matrix A are required for the calculation of the scalar value newf These matrix data elements may be pre-calculated as a \u201csystem matrix related vector\u201d and stored in memory as a data vector having length \u201cm,\u201d thereby obviating the need to store and transfer the entire system matrix, A.","In similar form, the memory space required to store Jacobian J may be reduced by half. If we define a \u201creduced size matrix\u201d Jas\n\n()\u2003\u2003(26)\n\nit may readily be verify that Jsatisfies the relationship\n\nA=JJ\u2003\u2003(27)\n\nBy replacing both Jacobian J and Jacobian\/Mass matrix Jwith respective, reduced size matrices having the form of J, the computational method illustrated in Pseudo-Code example 6 may be improved as shown below in Pseudo-Code Example 7.\n",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"f, v, x = 0, 0, 0"},{"entry":"while x < numIterations"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = 0",{}]},{"entry":[{},"while i \u2260 m"]},{"entry":[{},"newf := max(0, f\u2212 a(b+ J\u2022 v+ J\u2022 v))","(28)"]},{"entry":[{},"v:= v+ (newf \u2212 f)(J)","(29)"]},{"entry":[{},"v:= v+ (newf \u2212 f)(J)","(30)"]},{"entry":[{},"f:= newf"]},{"entry":[{},"endwhile"]},{"entry":[{},"x := x+1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"endwhile"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"By using the data form defined in equation (27), the computational method illustrated in Pseudo-Code example 7 will have the same convergence as the computational method illustrated in Pseudo-Code example 5. However, since the use of memory space within the context of the computational method illustrated in Pseudo-Code example 5 is dominated by the storage of matrixes J and J, use of matrices having the form of reduced sized matrix J, instead of J and J, dramatically reduces this memory requirement imposed on a display system incorporating a rigid body dynamics engine using the computational method of the present invention. This is particularly apparent when one postulates the animation of next-generation, large scale systems in which values for \u201cm\u201d might rise to 15,000.","Of further note in relation to the computational method illustrated in Pseudo-Code example 7, auxiliary variable v is now (implicitly) defined as\n\nv=Jf\u2003\u2003(31)\n\nObviously, this new auxiliary variable no longer has the same physical interpretation as that defined above with reference to equation (11). However, the new coupling invariant may be considered a weighted velocity of the simulated objects in animated world space, each object having the weight of (M). Thus, this example of further optimizing a computational method in relation to its constituent data form(s) also serves to further illustrate the selection and definition of an effective coupling invariant.\n","Undoubtedly, the computational method illustrated in Pseudo-Code example 6 could be similarly optimized by using of a reduced size matrix data form.","In yet another approach, the foregoing computational methods may be further optimized by the incorporation of one or more row filtering techniques.","Observing the exemplary methods illustrated in Pseudo-Code examples 5, 6, and 7, one will note that for each outer iterative loop (i.e. the WHILE loop in each of the given examples), the computation must iteratively run through each one of \u201cm\u201d constraint rows (i.e., up to 15,000 rows for a large scale simulation). However, during each iteration, there might be a great numbers of constraint rows already converging or remaining largely unchanged from the previous iteration (or a set of previous iterations). In such circumstances, the calculation on these constraint rows will not significantly contribute to the process of converging to the final solution. Nevertheless, the calculation of these \u201cnon-contributing\u201d constraint rows requires the expenditure of considerable computational resources.","This observation is true for changes in both vand vin a constraint row i. See, equations (21) and (22) in Pseudo-Code example 5 or equations (29) and (30) in Pseudo-Code example 7. Where during the update of auxiliary variables (i.e., velocity components) vand vthe difference between a new value and a previous value falls below a predetermined threshold, calculation of the constraint row is skipped in the current iteration.","To ensure this kind of row filtering is not to be too aggressive before the iteration finally converges, constraint rows that haven't satisfied the boxed LCP condition are processed during the following iteration. Another exemplary computational method, illustrated below as Pseudo-Code example 8, may be defined by incorporating a row filtering technique as well as reduced sized matrix data forms into the method illustrated in Pseudo-Code example 6. Within this example, an array \u201cnew_v_tag\u201d is used to store tags for all objects, such that for each object a determination may be made as to whether an iteration-wise change in v exceeds a predetermined threshold \u201cThres.\u201d Initially all changes in v are considered greater than \u201cThres\u201d, i.e. a value of \u201c1\u201d is assigned to each entry in array new_v_tag",{"@attributes":{"id":"p-0121","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ initialization"},{"entry":"f, v, x = 0, 0, 0"},{"entry":"new_v_tag = 1"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Find initial maximum unclamped velocity"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"max_u=0"},{"entry":"i=0"},{"entry":"while i\u2260 m"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if","(f= lo  b< 0)  "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(f= hi  b> 0)  ",{}]},{"entry":[{},"(f< hi  f> lo  |b| > Thres))   |b| > max_u","(25)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"max_u = |b|"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endif"]},{"entry":[{},"i:=i+1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"endwhile"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ If max_u remains above threshold, continue iterating"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"while (Thres < max_u)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = 0"]},{"entry":[{},"max_u = 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Remember tags from last (i.e. previous) iteration"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"cur_v_tag = new_v_tag"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Clear tags for current time step"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new_v_tag = 0"]},{"entry":[{},"while i \u2260 m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ If both the two objects have small changes, skip this row"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if !(cur_v_tag[I(i,1)] \u2225 cur_v_tag[I(i,2)])","(32)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"continue to next i = i + 1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endif",{}]},{"entry":[{},"u= b+ J\u2022 v+ J\u2022 v","(33)"]},{"entry":[{},"newf := med(lo,f\u2212 a* u,hi)"]},{"entry":[{},"\u0394v = (newf \u2212 f)(J)","(34)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Check if object I(i,1)'s v has large change"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if \u2225\u0394v\u2225 > Thres"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Set tag for object I(i,1)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new_v_tag[I(i,1)] = 1",{}]},{"entry":[{},"endif"]},{"entry":[{},"v:= v+ \u0394v","(35)"]},{"entry":[{},"\u0394v = (newf \u2212 f)(J)","(36)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Check if object I(i,2)'s v has large change"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if \u2225\u0394v\u2225 > Thres"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"new_v_tag[I(i,2)] = 1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endif",{}]},{"entry":[{},"v:= v+ \u0394v","(37)"]},{"entry":[{},"f:= newf"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Check LCP boxing conditions (4)\u2013(7)."]},{"entry":[{},"\u2003If checked row constraint isn't clamped"]},{"entry":[{},"\u2003update the maximum undamped |u|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ((f= lo  u< 0)   (fi = hi  u> 0)  "]},{"entry":[{},"\u2003(f< hi  f> lo  |u| > Thres))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if|u| > max_u"]},{"entry":[{},"max_u = |u|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"endif"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/If checked row constraint doesn't satisfy the"]},{"entry":[{},"conditions, calculate the row anyway during next"]},{"entry":[{},"iteration"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new_v_tag[I(i,1)] = 1"]},{"entry":[{},"new_v_tag[I(i,2)] = 1"]},{"entry":[{},"i: = i + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"endwhile"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"endwhile"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the foregoing example, convergence is determined in relation to the LCP boxing conditions and convergence threshold value, and in satisfaction of the termination condition, (max_u<Thres) for maximum|u|. Where this termination condition is satisfied, we may also conclude that all row constraints satisfy the LCP boxing conditions and terminate the computational method. Of note, the minimum change threshold value, Thres, may be defined in accordance with a desired trade-off between accuracy and speed of the computational method. If more accurate (or precise) result is required, then the convergence threshold should be selected to be relatively small. On the contrary, a relatively larger convergence threshold will speed convergence. As compared with an similar test case run using a computational method like that illustrated in Pseudo-Code example 6, absent the benefit of row filtering (i.e., incorporation of threshold testing \u0394v<Thres and \u0394v<Thres), test results show that incorporation of row filtering allows up to a five fold performance improvement.","A recent test case was run successfully in real-time using a computational method like the one illustrated in Pseudo-Code example 8. This test case included animation of888 rigid bodies (i.e., n=888), 5170 contacts, and a resulting 15,510 constraint rows (i.e., m=15,510). The convergence threshold, \u201cThres\u201d, was set at 0.01.","In one presently preferred embodiment, row filtering is indirectly implemented within competent computational methods adapted to solve LCPs using two bit tables having \u201cn\u201d entries (i.e. one bit per body), instead of bit tables having m entries (i.e. one bit per constraint row). This further refinement significantly simplifies the implementation of computational methods like the one illustrated in Pseudo-Code example 8.","Thus far in this written description, the foregoing exemplary embodiments of a computational method defined in accordance with the present invention have been presumptively run using a conventional display system like the one conceptually illustrated in . That is, a physics effects engine  running on display system hardware  may fully incorporate a rigid body dynamics engine  running a computational method defined in accordance with the present invention. The display system hardware may take any one of many conventional forms, including a general micro, mini, or mainframe computer, or a gaming console, or similar device. The rigid body dynamics engine incorporating a computational method defined in accordance with the present invention will operate in sympathy with, and typically under the control of, main application .","In general flow, as illustrated in , a display system will store in memory an initial set of system parameters (). System parameters may include, as examples, the size and position of a plurality of objects in an animation to be displayed, as well as their initial respective velocity, if any, and forces acting on one or more of the plurality of objects. The display system will also store an initial set of animation constraints (). Taken collectively, the initial system parameters and constraints \u201cphysically\u201d define an animation world space at an initial time step . Following initialization, the process of displaying a real-time, physics-based animation continues with incrementing the time step (). Following each time step increment, one or more processors (i.e., one or more CPUs, containing one or more computational logic units) associated with the display system calculate and update system parameters in accordance with the defined constraints and the initial (or step-wise previous) state of the system parameters (). Following calculation and update of the system parameters, a termination test is run (). Where a termination condition is satisfied (YES), the method stops. Where the termination condition remains unsatisfied, the method returns to increment the time step ().","Typically, main application  will provide an initial object data array and constraint data array. This data will be integrated by operation of the main application and\/or the physics engine to create a corresponding set of Jacobians, calculate the mass and inertia matrix, system matrix, and related constituent data components, including forces initially acting upon objects in world space.","Following calculation and integration of \u201cupdated\u201d system parameters in accordance with the present invention, system parameter values calculated by the physics engine may be exported to the main application, a peripheral device, and\/or external memory as part of a related method implementing the actual visual display. Thus, while not shown in , the conventional steps required to visually display the position and movement of objects within the animated world space are implicit in the application of the present invention.","A computational method defined in accordance with the present invention may also be efficiently executed on a display system incorporating a separate, hardware-based Physics Processing Unit. Such a display system is described using relevant teaching embodiments in provisional U.S. Patent Application 60\/507,527 filed Oct. 2, 2003 and related non-provisional patent application Ser. Nos. 10\/715,459; 10\/715,370; and 10\/715,440 all filed Nov. 19, 2003. The collective subject matter of these commonly assigned, pending U.S. patent applications is hereby incorporated by reference.","When the computational method according to the present invention is run on a display system incorporating a dedicated PPU, the method is preferably resident in the PPU and runs on the PPU in response to commands received from a corresponding CPU. Indeed, once initial system parameters are communicated from the host CPU to the PPU, rigid body dynamics may be calculated in the PPU largely independent of CPU operation, thereby freeing the CPU from the burden of physics-related data computations. Both the CPU and PPU are termed processing units.","The foregoing examples are just that\u2014examples. They teach the implementation and use of the present invention as presently preferred, but do not strictly limit the scope of the invention. Instead, the scope of the present invention is defined by the claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT(S)","PSEUDO CODE EXAMPLE 1","PSEUDO-CODE EXAMPLE 2","PSEUDO-CODE EXAMPLE 3","PSEUDO-CODE EXAMPLE 4","PSEUDO-CODE EXAMPLE 6","PSEUDO-CODE EXAMPLE 7","PSEUDO-CODE EXAMPLE 8"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings, like reference characters indicate like elements. The drawings, taken together with the foregoing discussion, the detailed description that follows, and the claims, describe a preferred embodiment of the present invention. The drawings include the following:",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
