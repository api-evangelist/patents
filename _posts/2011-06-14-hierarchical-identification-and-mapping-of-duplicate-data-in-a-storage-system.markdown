---
title: Hierarchical identification and mapping of duplicate data in a storage system
abstract: The technique introduced here includes a system and method for identifying and mapping duplicate data objects referenced by data objects. The technique illustratively utilizes a hierarchical tree of fingerprints for each data object to compare the data objects and identify duplicate data blocks referenced by the data objects. A progressive comparison of the hierarchical trees starts from a top layer of the hierarchical trees and proceeds toward a base layer. Between the compared data objects (i.e., the compared hierarchical trees), the technique maps matching fingerprints only at the top-most layer of the hierarchical trees at which the fingerprints match. Lower layer matching fingerprints are neither compared nor mapped. Data blocks corresponding to the matching fingerprints are then deleted. Such an identification and mapping technique substantially reduces the amount of mapping metadata stored in data objects that have been subject to deduplication.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043292&OS=09043292&RS=09043292
owner: NetApp, Inc.
number: 09043292
owner_city: Sunnyvale
owner_country: US
publication_date: 20110614
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["At least one embodiment of the techniques discussed in this application pertains to data storage systems, and more particularly, to a technique for generating hierarchical fingerprints for data objects in a storage system for the purpose of identifying and mapping duplicate data.","A network storage controller is a processing system that is used to store and retrieve data on behalf of one or more hosts on a network. A storage server is a storage controller that operates on behalf of one or more clients to store and manage data in a set of mass storage devices, such as magnetic or optical storage-based disks or tapes. Some storage servers are designed to service file-level requests from clients, as is commonly the case with file servers used in a network attached storage (NAS) environment. Other storage servers are designed to service block-level requests from clients, as with storage servers used in a storage area network (SAN) environment or virtual tape (VTL) environment. Still other storage servers are capable of servicing both file-level requests and block-level requests, as is the case with certain storage servers made by NetApp, Inc. of Sunnyvale, Calif.","In a large-scale storage system, such as an enterprise storage network, it is common for certain items of data, such as certain data blocks, to be stored in multiple places in the storage system, sometimes as an incidental result of normal operation of the system and other times due to intentional copying of data. For example, duplication of data blocks may occur when two or more logical containers of data (e.g., files, virtual tapes, etc.) have some data in common or where a given set of data occurs at multiple places within a given logical container of data. For example, consider a scenario where a user creates a Windows PowerPoint\u00ae document and stores the document at a first location of the storage system. The user sends the document over to another user, who then makes minor edits to one small section of the document. The second user then stores the edited document in a different location of the storage system. Here, we have two data objects (i.e., the two Windows\u00ae documents) that operate as logical containers of data. Each data object logically references a set of physical data blocks that stores the data corresponding to the documents. Since the two documents are substantially similar, there will be a substantial number of identical data blocks (i.e., duplicate data blocks) referenced by the two data objects. Duplication can also occur if the storage system backs up data by creating and maintaining multiple persistent point-in-time images, or \u201csnapshots,\u201d of stored data over a period of time. Data duplication generally is not desirable, since the storage of the same data in multiple places consumes extra storage space, which is a limited resource.","Consequently, in many large-scale storage systems, storage controllers have the ability to \u201cdeduplicate\u201d data, which is the ability to identify and remove duplicate data blocks. In one known approach to deduplication, data blocks referenced by two data objects (i.e., an original data object and a new data object) are compared and duplicate data blocks referenced by one of the data objects (e.g., the new data object) are deleted. Any references (e.g., pointers) of the new data object to those duplicate (deleted) data blocks are modified to refer to the remaining instances of those data blocks (i.e., the data blocks referenced by the original data object). A result of this process is that a given data block may end up being shared by the two data objects.","Further, in known deduplication approaches, the new data object (i.e., the data object referencing deduplicated data blocks) stores one-to-one mapping of each deleted data block to a corresponding data block referenced by the original data object. Such one-to-one mapping data is generated and stored for each individual deduplicated data block. Typically, such mapping information is stored in metadata associated with the data object.","Now consider the above example of the PowerPoint\u00ae documents. Each time a new copy of the document (i.e., a new data object) is created by a user to make minor edits, new data blocks (much of which are substantially similar to the original document) are created and stored within the storage server. Accordingly, a substantial number of data blocks referenced by these new copies (i.e., new data objects) will be identical to the original copy of the document. Even after the duplicate data blocks referenced by the new data object are deleted, each data object will still hold a substantial amount of \u201cmapping metadata\u201d to store mapping information for each deduplicated data block, consequently increasing the storage footprint of the corresponding data objects.","The techniques introduced here include systems and methods for identifying and mapping duplicate data objects referenced by data objects. The techniques illustratively utilize a hierarchical tree of fingerprints for each data object to compare the data objects and identify duplicate data blocks referenced by the data objects. The hierarchical fingerprint trees include at least two layers of fingerprints. A base layer of the hierarchical tree includes one fingerprint for each data block referenced by a data object. A layer over the base layer includes a lesser number of fingerprints (relative to the base layer), where each entity is a fingerprint of two or more fingerprints from an immediately lower layer. Any number of layers may be generated over the base layer in a similar manner, culminating at a single fingerprint at a top-most layer. This single fingerprint is representative of all the data blocks referenced by a data object, and is considered the object-level fingerprint of the data object.","A progressive comparison of the hierarchical trees starts from the top layer of the hierarchical trees and proceeds toward the base layer. In an illustrative example comparing two data objects, the technique introduced herein starts by comparing the top-layer fingerprints of the hierarchical trees of the two data objects. If there is a match, the two top-level fingerprints are matched and the comparison stops. If there is no match, processing steps to an immediately lower layer. The technique maps any sets of matching fingerprints at this layer, but allows processing to continue to the next lower layer of the hierarchical trees only for non-matching sets of fingerprints. In this manner, processing proceeds as necessary until the base layer of the hierarchical trees. The matching fingerprints are mapped only at the highest layer of the hierarchical trees at which they match with the compared fingerprints. Data blocks corresponding to the matching fingerprints are then deleted. Accordingly, multiple data blocks of one data object are capable of being simultaneously linked to a corresponding matching data blocks of another data object using just one mapping reference. Consequently, such an identification and mapping technique substantially reduces the amount of mapping metadata stored in data objects that have been subject to deduplication.","References in this specification to \u201can embodiment\u201d, \u201cone embodiment\u201d, or the like, mean that the particular feature, structure or characteristic being described is included in at least one embodiment of the present invention. Occurrences of such phrases in this specification do not necessarily all refer to the same embodiment.","I. Overview","The techniques introduced here include systems and methods for identifying and mapping duplicate data objects referenced by data objects. The techniques illustratively utilize a hierarchical tree of fingerprints for each data object to compare the data objects and identify duplicate data blocks referenced by the data objects. A progressive comparison of the hierarchical trees starts from a top layer of the hierarchical trees and proceeds toward a base layer. Between the compared data objects (i.e., the compared hierarchical trees), the technique maps matching fingerprints only at the top-most layer of the hierarchical trees at which the fingerprints match. Lower layer matching fingerprints are neither compared nor mapped. Data blocks corresponding to the matching fingerprints are then deleted. Such an identification and mapping technique substantially reduces the amount of mapping metadata stored in data objects that have been subject to deduplication.","II. System Environment","Refer now to , which shows a network storage system in which the technique being introduced here can be implemented. In , a storage controller  is coupled to a storage subsystem  and to a set of clients  through an interconnect . The interconnect  may be, for example, a local area network (LAN), wide area network (WAN), metropolitan area network (MAN), global area network such as the Internet, a Fibre Channel fabric, or any combination of such interconnects. Each of the clients  may be, for example, a conventional personal computer (PC), server-class computer, workstation, handheld computing\/communication device, or the like.","Storage of data in the storage subsystem  is managed by the storage controller  configured to operate as a network storage server. The storage controller  and the storage subsystem  are collectively referred to herein as the storage system . The storage controller  receives and responds to various read and write requests from the clients , directed to data stored in or to be stored in storage subsystem . The storage subsystem  includes a number of nonvolatile mass storage devices , which can be, for example, conventional magnetic or optical disks or tape drives; alternatively, they can be non-volatile solid-state memory, such as flash memory, or any combination of such devices. The mass storage devices  in storage subsystem  can be organized as a Redundant Array of Inexpensive Disks (RAID), in which case the storage controller  can access the storage subsystem  using a conventional RAID algorithm for redundancy.","The storage controller  includes a storage operating system , which is responsible for managing storage of data in the storage subsystem , servicing requests from clients , and performing various other types of storage related operations. In the illustrated embodiment, the storage operating system  includes a deduplication system  which performs deduplication of data blocks, which may include operations related to identifying duplicate blocks, generating hierarchical fingerprint trees for data objects, mapping data objects sharing common data blocks, etc. In some embodiments, the deduplication system  may be a separate component that is different from the storage operating system . In certain embodiments, the storage operating system  and deduplication system  are both implemented in the form of software (executed by one or more programmable processors). In other embodiments, however, either or both of these elements may be implemented in pure hardware, e.g., specially-designed dedicated circuitry, or as a combination of software and specially-designed dedicated circuitry.","The storage controller  can be, for example, a storage server which provides file-level data access services to clients, such as commonly done in a NAS environment, or block-level data access services such as commonly done in a SAN environment, or it may be capable of providing both file-level and block-level data access services to hosts. Further, although the storage controller  is illustrated as a single unit in , it can have a distributed architecture. For example, the storage controller  can be designed as a physically separate network module (e.g., \u201cN-blade\u201d) and disk module (e.g., \u201cD-blade\u201d) (not shown), which communicate with each other over a physical interconnect. Such an architecture allows convenient scaling, such as by deploying two or more N-modules and D-modules, all capable of communicating with each other through the interconnect, in a cluster configuration. In some instances, the deduplication  system is implemented as part of the D-blade of such an architecture.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 2"],"b":["102","102","201","202","203","203","203"]},"The processor(s)  is\/are the central processing unit (CPU) of the storage controller  and, thus, control the overall operation of the storage controller . In certain embodiments, the processor(s)  accomplish this by executing software or firmware stored in memory . The processor(s)  may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific integrated circuits (ASICs), programmable logic devices (PLDs), trusted platform modules (TPMs), or the like, or a combination of such devices.","The memory  is or includes the main memory of the storage controller . The memory  represents any form of random access memory (RAM), read-only memory (ROM), flash memory, or the like, or a combination of such devices. In use, the memory  may contain, among other things, code  embodying the storage operating system  and\/or the deduplication system .","Also connected to the processor(s)  through the interconnect  are a network adapter  and a storage adapter . The network adapter  provides the storage controller  with the ability to communicate with remote devices, such as clients , over the interconnect  and may be, for example, an Ethernet adapter or Fibre Channel adapter. The storage adapter  allows the storage controller  to access the storage subsystem  and may be, for example, a Fibre Channel adapter or SCSI adapter.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3","b":["107","107","310","310","314","310","312","103","310","318","310","340"],"i":"a "},"In addition, the storage operating system  includes a set of layers organized to form a backend server  that provides data paths for accessing information stored on disks. The backend server  in combination with underlying processing hardware also forms D-module . To that end, the backend server  includes a storage manager module  that manages any number of volumes, a RAID system module  and a storage driver system module .","The storage manager  primarily manages a file system (or multiple file systems) and serves client-initiated read and write requests. In at least one embodiment the storage manager  implements the volumes\/regions\/extents\/slabs based storage techniques introduced here. The RAID system module  manages the storage and retrieval of information to and from the volumes\/disks in accordance with a RAID redundancy protocol, such as RAID-4, RAID-5, RAID-DP or declustered RAID (discussed below), while the disk driver system  implements a disk access protocol such as Serial ATA (SATA), SCSI or FC protocol (FCP).","The backend server  also includes a CF interface module to implement intra-cluster communication  with N-modules and\/or other D-modules. The CF interface modules and can cooperate to provide a single file system image across all D-modules  in the cluster. Thus, any network port of an N-module  that receives a client request can access any data container within the single file system image located on any D-module  of the cluster.","The CF interface modules  implement the CF protocol to communicate file system commands among the modules of clusters in the storage environment. Such communication can be effected by a D-module exposing a CF application programming interface (API) to which an N-module (or another D-module) issues calls. To that end, a CF interface module  can be organized as a CF encoder\/decoder. The CF encoder of, e.g., CF interface on N-module  can encapsulate a CF message as (i) a local procedure call (LPC) when communicating a file system command to a D-module  residing on the same node or (ii) a remote procedure call (RPC) when communicating the command to a D-module residing on a remote node of the cluster. In either case, the CF decoder of CF interface on D-module  de-encapsulates the CF message and processes the file system command.","In operation of a node, a request from a client can be forwarded as a packet over the network  and onto the node, where it is received at the network adapter  (). A network driver of layer  processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to forwarding to the storage manager . At that point, the storage manager  interprets the request and generates operations to load (retrieve) the requested data from the RAID system . The storage manager  determines in which extent and in which region the data resides. The region receives a request for that (portion of) extent and in turn determines the slab(s) containing the requested data. The request is then handed to the RAID system module  for further processing and the determination of which storage device(s) hold the data, before issuing requests to the appropriate storage device driver(s). The storage device driver(s) access(es) the data from the specified device(s) and loads the requested data block(s) in memory for processing by the node. Upon completion of the request, the node (and operating system) returns a reply to the client.","The data request\/response \u201cpath\u201d through the storage operating system  as described above can be implemented in general-purpose programmable hardware executing the storage operating system  as software or firmware. Alternatively, it can be implemented entirely or partially in specially designed hardware. That is, in an alternate embodiment of the invention, some or all of the storage operating system  is implemented as logic circuitry embodied within, for example, one or more field programmable gate arrays (FPGAs), application specific integrated circuits (ASICs), programmable logic devices (PLDs), or some combination thereof.","The N-module  and D-module  each can be implemented as processing hardware configured by separately-scheduled processes of storage operating system ; however, in an alternate embodiment, the modules may be implemented as processing hardware configured by code within a single operating system process. Communication between an N-module  and a D-module  is thus illustratively effected through the use of message passing between the modules although, in the case of remote communication between an N-module and D-module of different nodes. A known message-passing mechanism provided by the storage operating system to transfer information between modules (processes) is the Inter Process Communication (IPC) mechanism. The protocol used with the IPC mechanism is illustratively a generic file and\/or block-based \u201cagnostic\u201d CF protocol that comprises a collection of methods\/functions constituting a CF API.","III. Internal Functionality and Architecture","It is useful now to consider how data can be structured and organized by the storage system . Reference is now made to  in this regard. In at least one embodiment, data is stored in the form of volumes, where each volume contains one or more directories, subdirectories and\/or files. The term \u201caggregate\u201d is used to refer to a pool of storage, which combines one or more physical mass storage devices (e.g., disks) or parts thereof into a single logical storage object. An aggregate contains or provides storage for one or more other logical data sets at a higher level of abstraction, such as volumes. A \u201cvolume\u201d is a set of stored data associated with a collection of mass storage devices, such as disks, which obtains its storage from (i.e., is contained within) an aggregate, and which is managed as an independent administrative unit, such as a complete file system. Each volume can contain data in the form of one or more directories, subdirectories and files.","In certain embodiments, a logical data object such as a file (or other form of logical data container, such as a logical unit or \u201cLUN\u201d) is represented in a storage system  in the form of a hierarchical structure called a \u201cbuffer tree\u201d. A buffer tree is a hierarchical structure which is used to store file data as well as metadata about a logical data object (simply, \u201cdata object\u201d) such as a file, including pointers for use in locating the data blocks for the file. A buffer tree includes one or more levels of indirect blocks (called \u201cL1 blocks\u201d, \u201cL2 blocks\u201d, etc.), each of which contains one or more pointers to lower-level indirect blocks and\/or to the direct blocks (called \u201cL0 blocks\u201d) of the file. All of the data in the file is stored only at the lowest level (L0) blocks.","The root of a buffer tree is the \u201cinode\u201d of the file. An inode is a metadata container that is used to store metadata about the file, such as ownership, access permissions, file size, file type, and pointers to the highest level of indirect blocks for the file. Each file has its own inode. The inode is stored in a separate inode file, which may itself be structured as a buffer tree.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4A","b":["4109","4305","4111","4311","4111","4313","4111","4313"]},"For each volume managed by the storage controller , the Modes of the files and directories in that volume are stored in a separate Mode file, such as Mode file  in  which stores Mode . A separate Mode file is maintained for each volume. The location of the Mode file for each volume is stored in a Volume Information (\u201cVolumeInfo\u201d) block  associated with that volume, such as VolumeInfo block  in . The VolumeInfo block  is a metadata container that contains metadata that applies to the volume as a whole. Examples of such metadata include, for example, the volume's name, type, size, any space guarantees to apply to the volume, and a pointer to the location of the Mode file of the volume.","IV. Duplicate Data Identification and Deduplication","Now consider the process of deduplication.  show an example of the buffer trees of two files, where  shows the two buffer trees before deduplication and  shows the two buffer trees after deduplication. The root blocks of the two files are Inode   and Inode  , respectively. The numerals in  are the values of the pointers to the various blocks and, in effect, therefore, are the identifiers of the data blocks. Inode   has indirect blocks  and , and Inode   has indirect blocks  and . The fill patterns of the direct (L0) blocks , , , , , and  in  indicate the data content of those blocks, such that blocks shown with identical fill patterns are identical. It can be seen from , therefore, that data blocks , , and  are identical.","The result of deduplication is that these three data blocks are, in effect, coalesced into a single data block, identified by pointer , which is now shared by the indirect blocks  and  that previously pointed to data block  and data block . Further, it can be seen that data block  is now shared by both files. In a more complicated example, data blocks can be coalesced so as to be shared between volumes or other types of logical containers. Note that this coalescing operation involves modifying the indirect blocks  and  that pointed to data blocks  and , and so forth, up to the root node. In a write out-of-place file system, that involves writing those modified blocks to new locations on disk.","The collection of the coalesced data blocks, along with the references pointing (e.g., the data objects) to the coalesced data blocks are referred to herein as a \u201cdataset.\u201d In some instances, the dataset may be, for example, a particular volume (or other types of logical containers) of the storage system . In other instances, the dataset may include, for example, multiple volumes (or other types of logical containers) of the storage system .","To identify duplicate data blocks, a hash function, such as MD5, SHA-1, SHA-256 or SHA-512, can be applied to all used (unfree) data blocks in the data set to be deduplicated. The output of the hash function is a value for each data block, called a fingerprint, where identical data blocks have the same fingerprint. By comparing the fingerprints during a subsequent deduplication process, duplicate data blocks can be identified and coalesced. Data blocks with identical fingerprints are possible duplicates. Once possible duplicates are identified from their fingerprints, a byte-by-byte comparison of those possible duplicates can be done to determine whether they are in fact duplicates of each other. Because the fingerprint of a block is much smaller than the data block, fingerprints for a very large number of data blocks can be stored without consuming a significant portion of the storage capacity in the system.","While duplicate data blocks referenced by a data object (e.g., a file) is deleted (as a result of a deduplication process), metadata associated with the data object would need to store information about newly referenced data blocks (i.e., new data blocks referenced by the data object as a result of the deduplication process). Consider, for example, . Data object D-B references twelve data blocks , namely data blocks B through B. Data object D-C references twelve data blocks , namely data blocks C through C. As illustrated in , data object D-C references ten data blocks (C through C) that are common to (i.e., duplicate of) data blocks referenced by data object D-B. Data blocks C and C are different from corresponding data blocks B and B (as indicated in  by use of different shading for the non-duplicate data blocks).","Deduplication is now done to remove duplicate data blocks. As will be explained further below, deduplication may be done inline (i.e., when data object D-C is first created and is being attempted to be written by the storage server, thus preventing duplicate data blocks from being stored at all) or post-write (i.e., after the data object D-C has already been stored and the duplicate data blocks already exist in the system and have to be subsequently deleted). In embodiments, as explained above, deduplication is performed by comparing fingerprints of each data block with other data blocks.  illustrates fingerprint layers  and  respectively for data blocks referenced by data objects D-B and D-C. When deduplication is done to remove the duplicate data blocks referenced by data object D-C, for example, data blocks C through C are deleted (or prevented from being stored in an inline deduplication scenario). The logical references of data object D-C to the deleted data blocks (data blocks C through C) are then redirected to corresponding data blocks (data blocks B through B).","One manner in which such redirection can be done is by doing a one-to-one mapping of logical references of the deleted blocks (e.g., from data object D-C) to corresponding data blocks referenced by data object D-B. This redirection may be done directly at the physical data block level (for example, at the L0 level explained in ) by pointing the references of the relevant (deleted) blocks directly to the data blocks referenced by data object D-B. Alternatively, or in addition to making a logical reference directly to the data blocks, redirection may also be done by mapping the logical references of data object D-C (relating to the deleted data blocks) directly to corresponding logical references of data object D-B. For example, a logical reference to deleted data block C (from data object D-C) would simply be mapped to data object D-B's logical reference to data block B. Effectively, logical reference is now made to the physical data block corresponding to data block B via the logical data object D-B, as illustrated by mapping connector  (only one exemplary mapping is shown in  for the purpose of illustration). Such a mapping of logical references (via data objects) may be stored in metadata corresponding to the relevant data objects. For example, data object D-C would store metadata about the mapping of logical references in associated metadata.","In embodiments, the mapping-related metadata (or simply, \u201cmapping-metadata\u201d) may include a one-to-one mapping of each redirected reference (i.e., for every duplicate data block). Such a one-to-one mapping may be unavoidable in situations where there is a smaller number of common or duplicate data blocks. But in situations where the there is a substantial number of common data blocks between two data objects (or even a situation where two identical data objects reference two completely identical sets of data blocks), the one-to-one mapping results in a large amount of mapping-metadata to be stored. Such is the situation in the exemplary deduplication illustrated with reference to . There are only two common data blocks. Here, a mapping of each of the C through C data blocks to corresponding B through B data blocks (a total of 10 mappings) would need to be stored in metadata associated with data object D-C. This increases the overall storage footprint for data object D-C, despite being almost exactly identical to data object D-B.","V. Hierarchical Fingerprint Trees for Data Objects","To alleviate the problem of storing excessive mapping-metadata, the techniques discussed herein present the use of hierarchical trees of fingerprints for storing mapping information for deduplicated data objects. Examples of such hierarchical trees of fingerprints (simply, \u201chierarchical trees\u201d), and an illustration of how the hierarchical trees may be used to reduce the amount of mapping-metadata stored for deduplicated data objects are provided here with reference to .  illustrates two data objects, data object D-B and data object D-C. Similar to the illustration in , the two data objects reference  data blocks each. Data object D-B references a set of twelve data blocks  and data object D-C references a set of twelve data blocks . Again, apart from two data blocks (i.e., data blocks C and C), all data blocks referenced by data object D-C are identical (or duplicate) to corresponding data blocks referenced by data object D-B.","Similar to the illustration in , fingerprints are generated and stored (e.g., as metadata) for each of the data blocks referenced by the two data objects. This first level of fingerprints, where every data block has a separate fingerprint, is referred to as the first layer or \u201cF0\u201d layer of fingerprints. Data object D-B has an F0 layer  with twelve fingerprints and data object D-C has an F0 layer  with twelve fingerprints. Subsequently, a second layer of fingerprints, the \u201cF1\u201d layer is built on top of the F0 layer. The F1 layer has fewer fingerprints than the F0 layer, and is constructed by generating a fingerprint using two or more fingerprints from the F0 layer. Typically, the fingerprints in the F1 layer would each correspond to a constant number (of value 2 or greater) of fingerprints from the F0 layer. A similar mechanism of grouping and construction is applied to both data objects illustrated in . The F1 layer  of data object D-B has four fingerprints, where each fingerprint is a fingerprint of three fingerprints from the F0 layer. In a similar manner, any number of layers can be built over the base layer (i.e., the F0 layer), until a top layer that has just one fingerprint is achieved. In the illustration, a third layer (F2 layer) is constructed over the F1 layer, the F2 layer having 2 fingerprints (each corresponding to two fingerprints from the immediately lower F1 layer). The top F3 layer ( and  respectively for data objects D-B and D-C) has just one fingerprint, that is a fingerprint of all fingerprints from the immediately lower F2 layer ( and  respectively for data objects D-B and D-C). Accordingly, the top layer fingerprint is effectively representative of all fingerprints (and thus all data blocks) corresponding to each data object.","It is understood that any number of groupings of fingerprints and any number of layers may be generated in this manner until a top layer with a single fingerprint is achieved. For example, the F1 layer  for data object D-B may use two fingerprints from the lower layer (instead of the illustrated 3 fingerprints), resulting in a higher granularity in the fingerprints of the F1 layer. Alternatively, the F1 layer could use six fingerprints from the lower layer, resulting in a lesser number (and corresponding lesser granularity) of fingerprints in the F1 layer. The total number of layers would thus increase or decrease, depending on the chosen granularity. The resulting tree of fingerprints, ranging from the top layer to the base layer, with any number of intermediate layers, is the hierarchical fingerprint tree of each data object.","In embodiments, the entire hierarchical tree is stored in metadata in association with each data object. In embodiments, each layer of the hierarchical tree may be collectively stored in a different logical container (e.g., a different volume for each layer) for organizational purposes. Given the copious number of data blocks that typical data objects would refer to, it can be envisioned that the amount of storage space consumed by storing the hierarchical trees for these data objects would be much lesser than storing extensive one-to-one mapping information for each deduplicated data block.","Subsequent to constructing the hierarchical trees, identification and mapping of duplicate blocks may be done at different layers of the hierarchical tree as will be explained here. It is noted that the hierarchical trees may be generated at any time, depending for example, on storage policies imposed by an administrator. In embodiments, the hierarchical trees may be constructed as soon as data objects are created. In embodiments, the hierarchical trees may be constructed at periodic intervals for all objects created or modified within a set period. In embodiments, the hierarchical trees may be constructed when deduplication routines are executed.","As indicated above, instead of comparing the direct base layer fingerprints to detect duplicate data blocks, the entire hierarchical trees of the two data objects are compared. Comparison of the two hierarchical trees commences at the top layer (which typically includes a single fingerprint representative of all data blocks referenced by the data block). If the top layer fingerprints match, then the two data objects are identified as duplicate objects in their entireties. If that is the case, the top-layer fingerprint of the duplicate data object (e.g., data object D-C) is directly mapped to the top-layer fingerprint of the original data object (e.g., data object D-B). As explained above, conventionally, references of each data block in data object D-C would have been mapped to references of corresponding data blocks in data object D-B. Such a one-to-one mapping would have required 12 mappings (one for each data block of data object D-C). Instead, using the hierarchical trees, only one mapping would be required (i.e., the mapping from top-layer fingerprint to top-layer fingerprint) for deduplication purposes. The entire set of data blocks referenced by data object D-C may now be deleted, with the logical references now mapped to data object D-B.","However, the above discussion assumed that the entire set of data blocks referenced by data object D-C was identical to data blocks referenced data object D-B. Now consider the scenario where there is at least one data block that is not common between the two data objects. Such is the scenario in . Here, data blocks C and C are not duplicates of corresponding data blocks B and B. All other data blocks referenced by the two data objects are common (duplicate) and will need to be deduplicated. Here, comparison starts again at the top layer. The top layer  of D-B does not match the top layer  of D-C because the top layers are representative of all data blocks of the data object, and thus will include the two non-identical data blocks. Comparison then next proceeds to the next lower layer. This layer, as illustrated, has two fingerprints each. One of the fingerprints is hierarchically linked to the two non-identical data blocks (in addition to some identical blocks), while the other is hierarchically linked to six identical blocks. Accordingly, there will be one matching fingerprint and one non-matching fingerprint at this layer. Consequently, the matching fingerprint C\u2032\u20331 of layer  is mapped to corresponding fingerprint B\u2032\u2033 of layer . This single mapping, from C\u2032\u20331 to B\u2032\u2033 is indicative or representative of mappings of mapping between data blocks C through C to corresponding data blocks B through B.","Subsequently, the matching process proceeds to the next lower layer only for the fingerprints that did not match at the current level. Accordingly, fingerprints corresponding to C\u2032\u20330 are mapped to fingerprints corresponding to B\u2032\u20330 at the next lower layer (layer  and ). At this level, again, one fingerprint corresponds to non-identical data blocks, while the other corresponds to identical data blocks. A process similar to the process from the previous step is performed, causing the matching fingerprints to be mapped at this layer (i.e., layers  and ) and allowing the matching process to continue to the next lower layer only for the non-identical or non-matching fingerprints at the current layer. If there are non-identical data blocks, it can be envisioned that the process would continue all the way to the base layer (e.g., layers  and ) for at least the hierarchical portion of the tree that corresponds to the non-identical data blocks.","In other words, a comparison is made of fingerprints starting from the top layer and progressing downward to the base layer. Mapping of matching fingerprints is done at the top-most layer where the fingerprints match, and continued matching of fingerprints at a lower layer is done only for non-matching fingerprints at the current layer.","In the illustrated example in , a conventional mapping would have required 10 mappings, one for each duplicate data block in data object D-C. However, by mapping using the hierarchical trees, the number of mappings reduces to just 3 mappings (one at layer  mapping C\u2032\u2033 to B\u2032\u2033, one at layer  mapping C\u2033 to B\u2033, and one at layer  mapping C\u2032 to B\u2032).","Refer now to , which is a flow diagram explaining a process for identifying and mapping duplicate data blocks in a data object. As explained in , each of the following steps required for identification and deduplication of duplicate data blocks may be performed, for example, by the deduplication system  of the storage controller . The process starts at block , where the deduplication system  identifies a first data object that needs to be compared against an existing data object (second data object) in the storage system. At block , the deduplication system  generates a hierarchical tree of fingerprints for both data objects, if one does not already exist for either data object. Subsequently, at block , the deduplication system  performs a hierarchical comparison of the fingerprint trees, starting at the top layer. For each layer, the deduplication system  identifies whether there are any matching fingerprints, as indicated in block . If any fingerprint matches at this layer, processing continues to block , where the matching fingerprints of the first data object are matched to corresponding fingerprints of the second data object. Subsequently, at block , the deduplication system  verifies whether there are any remaining unmatched fingerprints in the current layer. If there are, processing is stepped to the next lower layer only for the unmatched fingerprints, as indicated in blocks  and . If no matching fingerprints are identified at block , the deduplication system  determines whether there are any layers lower than the current layer, as indicated in block . If lower layers are found, processing is shifted to the next lower layer in block  and matching is done again at block  for the lower layer. In this manner, all identical data blocks of the first data object are mapped to corresponding data blocks at the top-most layer of the hierarchical tree at which they match. Either before the mapping operation or subsequent to the mapping operation, the identified duplicate data blocks are deleted from the storage system as appropriate as part of the deduplication process.","V. Object-Level Identification and Mapping of Duplicate Data Objects","The above discussion illustrated scenarios where a first data object is compared to a preexisting second data object and how duplicate data blocks referenced by the second data object are deduplicated. There are several manners by which the second data object may be selected to be compared against the first data object. In embodiments, a top layer fingerprint (i.e., the single fingerprint of the hierarchical tree that is representative of all data blocks referenced by a data object) of the first data object may be compared against every top-layer fingerprint corresponding to the preexisting data objects in the storage system. A top-layer fingerprint may otherwise be referred to as an object-level fingerprint of the data object. Comparison can be done by directly comparing (e.g., by doing a numerical comparison) a value of the first object-level fingerprint to values of each of the preexisting object-level fingerprints in the storage system. However, such a comparison may be computationally expensive considering the enormous number of preexisting data objects in the data system. Accordingly, this description further addresses techniques for reducing the amount of computations necessary for identifying the second data object.","In embodiments, the object-level fingerprints of the preexisting data objects are s in, for example, a numerical order in a database in the storage system. Accordingly, the received or first object-level fingerprint may be compared only against a range of preexisting fingerprints that correspond to a subset of values that are close to the value of the first object-level fingerprint. For example, if the value of a received first object-level fingerprint is 6330, and there are a million preexisting object-level fingerprints, the received object-level fingerprint may be compared against a subgroup (or a bucket) of preexisting object-level fingerprints ranging in values from 5000 to 10000 in the sorted list. Alternatively, or in addition to a sorted list, the storage system may also create buckets of preexisting top-level fingerprints. Each bucket stores or refers to a subset of the preexisting object-level fingerprints, for example, based on a value of the object-level fingerprints.  illustrates such a bucket-based classification of preexisting object-level fingerprints. The preexisting object-level fingerprints are placed in one of four buckets here, based on their values. Here, as illustrated for example in , when a first object-level fingerprint is received, it is compared against one of the buckets based on the value of the object-level fingerprint. For example, as illustrated in , a received object-level fingerprint has a value of 232, and is therefore compared only against the fingerprints in bucket , which range from values 201 to 300.","Object-level comparisons offer further computational benefits. Conventionally, fingerprints corresponding to each data block referenced by a data object would need to be compared against data blocks referenced by other data blocks. Instead, object-level fingerprint comparisons allow a single comparison between two data objects to identify identical data objects on an entity-level. Even if the two data objects are not exactly identical, the object-level comparison further helps identify closely related data objects such that the duplicate identification and mapping processes explained above may be executed. For example, consider the example in , where the received object-level fingerprint  has a value . Even if bucket  does not have a matching fingerprint with the exact \u201c233\u201d value, the storage system identifies the closest fingerprint (e.g., a fingerprint with a \u201c238\u201d value). Given the closeness of the value of the received object-level fingerprint, it can be adjudged that the related data object has a high probability of referencing data blocks that are identical to at least some of the data blocks referenced by the received data object.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 8","b":["111","802","111","111","804","806"]},"Now, at block , the deduplication system compares the value of the input object-level fingerprint against a database of preexisting object-level fingerprints maintained by the storage system. In some embodiments, as explained above, the deduplication system  may identify a subgroup or bucket of preexisting object-level fingerprints based on the value of the input object-level fingerprint prior to starting the matching process. Based on this comparison, at block , the deduplication system  identifies one or more preexisting object-level fingerprints to compare and match the input object-level fingerprint against. If, at block , the deduplication system  identifies a matching object-level fingerprint from the database of preexisting object-level fingerprints, deduplication system  identifies the input data object as completely identical to the identified preexisting data object and correspondingly deduplicates the input data object at block .","If an exact match is not identified, the deduplication system  proceeds to identify, at block , a related object-level fingerprint from the selected bucket of fingerprints. If one or more of such closely related fingerprints exist at block , processing proceeds to block , where a hierarchical comparison of the data objects if performed to identify and map any identical data blocks referenced by the input data object. If such identical data blocks exist, the deduplication system  deduplicates such blocks, as indicated at blocks  and .","Thus, methods and systems for identifying and mapping duplicate data blocks using hierarchical trees of fingerprints have been described. The techniques introduced above can be implemented by using programmable circuitry programmed by software and\/or firmware, or by using special-purpose hardwired circuitry, or by using a combination of such embodiments. Special-purpose hardwired circuitry may be in the form of, for example, one or more application-specific integrated circuits (ASICs), programmable logic devices (PLDs), field-programmable gate arrays (FPGAs), etc.","Software or firmware to implement the techniques introduced here may be stored on a machine-readable medium and may be executed by one or more general-purpose or special-purpose programmable microprocessors. A \u201cmachine-readable medium\u201d, as the term is used herein, includes any mechanism that can store information in a form accessible by a machine (a machine may be, for example, a computer, network device, cellular phone, personal digital assistant (PDA), manufacturing tool, any device with one or more processors, etc.). For example, a machine-accessible medium includes recordable\/non-recordable media (e.g., read-only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; etc.), etc.","Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more embodiments of the present invention are illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3","b":"107"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 4B and 4C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
