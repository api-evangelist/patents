---
title: Continuous query language (CQL) debugger in complex event processing (CEP)
abstract: A method including receiving, at a computer system, debugging configuration information specifying a functional area of a data stream processing server to be debugged, is described. Furthermore, the method includes identifying, by the computer system, an object associated with the functional area that has been instantiated by the data stream processing server, determining, by the computer system, that tracing for the object is enabled to perform the debugging, and instantiating, by the computer system, a tracelet associated with the object. Further, the method includes stepping, by the computer system, through the tracelet associated with the object to debug the object, and displaying, by the computer system, a visual representation of debugging results associated with the object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09329975&OS=09329975&RS=09329975
owner: Oracle International Corporation
number: 09329975
owner_city: Redwood Shores
owner_country: US
publication_date: 20110707
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present application incorporates by reference for all purposes the entire contents of the following related application: U.S. patent application Ser. No. 12\/534,384, entitled LOGGING FRAMEWORK FOR A DATA STREAM PROCESSING SERVER filed on Aug. 3, 2009.","The present disclosure relates in general to data logging, and in particular to the debugging of the logging of data pertaining to the operation of a data stream processing server.","Traditional database management systems (DBMSs) execute queries in a \u201crequest-response\u201d fashion over finite, stored data sets. For example, a traditional DBMS can receive a request to execute a query from a client, execute the query against a stored database, and return a result set to the client.","In recent years, data stream management systems (DSMSs) have been developed that can execute queries in a continuous manner over potentially unbounded, real-time data streams. For example, a typical DSMS can receive one or more data streams, register a query against the data streams, and continuously execute the query as new data appears in the streams. Since this type of query (referred to herein as a \u201ccontinuous query\u201d) is long-running, the DSMS can provide a continuous stream of updated results to a client. Due to the continuous nature of such queries, debugging or diagnosing problems within continuous queries is extremely difficult. With a complex event processing (CEP) server, continuous query language (CQL) has been used in describing the continuous queries.","Currently, diagnosing or debugging of continuous queries can be done by performing various levels of logging, such as input\/output adapter, output bean, operator, store, synopsis, queues, or the processing nodes in the event processing network level. However, this method cannot provide enough simplicity and flexibility for properly debugging the continuous queries. Usually the problem of logging methods include: too much logging data to analyze, not being able to change the state and continue, not being able to trigger conditions to enable logging, etc. Furthermore, some of the debugging cannot be done using just logging, for example, the pattern operator involving complex state.","DSMSs are particularly suited for applications that require real-time or near real-time processing of streaming data, such as financial ticker analysis, physical probe\/sensor monitoring, network traffic management, and the like. Many DSMSs include a server application (referred to herein as a \u201cdata stream processing server\u201d) that is configured to perform the core tasks of receiving data streams and performing various operations (e.g., executing continuous queries) on the streams. It would be desirable to have a framework for logging data pertaining to the operation of such a data stream processing server to facilitate performance tuning, debugging, and other functions. Hence, improvements in the art are needed.","One embodiment of the invention includes a method which includes receiving, at a computer system, debugging configuration information specifying a functional area of a data stream processing server to be debugged. Furthermore, the method includes identifying, by the computer system, an object associated with the functional area that has been instantiated by the data stream processing server, determining, by the computer system, that tracing for the object is enabled to perform the debugging, and instantiating, by the computer system, a tracelet associated with the object. Further, the method includes stepping, by the computer system, through the tracelet associated with the object to debug the object, and displaying, by the computer system, a visual representation of debugging results associated with the object.","In another embodiment, a machine-readable medium is described. A machine-readable medium includes instructions for receiving debugging configuration information specifying a functional area of a data stream processing server to be debugged. Furthermore, the machine-readable medium includes instructions for identifying an object associated with the functional area that has been instantiated by the data stream processing server, determining that tracing for the object is enabled to perform the debugging, and instantiating a tracelet associated with the object. Further, the machine-readable medium includes instructions for stepping through the tracelet associated with the object to debug the object, and displaying a visual representation of debugging results associated with the object.","In a further embodiment, a system is described. The system includes a processing component configured to receive debugging configuration information specifying a functional area of a data stream processing server to be debugged, identify an object associated with the functional area that has been instantiated by the data stream processing server, determine that tracing for the object is enabled to perform the debugging, instantiate a tracelet associated with the object, step through the tracelet associated with the object to debug the object, and display a visual representation of debugging results associated with the object.","In the following description, for the purposes of explanation, numerous details are set forth in order to provide an understanding of various embodiments of the present invention. It will be apparent, however, to one skilled in the art that certain embodiments can be practiced without some of these details.","Aspects of the present invention include a CQL debugger which introduces the following features: 1) step over operators in the query plan, 2) step into data structures of operations (e.g., enqueueing\/dequeueing, insert\/delete to store, synopsis, index), 3) setting breakpoints on operators in the query plan, 4) setting breakpoints on data structure, 5) setting conditional breakpoints on timestamp or attributes of a tuple, 6) inspect and watch data structures of operators including store, synopsis, queue, index, stat, etc.","Embodiments of the present invention include the following aspects: tracelet in a CQL processor engine, trace\/debug implementation in a diag module, a communication channel providing communication from a debugger application to client applications supporting debug sessions including visualizer, eclipse tooling, a command line interface, etc. In one embodiment, a tracelet may be a small code segment in the trace target which is used in tracing\/dumping and as a breakpoint. For trace targets including operators, data structures, etc, a tracelet may be placed such that the trace\/debug module can intercept accordingly. For example, LogLevelManager.trace (LogArea.OPERATOR, LogEvent.OPERATOR_RUN_BEGIN, this, getOptName( )); may be used. This embodiment may use a static function in implementing the tracelet, but it can also be dynamically injected on class loading using byte code manipulation so that the burden to the programmers\/developers to maintain the tracelets can be removed.","In a further embodiment, when the trace\/debug module receives \u2018trace\u2019 invocation from tracelets, it checks if tracing or breakpoint is set for the target. The checking is done using a multi-dimensional array in order to minimize performance degradation. If tracing is set, the proper level of tracing is processed and if a breakpoint is set, it waits for a user to continue through a visual debugger console interface.","The following shows a high level description of a trace\/debug module's task upon receiving tracelet's invocation:",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Levels levels = loglevelManager.getLevels(area,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"target.getTargetId( ), event);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002if (levels != null) {"]},{"entry":[{},"\u2003\u2002loglevelManager.traceLevels(area, event, target, levels, args);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2002Breakpoint bp = loglevelManager.getBreakpoint(area,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"target.getTargetId( ), event);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003if (bp != null) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bp.wait( ); \/\/ wait for next, continue"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Trace targets may implement an IDump interface, which can provide tailored state information to debug clients. This may be particularly important for operators pertaining to complex states, such as a pattern operator. In one embodiment, the pattern operator may implement tailored state visualization logic in dumping the state so that the customers can easily understand the state. Using combinations of trace, dump, and breakpoint, these features described above may be implemented. Due to the minimization of performance impact in checking tracing\/breakpoint setup, the target application may not need to be started in special mode, such as debug mode. Instead, customers can invoke the debugger any time even including within the production platform.","The present invention at least allows for the following competitive significances: 1) debuggers are provided but the user needs to run the application in debug mode, whereas, the present invention does not need to run the application in debug mode. 2) Various debuggers only provide information on tuples in the port level, whereas, the present invention can visualize the internal state to solve more complex problems, such as the current state of pattern detection. 3) Certain debuggers only provide stepping through at the operator level. The present invention can step into more fine-grained levels including data structure information and provides more detailed state information for debugging. 4) Other debugger implementations only provide tuple level information. The present invention can provide more tailored state information that provides further insight to the problems.","Further embodiments of the present invention provide techniques for logging data pertaining to the operation of a data stream processing server. In one set of embodiments, logging configuration information can be received specifying a functional area of a data stream processing server to be logged. Based on the logging configuration information, logging can be dynamically enabled for objects associated with the functional area that are instantiated by the data stream processing server, and logging can be dynamically disabled for objects associated with the functional area that are discarded (or no longer used) by the data stream processing server. By dynamically enabling and disabling logging for specific objects in this manner, data regarding the operation of the data stream processing server can be logged without significantly affecting the server's runtime performance. In another set of embodiments, a tool can be provided for visualizing the data logged by the data stream processing server.","According to one embodiment of the present invention, a method for facilitating logging in a data stream processing server is provided. The method comprises receiving, at a computer system, logging configuration information specifying a functional area of a data stream processing server to be logged, and identifying, by the computer system, an object associated with the functional area that has been instantiated by the data stream processing server. The method further comprises enabling, by the computer system, logging for the object, and determining, by the computer system, if the object is no longer used by the data stream processing server. If the object is no longer used, logging is disabled by the computer system for the object.","In one embodiment, enabling logging for the object comprises storing the logging configuration information for the object and generating one or more log records for the object based on the logging configuration information stored for the object.","In one embodiment, disabling logging for the object comprises deleting the logging configuration information stored for the object.","In one embodiment, the logging configuration information includes a first parameter identifying an event upon which to generate a log record and a second parameter identifying a level of detail for the log record. In this embodiment, generating one or more log records for the object comprises, upon occurrence of a predefined event related to the object, retrieving the logging configuration information stored for the object and determining if the predefined event corresponds to the event identified by the first parameter. If the predefined event corresponds to the event identified by the first parameter, a log record is generated for the object, where the generated log record has the level of detail identified by the second parameter.","In one embodiment, the functional area to be logged corresponds to a type of query plan object. In this embodiment, identifying an object associated with the functional area comprises traversing a query plan generated for a continuous query, where the query plan includes a plurality of query plan objects, and identifying a query plan object in the plurality of query plan objects having the type. Further, determining if the object is no longer used comprises determining if the continuous query is dropped.","In one embodiment, the plurality of query plan objects includes an operator object and one or more data structure objects associated with the operator object. In a further embodiment, if logging is enabled for the operator object, logging is automatically enabled for the one or more data structure objects associated with the operator object.","In one embodiment, the method above further comprises identifying another object associated with the functional area, where the another object was instantiated by the data stream processing server subsequently to receiving the logging configuration information, and enabling logging for the another object.","In one embodiment, the logging configuration information is received from a user and is expressed as a Continuous Query Language (CQL) statement. In another embodiment, the logging configuration information is received via an invocation of a Java Management Extensions (JMX) Applications Programming Interface (API).","According to another embodiment of the present invention, a machine-readable storage medium having stored thereon program code executable by a computer system is provided. The program code includes code that causes the computer system to receive logging configuration information specifying a functional area of a data stream processing server to be logged, and code that causes the computer system to identify an object associated with the functional area that has been instantiated by the data stream processing server. The program code further comprises code that causes the computer system to enable logging for the object, code that causes the computer system to determine if the object is no longer used by the data stream processing server, and code that causes the computer system to, if the object is no longer used, disable logging for the object.","According to another embodiment of the present invention, a logging system is provided. The logging system comprises a processing component configured to receive logging configuration information specifying a functional area of a data stream processing server to be logged and to identify an object associated with the functional area that has been instantiated by the data stream processing server. The processing component is further configured to enable logging for the object and to determine if the object is no longer used by the data stream processing server. If the object is no longer used, the processing component is configured to disable logging for the object.","According to another embodiment of the present invention, a method for visualizing log records is provided. The method comprises receiving, at a computer system, a file comprising log records generated by a data stream processing server, where the log records include information pertaining to a query plan and a sequence of one or more events executed by the data stream processing server in accordance with the query plan. The method further comprises generating, by the computer system, a graphical representation of the query plan based on the log records, and displaying, by the computer system, the graphical representation.","In one embodiment, the graphical representation of the query plan comprises one or more nodes, where each node represents a query plan object in the query plan. Examples of query plan objects include operators, queues, stores, indexes, synopses, etc.","In one embodiment, the method above further comprises, in response to a user input, displaying data information for a node.","In one embodiment, the method above further comprises, in response to a first user input, visually portraying execution of the one or more events in sequence by animating the graphical representation, where visually portraying execution of the one or more events in sequence comprises visually portraying execution of the one or more events in real-time based on timestamps associated with the one or more events. In a further embodiment, the method above further comprises, in response to a second user input, pausing the animation.","In one embodiment, the method above further comprises, if the log records indicate that an error occurred during execution of an event in the one or more events, displaying a representation of the error in the graphical representation.","In one embodiment, the method above further comprises providing the one or more events as one or more data streams to another data stream processing server and receiving a continuous query to be executed against the one or more data streams. The continuous query can then be executed by the another data stream processing server while the graphical representation is being animated.","In one embodiment, the method above further comprises, if a result for the continuous query is received from the another data stream processing server, pausing the animation. In another embodiment, the method above further comprises, if a result for the continuous query is received from the another data stream processing server, displaying an alert.","According to another embodiment of the present invention, a machine-readable storage medium having stored thereon program code executable by a computer system is provided. The program code includes code that causes the computer system to receive a file comprising log records generated by a data stream processing server, where the log records include information pertaining to a query plan and a sequence of events executed by the data stream processing server in accordance with the query plan. The program code further comprises code that causes the computer system to generate a graphical representation of the query plan based on the log records and code that causes the computer system to display the graphical representation.","According to another embodiment of the present invention, a log visualization system is provided. The log visualization system comprises a storage component configured to store a file comprising log records generated by a data stream processing server, where the log records include information pertaining to a query plan and a sequence of events executed by the data stream processing server in accordance with the query plan. The log visualization system further comprises a processing component in communication with the storage component, where the processing component is configured to generate a graphical representation of the query plan based on the log records and display the graphical representation.","A further understanding of the nature and advantages of the embodiments disclosed herein can be realized by reference to the remaining portions of the specification and the attached drawings.","Embodiments of the present invention provide techniques for logging data pertaining to the operation of a data stream processing server. In one set of embodiments, logging configuration information can be received specifying a functional area of a data stream processing server to be logged. Based on the logging configuration information, logging can be dynamically enabled for objects associated with the functional area that are instantiated by the data stream processing server, and logging can be dynamically disabled for objects associated with the functional area that are discarded (or no longer used) by the data stream processing server. By dynamically enabling and disabling logging for specific objects in this manner, data regarding the operation of the data stream processing server can be logged without significantly affecting the server's runtime performance.","In certain embodiments, the functional area specified in the logging configuration information can correspond to a type of query plan object, where a query plan object is a component of a query plan, and where a query plan is a data structure used by the data stream processing server to execute a continuous query. Examples of query plan object types include \u201coperator,\u201d \u201cqueue,\u201d \u201cstore,\u201d \u201csynopsis,\u201d \u201cindex,\u201d and the like. In these embodiments, logging can be dynamically enabled or disabled for query plan objects having the specified type based on query plan changes in the data stream processing server. For instance, in one set of embodiments, logging can be dynamically enabled for query plan objects having the specified type that are instantiated upon generation of a new query plan. In another set of embodiments, logging can be dynamically disabled for query plan objects having the specified type that are discarded upon the deletion of an existing query plan.","In one set of embodiments, a tool can be provided for visualizing log records that are generated for query plan objects according to the techniques noted above. For example, the tool can receive log records containing data regarding one or more events executed by the query plan objects in accordance with a query plan. The tool can then generate a visual representation of the query plan and animate, in real-time, the visual representation to illustrate the execution of the events. Such a tool can be useful for administrators, developers, and other users in understanding and analyzing the log records.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 1A","b":["100","100","100","100","102","104","106","108","110"]},"In one set of embodiments, server  can log data pertaining to its runtime operation. For example, in particular embodiments, server  can log data pertaining to query plan objects that are used by the server to execute continuous queries. This logged information can then be used by, e.g., an administrator or other user of server  to debug errors or analyze performance problems that may haven arisen during query execution. This logging capability is described in greater detail below.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 1B","b":["100","102","102","112","114","116","118"]},"In various embodiments, query manager  can receive continuous queries from, e.g., a client application or a user and generate query plans for executing the queries. As described above, a continuous query is a query that can be run in a continuous or persistent fashion against one or more data streams. A query plan is a data structure comprising one or more objects (referred to herein as \u201cquery plan objects\u201d) that can be used by server  to execute a continuous query. In some embodiments, query manager  can generate a separate query plan for each received query. In other embodiments, query manager  can maintain a single, global query plan for multiple queries.","By way of example,  is a graphical representation of a query plan  that can be generated by query manager  for a continuous query. As shown, query plan  can include a plurality of query plan objects - arranged in a hierarchical fashion. In certain embodiments, each query plan object can correspond to a software object (e.g., a JAVA a C++ object) that can be invoked to perform one or more actions. When input data (e.g., input data streams ,  of ) is passed through plan  and query plan objects - are invoked in the specified order, the continuous query associated with plan  can be executed.","In one set of embodiments, each query plan object can have a particular type that indicates its functional role within the plan. For example, query plan objects - are \u201coperator\u201d objects that are configured to carry out specific operations, or steps, in the overall execution of the continuous query. Query plan  can also include various other types of query plan objects such as \u201cstore\u201d objects -, \u201cqueue\u201d objects -, and \u201csynopsis\u201d objects -. Generally speaking, store, queue, and synopsis objects are data structure objects that can be associated with one or more operator objects and can be used to maintain an operator object's state and\/or manage data flow into (or out of) an operator object. For instance, in the embodiment of , operator object  can be associated with a store object , queue objects -, and synopsis objects -.","Once a query plan (such as plan ) has been generated for a continuous query, query manager  (or another component of server ) can execute the continuous query using the query plan. For example, with respect to query plan , query manager  can invoke the various query plan objects - according to the hierarchical ordering of plan  and thereby execute the associated query.","Returning to , log manager  can facilitate the logging of various functional areas of server . In one set of embodiments, log manager  can receive logging configuration information specifying a particular functional area of server . This information can be received, for example, from a user via a user interface or from a client application via an invocation of an Application Programming Interface (API). Upon receiving the logging configuration information, log manager  can store (in, e.g., log configuration database ) a copy of the logging configuration information for one or more software objects associated with the specified area that have been instantiated by server . This stored information can then be accessed by log manager  at runtime of server  to generate log records for each object.","For example, at runtime of server , the various software objects used by the server (e.g., log targets ) can invoke log manager  upon the occurrence of certain predefined events. In response, log manager  can determine, based on the logging configuration information stored in log configuration database , whether logging has been enabled for those log targets. If log manager  determines that logging has been enabled for a particular log target , log manager  can instruct the log target to generate a log record and store the record in log record database .","In some embodiments, the functional area specified in the logging configuration information received by log manager  can correspond to a type of query plan object, such as \u201coperator,\u201d \u201cqueue\u201d \u201cstore,\u201d \u201csynopsis,\u201d and so on. In these embodiments, log manager  can interoperate with plan monitor  to identify query plan objects that have been instantiated by query manager  (via, e.g., the generation of query plans). Specifically, log manager  can send the logging configuration information to plan monitor , which is configured to traverse the query plans generated by query manager  and identify query plan objects having the specified type. Plan monitor  can then return IDs for the identified query plan objects to log manager , which can store the IDs with the logging configuration information in log configuration database . In this manner, logging can be enabled for these specific query plan objects.","At runtime of server , the query plan objects used by the server (e.g., for executing continuous queries) can invoke log manager  upon the occurrence of certain predefined events. In response, log manager  can determine, based on the logging configuration information stored in log configuration database , whether logging has been enabled for those query plan objects. If logging has been enabled for a particular query plan object, logging manager  can instruct the query plan object to generate a log record and store the record in log record database .","In one set of embodiments, plan monitor  can, upon receipt of the logging configuration information from log manager , keep track of \u201cchange management information\u201d in change management database . As used herein, \u201cchange management information\u201d refers to changes that should be made to the information stored in log configuration database  in the event that new query plan objects are instantiated (e.g., via the generation of new query plans) or existing query plan objects are discarded or rendered obsolete (e.g., via the deletion of existing query plans) by query manager .","For example, assume the logging configuration information specifies that logging should be enabled for all operator-type query plan objects, and assume that there are currently two operator objects (having IDs O and O) instantiated in the server. In this case, the change management information can specify that the logging configuration information should be added to log configuration database  for any new operator objects subsequently instantiated by query manager . Further, the change management information can specify that the logging configuration information stored in log configuration database  for operator objects O and O should be deleted if either of these objects are discarded or rendered obsolete by query manager .","Once the change management information described above has been stored in change management database , plan monitor  can be automatically updated of any query plan changes by query manager . For example, query manager  can notify plan monitor  when a new query plan is generated, or when an existing query plan is discarded. Plan monitor  can then determine, based on the change management information stored in change management database , if any changes need to be applied to log configuration database . If changes need to be made (e.g., logging configuration information needs to be added or deleted for a specific query plan object), plan monitor  can instruct log manager  to apply those changes. In this manner, logging can be dynamically enabled and disabled for query plan objects in response to query plan changes.","It should be appreciated that  are illustrative and not intended to limit embodiments of the present invention. For example, DSMS  and server  may each have other capabilities or include other components that are not specifically described. One of ordinary skill in the art will recognize many variations, modifications, and alternatives.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 3","FIG. 1B"],"b":["300","300","114","116","112","102","300","300"]},"At blocks  and , query manager  can receive a continuous query and generate a query plan for the query. As described above, a query plan is a data structure comprising one or more objects (query plan objects) that can be used (by, e.g., server ) to execute a continuous query. In certain embodiments, the processing of steps  and  can be repeated continuously as new queries are received.","Concurrently with blocks  and , log manager  can receive logging configuration information specifying a type of query plan object to be logged (block ). In one set of embodiments, the logging configuration information can be received from a user of server  via, e.g., a user interface. In these embodiments, the logging configuration information can be expressed as a Continuous Query Language (CQL) statement. In other embodiments, the logging configuration information can be received from a client application or some other automated process via, e.g., an invocation of an Application Programming Interface (API) such as a Java Management Extensions (JMX) API.","In one set of embodiments, the logging configuration information received at block  can include at least three parameters: <AREA>, <EVENT>, and <LEVEL>, The <AREA> parameter can specify an identifier (ID) of a particular functional area of server  to be logged. For example, in the context of query plan objects, the <AREA> parameter can specify an ID of a particular query plan object type to be logged, such as \u201coperator,\u201d \u201cstore,\u201d \u201cqueue,\u201d \u201csynopsis,\u201d and the like. In some embodiments, the <AREA> parameter can also specify an ID of a \u201csubtype,\u201d where the subtype represents another level of granularity within the specified area. For example, if the specified area is \u201coperator,\u201d the <AREA> parameter can also include a subtype of \u201cbinjoin,\u201d \u201ctimewindow,\u201d or other subtypes of operator objects.","The <EVENT> parameter can specify an ID of an event, or operation, upon which logging should occur. In other words, the <EVENT> parameter can indicate when a log record should be generated for the specified area. In one set of embodiments, the permissible ID values for the <EVENT> parameter can vary based on the area specified via the <AREA> parameter. For example, if the specified area is \u201coperator\u201d (denoting the \u201coperator\u201d query plan object type), the permissible ID values for <EVENT> may be limited to those events that are typically carried out by operator objects, such as \u201cbegin execution\u201d and \u201cend execution.\u201d As another example, if the specified area is \u201cqueue\u201d (denoting the \u201cqueue\u201d query plan object type), the permissible ID values for <EVENT> may be limited to those events that are typically carried out by queue objects, such as \u201cenqueue\u201d and \u201cdequeue.\u201d","The <LEVEL> parameter can specify an ID indicating the desired level of detail, or verbosity, of the generated log record. Like the <EVENT> parameter, the permissible ID values for the <LEVEL> parameter can vary based on the area specified via the <AREA> parameter. Further, the meaning of a particular level ID may be different based on the specified area. For example, a level ID of \u201c1\u201d may denote a certain level of detail for the \u201cqueue\u201d object type and a different level of detail for the \u201coperator\u201d object type.","In some embodiments, if the area specified via the <AREA> corresponds to the operator object type, certain ID values for the <LEVEL> parameter can cause the generated log record to include information about data structure objects (e.g., stores, queues, synopses, etc.) associated with the operator object. In this manner, logging can be enabled for a plurality of related query plan objects via a single configuration command.","The following is a table of ID values for the <AREA>, <EVENT>, and <LEVEL> parameters that can be recognized by log manager  according to an embodiment of the present invention:",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"EVENT ID and","LEVEL ID and"]},{"entry":["AREA ID","DESCRIPTION","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CEP_QUEUE","21 - Queue DDL","1 - Metadata information such as"]},{"entry":[{},"22 - Enqueue","number of readers for a writer"]},{"entry":[{},"23 - Dequeue","queue, the operators involved,"]},{"entry":[{},"24 - Peek","etc. The exact information to be"]},{"entry":[{},"25 - Get","logged depends on the type of the"]},{"entry":[{},{},"queue."]},{"entry":[{},{},"2 - Timestamp, element kind and"]},{"entry":[{},{},"tuple details (only if pinned)."]},{"entry":[{},{},"3 - Timestamp, element kind and"]},{"entry":[{},{},"tuple details (even if unpinned)."]},{"entry":[{},{},"4 - Queue stats"]},{"entry":[{},{},"5 - List of all elements in the"]},{"entry":[{},{},"queue. The exact information to"]},{"entry":[{},{},"be logged depends on the type of"]},{"entry":[{},{},"the queue."]},{"entry":["CEP_STORE","41 - Store DDL","1 - Metadata information like"]},{"entry":[{},"42 - Insert","number of readers\/stubs, the"]},{"entry":[{},"43 - Delete","operators invoked, etc. The exact"]},{"entry":[{},"44 - Get","information to be logged depends"]},{"entry":[{},"45 - Scan Start","on the type of store."]},{"entry":[{},"46 - Scan","4 - Store statistics"]},{"entry":[{},"47 - Scan Stop","5 - List of all tuples\/timestamps."]},{"entry":[{},{},"The exact information to be"]},{"entry":[{},{},"logged depends on the type of"]},{"entry":[{},{},"store."]},{"entry":["CEP_INDEX","61 - Index DDL","1 - Tuple information (only if"]},{"entry":[{},"62 - Insert","pinned)"]},{"entry":[{},"63 - Delete","2 - Tuple information (even if"]},{"entry":[{},"64 - Scan Start","unpinned)"]},{"entry":[{},"65 - Scan","3 - Index statistics"]},{"entry":[{},"66 - Scan Stop","4 - List of all tuples"]},{"entry":["CEP_SYNOPSIS","81 - Synopsis DDL","1 - Metadata information like the"]},{"entry":[{},"82 - Insert","store identifier, stub identifier,"]},{"entry":[{},"83 - Delete","number of scans,"]},{"entry":[{},"84 - Get","predicates\/undexes, etc (for a"]},{"entry":[{},"85 - Scan Start","relational synopsis)."]},{"entry":[{},"86 - Scan","2 - Tuple information (only if"]},{"entry":[{},"87 - Scan Stop","pinned)"]},{"entry":[{},{},"3 - Tuple information (even if"]},{"entry":[{},{},"unpinned)"]},{"entry":[{},{},"4 - Store statistics"]},{"entry":[{},{},"5 - List of all tuples\/timestamps"]},{"entry":[{},{},"6 - Underlying index information"]},{"entry":[{},{},"7 - List of all tuples"]},{"entry":["CEP_OPERATOR","101 - Operator DDL","1 - Operator metadata"]},{"entry":[{},"102 - Beginning of operator","2 - Operator statistics"]},{"entry":[{},"execution","3 - Underlying structure statistics"]},{"entry":[{},"103 - End of operator execution","(e.g., input\/output queues, store,"]},{"entry":[{},"104 - Underlying structures","synopsis)"]},{"entry":[{},"(synopsis, queues, indexes, etc.) - ","4 - Underlying structures - least"]},{"entry":[{},"equivalent of CEP_QUEUE,","detail (equivalent of"]},{"entry":[{},"CEP_INDEX and","CEP_QUEUE, CEP_INDEX, and"]},{"entry":[{},"CEP_SYNOPSIS at insert\/delete","CEP_SYNOPSIS at level that"]},{"entry":[{},"105 - Enqueue\/dequeue","dumps tuples at insert\/delete, only"]},{"entry":[{},"performed during the execution","if pinned)"]},{"entry":[{},"106 - Peeks in the input queues","5 - Underlying structures - more"]},{"entry":[{},"performed during execution","detail (equivalent of level ID 4"]},{"entry":[{},"107 - Inserts\/deletes performed","plus dump stats and scan)"]},{"entry":[{},"on the synopsis","6 - Underlying structures - most"]},{"entry":[{},"108 - Underlying synopsis scan","detail (equivalent of level ID 5"]},{"entry":[{},"109 - Underlying index scan","plus dump the complete list at"]},{"entry":[{},{},"every get in the form of a get,"]},{"entry":[{},{},"etc.)"]},{"entry":[{},{},"7 - Detailed operator dump (this"]},{"entry":[{},{},"may be operator specific. For"]},{"entry":[{},{},"example, binjoin may decide to"]},{"entry":[{},{},"dump more information than"]},{"entry":[{},{},"streamsource)."]},{"entry":[{},{},"8 - Extremely detailed operator"]},{"entry":[{},{},"dump; effectively a code"]},{"entry":[{},{},"walkthrough."]},{"entry":["CEP_QUERY_OPERATORS","1 - Log all the operators for a","The level will produce the same"]},{"entry":[{},"specific query","amount of logging as the logging"]},{"entry":[{},{},"for all the operators under"]},{"entry":[{},{},"consideration. All of the"]},{"entry":[{},{},"operators of the query can be"]},{"entry":[{},{},"logged. If IDs are not specified,"]},{"entry":[{},{},"all queries can be used."]},{"entry":["CEP_SPILL","121 - Garbage collection in","1 - Eviction information"]},{"entry":[{},"spilling","2 - Spilling statistics"]},{"entry":[{},"122 - Eviction Begin","3 - Spilling reference map"]},{"entry":[{},"123 - Eviction End"]},{"entry":["CEP_STORAGE","141 - DB Open","1 - DB information"]},{"entry":[{},"142 - DB Close","2 - DB Statistics"]},{"entry":[{},"143 - DB Read"]},{"entry":[{},"144 - DB Write"]},{"entry":[{},"145 - DB Delete"]},{"entry":[{},"146 - DB Transaction Begin"]},{"entry":[{},"147 - DB Transaction End"]},{"entry":[{},"148 - DB Query Begin"]},{"entry":[{},"149 - DB Query End"]},{"entry":["CEP_QUERY","161 - Creation of query","1 - Query creation text and"]},{"entry":[{},"162 - Modification of query","corresponding activities (e.g.,"]},{"entry":[{},"163 - Deletion of query","create, update, drop)"]},{"entry":[{},"164 - Start of query","2 - Internal query metadata like"]},{"entry":[{},"165 - End of query","Query ID, external destinations,"]},{"entry":[{},{},"destination views, reference"]},{"entry":[{},{},"functions, and reference views"]},{"entry":[{},{},"along with query text."]},{"entry":[{},{},"3 - Reference count, whether"]},{"entry":[{},{},"read or write locked, stack trace"]},{"entry":["CEP_TABLE","181 - Table creation","1 - Table creation text and"]},{"entry":[{},"182 - Table update","corresponding activities (creation,"]},{"entry":[{},"183 - Table deletion","update, deletion)"]},{"entry":[{},{},"2 - Table ID, referenced queries,"]},{"entry":[{},{},"whether table is silent, push"]},{"entry":[{},{},"source (or not), table creation text"]},{"entry":[{},{},"3 - Reference count, whether"]},{"entry":[{},{},"read or write locked"]},{"entry":["CEP_WINDOW","201 - Window creation","1 - Window creation\/deletion"]},{"entry":[{},"202 - Window deletion","activity and context"]},{"entry":[{},{},"2 - Implementation class name,"]},{"entry":[{},{},"destination queries along with"]},{"entry":[{},{},"window name"]},{"entry":[{},{},"3 - Reference count, whether"]},{"entry":[{},{},"read or write locked"]},{"entry":["CEP_USERFUNCTION","221 - User function creation","1 - User function creation text,"]},{"entry":[{},"222 - User function deletion","implementation class name"]},{"entry":[{},{},"2 - Function ID, destination"]},{"entry":[{},{},"queries, creation text"]},{"entry":[{},{},"3 - Reference count, whether"]},{"entry":[{},{},"read or write locked"]},{"entry":["CEP_VIEW","241 - Creation of view","1 - Associated query information"]},{"entry":[{},"242 - Deletion of view","and view creation or deletion"]},{"entry":[{},{},"2 - View ID, query ID,"]},{"entry":[{},{},"destination queries, query"]},{"entry":[{},{},"information"]},{"entry":[{},{},"3 - Reference count, whether"]},{"entry":[{},{},"read or write locked"]},{"entry":["CEP_SYSTEM","261 - System state creation","1 - System state,"]},{"entry":[{},"262 - System state deletion","creation\/updation\/deletion"]},{"entry":[{},"263 - System state updation","2 - Reference count, whether"]},{"entry":[{},{},"read or write locked"]},{"entry":["CEP_SYSTEM_STATE","N\/A","1 - List of queries"]},{"entry":[{},{},"2 - List of tables"]},{"entry":[{},{},"3 - List of windows"]},{"entry":[{},{},"4 - List of user functions"]},{"entry":[{},{},"5 - List of views"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Once the logging configuration information is received per block , log manager  can determine, based on the <AREA> parameter in the received information, the functional area to be logged. For the purposes of process , it is assumed that the functional area corresponds to a type of query plan object, such as operator, queue, or the like. Log manager  can then send the logging configuration information to plan monitor  (block ).","At block , plan monitor  can receive the logging configuration information and determine the query plan object type specified therein. Plan monitor  can then traverse the query plans generated by query manager  (at block ) and identify query plan objects in the query plans that have the specified type (blocks , ). For example, if the logging configuration information specifies the \u201coperator\u201d object type, plan monitor  can identify all of the operator objects that have been instantiated by query manager  and are included in one or more query plans.","Once plan monitor  has identified query plan objects per block , plan monitor  can return a list of IDs for the identified query plan objects to log manager  (blocks , ). Log manager  can then store the object IDs along with the logging configuration information received at block  in a data store, such as log configuration database  of  (block ). At runtime of server , this stored information can be used to generate log records for the identified query plan objects. This runtime process is discussed in greater detail with respect to  below.","In one set of embodiments, plan monitor  can also store change management information in change management database  at block . As described above, this change management information can represent changes that should be made to the logging configuration information stored in log configuration database  (per block ) in the event that new query plan objects are instantiated (e.g., via the generation of new query plans) or existing query plan objects are discarded or rendered obsolete (e.g., via the deletion of existing query plans) by query manager . Accordingly, this change management information can be used to dynamically enable or disable logging for query plan objects as query plan changes occur.","For instance, in one set of embodiments, plan monitor  can be automatically notified by query manager  when, e.g., a new query plan is generated, or when an existing query plan is discarded. Plan monitor  can then determine, based on the information stored in change management database , if any changes need to be made to the logging configuration information stored in log configuration database  to enable or disable logging for a particular query plan object. If a change needs to be made (e.g., logging configuration information needs to be added or deleted for a specific object), plan monitor  can instruct log manager  to apply the change. This process is described in greater detail with respect to  below.","It will be appreciated that process  is illustrative and that variations and modifications are possible. Steps described as sequential may be executed in parallel, order of steps may be varied, and steps may be modified, combined, added, or omitted. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.","In some embodiments, the logging configuration information stored at block  of process  can be stored in a particular type of data structure, such as a multi-dimensional array. An example of such a multi-dimensional array  is illustrated in . As shown, multi-dimensional array  can include a first array  that is indexed by area ID. Each area ID index can correspond to a functional area that can be logged in server . In one set of embodiments, array  can include indices for various query plan object types such as operator, queue, store, synopsis, and so on.","Each value in array  can be a pointer to a second array  that is indexed by object ID. Each object ID index can correspond to a particular object instance (associated with the selected area) that can be logged by server .","Each value in array  can be a pointer to a third array  that is indexed by event ID. Each event ID index can correspond to a particular event that can be logged for the selected area and object.","Finally, each value in array  can be a pointer to a fourth array  that is indexed by level ID. Each level ID index can correspond to a particular level of detail for generating a log record for the selected area, object, and event. In one set of embodiments, the values in array  can be binary values indicating whether logging is enabled or disabled for that particular combination of [area, object, event, level]. In alternative embodiments, the values in array  can be booleans, strings, or any other type of value that can indicate whether logging is enabled or disabled.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 5","b":["500","102","500","114","102","118","300","118","102","500","500"]},"At block , log target  can invoke log manager  upon occurrence of a predetermined event and provide log manager  with information pertaining to the event and itself. In various embodiments, log target  can be preconfigured with code for invoking log manager  in this manner.","In some embodiments, the \u201cpredetermined event\u201d that triggers invocation of log manager  can be different based on the object type of log target . For example, if log target  is an operator object, log target  can be preconfigured to invoke log manager  upon, e.g., the occurrence of \u201cbegin execution\u201d and \u201cend execution\u201d events. As another example, if log target  is a queue object, log target  can be preconfigured to invoke log manager  upon, e.g., the occurrence of \u201cenqueue\u201d and \u201cdequeue\u201d events.","At block , log manager  can determine, from the information received from log target , the area ID and object ID for log target , as well as the event ID for the event that occurred at block . The area ID, object ID, and event ID can then be compared with the logging configuration information stored in log configuration database  to determine whether logging has been enabled for that particular combination of [area ID, object ID, event ID] (block ). For example, if the logging configuration information is stored in the form of multi-dimensional array  of , this process can comprise accessing array  using the determined area ID, accessing array  using the determined object ID, accessing array  using the determined event ID, and retrieving the appropriate array . In this embodiment, array  can identify all of the levels for which logging is enabled.","If logging is not enabled for any levels corresponding to the [area ID, object ID, event ID] determined at block , process  can end (blocks , ). On the other hand, if logging is enabled for one or more levels, log manager  can send the IDs for those levels to log target  (block ). In response, log target  can generate a log record based on the specified levels and store the log record in log record database  (block ).","It will be appreciated that process  is illustrative and not intended to limit embodiments of the present invention. Steps described as sequential may be executed in parallel, order of steps may be varied, and steps may be modified, combined, added, or omitted. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 6","b":["600","512","500","600","600","600","0","6","0"]},"Although not shown in , in some embodiments log record  can also include a timestamp indicating a time at which the log record was generated or stored. Further, log record  can include details about the query plan associated with this particular queue object. In various embodiments, this logged information can be used to visualize the execution of events in the query plan. This visualization technique is discussed in greater detail with respect to  below.","It will be appreciated that log record  is illustrative and not intended to limit embodiments of the present invention. For example, although log record  is shown as being expressed according to a particular structure and using particular naming conventions, log record  can also be expressed in many different ways. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.","As described above, in certain embodiments logging can be dynamically enabled or disabled for query plan objects based on query plan changes in server .  is a flow diagram illustrating such a process  according to an embodiment of the present invention. In one set of embodiments, process  can be carried out by query manager , plan monitor , and log manager  after configuration process  has been performed. Process  can be implemented in hardware, software, or a combination thereof. As software, process  can be encoded as program code stored on a machine-readable storage medium.","At block , query manager  can detect a change that affects one or more query plans used by server . For example, query manager  can detect when a new query plan has been generated in response to a request to add a new continuous query. Alternatively, query manager  can detect when an existing query plan is discarded or obsolete in response to a request to drop an existing continuous query. Upon detecting a query plan change, query manager  can send information regarding the change to plan monitor . For example, this query plan change information can include IDs of new query plan objects that have been instantiated (if, e.g., a query has been added), or IDs of query plan objects that have been discarded (if, e.g., an existing query has been dropped).","At block , plan monitor  can receive the query plan change information from query manager . Plan monitor  can then determine, based on the change management information stored in change management database , if any changes need to be made to the logging configuration information stored in log configuration database  (block ).","For example, assume the change management information specifies that the logging configuration information stored in log configuration database  for two objects, O and O, should be deleted if either of these objects is discarded or rendered obsolete by query manager . Further, assume that the query plan change information received at block  indicates that objects O and O have, in fact, been discarded. In this case, plan monitor  can create a change list specifying deletion of the logging configuration information for these specific objects. In other situations, plan monitor  can determine that logging configuration information should be added for certain objects to log configuration database , and can create a change list specifying the addition of such information accordingly.","If a change needs to be made (e.g., logging configuration information needs to be added or deleted for a specific query plan object), plan monitor  can send a change list to log manager  (blocks , ). Log manager  can then apply the changes to log configuration database  (block ). Alternatively, plan monitor  can directly apply the changes to log configuration database . By modifying the stored logging configuration information in this manner, logging can be dynamically enabled or disabled for query plan objects as query plan changes occur.","It will be appreciated that process  is illustrative and not intended to limit embodiments of the present invention. Steps described as sequential may be executed in parallel, order of steps may be varied, and steps may be modified, combined, added, or omitted. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.","In some situations, the logging techniques described above can create a voluminous amount of log data pertaining to the operation of server  that can be difficult to interpret and\/or analyze. Accordingly, embodiments of the present invention can provide techniques for visualizing log records created by server . In certain embodiments, these visualization techniques allow an end user to graphically view a query plan that has been executed by server  and see the progression of operations\/events that are performed by query plan objects within the query plan.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 8","FIG. 1B"],"b":["800","800","102","800"]},"At block , a file can be received comprising log records generated by a data stream processing server, where the log records contain information pertaining to a query plan and a sequence of events executed by the server in accordance with the query plan. For example, the file can contain log records generated according to process  of .","At block , a graphical representation of the query plan can be generated based on the log records and can be displayed to an end user. In one set of embodiments, the graphical representation can resemble a tree comprising a plurality of nodes, where each node corresponds to an object (e.g., operator, queue, store, etc.) in the query plan (such as the representation of plan  depicted in ).","At block , the graphical representation of the query plan can be animated, thereby depicting the occurrence of logged events over the course of the query's execution. For example, if the log records received at block  include an enqueue event and a subsequent dequeue event for a particular queue object, the occurrence of these events can be depicted and animated accordingly. In some embodiments, this animation can occur in real-time based on timestamps associated with the events in the log records. Thus, a user can understand and analyze, in a visual manner, the flow of events and data during query execution.","In certain embodiments, the animation described at block  can be initiated, stopped, paused, rewound, and\/or fast-forwarded according to inputs received from a user. Further, if the animation is paused, the user can inspect data related to each query plan object in the query plan. For example, in one embodiment, the user can select a particular query plan object and view information about its state, its associated data structures, etc. at that point in the query execution.","In further embodiments, various alerts and or messages can be displayed to the user during the animation. For example, if the log records contain information about an error (such as the stack trace depicted in log record  of ), an alert can be generated and displayed advising of that error.","It will be appreciated that process  is illustrative and not intended to limit embodiments of the present invention. Steps described as sequential may be executed in parallel, order of steps may be varied, and steps may be modified, combined, added, or omitted. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 9","b":["900","800","900","902","900","904"]},"In certain embodiments, the visualization application shown in  can (in addition to visualization) allow more sophisticated analyses to be performed on log records. For example, in one embodiment, the application can treat the log records as comprising one or more data streams (e.g., stream of enqueue events, stream of dequeue events, stream of insert into index events, stream of delete from index events, etc.). Accordingly, the application can provide these log records as inputs into a data stream processing server. Queries can then be run against the data streams and the results can be used by the application for various purposes.  is a flow diagram of a such a process .","At block , one or more events in the log file received at block  of process  can be provided to a data stream processing server. In one set of embodiments, the data stream processing server can be embedded into the visualization application performing the steps of process . Alternatively, the data stream processing server can be running in a different address space or on a different machine.","At blocks  and , a continuous query executed against the data streams can be received, and the query can be provided to the data stream processing server for processing. Merely by way of example, once such query may relate to checking the growth of a particular queue object. Another type of query may relate to correlating the size of an index to a size of a queue. Yet another type of query may relate to correlating the contents of an index to the contents of a queue. In one set of embodiments, the server can execute this query while the graphical representation of the query plan described in the log records is being animated (per block  of process ).","At block , a result set for the continuous query can be received from the data stream processing server. The result set can then be used to perform a specific action. For example, if the result set contains data satisfying a particular condition, the animation of the query plan can be halted, or an alert can be displayed. In this manner, the continuous query can act as a complex breakpoint condition (e.g., break playback if this condition is satisfied). A user can then inspect the contents of various query plan objects to try and determine the cause of any problems that may have occurred during query execution.","It will be appreciated that process  is illustrative and not intended to limit embodiments of the present invention. Steps described as sequential may be executed in parallel, order of steps may be varied, and steps may be modified, combined, added, or omitted. One of ordinary skill in the art would recognize many variations, modifications, and alternatives.","Turning now to  a process  is illustrated which is one implementation of a CQL debugger in CEP. At block , one or more events in the log file received at block  of process  can be provided to a data stream processing server. In one set of embodiments, the data stream processing server can be embedded into the visualization application performing the steps of process . Alternatively, the data stream processing server can be running in a different address space or on a different machine.","At block , a continuous query executed against the data streams can be received, and the query can be provided to the data stream processing server for processing. Merely by way of example, one such query may relate to checking the growth of particular queue object. Another type of query may relate to correlating the size of an index to a size of a queue. Yet another type of query may relate to correlating the contents of an index to the contents of a queue. In one set of embodiments, the server can execute this query while the graphical representation of the query plan described in the log records is being animated (per block  of process ).","At block , operators in the continuous query are stepped over. This allows for debugging of the operators within the query. Accordingly, once the operators have been identified, the data structures of the operators may be stepped into (block ). Stepping into such data structures provides the administrator with the ability to analyze bugs and other issues with the data structures, and develop solutions for such problems.","At block , breakpoints on the operators in the continuous query and the data structures are set. Furthermore, conditional breakpoints based on, for example, timestamps, tuple attributes within the data streams, etc. may also be set (block ). Therefore, the process will be able to stop at the hard breakpoints as well as optionally stop at the conditional breakpoints depending on the conditions being met.","Furthermore, at block , inspecting and watching of the data structures of the operators occurs because of the ability to step into the data structures and the breakpoints which have been set. In one embodiment, the data structures of the operators may include store, synopsis, queue, index, stat, etc.; however, other data structures of the operators may be included in the streaming query.","At block , the steps and breakpoints may be executed and as a result a graphical representation of the query plan as the query plan is being debugged may be presented. Such a graphical representation may be presented in a user interface, a mobile interface, etc. Furthermore, the interface may be interactive and provide the administrator, tester, etc. with the ability to manipulate the debugging information. Further, upon receipt of a debugging result(s), an output log of the debugging information may be produced (block ).","Turning now to , a process  is illustrated which is one implementation of a CQL debugger in CEP. At block , a trace and\/or breakpoint invocation is received. If it is determined that tracing has been set (decision block ), then a tracing level is processed (block ). In one embodiment, the tracing level may include normal, terse, verbose initialization, verbose data, and the like. Each of the levels may provide additional or alternative tracing information.","At decision block , if it is determined that one or more breakpoints have been set, then it is determined if there is an indication to continue through to the visual debugger console interface (decision block ). Once there is an indication to continue to the debugger console interface, then a visual representation of the debugging results is produced (block ).","Referring now to , a system  is illustrated for implementing a CQL debugger in CEP. The system  includes a tracelet  in a CQL processor engine . The system  further includes a trace\/debug engine  which is included in the data stream processing server  within the DSMS . In one embodiment, a communication channel provides communication from trace\/debug engine  to client applications supporting debug sessions including a visualizer (display device) , eclipse tooling , and a command line interface .","In one embodiment, a tracelet  may be a small code segment in the trace target which is used in tracing\/dumping and as a breakpoint. For trace targets including operators, data structures, etc, a tracelet  may be placed such that the trace\/debug module can intercept accordingly. For example, LogLevelManager.trace (LogArea.OPERATOR, LogEvent.OPERATOR_RUN_BEGIN, this, getOptName( )); may be used. This embodiment may use a static function in implementing the tracelet, but it can also be dynamically injected on class loading using byte code manipulation so that the burden to the programmers\/developers to maintain the tracelets can be removed.","In a further embodiment, when the trace\/debug engine  receives \u2018trace\u2019 invocation from tracelets , it checks if tracing or breakpoint is set for the target. The checking is done using a multi-dimensional array in order to minimize performance degradation. If tracing is set, the proper level of tracing is processed and if a breakpoint is set, it waits for user to continue through a visual debugger console interface.","The trace\/debug engine  includes the following tasks upon receiving tracelet 's invocation:",{"@attributes":{"id":"p-0133","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Levels levels = loglevelManager.getLevels(area,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"target.getTargetId( ), event);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002if (levels != null) {"]},{"entry":[{},"\u2003\u2002loglevelManager.traceLevels(area, event, target, levels, args);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2002Breakpoint bp = loglevelManager.getBreakpoint(area,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"target.getTargetId( ), event);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003if (bp != null) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bp.wait( ); \/\/ wait for next, continue"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In a further embodiment, trace targets may implement an IDump interface, which can provide tailored state information to debug clients. This may be particularly important for operators pertaining to complex states, such as a pattern operator. In one embodiment, the pattern operator may implement tailored state visualization logic in dumping the state so that the customers can easily understand the state. Using combinations of trace, dump, and breakpoint, these features described above may be implemented. Due to the minimization of performance impact in checking tracing\/breakpoint setup, the target application may not need to be started in special mode, such as debug mode. Instead, customers can invoke the debugger any time even including within the production platform.",{"@attributes":{"id":"p-0135","num":"0134"},"figref":["FIG. 14","FIGS. 1A and 1B"],"b":["1400","1400","1402","1404","1406","1408","1410","1412","1402","1404","1406","1408","100","1410","100","1400"]},"Client computing devices , , ,  may be general purpose personal computers (including, for example, personal computers and\/or laptop computers running various versions of Microsoft Windows and\/or Apple Macintosh operating systems), cell phones or PDAs (running software such as Microsoft Windows Mobile and being Internet, e-mail, SMS, Blackberry, and\/or other communication protocol enabled), and\/or workstation computers running any of a variety of commercially-available UNIX or UNIX-like operating systems (including without limitation the variety of GNU\/Linux operating systems). Alternatively, client computing devices , , ,  may be any other electronic device capable of communicating over a network (e.g., network  described below) with server computer .","Server computer  may be a general purpose computer, specialized server computer (including, e.g., a LINUX server, UNIX server, mid-range server, mainframe computer, rack-mounted server, etc.), server farm, server cluster, or any other appropriate arrangement and\/or combination. Server computer  may run an operating system including any of those discussed above, as well as any commercially available server operating system. Server computer  may also run any of a variety of server applications and\/or mid-tier applications, including web servers, Java virtual machines, application servers, database servers, and the like. As indicated above, in one set of embodiments, server computer  is adapted to run one or more server and\/or middle-tier components such as data stream processing server  of DSMS .","As shown, client computing devices , , ,  and server computer  are communicatively coupled via network . Network  may be any type of network that can support data communications using any of a variety of commercially-available protocols, including without limitation TCP\/IP, SNA, IPX, AppleTalk, and the like. Merely by way of example, network  may be a local area network (LAN), such as an Ethernet network, a Token-Ring network and\/or the like; a wide-area network; a virtual network, including without limitation a virtual private network (VPN); the Internet; an intranet; an extranet; a public switched telephone network (PSTN); an infra-red network; a wireless network (e.g., a network operating under any of the IEEE 802.11 suite of protocols, the Bluetooth protocol known in the art, and\/or any other wireless protocol); and\/or any combination of these and\/or other networks.","System environment  may also include one or more databases . In one set of embodiments, database  can include any other database or data storage component discussed in the foregoing disclosure, such as log configuration database , log record database , and change management database  of . Database  may reside in a variety of locations. By way of example, database  may reside on a storage medium local to (and\/or resident in) one or more of the computers , , , , . Alternatively, database  may be remote from any or all of the computers , , , ,  and\/or in communication (e.g., via network ) with one or more of these. In one set of embodiments, database  may reside in a storage-area network (SAN) familiar to those skilled in the art. Similarly, any necessary files for performing the functions attributed to the computers , , , ,  may be stored locally on the respective computer and\/or remotely on database , as appropriate. In one set of embodiments, database  is a relational database, such as Oracle 10 g available from Oracle Corporation. In a particular embodiment, database  is adapted to store, update, and retrieve data streams in response to CQL-formatted commands received at server computer .",{"@attributes":{"id":"p-0140","num":"0139"},"figref":["FIG. 15","FIG. 15"],"b":["1500","1500","1402","1404","1406","1408","1410","1400","1500","1524","1502","1504","1506","1500","1508","1508"]},"Computer system  may additionally include a computer-readable storage media reader , a communications subsystem  (e.g., a modem, a network card (wireless or wired), an infra-red communication device, etc.), and working memory , which may include RAM and ROM devices as described above. In some embodiments, computer system  may also include a processing acceleration unit , which can include a digital signal processor (DSP), a special-purpose processor, and\/or the like.","Computer-readable storage media reader  can further be connected to a computer-readable storage media , together (and, optionally, in combination with storage device(s) ) comprehensively representing remote, local, fixed, and\/or removable storage devices plus storage media for temporarily and\/or more permanently containing computer-readable information. Communications subsystem  may permit data to be exchanged with network  of  and\/or any other computer described above with respect to system environment .","Computer system  may also comprise software elements, shown as being currently located within working memory , including an operating system  and\/or other code , such as an application program (which may be a client application, Web browser, mid-tier application, RDBMS, etc.). It should be appreciated that alternative embodiments of computer system  may have numerous variations from that described above. For example, customized hardware might also be used and\/or particular elements might be implemented in hardware, software (including portable software, such as applets), or both. Further, connection to other computing devices such as network input\/output devices may be employed.","In one set of embodiments, the techniques described herein may be implemented as program code executable by a computer system (such as a computer system ) and may be stored on machine-readable storage media. Machine-readable storage media may can include any appropriate media known or used in the art, including storage media and communication media, such as (but not limited to) volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage and\/or transmission of information such as machine-readable instructions, data structures, program modules, or other data, including RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disk (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store or transmit the desired information and which can be accessed by a computer.","Although specific embodiments of the present invention have been described, various modifications, alterations, alternative constructions, and equivalents are within the scope of the invention. For example, embodiments of the present invention are not restricted to operation within certain specific data processing environments, but are free to operate within a plurality of data processing environments. Additionally, although embodiments of the present invention have been described using a particular series of transactions and steps, it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.","Further, while embodiments of the present invention have been described using a particular combination of hardware and software, it should be recognized that other combinations of hardware and software are also within the scope of the present invention. Embodiments of the present invention may be implemented only in hardware, or only in software, or using combinations thereof.","The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The scope of the invention should be determined not with reference to the above description, but instead should be determined with reference to the pending claims along with their full scope or equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
