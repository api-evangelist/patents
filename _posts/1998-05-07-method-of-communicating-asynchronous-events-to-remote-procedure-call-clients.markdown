---
title: Method of communicating asynchronous events to remote procedure call clients
abstract: A computer system in accordance with the present invention provides a method of communicating events from a server to remote procedure call clients. The disclosed technique begins with a remote procedure call by a remote procedure call client to a server to establish an initial client-server connection. Next, there is a remote procedure call to create a guaranteed delivery communication conduit, such as a named pipe, between the server and client and to create a server asynchronous event thread in a blocked state for blocking execution of the server asynchronous event thread. A client asynchronous event thread in the client is then created to open the named pipe. If the server detects an event, an event message is generated which places the server asynchronous event thread in an unblocked state to allow execution of the server asynchronous event thread. Event data may then be transmitted across the named pipe from the server to the client. After transfer of the event data is complete, the server asynchronous event thread is blocked. By unblocking the server asynchronous event thread when an event is detected and blocking the server asynchronous event thread following transmission of the event through a named pipe to the client, asynchronous events may be communicated by a server to remote procedure call clients. As a result, it is not necessary for a remote procedure call client to poll a server to receive asynchronous event information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06901596&OS=06901596&RS=06901596
owner: Hewlett-Packard Development Company, L.P.
number: 06901596
owner_city: Houston
owner_country: US
publication_date: 19980507
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF INVENTION"],"p":["Commonly-assigned U.S. patent application Ser. No. 09\/074,110, now U.S. Pat. No. 6,278,004 B1, entitled \u201cMETHOD OF COMMUNICATING ASYNCHRONOUS EVENTS FROM A MINIPORT DRIVER,\u201d filed concurrently, is hereby incorporated by reference.","1. Field of the Invention","The present invention relates to remote procedure call clients, and more particularly to a method of communicating asynchronous events from a server to remote procedure call clients.","2. Description of the Related Art","Computer systems for distributed and remote applications are increasingly being designed for a client-server model and a RPC (Remote Procedure Call) model. In a client-server model, front-end clients present information to a user, and a back-end server performs computing task for the clients. A client usually manages a user interface, and the server usually handles data storage, queries, and manipulation. A client-server model enhances efficiency by allowing resources to be shared among numerous computers and provides ease of network administration. A client-server model is understood to encompass the growing computing needs that extend from corporate desktop PCs to corporate computing levels.","A client and a server each have their own address space. A RPC model, an industry standard which includes a server and a remote procedure client, makes it appear to users as though a client directly calls a procedure located in a remote server program. For example, instead of containing the actual code that implements a remote procedure, client stub code within a client retrieves the required parameters from the client address space, translates the parameters from a local data representation to a network representation, and calls functions in a RPC client runtime library within the client to send the request and parameters to the server. A server runtime library within the server accepts the request and calls server stub code within the server. The server stub code retrieves the parameters from a network buffer, translates the parameters from the network representation to a local data representation, and calls the actual procedure on the server. The remote procedure may return its data to the server stub code. Output parameters are then returned to the server RPC runtime library by the server stub code.","To obtain asynchronous events from a server of a computer system configured for an RPC model it has been necessary for a RPC client to execute a remote procedure call to a server. A remote procedure call by a RPC client permits a RPC client to poll a server to obtain asynchronous event information. RPC client software has not provided a method for a server to communicate to a RPC client about an asynchronous event without the RPC client first polling the server.","Polling of a server by a RPC client in order to keep asynchronous event information current has caused network traffic and system overhead. Polling also allows asynchronous event information at a server to become stale for certain periods until the server is polled and the asynchronous event information is received by the RPC client. If the poll frequency is increased in an effort to maintain more current asynchronous event information from a server, then network traffic is also undesirably increased.","Briefly, a computer system in accordance with the present invention provides a method of communicating asynchronous events from a server to remote procedure call clients. The disclosed technique begins with a remote procedure call by a client to a server to establish an initial client-server connection. Next, there is a remote procedure call to create a guaranteed delivery communication conduit, such as a named pipe, between the server and client and to create a server asynchronous event thread in a blocked state for blocking execution of the server asynchronous event thread. A client asynchronous event thread in the client is then created to open the named pipe. If the server detects an event, an event message is generated which places the server asynchronous event thread in an unblocked state to allow execution of the server asynchronous event thread. Event data may then be transmitted across the named pipe from the server to the client. After transfer of the event data is complete, the server asynchronous event thread is blocked. By unblocking the server asynchronous event thread when an event is detected and blocking the server asynchronous event thread following transmission of the event through a named pipe to the client, asynchronous events may be communicated by a server to remote procedure call clients. As a result, it is not necessary for a remote procedure call client to poll a server to receive asynchronous event information.","Turning now to the drawings.  shows a schematic diagram of a remote procedure client  and a server  of a computer network system S. Both the client  and the server  include a multitasking operating system (not shown) that supports multiple threads of execution within a running process and a kernel for handling thread management. A process is a program that is loaded into memory and prepared for execution. A process may contain code, data, and other system resources\u2014such as files, pipes, and synchronization objects\u2014that are accessible to the threads of the process. Each process is started with a single thread. A thread is the basic entity to which the operating system allocates CPU time. A thread can execute any part of an application's code, including a part currently being executed by another thread. A multitasking operating system divides the available CPU time among the threads that need it. The operating system may utilize preemptive multitasking for allocating small slices of CPU time among the competing threads. Multitasking provides the ability to have several applications open and working at the same time. A further advantage of multitasking is the ability to create applications that use more than one process and to create processes that use more than one thread of execution.","The client  includes a processor  coupled to a processor readable medium  containing RPC client interface , a client RPC runtime library , a client stub , a RPC client application , and a user interface (UI) . The RPC client application  uses function calls to the client RPC runtime library  to access RPC client stub code  through the RPC client interface . The client stub  marshals arguments and calls a communication subsystem (not shown) to send the arguments to the server . Marshalling is essentially the process of packaging arguments or parameters into a network message. The kernel of the client  sends the network message to the server . A function call to the RPC client application  may be initiated by a user command from the user interface . A remote procedure call (RPC) permits individual procedures of an application to run on systems anywhere on a network. The client  permits remote communication over a network to the server , and the server  permits remote communication over the network to the client . It should be understood that the network computer system S may include a plurality of remote procedure clients capable of remote communication to the server .","In accordance with the present invention, the server  includes a processor  coupled to a processor readable medium  containing an RPC server interface , a server RPC runtime library , server stub , an ASYNC_NOTIFY block , and a service . A service is essentially a software construct that provides software code to supplement the functions of an operating system. The service  supports RPC interface calls, service calls, device class DLL calls, client library calls, and driver calls. The RPC interface calls, service calls, device class DLL calls, and client library calls, are of a conventional type, such as those defined by Windows NT\u00ae. Certain RPC interface calls, for example, are documented in MS WIN32 RPC Programmers' Guide and Reference, which is incorporated herein by reference. Examples of service calls which may be supported by the service  may include messages for informing the service  to stop, pause, resume, or report its status. It should be understood that the processor readable medium  of the client  and the processor readable medium  of the server  may be any medium suitable for storing code to be executed by a processor, such as a compact disc read only memory (CD-ROM), a disk, or a memory device, for example.","Incoming calls to a server  are directed to the RPC server interface . The RPC server interface  defines a number of procedures which may be called remotely by the client . A remote procedure call is passed through the RPC server interface  to the server stub code . The server stub code  marshals arguments from the network message. The server stub code  also translates the input arguments from network to local data representation and passes the arguments directly on to the called-remote procedure. The procedure then executes and returns any results to the server stub code . The server stub code  translates the results and passes them to the server RPC run time library . The server RPC runtime library  dispatches the results over the network to the client RPC runtime library . In accordance with the present invention, the server  further includes an ASYNC_NOTIFY block  for communicating asynchronous events from the server  to client . It should be understood that the software of the present invention may be stored in a processor readable medium external to the server  or client  and then provided to the processor readable medium  or  internal to the client or server.","Asynchronous Communication Between a Client and Server","Referring to , a flow chart of a CLIENT_INTERFACE routine  for the client  is shown. Beginning at step , an OPEN_SERVER routine  is called. Referring to , the OPEN_SERVER routine  is shown. In the disclosed embodiment, the OPEN_SERVER routine  is a function having an input parameter, Server. The Server parameter is a null terminated string containing the name of a server such as . If the function succeeds in binding to a server, the return value is ERROR_SUCCESS. If the function fails to bind, the return value is FALSE. Beginning at step , it is determined whether the server  is already open. A determination of whether the server  is already open may be made by determining the state of a SERVER_ALREADY_OPEN variable. If SERVER_ALREADY_OPEN is TRUE, then the server  is open, and if SERVER_ALREADY_OPEN is FALSE, then the server  is not open. If the server  is already open, control returns through step . If the server  is not already open, control proceeds to step  where a client-server connection is established. In the disclosed embodiment, a client-server connection is established by a remote procedure call from the client  to the server  which returns a ClientID parameter. When a connection is made between the server  and the client , a binding handle for the particular client  is returned. The binding handle is implicitly used until the connection between the server  and the client  is closed. Various string binding APIs (application programming interfaces) may be used for establishing or terminating a client-server connection. Examples of string binding APIs are provided in the table below:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["STRING BINDING FUNCTIONS","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RPCStringBindingCompose","Combine components of a string"]},{"entry":[{},"binding into a string binding"]},{"entry":["RPCBindingFromStringBinding","Convert string binding to binding"]},{"entry":[{},"handle"]},{"entry":["RPCBindingSetAuthInfo","Set security for string binding"]},{"entry":["RPCStringFree","Deallocate memory for the string"]},{"entry":[{},"returned in the String Binding"]},{"entry":[{},"argument"]},{"entry":["RPCBindingFree","Release binding"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Next, control proceeds to step  where a callback address for the client  and an event type are saved. The saved event type indicates the type of events to be provided to the client . An event mask is defined for the client  to mask out activities and events which are not of interest to the client . In the disclosed embodiment, a callback address for the client  is stored as a callback entry in a callback table. From step , control proceeds to step  where a REGISTER_FOR_ASYNC_EVENT_CALLBACK routine  is called. Referring to , the REGISTER_FOR_ASYNC_EVENT_CALLBACK routine  is shown. In the disclosed embodiment, the REGISTER_FOR_ASYNC_EVENT_CALLBACK routine  is a remote procedure call. The routine  is also a function having an input parameter, ClientID. The ClientID parameter represents the ID of the client  to register which was returned when the client server connection was established. If the function is successful, the return value is 0. If the function fails, the return value is an error code.","Beginning at step , a named pipe instance is created. A pipe is a communication conduit, which in this case is between the server  and the client . In the disclosed embodiment, a named pipe instance is created by calling the CreateNamedPipe function. The data passed to the CreateNamedPipe function is defined below:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HANDLE CreateNamedPipe("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LPCTSTR lpName,"]},{"entry":[{},"DWORD dwOpenMode,"]},{"entry":[{},"DWORD dwPipeMode,"]},{"entry":[{},"DWORD nMaxInstances,"]},{"entry":[{},"DWORD nOutBufferSize,"]},{"entry":[{},"DWORD nlnBufferSize,"]},{"entry":[{},"DWORD nDefaultTimeOut,"]},{"entry":[{},"LPSECURITY_ATTRIBUTES lpSecurityAttributes"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The IpName is a pointer to the pipe name. dwOpenMode is a parameter specifying the pipe access mode. dwOpenMode is set to PIPE_ACCESS_DUPLEX and FILE_FLAG_WRITE_THROUGH. The PIPE_ACCESS_DUPLEX mode causes the pipe to be bidirectional, such that both the client  and the server  can read from and write to the named pipe. The FILE_FLAG_WRITE_THROUGH mode causes functions writing to the named pipe to not return until data written is across the network. dwPipeMode specifies the type, read, and wait modes of the pipe handle. dwPipeMode is set to PIPE_TYPE_MESSAGE, PIPE_READMODE_MESSAGE, and PIPE_WAIT. In a PIPE_TYPE_MESSAGE mode, data is written to the pipe as a stream of messages. In a PIPE_READMODE_MESSAGE mode, data is read from a pipe as a stream of messages. In a PIPE_WAIT mode, blocking of a pipe is enabled. nMaxInstances specifies the maximum number of instances that can be created for a pipe. nOutBufferSize specifies the number of bytes to reserve for the output buffer. The nInBuffer Size parameter specifies the number of bytes to reserve for the input buffer. The nDefaultTimeOut parameter specifies the default time-out value in milliseconds. The IpSecurityAttributes parameter specifies a pointer to a SECURITY ATTRIBUTES structure for determining whether child processes can inherit the returned handle. If the CreateNamedPipe function succeeds, the return value is a handle to the server end of a named pipe instance. If the function fails, the return handle is INVALID_HANDLE_VALUE. A named pipe is one type of guaranteed delivery communication conduit since either end of a pipe can determine if the other end received an event or failed to receive an event. While the disclosed embodiment is illustrative of pipe-based communication, it should be understood that other implementations providing guaranteed delivery communication are also possible, such as socket-based communication for example.","Control continues from step  to step  where an async event signal is created. The async event signal when provided indicates that an asynchronous event is present in the server asynchronous event queue  (FIGS. B-F). The server asynchronous event queue  is a queue in the server  for storing asynchronous events. The server  contains a server asynchronous event queue  for each client  of the plurality of clients. From the server asynchronous event queue , an event is transmitted across a named pipe to a respective client . Control next proceeds to step  where a CreateThread function is called to create a SERVER_ASYNC_EVENT_THREAD routine . The data passed to the CreateThread function is defined below:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HANDLE CreateThread("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LPSECURITY_ATTRIBUTES lpThreadAttributes"]},{"entry":[{},"DWORD dwStackSize,"]},{"entry":[{},"LPTHREAD_START_ROUTINE lpStartAddress"]},{"entry":[{},"LPVOID lpParameter,"]},{"entry":[{},"DWORD dwCreationFlags,"]},{"entry":[{},"LPWORD lpThreadLD"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The IpThreadAttributes parameter is a pointer to a SECURITY ATTRIBUTES structure that determines whether the return handle can be inherited by a child process. The dwStackSize parameter specifies the initial thread stack size in bytes. The IpStartAddress parameter points to the application-supplied function to be executed by the thread and represents the starting address of the thread. The IpParameter parameter specifies a single 32-bit parameter value for an argument for the new thread. The dwCreationFlags parameter specifies the flags that control creation of the thread. In accordance with the present invention, dwCreationFlags is set to the CREATE_SUSPENDED flag. The CREATE_SUSPENDED flag causes the created thread to be in a suspended state. A ResumeThread function is necessary to return a thread from a suspended mode. Operation of the ResumeThread function is understood to one of ordinary skill in the art. The IpThreadId parameter points to a 32-bit variable that receives the thread identifier. If the CreateThread function succeeds, the returned value is a handle to a new thread. If the function fails, the return value is NULL. The SERVER_ASYNC_EVENT_THREAD routine  may execute independently at any time after a CreateThread call. It should be understood that the SERVER_ASYNC_EVENT_THREAD routine  creates an event thread for any client which calls REGISTER_FOR_ASYNC_EVENT_CALLBACK routine .","Referring to , the SERVER_ASYNC_EVENT_THREAD routine  is shown. The SERVER_ASYNC_EVENT_THREAD routine  is a thread function with an input parameter, ThreadData. The ThreadData parameter is a pointer to data that will be associated with a thread. If the function is successful, the return value is 0. If the function fails, the return value is an error code. Beginning at step , an event handle is created. In the disclosed embodiment, the event handle is created by calling a CreateEvent function. The data passed to the CreateEvent function is defined below:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HANDLE CreateEvent ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LPSECURITY_ATTRIBUTES lpEventAttributes,"]},{"entry":[{},"BOOL bManualReset"]},{"entry":[{},"BOOL bInitialState"]},{"entry":[{},"BOOL lpName"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The parameter IpEventAttributes is a pointer to a SECURITY ATTRIBUTES structure that defines whether the returned handle can be inherited by a child process. The IpEventAttributes parameter is set to NULL. The bManualReset parameter specifies whether a manual-reset or auto-reset event object is created. The bManualReset parameter is set to TRUE, therefore the ResetEvent function must be used to manually reset a state to non-signalled. The bInitialState parameter specifies an initial state of an event object. The bInitialState parameter is set to FALSE, therefore the initial state is non-signaled. The IpName parameter points to the event object name. The IpName parameter is set to NULL, causing the event object to be created without a name. If the CreateEvent function succeeds, the return value is a handle to the event object.","Control next proceeds to step  where the SERVER_ASYNC_EVENT_THREAD routine  waits for the named pipe instance to connect. Next, in step , a block is placed on the async event signal. A block on the async event signal places the SERVER_ASYNC_EVENT_THREAD routine  in a sleep or suspend state. The SERVER_ASYNC_EVENT_THREAD routine  remains in a suspend state until the SERVER_ASYNC_EVENT_THREAD routine  receives either an event message or an exit message from the client . In step , it is determined whether the SERVER_ASYNC_EVENT_THREAD routine  has received an exit message. If the SERVER_ASYNC_EVENT_THREAD  has received an exit message, control proceeds to step  where the exit message is written to the named pipe. In the disclosed embodiment, data is written to a pipe by calling a WriteFile function. The data passed to the WriteFile function is defined below:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BOOL WriteFile ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE hfile,"]},{"entry":[{},"LPVOID lpBuffer,"]},{"entry":[{},"DWORD nNumberOfBytesToRead"]},{"entry":[{},"LPWORD lpNumberOfBytesToRead,"]},{"entry":[{},"LPOVERLAPPED lpOverlapped"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The hfile parameter identifies the pipe to be written. The IpBuffer parameter points to a buffer containing the data to be written to the pipe. The IpBuffer parameter is set to the variable TRANSMSG representing a message to be transmitted. The nNumberOfBytesToWrite parameter is the number of bytes to be written. The IpNumberOfBytesWritten points to the number of bytes actually written, filled by the WriteFile call. The IpOverlapped parameter points to the OVERLAPPED structure, which is set to NULL.","From step , control proceeds to step  where the named pipe instance is closed. In the disclosed embodiment, the named pipe instance is closed by calling a CloseHandle function known in the art. Next, at step  the event handle is closed. In the disclosed embodiment, an event handle is closed by calling the CloseHandle function. Next, control proceeds to step  where the asynchronous event thread data is deleted. From step , control proceeds to step  where the SERVER_ASYNC_EVENT_THREAD routine  is exited.","In step , if the SERVER_ASYNC_EVENT_THREAD routine  does not detect an exit message, then control proceeds to step  where it is determined if an event message is provided. If an event message is provided to the SERVER_ASYNC_EVENT_THREAD routine , then control proceeds to step  where the event message is written to the named pipe. In the disclosed embodiment, an event message is written to the named pipe by calling the WriteFile function described above. If an event message is not available, control proceeds from step  back to step . The SERVER_ASYNC_EVENT_THREAD routine  thus remains in a blocked state until an event message or exit message is received. Returning to , control continues from step  to step  where a thread ID and machine name is saved. From step , control returns from the REGISTER_FOR_ASYNC_EVENT_CALLBACK remote procedure call  through step . Returning to , from step , control proceeds to step  where a client asynchronous event thread  () is created. In the disclosed embodiment, a CreateThread function is used to create the client asynchronous event thread  in a suspended state. The data passed to the CreateThread function is defined above.","From step , control proceeds to step  where the client asynchronous event thread  is resumed. The client asynchronous event thread  is resumed from its initially suspended state by a call to the ResumeThread function, and the CLIENT_ASYNC_EVENT_THREAD thread function  begins (FIG. ). Beginning at step , a named pipe is opened. The pipe name is based on the client ID and is the client end of the named pipe that was created in the server by the REGISTER_FOR_ASYNC_EVENT_CALLBACK routine . In the disclosed embodiment, the named pipe is opened by calling a CreateFile function. The data passed to the CreateFile function is defined below:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HANDLE CreateFile("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LPCTSTR lpFileName,"]},{"entry":[{},"DWORD dwDesiredAccess,"]},{"entry":[{},"DWORD dwShareMode,"]},{"entry":[{},"LPSECURITY_ATTRIBUTES lpSecurityAttributes,"]},{"entry":[{},"DWORD dwCreationDistribution,"]},{"entry":[{},"DWORD dwFlagsAndAttributes,"]},{"entry":[{},"HANDLE hTemplateFile,"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The IpFileName parameter is a pointer to the name of the pipe. The dwDesiredAccess parameter is an access mode for the pipe. The dwDesiredAccess parameter is set to GENERIC_READ and GENERIC_WRITE. The dwShareMode paremeter is a set of bit flags that specify the file can be shared. The dwShareMode is set to zero indicating the pipe cannot be shared. The IpSecurityAttributes parameter is a pointer to a SecurityAttributes structure that determines whether the returned handle can be inherited by a child process. The IpSecurityAttributes parameter is set to NULL so the handle cannot be inherited. The dwCreationDistribution parameter specifies which action to take on existing pipes. The dwCreationDistribution is set to OPEN_EXISTING, specifying an open file operation. The dwFlagsAndAttributes parameter specifies the file attributes and flags for the created file. The dwFlagsAndAttributes parameter is set to FILE_ATTRIBUTE_NORMAL, meaning the pipe has no attributes set. The hTemplateFile parameter specifies a handle with GENERIC_READ access to a template file. The hTemplateFile paramater is set to NULL.","From step , control proceeds to step  where the named pipe is read and the thread waits for pipe message data. Next, in step , it is determined whether an exit message was read from the named pipe. If an exit message was read, control proceeds to step  where the client end of the named pipe is closed. From step , the client asynchronous event thread exits through step . If the message read from the named pipe is not an exit message, control proceeds from step  to step . In step , it is determined whether the event message from the named pipe is a relevant event message type to the particular client , based on the event mask provided in the OPEN_SERVER routine . If the event message is a relevant event message type, then control proceeds to step  where the client  is called with the saved callback address (for a callback routine) and the event message. From step , control loops back to step  where the named pipe is again read. If the event message from the named pipe is not of a relevant event type to the particular client , then control loops from step  back to step .","From step , control proceeds to step  where the SERVER_ALREADY_OPEN variable is set to TRUE. Next, control returns through step . Returning to , from step , control proceeds to step  where asynchronous events are processed. Calling a callback routine in the client  in step  activates the processing of events. Next, control proceeds to step  where the CLOSE_SERVER routine  is called. Referring to , the CLOSE_SERVER routine  is shown. In the disclosed embodiment, the CLOSE_SERVER routine  is a function having no input parameters. If the function is successful, the return value is TRUE. If there is an error when unregistering the client , waiting for the client asynchronous event thread to exit, or releasing a binding, the return value is FALSE. Beginning at step , it is determined whether the server  is already closed by determining the state of the SERVER_ALREADY_OPEN variable. If the server  is already closed, control returns through step . If the server  is not already closed, control proceeds to step  wherein the remote procedure call UNREGISTER_FOR_ASYNC_EVENT_CALLBACK  is called. Referring to , the UNREGISTER_FOR_ASYNC_EVENT_CALLBACK remote procedure call  is shown. In the disclosed embodiment, the UNREGISTER_FOR_ASYNC_EVENT_CALLBACK routine  is a function with an input parameter, ClientID. Client ID refers to the ID of the client  to unregister that was obtained in OPEN_SERVER . If the function is successful, the return value is 0. If the function fails, the return value is an error code. Control begins at step  where an exit server async event thread flag is set. From step , control proceeds to step  where an async event wakeup signal is generated.","Control then proceeds to step  where the process waits for the SERVER_ASYNC_EVENT_THREAD routine  to exit. In the disclosed embodiment, a WaitForSingleObject function is called to cause a wait for the particular thread to exit. The data passed to the WaitForSingleObject function is defined below:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DWORD WaitForSingleObject("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE hHandle,"]},{"entry":[{},"DWORD dwMilliseconds"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The hHandle parameter identifies the particular object. The dwMilliseconds parameter specifies the time-out period in milliseconds. The WaitForSingleObject function returns when either a specified object is in the signaled state or the time-out interval elapses. The WaitForSingleObject function returns when the thread handle is signaled (thread exited) or when the time-out expires.","Next, Control returns from the UNREGISTER_FOR_ASYNC_EVENT_CALLBACK remote procedure call  through step . Referring to , control proceeds from step  to step  where a wait for the client asynchronous event thread to exit is generated. In the disclosed embodiment, the wait is performed by calling the WaitForSingleObject function described above. From step , control proceeds to step  where the SERVER_ALREADY_OPEN variable is set to FALSE. Next, the CLOSE_SERVER routine  returns through step . Referring to , from step , the CLIENT_INTERFACE routine  terminates through step .","Referring to , an ASYNC_NOTIFY_THREAD routine  provided by the ASYNC_NOTIFY block  is shown. The ASYNC_NOTIFY_THREAD routine  represents an asynchronous event notification thread for generating and sending asynchronous event messages from the server  to the client . Beginning in step , the routine  calls a monolithic driver  () for an event queue  using the IOCTL  in  which is described below. In the disclosed embodiment, step  is performed using an IOCTL. An IOCTL is a generic driver call  interface such as the Win32 DeviceIoControl API function. The parameter types, input parameters, and description of the input parameters for the Win32 DeviceIoControl API function are given below:",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"INPUT",{}]},{"entry":["PARAMETER TYPES","PARAMETERS","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HANDLE","HDevice;","handle of device"]},{"entry":["ULONG","UIIoControlCode;","control code of operation"]},{"entry":[{},{},"not perform"]},{"entry":["LPVOID","IpvInBuffer;","address of buffer for input"]},{"entry":[{},{},"data"]},{"entry":["ULONG","IcbInBuffer;","size of input buffer"]},{"entry":["LPVOID","IpvOutBuffer;","address of output buffer"]},{"entry":["ULONG","IcbOutBuffer;","size of output buffer"]},{"entry":["LPULONG","IpcbBytesReturned;","address of actual bytes of"]},{"entry":[{},{},"output"]},{"entry":["LPOVERLAPPED","IpoOverlapped;","address of overlapped"]},{"entry":[{},{},"structure"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["204","206","204","120","122","124","126","128","130","130","10","132","133"]},"Referring to , the SIGNAL_ALL_ENTRIES routine  is shown. Beginning at step , a server asynchronous event thread mutex (mutually exclusive) is acquired by SIGNAL_ALL_ENTRIES  in order to add data to the server asynchronous event queue . At step , the event message is placed in the server asynchronous event queue . Control then proceeds to step  where the server asynchronous event thread is awakened by an event message. Next, in step , the server asynchronous event thread mutex is released. From step , control proceeds to step  where it is determined whether there are additional client asynchronous event threads. If there are other client asynchronous event threads, control proceeds back to step . If there are no other client asynchronous event threads, control returns to step .","Returning to , control proceeds from step  to step . At step , it is determined whether an additional event is in the event queue . If an additional event is not in the event queue , control returns to step  where the monolithic driver  is again called for the event queue . If an additional event is in the event queue , control proceeds back to step  where another event is selected from the event queue .","Asynchronous Event Messaging Process","Referring to , the asynchronous event messaging process between the client  and the server  is shown. In the disclosed embodiment, the event messaging process between the client  and the server  are performed in the order of the stages illustrated by . It should be understood that the order of the stages may be varied without detracting from the spirit of the invention. Referring to , remote procedure call. RPC-, for establishing a client-server connection is shown. Referring to , a remote procedure call. RPC-, for creating a named pipe  between the client  and the server  and for creating the server asynchronous event thread  is shown. The remote procedure call, RPC-, also creates the server asynchronous event queue  owned by the server asynchronous event thread . Referring to , the client asynchronous event thread  for opening the named pipe  is shown. Referring to , the server asynchronous event thread  is in a blocked state for blocking execution of the server asynchronous event thread . Referring to , the server asynchronous event thread  is shown in an unblocked state. The server asynchronous event thread  was placed in an unblocked state in response to an asynchronous event signal . The server asynchronous event thread  in an unblocked state allows execution of the server asynchronous event thread . This way, an asynchronous event may be communicated from the server  to the client . Referring to , the server asynchronous event thread  is blocked following the asynchronous event message  to the client . Referring to , the server asynchronous event thread  is terminated. Referring to , the named pipe  is closed by a remote procedure call, RPC-. Referring to , the client asynchronous event thread  is terminated. Communicating an asynchronous event from a server to a remote procedure client event without the need for polling is of particular use to remote configuring, monitoring and reporting applications for computer systems. Examples of events that may be communicated for such applications include a driver fault event, a temperature fault event, a power fault event, a slot state change event, and a board failure event. It should be understood, however, that any event of interest to a client may be communicated by a server to a client.","Asynchronous Communication Between a Miniport Driver and a Service","Referring to , a schematic illustration of software components within the server  for asynchronous event messaging between a mini-port driver  and a service  in accordance with the present invention is shown. In accordance with the present invention, a monolithic driver  is used for communicating an asynchronous event from a mini-port driver  to a service . The service  of the invention supports a GET_ENTRY_POINT_&_INITIALIZE_QUEUE IOCTL  () to the monolithic driver , a MONOLOTHIC_BLOCKING IOCTL  () to the monolithic driver, and a MINIPORT_SET_CALLBACK IOCTL  () to the mini-port driver .","For the GET_ENTRY_POINT_&_INITIALIZE_QUEUE_IOCTL , the hDevice parameter is the handle of the monolithic driver, and the IpvInBuffer parameter is for storage of the callback address. For the MONOLITHIC_BLOCKING IOCTL , the hDevice parameter is the handle of the monolithic driver. For the MONOLITHIC_SET_CALLBACK IOCTL , the hDevice parameter is the handle of the mini-port driver , and the IpvOutBuffer is the address of the event queue . It should be understood that each IOCTL defined for the present invention may alternatively be defined as a plurality of IOCTLs and that certain IOCTLS might be merged to define a single IOCTL. It should also be understood that a step or operation of an IOCTL or routine defined for the present invention might itself be implemented in the form of a routine.","A MINIPORT_SEND_EVENT routine  () is provided from the mini-port driver  to the monolithic driver  for communicating an asynchronous event from the mini-port driver  to the monolithic driver . The monolithic driver  includes the event queue  which provides a plurality of slots for storing a plurality of asynchronous events. A mini-port driver is essentially a device specific event-mode driver, and a monolithic driver is essentially a driver containing different classes of functionality. It is contemplated that the monolithic driver  may be used (as a dispatch) for communicating asynchronous events between any software component and any driver having an architecture similar to a mini-port driver. In accordance with the present invention, asynchronous events or asynchronous commands may be sent from the mini-port driver  to the service . Although a single mini-port driver  is illustrated, it should be understood that the server  may include a plurality of mini-port drivers . Referring to , a SERVICE_INIT routine  is shown. During initialization of the service , control begins at step . At step , the GET_ENTRY_POINT_&_INITIALIZE_QUEUE IOCTL  is called. Referring to , the GET_ENTRY_POINT_&_INITIALIZE_QUEUE IOCTL  is shown. Beginning at step , a callback or entry point address is fetched from the monolithic driver . The callback address may later be used to call the monolithic driver  when there is an asynchronous event to report to the service . From step , control proceeds to step  wherein the event queue  is enabled. Control next returns through step . Returning to , control proceeds from step  to step . In step , the MINIPORT_SET_CALLBACK IOCTL  is called. Referring to , the MINIPORT_SET_CALLBACK IOCTL  is shown. Beginning at step , the callback address is provided to the mini-port driver . Control then returns through step . Referring to , control proceeds to step  where an ASYNC_NOTIFY thread  is created. The ASYNC_NOTIFY thread  calls the MONOLITHIC_BLOCKING IOCTL  of FIG. . From step , control proceeds to step . It should be understood that initialization of a service may include various process tasks (general and application-specific) which would be appreciated by one of ordinary skill in the art.","Referring to , the MONOLITHIC_BLOCKING IOCTL  begins at step  where it is determined if there is an event in the event queue . If so, control proceeds to step  where all events are copied and a count is reset. The count is used for tracking the number of events held by the event queue . If not, control proceeds to step  where the ASYNC_NOTIFY thread  is blocked. The thread  remains blocked until the signal generated in step  is received. Once the signal is received, control proceeds to step  where all events are copied. From step , control returns through step . In accordance with the present invention, an event may be available before or after the MONOLITHIC_BLOCKING IOCTL  is called.","Referring to , the MINIPORT_SEND_EVENT routine  is shown. Beginning at step , an event structure of an event object is filled with event data for the detected event. From step , control proceeds to step  where a PASS_EVENT routine  is called with the particular event using the callback address, provided in the SERVICE_INIT routine  obtained from the monolithic driver . Referring to , the PASS_EVENT routine  is shown. Control begins at step  where it is determined if the event queue  is enabled. If the event queue  is disabled, control returns through step . If the event queue  is enabled, then control proceeds to step . In step , the event is copied to the next available slot in the event queue  and the count is incremented.","From step , control proceeds to step  where the event object is set to signal an event is in the event queue . The MINIPORT_SEND_EVENT routine  may be concurrent with the MONOLITHIC_BLOCKING IOCTL . An event may not be detected in step  (FIG. ), until an event object is set in step . Setting the event object signals the monolithic driver  that an asynchronous event is present. In the disclosed embodiment, a deferred procedure call (DPC) is used to set an event object. While one mini-port driver  is accessing the event queue , other mini-port drivers  are prevented from accessing the event queue . Exclusive access to the event queue , for example, may be achieved by a mini-port driver  acquiring a spinlock object to access the event queue . In the disclosed embodiment, each mini-port driver  has an ID to use when calling the monolithic driver  for identifying which mini-port driver  an asynchronous event is coming from. From step , control returns through step . The disclosed asynchronous messaging process between the mini-port driver  and the service  may be used as an alternative to polling a mini-port driver  or in conjunction with polling a mini-port driver . Communicating asynchronous events from a mini-port driver to a software component is of particular use to remote configuring, monitoring, and reporting applications for computer systems. Examples of events that may be communicated for such applications include a driver fault event, a temperature fault event, a power fault event, a slot state change event, and a board failure event. It should be understood, however, that any event of interest to a client may be communicated by a server to a client.","The foregoing disclosure and description of the invention are illustrative and explanatory thereof, and various changes in the number of variables, number of parameters, order of steps, field sizes, data types, code elements, code size, connections, components, and materials, as well as in the details of the illustrated hardware and software and construction and method of operation may be made without departing from the spirit of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 7","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 11A-11I"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 14","FIG. 12"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 15","FIG. 12"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 16","FIG. 12"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 17","FIG. 12"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 18","b":"17"}]},"DETDESC":[{},{}]}
