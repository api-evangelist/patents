---
title: Method and system for temporary data unit storage on infiniband host channel adaptor
abstract: A method for temporary storage of data units including receiving a first data unit to store in a hardware linked list queue on a communications adapter, reading a first index value from the first data unit, determining that the first index value does match an existing index value of a first linked list, and storing the first data unit in the hardware linked list queue as a member of the first linked list. The method further includes receiving a second data unit, reading a second index value from the second data unit, determining that the second index value does not match any existing index value, allocating space in the hardware linked list queue for a second linked list, and storing the second data unit in the second linked list.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08804752&OS=08804752&RS=08804752
owner: Oracle International Corporation
number: 08804752
owner_city: Redwood Shores
owner_country: US
publication_date: 20110531
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application contains subject matter that may be related to the subject matter in the following U.S. patent applications, which are both assigned to a common assignee and are both incorporated by reference in their entirety: U.S patent application Ser. No. 13\/149,449 entitled, \u201cMethod and System for Infiniband\u00ae Host Channel Adapter Quality of Service,\u201d filed on May 31, 2011, and now issued as U.S. Pat. No. 8,484,392; and U.S. patent application Ser. No. 13\/149,436 entitled, \u201cMethod and System for Processing Commands on an Infiniband\u00ae Host Channel Adapter,\u201d filed on May 31, 2011, and now issued as U.S. Pat. No. 8,589,610.","The Infiniband\u00ae network includes nodes that communicate through a channel-based switched fabric (Infiniband\u00ae is a registered trademark of Infiniband Trade Association, located in Beaverton, Oreg.). For example, the nodes may be a host, an input\/output subsystem, or a router which connects to another network. The switched fabric is made of a collection of switches, routers, and links that connect a set of channel adapters. The channel adapters form an interface between the switched fabric and the nodes. The channel adapter of the host is referred to as a host channel adapter. The channel adapter of an I\/O subsystem is referred to as a target channel adapter.","In Infiniband\u00ae, two processes communicate using a queue pair. A queue pair includes a send queue and a receive queue. Specifically, in order for a process to send a message to another process, the process posts the message to the send queue. The host channel adapter sends the message in the form of packets to the channel adapter having the receive queue. Each packet that is sent may include a packet sequence number. Logic associated with the receive queue ensures that packets are processed in a particular order using the packet sequence number.","Infiniband\u00ae supports operations such as remote direct memory access (RDMA) read and write operation. Specifically, a requested process may send a request in the message for the receiver to store data and\/or return data. In response, the remote node's channel adapter includes functionality to store and\/or return the requested data to the requesting process.","In general, in one aspect, the invention relates to a method for temporary storage of data units on a communications adapter. The method includes receiving a first data unit to store in a hardware linked list queue on the communications adapter, reading a first index value from the first data unit, determining that the first index value does match an existing index value of a first linked list of the plurality of linked lists in the hardware linked list queue, and storing the first data unit in the hardware linked list queue as a member of the first linked list. The method further includes receiving a second data unit to store in the hardware linked list queue on the communications adapter, reading a second index value from the second data unit, determining that the second index value does not match any existing index value of any of the plurality of linked lists stored in the hardware linked list queue, allocating space in the hardware linked list queue for a second linked list to add the second linked list to the plurality of linked lists based on determining that the second index value does not match any existing index value, and storing the second data unit in the second linked list. The method further includes, for each transmission request on the hardware linked list queue, identifying a list identifier in the transmission request, identifying a head pointer of a requested linked list of the plurality of linked lists that matches the list identifier in the transmission request, obtaining, from the hardware linked list queue, a requested data unit referenced by the head pointer, and transmitting the requested data unit.","In general, in one aspect, the invention relates to a hardware linked list queue for temporary storage of data units on a communications adapter. The hardware linked list queue includes a data list component that includes a data memory comprising memory locations for storing a linked lists, wherein each linked list comprises at least one data unit. The data list component further includes a data list memory that includes a free list for storing a list of available memory locations in the data memory, and a data unit list that includes list entries, where each list entry corresponds to a memory location of the plurality of memory locations, and where each list entry stores an identifier of a next list entry in a same linked list. The data list component further includes a data list controller for storing a head pointer for each list of the plurality of linked lists, wherein the head pointer references a first list entry in the data unit list. The hardware linked list queue further includes a management unit operatively connected to the data list component and configured to receive an inbound data unit, and send the list identifier corresponding to the inbound data unit to the data list controller to associate the inbound data unit with the linked list corresponding to the inbound data unit. The data list component is configured, for each transmission request of a plurality of transmission requests, to identify a list identifier in the transmission request, identify the head pointer of a requested linked list of the plurality of linked lists that matches the list identifier in the transmission request, obtain, from the data memory, a requested data unit referenced by the head pointer, and transmit the requested data unit.","In general, in one aspect, the invention relates to a communications adapter that includes a producer module, a consumer module, and a current module interposed between the producer module and the consumer module. The current module is configured to receive, from the producer module, a first data unit to store in a hardware linked list queue on the communications adapter, read a first index value from the first data unit, determine that the first index value does match an existing index value of a first linked list of the plurality of linked lists having data units, and store the first data unit in the hardware linked list queue as a member of the first linked list. The current module further includes functionality to receive, from the producer module, a second data unit to store in the hardware linked list queue on the communications adapter, read a second index value from the second data unit, determine that the second index value does not match any existing index value of any of the plurality of linked lists stored in the hardware linked list queue, allocate space in the hardware linked list queue for a second linked list to add the second linked list to the plurality of linked lists based on determining that the second index value does not match any existing index value, and store the second data unit in the second linked list. The current module further includes functionality to, for each transmission request on the hardware linked list queue, identify a list identifier in the transmission request, identify a head pointer of a requested linked list of the plurality of linked lists that matches the list identifier in the transmission request, obtain, from the hardware linked list queue, a requested data unit referenced by the head pointer, and transmit, to the consumer module, the requested data unit.","Other aspects of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.","In the following detailed description of embodiments of the invention, numerous specific details are set forth in order to provide a more thorough understanding of the invention. However, it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in detail to avoid unnecessarily complicating the description.","In general, embodiments of the invention provide a method and apparatus for supporting multiple linked lists in a single hardware linked list queue on a communications adapter. Specifically, the hardware linked list queue corresponds to a hardware component that is configured to store multiple linked lists and individually manage the stored linked lists. For example, when a new data unit is received for the hardware linked list queue, the hardware linked list queue determines whether a linked list corresponding to the new data unit exists in the hardware linked list queue, adds a new linked list when the linked list does not exist, and stores the data unit in the hardware linked list queue. Further, in one or more embodiments of the invention, the hardware linked list queue includes functionality to individually manage each linked list. Specifically, data units in each linked list are processed in order of receipt. Additionally, data units in different linked list may be processed out of order of receipt.","In one or more embodiments of the invention, a communications adapter is a hardware device that is configured to connect a host to a network. For example, the communications adapter may correspond to a channel adapter for connecting a host or target system to an Infiniband\u00ae network. In such a scenario, the communications adapter may correspond to a host channel adapter or a target channel adapter. Other types of communications adapters may be used without departing from the invention.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIGS. 1A-1B","FIG. 1A"],"b":["100","100","1","102","2","102","102","100","1","102","2","102","102"],"i":["a","b","c","a","b","c"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1B","FIG. 1B"],"b":["104","104","1","106","2","106","106"],"i":["a","b","c"]},"In one or more embodiments of the invention, as shown in , the first entry of the linked list may not be optional while subsequent entries of the linked list are optional. Specifically, for a linked list to exist, the linked list may be required to have at least one entry in some embodiments of the invention. In alternative embodiments, the linked list is not required to have an entry. In one or more embodiments of the invention, entries in the linked list are ordered. The ordering of the entries may be, for example, a first in first out order. In other words, entries are removed from the linked list in the order that the entries were received in the linked list.","Returning to , in one or more embodiments of the invention, the number of linked lists and the size of each linked list dynamically adjusts in the hardware linked list queue. For example, at any particular moment in time, the hardware linked list queue () may have zero linked lists up to N linked lists, where N is the maximum number of entries in the hardware linked list queue. In the scenario in which the hardware linked list queue has N entries, each linked list has only a single entry. Further, in one or more embodiments of the invention, the hardware linked list queue () includes functionality to process data units in different linked lists out of order.","For example, consider the scenario in which the hardware linked list queue includes a first linked list and a second linked list. Further, consider the scenario in which the first data unit for the first linked list arrived before the first data unit for the second linked list. Because the first data unit for the first linked list arrived before the first data unit for the second linked list, the first linked list is allocated before the second linked list. Further, in the example, the first linked list and the second linked list each have two entries. The first entry of the first linked list requires additional time in processing, while the second entry of the first linked list is immediately ready. Both entries of the second linked list are immediately ready. In the example, the hardware linked list queue includes functionality to forward both entries of the second linked list immediately and in order with respect to each other even though the first entry of the first linked list is allocated prior to the first entry of the second linked list. Further, the hardware linked list queue includes functionality to hold the second entry of the first linked list because the first entry is not ready for forwarding.","Although  show linked lists as being allocated as consecutive entries in the hardware linked list queue, the entries allocated to a linked list may not be consecutive in one or more embodiments of the invention. In particular, entries of different linked lists may be intermixed without departing from the invention. Further, although  shows entries stored in order, entries may not be stored in order in the hardware linked list queue.","As discussed above, the hardware linked list queue provides a tool for processing commands on a host channel adapter in a host system in one or more embodiments of the invention.","As discussed above, the hardware linked list queue may be included in any type of communications adapter.  show schematic diagrams when the communications adapter is a host channel adapter in one or more embodiments of the invention.  shows a schematic diagram of a host system () in one or more embodiments of the invention. In one or more embodiments of the invention, the host system () is any physical computing device. Specifically, the host system () includes at least a minimum amount of hardware necessary to process instructions. As shown in , the host system () includes a host () and a host channel adapter () in one or more embodiments of the invention. These components are discussed below.","In one or more embodiments of the invention, the host () includes one or more guest virtual machines (e.g., virtual machine  (), virtual machine Y ()), a control virtual machine (), a hypervisor (), and a root complex (). Each of these components is discussed below.","Broadly speaking, the virtual machines (e.g., virtual machine  (), virtual machine Y (), control virtual machine ()) are distinct operating environments configured to inherit underlying functionality of the host operating system via an abstraction layer. In one or more embodiments of the invention, each virtual machine includes a separate instance of an operating system (e.g., OS  (), OS Y ()) (OS in ). The separate instances of the operating system may be the same type of operating system or different types of operating systems.","Specifically, the guest virtual machine operating system (e.g., OS  (), OS Y ()) operates as if the guest virtual machine operating system is the only operating system on the host () and the resources (e.g., processor cycles, memory, resources of the host channel adapter) allocated to the guest virtual machine are the only resources available on the host (). Thus, the guest virtual machine operating system (e.g., OS  (), OS Y ()) includes functionality to control the operating environment of applications executing in the guest virtual machine using resource allocated to the guest virtual machine Each virtual machine may be allocated disjoint or non-overlapping physical memory ().","Many different types of virtual machines exist. For example, the Xen\u00ae virtualization project allows for multiple guest operating systems executing in a host operating system. Xen\u00ae is a trademark overseen by the Xen Project Advisory Board. In one embodiment of the invention, the host operating system supports virtual execution environments (not shown). Another example is a Solaris\u2122 Container. In such cases, the Solaris\u2122 Container may execute in the host operating system, which may be a Solaris\u2122 operating system. Solaris\u2122 is a trademark of Oracle America, Inc. In one embodiment of the invention, the host operating system may include both virtual machines and virtual execution environments.","In one or more embodiments of the invention, the guest virtual machine includes a virtual host channel adapter device driver (e.g., vHCA driver  (), vHCA driver Y ()). The virtual host channel adapter device driver is software program that provides an interface to host channel adapter () for the guest virtual machine operating system. Specifically, when the guest virtual machine operating system wants to send commands to the host channel adapter (), the virtual machine operating system invokes a routine in the virtual host channel adapter device driver. In response, the virtual host channel adapter device driver issues commands to a virtualized device controller (not shown) presented by the hypervisor () (discussed below). In turn, the hypervisor () includes functionality to transmit the message to the host channel adapter ().","In addition to the guest virtual machine (e.g., virtual machine  (), virtual machine Y ()), the host () also includes a control virtual machine (). In one or more embodiments of the invention, the control virtual machine () has a separate address space and operating system environment than the guest virtual machine (e.g., virtual machine  (), virtual machine Y ()). The control virtual machine () includes a control virtual machine operating system (), a control virtual machine manager (), and a virtual machine host channel adapter device driver (). The virtual machine host channel adapter device driver () includes functionality similar to the guest virtual machine host channel adapter device drivers (e.g., vHCA driver  (), vHCA driver Y ()) discussed above. The host virtual machine operating system () includes functionality to provide an operating environment for software executing in the control virtual machine ().","In one or more embodiments of the invention, the software executing in the control virtual machine () includes a virtual machine manager () (discussed below). In one or more embodiments of the invention, the virtual machine manager () includes functionality to configure the hypervisor (), configure the host channel adapter (), create, remove, and configure guest virtual machines, and perform the management of the host (). With regards to configuring the host channel adapter, the virtual machine manager includes functionality to send commands to the host channel adapter to adjust the number of resources allocated to each virtual machine To receive parameter values for performing the above management tasks, the virtual machine manager () may include a user interface and\/or an application programming interface for communicating with a computer administrator or another program in one or more embodiments of the invention.","Continuing with , the hypervisor () includes functionality to control the sharing of hardware resources on the host (). Specifically, the hypervisor () includes functionality to virtualize the physical devices of the host () so that more than one operating system may share the same physical device transparently in accordance with one or more embodiments of the invention. Further, the hypervisor () controls when the guest virtual machine (e.g., virtual machine  (), virtual machine Y ()) and the control virtual machine () are allowed to execute. For example, the hypervisor () may be a thin-privileged layer of software that only manages which guest virtual machine or the host virtual machine () is executing.","Continuing with the host, the host () includes hardware (). The hardware () may include, for example, a central processing unit (), memory (), and a root complex (). In one or more embodiments of the invention, the CPU () is a hardware processor component for processing instructions of the host. The CPU () may include multiple hardware processors. Alternatively or additionally, each hardware processor may include multiple processing cores in one or more embodiments of the invention. In general, the CPU () is any device configured to execute instructions on the host ().","In one or more embodiments of the invention, the memory () is any type of hardware device for storage of data. In one or more embodiments of the invention, the memory () may be partitioned on a per-virtual machine basis, such that each virtual machine (e.g., control virtual machine (), virtual machine  (), virtual machine Y ()) is allocated separate and distinct memory. In one or more embodiments of the invention, the memory () includes functionality to store a send queue (not shown).","A separate send queue may be stored in memory for each virtual machine Alternatively or additionally, multiple virtual machines may share one or more send queues. In one or more embodiments of the invention, a send queue includes functionality to store an ordered list of command identifiers for commands for processing by the host channel adapter (). In one or more embodiments of the invention, the command identifiers may be the actual commands and\/or references to the commands.","In one or more embodiments of the invention, the root complex () includes functionality to connect the CPU and memory subsystem to a peripheral component interconnect (PCI) Express switch fabric. Specifically, in one or more embodiments of the invention, the root complex () connects the host () to the host channel adapter (). Although  shows the root complex () as separate from the CPU (), the root complex () may be integrated as part of the CPU.","The root complex () includes an input\/output memory management unit (IOMMU) () in one or more embodiments of the invention. The IOMMU () includes functionality to connect a direct memory access (DMA) input\/output (I\/O) bus to the memory. In one or more embodiments of the invention, the IOMMU () includes functionality to translate device virtual addresses to physical addresses of memory on the host ().","Continuing with , the host () is connected to the host channel adapter (). In one or more embodiments of the invention, the connection between the host () and the host channel adapter () may be a PCI express connection. Specifically, the host channel adapter may connect to a PCI express fabric connector on the host.","In one or more embodiments of the invention, the host channel adapter () is a hardware device configured to connect the host () to the Infiniband\u00ae network (). Specifically, the host channel adapter () includes functionality to receive commands from the host () and process the commands. Processing the commands may include performing DMA with host memory to obtain and store packet data and to obtain control information, performing any validation required on the packet data, generating packets from the packet data, and sending and receiving packets on the Infiniband\u00ae network ().  shows a schematic diagram of the host channel adapter () from the prospective of the host (). As shown in , the host channel adapter () includes at least one Infiniband\u00ae port (e g., Infiniband\u00ae port  (), Infiniband\u00ae port  ()), a resource pool (), and an embedded processor subsystem (). Each of the components of the host channel adapter is discussed below.","In one or more embodiments of the invention, an Infiniband\u00ae port (e.g., Infiniband\u00ae port  (), Infiniband\u00ae port  ()) is a physical interface connector between the host channel adapter () and the Infiniband\u00ae network (). Although  shows two Infiniband\u00ae ports, more or fewer ports may exist without departing from the invention.","The resource pool () is a collection of resources that are required to send and receive packets on the Infiniband\u00ae network. Specifically, the resource pool () corresponds to the collection of hardware and stored data that is shared by the virtual machines (e.g., control virtual machine (), virtual machine  (), virtual machine Y ()). The resource pool () is discussed in  below.","In one or more embodiments of the invention, the sharing of the resource pool is performed using the concepts of physical function and virtual functions. A physical function () exposes the actual hardware of the host channel adapter () to an operating system. Specifically, by way of the physical function, the control virtual machine operating system () may control the host channel adapter. Thus, the physical function allows the control virtual machine () to control the host channel adapter (), such as to disable the host channel adapter ().","A virtual function (e.g., virtual function  (), virtual function Y ()) exposes a virtualized host channel adapter to a virtual machine Specifically, the virtual function (e.g., virtual function  (), virtual function Y ()) exposes to the virtual machine operating system only the partition of the resource pool allocated to the virtual machine To the guest virtual machine (e.g., virtual machine  (), virtual machine Y ()), the resources exposed by the virtual function (e.g., virtual function  (), virtual function Y ()) appear as if the resource are the only resources on the host channel adapter (). Thus, the virtual function (e.g., virtual function  (), virtual function Y ()) allows the virtual machine operating system (e.g., OS  (), OS Y ()) to control the portion of resources allocated to the virtual machine In other words, a virtual function (e.g., virtual function  (), virtual function Y ()) provides the virtual machine operating system (e.g., OS  (), OS Y ()) the appearance that the virtual machine operating system (e.g., OS  (), OS Y ()) is controlling the host channel adapter () as a whole even though the actions of the virtual machine operating system (e.g., OS  (), OS Y ()) does not affect any other virtual function (e.g., virtual function  (), virtual function Y ()).","In one or more embodiments of the invention, the term, underlying function (UF), is used to generically refer to either a physical function or a virtual function. Specifically, as used herein, an underlying function may be a physical function or a virtual function.","The embedded processor subsystem () corresponds to an embedded processor and logic for managing the host channel adapter (). The embedded processor subsystem includes a service processor resource manager () and a send queue scheduler (). The service processor resource manager () includes functionality to receive and process the management commands on the host channels adapter. For example, the management commands may be to change the allocation of host channel adapter resources, change the configuration of the host channel adapter, and perform other management of the host channel adapter. With regards to resource allocation, the service processor resource manager includes functionality to change the allocation of the host channel adapter resources to underlying functions and change the allocation of the host channel adapter resources to QoS levels within the underlying functions.","Continuing with , the send queue scheduler () includes functionality to schedule commands identified in the send queue on the host channel adapter. Specifically, the send queue scheduler includes functionality to iterate through the send queue and store commands identified in the send queue on the host channel adapter ().","As discussed above,  provides a general diagram of the host channel adapter () in one or more embodiments of the invention.  shows a schematic diagram of the resource pool of the host channel adapter () in one or more embodiments of the invention. As shown in , the host channel adapter () includes a collect buffer unit module (), a virtual kick module (), a queue pair fetch module (), a direct memory access (DMA) module (), an Infiniband\u00ae packet builder module (), one or more Infiniband\u00ae ports (), a completion module (), an Infiniband\u00ae packet receiver module (), a receive module (), a descriptor fetch module (), a receive queue entry handler module (), and a DMA validation module (). In one or more embodiments of the invention, each module may correspond to hardware and\/or firmware. The dark arrows between modules show the transmission path of data units between modules as part of processing commands in one or more embodiments of the invention. Data units may have other transmission paths (not shown) without departing from the invention. Further, other communication channels and\/or additional components of the host channel adapter () may exist without departing from the invention. Each of the components of the host channel adapter () is discussed below.","The collect buffer controller module () includes functionality to receive command data from the host and store the command data on the host channel adapter. The collect buffer controller module () is discussed below and in .","In one or more embodiments of the invention, the virtual kick module () includes functionality to load balance commands received from different underlying functions. Specifically, as discussed below with reference to , each command is assigned to a transmit virtual lane (TVL). Each transmit virtual lane (TVL) is allocated a number of execution credits and a number of completion credits in one or more embodiments of the invention. When a transmit virtual lane (TVL) has an execution credit and a completion credit available, a command assigned to the transmit virtual lane is ready for processing on the non-blocking pipeline (). In one or more embodiments of the invention, the virtual kick module () includes a virtual kick hardware linked list queue (not shown) and an arbitrator (not shown). Each entry in the virtual hardware linked list queue is configured to store a data unit corresponding to the command. Specifically, in one or more embodiments of the invention, the data unit may include the command or an identifier of a physical collect buffer (PCB) (discussed below) that stores the command.","In one or more embodiments of the invention, the arbitrator is configured to process data units from the hardware linked list queue. Specifically, in one or more embodiments of the invention, the arbitrator is configured to determine whether the TVL to which the data unit is assigned has an execution credit and a completion credit available, and mark the data unit as ready when an execution credit and a completion credit are available.","Continuing with , the queue pair fetch module () includes functionality to obtain queue pair status information for the queue pair corresponding to the data unit. Specifically, a data unit may correspond to a command to send a message on the Infiniband\u00ae network. Per the Infiniband\u00ae protocol, the message has a corresponding send queue and a receive queue. The send queue and receive queue form a queue pair. Accordingly, the queue pair corresponding to the message is the queue pair corresponding to the data unit in one or more embodiments of the invention.","In one or more embodiments of the invention, the queue pair fetch module () includes a queue pair fetch hardware linked list queue (not shown), a queue pair state cache (not shown), and a queue pair fetch data unit processor (not shown). The queue pair fetch hardware linked list queue includes functionality to store data units until the queue pair state corresponding to the data unit is obtained and store data units waiting for transmission to a next module in one or more embodiments of the invention.","In one or more embodiments of the invention, the queue pair state cache corresponds to a cache for storing queue pair state entries corresponding to a portion of the queue pairs. Each queue pair state entry includes the queue pair state for a particular queue pair. In one or more embodiments of the invention, memory on the host () may store queue pair state entries for all queue pairs. The queue pair state information may include, for example, sequence number, address of remote receive queue\/send queue, whether the queue pair is allowed to send or allowed to receive, and other state information.","In one or more embodiments of the invention, the queue pair fetch data unit processor includes functionality to determine whether the queue pair state entry corresponding to a data unit is in the queue pair state cache and obtain the queue pair state entry corresponding to the data unit from the queue pair state cache. Further, in one or more embodiments of the invention, the queue pair fetch data unit processor may further include functionality to perform DMA with host memory to obtain the queue pair state entry for the data unit from the host memory when the queue pair state entry is not in the queue pair state cache.","In one or more embodiments of the invention, the DMA module () includes functionality to perform DMA with host memory. In one or more embodiments of the invention, the DMA module includes a DMA data unit processor (not shown), DMA memory, and a DMA hardware linked list queue (not shown). The DMA data unit processor may include functionality to determine whether a command in a data unit or referenced by a data unit identifies a location in host memory that includes packet data. The DMA data unit processor may further include functionality to validate that the process sending the command has necessary permissions to access the location, and to obtain the packet data from the host memory, and store the packet data in the DMA memory. Specifically, the DMA memory corresponds to a storage unit for storing packet data obtained using DMA.","The DMA hardware linked list queue includes functionality to store entries and associate each entry with a linked list. Each entry in the DMA hardware linked list queue includes functionality to store a data unit waiting for a DMA or waiting for transmission to a next module. For example, when two commands are assigned to the same queue pair, then the packet data in the commands or referenced by the commands are processed in order of the issuance of the command to the host channel adapter (). Thus, if the data unit corresponding to the first command issued to the host channel requires a DMA to obtain packet data while the data unit corresponding to the second command issued to the host channel does not require a DMA, then the data unit corresponding to the first command and the data unit corresponding to the second command may be stored in the DMA hardware linked list queue until, at least, the packet data for the first command is received.","Continuing with , in one or more embodiments of the invention, the DMA module () is connected to an Infiniband\u00ae packet builder module (). In one or more embodiments of the invention, the Infiniband\u00ae packet builder module () includes an Infiniband\u00ae packet builder data unit processor (not shown) and an Infiniband\u00ae packet builder hardware linked list queue (not shown). Each entry in the Infiniband\u00ae packet builder hardware linked list queue includes functionality to store a data unit corresponding to a command waiting to have packets generated or waiting for transmission to a next module.","In one or more embodiments of the invention, the Infiniband\u00ae packet builder data unit processor includes functionality to generate one or more packets for each data unit in the Infiniband\u00ae packet builder hardware linked list queue, and to initiate transmission of the one or more packets on the Infiniband\u00ae network () via the Infiniband\u00ae port(s) ().","In one or more embodiments of the invention, the Infiniband\u00ae packet builder data unit processor may include functionality to obtain the packet data from a PCB corresponding to the data unit, from the DMA memory, and from an embedded processor subsystem memory. In one or more embodiments of the invention, the Infiniband\u00ae packet builder data unit processor may include functionality to obtain header information for the packet(s) from the data unit.","Continuing with , in one or more embodiments of the invention, the completion module () includes functionality to manage packets for queue pairs set in reliable transmission mode. Specifically, in one or more embodiments of the invention, when a queue pair is in a reliable transmission mode, then the receiving channel adapter of a new packet responds to the new packet with an acknowledgement message indicating that transmission completed or an error message indicating that transmission failed. The completion module () includes functionality to manage data units corresponding to packets until an acknowledgement is received or transmission is deemed to have failed (e.g., by a timeout).","In one or more embodiments of the invention, the completion module () includes a completion hardware linked list queue (not shown) and a completion data unit processor (not shown). Each entry in the completion hardware linked list queue includes functionality to store a data unit corresponding to packet(s) waiting for an acknowledgement or a failed transmission or waiting for transmission to a next module. In one or more embodiments of the invention, the completion data unit processor includes functionality to determine when an acknowledgement message is received, an error message is received, or a transmission times out. Transmission may time out, for example, when a maximum transmission time elapses since sending a message and an acknowledgement message or an error message has not been received. The completion data unit processor further includes functionality to update the corresponding modules (e.g., the DMA module and the collect buffer module to retransmit the message or to free resources allocated to the command).","Continuing with , in one or more embodiments of the invention, the Infiniband\u00ae packet receiver module () includes functionality to receive packets from the Infiniband\u00ae port(s) (). In one or more embodiments of the invention, the Infiniband\u00ae packet receiver module () includes functionality to perform a checksum to verify that the packet is correct, parse the headers of the received packets, and place the payload of the packet in memory. In one or more embodiments of the invention, the Infiniband\u00ae packet receiver module () includes functionality to obtain the queue pair state for each packet from a queue pair state cache. In one or more embodiments of the invention, the Infiniband\u00ae packet receiver module includes functionality to transmit a data unit for each packet to the receive module () for further processing.","In one or more embodiments of the invention, the receive module () includes functionality to validate the queue pair state obtained for the packet. In one or more embodiments of the invention, the receive module () includes a queue pair fetch hardware linked list queue (not shown) and a receive module data unit processor (not shown). Each entry in queue pair fetch hardware linked list queue includes functionality to store a data unit waiting for verifying the queue pair state information or waiting for transmission to a next module. The receive module data unit processor includes functionality to determine whether the packet should be accepted for processing. In one or more embodiments of the invention, if the packet corresponds to an acknowledgement or an error message for a packet sent by the host channel adapter (), the receive module data unit processor includes functionality to update the completion module ().","Additionally or alternatively, in one or more embodiments of the invention, the receive module () may include a receive module hardware linked list queue (not shown) and a buffer data unit processor (not shown). In one or more embodiments of the invention, the receive module hardware linked list queue includes functionality to store data units waiting for one or more reference to buffer location(s) or waiting for transmission to a next module. Specifically, when a process in a virtual machine is waiting for data associated with a queue pair, the process may create receive queue entries that reference one or more buffer locations in host memory in one or more embodiments of the invention. For each data unit in the receive module hardware linked list queue, the buffer data unit processor includes functionality to identify the receive queue entries from a host channel adapter cache or from host memory, and associate the identifiers of the receive queue entries with the data unit.","In one or more embodiments of the invention, the descriptor fetch module () includes functionality to obtain descriptors for processing a data unit. For example, the descriptor fetch module may include functionality to obtain descriptors for a receive queue, a shared receive queue, a ring buffer, and the completion queue.","In one or more embodiments of the invention, the receive queue entry handler module () includes functionality to obtain the contents of the receive queue entries. In one or more embodiments of the invention, the receive queue entry handler module () includes a receive queue entry hardware linked list queue (not shown) and a receive queue entry processor (not shown). Each entry in the receive queue entry hardware linked list queue includes functionality to store a data unit waiting for the buffer references in the corresponding receive queue or waiting for transmission to a next module. In one or more embodiments of the invention, the receive queue entry processor includes functionality to identify the location of the receive queue entry corresponding to the data unit and obtain the buffer references in the receive queue entry. In one or more embodiments of the invention, the receive queue entry may be located on a cache of the host channel adapter () or in host memory.","In one or more embodiments of the invention, the DMA validation module () includes functionality to perform DMA validation and initiate DMA with host memory. In one or more embodiments of the invention, the DMA validation module () includes a DMA validation hardware linked list queue (not shown) and a DMA validation data unit processor (not shown). Each entry in the DMA validation hardware linked list queue includes functionality to store a data unit waiting for DMA or waiting for transmission to a next module. The DMA validation processor includes functionality to confirm that the remote process that sent the packet has permission to write to the buffer(s) referenced by the buffer references, and confirm that the address and the size of the buffer(s) match the address and size of the memory region referenced in the packet. Further, in one or more embodiments of the invention, the DMA validation module () includes functionality to initiate DMA with host memory when the DMA is validated.","As shown in , each module receives data units from at least one other component and sends data units to at least one other component. The component from which a particular module receives data units is referred to as a producer in one or more embodiments of the invention. The component to which the particular module sends data units is referred to as a consumer in one or more embodiments of the invention. For example, with respect to the virtual kick module (), the producer is the collect buffer unit module () and the consumer is the queue pair fetch module (). With respect to the queue pair fetch module (), the producer is the virtual kick module () and the consumer is the DMA module (). With respect to the Infiniband\u00ae packet receiver module (), the producer is the Infiniband\u00ae ports () and the consumer is the receive module (). Thus, each module has at least one consumer and at least one producer in one or more embodiments of the invention.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 4","FIG. 4","FIG. 4"]},"In general, the resource pool is configured to receive and execute commands from a virtual machine A command corresponds to an instruction to the host channel adapter. For example, a command may be an instruction to send a message on the Infiniband\u00ae network (not shown). A command includes command data in one or more embodiments of the invention. Specifically, command data corresponds to individual portions of the command.","When the command is an instruction to send a message on the Infiniband\u00ae network, the command may include the message itself or one or more addresses in the host memory having the message. The host channel adapter is configured to obtain the command, obtain the message from the command or from host memory referenced in the command, partition the message into packets if required, and send the packets on the Infiniband\u00ae network in accordance with an Infiniband\u00ae protocol. In one or more embodiments of the invention, the message is packet data. Specifically, packet data is data sent in the packets on the Infiniband\u00ae network. Thus, the packet data may be in the command or in the one or more addresses in host memory.","As shown in , the resource pool and the management components of the host channel adapter includes a non-blocking pipeline (), a virtual kick arbitrator (), transmit virtual lane (TVL) virtual kick hardware linked list queue (), a mapping table (), physical collect buffer (PCB) pool (), dedicated PCBs (), a PCB allocator (e.g., PCB Allocator(), PCB Allocator()), virtual collect buffers (VCBs) (e.g., VCB (), VCB N(), VCB (), VCB T()), and underlying function CSRs (e.g., underlying functionCSR(), underlying functionCSR()). Each of these components is discussed below.","The non-blocking pipeline () corresponds to a set of hardware and firmware that includes functionality to process commands on the host channel adapter. Specifically, the non-blocking pipeline () includes functionality to obtain a command from a PCB (described below), obtain packet data based on the command data, verify the queue pair for sending the packet data, generate one or more packets having the packet data, and sending the packets on the Infiniband\u00ae network in accordance with the Infiniband\u00ae protocol. In one or more embodiments of the invention, the non-blocking pipeline () is partitioned into modules (not shown). Each module corresponds to hardware and\/or firmware that includes functionality to perform a portion of the nonblocking pipeline. For example, one module may be configured to perform DMA with the host memory while another module may be configured to generate packets having the packet data.","In one or more embodiments of the invention, one of the modules includes a completion module. A completion module includes functionality to store messages in a completion linked list queue until an acknowledgement is received or transmission is deemed to have failed, such as by not receiving an acknowlegement within a predefined period of time. In one or more embodiments of the invention, the completion module is used when a queue pair is set in reliable transmission mode.","In one or more embodiments of the invention, the non-blocking pipeline is time shared amongst TVLs. In particular, a TVL is a time slice of the non-blocking pipeline. In other words, commands assigned to a TVL may be blocked by the execution through the pipeline of one or more other commands in the same TVL. In contrast to commands assigned to the same TVL, when a command is assigned to a different TVL, the command is not blocked by other commands in different TVLs.","In one or more embodiments of the invention, each TVL is associated with a virtual kick hardware linked list queue (). A virtual kick hardware linked list queue () corresponds to a storage location for storing command identifiers of commands for which a kick has issued. A kick indicates that the command is ready for execution on the non-blocking pipeline (). Specifically, in one or more embodiments of the invention, the kick indicates that the entirety of the command is stored on the host channel adapter. In one or more embodiments of the invention, the virtual kick hardware linked list queue includes functionality to store multiple linked lists. Each linked list in the virtual kick hardware linked list queue corresponds to a separate TVL. In one or more embodiments of the invention, commands are processed from each linked list in a first in first out (FIFO) order. In other words, the commands are processed in an order in which the commands are received to the linked list.","In one or more embodiments of the invention, the command identifier of the command may be the command, an address of a memory location having the command, or any other data that identifies the command. For example, the command identifier may be an address or identifier of the PCB (discussed below) having the command.","In one or more embodiments of the invention, a virtual kick arbitrator () is operatively interposed between the virtual kick hardware linked list queue () and the non-blocking pipeline () in one or more embodiments of the invention. In one or more embodiments of the invention, the virtual kick arbitrator includes functionality to arbitrate between TVLs having commands initiating execution on the pipeline. Specifically, the virtual kick arbitrator includes functionality to select a TVL and initiate execution of the command from the linked list corresponding to the selected TVL in the virtual kick hardware linked list queue.","Continuing with , the host channel adapter includes PCBs (e.g., dedicated PCBs (), PCB  (), PCB Z ()). A PCB is physical memory that is configured to store a single command. Further, each command requires a single PCB in one or more embodiments of the invention.","Dedicated PCBs correspond to PCBs that are dedicated for use by administrator and management components in one or more embodiments of the invention. For example, dedicated PCBs may be used by the service processor resource manager, the send queue scheduler, a host process for controlling the host channel adapter, and for other such components of the system.","In one or more embodiments of the invention, the host channel adapter includes a PCB pool (). A PCB pool () corresponds to a collection of PCBs (e.g., PCB  (), PCB Z ()) that are available for use by any underlying function. Specifically, each PCB (e.g., PCB  (), PCB Z ()) in the PCB pool () may used by any underlying function in one or more embodiments of the invention. When a PCB is in use by an underlying function (e.g., Underlying Function(), Underlying Function()) to store a command, the PCB is considered bound to the underlying function and cannot be used by another underlying function.","Continuing with , a TVL mapping table is operatively interposed between the PCBs (e.g., dedicated PCBs (), PCB  (), PCB Z ()) and the virtual kick hardware linked list queue () in one or more embodiments of the invention. The TVL mapping table () includes a mapping of the underlying function (e.g., Underlying Function(), Underlying Function()) to one or more TVLs. In particular, the mapping defines, for each underlying function, which TVLs correspond to the underlying function. Specifically, each underlying function may be allocated a set of TVLs. In one or more embodiments of the invention, the mapping of set of TVLs may be storage of an identifier of the underlying function with an identifier of the virtual kick lists corresponding to the TVLs in the set of TVLs.","Additionally, in one or more embodiments of the invention, a set of TVLs may be allocated to the dedicated PCBs (). Thus, the TVL mapping table () may further include a mapping of the dedicated PCBs to the set of TVLs allocated to the dedicated PCBs.","Continuing with , the PCB pool () is connected to one or more PCB allocators. A PCB allocator is logic, such as hardware or firmware, configured to select the PCB from the PCB pool () for storing a command. Although  shows multiple PCB allocators, a single PCB allocator may exist for all underlying functions. Alternatively or additionally, a separate PCB allocator may exist for each PCB. The PCB allocator is discussed in further detail below and in .","In one or more embodiments of the invention, the PCB allocator further includes functionality to bind the PCB to a VCB (VCB) (e.g., VCB (), VCB N(), VCB (), VCB T()). In one or more embodiments of the invention, a VCB is a virtual address space used by a process on the host to write to a PCB. Specifically, a single VCB is capable of being bound to only a single PCB at any single moment in time in one or more embodiments of the invention. Thus, the binding a PCB to a VCB creates an association between the VCB and the PCB. In other words, the binding prevents the PCB from being used by any other VCB and prevents the VCB from being associated with any other PCB.","In one or more embodiments of the invention, an underlying function CSR (e.g., CSR(), CSR()) stores status and control information about the VCBs allocated to the underlying function. Specifically, each underlying function is allocated a set of VCBs from a VCB pool (discussed below and in FIG. ). The number of VCBs allocated to an underlying function represents a guarantee of the number of commands that the HCA will process for the virtual machine corresponding to the underlying function. In one or more embodiments of the invention, the number of VCBs allocated to an underlying function may exceed the number of PCBs allocated to the underlying function. The flowcharts of , discussed below, provide a method for processing requests when the underlying function has a VCB available and no PCBs available.","Continuing with , in one or more embodiments of the invention, the underlying function CSR (e.g., CSR(), CSR()) may include a base address register (BAR). The BAR stores the lowest virtual address assigned to the underlying function in one or more embodiments of the invention. The underlying function CSR may further store information about which VCBs are in use in one or more embodiments of the invention.","As discussed above with reference to , and as shown by way of an example hardware linked list queue in , various modules of the host channel adapter may each include a hardware linked list queue.  shows a schematic diagram of a module () that includes a hardware linked list queue in one or more embodiments of the invention. Specifically, any of the modules that include a hardware linked list queue may correspond to the module () shown in . Solid dark lines in  correspond to transmission paths of instructions, data units, commands, and messages in one or more embodiments of the invention. Other communication paths (not shown) may alternatively or additionally exist without departing from the invention.","As shown in , each module () is operatively connected to at least one producer () and at least one consumer (). The producer () as related to the module () is configured to send data unit and\/or packets to the module (). The consumer () as related to the module is configured to receive data units and\/or packets from the module (). Further, as shown in , the module () includes a hardware linked list queue () and a queue control structure () in one or more embodiments of the invention. Both of these components are discussed below.","In one or more embodiments of the invention, the hardware linked list queue () includes hardware and firmware for storing and individually managing multiple linked lists. For example, the hardware linked list queue () may correspond to the queue pair fetch hardware linked list queue, the DMA hardware linked list queue, the Infiniband\u00ae packet builder hardware linked list queue, the completion hardware linked list queue, the buffer hardware linked list queue, the receive queue entry hardware linked list queue, the DMA validation hardware linked list queue, or any other hardware linked list queue. In one or more embodiments of the invention, the hardware linked list queue includes a data list component (), a management component (), an inbound credit storage (), a list identifier to index memory (), an index to list identifier memory (), a data unit ready component (), and a list ready component (). Each of these components is discussed below.","The data list component () includes functionality to store and track the storage of data units in the hardware linked list queue (). In one or more embodiments of the invention, the data list component () includes data memory (), a data list memory (), and a data list controller ().","The data memory () corresponds to a hardware memory device that includes functionality to store data units. For example, a hardware memory device may correspond to random access memory (RAM). When stored in the hardware linked list queue (), the data units are located in the data memory (). In one or more embodiments of the invention, the data memory () is partitioned into entries. Each entry includes functionality to store a data unit. Further, in one or more embodiments of the invention, each entry is associated with a corresponding unique identifier for the entry. The unique identifier uniquely identifies the entry with respect to other entries in the data memory () in one or more embodiments of the invention. For example, the unique identifier may be a consecutive number, an address of the entry, or any other type of identifier.","In one or more embodiments of the invention, the linked list memory () corresponds to a hardware memory device for storing data for tracking linked lists. In one or more embodiments of the invention, the linked list memory () includes functionality to store a free list (), a data unit list (), and a scrubber ().","The free list () corresponds to a list of entries in the data memory () that are available. Specifically, in one or more embodiments of the invention, data memory entries that are identified the free list () are available to be allocated to linked lists. In one or more embodiments of the invention, the free list may be maintained as a bit string whereby a single bit exists for each entry in the data memory (). Specifically, each entry in the data memory () has a corresponding unique bit in the bit string. When the corresponding bit is set, then the entry is unavailable. When the corresponding bit is not set, then the entry is available.","The data unit list () maintains a listing of which entries of the data memory () are in each linked list and the order of entries in each linked list. In one or more embodiments of the invention, the data unit list () includes a data unit list entry for each entry in the data memory (). Specifically, a separate and unique data unit list entry exists for each entry in the data memory (). In one or more embodiments of the invention, when the entry in the data memory () is used by a linked list, the data unit list entry corresponding to the entry in the data memory () stores the unique identifier of the next entry allocated to the linked list. For example, consider the scenario in which the linked list includes data unit W located at entry , followed by data unit X located at entry , followed by data unit Y located at entry , followed by data unit Z located at entry . In the example, the data unit list entry corresponding to entry  stores the unique identify of entry , the data unit list entry corresponding to entry  stores the unique identify of entry , and the data unit list entry corresponding to entry  stores the unique identify of entry . The data unit list entry corresponding to the last entry in the linked list is associated with or stores a value indicating that the data unit list entry corresponds to the last entry. For example, a separate reference may exist to indicate that the data unit list entry is the last entry. Alternatively or additionally, the data unit list entry may store a value indicating that the entry is the last entry.","In one or more embodiments of the invention, the scrubber () includes functionality to detect bit errors in the data memory (). In one or more embodiments of the invention, the scrubber () may include to correct the bit errors in the data memory ().","Continuing with the data list component (), the linked list memory () is operatively connected to the data list controller (). In one or more embodiments of the invention, the data list controller () corresponds to hardware and\/or firmware logic that includes functionality to maintain the data list memory () and provide information to the management component () (discussed below). Specifically, the data list controller () includes functionality to update the data list memory () when changes are made to the data memory (). Further, the data list controller () includes functionality to return an identifier of an available entry in the data memory () and the next entry of a linked list stored in the data memory (). In one or more embodiments of the invention, the data list controller () includes functionality to store, for each linked list in the data memory (), a head pointer referencing the first entry in the linked list. Additionally or alternatively, in one or more embodiments of the invention, the data list controller () includes functionality to store, for each linked list in the data memory (), a tail pointer referencing the last entry in the linked list.","In one or more embodiments of the invention, the data list controller () further includes functionality to store a data unit counter (not shown) for each linked list. In one or more embodiments of the invention, the data unit counter is the total entries allocated to the linked list and\/or available to be allocated to the linked list. For example, consider the scenario in which a linked list has a maximum allocated allowance of ten entries and has three entries used. In the example, the data unit counter may store the value of ten as the maximum allocated allowance, the value of three as the number of entries in the linked list, and\/or the value of seven as the number of remaining entries that may be used by the linked list. Alternatively, the data unit counter may not store any value associated with the maximum allocated allowance.","In one or more embodiments of the invention, the inbound credit storage () stores the inbound credit number (). The inbound credit number () is the number entries available in the free list. In other words, the inbound credit number () is the number of data units that may be added to the data memory (). In one or more embodiments of the invention, when a data unit is added to the data memory () (e.g., an inbound data unit and index number () is received from the producer ()), the inbound credit number is decremented in the inbound credit storage (). When a data unit is removed from the data memory () (e.g., an outbound data unit and index number () is transmitted to the consumer ()), the inbound credit number is incremented in the inbound credit storage (). In one or more embodiments of the invention, the producer () includes functionality to read the inbound credit number () from the inbound credit storage (). To the producer (), the inbound credit number () may be referred to as an outbound credit number (discussed below).","Continuing with the hardware linked list queue () in , the list identifier to index memory () corresponds to a hardware storage device for associating a list identifier of a linked list in data memory () with an index value. Specifically, in one or more embodiments of the invention, the index value is a value provided in the data unit that associates the data unit with a linked list. For example, the index value may be a queue pair identifier, a TVL identifier, or another identifier. The list identifier of the linked list is an identifier used by the module () to reference the linked list. For example, the list identifier of the linked list may be a unique identifier of the location of the head pointer for the linked list, a number in a series of consecutive numbers where each number is an identifier of a linked list, or another identifier used by the module. In one or more embodiments of the invention, the list to index memory may correspond to RAM, content addressable memory (CAM) structure, or another type of memory.","In one or more embodiments of the invention, the index to list identifier memory () corresponds to a hardware storage device for associating each linked list in the data memory () with the corresponding linked list. In one or more embodiments of the invention, the index to list memory () may correspond to RAM, a CAM structure, or another type of memory.","In one or more embodiments of the invention, the list to index memory (), the index to list memory (), inbound credit storage (), and data list component () are operatively connected to a management component (). The management component () includes functionality to store data units in the data memory (), manage the contents of the list to index memory () and index to list memory (), and update the inbound credit storage (). In one or more embodiments of the invention, the management component further includes functionality to determine whether a linked list corresponding to an inbound data unit () is allocated in the data memory () and allocate a new linked list when the linked list is not allocated. Further, the management component () includes functionality to identify the linked list corresponding to the inbound data unit () and add the inbound data unit () to the linked list in the data memory (). In one or more embodiments of the invention, the management component () further includes functionality to update the queue control structure () (discussed below) with the unique identifier of the entry () used to store the inbound data unit () and with an error message () for any errors on the hardware linked list queue (). In one or more embodiments of the invention, the management component () includes functionality to transmit a command identifier () of the command in the data unit to the arbitrator () (discussed below).","Continuing with the hardware linked list queue (), in one or more embodiments of the invention, the data unit ready component () corresponds to memory and logic configured to identify when data units in entries of the data memory are ready for forwarding to the consumer (). A data unit is ready for forwarding to the consumer () when additional processing by the module () on the data unit is not required. Conversely, a data unit is not ready for forwarding to the consumer () when initial or additional processing of the data unit by the data unit processor () is required. For example, the data unit may be ready immediately upon receipt by the module () when no processing is required on the data unit. As another example, the data unit may be ready after the data unit processor () (discuss below) completes processing of the data unit. In one or more embodiments of the invention, the data unit ready component stores a bit string. Each entry in the bit string corresponds to a separate and unique entry in the data memory (). The entry in the bit string is set when the data unit in the corresponding entry in the data memory () is ready. The entry in the bit string is not set when the data unit in the corresponding entry in the data memory is not ready or when the corresponding entry in the data memory does not contain a data unit.","In one or more embodiments of the invention, the list ready component () corresponds to memory and logic configured to identify when the first entry of each linked list is ready for transmission to the consumer (). Specifically, in one or more embodiments of the invention, the list ready component () includes functionality to determine, for each linked list, whether the entry referenced by the head pointer of the linked list has the corresponding ready bit set. In one or more embodiments of the invention, the list ready component () maintains a data structure that associates each linked list with a list ready bit. If the first entry of the linked list has the ready bit set, then the list ready bit is set in the data structure maintained by the list ready component (). By having the list ready component that includes a bit for each linked list, linked lists may be individual managed. Specifically, when the first data unit in a linked list is ready for transmission to the consumer, the first data unit may be sent to the consumer even when the oldest data unit in the linked list queue that is in a different linked list is not ready for transmission. Thus, as shown in the example, the individual management allows for data units to be transmitted without having to wait for processing to complete on data units in other linked lists.","Continuing with the module (), the queue control structure () corresponds to logic and memory for controlling the hardware linked list queue (). In one or more embodiments of the invention, the queue control structure () includes a data unit processor () and an arbitrator (). The data unit processor () corresponds to logic for performing the functionality of the module (). For example, the data unit processor may correspond to the queue pair fetch data unit processor, the DMA data unit processor, the Infiniband\u00ae packet builder data unit processor, the completion data unit processor, the buffer data unit processor, the receive queue entry data unit processor, the DMA validation data unit processor, or any other data unit processor.","In one or more embodiments of the invention, the data unit processor () is configured to process each data unit in the hardware linked list queue requiring processing. For example, if the module () is a DMA module, the data unit processor includes functionality to process all data units in the hardware linked list queue that require DMA. In one or more embodiments of the invention, the data unit processor () further includes functionality to update the data unit ready component () when a data unit is ready (e.g., processing of the data unit by the module () is complete or no processing by the module () needs to be performed on the data unit). Specifically, the data unit processor () includes functionality to read and\/or write () to the data unit ready component ().","In one or more embodiments of the invention, the arbitrator () includes functionality to identify from the list ready component () when the first data unit of a linked list is ready and initiate transmission of the first data unit () to the consumer. In one or more embodiments of the invention, the arbitrator () further includes functionality to select, from amongst all linked list having the corresponding list ready bit set, a linked list from which to forward a data unit. In one or more embodiments of the invention, the arbitrator () further includes functionality to read the outbound credit number (), and forward a data unit only when an outbound credit is available. In one or more embodiments of the invention, the outbound credit number () represents the number of data units that may be forwarded to the consumer (). In particular, to the consumer (), the outbound credit is referred to as an inbound credit (discussed above).","Although  shows a certain configuration of components, other configurations may be used without departing from the invention. By way of an example, all or a portion of the functionality of multiple components may be performed by a single component. As another example, all or a portion of the functionality performed by a single component may be performed by one or more other components shown or not shown in . Further, different memory structures may be used, and additional component with additional functionality may exist without departing from the invention. Additionally or alternatively, other connections between components may exist.","Although  show a certain configuration of components, other configurations may be used without departing from the invention. For example, rather than having a PCB pool from which any underlying function may use, individual PCB may be allocated to a particular underlying function to be used solely for the particular underlying function. Other variations of the system may be used without departing from the invention.",{"@attributes":{"id":"p-0110","num":"0109"},"figref":["FIGS. 6-10","FIGS. 6-10","FIG. 6"]},"In Step , a process executing in a virtual machine acquires a lock to the dedicated PCB. In one or more embodiments of the invention, the lock is located on the host channel adapter. In Step , the process executing in the virtual machine writes a command to the send queue on the host. In one or more embodiments of the invention, the writing of the command to the send queue may be performed by acquiring a separate lock corresponding to the memory location of physical memory having the send queue and storing the command in the memory location.","Continuing with , in Step , the virtual machine determines whether a dedicated PCB is available. In one or more embodiments of the invention, determining whether a dedicated PCB is available may be performed by checking a CSR that indicates whether the corresponding dedicated PCB is in use. In one or more embodiments of the invention, the CSR may be set and checked by both hosts processes and the embedded processor subsystem.","In Step , when the dedicated PCB is available, the host channel adapter receives command data (i.e., data in the command) and writes the command data to the PCB until the kick is received. Specifically, in one or more embodiments of the invention, the command data may be transmitted to the host channel adapter using the PCI express fabric. Each command may be of variable length. The kick indicates that the entirety of the command is stored in the PCB. Performing Step  is discussed below and in . Continuing with , in Step , the lock is released in one or more embodiments of the invention.","Although  shows a flowchart for a process on the host to use the dedicated PCB, in one or more embodiments of the invention, dedicated PCBs may be used by the virtual machine manager, the send queue scheduler, portions of the electronic processor subsystem, and other components to perform management functions.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 7","b":"701"},"In Step , a determination is made about whether a VCB is available. Management of the usage of the VCBs is performed by the virtual machine operating system in one or more embodiments of the invention. Specifically, the virtual machine operating system allocates the VCBs to the process in the virtual machine requesting the VCB. The process selects the VCB to allocate from the set of VCBs allocated to the process. If a VCB is not available, then the process waits.","When a VCB is available, the process in the virtual machine sends a command to the requested address of the VCB in Step . At this stage, once the command is sent to the VCB, to the process, the command is processed by the host channel adapter. However, the physical resources may not be available on the host channel adapter.","In Step  a determination is made about whether a PCB is available to the underlying function. Specifically, when command data corresponding to a new command is received, the PCB allocator determines, based on the VCB address, whether a PCB is available. For example, the PCB allocator may first check whether a PCB corresponding to the underlying function is available. If a PCB corresponding to the underlying function is not available, then the PCB allocator may check whether a PCB shared amongst the underlying functions is available. Checking whether a PCB is available may be performed by checking a CSR to determine whether the maximum allocated number of PCBs is in use.","In Step , if a PCB is available, then PCB is bound to the VCB and the command data is written to the PCB. In one or more embodiments of the invention, the binding means that any subsequent command data written to the VCB for the command is stored in the PCB bound to the VCB. Writing command data until the kick is received may be performed as discussed above with reference to Step  in .","Continuing with , if a PCB is not available, then the VCB is marked to be in send queue mode in Step . By marking the VCB in send queue mode, the command is set to be later obtained from the send queue.","In Step , the queue pair identifier and the send queue sequence number is extracted from the command data and the remaining command data is dropped until the kick is received. In one or more embodiments of the invention, the queue pair identifier corresponds to the queue pair to which the command is directed. The send queue sequence number provides an identifier of where the command was stored in the send queue in Step  (discussed above).","As discussed above, the non-existence of a PCB may be hidden from the process in the virtual machine Accordingly, the process of the virtual machine may send command data for the entire command to the host channel adapter. However, as discussed above, the remaining command data is dropped in one or more embodiments of the invention.","In Step , the queue pair identifier and the send queue sequence number is added to the queuing structure in host memory. By adding the queue pair identifier and the send queue sequence number to the queuing structure, the command may be obtained by the send queue scheduler and stored on the host channel adapter. In Step , once the kick is received, the VCB is freed. At this stage, the VCB may be used by other processes in the virtual machine",{"@attributes":{"id":"p-0124","num":"0123"},"figref":["FIG. 8","FIG. 6"]},"In Step , the send queue scheduler identifies the next entry in the queuing structure. In one or more embodiments of the invention, the queuing structure is a first in first out queue. In such embodiments, the next entry in the queuing structure is the oldest entry in the queuing structure.","In Step , the send queue scheduler determines whether a dedicated PCB is available. Determining whether a dedicated PCB is available may be performed as discussed above with reference to Step  of .","When a dedicated PCB is available, the send queue scheduler obtains the send queue sequence number and the queue pair identifier in the queuing structure. The scheduler requests the command from the send queue location corresponding to the send queue sequence number using the queue pair identifier. When the scheduler requests the command, the command data is transferred to the host channel adapter.","In Step , the host channel adapter receives the command data from the send queue and writes the data to the dedicated PCB until the kick is received. Step  may be performed in a similar manner as discussed above with reference to Step  in .","In Step , a determination is made about whether another entry in the queuing structure on the host exists. If another entry exists, then the send queue scheduler continues  to process the next entry in the queuing structure.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 9","FIG. 9"]},"In Step , command data is received on the PCI express fabric bus. In one or more embodiments of the invention, the command data received is in conformance with a predefined protocol. For example, the predefined protocol may set the position of the address, the type of command, and the length field as well as remaining data in the command. The length field may be defined according to the predefined protocol as being located at a particular portion of the command, such as starting at a particular bit location, or otherwise being specified by the predefined protocol.","In Step , a determination is made about whether the received command data includes a length field. Determining whether the received command data includes the length field may be performed using the predefined protocol. In Step , if the received command data includes a length field, the length value is obtained from the length field. At this stage, the host channel adapter has information regarding the size of the command.","In Step , regardless of whether the received command data includes a length field, the received command data without the length field is stored in the PCB. For example, the received command data is stored in the PCB bound to the VCB to which the command data is addressed.","In Step , a determination is made about whether the full length of the command is received. If the received command data, including previously received command data, does not include a length field, then the full length of the command may be determined not to be received. Specifically, because the command includes a length field when virtual kicks are used, the absence of the length field indicates that at least the portion of the command having the length field is not yet received. If all received command data includes a length field, determining whether the full length of the command data is received may be performed by comparing the length value with the amount of the command received.","In one or more embodiments of the invention, the following method may be used to determine whether the full length of the command is received. The length value may be used to create a scoreboard mask. The scoreboard mask is a bit mask has bits that exceed the length preset. A scoreboard is used to track portions of the command data received. The scoreboard may be a series of bits. Each bit represents a position of command data in the command. Specifically, when command data is received, the position of the command data within the command is used to update the scoreboard. When an \u201cor\u201d operation on the scoreboard and the scoreboard mask results in all bits being set, then the determination is made that the full length of the command is received. Other methods may be used to determine whether the full length of the command is received without departing from the invention.","If the full length of the command is not received, then the method may repeat with Step  to receive command data for the command on the bus. If the full length of the command is received, then a kick is issued in Step  in one or more embodiments of the invention. Issuing a kick may be performed by accessing the TVL mapping table to identify the TVL corresponding to the command. Specifically, from the TVL mapping table the TVL or set of TVLs corresponding to the QoS level and the underlying function is identified. If a set of TVLs are identified, then a TVL may be selected from the set of TVLs, such as by using a load balancing protocol.","The virtual kick linked list corresponding to the selected TVL is identified and an identifier of the PCB having the command is stored in the virtual kick linked list. When the identifier of the PCB is in the virtual kick linked list, the command is deemed ready for processing by the non-blocking pipeline in one or more embodiments of the invention.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 10","b":"1001"},"In Step , a determination is made about whether DMA is required. In one or more embodiments of the invention, the host channel adapter supports DMA between the host memory and the host channel adapter. For example, command data sent to the host channel adapter may include the packet data for packets to send on the Infiniband\u00ae network. In such a scenario, in Step , if DMA is not required, then the packet data is extracted from the command in the PCB.","Alternatively, the command data may specify a location in host memory, such as the location of packet data. If the command data specifies a location in host memory, then DMA is required to obtain the command data. In Step , a DMA module identifies one or more locations in host memory that are specified in the command data in the PCB. In Step , the DMA module obtains the packet data from the one or more locations in host memory and stores the packet data into buffers. In one or more embodiments of the invention, as part of obtaining the packet data, the DMA may perform validation to ensure that the host process sending the command has necessary permissions to obtain the packet data.","In Step , regardless of whether DMA is performed to obtain the packet data, the packets are issue to the Infiniband\u00ae port for sending on the Infiniband\u00ae network. In particular packets are generated from the packet data. The generating of the packets may include performing various levels of identification and validation, such as validating the send queue sending the packet(s) and the receive queue receiving the packet(s).",{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 11","b":"1101"},"In Step , the index value is read from the data unit in one or more embodiments of the invention. In one or more embodiments of the invention, which index value is read may be dependent on the type of the module. For example, if the module is the virtual kick module, then the index value that is read may be the TVL assigned to the data unit. If the module is the DMA module, then the index value that is read may be the queue pair identifier assigned to the data unit in one or more embodiments of the invention. Other index values may be used without departing from the invention. In one or more embodiments of the invention, the management component reads the index value.","In Step , a determination may be made about whether the underlying function corresponding to the index value have an available allocated entry in the hardware linked list queue. Specifically, if underlying functions are allocated only a certain number of entries in the data memory, then the hardware linked list queue may include functionality to prevent the underlying function from using more than the allocated number of entries. For example, the management component may determine whether the underlying function has at least one entry credit available. The number of entry credits may be stored in a counter on the module in one or more embodiments of the invention.","If an entry credit is available, then the underlying function is determined to have an available allocated entry and the method proceeds to Step . If an entry credit is not available, then the underlying function is determined not to have an available allocated entry and the data unit is dropped in Step . In one or more embodiments of the invention, Steps  and  are shown as optional as whether the steps are performed may be dependent on the type of module. For example, the virtual kick module may support preventing underlying functions from using more than the allocated number of entries, while the Infiniband\u00ae packet builder module may not support preventing the underlying function from using more than the allocated number of entries.","Continuing with , in Step , a determination is made about whether the index value of the data unit match an existing linked list. In one or more embodiments of the invention, to determine whether the index value matches an existing linked list, the management component may check the index to list identifier memory. If the index value is found in the index to list identifier memory and has a corresponding list identifier, then the list identifier is obtained and the index value of the data unit is deemed to match an existing linked list in one or more embodiments of the invention. If the index value is not found in the index to list identifier memory, then the data unit does not match an existing linked list in one or more embodiments of the invention.","In Step , a new linked list is allocated for the index value in the hardware linked list queue. Specifically, a new list identifier is obtained. In one or more embodiments of the invention, a component of the hardware linked list queue (e.g., data list controller, management component, list identifier to index memory, or another component) maintains a set of list identifiers. The list identifiers in the set may or may not be assigned to an index value. Specifically, the list identifiers that are not assigned to any index value may be deemed available. In one or more embodiments of the invention, the component maintaining the set of list identifiers may provide an available list identifier to the management component. For example, the available list identifier provided may be the first available list identifier in the set of list identifiers. However, other list identifiers may be provided without departing from the invention.","In one or more embodiments of the invention, with the allocation of the new linked list entries, one or more memory structures on the hardware linked list queue are created in Step . For example, the data list controller may update the list identifier to index memory and the index to list identifier memory to associate the list identifier of the new linked list with the index value of the data unit.","In Step , the data unit is stored in the linked list in one or more embodiments of the invention. Specifically, an available entry in the data memory may be selected from the free list and returned to the management component. The management component may trigger the storage of the data unit in the available entry.","In Step , the data list memory is updated based on storing the data unit in an entry in the data memory. In one or more embodiments of the invention, updating the data list memory may be performed as follows: (i) an identifier of the entry storing the data unit is removed from the free list, thereby making the entry storing the data unit is no longer available; (ii) if the linked list is a new linked list, a tail pointer and a head pointer corresponding to the list identifier is set to reference the entry in data unit list memory corresponding to the entry in the data memory storing the data unit; and (iii) if the linked list is not a new linked list, then the following steps may be performed: (a) the tail pointer referencing previous last entry in the data unit list is identified; (b) the previous last entry in the data unit list is updated to reference the new last entry in the data unit list, where the entry in the data memory storing the data unit corresponds to the new last entry in the data unit list; and (c) the tail pointer corresponding to the linked list is updated to reference the new last entry in the data unit list. In one or more embodiments of the invention, the data list controller may perform the updates using an identifier of the entry in the data memory and the list identifier.",{"@attributes":{"id":"p-0151","num":"0150"},"figref":"FIG. 12","b":["1201","1203"]},"In Step , a determination is made about whether the command is a pop command in one or more embodiments of the invention. A pop command is a command to remove an entry in the linked list referenced by the list identifier. In one or more embodiments of the invention, data units are removed from the linked list using pop commands in order of the linked list. By requiring that data units are removed in order, the hardware linked list queue preserves the ordering of messages transmitted on the Infiniband\u00ae network for a particular linked list. In one or more embodiments of the invention, the pop command may be issued when the list ready bit for the linked list is set. For example, the pop command may be issued by an arbitrator for the linked list after arbitrator determines that the linked list is the next list to send a data unit and confirming that an outbound credit is available to the module.","In Step , the data unit referenced by the head pointer of the linked list is identified. Specifically, in one or more embodiments of the invention, the head pointer references an entry in the data unit list. The data unit is obtained from the entry in the data memory corresponding to the entry in the data unit list. In Step , the obtained data unit is returned. In one or more embodiments of the invention, the data unit is forwarded to the consumer module.","In Step , the data unit is removed by moving the head pointer to reference to the next entry, corresponding to the linked list, in the data unit list and returning the entry to the free list. Moving the head pointer may include identifying the current entry in the data unit list referenced by the head pointer. The value stored in the current entry is obtained. The value identifies the next entry in the data unit list in one or more embodiments of the invention. The value may be stored in the head pointer. Further, the entry that stored the popped data unit is returned to the free list. Additionally, if the entry is the last entry in the linked list, in one or more embodiments of the invention, references to the index corresponding to the linked list are removed from the list identifier to index memory and the index to list identifier memory.","In Step , if the command is not a pop command, the command may be a peek command. A peek command is a command to view the data unit without removing the data unit. In one or more embodiments of the invention, similar to a pop command, multiple peek commands allows for the viewing of multiple data units in FIFO order. However, the data unit is not removed from data memory and may be accessed again. In Step , a determination is made about whether the command is a peek command in one or more embodiments of the invention. A peek command may be used, for example, by the data processor to process an entry in the hardware linked list queue. In Step , if the command is a peek command, the data unit referenced by a peek pointer of the linked list is identified. In one or more embodiments of the invention, the peek pointer is a pointer that references the next entry in the linked list that has not been returned. Performing Step  may be performed in a similar manner to using the head pointer as discussed above with reference to Step . In Step , the obtained data unit is returned. For example, the data unit may be transmitted to the data unit processor for processing.","In one or more embodiments of the invention, a peek pointer is moved to the next entry in Step . The peek pointer may be a separate pointer in the data list controller. Moving the peek pointer may be performed in a similar manner to moving the head pointer as discussed above with reference to Step . In one or more embodiments of the invention, by moving the head pointer when a peek command is received, the hardware linked list queue may support processing multiple data units in a linked list without removing the data units from the hardware linked list queue. Thus, whether subsequent data units in a linked list are processed may not be dependent on whether the first data unit in the linked list is removed.","In one or more embodiments of the invention, if the command is not a peek, the command may be a reset pointer command. In Step , a determination is made about whether the command is a reset pointer command. If the command is a reset pointer command, then the peek pointer is set to reference the data unit list entry referenced by the head pointer in Step .","In one or more embodiments of the invention, if the command is not a reset pointer command, then a determination is made whether the command is a flush command reclaim the memory to store the linked list in Step . In Step , if the command is a reclaim command, then all entries allocated to the linked list are returned to the free list. Further, in one or more embodiments of the invention, references to the index corresponding to the linked list are removed from the list identifier to index memory and the index to list identifier memory.","In one or more embodiments of the invention, if the command does not match any recognized commands, the hardware linked list queue may optionally not perform an operation in Step . Although  shows particular types of commands, alternative or other types of commands may exist without departing from the invention.","In one or more embodiments of the invention, Steps - are shown as optional. Specifically, whether the steps are performed may be dependent on the type of module. For example, the DMA module may support peek commands while the virtual kick module does not support peek commands.",{"@attributes":{"id":"p-0161","num":"0160"},"figref":["FIG. 13","FIG. 13"],"b":["1300","1302","1304","1306","1300","1302","1300","1302","1304"]},"Continuing with the example, \u201ca\u201d is used to represent that the entry stores an address, \u201cd\u201d is used to represent that the entry stores a data unit, \u201cr\u201d is used to indicate that the entry indicates the ready bit is set, a \u201c0\u201d indicates that the data in the bit is reset, and an empty space indicates that it does not matter what the data is in the unit. Further, thick arrows represent the references between components. Thin arrows are used for reference characters. In the example, list  head references entry (). The address stored in entry () is the address of entry (). Thus, entry () in data memory () is the first entry in linked list  and entry () in data memory () is the second entry in linked list . As shown in , the data unit list () may be used to identify, for a particular linked list, the data units and the order of the data units in the linked list.","Continuing with the example, as shown by the data unit ready bit string (), some of the data units may be processed and ready for forwarding to the consumer while other data units are not processed. For example, entry () is ready as shown by bit (). Additionally, entry () is ready as shown by bit (). In one or more embodiments of the invention, entry () may be ready before other entries in linked list  because, for example, no processing is required on entry (). In particular, if the module is a DMA module, and entry () does not require DMA, then entry () may be deemed immediately ready upon receipt by the DMA module. In other words, because DMA is not required by entry (), entry () may be transmitted to the consumer as soon as entry () is the first data unit in list .","In the example, the list ready bit string () may be used to represent whether the list is ready. For example, as shown by bit (), linked list  is ready. Specifically, because the list  head pointer () references entry () corresponding to data unit () that is ready as shown in bit (), linked list  is deemed ready for the first data unit to be popped and transmitted to the consumer. However, because the list  head pointer () references entry () corresponding to data unit () that is not ready as shown in bit (), linked list  is not deemed ready for the first data unit to be popped and transmitted to the consumer. Accordingly, bit () is not set. Because bit () is not set, no data units in linked list  are removed from the data memory ().","In one or more embodiments of the invention, when a pop command is issued for linked list , list  head pointer is moved to reference entry (). Further, because entry () corresponds to data unit in entry () which is not ready as shown by bit (), the list  ready bit () is reset in the list ready bit string () after data unit () is removed from list .","As shown by way of the example, embodiments of the invention provide a mechanism for supporting, in hardware, multiple linked lists in a single hardware linked list queue. Specifically, embodiments of the invention provide a mechanism for individually maintaining the ordering of forwarding data units in the same linked list while at the same time allowing data units in different linked lists to be processed out of order. Thus, for example, messages in the same queue pair are sent in order without having to wait for messages assigned to different queue pairs. Therefore, in one more embodiments of the invention, through the hardware linked list queue(s), the communications adapter supports resource sharing between processes executing on a host without having a single process block other processes from sending messages and using the resources of the host channel adapter.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 1-5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 6-12"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
