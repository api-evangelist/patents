---
title: Graphical display system and method
abstract: A graphical display system utilizes a plurality of graphics pipelines, a compositor, and application interface logic. The plurality of graphics pipelines are configured to render graphical data in parallel. The compositor is configured to define a composite data signal that is based on the graphical data rendered by each of the pipelines. The application interface logic is configured to retrieve configuration data indicative of a configuration of the compositor. The application interface logic is further configured to provide the configuration data to a graphics application, wherein the graphics application is configured to provide graphical data to the plurality of pipelines based on the configuration data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06853380&OS=06853380&RS=06853380
owner: Hewlett-Packard Development Company, L.P.
number: 06853380
owner_city: Houston
owner_country: US
publication_date: 20020304
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention generally relates to graphical rendering and display techniques and, in particular, to a graphical display system and method.","2. Related Art","Computer graphical display systems are commonly used for displaying graphical representations of two-dimensional and\/or three-dimensional objects on a two-dimensional display device, such as a cathode ray tube, for example. In this regard, a computer graphical display system normally includes one or more graphics applications having graphical data that defines one or more graphical objects. When a graphical object is to be displayed, the graphics application submits a command or a set of commands, referred to hereafter as a \u201cdrawing command,\u201d for drawing the object. The drawing command includes or is associated with graphical data that defines the color value and possibly other attributes for each pixel of the object.","In response to the drawing command, a graphics pipeline within the graphical display system renders the command's graphical data to a frame buffer. The data within the frame buffer defines the display attributes (e.g., color) for each pixel of a display device, which periodically reads the frame buffer and colors each pixel displayed by the display device according to each pixel's corresponding color value in the frame buffer. Moreover, by rendering the graphical data of the drawing command to the frame buffer, the image displayed by the output device is eventually updated to include an image of the object defined by the graphical data of the drawing command.","Higher quality images are often defined by larger amounts of graphical data. However, increasing the amount of graphical data defining an image to be displayed by a typical graphical display system generally increases the amount time required for the graphical display system to render the graphical data. Thus, a trade-off between image quality and rendering speed often exists, and the overall rendering speed of a typical graphical display system is often a limiting factor in the types of images rendered by the graphical display system.","A graphical display system in accordance with an exemplary embodiment of the present invention utilizes a plurality of graphics pipelines, a compositor, and application interface logic. The plurality of graphics pipelines are configured to render graphical data in parallel. The compositor is configured to define a composite data signal that is based on the graphical data rendered by each of the pipelines. The application interface logic is configured to retrieve configuration data indicative of a configuration of the compositor. The application interface logic is further configured to provide the configuration data to a graphics application, wherein the graphics application is configured to provide graphical data to the plurality of pipelines based on the configuration data.","A graphical display method in accordance with an exemplary embodiment of the present invention can be broadly conceptualized by the following steps: providing graphical data from a graphics application to a plurality of graphics pipelines, rendering the graphical data in parallel, via the plurality of graphics pipelines, utilizing a compositor to form a composite data signal based on the graphical data rendered by each of the plurality of pipelines, retrieving configuration data indicative of a configuration of the compositor, and adapting operation of the graphics application based on the configuration data.",{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 1","b":["15","17","15","17","23","23","17","26"]},"In general, the frame buffer  stores graphical data defining an image that is to be displayed by a display device . In this regard, the frame buffer  includes a set of data for each pixel displayed by the display device . Each set of data is correlated with coordinate values that identify one of the pixels displayed by the display device , and each set of data includes the color value of the identified pixel, as well as any additional information needed to appropriately color or shade the identified pixel.","By employing a plurality of graphics pipelines, it is possible to increase rendering speed and\/or image quality. For example, commonly-assigned U.S. patent application Ser. No. 09\/715,335, entitled \u201cSystem and Method for Efficiently Rendering Graphical Data,\u201d which is incorporated herein by reference, generally describes a graphical display system having multiple pipelines for rendering graphical data from a graphics application. In one embodiment described by the foregoing patent application, a master computer passes a copy of each three-dimensional (3D) graphics command to a plurality of pipelines, which render the 3D graphics commands in parallel. By having each of a plurality of pipelines render at least a portion of the graphical data associated with the 3D graphics command, the overall rendering speed of the graphical display system can be increased, and\/or the image quality of the graphical display system can be efficiently increased via techniques such as jitter enhancement and\/or anti-aliasing.","Note that, by having a master processor distribute each 3D graphics command to the plurality of pipelines, the use of multiple pipelines to render graphical data can be transparent to the graphics application. Thus, conventional graphics applications  designed to operate on the system  depicted in  can be utilized in the graphical display system described by the foregoing patent application.","However, transparently passing a copy of each 3D graphics command to a plurality of pipelines for rendering may not always be the best methodology for rendering graphical data from a graphics application. For example, when graphical objects are defined by a relatively large amount of graphical data, significant delays may occur due to the passing of multiple copies of the same graphics command to different pipelines. Some of these delays are needless in that one or more of the graphics pipelines may never actually render at least some of the graphical data in each graphics command.","In such situations, it may be more desirable for the graphics application to allocate portions of the graphical data to different pipelines and to then pass, to each pipeline, only graphical data that is allocated to the pipeline. In essence, the graphics application passes different commands and different graphical data to the different pipelines so that the overall graphical display system can operate more efficiently. A preferred embodiment of such a graphical display system  is depicted in FIG. .","As shown by  the graphical display system  has multiple pipelines - for rendering graphics commands from a graphics application . The graphics pipelines - may be implemented via hardware, software or any combination thereof. It should be noted that the embodiment shown by  depicts four graphics pipelines - for illustrative purposes only, and other numbers (i.e., two or more) of graphics pipelines - may be employed to implement the system  in other embodiments.","As will be described in more detail hereafter, the graphics application  receives configuration data  from application interface logic (AIL)  and, based on this data , provides graphical data to each of the graphics pipeline -, which respectively render the graphical data to frame buffers -. Each frame buffer - buffers the graphical data rendered to it and outputs the graphical data to a compositor , which may be implemented in software, hardware, or any combination thereof. The compositor , which will be described in more detail hereafter, is configured to provide, to a display device  (e.g., a cathode ray tube), a composite data signal  based on the graphical data from the frame buffers -. The graphical data provided to the display device  via the composite data signal  is received by the display device , which displays images defined by the composite data signal . Note that the pipelines -, the frame buffers -, and the compositor  will be collectively referred to as a graphical acceleration unit .","In some situations, it may be desirable to distribute some of the graphics pipelines - across multiple computers. In this regard, by distributing the graphics pipelines - across multiple computers, it is possible to divide the processing burden associated with the rendering performed by the pipelines - across the multiple computers rather than having a single computer bear the entire processing burden alone. For illustrative purposes, assume that, in the embodiment shown by , each of the graphics pipelines - is implemented via a different computer. However, it should be noted that, in other embodiments, multiple ones of the graphics pipelines - could be implemented via the same computer, if desired.","When the graphics pipelines - are implemented via different computers, it may be desirable to utilize a network, such as a local area network (LAN), for example, to enable communication with the pipelines -. Indeed, in the exemplary embodiment shown by , a LAN  is utilized to interface the graphics application  with each of the pipelines -, which preferably reside on different computers as described above.",{"@attributes":{"id":"P-00032","num":"00032"},"figref":["FIG. 3","FIG. 3"],"b":["103","61","103","61","102","61","111","103","113","115","103","117","103","126","103","98","2"]},"Various types of network protocols may be employed to process the graphical data received from the graphics application . In the exemplary embodiment of the system  described herein, X Protocol is preferably utilized to render two-dimensional (2D) graphical data, and an extension of X Protocol, referred to as \u201cOpenGL (OGL) Protocol,\u201d is preferably utilized to render three-dimensional (3D) graphical data, although other types of protocols may be utilized in other embodiments.","By way of background, OGL Protocol is a standard application programming interface (API) to hardware that accelerates 3D graphics operations. Although OGL Protocol is designed to be window system independent, it is often used with window systems, such as the X Window System, for example. In order that OGL Protocol may be used in an X Window System environment, an extension of the X Window System has been developed called \u201cGLX.\u201d For more complete information on the GLX extension to the X Window System and on how OGL Protocol can be integrated with the X Window System, see for example Mark J. Kilgard, (Addison-Wesley Developers Press 1996), which is incorporated herein by reference. Also see commonly-assigned U.S. Pat. No. 6,249,294, entitled \u201c3D Graphics in a Single Logical Screen Display Using Multiple Remote Computer Systems,\u201d which is incorporated herein by reference as well.","The host computer  preferably includes a GLX layer  that can be implemented in software, hardware, or any combination thereof. In the embodiment shown by , the GLX layer  is implemented in software and translates each graphics command issued by the graphics application  into one or more X Protocol commands for performing the functionality commanded by the issued command. In the preferred embodiment, each X Protocol command is communicated to one or more graphics pipelines - via LAN interface  and LAN .",{"@attributes":{"id":"P-00036","num":"00036"},"figref":["FIG. 4","FIG. 4"],"b":["133","55","58","133","141","133","143","145","133","147","133","156","133","98"]},"The computer  of the preferred embodiment also comprises an X server . The X server  may be implemented in software, hardware, or any combination thereof, and in the embodiment shown by , the X server  is implemented in software and stored in memory . In the preferred embodiment, the X server  renders two-dimensional (2D) graphical data and routes three-dimensional (3D) graphical data to an OpenGL (OGL) daemon . Note that the OGL daemon  may be implemented in software, hardware, or any combination thereof, and in the embodiment depicted by , the OGL daemon  is also implemented in software and stored within memory .","Moreover, an X server dispatch layer  is designed to route 2D graphical data of a received command to a device-independent (DIX) layer . The DIX layer  and a device-dependent (DDX) layer  are configured to process the 2D data and to accelerate or drive the 2D data through pipeline hardware  to the pipeline's associated frame buffer - (FIG. ). The X server dispatch layer  is further designed to route 3D graphical data of a received command to a GLX layer , which interfaces the 3D graphical data with the an OGL dispatch layer  of the OGL daemon . The OGL dispatch layer  interfaces this data with an OGL device-independent (DI) layer . The OGL DI layer  and an OGL device-dependent (DD) layer  are configured to process the 3D data and to accelerate or drive the 3D data through pipeline hardware  to the pipeline's associated frame buffer - (FIG. ). Thus, the 2D graphical data of a received command is processed or accelerated by the X server , and the 3D graphical data of the received command is processed or accelerated by the OGL daemon . Note that logic for implementing a graphics pipeline - shown by  generally resides within the X server , the OGL daemon , and the pipeline hardware  of FIG. .","As set forth above, the compositor  () is configured to form a composite data signal  that is based on graphical data from the frame buffers -. The composite data signal  defines the color values for the pixels displayed by the display device , and the display device  updates its displayed image based on the color values received from the composite data signal . Exemplary techniques that may be utilized by the compositor  to process the graphical data from the frame buffers - and to form the composite data signal  will be generally described in more detail hereafter.","In a first example, the additional processing power provided by the multiple pipelines - may be utilized to increase the rendering speed of the system . In this regard, the graphics application  may be configured to allocate each of the pipelines - for rendering only a portion of the overall image displayed by the display device . As an example, referring to , each of the pipelines - may be respectively allocated to render portions - of an overall image  displayed by the display device . More specifically, the graphics application  may allocate the graphics pipeline  to render graphical data for portion  and may allocate the graphics pipeline  to render graphical data for portion . Furthermore, the graphics application  may allocate the graphics pipeline  to render graphical data for portion  and may allocate the graphics pipeline  to render graphical data for portion .","Assume that, in such an example, a new object to be displayed resides only in portions -. To render the new object, the graphics application  determines which primitives of the object are to be displayed in portion  and provides these primitives to pipeline , which renders the primitives to the frame buffer . The graphics application  also determines which primitives of the object are to be displayed in portion  and provides these primitives to pipeline , which renders the primitives to the frame buffer . In addition, the graphics application  determines which primitives of the object are to be displayed in portion  and provides these primitives to pipeline , which renders the primitives to the frame buffer . Note that it is not necessary for the graphics application  to provide the same set of primitives to more than one pipeline -. Furthermore, since the object does not reside in the portion  allocated to the pipeline , it is not necessary for the graphics application  to provide any of the foregoing primitives to the pipeline .","After the aforementioned primitives have been respectively rendered to frame buffers -, each of the frame buffers - stores the pixel values for a different portion of the object being rendered. Moreover, the compositor  provides the object's pixel values from the frame buffer  to the display device , which displays the object portion defined by these pixel values in image portion , and the compositor  provides the object's pixel values from the frame buffers  and  to the display device , which displays the object portions defined by these pixel values in image portions  and , respectively. As a result, the entire object is displayed by the display device  in portions -. The process of displaying an image  according to the foregoing techniques shall be generally referred to hereafter as \u201cscreen space subdivision.\u201d","As illustrated by the foregoing example, the amount of graphical data processed by a graphics pipeline - can be reduced if the graphics application  refrains from providing the pipeline - graphical data that is outside of the pipeline's allocation. Indeed, in the preceding example, the graphics pipeline  is not burdened with processing the primitives that are to be displayed in portions  and . Similarly, the graphics pipelines  and  are not burdened with processing primitives outside of their respective allocations, and pipeline  is not burdened with processing any of the primitives since all of the primitives are outside of its allocation. As a result, the overall rendering speed of the system  is enhanced.","Note that a variety of techniques may be employed by the compositor  in forming the composite data signal  in the foregoing example. In the preferred embodiment, as shown by , the compositor  comprises an input buffer  that buffers the graphical data received from the frame buffers -. Based on the buffered data, compositor control logic  stores, in an output buffer , a color value for each pixel of an image frame to be displayed by the display device . The output buffer  then outputs the image frame via composite data signal , which is utilized by the display device  to display the image frame. Note that the compositor control logic  can be implemented in hardware, software, or any combination thereof.","To provide a color value for a pixel within image portion , the compositor control logic  utilizes the graphical data from frame buffer . In this regard, the compositor control logic  reads, from the graphical data received from frame buffer , the color value of the corresponding pixel and writes this color value to the output buffer . In a similar fashion, the compositor control logic  utilizes the graphical data from frame buffers - to provide the color values for pixels within image portions -, respectively.","Thus, for each pixel of an image frame stored in the output buffer , the compositor control logic  is configured to define a color value based on the graphical data stored in one of the frame buffers -, depending on which frame buffer - has been allocated to the image portion - that includes the pixel. The compositor control logic  then writes this color value to the output buffer . Note that various other configurations of the compositor  are possible, and the compositor  may employ various other techniques in forming the composite data signal  based on the graphical data received from each of the frame buffers -.","It should be further noted that it is not necessary for each pipeline - to be allocated an equal portion - by the graphics application . For example, one of the portions - may include more objects or more complex objects than other portions - and\/or may be of a smaller size than the other portions -. Indeed, it may be desirable for the graphics application  to define the portions - allocated to the pipelines - such that each pipeline - is responsible for rendering substantially the same amount of graphical data during operation. Furthermore, it is not necessary for each of the portions - to be similarly shaped, and it is possible for the same pipeline - to be allocated a plurality of non-contiguous portions of the overall image  (FIG. ).","In addition, it is possible for the graphics pipelines -, instead of the graphics application , to perform culling. In this regard, the graphics application  may communicate, to each of the graphics pipelines -, information indicative of which pipelines - are allocated or assigned to which image portions -. The graphics pipelines - may then cull the primitives received from the graphics application  such that each pipeline - only renders primitives within its allocated or assigned image portion -.","In another embodiment, each of the graphics pipelines - may be allocated a particular portion - of the overall image , as described above. However, before rendering to the frame buffers -, the graphics pipelines - super-sample the graphical data rendered by the pipelines -. In other words, each of the graphics pipelines - magnifies the image being rendered by the pipeline -. Then, for each of the frame buffers -, the compositor  blends the received graphical data such that the image defined by such data is reduced to its original size (i.e., the image's size before super-sampling).","The compositor  then defines each pixel value for the image  based on the blended color values according to techniques similar to those described above. In this regard, the compositor control logic  reads, from the blended values derived from the graphical data output by the frame buffer , to provide the color values for pixels within the image portion . In a similar fashion, the compositor control logic  utilizes the blended values derived from the graphical data output by the frame buffers - to provide the color values for pixels within image portions -, respectively. Thus, for each pixel of an image frame stored in the output buffer , the compositor control logic  is configured to define a color value based on the blended values derived from the graphical data output by one of the frame buffers -, depending on which frame buffer - has been allocated to the image portion - that includes the pixel. The compositor control logic  then writes this color value to the output buffer . By super-sampling and then blending the graphical data rendered by each of the graphics pipelines -, the image displayed by the display device  is anti-aliased.","In another embodiment, one or more of the graphics pipelines - may be allocated the same image portion - in order to enable certain image enhancement techniques. For example, in one embodiment, each of the pipelines - may be allocated the entire image . Therefore, the same primitives are provided to each of the pipelines - for rendering, and the graphical data in each of the frame buffers - define the same image. However, in rendering the graphical data, each of the graphics pipelines - adds a small offset to the coordinates of each pixel rendered by the pipeline -. The offset applied to the pixel coordinates is preferably different for each different pipeline -.","The compositor  then averages the color values for the same pixel coordinates from frame buffers - to define the pixel color values that are stored in the output frame buffer . The display device  then displays the averaged color values, thereby displaying a jitter enhanced 3D image.","It should be noted that it is possible to perform jitter enhancement while allocating one or more pipelines to only a portion of the overall image  displayed by the display device . For example, it is possible to allocate two of the pipelines  and  to a first portion (e.g., half) of the image  and to allocate the other two of the pipelines  and  to a second portion (e.g., the other half) of the image . Then, pipelines  and  may render the same images, which are averaged by the compositor , to perform jitter enhancement on the first portion, and the pipelines  and  may render the same images, which are averaged by the compositor , to perform jitter enhancement on the second portion. It should be noted that other techniques may be employed to exploit the additional processing power provided by the multiple pipelines - for the purposes of enhancing rendering speed and\/or image quality.","It should be further noted that the configuration of the compositor  may be different for different graphical acceleration unit . For example, the graphics application  may be interfaced with a graphical acceleration unit  having a compositor , such as the one depicted in , capable of receiving and processing graphical data from four graphics pipelines -. However, the graphics application  may later be interfaced with another graphical acceleration unit  having a compositor  capable of receiving and processing graphical data from only three graphics pipelines -. In such a situation, the graphics application  preferably allocates different portions of the image  that is to be displayed by the display device  to only three graphics pipelines -.","Thus, in the preferred embodiment, the graphics application  is able to adapt its operation depending on the configuration of the compositor  and\/or other components of the graphical acceleration unit . In this regard, as shown by , the graphics application  is preferably interfaced with application interface logic (AIL)  that comprises configuration data  indicative of the configuration of the graphical acceleration unit  and, more particularly, of the compositor . As mere examples, the configuration data  may indicate the number of pipelines - that may be utilized by the graphics application  to render the image  to be displayed by the display device  (e.g., the number of frame buffers - that may simultaneously input rendered graphical data into the compositor ), or the configuration data  may indicate whether the compositor  is capable of blending the graphical data received from one or more frame buffers - for the purposes of performing anti-aliasing and\/or jitter enhancement, as described above. The configuration data  may also indicate whether the compositor  is capable of performing Z-buffering processes and\/or alpha-blending, which will be described in more detail hereafter. Note that the configuration data  may indicate other types of information pertaining to the configuration or operational capabilities of the graphical acceleration unit  and the compositor , in particular.","In the preferred embodiment, the application interface logic  is configured to retrieve the configuration data  and to provide the retrieved configuration data  with the graphics application  (FIG. ), as will be described in more detail hereafter. The application interface logic  can be implemented in software, hardware, or any combination thereof. As an example, the application interface logic  can be implemented in software and stored in the memory  () of a computer  utilized to implement the graphics application .","When the application interface logic  is implemented in software, the configuration data  may be stored in the same memory as the software of the logic . In alternative embodiments, the configuration data  may be stored in memory separate from the application interface logic . For example, the configuration data  may be stored in a database (not specifically shown), and the application interface logic  may be configured to exchange information with the database in order to retrieve the configuration data . In another embodiment, which will be described in more detail hereafter, the configuration data  may be stored in the compositor , and the application interface logic  may be configured to exchange data with the compositor  to enable the logic  to retrieve the configuration data . In other embodiments, the configuration data  may be stored in other locations accessible by the application interface logic .","When the graphics application  is invoked, the application  preferably requests the application interface logic  to query the configuration of the graphical acceleration unit  and, in particular, the compositor , as depicted by blocks  and  of FIG. . In response, the application interface logic  retrieves the configuration data  and provides the configuration data  to the application , as depicted by blocks  and  of FIG. . The graphics application  then adapts its operation to the configuration indicated by the configuration data , as depicted by block  of FIG. .","For example, the configuration data  may indicate that the compositor  is capable of performing screen space subdivision based on graphical data from four graphics pipelines -. In response, the application  may allocate each of the pipelines - to a different portion - of the overall image  to be displayed by the display device . However, if the configuration data  indicates that the compositor  is capable of blending graphical data for performing jitter enhancement, then the application  may allocate a plurality of the pipelines - to the same portion of the image  and instruct the compositor  to perform jitter enhancement on the graphical data received from the plurality of pipelines -. Furthermore, if the configuration data  indicates that the compositor  is capable of blending graphical data for performing anti-aliasing, then the application  may instruct the compositor  to anti-alias the graphical data received from one or more pipelines -.","In addition, if the configuration data  indicates that the compositor  is capable of performing Z-buffering processes, the graphics application  may be configured to provide depth data according to the Z-buffering capabilities of the compositor . As used herein, the term \u201cZ-buffering processes\u201d generally refers to processes, such as culling, that utilize depth values, commonly referred to as \u201cZ-values,\u201d for processing or selecting graphical objects. As an example, in some embodiments, one or more of the pipelines - may be allocated to the same image portion - () of the image . However, the graphics application  may allocate different objects to different pipelines -. As an example, the graphics application  may allocate a first object to pipeline  and a second object to pipeline . In such an example, the graphics application  may provide commands for drawing or manipulating the first object only to pipeline  and may provide commands for drawing or manipulating the second object only to pipeline . Thus, pipelines - are not burdened with processing graphical data from the first object, and pipelines , , and  are not burdened with processing graphical data from the second object.","However, the first object may occlude the second object. In such an example, the compositor  may be configured to perform occlusion culling. In this regard, along with each primitive transmitted to the pipelines -, the graphics application  preferably transmits each primitive's Z-value. The pipeline - rendering the primitive then defines one or more pixels based on the primitive and stores each pixel's color value and Z-value in the pipeline's associated frame buffer -. The compositor  then utilizes the Z-values stored in the frame buffers - to perform occlusion culling.","Moreover, in defining a color value for a particular pixel, which is preferably associated with a particular set of two-dimensional coordinates (x,y), the compositor control logic  compares the Z-values, from the frame buffers -, that are also associated with the particular set of two-dimensional coordinates (x,y). The compositor  then selects the frame buffer - having the smallest Z-value for the particular pixel (assuming that a smaller Z-value indicates that the object having the smaller Z-value is closer than an object having a larger Z-value). The compositor  then utilizes the color value associated with the particular set of two-dimensional coordinates (x,y) from the selected buffer - as the particular pixel's color value.","For example, in the previous illustration where a first object defined by graphical data in frame buffer  occludes a second object defined by graphical data in frame buffer , the compositor  preferably culls the second object. In this regard, to define a color value of a pixel shared by the first and second object, the compositor  compares the Z-values associated with the pixel in each of the frame buffers -. The Z-value from frame buffer  is preferably larger than the Z-value from frame buffer , since the first object occludes the second object. Therefore, if there are no objects in the frame buffers  and  having a smaller Z-value for the pixel, the compositor  preferably selects frame buffer  and defines the color value of the pixel based on the pixel's color value stored in frame buffer . In this regard, the compositor  stores, in the output buffer , the pixel's color value from frame buffer . By implementing the foregoing technique for each of the pixels shared by the first and second object, the compositor  effectively culls the second object or, in other words, renders the first object in lieu of the second object.","In the preferred embodiment, the configuration data  indicates whether the compositor  is capable of processing Z-values for the purposes of performing various Z-buffering processes, such as the culling process described above, for example. Furthermore, if the compositor  is capable of performing Z-buffering processes, the configuration data  also preferably indicates the maximum Z-value bit length that the compositor  is capable of handling. Thus, based on the configuration data , the graphics application  may determine whether the compositor  can perform occlusion culling and, therefore, whether it can allocate the pipelines - to different objects as described above. Furthermore, the graphics application  may scale the Z-values in the graphical data provided to the pipelines - based on the configuration data . In this regard, the graphics application  may scale the Z-values such that the largest bit length of a Z-value provided to the pipelines - does not exceed the maximum Z-value bit length, as indicated by the configuration data .","Furthermore, when different objects are allocated to different pipelines -, as described above, it may be desirable for the compositor  to perform alpha-blending. In general, alpha-blending is a well-known process to determine pixel color values when a substantially transparent object occludes a substantially opaque object. Furthermore, the configuration data  may indicate the types of information utilized by the compositor  in performing alpha-blending. Thus, the graphics application  may determine, based on the configuration data , whether the compositor  is capable of performing alpha-blending, and if the compositor  is capable of performing alpha-blending, the graphics application  may include, in the graphical data provided to the pipelines -, information sufficient for enabling the compositor  to perform alpha-blending. This information may then be passed to the compositor  and utilized by the compositor  for performing alpha-blending.","Note that the foregoing examples pertaining to how the application  may utilize the configuration data  received from the application interface logic  have been described for illustrative purposes. Indeed, in other embodiments, the configuration data  may be indicative of other configuration characteristics of the graphical acceleration unit  and, in particular, the compositor , and the graphics application  may be configured to utilize other techniques in adapting its operation based on the configuration data .","Furthermore, it should also be noted that the operation of the compositor  can be generally controlled by the graphics application . For example, the application  may divide the image  to be displayed by the display device  into multiple portions - and then allocate each of the pipelines - to different portions -, as described above. The graphics application  may then inform the compositor control logic  which portion - of the overall image  is allocated to each of the pipelines -. Based on this information, the compositor control logic  then writes the appropriate graphical data into the output buffer  according to the techniques described above. Furthermore, the graphics application  can inform the compositor control logic  whether anti-aliasing, jitter enhancement, Z-buffering, and\/or alpha-blending is to be performed by the compositor . Note that the graphics application  may communicate such control information through one or more of the pipelines - to the compositor , or the graphics application  may communicate such information to the compositor  via a connection  that bypasses the pipelines -.","In addition, it is possible to distribute multiple graphics applications  or multiple threads of the same graphics application  across multiple pipelines - rather than having a single graphics application  provide graphical data to each of the pipelines -, as is shown in FIG. . As an example, refer to , which depicts a plurality of graphics application threads -that are each interfaced with one of the pipelines -. Each of the graphics application threads -may be implemented via a different host computer  (FIG. ). Alternatively, if desired, each of the graphics application threads -may be implemented via the same computer  that implements the application's corresponding pipeline -. For example,  depicts a computer  utilized to implement one of the threads and its corresponding pipeline . Note that other methodologies for implementing the graphics application threads -and\/or the pipelines - may be employed in other embodiments.","In the example shown by , each of the graphics application threads -is interfaced with a different set of application interface logic . Each of the graphics application threads -is configured to request its associated set of application interface logic  to query the configuration of the graphical acceleration unit  and, more particularly, the compositor . In response, the associated application interface logic  retrieves the configuration data  and provides the configuration data  to its respective graphics application thread -. Each of the graphics application threads -then adapts its operation based on the configuration data  via similar techniques described above for the embodiment depicted by FIG. . However, instead of providing each of the graphics pipelines - with graphical data, as is done by the graphics application  depicted in , each graphics application thread -only provides its corresponding pipeline - with graphical data.","As an example, when the configuration data  indicates that the compositor  may perform screen space subdivision for four pipelines -, each of the graphics application threads -may be configured to allocate its corresponding pipeline -, respectively, to a particular one of the image portions - (FIG. ). More specifically, thread may be configured to allocate its corresponding pipeline  to image portion , and thread may be configured to allocate its corresponding pipeline  to image portion . Further, thread may be configured to allocate its corresponding pipeline  to image portion , and thread may be configured to allocate its corresponding pipeline  to image portion . Then, each of the graphics application threads -provides its corresponding pipeline -, respectively, with primitives only located in the image portion - allocated to its corresponding pipeline -.","In , each set of application interface logic  stores its own set of configuration data . However, it is possible for multiple sets of application interface logic  to utilize the same set of configuration data . For example, a set of configuration data  may be stored in a memory location (e.g., in a database, in the compositor , in memory shared by one of the sets of logic , etc.) accessible by multiple sets of the application interface logic . Then, each of the multiple sets of application interface logic  may retrieve the configuration data  from the same memory location. Note that, in embodiments where multiple threads -utilize the same set of configuration data , a single set of application interface logic  may be configured to provide the configuration data  to the multiple threads -, if desired.","Note that one or more threads -, similar to the graphics application  depicted in , may communicate, to the compositor , control information for controlling the general operation of the compositor . Such information may be transmitted via one or more pipelines - or via one or more connections  (not specifically shown in ) that bypass the pipelines -.","Further note that, as previously set forth above, the configuration data  may reside in various memory locations, such as in the compositor  or the computers  and  utilized to implement the graphics application  and\/or one or more of the pipelines -, for example.  depict an embodiment where the configuration data  is stored within memory  (e.g., registers or other types of memory devices) of the compositor . In such an embodiment, the compositor control logic  (FIG. ), the memory , and the compositor's buffers  and  may reside on one or more printed circuit boards (not specifically shown).","When the configuration data  resides within the compositor , as shown by , the compositor  may comprise a compositor interface  for enabling data to be exchanged with the compositor . The compositor interface  may comprise any known or future developed communication device (e.g., RS-232 connector) for enabling data communication between the compositor control logic  and a device external to the compositor . In the embodiment depicted by , the compositor interface  is coupled to the application interface logic , which is configured to retrieve the configuration data  and to interface the retrieved configuration data  with the graphics application  (FIG. ), as described hereinbefore.","Note that, according to the techniques described above, the graphics application  generally controls the operation of the graphical acceleration unit . In this regard, the graphics application  generally controls the allocation of the pipelines - and whether various image enhancement techniques (e.g., jitter-enhancement and\/or anti-aliasing) are performed by the graphical acceleration unit . It should be noted that the graphics application  may change its control of the graphical acceleration unit  during operation (i.e., \u201con the fly\u201d).","For example, as the image displayed by the display device  changes, the graphics application  may change the allocation of the pipelines - in an effort to increase the efficiency of the unit  by keeping the amount of graphical data rendered by, each pipeline - substantially equal. In another example, the graphics application  may, if desired, dynamically change whether the unit  performs image enhancement techniques. Such a change may occur automatically or may occur in response to a user input command. Moreover, it may be desirable to change the allocation of the pipelines - as the application  changes the image enhancement techniques performed by the graphical acceleration unit .","As an example, two of the pipelines - may be allocated the same image portion for enabling the graphical acceleration unit  to perform jitter-enhancement on the image portion. If the graphics application  determines to end the jitter-enhancement, the graphics application  may allocate each of the two pipelines to different image portions in an effort to increase the rendering speed of the graphical acceleration unit . In any event, when the graphics application  dynamically changes the operation of the graphical acceleration unit , the graphics application , according to the techniques described herein, preferably utilizes the configuration data  to ensure that the operation of the unit  is changed in a manner consistent with the configuration of the unit .","By performing the techniques described herein, the graphics application  is capable of dynamically adapting its operation depending on the particular configuration of the graphical acceleration unit  and the compositor , in particular. Thus, the graphics application  is capable of efficiently operating in conjunction with graphical acceleration units  of different configurations."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention can be better understood with reference to the following drawings. The elements of the drawings are not necessarily to scale relative to each other, emphasis instead being placed upon clearly illustrating the principles of the invention. Furthermore, like reference numerals designate corresponding parts throughout the several views.",{"@attributes":{"id":"P-00011","num":"00011"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00013","num":"00013"},"figref":"FIG. 3","b":"2"},{"@attributes":{"id":"P-00014","num":"00014"},"figref":"FIG. 4","b":"2"},{"@attributes":{"id":"P-00015","num":"00015"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"P-00016","num":"00016"},"figref":"FIG. 6","b":"2"},{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 7","b":"2"},{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 8","b":"2"},{"@attributes":{"id":"P-00019","num":"00019"},"figref":"FIG. 9","b":"8"},{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 10","b":"2"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":"FIG. 11","b":"10"}]},"DETDESC":[{},{}]}
