---
title: Remote monitoring of computer programs
abstract: Computer software and hardware provide for remotely monitoring the execution of computer programs. Monitoring instructions are added to the computer program so that during execution of the program, data is collected regarding the program execution. The collected data may be automatically sent to a remote system or site for analysis. The monitoring instructions create little or no performance impact on the client yet provide valuable information to the developer of the program. Additionally, the monitoring instructions may be changed during computer program development.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07299455&OS=07299455&RS=07299455
owner: Cisco Technology, Inc.
number: 07299455
owner_city: San Jose
owner_country: US
publication_date: 20030815
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation-in-part of U.S. application Ser. No. 08\/460,516, filed Jun. 2, 1995 now abandoned, which is hereby incorporated by reference for all purposes.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the xerographic reproduction by anyone of the patent document or the patent disclosure in exactly the form it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The Microfiche Appendix (17 fiche with total of 1027 frames) includes source code for implementing an embodiment of the invention.","The present invention is related to remote monitoring of computer programs and, more particularly, to a adding remote monitoring instructions to a computer program so that the execution of the computer program may be monitored at a remote site.","As computer systems increasingly become more powerful and complex, so too do the computer programs that operate upon these computer systems. The increased complexity has resulted in much longer development times. Currently, computer programs take months and sometimes years to progress from pre-alpha through beta and final release.","Developers have long realized that when a computer program is very complex, it is more efficient to have customers run the computer program (typically beta versions) so that the full functionality of the computer program in different environments may be exercised. Few developers have the people, machines and time to do the testing that may be provided by their customers.","There are many problems that are presented with beta testing computer programs. Many of the problems revolve around the fact that the developer is at a remote site from the customers. At the remote site, it is difficult for the developer to know what is happening on a customer's computer system. Most customers do not have the expertise or resources to effectively convey problems to the developer. Without adequate information, it may be nearly impossible for a developer to correct a problem.","The preceding is just one of the problems presented to a developer that is trying to develop a computer program that is running at a customer's site. Other problems include customers having platform differences, dealing with the evolving computer program through to final release, upgrading customers' computer programs, tracking bugs, analyzing multi-tasking or multi-threaded applications, and developing multi-vendor applications just to name a few.","The present invention provides innovative systems and methods for remotely monitoring the execution of computer programs. Monitoring instructions (or data collecting instructions) are added the computer program so that during execution of the program, data may be collected regarding the program execution. The collected data may be automatically sent to a remote system or site for analysis. The present invention creates little or no performance impact on the client yet provides valuable information to the developer of the program.","In one embodiment, the present invention provides a method of remotely monitoring execution of a computer program in a computer system, comprising the steps of: modifying the computer program to include at least one monitoring instruction; executing the computer program; the at least one monitoring instruction collecting data regarding the execution of the computer program; and sending the collected data to a remote system.","In another embodiment, the present invention provides a distributed computer system, comprising: a server computer; a client computer in communication with the server computer; and a computer program running on the client computer that includes monitoring instructions that collect and send data regarding execution of the computer program to the server computer.","In another embodiment, the present invention provides a computer program product for remotely monitoring execution of a computer program, comprising: a computer readable storage medium storing the computer program comprising: code that calls at least one monitoring instruction, the at least one monitoring instruction collecting data regarding the execution of the computer program; and code that sends the collected data to a remote system","Other features and advantages of the present invention will become apparent upon a perusal of the remaining portions of the specification and drawings.","The present invention provides a remote data collection facility that may be utilized for developers to monitor a program under test (PUT). A PUT is therefore a computer program or application that has been distributed to a client (or other site) for which the developer would like to monitor the execution remotely. This remote monitoring may be performed from pre-alpha through beta and final release. In a preferred embodiment, the present invention is incorporated in Purevision (PV) which is available from Pure Software Inc., Sunnyvale, Calif.","In the description-that follows, the present invention will be described in reference to an IBM compatible computer running under one of the Windows family of operating systems. The present invention, however, is not limited to any particular computer architecture or operating system. Therefore, the description the embodiments that follow is for purposes of illustration and not limitation.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 1","FIG. 1","FIG. 2"],"b":["1","3","5","7","9","11","11","13","7","15","17","7"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 1"],"b":["1","1","3","9","1","102","104","106","108","112","116","118","120","102"]},"Arrows such as  represent the system bus architecture of computer system . However, these arrows are illustrative of any interconnection scheme serving to link the subsystems. For example, a local bus could be utilized to connect the central processor to the system memory and display adapter. Computer system  shown in  is but an example of a computer system suitable for use with the present invention. Other configurations of subsystems suitable for use with the present invention will be readily apparent to one of ordinary skill in the art.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","b":["202","204","206","208","208"]},"The computer system that monitors a PUT will be designated a \u201cserver\u201d and a computer system on which the PUT executes will be designed a \u201cclient.\u201d For simplicity, the server computer will be described as the computer system that performs development of the PUT and remote monitoring of execution of the PUT. However, the development and remote monitoring may be performed on entirely different computer systems and at different locations.","A client executes the PUT which includes additional monitoring instructions for collecting data regarding the PUT execution. The collected data may be stored locally on the client until it is transferred to the server for analysis. The collected data is sent or transferred to the server via a transport mechanism.","The present invention provides a platform independent application programming interface (API) for directing the data collection for an executing PUT. As shown, client  is operating under the Unix operating system. In contrast, client  is operating under one of the family of Windows operating systems. The API of the present invention (PV API) is portable as a same set of API calls apply to PUTs running on both operating systems. This functionality allows developers to create a single source tree across different platforms. Although platform-specific API calls may be provided, these calls will be ignored if the platform is incompatible.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIGS. 5 and 6"],"b":"302"},"At least one PV API call is placed in the PUT source code at step . The PV_Start call may be added to the PUT source code to start monitoring of the PUT during execution. Data will be collected regarding the execution and, in a preferred embodiment, the collected data will be automatically sent to the server. The data is typically collected until the PUT finishes execution. Other PV API calls may be utilized to customize the data collection. Thus, developers may dynamically change the data that will be collected over the application development cycle from pre-alpha to beta through final release.","At step , the PUT is compiled and linked into an executable computer program. After the PUT is a computer program that incorporates remote monitoring instructions, the PUT is sent to the client. The PUT may be sent to the client in any number of ways including networks and magnetic media like floppies.","Once the PUT is installed on the client, the PUT is executed at step . Although multi-tasking and multi-threaded applications perform tasks in parallel, each task or thread essentially operates by executing statements in sequential order. Accordingly, in discussing this figure, all applications will be generalized to this sequential execution of statements.","At step , the next statement is retrieved. The client then determines if the statement is a PV API call at step . If it is not, the PUT statement is executed at step . A PUT statement is basically any statement that is not a PV API call for remote monitoring.","The client calls the PV API specified by the statement at step . There are numerous types of PV API calls that may be called including calls that perform the following:\n\n","The PV API calls allow the developer to specify characteristics of the data that will be collected during a PUT run. For example, in addition to the developer being able to turn data collection on and off at locations in the PUT with PV_On and PV_Off, the developer is also able to specify that data collected under a given type should be discarded (e.g., to reduce the amount of collected data that is sent to the server). Additionally, the developer may specify that data collected will be stored in a database table with the calls PV_DBAddStringToRow and PV_DBAddIntToRow. Thus, the developer is provided great flexibility in specifying what data will be collected and how the data will be available.","At step , it is determined whether the PUT is finished executing. If it is not, execution resumes at step  where the next statement is retrieved. Otherwise, the client performs END-HOOK data collection at step . In a preferred embodiment, END-HOOK is the mechanism in Windows through which data is collected after the PUT terminates or crashes. In order to aid the developer in tracking down crashes, information regarding the hardware, operating system, PUT (e.g., version number), and the like may be automatically collected to indicate the environment of the client. In a preferred embodiment, this information is automatically collected with a single API call, PV_Start.","Once the data is collected regarding the PUT execution, the data is sent to the server at step . Once at the server, the data may be analyzed. The data may be analyzed to fix bugs in the PUT, track feature utilization, optimize execution of the PUT, and the like.",{"@attributes":{"id":"p-0047","num":"0052"},"figref":"FIG. 5","b":["402","404"]},{"@attributes":{"id":"p-0048","num":"0053"},"figref":"FIG. 6","b":["452","454","456"]},"Additionally, PV API calls are also added to call table  so that the appropriate routines in the PV library will be called. As an example,  shows that a PV API call PV_EndRunNow may cause the execution of the END_HOOK routine in the PV library. The PV_EndRunNow terminates the data collection on the client but allows the PUT to continue execution.",{"@attributes":{"id":"p-0050","num":"0055"},"figref":["FIG. 7","FIG. 7"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["1. PUT Normal Exit\u2014exiting by invoking a member of the exit family of routines or returning from the main routine","2. PUT exec( )\u2014invoking a different executable by successfully calling exec","3. PUT Exception Caught by Developer\u2014catching an exception or signal in an exception handler and invoking exit from the handler","4. PUT Exception Uncaught by Developer\u2014encountering an uncaught exception","5. PUT Dies via uncatchable event\u2014encountering an uncatchable event (e.g., stack overflow or kill process)","6. Developer ends run before PUT ends\u2014PV API call to stop data collection (PV_EndRunNow)","7. Purevision Dies via an unexpected event\u2014the data collection software of the present invention halts (e.g., power off or internal error)"]}}}},"All of the above end-of-run types except for 4. would pass through the modified call table. The information available indicates the information the present invention may analyze and include in the data collected that will be sent to the server.",{"@attributes":{"id":"p-0052","num":"0064"},"figref":"FIG. 8","b":"502"},"At step , the PUT run is classified. The PUT run is classified as either a normal or abnormal run. In Windows, an abnormal run is defined as a PUT that terminates with an uncaught exception or with a caught exception followed by a non-zero exit code. Similarly, on Unix an abnormal run is defined as a PUT that terminates with an uncaught signal or exits with a non-zero exit code.","Data is collected for the end-of-run at step . As mentioned earlier, information regarding the hardware, operating system, PUT (e.g., version number), user identifier, PUT start time, PUT execution duration, exit code, exit exception, and the like may be automatically collected to indicate the environment of the client at an end-of-run. Additionally, in the event of an abnormal run, stack information of the client may be collected for analysis on the server.","At step , the collected data is sent to the server. The server may then remotely analyze the data it receives. If the end of the PUT is reached at step , the PUT is exited at step . Otherwise, the PUT continues execution at step . In a preferred embodiment, the collected data is automatically transmitted to the server without requiring the client to issue a command to send the collected data.","Although the present invention provides a default mechanism for handling end-of-run situations, it also allows the developer to customize end-of-run processing. The PV API PV_RegisterEndHook allows a callback function to be defined that will be utilized instead of the default end-of-run processing. The custom END_HOOK processing is shown as step  in .",{"@attributes":{"id":"p-0057","num":"0069"},"figref":"FIG. 9"},"At step , the PUT is compiled with the source code including PV API calls to collect data for remote debugging. A module map is created during compilation and it is stored at step . The module map is essentially a table that for each module in the PUT source code contains the address and offset of every function in the module. Typically, the module map is stored on nonvolatile storage (e.g., a hard drive) on the server.","The executable PUT is sent to the client at step . On the client-side, the PUT is executed at step . When an end-of-run is encountered, the END_HOOK directs the client to save both the call stack and the module list at step . The call stack is a list of addresses of function calls that were sequentially invoked during the PUT execution. The call stack is therefore generated while the PUT runs.","The module list is a list of modules, including modules in the executable and any DLLs, along with the base address and size of each module. The module list is also created while the PUT runs.","At step , the client generates a module name\/relative virtual address (RVA) list. The module name\/RVA list is generated from the call stack and the module list. The module name\/RVA list shows the sequence of function calls as a list of module names and relative offsets into each module. Typically, the module name\/RVA list is generated during end-of-run processing.","The module name\/RVA list is sent to the server along with any other collected data at step . On the server, a symbolic call stack is generated from the module map and the module name\/RVA list at step . The symbolic call stack is the sequence of functions calls including the module name, function name, and offset into the function for each call. Utilizing the symbolic call stack, the PUT may be remotely debugged on the server at step . In a preferred embodiment, the present invention also reports uniqueness of the call stacks so that a developer may more quickly determine if the same problem is occurring on other clients' computers.",{"@attributes":{"id":"p-0063","num":"0075"},"figref":"FIG. 10"},"As an example, step  shows a PUT running on the client computer. During execution, a PV API call (e.g., PV_Start) sends the PUT version number to the server at step . The server receives the PUT version number and determines if the version is current at step . If the version is not current, the current version (or a patch) may be downloaded to the client at step . Additionally, the client may be queried as to whether it is desirable to get an upgrade in the event that they would prefer to retain the older version for any number of reasons (e.g., stability).","Whether a new version is downloaded or not, the PUT continues execution at step . Utilizing this process, the developer is able to accurately track which clients are running what versions of software. Additionally, as the developer is able to more quickly upgrade older versions, the testing of the program is more efficient as clients do not continue to run older versions reporting old problems or bugs.",{"@attributes":{"id":"p-0066","num":"0078"},"figref":"FIG. 11","b":["652","654"]},"A bug tracking application  is designed to track the bugs that are found in the PUT and other information regarding the bug. When an event occurs during execution of the PUT that necessitates reporting (e.g., a bug), a PV API call is utilized to collect the data for reporting the event to the bug tracking application.","The bug tracking application may receive the information it requires directly from the clients or the clients may send information to the server with the server collecting the information. The server may then format the collected bug information and sends it to the bug tracking application. Additionally, a PV API call may send collected data to more than one server if this is desirable for the developer.",{"@attributes":{"id":"p-0069","num":"0081"},"figref":"FIG. 12"},"As shown, a server computer  is in communication with a client computers  and . Programs A and B are running on one client and program C is running on another client. Although A and B are described as programs, they may also be threads of the same program. Programs A, B and C are running concurrently and separate data is collected for each program (although the data may be stored on the same hard driver, it is shown separate for clarity). In a preferred embodiment, PV_Start returns a handle that may be utilized to uniquely identify a program or thread. The other PV API calls may receive this handle as a parameter so that data for each program or thread is collected together.","In a preferred embodiment, the data collected for each program includes timestamps as to when the program began running. Additionally, information that indicates what program invoked another program may be collected. Once this collected data is received by the server, the server will be able to reconstruct the sequence of program execution on the clients.",{"@attributes":{"id":"p-0072","num":"0084"},"figref":"FIG. 13","b":"752"},"Although the above has described modifying the source code to include PV API calls for data collection, the present is not limited to any specific method. For example, the present invention may utilize object code processing that inserts the data collection instructions into the object code of the PUT.",{"@attributes":{"id":"p-0074","num":"0086"},"figref":["FIG. 14","FIG. 1"],"b":["802","804","806"]},"The Microfiche Appendix includes source code for implementing an embodiment of the invention. The source is written in C++ and is designed for an IBM compatible computer running under one of the Windows family of operating systems.","Appendix A, a PureVision Unix & Windows API Specification, and Appendix B, a PureVision Programmers' Guide, are filed herewith as part of the application and are incorporated by reference for all purposes.","While the above is a complete description of the preferred embodiments of the invention, various alternatives, modifications and equivalents may be used. It should be evident that the present invention is equally applicable by making appropriate modifications to the embodiments described above. Therefore, the above description should not be taken as limiting the scope of the invention which is defined by the metes and bounds of the appended claims."],"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","MICROFICHE APPENDIX","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
