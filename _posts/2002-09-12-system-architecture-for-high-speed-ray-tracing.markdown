---
title: System architecture for high speed ray tracing
abstract: A system and method for generating images of three-dimensional objects. The system includes one or more tracing processors, and one or more shading processors. Each of the tracing processors may be configured to (a) perform a first set of computations on a corresponding group of primary rays emanating from a viewpoint resulting in a ray tree and a set of one or more light trees for each primary ray of the corresponding group, (b) transfer the ray trees and associated light trees to one of the shading processors, and (c) repeat (a) and (b). Each of the shading processors may be configured to (d) receive ray trees and associated light trees from one of the tracing processors, (e) perform a second set of computations on the received ray trees and associated light trees to determine pixel color values, and (f) repeat (d) and (e) a plurality of times.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07012604&OS=07012604&RS=07012604
owner: Advanced Micro Devices, Inc.
number: 07012604
owner_city: Sunnyvale
owner_country: US
publication_date: 20020912
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates to a system for generating images, and more particularly, to a ray-tracing system for generating images of three-dimension scenes in real-time.","2. Description of the Related Art","Ray tracing is the term used to describe a method for generating images of three-dimensional scenes. The method involves sending out a system of rays from a viewpoint in a world space. The world space may be populated by a collection of three-dimensional objects. Color values are computed for each of these rays, and the color values determine the pixels of a displayable image. To compute a color value (e.g. a RGB color vector) for a given ray may involve a set of computations such as the following. The point where the ray encounters its first intersection with an object may be determined. At this \u201cprimary\u201d intersection point, a reflection ray and a transmission ray may be determined. (The transmission ray may be computed on the basis of Snell's law of optics.) The reflection ray and transmission ray propagate until they intersect with an object. At each of these two \u201csecondary\u201d intersection points, new reflection and transmission rays may be determined. Now the four rays propagate until they hit four intersection points. For the sake of discussion, assume the propagation of rays stops with the four intersection points. Next, a local lighting computation is performed at the four intersection points to determine color values. Then color values at the two secondary intersection points are determined based on local lighting and some linear combination of the color values at the four intersection points. Finally, a color value at the primary intersection point is determine based on local lighting and a linear combination of the color values at the secondary intersection points. Obviously the number of intersection points grows exponentially with the number N of ray spawning stages. Thus, ray tracing is a computationally expensive process. However, the images generated with ray tracing are often more realistic and\/or visually pleasing than images generated by other means. Thus, in general, there exists a need for systems and methodologies for performing ray tracing with increased speed.","In one set of embodiments, a visualization system for generating images of three-dimensional objects may include one or more tracing processors, and one or more shading processors. Each of the tracing processors may be configured to:\n\n","The first set of computations may operate on a set of vertices and corresponding normal vectors. The set of vertices define triangles for objects in a scene (e.g. a frame in a 3D animation or a computer-aided design). The normal vectors represent surface normals for the objects. Nodes of the ray tree correspond to intersections between the objects and rays derived from the primary ray. Each of the light trees includes lighting information with respect to a corresponding light source for each of the intersections in the associated ray tree. In some embodiments, other types of graphical elements (such as higher-order surfaces, etc.) may be supported in addition to or instead of triangles or polygons.","The first set of computations may include repeated applications of a ray tracing computation, a shadow information computation and a ray spawning computation. The ray tracing computation propagates a ray to determine an intersection with a nearest object along the ray's path. The shadow information computation determines the visibility (or amount of visibility) of one or more light sources at the intersection point. The ray spawning computation computes a reflective ray and transmissive ray at the intersection.","The ray spawning computation may be application programmable by a software application executing on a host computer (e.g., a desktop computer, a workstation, a computer coupled to the visualization system through one or more networks, etc.). In one embodiment, a ray spawning computation may be determined by ray spawning code transferred to each of the tracing processors in response to one or more commands asserted by the software application. In addition, the shadow information computation may be application programmable by a software application executing on a host computer.","The second set of computations may include a global lighting combine operation which combines information from the ray tree and the associated light trees in a bottom-up fashion to determine the pixel color. The global lighting combine operation may be application programmable by the host software application.","In another set of embodiments, a method for generating images of three-dimensional objects may be arranged as follows. A host program executing on a host computer may invoke the transfer of ray spawning code to a first processing unit. The first processing unit may perform a first set of computations to determine a ray tree and one or more light trees. The first set of computations may include one or more ray tracing operations and one or more ray spawning operations. The first processing unit performs the ray spawning operations by executing the ray spawning code. The first processor transfers the ray tree and the associated light trees to a second processing unit. The second processing unit performs a second set of computations on the ray tree and associated light trees to determine pixel color. The pixel color determines a pixel in an output image. The output image may be a frame in a real-time video stream.","In yet another set of embodiments, a system 3D image generation system may include one or more tracing processors and one or more shading processors. The tracing processors may be configured to generate ray trees corresponding to primary rays emanating from a viewpoint in an object space. The shading processors couple to the tracing processors and may be configured to operate on the ray trees to generate pixel values. The pixel values determine an output image. One or more of the tracing processors may include a general-purpose CPU as the algorithms for accelerating ray tracing performance are expected to improve over time. The shading processors may include specialized processors configured to support a virtual graphics language.","The number and type of tracing processors, and the number and type of shading processors may vary from one implementation to the next. A designer of the visualization system may determine these numbers and types to achieve a desired balance of cost and performance. To support maximum flexibility in the range of choices available for the tracing processors and the shading processors to be incorporated in the visualization system, the data structures which are transferred from the tracing processors to the shading processors are configured to be application programmable.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","1. General","Ray tracing is a very compute intensive process. However, next generation central processing units (CPUs) and multi-processor (MP) systems will be more capable of delivering the computer power required for real time ray tracing (RTRT).","Ray tracing may be performed with different types of graphical elements such as triangles, spheres and parameterized surfaces (e.g. higher-order surfaces determined by control parameters). The following discussion focuses mostly on the use of triangles. However, the mechanisms described herein may be used with a variety of different element types.","In one set of embodiments, a method for rendering three-dimensional objects (or N-dimensional objects where N is a positive integer) may be arranged as illustrated in .","Stage : Transformation\n\n","Stage 1A: Global Light preprocessing\n\n","Stage : Tracing\n\n","Stage : Shading\n\n","Each of these stages may use its own processor (or set of processors). In the following descriptions the processor for the transform stage  is called the transform processor (XFP); the processor for the tracing stage  is called the tracing processor (TRP), and the processor for the shading stage  is called the shading processor (SHP).","Any or all of these stages may be parallelized. Thus, any or all of the XFP, TRP and SHP may include multiple parallel physical processors. In some embodiments, parallelizing the transform and tracing stages may involve two or more intermediate buffers, e.g. a first buffer to store the transformed triangles of a scene, and a second buffer to store the corresponding object descriptors (i.e. materials, textures, etc.).","In one embodiment, the TRP performs the transform stage processing as well as the tracing stage processing. Thus, the XFP and the intermediate buffers between the XFP and TRP may be eliminated in this embodiment.","2. Architecture of the Processors","Each of the XFP, TRP and SHP may be realized by a general purpose CPU or a specialized processor (SP). As used herein, the term \u201cspecialized processor\u201d includes any circuit, device or system whose hardware organization has been optimized to perform a set of graphical computations such as three-dimensional rendering computations. Specialized processors may have fixed functionality, or alternatively, may have varying levels of programmability. For example, a specialized processor may be configured to support a graphics API (application programmer's interface) such as DirectX 8 Vertex Virtual Machine (DX8 VVM), Renderman, OpenGL and so on. The AR250 chip manufactured by Advanced Rendering Technology is an example of a specialized processor.","One or more specialized processors may be used to implement the XFP because the transform stage operations are well defined. However, in some alternative embodiments, one or more general-purpose processors may be used to implement the XFP.","As noted above, in some embodiments the transform stage processing may be performed by the TRP, and thus, the XFP may be omitted.","Algorithms for improving the performance of ray tracing rely on reducing the number of intersection tests rather than speeding up the intersection tests. These algorithms are expected to change and improve over time. Furthermore, these algorithms involve conditional branching operations (such as \u201cif condition X is true, execute Y; else execute Z\u201d). Thus, in one set of embodiments, the TRP may be realized by a set of one or more general-purpose CPUs. As used herein, the term \u201cgeneral-purpose CPU\u201d is intended to include any of a variety of microprocessors or microprocessor-based systems such as those manufactured by Advanced Micro Devices, Inc.","The shading stage operations are fairly stable and have mostly linear control flow (i.e. do not require branches very often). Furthermore, the shading stage operations are very compute intensive (e.g., as when multiple textures and bump mapping are applied). These properties suggest that specialized hardware may be of benefit for implementing the SHP. Thus, in one set of embodiments, the SHP may be realized by a set of one or more specialized processors.","In one set of embodiments, the TRP is implemented using a general-purpose CPU, and the SHP is implemented using a specialized processor.","In one alternative embodiment, the SHP is implemented with a general-purpose CPU.","In some embodiments, either or both of the TRP and the SHP may be realized by multiple parallel processors. Support for symmetrical multi-processing (SMP) may be implemented in the system architecture of these embodiments.","2.1 Application Programmable TRP and SHP","In addition to being programmable, a processor (such as the XFP, TRP or SHP) may be application programmable. As used herein the term \u201capplication programmable\u201d as applied to a processor means that a software application running on a host computer can specify the functionality of the processor (i.e. the computational algorithms to be performed by the processor). For example, in one set of embodiments, the software application may specify the functionality of the processor by calling pre-defined functions of an API (e.g. a graphics API such as OpenGL or DirectX 8 Vertex Virtual Machine). The API functions have a well-defined software interface that application developers can rely upon. Furthermore, the API functions handle the hardware-oriented details of interacting with the processor.","In another set of embodiments, the software application may specify the functionality of the processor by downloading machine code to the processor. The processor executes the machine code to enact the application specified functionality.","In yet another set of embodiments, the software application may specify the functionality of the processor by downloading a set of machine-independent instructions to a translation agent. The translation agent may translate the machine-independent instructions into machine code executable by the processor, and forward the machine code to a memory accessible by the processor.","In one set of embodiments, the TRP and the SHP are application programmable. Thus, the functions performed by the TRP and the SHP may be defined by a software application (within the limits of programmability imposed by selections of a TRP and an SHP).","Certain operations or algorithms within the tracing stage and\/or shading stage may be defined by the software application using a virtual graphics language (VGL) such as Microsoft's DX8 VVM, OpenGL or Renderman. As defined herein, the term \u201cvirtual graphics language\u201d refers to a language which allows programmers to invoke graphics operations in a hardware-independent fashion.","In one collection of embodiments, the programmability of the different stages is as follows.","Transform.\n\n","Tracing\n\n","Shading\n\n","The local lighting computation may include the computation of diffuse and\/or specular color values at the intersection points.","The application program may rely on predefined standard instruction sequences (e.g. may call macros comprising such predefined instruction sequences) to specify the application programmable portions of the transform, tracing and\/or shading stages.","In one set of embodiments, the operation of a real-time ray tracing system may be described as follows.\n\n","In some embodiments, the TRP may implement the operations described by the following pseudeo-code:",{"@attributes":{"id":"p-0052","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"while (!EndScene)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Get object."]},{"entry":[{},"for (all vertices of object)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Call VGL code to transform vertices from model to world space."]},{"entry":[{},"VGL code may use input streams directly, or alternatively,"]},{"entry":[{},"the TRP may setup input registers before calling the VGL code."]},{"entry":[{},"Update bounding values."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Add object to object list."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"Perform tracing in batches of Nrays."},{"entry":"Update interface structure and set status flag to the ready-to-shade state"},{"entry":"(i.e. enabled state)."},{"entry":"Call VGL code to compute reflective and transmissive rays."},{"entry":"Eventually call VGL code for local lighting."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"sub":["B ","B "]},"In some embodiments, the SHP may implement the operations described by the following pseudo-code:",{"@attributes":{"id":"p-0054","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"while (1)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Check status flags;"]},{"entry":[{},"for (each enabled status flag)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Setup input registers accordingly;"]},{"entry":[{},"Call VGL code for SHP;"]},{"entry":[{},"Write result to frame buffer;"]},{"entry":[{},"Disable the status flag;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The TRP may process multiple rays before passing the results to the SHP. This batch processing methodology makes the TRP processing and interfacing (with SHP) more efficient. Thus, assume that the TRP processes Nrays in a batch. For example, Nmay equal 16 in one embodiment. Also, assume that each ray tree has a depth DR, where DR is a positive integer. For example, if DR equals three, reflective and transmissive rays are spawned up to the third intersection as suggested by . Thus, in this example, there are a total of 7 ray segments (1+2+4) per pixel.","In one set of embodiments, the TRP may perform the following ray-processing sequence:\n\n","Early termination of the rays (e.g. no reflective ray) is handled within the corresponding steps. The appropriate intermediate data is stored in the corresponding BatchRayTree and LightRayTree structures.","3.1 Tracing Processsor (TRP) Operation","In some embodiments, the TRP may perform the following operations.","A. Transformation\n\n","B. Tracing of rays\n\n","C. Determine Local Lighting\n\n","D. Transfer to SHP\n\n","In various embodiments, the SHP may have varying computational capabilities. The TRP may be configured to interface with SHPs which span a spectrum of computational capabilities. The host application may provide the TRP with an indication of the computational capabilities of the specific SHP with which it will interact.","In one embodiment of the SHP, the SHP may be configured to perform local lighting. In this case, the TRP will not perform the local lighting computation; instead it will pass the necessary parameters to the SHP. The TRP determines for a given light source, whether the light source is visible (no shadow) or invisible (shadow) from a given intersection point. The resulting information is then stored in the corresponding light tree.","If the SHP cannot perform local lighting, the local lighting code (e.g. VGL code) may be executed by the TRP before passing the results to the SHP.","In one set of embodiments, the SHP capabilities (as represented by the SHP_CAPS indicator) may be classified as follows.\n\n","For the sake of simplicity, in many of the examples to follow, it may be implicitly assumed that the SHP performs the local lighting computation. However, it should be borne in mind that the TRP may be configured to perform local lighting in embodiments where the SHP is not so configured.","4. Interface","It is very desirable to create a flexible interface between the TRP and the SHP, i.e. an interface that will allow the various embodiments of the SHP to perform tasks of varying complexity.","Therefore the data structures may be divided up into two main structures. An additional static parameter structure may contain static parameters for the light source and the attenuation factors for the distance traveled. The static parameter structure may change infrequently. For example, it may be static for at least one frame. This static parameter structure is further defined in section 4.4.","The two main data structures may contain information corresponding to a batch of NB primary rays (e.g. N=16).","The first structure BatchRayTree contains the NRayTree structures corresponding to the Nprimary rays. The RayTree structures contain intersection information.","The second structure BatchLightTree contains the LightTree structures for the Nrays. The LightTree structures contain the lighting related information. One LightTree structure is generated per primary ray and per light source. The BatchLightTree structure may be a simple array of LightTree structures. Each primary ray of a batch is associated with a segment of the array. For example, if two light sources are used, the lighting information for primary ray # can be found at index  and ; for primary ray # at index  and . So the size of the array may be:\n\n*MaxNumLights.\n","This BatchLightTree organization has the advantage that all the lighting information spans one contiguous memory region. The same applies to the BatchRayTree structure. The TRP may then maintain only two pointers, one to the RayTree and another to the LightTree structure.","This is done to allow the SHP to effectively DMA or access the data with just two pointers.","In some embodiments, a buffer memory may intervene between the TRP and SHP. The TRP writes the BatchRayTree data structures and the BatchLightTree data structures to the buffer memory, and the SHP reads these data structures from the buffer memory. The buffer memory may be double buffered to allow overlapped TRP and SHP operations. Swapping of buffer segments in the memory buffer may occur on frame boundaries.","The RayTree and LightTree data structures may also be used as the internal data structures of the TRP. Thus, no unnecessary copying of data is required.","In one set of embodiments, the Batch structures may be defined as follows:",{"@attributes":{"id":"p-0078","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct tstBatchRayTree {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"stRayTree RayTree[RTRT_NUMBATCHRAYS];"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} stBatchRayTree;"]},{"entry":[{},"typedef struct tstBatchLightTree {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stLightTree LightTree[RTRT_NUMBATCH-"]},{"entry":[{},"RAYS*RTRT_MAXNUMLIGHTS];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} stBatchLightTree;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The structure of the ray tree and the structure of the light tree may be very similar. They may have the same node topology, but their nodes may contain different information. The ray tree may contain intersection information, whereas the light tree may contain lighting information at a given node.","A ray tree having depth D has 1+2+4+ . . . +2=2\u22121 nodes. For example, for depth D=3, the ray tree has seven nodes. Each node stores information concerning a corresponding intersection point. Each local light structure may have the same depth and number of entries as suggested by .","4.1 Symmetric Multi-Processing (SMP) Support","In one set of embodiments, the TRP and\/or the SHP may support multiple processors (e.g. symmetric multi-processors). The TRPs may communicate to the SHP which rays in a batch are ready to be processed and which are not. Therefore, a status flag may be included in each ray tree. The status flag indicates whether a ray is ready to be shaded or not.","Each processor of the TRP operates on a different batch of primary rays. When a primary ray within a batch is ready to be shaded, meaning that the primary ray has been traced completely, the processor sets the status flag to the ready-to-shade state.","When SHP detects that the status flag of a given ray tree is set to ReadyToShade, it will load the shading parameters of the ray tree and its corresponding light trees, and then restore the status flag to the available state. The TRP waits until after a status flag has been set to the available state before putting new information into the ray tree and corresponding light trees.","The buffer (which stores the ray trees and light trees) may contain any number of ray trees as mentioned above. The individual ray trees in the BatchRayTree may be configured (e.g. padded) so that they fall into different cache lines to avoid coherency ping-pong between the different TRP processors. Similarly, packets of light trees belonging to different ray trees may be configured so that they fall into different cache lines.","This flag-based handshaking mechanism is very flexible with regard to the distribution of the rays from the TRP to the SHP. It also hides the nature of the TRP from the SHP. Regardless of whether there is one processor or multiple processors in the TRP, the buffer and the synchronization are identical. This mechanism also avoids the difficulty of having to synchronize the TRP processors before the buffer is updated.","In one set of embodiments, the SHP automatically scans each flag to determine whether to process the corresponding primary ray. Alternatively, to reduce memory traffic, the SHP may use the first flag in a BatchRayTree as a trigger event to process the first primary ray and then scan the other primary rays in the batch.","The stride between successive ray trees in the BatchRayTree may be indicated to the SHP. The stride is a global parameter, and may either be put into the static parameter structure or directly programmed into the SHP.","In addition to multiple TRPs processing multiple batches in parallel, multiple SHPs may also process multiple batches in parallel. The same flag-based handshaking mechanism as described above may be used.","This handshaking mechanism supports any number of TRPs and SHPs without modification. This mechanism allows the number Nof TRP processors and the number Nof SHP processors to be independent. In fact, Nand\/or Nmay be changed dynamically.","4.2 Ray Tree Structure","A ray tree structure contains the intersection information for the rays derived from a single primary ray. The following describes an exemplary structure for the ray tree. It is noted that the ray tree may have any of various structures for various special embodiments. Assuming a depth level of 3, the ray tree structure has 7 entries as follows.",{"@attributes":{"id":"p-0091","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct tstRayTree {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stRayTreeElement InitRay;","\/\/","Initial Ray"]},{"entry":[{},"stRayTreeElement Ray_R;","\/\/","Refl. Ray"]},{"entry":[{},"stRayTreeElement Ray_T;","\/\/","Transm. Ray"]},{"entry":[{},"stRayTreeElement Ray_R_R;","\/\/","Refl._Refl. Ray"]},{"entry":[{},"stRayTreeElement Ray_R_T;","\/\/","Refl. Transm. Ray"]},{"entry":[{},"stRayTreeElement Ray_T_R;","\/\/","Transm._Refl. Ray"]},{"entry":[{},"stRayTreeElement Ray_T_T;","\/\/","Transm._Transm. Ray"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} stRayTree;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"To support multiple processors with SMP for either the TRP and\/or the SHP, the TRPs may indicate to the SHP which primary rays (i.e. which ray trees) are ready to be processed and which are not. Therefore, a status flag may be included in each ray tree. The status flag indicates whether the primary ray (i.e. the ray tree) is ready to be shaded or not. Each processor of the TRP may process different batches of rays.","The stRayTreeElement structure may contain the following information:\n\n","The distance traveled may be used to attenuate the ray contribution. The attenuation function may have any desired form. For example, in one embodiment, the attenuation function may be a quadratic polynomial with three coefficients such as Att(x)=a+bx+cx, where x is the distance traveled from the light source to the intersection point.","4.3 Light Tree Structure","A light tree structure may contain the lighting information for each of the intersection points of a given ray tree for one light source. Each node of the light tree may relate to a corresponding node of the ray tree. There may be one light tree structure for each light source.","In one embodiment, the light tree structure has the following form. Assuming a depth level of 3, the light tree structure has 7 entries as follows.",{"@attributes":{"id":"p-0097","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct tstLightTree {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stLightTreeElement InitRay;","\/\/ Initial Ray"]},{"entry":[{},"stLightTreeElement Ray_R;","\/\/ Refl. Ray"]},{"entry":[{},"stLightTreeElement Ray_T;","\/\/ Transm. Ray"]},{"entry":[{},"stLightTreeElement Ray_R_R;","\/\/ Refl. Refl. Ray"]},{"entry":[{},"stLightTreeElement Ray_R_T;","\/\/ Refl. Transm. Ray"]},{"entry":[{},"stLightTreeElement Ray T_R;","\/\/ Transm. Refl. Ray"]},{"entry":[{},"stLightTreeElement Ray T_T;","\/\/ Transm. Transm. Ray"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} stLightTree;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The SHP uses the light tree as an input. The VGL shader code and the SHP capabilities indicator determine what kind of processing can be performed by the SHP.","The state of the SHP capabilities (SHP_CAPS) indicator may determine what information is stored in the stLightTreeElement structure. If the SHP can perform local lighting (e.g. SHP_CAPS=SHP LOCL_X), then the TRP will put the appropriate information including shadow flag into the light tree. The SHP will then perform local lighting and the global lighting combine step as described below.","If the SHP cannot perform local lighting (e.g. SHP_CAPS=SHP_NULL), the TRP will perform the local lighting, and store the final diffuse and specular values for each intersection point into the light tree structure. The SHP will then perform the global lighting combine step.","Thus, the stLightTreeElement structure may be assembled according to the state of the SHP_CAPS indicator.","In some embodiments, the stLightTreeElement structure may contain the following information.","Local Lighting information",{"@attributes":{"id":"p-0103","num":"0000"},"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":["A. Diffuse color (0 if in intersection is in shadow).\n    \n    ","B. Specular color (0 if intersection is in shadow).\n    \n    ","C. Color3: Color3 is an additional color which may be generated by the TRP. It may represent, e.g., the color of a photon map lookup. This color may be useful if the SHP is programmable. For example, an algorithm programmed with VGL code may use this color.","D. Shadow flag: equals one if intersection point is in shadow; otherwise the light source is visible from the intersection point.","E. Transparency coefficient: multiplies the text alpha during tracing step.","F. Reflectance coefficient: may be modified with a TBD value during tracing. (TBD is an acronym for \u201cto be determined\u201d)."]}},"The following entries may be used if the SHP performs local lighting (e.g. SHP_CAPS=SHP_LOCL_X):\n\n","The static parameter structure may contain parameters which are static for at least one frame. It may contain the following entries.\n\n","The light source parameters may be stored in an array. The index used to access successive records in this array may be identical to the index used to access successive light trees in the BatchLightTree. This one-to-one correspondence makes addressing easy.","If it is anticipated that the light source parameters will change frequently, the light source parameters may be appended to the light trees. The light source parameters for a given light source may be appended to the corresponding light tree. Similarly, the attenuation factors may also be appended to the ray trees.","5. Global Lighting Combine","The global lighting combine (GLC) step may be performed after the local lighting step and before rasterizing the pixel. The GLC step may be application programmable (e.g. with VGL instructions).","The GLC step combines the local lighting values in a light tree. Initially, the diffuse and specular components may be added to obtain a local color value at each node of the light tree. (Recall that the nodes of the light tree correspond to the intersection nodes of the ray tree). In one set of embodiments, the light tree may then be processed (in conjunction with the ray tree) from bottom to top as follows:\n\n","The example above has been described in terms of a ray tree and light tree with depth D=3. However, the example naturally generalizes to trees of arbitrary depth.","The example above illustrates one possible method for performing the GLC step, and is not intended to be limiting. A wide variety of methods are contemplated. In fact, the specific method to be used may be determined by the application designer (e.g. through VGL code programming).","Texturing may apply any desired transformation to the local lighting. Texture alpha values may be used during tracing to determine transparency. A final transparency coefficient is determined in the tracing stage and placed into the tracing coefficient field of the light tree. The pOBJ descriptor contains information on how to compute the final transparency value from the object transparency and the texture alpha value (TBD).","An example of the GLC computation is shown below. For the sake of simplicity, part of the computation is suppressed. However, the suppressed portion (i.e. the computation of Tot_T) may easily be derived based on parallelism of structure with respect to the disclosed portion (i.e. the computation of Tot_R). \n\n\nwhere,\n\n","In one set of embodiments, the transfer of ray trees and light trees between the TRP and SHP may be distributed across multiple links as described in the following. In one embodiment, one or more of these links could be realized by the Lighting Data Transfer Busses (LDTs) manufactured by Advanced Micro Devices (AMD).","In some embodiments, multiple parallel TRPs and SHPs are utilized. Logically, there are three distinct cases regarding the number Nof TRPs and the number Nof SHPs:\n\n","These three cases are described in more detail in the following sections.","6.1 Identical count of TRPs and SHPs","Suppose that the number of TRPs and the number of SHPs are identical. In one set of embodiments, each TRP may couple to a corresponding SHP through a dedicated link as suggested by . Thus, the total transfer bandwidth is the sum of the bandwidths of all links.","In some embodiments, the links are configured so that almost all of the data is transferred through the links in one direction: i.e. downstream from the TRPs to the SHPs. In one particular embodiment, the links are configured so that no turnaround is required. Because, the TRP doesn't have to wait for any results from the SHP, high link utilization may be achieved. Also unidirectional dataflow allows more freedom for the computational stages in the TRP to be pipelined heavily without negatively impacting performance.","The SHP may control the state of a ready-to-receive flag. The ready-to-receive flag indicates to the TRP whether the SHP is ready to receive information from the TRP. This ready-to-receive flag may be implemented in the hardware (HW) control flow mechanism of the underlying link. In this case the TRP may check the link to determine whether it may send data or not. On the SHP receiving side, a first-in first-out (FIFO) may buffer the input data.","The SHP may have a FIFO sufficiently deep to store at least a tree bucket (i.e. a ray tree and light trees corresponding to a single pixel). In one set of embodiments, the synchronization mechanism may operate as follows.\n\n","This synchronization mechanism requires little overhead and is fast.","The SHPs may also access some common memory which stores global data such as the object descriptors, texture maps, etc. The SHPs may have special cache memories to decouple accesses to the common memory.","6.2 TRP Count Greater than SHP Count","In the case where the number of TRPs is greater than the number of SHPs, each SHP may receive data from multiple TRPs. The communication between each SHP and the multiple TRPs which feed it may be achieved using a bridge component as suggested by . The bridge combines the multiple TRP links into one link to the corresponding SHP. In the embodiment illustrated in the figure there are four TRPs and two SHPs. However, a wide variety of set of values are contemplated for the number of TRPs and the number of SHPs. As with the embodiments of section 6.1, the SHPs may access a common memory.","The synchronization protocol may be very similar to that described above except that additional information may be used to indicate the TRP which sent a given bucket. This additional information may not be required for the shading process itself but may be used for the transmission of the ready-to-receive flag. Thus, the SHP may selectively control the data transfers for each TRP.","There are at least two possibilities for including the additional information. One possibility is to use the source address of the link as in Advanced Micro Devices' LDT. The second possibility is to include a tag as an additional field in the ray tree structure. The tag identifies the TRP which sent the data. Thus, the SHP may use that information to send the ready-to-receive flag to the corresponding TRP.","6.3 TRP Count Less than SHP Count","In the case where the number of TRPs is less than the number of SHPs, each TRP may send data to multiple SHPs. Each TRP may send data to the corresponding multiple SHPs using a bridge component. The bridge component may connect the single TRP link to multiple SHP links as suggested in . In the illustrated example, there are two TRPs and four SHPs. However, a wide variety of set of values are contemplated for the number of TRPs and the number of SHPs. Again, the SHPs may access a common memory as in section 6.1.","The synchronization protocol may be very to the protocol in section 6.2. However here the additional tag may be used to send the ready-to-receive flag back to the TRP and not to the other SHPs (link addressing).","The TRP may send buckets to the SHPs in a certain order to split up the work load for the SHPs. Multiple distribution methods may be used such as round robin or any of various load-balancing schemes.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":[{"@attributes":{"id":"p-0014","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0024"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
