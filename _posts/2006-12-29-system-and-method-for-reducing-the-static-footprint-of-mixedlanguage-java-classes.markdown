---
title: System and method for reducing the static footprint of mixed-language JAVA classes
abstract: A system and a method for minimizing the functionality-gap between JAVA™ and native platforms while keeping the impact on each JAVA™ API static footprint as small as possible. A JAVA™ Runtime Dynamic Invocation API is used for low-level bridging between JAVA™ and C/C++, enabling the dynamic invocation of native C/C++ functions and C++ class/object methods from the JAVA™ side without adding any additional ad hoc implemented native code to the overall JAVA™ component implementation. Thereby, the need to write new native code when implementing a JAVA™ component that needs to invoke some native functionality is reduced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08756616&OS=08756616&RS=08756616
owner: Core Wireless Licensing S.A.R.L.
number: 08756616
owner_city: Luxembourg
owner_country: LU
publication_date: 20061229
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to native code invocation from JAVA\u2122 classes. More particularly, the present invention relates to systems for reducing the size and static footprint of \u201cmixed language\u201d or mixed-mode code JAVA\u2122 classes, i.e., classes having one or more methods implemented in programming languages other then JAVA\u2122.","This section is intended to provide a background or context to the invention that is recited in the claims. The description herein may include concepts that could be pursued, but are not necessarily ones that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, what is described in this section is not prior art to the description and claims in this application and is not admitted to be prior art by inclusion in this section.","JAVA\u2122 is an object-oriented programming language and platform that was originally developed in the early 1990s. JAVA\u2122 components can invoke native platform application programming interfaces (APIs) by using a standard native code embedding mechanism, commonly referred to as a JAVA\u2122 Native Interface (JNI\u2122) The JNI\u2122 is primarily intended to foster native API reuse or to implement mission-critical parts of the code in a native language for improved efficiency. The JNI\u2122 approach is quite helpful for the reuse of existing APIs from JAVA\u2122. The JNI\u2122 allows a component written in the JAVA\u2122 language to call code written in any other programming language by declaring one or more native JAVA\u2122 methods, implementing a native library containing one or more functions that implement the native JAVA\u2122 methods in a different programming language, loading the library that contains the native code, and then calling the native method.","The static footprint of a JNI\u2122-based mixed-language JAVA\u2122 class comprises two primary contributions, namely the JAVA\u2122 class (bytecode) footprint and the additional native code footprint. Native code comprises the method's business logic implementation and additional JNI\u2122-specific boilerplate code (e.g., for marshalling\/un-marshalling I\/O parameters between JAVA\u2122 and native side, to create new JAVA\u2122 objects and\/or to invoke methods on a JAVA\u2122 object from native code). Invoking native objects from JAVA\u2122 via JNI\u2122 requires the addition of more JAVA\u2122-side and native-side boilerplate code in order to deal with a native object's lifecycle (i.e., invocation of a native object constructors, methods, and destructors) since JNI\u2122 relies on a procedural programming model. Thus, object-oriented concepts must be implemented from scratch on top of the functional JNI\u2122 programming model.","When using JNI\u2122 to implement JAVA\u2122 system components and APIs, developers must find a satisfactory trade-off between a pair of conflicting requirements. The first such requirement is to provide a minimum functionality-gap, meaning that most of the native APIs available to native developers should be available to JAVA\u2122 components as well. The second requirement is for a minimum JAVA\u2122 component static footprint. In other words, adding new JAVA\u2122 APIs to a certain JAVA\u2122 runtime should not have a strong impact on the overall JAVA\u2122 runtime static footprint in terms of both native and JAVA\u2122 libraries to be added. This requirement is very important when deploying and running JAVA\u2122 platforms on embedded and mobile devices which often possess relatively low memory and processing capabilities.","Unfortunately, the above two requirements conflict with each other, as minimizing the functionality-gap by using JNI\u2122 can cause the final static footprint of a JAVA\u2122 component to increase significantly. This is commonly referred to as footprint explosion. In fact, the one-to-one relationship between native JAVA\u2122 methods and functions in the native implementation makes the amount of native code used to implement native JAVA\u2122 methods increase when the number of JAVA\u2122 native methods to implement increases. Even if native boilerplate code can be reused by wrapping frequently used libraries in a JAVA\u2122 API, as depicted in , it is still difficult to avoid footprint explosion since the more native functions are wrapped, the larger the size of the additional JNI\u2122 code. This conflict is even more difficult to solve when dealing with object-oriented native APIs due to the existing programming model mismatch between the JNI\u2122 C primitives and the C++ object-oriented programming model.","A number of proposals have been made to enable JAVA\u2122 wrapping of native C++ objects. These proposals are discussed, for example, in the Simplified Wrapper and Interface Generator (SWIG) User's Manual 1.1, (available at the SWIG website); U.S. Pat. No. 6,066,181, issued May 23, 2000; and U.S. Patent Publication No. 2005\/0044540, published Feb. 24, 2005. These documents discuss a pair of strategies for the JAVA\u2122 wrapping. However, the processes discussed in these documents do not allow for the minimizing of the static footprint, as they require one new native library for each class\/function to be integrated. Therefore, the minimizing of the functionality gap with these systems can easily lead to footprint explosion since all boilerplate code cannot be re-used.","In addition to the above, MICROSOFT\u00ae Corporation's C# Programmer's Reference: Platform Invoke Tutorial (available at the MSDN: Microsoft Development website), while somewhat useful, is strictly limited to the invocation of native procedural APIs and not for the invocation of object-oriented APIs.","There is therefore a need for a system and method of reducing the functionality gap between JAVA\u2122 and native platform, while at the same time providing only a minimum impact on the static footprint of the JAVA\u2122 environment.","Various embodiments of the present invention involve a system and a method for minimizing the functionality-gap between JAVA\u2122 and native platforms while keeping the impact on each JAVA\u2122 API static footprint as small as possible. The various embodiments provide a general purpose mechanism for low-level bridging between JAVA\u2122 and C\/C++, enabling the dynamic invocation of native C\/C++ functions and C++ class\/object methods from the JAVA\u2122 side without adding any additional ad hoc implemented native code to the overall JAVA\u2122 component implementation. In this way, the need to write new native code when implementing a JAVA\u2122 component that needs to invoke some native functionality is drastically reduced.","With the various embodiments of the present invention, the need for writing JNI\u2122 native code in JAVA\u2122 component (e.g. JSR) implementations is reduced, as is the amount of boilerplate code that is needed for JNI\u2122 invocation. In addition, these various embodiments enable JAVA\u2122 developers to write JAVA\u2122 applications that consume native APIs without writing any additional application-specific native code. Still further, with these embodiments, JAVA\u2122 consumers can reuse all of the needed JAVA\u2122 and native boilerplate code, thus reducing the overall size of the resulting JAVA\u2122 consumer APIs. This system can also be used to reduce start-up time and dynamic footprints, as there are fewer native libraries to load, and libraries are only loaded once. Still further, this system and method can also be used for garbage collection of native C++ objects instantiated by a JAVA\u2122 application.","These and other advantages and features of the invention, together with the organization and manner of operation thereof, will become apparent from the following detailed description when taken in conjunction with the accompanying drawings, wherein like elements have like numerals throughout the several drawings described below.","Various embodiments of the present invention involve a system and a method for minimizing the functionality-gap between JAVA\u2122 and native platforms while keeping the impact on each JAVA\u2122 API static footprint as small as possible. The various embodiments provide a general purpose mechanism for low-level bridging between JAVA\u2122 and C\/C++, enabling the dynamic invocation of native C\/C++ functions and C++ class\/object methods from the JAVA\u2122 side without adding any additional ad hoc implemented native code to the overall JAVA\u2122 component implementation. In this way, the need to write new native code when implementing a JAVA\u2122 component that needs to invoke some native functionality is drastically reduced.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 2"],"b":["200","200","210","215","200","220","230","240","200","250","260","210","215"]},"A set of JAVA\u2122 peer classes, referred to herein as JavaPointers, is used to represent dynamically allocated native entities on the JAVA\u2122 side. Different types of native entities, such as objects and primitive variables, are represented on the JAVA\u2122 side by an instance of a dedicated JAVA\u2122 class, e.g., a NativeObjectPointer or a Native StructurePointer instance. As a result of programming idioms and interfaces provided by the JRDI API, JAVA\u2122 applications can use a JavaPointer as a type of JAVA\u2122 peer-pointer in order to invoke methods on dynamically allocated native entities, or to use them as I\/O arguments when invoking another entity's functionality. In this sense, a JavaPointer is used in the same way as a native application would use native pointers to manage dynamically allocated variables.","Various embodiments of the present invention operate under the assumption that the JAVA\u2122 runtime comprises two points of functionality. First, there needs to be a working mechanism for embedding native code in JAVA\u2122 components by using the standard JNI\u2122 mechanism. Second, there must also be a working mechanism for loading native dynamic link libraries (DLLs) at run-time.","The following is a description of a first use case involving the creation of an effective system-development JAVA\u2122 platform for memory-constrained devices. In this situation, a mobile device manufacturer desires to include a powerful pure-JAVA\u2122 application development platform on a memory-constrained device. In order to accomplish this goal, almost all on-device native functionality should be exposed to JAVA\u2122 via a set of JAVA\u2122 mixed language classes representing platform features and system calls. In this case, however, standard JNI\u2122 coding can easily lead to static footprint explosion, as the number of native functions\/methods to expose can be quite large (e.g., around 10functions\/methods to wrap on the latest releases of one operating system). This in turn makes a pure JNI\u2122-based approach unsuitable for memory-constrained devices. If a general purpose native platform invocation JAVA\u2122 component is available, JAVA\u2122 developers can exploit it to invoke whatever native API are needed from JAVA\u2122 without having to write and install any additional C\/C++ application-specific library. In this way, device manufacturers can provide an effective system-development JAVA\u2122 platform that is suitable for memory constrained devices since it has a minimum impact on the overall JAVA\u2122 platform static footprint.","The following is a description of a second use case involving the small footprint implementation of different time-critical methods by re-using a large native C++ object-oriented API. In this case, a JAVA\u2122 developer wishes to implement a large number of time-critical methods of a JAVA\u2122 class. It has been decided to implement them in the C++ programming language because the developer wishes to re-use an existing library of C++ classes. Since JNI\u2122 does not provide support for invocation of object-oriented APIs, the wrapping of the needed class library can require the developer to write a lot of native and JAVA\u2122 boilerplate code. However, this problem can be alleviated if the developer can invoke the native C++ object-oriented API from JAVA\u2122.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3","FIG. 3"],"b":["200","210","215","220","240","230","315","3","315","320","325","330"]},"Upon the JRDI-based dynamic creation of a native entity from JAVA\u2122, a new native variable\/object is allocated on the heap, and a new JavaPointer instance is returned to JAVA\u2122 applications for further usage. The dynamic destruction interface  allows JAVA\u2122 applications to explicitly remove the created native entities from the heap.","With regard to the native APIs to invoke, the available C\/C++ functions and C++ classes may have been either exported by a DLL or not (e.g., using template and inline functions\/methods as well as inherited methods). C and C++ compilers treat these two alternatives differently, and such differences may have an impact on the implementation of the JRDI API . In particular, DLL-exported APIs  can be loaded and invoked at run-time without a DLL invoker  posing any API-specific build-time constraint to the native part of the JAVA\u2122 component. However, native APIs typically also include other C\/C++ definitions and declarations, such as template methods\/functions  and inline methods\/functions . These definitions and declarations can pose several build-time API-specific dependencies between the target APIs of the native platform and the native implementation of a JAVA\u2122 consumer component. These dependencies are due to the fact that C\/C++ compilers generate templates instantiations and expand inline code only at the calling block and add them statically to the calling component's object code at build-time.","Therefore, in addition to DLL-based invocation, an exemplary JRDI implementation may also include components for invoking functionality that does not have any corresponding entry points in DLLs and thus may pose some build-time dependencies to the mixed-language JAVA\u2122 class. In this case, each native method can be wrapped in C-style wrappers  (commonly referred to as C functions) or, more generally, downcalling wrapper functions. Downcalling wrapper functions are functions that are used to wrap a call to a native c\/c++ API in order to enable a downcall. A downcall refers to a call from a managed (e.g. JAVA\u2122) component to a native (e.g. C\/C++) function or method. The necessary wrappers can then be included into a dedicated library, namely a dynamic invocation library (DIL) . In addition to wrappers, the DIL  also includes an array of opaque function pointers. These pointers are referred to as an Entry Point Table (EPT) , which is used by the entry point table invoker component  of the JRDI library to perform the actual invocation of the needed existing native API.","In various embodiments, the JRDI framework relies on the invokers to actually invoke a given native method at run-time by using either DLL-based or EPT-based JRDI approach. For this purpose, in these embodiments the JRDI framework includes two primary invoker components, namely CDynLibInvoker and CEPTInvoker components. These components are derived from the same mixin class, namely MJRDInvoker, which represents the abstract core of the low-level invocation API. Each invoker instance is associated with an instance of a given native class that has been previously allocated on the heap during invoker's creation. Upon native object creation, each invoker holds a pointer to it that is represented by the iThisPointer member of the MJRDInvoker class. Such a pointer is subsequently used to invoke different methods on the target object instance.","The actual method-invocation approach relies on the assumption that the member functions to invoke are represented in native object code as calls to standard C functions. For example, invokers assume that the following method:","int MyClass::MyMethod(int anInt)","is compiled (and thus can be invoked) as a C function having the following prototype: int myclass_myMethod(MyClass * aThisPointer, int anInt)","It should be noted that method invocations are not necessarily converted to such a function call from C++ compilers. Therefore, it is assumed that the native C++ compiler supports this calling convention. If the compiler adopts a different conventions, the low-level JRDI API must support it explicitly. For example, MICROSOFT\u00ae C++ Win32 and ARM RVCT compilers support different default calling conventions and we had to deal with such a difference when implementing the JRDI proof-of-concept prototype.","In order to invoke a given method, invokers (both CEPTInvoker and CDynLibInvoker) typically retrieve a generic (function) pointer to it, and then cast it to a precise type representing a pointer to a function having a specific prototype. For example, in order to invoke the MyMethod method above, the retrieved function pointer should be cast to the T1ArgMethod type defined as follows:",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef void* (*T2ArgFunction)(void *, void *)"]},{"entry":[{},"[...............]"]},{"entry":[{},"typedef T2ArgFunction T1ArgMethod;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It is also noted that, while the first void * argument of T1ArgMethod represents a pointer to the dynamic target-object instance (the so-called this pointer), the second void * argument represents the actual argument to pass to the native method, i.e., the int anInt input parameter of MyClass::MyMethod. A JavaPointer is in charge of converting arguments to void * representation, and of invoking the appropriate method on the right invoker at run-time. If the native method call returns any leave\/error code, a JAVA\u2122 exception is thrown. For example, for invoking the mentioned MyClass::MyMethod method, the JAVA\u2122 consumer must invoke the InvokeIntOneArg argument of the JavaPointer. This method converts the argument to a void * and then invokes the CallOneArgOneWayWithReturn method on the right invoker as follows:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"JNIEXPORT jint JNICALL"},{"entry":"Java_com_nokia_jnai_jrdi_JavaPointer_invokeIntOneArg"},{"entry":"\u2003(JNIEnv * env, jobject, jint aHandle, jint aOrdinal, jint aArg, jboolean"},{"entry":"\u2003aByValue)"},{"entry":"{"},{"entry":"\u2003TInt leaveCode = KErrNone;"},{"entry":"\u2003TInt errCode = KErrNone;"},{"entry":"\u2003TInt returnValue;"},{"entry":"\u2003\/\/1. Get pointer to the invoker instance and cast it to a mixin"},{"entry":"\u2003\/\/ \u2002pointer. We don't need to know what kind of invoker is it."},{"entry":"\u2003MJRDInvoker* invoker = JavaUnhand<MJRDInvoker>(aHandle);"},{"entry":"\u2003\/\/2. Perform method invocation"},{"entry":"\u2003if (!aByValue)"},{"entry":"\u2003\u2003{\/\/2a. Passed by Reference: aArg address is used as a valid"},{"entry":"\u2003\u2003\/\/ \u2002void * parameter for the invoker"},{"entry":"\u2003\u2003TRAP(leaveCode, errCode = (TInt)invoker->"},{"entry":"\u2003\u2003CallOneArgOneWayWithReturn(aOrdinal, &aArg));"},{"entry":"\u2003\u2003returnValue = aArg;}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{\/\/2b. Passed by value: aArg value is cast to void * type"},{"entry":"\u2003\u2003\/\/ \u2002in order for the invoker to retrieve it from the stack"},{"entry":"\u2003\u2003\/\/ \u2002correctly"},{"entry":"\u2003\u2003TRAP(leaveCode, errCode ="},{"entry":"\u2003\u2003(TInt) invoker->CallOneArgOneWayWithReturn"},{"entry":"\u2003\u2003(aOrdinal, (void*)aArg));"},{"entry":"\u2003\u2003\u2003\u2003returnValue = errCode; \/\/ returns success value (KErrNone)"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\/\/3. Throw exception if any leaveCode \/ errorCode have been caught"},{"entry":"\u2003\u2003[.....................]\/\/"},{"entry":"\u2003\u2003\/\/4. Send return value to JavaPointer Java-side"},{"entry":"\u2003\u2003return returnValue;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment of the present invention, both DLL-based and EPT-based invocation of native APIs are enabled. According to this embodiment, in DLL-based invocation, a CDynLibInvoker component contains an RLibrary object that is used to dynamically load a certain target DLL containing one or more class implementations. The CDynLibInvoker component uses the RLibrary object at run-time to retrieve function pointers to exported methods by ordinal (by using a RLibrary::Lookup method) in accordance with the following code:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"EXPORT_C void *"},{"entry":"CDynLibInvoker::CallOneArgOneWayWithReturn(const TInt"},{"entry":"aOpOrdinal, void *arg0) {"},{"entry":"\u2003\u2003TLibraryFunction myMethod= libLoader->Lookup(aOpOrdinal);"},{"entry":"\u2003\u2003return Invoke1ArgMethod(iThisPointer, (void *) myMethod, arg0,"},{"entry":"\u2003\u2003EFalse,"},{"entry":"\u2003\u2003ETrue\/*returns something*\/);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The invoked Invoke1ArgMethod of the CDynLibInvoker object then casts the retrieved generic (i.e., void *) function pointer to the appropriate function prototype, and then invokes the native method. For example, for invoking an int MyClass::MyMethod(int anInt), the function pointer should be cast to a T1ArgMethod (i.e. T2ArgFunction) pointer and then invoked as a 2-arguments function as follows:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void * Invoke1ArgMethod"]},{"entry":[{},"\u2003\u2003( void * thisObj, void * methodToCall, void * arg0, const TBool"]},{"entry":[{},"\u2003\u2003isStatic, const TBool returnsSomething )"]},{"entry":[{},"{if(returnsSomething)"]},{"entry":[{},"\u2003{T1ArgMethod ourMethod=(T1ArgMethod)methodToCall;"]},{"entry":[{},"\u2003return ourMethod(thisObj, arg0);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"else"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003T1ArgMethodNoReturn"]},{"entry":[{},"\u2003ourMethod=(T1ArgMethodNoReturn)methodToCall;"]},{"entry":[{},"\u2003ourMethod(thisObj, arg0);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"EPT-based invocation is similar to DLL-based invocation in that the CEPTInvoker must retrieve the appropriate function pointer as a void pointer, cast it to the actual function pointer type to use, and invoke it. However, a primary difference with EPT-based invocation involves the function-pointer retrieval mechanism. While the CDynLibInvoker relies on the assumption that the method to invoke is available at a given ordinal of a given DLL, the CEPTInvoker has no DLL to refer to since the native functionality is not exported by any existing DLL. In order to invoke unexported native APIs, each required method\/function of such APIs must be wrapped in a C-style wrapper function having the same prototype as the appropriate function prototype to use (e.g. T2ArgFunction). For example, the MyClass::MyMethod method could be wrapped in a C-style wrapper function defined as follows:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int JW_MyClass_MyMethod(MyClass * thisPtr, int anInt){"]},{"entry":[{},"\u2003\u2003return thisPtr->MyMethod(anInt);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"During the construction of a new JavaPointer, the CEPTInvoker instance is initialized by providing it with an array of pointers to all the required wrapper functions related to MyClass. Such an array is defined as follows:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const unsigned int EPT[ ]="]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003(unsigned int)JW_MyClass, \u2003\u2003\/\/0"]},{"entry":[{},"\u2003\u2003\u2003(unsigned int)JW_MyClass_MyMethod, \/\/1"]},{"entry":[{},"\u2003\u2003\u2003(unsigned int)JW_MyClass_MySecondMethod, \/\/2"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Given such an array, in order to invoke the mentioned MyClass::MyMethod method, the CEPTInvoker can retrieve the pointer to the JW_MyClass_MyMethod wrapper, and then invoke it by using the generic CEPTInvoker::Invoke2ArgFunction method as follows:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EXPORT_C void *"]},{"entry":[{},"CEPTInvoker::CallOneArgOneWayWithReturn(const TInt"]},{"entry":[{},"aOpIndex, void *arg0){"]},{"entry":[{},"\u2003\u2003return Invoke2ArgFunction((void *)iEPT[aOpIndex],"]},{"entry":[{},"\u2003\u2003iThisPointer, arg0, ETrue\/*returns something*\/);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It is also noted that EPT-based invocation can be used to provide JAVA\u2122-side setter and getter methods to access a given Class\/object member variables. For example, a setter method for the OneField member of the MyClass class could be invoked by means of the following wrapper function:",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void JW_MyClass_SET_OneField(MyClass * thisPtr, int newValue){"},{"entry":"thisPtr->OneField=newValue;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A JavaPointer instance can hold one CEPTInvoker, as well as multiple CDynLibInvoker instances. This approach results in forcing each EPT to contain all of the DLL-unexported methods that the JAVA\u2122 consumer wishes to invoke on a given object, including methods belonging exactly to object's class as well as to its mother class(es). In other words, inherited methods are always explicitly wrapped by a DIL, and thus explicitly represented in a certain class' EPT.","Both the DLL-based and EPT-based approaches assume that the JAVA\u2122 developer knows beforehand the C\/C++ signature of the native functionality that his application is interested in consuming. Therefore, these approaches requires developers to consult native service documentation, but in any case developers must be aware of native platform's APIs if they want to use them.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIGS. 4 and 5","FIGS. 2 and 3"],"b":["12","12","12","30","32","34","36","38","40","42","44","46","48","52","54","56","58","80"]},"Communication devices implementing the various embodiments of the present invention may be capable of communicating using various transmission technologies including, but not limited to, Code Division Multiple Access (CDMA), Global System for Mobile Communications (GSM), Universal Mobile Telecommunications System (UMTS), Time Division Multiple Access (TDMA), Frequency Division Multiple Access (FDMA), Transmission Control Protocol\/Internet Protocol (TCP\/IP), Short Messaging Service (SMS), Multimedia Messaging Service (MMS), e-mail, Instant Messaging Service (IMS), BLUETOOTH\u00ae, IEEE 802.11, etc. A communication device may communicate using various media including, but not limited to, radio, infrared, laser, cable connection, and the like. The communication devices may be stationary or mobile as when carried by an individual who is moving. The communication devices may also be located in a mode of transportation including, but not limited to, an automobile, a truck, a taxi, a bus, a boat, an airplane, a bicycle, a motorcycle, etc.","The present invention is described in the general context of method steps, which may be implemented in one embodiment by a program product including computer-executable instructions, such as program code, executed by computers in networked environments. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Computer-executable instructions, associated data structures, and program modules represent examples of program code for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represents examples of corresponding acts for implementing the functions described in such steps.","Software and web implementations of the present invention could be accomplished with standard programming techniques with rule based logic and other logic to accomplish the various database searching steps, correlation steps, comparison steps and decision steps. It should also be noted that the words \u201ccomponent\u201d and \u201cmodule,\u201d as used herein and in the claims, is intended to encompass implementations using one or more lines of software code, and\/or hardware implementations, and\/or equipment for receiving manual inputs.","The foregoing description of embodiments of the present invention have been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the present invention to the precise form disclosed, and modifications and variations are possible in light of the above teachings or may be acquired from practice of the present invention. The embodiments were chosen and described in order to explain the principles of the present invention and its practical application to enable one skilled in the art to utilize the present invention in various embodiments and with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 4"]}]},"DETDESC":[{},{}]}
