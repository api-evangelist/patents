---
title: Apparatus and method for processing data streams
abstract: A distributed architecture and method for maintaining the integrity of data streams within a multi-pipelined processing environment. The architecture comprising a communications network for carrying a plurality of data streams and a master processor adapted to process one or more messages in at least one of the data streams, the message processing including the creation of one or more data packets within the stream, each packet encapsulating at least a transaction summary of the data that has been processed. The architecture further comprising at least one slave processor per master processor adapted to emulate the transactional state of the master processor by regenerating the data stream as a result of processing the one or more data packets, whereupon in response to an error event on the master processor, the slave processor acts to avoid interrupting the data stream by generating one or more successive data packet(s). Hence, the architecture and method serve as a high availability, robust fault tolerant system, mitigating against the loss of data within data streams.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930754&OS=08930754&RS=08930754
owner: BAE Systems PLC
number: 08930754
owner_city: London
owner_country: GB
publication_date: 20091208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["The present invention relates to an apparatus and method for processing data streams, and particularly relates to a distributed architecture and method for maintaining the integrity of data streams within multi-pipelined processing environments.","There are many different architectures and systems known in the prior art for controlling the flow of data within a multi-pipelined processing environment. Such control systems process data streams according to prescribed methodologies and paradigms in order to preserve the integrity of the processed data in the event that the system should develop an error or malfunction in some way. Therefore, it is known to provide fault tolerant architectures, for example in the form of dual processors, to ensure that data can be recovered in the event of an error.","In many applications, data is processed and stored via database operations, and a common technique of preserving data during such operations is via \u201ctransaction processing\u201d. Transaction processing treats each operation on a particular piece of data as an action, or set of actions, which must be completed as a whole before the operation is regarded as having been carried out. Therefore, any changes to the data are only acknowledged by the system if the transaction has completely finished what it was instructed to do. Should an error occur within the system during an operation, the data can be \u201crolled back\u201d or restored to the last known valid state prior to any incomplete transactions.","Such error recovery techniques are very well suited for preserving processed data, and consequently transaction processing is used widely within business applications and database systems generally. However, in some applications the loss of data from within a data stream (i.e. when the data is in transit) can be critical, as depending on the nature of the lost data, and form of control system, the subsequent response of the system or subsequent application logic may differ from what was intended or expected.","Therefore, for such applications it is important to preserve the flow of data within the data stream, a requirement which is generally incompatible with conventional techniques for recovering processed data. This is usually because either the existing paradigm or recovery logic is designed to restore data to its last known valid state, and consequently the paradigm\/logic is typically only concerned with the \u201cend states\u201d of the data and not with the status of any data that is in transit.","In applications such as air traffic control and radar monitoring, data streams generally comprise a continuous series of messages derived from an associated receiving equipment. Each message typically represents some form of \u201ctriggering event\u201d that is intended to invoke some response or action within the control system, which in itself may invoke a further response\/action etc., to thereby generate a particular course of action for responding to the information conveyed in the data stream. Hence, any loss of such messages is undesirable and may be potentially hazardous, particularly where the objects being monitored are moving at high speeds.","Therefore, there is a need within the art for a control system and method that can maintain the integrity of data streams in applications were the loss of information from within the data streams is best avoided and\/or is not permissible.","According to a first aspect of the present invention there is provided a distributed architecture configured to maintain the integrity of data streams within a multi-pipelined processing environment, the architecture comprising:\n\n","According to a second aspect of the present invention there is provided a method of maintaining the integrity of data streams within a multi-pipelined processing environment, implemented across a distributed architecture, the method comprising the steps of:\n\n","The present invention seeks to address some or all of the above problems in the prior art by providing a robust distributed architecture that is operated to preserve the flow of data within one or more data streams. In this way, the architecture achieves a \u201chigh availability\u201d in terms of operational reliability, which makes the present invention ideally suited for use in both civilian and military real-time monitoring applications, such as air traffic control, air-space defence and naval operations etc.","The architecture of the present invention is distributed in the sense that the master processor and the slave processor may be remotely located from each other, and from any other processors within the architecture. By \u201cremotely located\u201d we mean that each processor may be physically separated and therefore need not be located in close proximity to the other or others. An advantage of implementing the invention by way of a distributed architecture, is that it increases the overall architecture's fault tolerance and resilience to potential malfunction and\/or damage. Hence, should a portion of the architecture be rendered inoperative due to instantaneous equipment failure, sabotage or possible battle damage (e.g. as arising in military applications etc.), the remaining processor(s) can assume control and maintain the flow of data within the system, without any undue impact on the operational reliability or capability of the system as a whole.","It is to be understood that any number of processors may be included within the architecture depending on the particular application. Hence, the architecture of the present invention is inherently scalable. Moreover, there may be more than one master processor and more than one slave processor, and there may be more than one slave processor associated with any particular master processor, but it is most preferred that there is only one respective slave processor associated with each master processor.","The processors themselves may be conventional servers, workstations or personal computers, or alternatively, may be bespoke computing devices arranged and operated according to the architecture and method of the present invention. Moreover, it is to be appreciated that the processors may be advantageously derived from any \u201ccommercial-off-the-shelf\u201d (COTS) hardware. Furthermore, in some arrangements, each \u2018processor\u2019 may correspond to a \u2018virtual machine\u2019, that can be executed on a single core or multiple core processor. Hence, the architecture of the present invention may be implemented with potentially significant cost-savings over existing fault tolerant systems.","Each of the processors are coupled to a communications network. The network may be a hardwire or wireless comms network. The network is preferably configured to have sufficient bandwidth to carry a plurality of data streams, each stream originating from one or more data sources, such as sensors or receiving equipment etc. In preferred arrangements, the network is configured to support and convey multi-cast data traffic, so as to enable multiple processors within the network to receive data packets via multi-cast data streams.","By \u201cdata stream\u201d we mean a flow of data, typically comprising one or more messages, which are streamed continuously, intermittently or according to some other prescribed transmission sequence. The flow of data may be subject to some form of modulation and\/or may be partly or fully encrypted according to a desired encryption standard.","References herein to a \u201cmessage\u201d are intended to include any data element that conveys an instruction to an application logic to perform\/invoke some intended function. Hence, a message may be viewed as a \u201ctriggering event\u201d to trigger some action or response within one or more of the processors.","The processors within the architecture are preferably arranged according to an inter-meshed topology, throughout which a large number of messages may be in transit at any particular moment of operation. Each processor may handle a plurality of different processing threads and can process any number of messages from within the data streams.","However, it should be appreciated that any network topology or connectivity arrangement may be used according to the present invention, without sacrificing any of the benefits or advantages of the architecture or method. Moreover, it is to be understood that the present architecture is most preferably implemented as a \u201csoft real-time\u201d system, whereby some degree of latency between keeping all of the distributed processors within the network up-to-date with changing situations is tolerated, without any undue effect on the overall system performance.","At least one of the processors within the network is selected to be a master processor, with one or more second processors preferably being selected to be a slave processor correspondent to that respective master. The master processor is adapted to process one or more messages in at least one of the data streams within the network. The messages may be sent directly (i.e. be addressed to) the master processor, or more preferably, they are multi-cast or broadcast throughout the network and are received by the one or more processors that are listening for them.","Upon receiving a message, the master processor preferably applies an application logic to the message, which processes the instruction(s) within the message to invoke a response, such as changing the state of, or updating, a prescribed data as part of a pipelined processing sequence. As part of the processing, the application logic creates a data structure in the form of a data packet, referred to herein as a \u201ctransaction unit\u201d, which preferably encapsulates a complete description of what changes\/updates were made to the prescribed data as a result of the incoming message (e.g. \u2018triggering event\u2019). In other words, the transaction unit maintains a summary or record of what it did to the data.","In addition to the record, the transaction unit also contains information relating to the incoming message, which triggered the response to change or update the prescribed data. In this way, the transaction unit contains a complete record of what transactional changes have been made and what triggering event brought about these changes. The transaction unit is also configured to include a new outgoing message for triggering a further event during the next step of the pipelined processing sequence. The instruction(s) within the outgoing message will, of course, depend on what changes have just been made and what is the intended\/expected response at the next step and beyond etc. Therefore, if further processing is required the transaction unit is preferably consumed by the next stage of the application logic within the master processor.","A copy of the transaction unit is now also made available on the network as part of the data stream by preferably broadcasting the data packet, so that any interested processors can receive the data packet\u2014of which one is at least the correspondent slave processor. A buffer within the slave processor is preferably configured to receive and store the transaction units that are made available by the master processor.","The application logic within the master processor thereafter continues to process each generated transaction unit as it proceeds through the pipelined processing sequence, recording changes\/updates to the data in each successive transaction unit. Each transaction unit preferably being made available on the network to the slave processor and any other interested processors.","The correspondent slave processor is adapted to emulate the transactional state of the master processor by logically tracking, i.e. effectively \u201cshadowing\u201d, the pipelined processing sequence of the master processor. However, in preferred embodiments, the emulation does not require any high degree of synchronicity with the master processor and consequently the slave may lag behind the master without any undue effects. Hence, a further advantage of the present invention is that relatively complex timing and\/or coupling circuits are not required between the master and slave processors, unlike those found in dual processor fault-tolerant systems.","It is to be appreciated that the potential \u201clag\u201d between the slave and the master processors may amount to several seconds or more, but is most preferably within a sub-second range, as obviously longer delays may hinder the performance and\/or reliability of the architecture. In practice, the lag is dependent on the loading of the slave processor and upon the latency of the network itself. Hence, the lag will be greater when the slave is busy processing data and\/or when there are large amounts of data traffic flowing through the network.","While the master processor is operating normally, that is when no \u201cerror event\u201d has occurred on the master and\/or has been detected by another processor, the slave processor enters into what is called a \u201clogically inactive\u201d state. By \u201clogically inactive\u201d we mean that the slave processor logically tracks the master processor by applying the same application logic to any received transaction units as that of the master, but the application logic is not regarded as being \u201cactivated\u201d at that time. The result of this is that none of the transaction units generated by the slave processor, as a consequence of the emulation, are made available on the network while the master processor is operating normally. In this way, there can never be two identical transaction units on the network at the same time.","Moreover, it is very important to prevent the slave processor from applying its application logic while the master is operating normally, as the resulting logic is non-deterministic, and as a result the master and slave processors could bring about different changes of state in the data\u2014even though the logic is the same and the inputs are nominally similar. Hence, if the slave processor were to simultaneously process equivalent threads of application logic to that of the master, it may still arrive at a different set of data\/messages to the master, particularly where the application logic comprises time dependent parts. This is why the slave processor is prevented from multi-casting transaction units until such time that the master processor fails.","By \u201cerror event\u201d we mean an error, fault or malfunction in the software and\/or hardware of the master processor, brought about by a coding anomaly, component failure, loss of power, physical damage or destruction of the processor, or otherwise, which causes or results in an interruption or permanent cessation of the processing pipeline by the master processor. In other words, any event which halts the master processor from processing messages within the data stream.","The slave processor therefore tracks the transactional state of the master processor by regenerating the data stream as a result of processing the transaction units made available by the master processor. Since each transaction unit contains a record of what changes it made to a prescribed data, the slave processor is able to follow the changes\/updates and apply these to its own equivalent data to thereby logically track the pipelined processing sequence of the master processor. To ensure that the slave processor accurately tracks the master processor, the slave regenerates the data stream by restoring the one or more messages in the same order in which they were originally created and\/or processed by the master processor. This is preferably achieved by the slave processor asynchronously processing the one or more transaction units.","The application of transaction processing to regenerating a data stream is therefore particularly advantageous, as the original flow of data can be recreated or restored by the slave processor, irrespective of the end states or status of the processed data. In this way, the transaction units provide an advantageous mechanism by which the contents of a data stream may be regenerated without the need to re-set and\/or re-send the data stream, which in real-time monitoring applications would not be desirable or indeed practical.","Not only does the regeneration of the data stream restore the original flow of data, it also preserves the dynamic state of the messages within the stream, which ensures that the result achieved by applying the application logic to the message is what was intended or expected when the original message was sent.","Should the master processor undergo an error event at some future point in time, and consequently cease processing, the slave processor acts to avoid any interruption in the data processing pipeline by continuing the data stream at the point were the master processor ceased operating. By processing the available transaction units placed on the network by the master processor, the slave processor emulates the transactional state of the master processor, which means that in the event of an error event occurring, it can rapidly assume control over the failing master processor.","In preferred embodiments, a monitoring protocol comprising the use of periodic \u201cheartbeats\u201d or \u201cI'm alive\u201d messages is implemented throughout the architecture, and such messages are passed between both the master and slave processors to confirm the presence and\/or operation of each processor to the other. However, it is to be appreciated that any suitable form of monitoring protocol or processor detection technique (i.e. to check that a processor is \u201calive\u201d) may be used in conjunction with the present invention.","As discussed previously, the slave processor preferably resides in a logically inactive state during normal operation of the master processor. However, should the slave processor become aware that one or more of the heartbeat messages are absent or delayed beyond a predetermined interval of time, the slave processor preferably \u201creleases\u201d its application logic (i.e. marks the logic as being valid and activated) and begins to process any queued messages and consume remaining transaction units within the pipelined processing sequence. In so doing, it preferably asserts control over the failing master processor by appointing itself as the new master, and ensures that the flow of data within the data stream is not interrupted by generating one or more successive transaction units.","Since the application logic is now activated, the slave processor is permitted to make the successive transaction units available on the network for any other interested processors, thereby maintaining the integrity and continuity of the data stream despite the failure of the original master processor.","The slave processor is preferably configured to transmit a \u201ckill\u201d message to the master processor upon detecting an absent heartbeat, arising from an error event occurring on the master processor. Alternatively, and or additionally, the master processor itself may automatically shut down in response to detecting an error or malfunction in its operating procedure or processing pipeline, and may also shut down if it detects that a slave processor has become active (i.e. indicative of a failure associated with the master processor). In this way, the master processor can be removed from the processing pipeline as rapidly as possible, allowing the slave to take over from the point were the original master ceased operating.","The change of control between the master and slave processors preferably occurs substantially at \u201cRAM speed\u201d, typically within several tens of milliseconds or faster following detection of the error event. Therefore, from an operator's point of view, the reconfiguration appears to be imperceptible and no interruption in the flow of data occurs. In other words, there appears to be a \u201cvirtually continuous\u201d operation of the system. It has been found that the architecture and method of the present invention can deliver a \u201chigh availability\u201d (i.e. system availability and resilience) of substantially 99.999%, which is sufficiently reliable and robust enough to allow its use in real-time monitoring and sensing applications within, for example, military and aviation environments. However, it is to be appreciated that the advantages of this invention are not dependent solely on the speed of the data recovery, but also in that it is the \u201ccompleteness\u201d of the recovery that is especially noteworthy, as the data stream can be restored in its entirety without any interruption or loss in the flow of data.","In accordance with each of the preferred embodiments of the present invention, the message and transaction unit processing is implemented within the middleware of the distributed architecture. Therefore, all of the \u201cintelligence\u201d required to handle the messages and transaction units is preferably embedded within one or more APIs (Application Programming Interfaces), which are designed to apply the technique of transaction processing to data that is in transit as part of a data stream. An advantage of embedding the intelligence within the middleware is to essentially hide the complexity of the hardware exploitation, which may also avoid or mitigate against middleware incompatibilities resulting from applications developed according to different development models.","To control the message handling, a known application design model called \u201cCommunication Sequential Processing\u201d or \u201cCSP\u201d is preferably implemented as part of the present invention. CSP controls the flow of data by way of a communications based kernel which sends messages asynchronously throughout the communications network. The CSP control method is preferably implemented within the middleware APIs by way of an Object based methodology. However, it is to be appreciated that other development methodologies may alternatively be used to implement aspects of the present invention, without sacrificing any of the benefits or advantages of the architecture or method as disclosed herein.","Although the above embodiments have been described with reference to an architecture and method for maintaining the integrity of data streams in multi-pipelined processing environments, whereby it is essential to avoid the loss of data from within a stream, it should be appreciated that one or more of the principles of the invention may be used in other applications and data processing environments, where there is a need to regenerate a flow of data as a result of an error, system testing or calibration, or as part of general house-keeping routines etc.","Referring to , there is shown a distributed architecture  according to an embodiment of the present invention, the architecture comprising a communications network , to which are connected a master processor  and a slave processor . The communications network  is a hardwire network, arranged according to a inter-meshed topology (not shown) and has sufficient bandwidth to carry a plurality of data streams, which originate from one or more real-time sensors, for example, radar or sonar detectors etc.","Both the master and slave processors ,  are commercial-off-the-shelf workstations or PCs, which have been configured to process data streams within the pipelined processing environment of the distributed architecture . The master processor  is remotely located to that of the slave processor , so that they are physically or geographically separated. For example, the master processor  may be situated at the bow of a ship, while the slave processor  is located at the stern of the ship etc. Therefore, should one of the processors be damaged and\/or rendered inoperative due to a localised event, the other processor should remain unharmed.","The slave processor  is selected to be correspondent to the master processor , and both are configured to include the same application logic for processing one or more data streams. A pipelined processing sequence  is shown schematically within the master processor , comprising a plurality (here three) functions , ,  which are to be successively applied by the application logic to the flow of data within the data stream. Each function acts on the data to invoke a change and\/or update to the data. Of course, it is to be understood that any number of functions may be included within the pipeline depending on how the data is to be processed.","A corresponding pipelined processing sequence \u2032 is also implemented within the slave processor , as shown in  (as ghost lining), which during normal operation is regarded as being \u201clogically inactive\u201d, as explained in further detail below.","Although not shown in , the distributed architecture  may also include a plurality of other processors, each connected to the network  to receive and process respective data streams. A portion of the processors may be designated as master processors, with another portion being identified as slave processors, each slave being assigned to a respective master processor. Hence, it is to be understood that the example shown in  is readily scalable to suit the desired processing application and\/or environment.","Referring now to , there is shown a message , which has been sent via the network , as part of a data stream. The message  essentially corresponds to a \u201ctriggering event\u201d that when acted upon by one or more of the functions , ,  in the processing pipeline , generates some particular response or action within the master processor . In , the processing pipeline is denoted generally by label \u2018\u2019, but it should be appreciated that the pipeline corresponds to the processing flow between functions ,  and , as indicated by the arrows illustrated there between. The message handling in this example is controlled by a CSP data control method, implemented within the middleware APIs of the architecture, as a communications based kernel. The message  may be directly addressed to the master processor , or as in this example, has been multi-cast on the network  so that any interested processors can receive it.","As shown in , the message  enters the pipeline , within the master processor , and function  is then applied to the triggering message. The message  is processed by the application logic and proceeds to change and\/or update an associated data, shown schematically as \u2018\u2019 in , in response to the message. As part of the message processing, the application logic creates a data structure in the form of a data packet , called a \u201ctransaction unit\u201d, which encapsulates a complete description of what changes\/updates have been made to the data  as a result of the message . In this way, the transaction unit  maintains a summary or record of what response or action the message  invoked when processed by function  in the pipeline .","In addition to the summary or record, the transaction unit  also contains information relating to the triggering event and a new outgoing message for triggering another event at the next step in the pipeline . The instructions within message will depend on what changes\/updates have just been made and what the intended\/expected response should be along the processing pipeline .","At the time the transaction unit  is created, a copy of the transaction unit is also made available on the network  by the master processor , as shown in . The master processor  multi-casts the transaction unit  via the network  (as indicated by the bi-directional arrow in ), so that any interested processors (particularly the slave processor ) can receive it as part of the data stream.","The pipeline  continues to process the data stream by consuming the transaction unit , and processing message by applying it to function , as shown in . Once again, the message acts as a triggering event and causes the application logic to change and\/or update an associated data , as indicated in . As before, another transaction unit  is created, which encapsulates a complete description of the changes\/updates to the data  in response to message , while a copy of the transaction unit  is multi-cast via the network .","The new transaction unit  is consumed by the application logic as it progresses through the pipeline , such that function  is then applied to message , as shown in . All the while, the multi-cast copies of the transaction units ,  are propagating through the network  and are being received by the slave processor .","However, at the time the transaction unit  is consumed by the application logic of pipeline , and function  is applied to message , the master processor  experiences an error event, in this example a fatal power loss, which renders the processor inoperative, as shown in . As a result, all processing halts on the master processor  and no further transaction units are multi-cast to the network .","The slave processor  has no knowledge of the error event at the time the event occurs, and therefore proceeds to continue with its instructions to emulate the transactional state of the master processor . The slave processor  achieves this emulation by logically tracking, i.e. effectively \u201cshadowing\u201d, the pipelined processing sequence carried out within the master processor  (as shown in ). Therefore, the slave processor  proceeds to process any transaction units received via the network  from the master processor , including any that have been stored in its conventional FIFO (First In, First Out) type buffer. As shown in , the transaction units ,  have arrived at the slave processor  and have been queued in the processor's buffer (not shown).","During normal operation of the master processor , the application logic within the slave processor  is deemed to be \u201clogically inactive\u201d. In other words, although the pipeline \u2032 is fully functional, the application logic is not formally \u201cactivated\u201d and consequently the slave processor  is blocked from sending any copies of its transaction units via the network . However, despite the status of the application logic, slave processor  is able to track the transactional state of the master processor , by processing the one or more transaction units , .","The slave processor  tracks the transactional state of the master processor  by regenerating the data stream as a result of consuming the transaction units , . Since each transaction unit contains a record of what changes it made to the data , , the slave processor  is able to follow the changes\/updates and apply these to its own equivalent data. Therefore, as shown in , transaction unit  is applied to function \u2032, which results in data \u2032 being changed\/updated in accordance with the changes\/updates to data . However, there is now no need to process the released message , as transaction unit  can instead be simply consumed by function \u2032 to change\/update data \u2032, as shown in , with any released messages, such as message , being queued within the slave processor .","Hence, it is clear that the slave processor  is able to regenerate the original data stream by restoring the messages in the same order in which they were originally created and\/or processed by the master processor . Moreover, as each transaction unit contains a complete description as to how the data was changed\/update, asynchronously processing the transaction units in the order in which they are received, allows the slave processor  to align itself with the transactional state of the master processor .","In , the message released from consuming transaction unit , i.e. message , is queued by the application logic in anticipation of a further transaction unit from the master processor . However, as shown in , the slave processor  eventually becomes aware that the master processor  has experienced an error event, due to an absent \u201cheartbeat\u201d message expected from the master processor  (indicated schematically as crossed lines on the input to the slave). Whereupon, the slave processor  acts to assume control over the failed master processor  and, importantly, to avoid any interruption in the flow of data within the data stream.","At the point where the slave processor  becomes aware that the master processor  has failed, the slave processor  automatically activates its application logic and begins to process any queued messages in the pipeline \u2032. Therefore, as shown in , the pipeline \u2032 (now indicated by solid lines) processes the previously queued message and the application logic removes the block on sending transaction units via the network . At this point, the slave processor  becomes the new master processor.","The new master processor  also sends a kill message to the original master processor  to ensure that it shuts down completely, even if it appears that the original master processor  has already ceased operating. In this way, the original master processor  can be removed from the processing pipeline as rapidly as possible, while allowing the new master processor  to assert control over it.","A comparison of  reveals that the new master processor  is now in the same transactional state as the original master processor  was just before the error event. Therefore, as a result of restoring the original messages within both the data stream and processing pipeline, the new master processor  has aligned its data with that of the original master processor .","Referring to , the application logic now applies function \u2032 to the message , which enables data  to be changed and\/or updated, the details of which are encapsulated within a new transaction unit  that is made available to the network  by the new master processor . In this way, there is no interruption in the flow of data within the architecture , as the new master processor  continues from the exact point where the failed master processor ceased operating. As a result, the architecture is able to maintain the integrity of the data stream, without any loss of data.","The change of control between the master and former slave processors ,  occurs substantially at \u201cRAM speed\u201d upon detection of the missed heartbeat. Therefore, from an operator's point of view, the reconfiguration is imperceptible and there is consequently negligible or no change in the availability of the system.","The above embodiments are described by way of example only. Many variations are possible without departing from the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"p":["Embodiments of the invention will now be described in detail by way of example and with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0043","num":"0048"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0044","num":"0049"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0045","num":"0050"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0046","num":"0051"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0047","num":"0052"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0048","num":"0053"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0049","num":"0054"},"figref":"FIGS. 7 & 8"},{"@attributes":{"id":"p-0050","num":"0055"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0051","num":"0056"},"figref":"FIGS. 10 to 13"},{"@attributes":{"id":"p-0052","num":"0057"},"figref":"FIGS. 14 & 15"},{"@attributes":{"id":"p-0053","num":"0058"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
