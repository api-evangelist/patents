---
title: Non-volatile memory access control
abstract: A system is described for controlling access to non-volatile memory. The system can include logic configured to determine whether to delay access to the non-volatile memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06868473&OS=06868473&RS=06868473
owner: Scientific-Atlanta, Inc.
number: 06868473
owner_city: Lawrenceville
owner_country: US
publication_date: 20021030
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention is generally related to memory devices, and, more particularly, is related to memory devices with a finite number of access cycles.","Memory exists, generally, because microcontrollers and microprocessors typically require some form of non-volatile and\/or volatile memory for their basic operation. Semiconductor memory can broadly be categorized into two major families that are characterized by whether or not their data is retained when power to the memory is removed. Volatile memory, which loses its data when the power is removed, is commonly referred as random access memory (RAM). Non-volatile memory (NVM) retains its data when the power to the device is removed.","NVM is preferably the location where non-volatile code or data is stored. Non-volatile memory includes such memory types as FLASH, electrically erasable read only memory (EEROM (or electrically erasable programmable read only memory EEPROM)), electrically alterable read only memory (EAROM), among others. Non-volatile memory is popular in data storage applications and code storage applications. Historically, basic input\/output systems (BIOS) memory for computers has stored application driving code (code-storage memory) and has included non-volatile memory, such as FLASH memory. Data-storage applications are numerous, and include digital still camera technology, voice\/audio recorders, portable computers, and removable storage media, among others. Other applications include embedded devices. Embedded devices include computer functionality, and can include such devices as toasters, microwaves, VCRs, cable or satellite television set-top boxes, and other electronic devices, that include functionality to retain set-up information (e.g., device programming and the state of the machine or device, etc.) all in NVM. If the device loses power, that set-up information is retained and will be available for use when power is re-applied.","EEROM NVM typically has a low net number of access cycles, particularly erase-write (EW) cycles, with a typical range of 10,000 to 10 million EW cycles. One reason for this limited number of EW cycles has to do with the physics of the memory device. For example, charge tunneling is one mechanism to perform a write operation. In charge tunneling types of memory devices, charge is placed into a memory cell using some form of tunneling (e.g., Fowler-Nordheim tunneling, among others) which results in a \u201cpath\u201d in the material comprising the memory cell. As the number of writes increases over time, the \u201cpath\u201d creates a lowered resistance, which provides a path for charge to leak out of the memory cell. Thus, a need exists in the industry to address the aforementioned and\/or other deficiencies and inadequacies.","The preferred embodiments of the invention now will be described more fully hereinafter with reference to the accompanying drawings. The preferred embodiments of the invention include a non-volatile memory (NVM) access system that is described below in the context of an embedded device, such as a set-top box, computer, digital video disk (DVD) player, among others. However, the NVM access system includes elements that can be embodied as separate elements distributed throughout a system such as a telephone communications system, home entertainment system, building management network, subscriber television system, among others. In particular, the preferred embodiments of the invention include systems and methods for controlling access to and\/or from NVM. Access will herein be understood to include write, erase-write (EW) (i.e., wherein the data in one or more cells are erased prior to being written to), erase, and\/or read operations to and\/or from NVM, with emphasis placed on the EW operations to NVM. Further, although the preferred embodiments are described in the context of a system for controlling access to NVM, access applications to substantially any storage device with a finite number of access cycles are considered to be within the scope of the invention.","Since the preferred embodiments of the invention are described in the context of an NVM access system located in an embedded device, a generalized description of the NVM access system is described and followed by an illustration of one embodiment of an NVM access system included in an example embedded device. Following the description associated with the example embedded device are illustrations of the example counting and delay schemes employed by the NVM access system, as well as an example method for controlling access to NVM.","The preferred embodiments of the invention may, however, be embodied in many different forms and should not be construed as limited to the embodiments set forth herein; rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope of the invention to those having ordinary skill in the art. Furthermore, all \u201cexamples\u201d given herein are intended to be non-limiting, and are included as examples among others contemplated and within the scope of the invention.",{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 1","b":["100","100","10","20","30","10","20","10","30"]},"These NVM access system elements can be embodied in a single device, such as in a set-top box or other embedded devices, and one or more of these system elements can be located on a single component such as an integrated chip (e.g., all in a single memory component) or distributed among different components and\/or devices. For example, the NVM access manager  can be software resident in memory, for example as a module in an operating system. In other embodiments, the NVM access manager  can be hardware and\/or firmware embodied in a single applications specific integrated circuit (ASIC) that cooperates with an integral arithmetic logic unit (ALU) and\/or integral processor (not shown). In other embodiments, at least some of the processing functionality of the preferred embodiments of the invention can be performed external to and in cooperation with such an ASIC. The NVM access functionality in the ASIC can include some form of temporary data storage and\/or receive data from an external data storage component or device. Further, NVM  can be co-located in the same device or in a separate device.",{"@attributes":{"id":"P-00020","num":"00020"},"figref":["FIG. 2A","FIG. 1"],"b":["200","100","200","250","260","260","100","240","250","255","258","100","200","100","10","20","10","20","20","100","100","30","30","30","30","230"]},"In one implementation, the data in NVM blocks  are duplicated, at least in part, in the storage component , and temporarily stored in buffer NVM blocks . In the storage component , data in each block of the buffer NVM blocks  can be changed one or more times, or not at all, between EW cycles. Further, since the data stored in the buffer NVM blocks  should ideally be the same as the data that is to be stored in the NVM blocks , a read request (e.g., from an operating system or application) to the NVM access manager  preferably results in data being returned from the buffer NVM blocks  rather than from the NVM blocks , although that is not necessarily a limitation. Data in each block of the buffer NVM blocks  will be shuttled to the corresponding NVM blocks  during EW cycles. The storage component  also includes NVM block counters  for each block of the buffer NVM blocks . The NVM block counters  are preferably used by the counter manager  of the NVM access manager  (in cooperation with the processor , timer , and clock  in one implementation) to keep track of the EW cycles and EW lifecycle ticks for NVM . A delay determiner  in the NVM access manager  cooperates with the counter manager  to determine the EW delay to employ to enable NVM access control, as described below. The NVM block counters  can be practically any size, such as 2 bits, 6 bits, 8 bits, etc. In other embodiments, the storage component  may omit the buffer NVM blocks , and just maintain the NVM block counters . Still in other embodiments, the buffer NVM blocks  may not include the entire contents of the NVM blocks .","For example, the buffer NVM blocks  may only include data that is being buffered for later storage using the functionality of the NVM access manager , and thus there would not necessarily be a 1:1 correspondence between the content in the buffer NVM blocks  and the NVM blocks . Thus, only data being write-delayed would be stored, in one embodiment, in the buffer NVM blocks . In such embodiments, read requests for NVM data would preferably prompt a search of the buffed NVM blocks  and if the data was not found there, then a read operation would be performed on the NVM blocks . The decision as to whether to mirror only a portion of the NVM block data versus the data in the entire NVM blocks  is based in part on the needs of the particular product, performance requirements, and\/or available buffer memory, among other considerations. For example, if the NVM  is small (e.g., 4 Kbytes), buffering the entire contents of the NVM blocks  may be appropriate. If the NVM is large (e.g., 128 Kbytes), it may be appropriate to buffer more selectively. Further variations in architecture of the NVM access system  are contemplated to be within the scope of the invention, including incorporating processing, timer, and\/or clock functionality into the NVM access manager  in some embodiments, as described above.","The example embedded device  also includes the instruction memory , such as ROM, which is preferably used by the processor  for executing instructions. One skilled in the art would understand that the embedded device  () can also include other components not shown, including an operating system, device drivers, application software, and other application specific functionality, such as radio frequency tuners for set-top boxes, or cathode ray tubes (CRTs) for televisions, among others.","With continued reference to ,  illustrates an example software stack showing how the NVM access manager  can cooperate with different layers of control in the example embedded device  of FIG. A. The example software stack includes an application layer , an operating system layer , a hardware abstraction layer (HAL) , and a hardware interface layer . Note that the following set-up illustrates one example implementation, and that the NVM access manager  can be resident in one or more of the following levels in some embodiments. One or more programmed software applications, herein referred to as applications, may comprise the application layer . Applications can be executed by utilizing computing resources via one or more operating system application programming interfaces (APIs)  in the example embedded device . The applications may be resident in instruction memory  () or downloaded (or uploaded) into the storage component  () (e.g., RAM, DRAM, etc.).","The computing resources are preferably implemented at the operating system layer , which in one implementation includes the NVM access manager  and its corresponding components. An operating system enables the services of the NVM access manager  to be used by other software modules and facilitates the sharing of processor functions with other running processes. The operating system layer  is not necessary to implementing the preferred embodiments of the invention, but it does provide the NVM access manager  one environment to operate in. Cooperation with an application requiring a write to NVM  () is preferably implemented via one or more NVM API's .","The HAL  is preferably used to isolate applications and\/or operating systems from variations in the underlying hardware. The HAL  can be considered as a set of specifications for layers above and below to follow to enable functions to be performed. If the hardware is changed, the higher level software using the hardware does not have to be re-written. The HAL  provides a mechanism for accessing devices, such as the NVM  (FIG. ), with higher level code. The HAL  also includes mechanisms for determining various properties of an underlying device. For example, the NVM HAL interface  is an example of an HAL interface for the NVM access manager , the NVM driver , and the NVM . Other HAL interfaces can include a tuner system HAL, or a timer HAL, among others not shown. In one embodiment, the NVM access manager  can query the NVM driver  using the functions defined by the HAL interface  to determine NVM parameters such as size, life cycle parameters, block size, etc. The NVM driver , which is written to the interface specifications of the HAL , provides the correct replies based on the properties of the NVM .","While the NVM driver  controls the reading and the writing of the NVM  (under the instructions of the NVM access manager  and specifications of the HAL interface ), it does not interface directly with the hardware connecting the NVM  to the processor  (FIG. ). This direct interface is accomplished via the IC bus driver  and hardware. IC is a well-known communication protocol that uses bi-directional communication between components that can switch roles between master and slave. The IC bus driver  has its own IC HAL interface  between the NVM driver  and the IC bus driver . With continued reference to , and referring to , the IC bus driver  cooperates with the processor  (or other controller) to control the bus. In other embodiments, the NVM access manager  can control the bus directly (i.e., without intervening software layers). The IC bus driver , in cooperation with the processor  and clock , generates a serial clock (SCL), which in conjunction with the serial data signal (SDA) controls the bus timing, direction, and the transfer of data. One skilled in the art will understand that  represent one example embodiment among others. For example, although the NVM access manager  is shown at the operating system layer , it has functionality that can also be implemented at the application layer  and\/or at the operating system layer , among other layers. Further, one or more of these layers can be omitted, or additional layers can be added. For example, in some embodiments, the instruction memory  and the processor  can be replaced with specialized hardware to implement the preferred embodiment of the invention, without the need for an operating system layer . In other embodiments, an operating system may provide an unprotected access method, and an application could add this functionality. This access functionality could be used solely for the operating system, or provided as a service for other applications. As another example of the breadth of scope contemplated in this disclosure, one mechanism was described in , with the understanding that it represents one example of the more general notion of providing a mechanism for the processor  to store and retrieve information to and from the NVM . The NVM  can be embodied in various forms, and those differences (among others) can result in different interface mechanisms (e.g., SPI, serial, parallel, etc.).",{"@attributes":{"id":"P-00028","num":"00028"},"figref":["FIG. 3","FIG. 2A","FIG. 3","FIG. 2A","FIG. 2A"],"b":["214","222","2","302","304","306","214","230","212"],"sub":"EW","sup":"8"},"An EW lifecycle tick results in a decrement of the counter, which if it occurs at or below the threshold counter value, causes a surplus in EW cycles to be accumulated, resulting in a plurality of EWs that experience no delays (i.e., no \u201cdesigned-in\u201d NVM access delays) upon requests for EWs. The EW lifecycle tick  can be programmed into the NVM access manager  based on design criteria, and determined according to the EW lifecycle tick equation . As shown, the EW lifecycle tick  is preferably determined by dividing the design life (in seconds) by the maximum specified EW cycles.","In the examples that follow, a 7-year design life is assumed, and a maximum specified EW cycle of 1 million EW cycles is used to determine the EW lifecycle tick . If EW cycles were limited to the EW lifecycle tick , after 7 years, NVM  () would preferably have some minimum retention time for data, say approximately 10 years of charge retention for this example. Although 7 years and 1 million cycles are used in the examples that follow, it is understood that such criteria are design choices, and consequently the scope of the invention includes other specified design criteria. Failure of the embedded device  () to abide by the specifications in actual use, such as by a rogue application (resident in memory  () or located remotely) causing a greater frequency of EWs to NVM , can reduce this residual charge retention to days or hours, resulting in lost data and\/or failure of operation of the embedded device  or other cooperating system components.","The NVM access manager  () (via the counter manager , ) preferably maintains a balance sheet of EW debits and credits, delaying the EW when the counter value exceeds a threshold counter value, and backing off the delays (or accumulating credit towards non-delayed EWs when below the threshold counter value) for each EW lifecycle tick. EW delays are employed by appending a delay to each write request (WR), wherein the delays can accumulate enough to cause EW operations to occur at the specified EW lifecycle tick rate if WRs are excessive, thus preventing intermediary EWs corresponding to intermediary WRs (those occurring during the delay period) and preserving the life of the NVM  (FIG. A).",{"@attributes":{"id":"P-00032","num":"00032"},"figref":["FIG. 4A","FIG. 2A"],"b":["200","2","402","308","3","404","222","406","408"],"sub":"d "},"Assuming a starting point at the threshold counter value of 80 (short for hexadecimal 0\u00d780), the first WR occurs at 5 seconds past the starting point. As shown, the EW occurs at approximately the same time as the WR with no delay and the counter is incremented to 81. Further, a delay is calculated (e.g., via delay determiner , ) for the next EW. As shown in , the delay, t, is determined by equation  by calculating the difference between the counter value above threshold (here 0\u00d781, or in decimal, 129) and the threshold counter value (here 0\u00d780, or 128), divided by the difference between a total counter value and the threshold counter value, multiplied by the EW lifecycle tick (e.g., 221 sec). Note that in this example, an 8-bit signed value gives a range of \u2212128 to +127. Since zero is a valid value, this range results in a total counter value of 256 in decimal. Although shown using hexadecimals and decimals, this subtraction can be performed using 2 s complement math, ASCII, among other subtraction mechanisms well known to those having ordinary skill in the art. Further, although shown using numbers, the math can be performed using variables as well.","The result of calculations using equation  (using the decimal equivalents 129 for hexadecimal 81 and 128 for hexadecimal 80 as one example) is a delay of [(129\u2212128)\/(256\u2212128)]*221, or 1.7 seconds. This value will be appended to the next WR, providing for a delayed EW. Returning to , as shown, the next WR occurs at 10 seconds, but the actual EW occurs at 11.7 seconds from the starting point (or 1.7 seconds beyond the WR at 10 seconds) because of the delay. The counter is incremented to 82 (decimal equivalent equal to 130), and a new delay is calculated for the next WR, and again based on the equation  (FIG. B), the delay is [(130\u2212132)\/(256\u2212128)]*221, or 3.4 seconds. The next WR at 15 seconds results in an EW delayed 3.4 seconds from that WR, or at 18.4 seconds. Again, the counter is incremented (to hexadecimal 83), and a new delay is calculated to be 5.1 seconds.","When the next WR occurs at the 20 second mark, note that the delay will cause it to extend beyond the next WR that occurs at 25 seconds (since 5.1 is greater than 5 seconds). Referring to the example embedded device  shown in , data written into one or more blocks of the buffer NVM blocks  () at the WR at 20 seconds will be overwritten by the data written into that block at the WR=25 seconds mark. Thus, the WR at 20 seconds does not prompt an immediate EW by the NVM access system  () to NVM  (FIG. A), although a write does occur to the buffer NVM blocks  for each WR. The WR at 20 seconds is used for the purpose of referencing the delay of 5.1 seconds (and for prompting writes to the buffer NVM blocks ). Thus the data in storage component  () from the WR at 25 seconds is written to NVM  approximately 5.1 seconds after the WR at 20 seconds. The counter is then incremented to hexadecimal 84, and a new delay of 6.8 seconds is calculated. Again, the WR at 30 seconds does not prompt an immediate EW to NVM , but is written to the buffer NVM blocks  and the data resulting from the WR at 35 seconds is written to NVM 30, 6.8 seconds after the WR at 30 seconds.","The counter is incremented to hexadecimal , and a new delay is calculated to be 9.3 seconds. The WR at 40 seconds is the reference from which the delay is calculated and the data from storage component  () entered via the WR at 45 seconds is written to NVM  () at 9.3 seconds after the WR at 40 seconds. This process can continue to accumulate delays within an EW lifecycle tick until a maximum of the EW lifecycle tick (221 seconds) is reached, with WRs resulting in EWs to the buffer NVM blocks  in the storage component  but resulting in delayed EWs to NVM , such that EWs occur at the 221 second intervals to preserve the rated life of the NVM against the rogue application that is causing excessive writes. At the 221 second mark (the EW lifecycle tick interval), the counter decrements. If for some reason the EWs ceased, the counter would continue to decrement at each EW lifecycle tick until the delays disappeared and writes could occur without delay. Thus, delays within a lifecycle tick would begin at the first WR that occurs that is not within a delay period should the same or another rogue application cause excessive EWs again.",{"@attributes":{"id":"P-00037","num":"00037"},"figref":["FIG. 5","FIG. 2A","FIG. 5"],"b":["10","30","2"]},"Beginning at the start, step  includes receiving an event that prompts the NVM access manager  () into operation. This event can be, for example, a control signal from the processor  () in response to an interrupt generated from a peripheral device, such as a timer, an applications programming interface (API), or other component and\/or device (not shown) enabling the NVM access manager  to execute NVM control access functionality. In other instances, this event can be a control signal from a temporary storage device or other device requesting a write, EW, erase, and\/or read operation to and\/or from the NVM  () via direct memory access.","As the NVM access manager  () is monitoring for write requests and lifecycle ticks, step  includes determining whether the event is a write request (WR) or a lifecycle tick (LT). If a lifecycle tick is detected, the counter is decremented (step ) and a comparison of the value of the current counter value and the threshold counter value (e.g., 0\u00d780) is made. This comparison can be performed by the processor  () or the NVM access manager  via combinational logic such as an ALU or other processing device, as would be understood by those having ordinary skill in the art. If the current counter value is greater than the threshold counter value, then a delay is calculated (or re-calculated if the current operating environment was under a delay situation) according to step . The delay is determined according to the equation  described above in association with , and preferably performed by the delay determiner  () or in other embodiments by the processor  alone or in coordination with the delay determiner . If the current counter value is less than or equal to the threshold counter value, operations continue at step .","Returning back to step , if the received event is a write request, then in one implementation, a comparison is made of the affected block data (i.e., data in a block subject to a write) in NVM  () and the corresponding data in buffer NVM blocks  () in storage component  () (step ). This comparison can be performed according to several mechanisms well known in the art. For example, a flag bit can be employed for each block of the buffer NVM blocks  indicating whether data has changed since the last write to NVM . In other instances, a flag may not be used, but instead, the data in an affected block can be scanned by a periodic wake-up coordinated with the timer  () (e.g., every 100 msec, or after every delay period has expired) and in cooperation with the NVM access manager  (FIG. A). In other embodiments, the comparison of data can be ignored and writes can occur such that NVM data in the NVM blocks  can be erase-written for writing in identical data.","Continuing to step , if there is no difference between data to be written and the data that is to be replaced, the write request is ignored (step ), and operation continues to step . If there is a difference in data, a comparison is made between the current counter value and the threshold counter value to determine if the current environment is operating under a delay period (step ). If the counter value is greater than the threshold counter value, then the NVM access manager  () knows it is in a delay period and thus it incorporates the delay (step ) before it performs the write to the NVM  () (step ). If the counter value was less than or equal to the threshold counter value, no delay was necessary and the NVM access manager  would implement the write (step ). Step  includes incrementing a counter, and then operations proceed to step , wherein a new delay period is calculated and then the NVM access manager  awaits the next event.","In other embodiments, the accumulating delays can be omitted, and the NVM access manager  () could cause writes to only occur at 221-second intervals and prohibit EWs to NVM  () for all intervening WRs. For example, surpluses in EWs could occur in the presence of continuing EW lifecycle ticks that occur in the absence of WRs, and EWs in response to WRs occur only at EW lifecycle tick intervals.","In some embodiments, the concept of \u201ccredit\u201d can be issued for average downtime (e.g., power off time). As one example, in set-top box operations for subscriber television systems, a user may power off his or her set-top box on an average of 6 hours per day. The NVM access manager  () can be programmed to consider this downtime as EW credit (e.g., the threshold counter value may not be 0\u00d780, but some lower value).","Further note that in some embodiments, a controlled shut-down of the system (e.g., due to a user request, an error handling mechanism that detects operating system problems, and\/or from hardware detecting removal of power) can prompt a buffer flushing mechanism whereby all unsaved buffers of the buffer NVM blocks  are written to NVM  () immediately (and thus overriding the delay mechanisms of the preferred embodiments).","The NVM access manager  can be implemented in hardware, software, firmware, or a combination thereof. In the preferred embodiment(s), the NVM access manager  is implemented in software or firmware that is stored in memory and that is executed by a suitable instruction execution system. If implemented in hardware, as in an alternative embodiment, the NVM access manager  may be implemented with any or a combination of the following technologies, which are all well known in the art: a discrete logic circuit(s) having logic gates for implementing logic functions upon data signals, an application specific integrated circuit (ASIC) having appropriate combinational logic gates, a programmable gate array(s) (PGA), a field programmable gate array (FPGA), etc.","The NVM access manager  which comprises an ordered listing of executable instructions for implementing logical functions, can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions. In the context of this document, a \u201ccomputer-readable medium\u201d can be any means that can contain, store, communicate, propagate, or transport the instructions and\/or data for use by or in connection with the instruction execution system, apparatus, or device. The computer readable medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a nonexhaustive list) of the computer-readable medium would include the following: an electrical connection (electronic) having one or more wires, a portable computer diskette (magnetic), a random access memory (RAM) (electronic), a read-only memory (ROM) (electronic), an erasable programmable read-only memory (EPROM or Flash memory) (electronic), an optical fiber (optical), and a portable compact disc read-only memory (CDROM) (optical). Note that the computer-readable medium could even be paper or another suitable medium upon which the instructions and\/or data is printed, as the instructions and\/or data can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.","It should be emphasized that the above-described embodiments of the present invention, particularly, any \u201cpreferred embodiments\u201d are merely possible examples of implementations, merely setting forth a clear understanding of the principles of the inventions. Many variations and modifications may be made to the above-described embodiments of the invention without departing substantially from the spirit of the principles of the invention. All such modifications and variations are intended to be included herein within the scope of the disclosure and present invention and protected by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The preferred embodiments of the invention can be better understood with reference to the following drawings. The components in the drawings are not necessarily to scale, emphasis instead being placed upon clearly illustrating the principles of the present invention. Moreover, in the drawings, like reference numerals designate corresponding parts throughout the several views.",{"@attributes":{"id":"P-00007","num":"00007"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00008","num":"00008"},"figref":["FIG. 2A","FIG. 1"]},{"@attributes":{"id":"P-00009","num":"00009"},"figref":["FIG. 2B","FIG. 1"]},{"@attributes":{"id":"P-00010","num":"00010"},"figref":"FIG. 2C"},{"@attributes":{"id":"P-00011","num":"00011"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 4A"},{"@attributes":{"id":"P-00013","num":"00013"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"P-00014","num":"00014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
