---
title: Revocation method and apparatus for secure content
abstract: A system and method is provided for revoking a device. A method includes receiving a certificate from the device, the certificate including one or more of fields, at least one of the fields holding a signature, attempting to verify the signature, receiving a revocation list from a source, the revocation list identifying one or more data on the certificate as valid or invalid, the data including at least one of the fields of the certificate; and if one of one or more signatures identified unsuccessfully verified and one or more data is identified as invalid, preventing the transmission of a session key to the device, the session key being required to establish a secure communication channel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07672903&OS=07672903&RS=07672903
owner: DPHI Acquisitions, Inc.
number: 07672903
owner_city: Longmont
owner_country: US
publication_date: 20010827
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCES TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Overview","TPDRM Copy","Other Embodiments"],"p":["This application is related to U.S. patent application Ser. No. 09\/542,510, \u201cDigital Rights Management within an Embedded Storage Device\u201d to Lane W. Lee and Daniel R. Zaharris, filed Apr. 3, 2000, which application is incorporated herein for all purposes.","This application is related to U.S. patent application Ser. No. 09\/940,083, \u201cA Secure Access Method and System\u201d to Timothy R. Feldman, Lane W. Lee, Michael F. Braitberg, Douglas M. Rayburn, and Gary G. Kiwimagi, filed herewith, which application is incorporated herein for all purposes.","This application is related to U.S. patent application Ser. No. 09\/940,174, \u201cSystem and Method for Detecting Unauthorized Copying of Encrypted Data\u201d to Lane W. Lee, Timothy R. Feldman, Douglas M. Rayburn, and Gary G. Kiwimagi, filed herewith, which application is incorporated herein for all purposes.","This application is related to U.S. patent application Ser. No. 09\/940,025, \u201cSystem and Method for Identifying Vendors of Hidden Content\u201d to Steven B. Volk, Michael F. Braitberg, Timothy R. Feldman, Lane W. Lee, Douglas M. Rayburn, and Gary G. Kiwimagi, filed herewith, which application is incorporated herein for all purposes.","This application is related to U.S. patent application Ser. No. 09\/940,035, \u201cAn Unlocking Method and System for Data on Media\u201d to Lane W. Lee, Timothy R. Feldman, Douglas M. Rayburn, and Gary G. Kiwimagi, filed herewith, which application is incorporated herein for all purposes.","This application is related to U.S. patent application Ser. No. 09\/940,026, \u201cHost Certification Method and System\u201d to Lane W. Lee, Timothy R. Feldman, Douglas M. Rayburn, and Gary G. Kiwimagi, filed herewith, which application is incorporated herein for all purposes.","This application is related to U.S. patent application Ser. No. 09\/939,960, \u201cMastering Process and System for Secure Content\u201d to Lane W. Lee, Timothy R. Feldman, Douglas M. Rayburn, and Gary G. Kiwimagi, filed herewith, which application is incorporated herein for all purposes.","1. Field of the Invention","The present invention relates to the field of digital rights management. More particularly, this invention relates to security and systems and methods that ensure that content is accessed, copied and controlled in secure ways in an electronic environment.","2. Description of the Related Art","Entities, including people, companies, systems and computers transfer information faster than ever since the advent of the Internet and technologically advanced electronic appliances. Facsimile machines, computers, and electronic appliances such as personal digital assistants (PDAs) and wireless phones with Internet access enable the quick transfer of information to remote locations around the world.","The quick transfer of information is not without drawbacks. Information in digital form, while readily transferable, is also readily accessible to many more entities than ever before. So-called \u201chackers\u201d attract attention by quickly retrieving information from computer systems before being detected. Similarly, world-wide web pages quickly disseminate electronic content on the Internet, such as MP3 data containing copyrighted material. Thus, electronic content reaches individuals to whom it was not intended. For this reason, electronic content providers, businesses and citizens are increasingly concerned about security issues.","The issue concerning security of electronic content and the Internet is timely and hotly debated. For example, Alanis Morissette addressed the issues of copyright and royalties to a U.S. Senate Judiciary Committee headed by Orrin Hatch in a hearing entitled \u201cOnline Entertainment and Copyright Law: Coming Soon To A Digital Device Near You.\u201d In her speech, Alanis highlighted the differences in goals between content creators, content providers and content users. Commercial content providers desire compensation for the electronic content. These content providers are concerned with the prevalent copying of content without compensation, such as compact disks (CDs) and digital video disks (DVDs). Individual content users are often at cross purposes with content providers, desiring unauthorized copying of content, including digital music, software programs, movies, digital books and the like. Content creators, who desire as wide an audience as possible, are often tom between dissemination goals and compensation goals.","The speed with which appliances, computers and the like disseminate electronic content caused an increase in complex security techniques. These complex security techniques attempt to ensure the security of the content and the transactions. For example, one security technique protects electronic transactions and content by using a time stamp or a counter to determine whether a transaction is authentic. Other security techniques focus on cryptography and mathematical algorithms.","Cryptographic solutions not only provide confidentiality to transactions and content, but provide methods for authentication, integrity (e.g., verifying that a message has not been modified in transit), and non-repudiation (preventing false denials of transactions). Some cryptographic solutions are referred to as restricted algorithms that typically are used by low-security applications. More recently, cryptographic keys protect content by requiring a key for both encryption and decryption of content. Key-based cryptographic solutions enable the spreading of an algorithm without risking security breaches because the security onus is on the keys themselves.","There are a number of cryptographic key solutions. One type is the symmetric key solution in which an encryption key can be calculated from the decryption key and vice versa. A more secure key solution is the public-key solution, or asymmetric solution, in which the key used for encryption is different from the key used for decryption. The public-key solution is part of the ISO authentication specifications, commonly known as the X.509 protocols. More specifically, the X.509 protocols provide a framework for authentication across networks, such as the Internet. The X.509 protocols do not specify a particular algorithm. Instead, the protocols focus on using public-key certificates. Under the specification, each user has a distinct name and has a signed certificate with a name and a public key issued by a trusted certification authority (CA). Typical fields in an X.509 certificate include: version; serial number; algorithm identifier; issuer; period of validity; subject; subject's public key; and signature. More specifically, a version field identifies a format for the certificate. A serial number is unique for the certification authority. The algorithm field identifies the type of algorithm used to sign the certificate and includes necessary parameters to run the algorithm. The issuer field identifies the name of the CA. The period of validity field provides the time period during which the certificate is valid. The subject field identifies the name of the user. The subject's public key field provides the algorithm name, parameters and such related to the public key.","Communicating using certificates configured according to the X.509 protocol is known in the art. A user desiring to communicate with another retrieves the destination certificate from a database and verifies authenticity. Verifying authenticity often involves several CAs if there is a hierarchy of CAs between the user's CA and the destination CA. After verification, communication may take place. Typically, timestamps are used to confirm that messages are current. A three-way protocol is one authentication protocol that does not use timestamps, however, additional steps are required involving the user checking a random number that was originally generated by the user, sent to the destination, and received back from the destination. Likewise, the destination checks a random number received from the user that was originally generated at the destination.","Another known security technique is fingerprinting messages. Fingerprinting is typically accomplished using a hash function. There are a number of types of hash functions. A common hash function is the one-way hash function that provides a fixed-length hash value, h, after operating on an arbitrary-length pre-image message. The h is unique to the message associated with it. However, the security of the h depends on the number of bits of the hash. A practical size is 128 bits. There are a number of different types of hashing algorithms, including the Message Digest (MD) 4 algorithm, the MD5 algorithm, which is more complex than the MD4 algorithm. Another type of hash function is the n-hash algorithm. A more complicated hash algorithm than the one-way hash, an n-hash algorithm implements a randomizing function, hashing and logical exclusive OR functions.","The descriptions of cryptographic solutions above represent a sampling of known digital security systems. Another aspect of the security of electronic content concerns digital rights management (DRM). DRM entails the establishment and management of rights and permissions for digital content and supports distribution of digital content. DRM is necessary for digital distribution of educational, professional and trade content as well as entertainment content.","Some known DRMs use the eXtensible Rights Markup Language (XML) to implement access and use controls for the exchange of secure digital content. Markup languages are typically based on the Standard Generalized Markup Language (SGML). SGML is a standard language for defining the format in a text document that allows sharing of documents among computers, regardless of hardware and operating system configurations. Markup language files use a standard set of code tags embedded in text that describes the elements of a document. The web browser interprets the code tags so that each computer having its own unique hardware and software capabilities is able to display the document while preserving the original format of the document. An SGML document uses a separate document type definition (DTD) file that defines the format code tags embedded within it.","Other DRM schemes are implemented with C, Fortran and other known programming languages. Known systems include Interleaf, ArborText, and TexCel.","As discussed above, content providers, content creators and content users are in conflict. Known DRM systems fail to resolve the conflicts between these stakeholders in the electronic content world. More specifically, to resolve the conflicts, a DRM is needed that meets content users expectations, including allowing a consumer fair use of content. Further, content providers, including content owners and manufacturers need a DRM that maintains content security, supports new and expanded business models and brings high value to the marketplace for the content. One area in which improvement is needed is in the area of security of devices. Content providers, content vendors, and users, must be assured that devices that are unauthorized can be revoked.","Accordingly, system and method is provided for revoking a device. A method includes receiving a certificate from the device, the certificate including one or more of fields, at least one of the fields holding a signature, attempting to verify the signature, receiving a revocation list from a source, the revocation list identifying one or more data on the certificate as valid or invalid, the data including at least one of the fields of the certificate; and if one of one or more signatures identified unsuccessfully verified and one or more data is identified as invalid, preventing the transmission of a session key to the device, the session key being required to establish a secure communication channel.","In accordance with embodiments of the present invention, a secure electronic content (SEC) system provides a solution to electronic content concerns of the content creators, content providers, content owners, and content users. The scope of the SEC system includes media, an engine capable of providing read and write access to the media, encryption and access riles, encoding, decoding, meanings, associations, navigation and presentation, the standardization of each of which results in a seamless security system for electronic content.","The encryption and access rules disclosed in embodiments herein provide an invisible and seamless ContentKey\u2122 digital rights management (CKDRM) system that secures content and allows content to be portable and interoperable with appropriate electronic devices The CKDRM supports fair use by content purchasers and users with the CKDRM directly supporting personal use copies of electronic content and allowing import and export of content. According to embodiments disclosed herein, pre-recorded, unlocked content located on media is playable at a point of sale by a device designed to render content protected with the CKDRM or other third party digital rights management schemes (TPDRMs). For purposes of this disclosure the term pre-recorded content includes mastered content.","Further, pre-recorded locked content on media may be unlocked by a device\/player operating in accordance with an embodiment by connecting with a clearinghouse. Depending on the permissions granted on media, any player may render the content after unlocking. Moreover, unlocked content may be moved onto CKDRM associated media and be rendered on a player. The embodiments further disclose that the media may be written to without resulting in content capable of being rendered on any player, but only on predetermined players. According to one embodiment, for example, the CKDRM permits a predetermined number of copies of pre-recorded, unlocked content as determined by content providers and licenses and the like.","Further, the CKDRM supports new content consumer experiences by providing a method of unlocking content and managing content. The disclosed CKDRM is implemented by devices capable of rendering electronic content, hereinafter \u201cplayers.\u201d Players implement the CKDRM and interface with servers, kiosks, replicators, and the like. Players either embed an engine that operates with the CKDRM to provide security or couple to the engine, for example, a personal computer (PC). Further, players render content on digital media, such as disks. In another embodiment, a PC implements a player.","The CKDRM is also extensible by, in part, providing a flexible unlocking method and supporting the transfer of content and rules to other DRM implementations. Specifically, a player implementing CKDRM is further capable of implementing third party DRMs (TPDRMs). In an embodiment, a player with an embedded engine implements CKDRM and exposes a file system and a CKDRM application programming interface (API) through general purpose interfaces. The CKDRM advantageously provides numerous functions, including unlocking, play, counting copies, importing from certified sources, exporting to certified destinations, and securing metadata storage.","A Secure Electronic Content System","The CKDRM system includes security and access rules as part of the secure electronic content system.","For purposes of the discussion of the Secure Electronic Content (SEC) System, the following glossary applies:","PKI: Public Key Infrastructure","AES: Advanced Encryption Standard.","API: Application programming interface. This term refers to the logical interface between components","CA: Certificate Authority. The Certificate Authority is the entity that issues certificates.","Content Provider: The Content Provider is the entity that owns the rights to the content and participates in the delivering content to the marketplace.","DFS: DataPlay File System. In at least one embodiment, DFS is an open application programming interface (API).","Engine: The component that provides read and write access to digital media.","Host: The device controlling the engine.","USB: Universal Serial Bus\u2014Physical connection between the Client PC and a connected engine","MAC: MAC is an acronym for Message Authentication Code.","SHA-1: SHA is an acronym for Secure Hash Algorithm, which is defined by NIST FIPS PUB 186","Protected Content: \u2014Content that is stored on the digital media in an encrypted form under the governance of CKDRM.","Unlocked Content\u2014Protected Content that is available to be rendered on any certificated device capable of rendering the content. Unlocked Content that was pre-mastered onto the media in this state may also referred to as Primary Content.","Locked Content: Protected Content that is not available to be rendered until a CKDRM unlock transaction occurs which will change it to Unlocked Content. Locked Content is also referred to as Secondary Content.","Key Complement: The information required to complete a set of decryption keys that enables Locked Content to become Unlocked.","Referring to Table 1A, the interoperability of the parts of the secure electronic content system:",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Interoperability Stack"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["101","User Interface"]},{"entry":["102","Presentation"]},{"entry":["103","Navigation"]},{"entry":["104","Associations"]},{"entry":["105","Meanings"]},{"entry":["106","Encoding"]},{"entry":["107","Access Rules"]},{"entry":["108","Encryption"]},{"entry":["109","File System"]},{"entry":["110","Media"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 1A provides an interoperability stack showing the layers with which the CKDRM operates. The stack further includes layers supplied by other TPDRMs, players on which an appropriate engine is embedded, and players coupled to such players. The term \u201cengine\u201d as used herein refers to a component that provides read and write access to digital media. As such, embodiments include one or more of a firmware, software, and hardware, or any combination thereof implementation of an engine. The CKDRM is focused on layers  and  of the interoperability stack.","Referring to layer , electronic content that is pre-recorded or written is bound to the media and does not reside on a player or on an engine. The system enables a plurality of methods of storing data on a media disk. For example, a disk in accordance with an embodiment allows secure pre-recorded content, written content or both pre-recorded and written content on the same disk. Data may be stored on the disk in large blocks or small blocks of data.","Referring to layer , the system supports a hierarchical directory structure with file data. Thus, data written by the file system \u201cwrites\u201d and returned for file system file \u201creads\u201d are stored as file data. According to an embodiment, only the data stored in files is accessible through the file system application-programming interface (API). As used herein an API refers to a logical interface between components.","The interpretation of the file data is indicated by file type, as, for example, a MIME string, directory and file name. According to an embodiment, only the data stored in files is accessible through the file system API. Layer  does not allow full access to metadata through file system reads and writes. Rather, metadata allows an engine to support the storage of data outside the file system. Thus, some metadata is visible to the host, such as file names, MIME type, size and attributes. Other metadata is exposed only via the CKDRM API. Yet other metadata is only available to an engine. For example, according to an embodiment, secret media identifiers and private metadata is visible only to an engine. Data may be associated with a disk, a directory and a file. The engine, in accordance with the CKDRM may change and manage the metadata and thus, updates consume less of available disk capacity.","According to an embodiment, predetermined metadata is bound to the engine and not stored on a disk Further, the predetermined metadata is not accessible through the file system API. This information includes the engine's firmware, and public and private key pair. The key pair is generated in conjunction with engine manufacturing, and according to a secure process. According to one embodiment, field updates of engine private storage are supported by the CKDRM via a secure process.","The SEC system advantageously allows TPDRM metadata to be stored with each file, if desired. Moreover, an embodiment allows multiple TPDRM metadata for any individual file. TPDRM metadata may have an ownership identifier that matches a received CKDRM Certificate, as described in further detail below, to gain access to the metadata.","In an embodiment, TPDRM metadata is stored with each file, and, therefore uses the metadata system already used in an appropriate file system, such as the DataPlay File System (DFS). TPDRM metadata nodes may have a bit set in a file system flag definition to identify the data as TPDRM metadata.","A metadata packet may be that shown in Table 1B. Each symbol showing \u201cU\u201d followed by a number indicates an unsigned value and a bit length of the value.",{"@attributes":{"id":"p-0114","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Name","Description\/Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["struct META *","psNext","Internal pointer for linked list."]},{"entry":["DFSID","DfsId","Handle of the file to attach"]},{"entry":[{},{},"the metadata."]},{"entry":["DFSFLAG","Flags","Internal use flags -"]},{"entry":[{},{},"including a bit defining this"]},{"entry":[{},{},"item as a"]},{"entry":[{},{},"DRM_METADATA must"]},{"entry":[{},{},"be set."]},{"entry":["U16","MetadataOwner","Identifier that must match"]},{"entry":[{},{},"the Metadata Owner field in"]},{"entry":[{},{},"the received ContentKey"]},{"entry":[{},{},"Certificate in order to"]},{"entry":[{},{},"establish ownership of the"]},{"entry":[{},{},"metadata."]},{"entry":["SYMMETRIC_KEY","MetadataKey","The key used to encrypt the"]},{"entry":[{},{},"data."]},{"entry":["U16","ByteCount","Number of bytes in metadata"]},{"entry":["U8[ ]","Metadata","The DRM metadata itself."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table 1B In an embodiment, TPDRM metadata is stored in RAM type memory. However, if TPDRM metadata it too large to store all of it in RAM, then a lookup system may be employed wherein the TPDRM metadata is replaced with a value that represents the location for the metadata item.","Certain data is available only through the CKDRM API, including data managed by the engine, including metadata providing play keys and remaining copy counts. According to some embodiments, data available through the CKDRM API includes data managed by a second TPDRM, in which case the format is defined by the TPDRM.","Referring now to , a block diagram illustrates a content storage model for electronic content. As shown, there are five basic models in which content may be stored and governed. One type is shown as ungoverned content using file system methods only .","Ungoverned content  includes basic information such as cleartext data, such as in a general computer storage model. Also shown in  is TPDRM-governed content . Such governed content may use the same methods and facilities as ungoverned content . Such content includes TPDRM-governed content using file system methods only . In this model , the TPDRM has responsibility for securing the content and the metadata. Model  does not require pre-qualification of the TPDRM by the CKDRM, thus any TPDRM may be operable to govern content in this model. This matches the model of TPDRM-governed content on storage without security facilities.","In another type of storage of electronic content, TPDRM-governed content is accessed with the file system, but metadata accesses use CKDRM facilities such as CKDRM APIs . This embodiment of a content storage model provides a greater level of security for the metadata and to encryption keys. Block  relates to a model of governing content using CKDRM metadata rules and a TPDRM API wherein the TPDRM API governs rendering of electronic content. The model provides a high level of security for the content itself as additional layers of encryption are implemented by an engine.","Another content storage model  provides that content is governed by both a TPDRM and by CKDRM rules for content and metadata. This model  permits an overlap between CKDRM governed content and third party DRM governed content. Thus, the system supports content accessed through a CKDRM API and governed by a third-party DRM.","Access model  provides the content and metadata are governed by the CKDRM. Model  provides a higher level of security for the content by providing that pre-determined metadata never leaves the engine. One type of content appropriate for this model is pre-recorded content.","A third party DRM controlling content has a choice of models for moving content to a disk. As those of skill in the art appreciate, rules governing the content may constrain the choice of models available. Further, required security requirements may govern the choice of model, with CKDRM models providing greater security. Further, the CKDRM models, when sufficient to govern necessary permissions of the content, provide efficient and value-added benefits to consumers and content providers.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 1","b":["160","160","170"]},"Referring now to , a content flow diagram  illustrates how content organized in one of the plurality of models shown in  flows in the secure electronic content system. A content provider  decides the content following one of the models shown in . Once a master is created on media, a replicator  creates multiple copies for distribution. Examples of media following this content flow path include compact disks (CDs), digital versatile disks (DVDs), optical disks such as DataPlay\u2122 optical disks and magnetic media such as floppy disks and tapes. The replicator  is a manufacturer that includes on any media any necessary data to enable secure functionality of the content as described above with reference to . According to another embodiment, the content flows from a content provider to a server . Server , in one embodiment, transfers the secure content to one or more of a kiosk , directly to an engine equipped to receive secure data (), or to a connected host  that is coupled to an engine (). The connected host , in one embodiment, is a personal computer that enables CKDRMs, TPDRMs and file system rules. Content also flows from an engine () to an embedding device . The embedding device , in an embodiment, enables CKDRM and TPDRMs.","Also shown in , content flow includes flow from an engine to another engine as between engine () and (). Such content flow occurs during a copy function, as more fully explained below.","Architectural Overview","The CKDRM operates in the context of the secure electronic content system (SEC system).  illustrates methods supported by the secure electronic content system in block form. The components include a content provider , tools and processes for producing pre-recorded content , appropriate media, such as a disk , an engine , the players  and the DRMs  discussed above.","According to an embodiment, the components are organized into an architecture that partitions the SEC system and assigns responsibilities. For example, a content provider  brings the original content and makes decisions for all of the variable qualities. The decisions include: which files are initially locked and unlocked; when the file is unlocked, whether the content may be played by player running CKDRM or TPDRMs; how many copies may be made according to CKDRM rules and TPDRM rules; and what rules are to be governed in the CKDRM domain and the TPDRM domain.","In one embodiment, the electronic content system supports global TPDRM rules that limit the number of subsequent copies a TPDRM is allowed to make. In other embodiments, the electronic content system supports rules for specific TPDRMs.","The tools and processes for producing pre-recorded content  take all of the inputs from a content provider  and create appropriate digital media  that conforms to all of the requirements of pre-recorded content. The content is encoded, if not already, in one of a plurality of formats. The content is encrypted in layers of encryption with keys generated and stored in predetermined methods as described herein. The CKDRM metadata and TPDRM metadata, if present, are stored in accordance with methods described herein.","Digital media , according to an embodiment, contains all of the information needed to support all of the usage models and permissions specified by content provider .","In one embodiment, a player  is a certified host  that receives a certificate  from a certificate authority . Certificate  provides an authentication portion of the protocols, and establishes an authenticated channel for access to secure API's.","Engine  presents APIs to the players  and TPDRMs and CKDRMs to support a plurality of the usage models. In one embodiment, engine  supports security through the methods implemented in hardware and firmware, but also by embodying cryptographic keys. In one embodiment the cryptographic keys are unique to each engine and some are global among all engines. For example, each engine may include non-volatile memory that stores a signature key list. In one embodiment, the list is an array of public keys used for validating CA signatures.","In one embodiment, using secure APIs, the engine  is an endpoint in the authenticated connections that are established. The engine  decrypts and encrypts various encryption layers in the play, copy and handoff functions. The engine  enforces the basic unlock transactions at the disk  level. The engine  governs the play and copy permissions, including decrementing the copy counts on the disk .","In one embodiment, the engine  operates with a USB or other interconnection driver that conforms with APIs used by the CKDRM and DFS APIs. The driver, in an exemplary embodiment allows the engine to communicate with hosts, including players, such as PCs regardless of the host hardware manufacturer or configuration. The operating system may communicate with a Windows\u2122 Registry or .inf file(s) to locate the driver on a system when multiple engines are connected to a host.","In some embodiments, player  is a host portion of a device that embeds an engine . Alternatively, a player  may be an application on a platform coupled to a device with an embedded engine . In each alternative, player  uses the APIs exposed by the engine  to access content and presentation information on a disk . The player  uses that information to present data to a user and render the content. To access secure content, player  is an endpoint in the authenticated connection that is established in the secure API . Further, to play content, a player , in accordance with an embodiment, must request an authenticated channel after an authority  certifies the player . The certification process includes issuing player  a public key and private key pair, and a certificate . The authenticated channel allows access to a secure API .","As discussed above, CKDRM and, if media is configured to use TPDRMs, one or more TPDRMs, manage rights and govern operations on secure content. CKDRM and\/or TPDRMs implement the rules specified by the content provider  and stored on the disk . To access secure content, either the CKDRM or a TPDRM is an endpoint in the authenticated connection that is established in the secure API . The TPDRM implementation is outside of the engine . Nonetheless, the engine  through a secure API  offers secure storage on media . Further, if configured to use TPDRMs, the TPDRMs must be compliant with the disclosed secure electronic content system. More particularly, a compliant TPDRM must request an authenticated channel before accessing content and secure data. According to an embodiment, the authenticated channel is created by first certifying the TPDRM and issuing a public key and private key pair, and a CKDRM certificate. The CKDRM certificate may include a CA Signature Public Key ID or public key identifier that acts as an index to a valid signature key list of an engine  for a number of purposes as explained in further detail below. The authenticated channel is created for further access to a secure API.","Referring now to , an Open System Interconnection Model (OSI Model)  of the SEC system is shown that provides an overview of the architecture for supporting the functions described with reference to  and other functions.","In , the layered OSI model  shows the supported paths in the host , engine  and media . As shown,  includes a physical layer , a command-data layer , a data link layer , a session layer  and an application layer .  describes each of the layers with reference to components of interconnection between a host , an engine  and digital media . Interconnections outside of the host , engine  and digital media are within the scope of present invention and the exclusion with reference to  is by no means intended to be limiting.","The OSI model  is described below with reference to the flow of electronic content as shown in . A media , such as a disk or other portable media, or media permanently stationed in an engine , includes file system file data , file system metadata  and CKDRM metadata  as part of its physical layer. At the host  and the engine , the data flows through physical layer interfaces  and . The data on the media  flows through a data link layer  that interprets the data in optics  in an optical disk embodiment. One of skill in the art will appreciate that the interpretation of other types of media will require other interpreters, for example, a magnetic interpreter for magnetic media, etc. In the host  and the engine , an interface protocol  provides the data link layer .","At the command data layer , a player reads or writes to the media  via read\/write . In the host  and the engine , at command data layer  the interface protocol runs either a file system  and\/or the CKDRM , depending on data read at read\/write . More particularly, according to one embodiment, a host  must be certified at the application layer  to run CKDRM . The certification process as more fully described below, determines whether the host  is secure  or insecure . A certified host runs encrypt-decrypt processes in the session layer  to authenticate a channel as more fully described herein. An uncertified host  runs insecure processes  at the session layer  via an open file system .","For insecure content, the engine  performs file and metadata mapping  at the application layer and runs open file systems  at the command data layer . For secure content, the engine  processes files and maps metadata at block , but also encrypts and decrypts the secure data at the session layer via secure () and encrypt-decrypt () using the CKDRM rules  at the command data layer . In an embodiment, the host  and the engine  work with the media by having servo positioning  direct a player to locations on the media  where secure content should be found at the session layer . The secure and insecure data are then managed at block manager  at the application layer .",{"@attributes":{"id":"p-0142","num":"0141"},"figref":["FIG. 4","FIG. 4"],"b":["412","416","1","418","1","430","1","430","2","413","420"]},"CKDRM Security\u2014Overview","Referring now to , an overview of the CKDRM security  is described. The CKDRM implements an efficient security model wherein electronic content is created and secured via an application  and represented in files  as well as metadata . The content elements  and  are encrypted. Thus, when the content file  is read or copied through an open API an encrypted form is returned. When content is accessed for play or handoff to a TPDRM the content with a lighter form of encryption may be returned.","Access to secure content  and  is through open APIs and secure APIs  and , respectively. Open APIs  only allow plain file read and write access ; the secure metadata and unencrypted content are not available via open APIs . Further, neither secure APIs  nor open APIs  expose raw content or block access to the media. The secure APIs  have restricted access to content  and  in that only secure APIs may retrieve secure metadata . Further, the access is subject to revocation in revocation methods .","The open and secure APIs  and  highlight a crucial difference between a hard drive interface and an interface using APIs  and . According to an embodiment, block level access of contents on media is via firmware including a block driver. Block level access to content on a hard drive of a computer is generally accessible via only a block driver. The firmware prevents open access by not supporting block access for block drivers. The file system may be hierarchical in nature. In one embodiment, the media disk may have a writeable, write-once portion, and a read-only portion with pre-mastered content. A media identifier may be in one or each of the portions and may or may not be the same identifier. Further, in one embodiment, the identifier is read from the media disk and extracted for use in an application specific integrated circuit (ASIC) and\/or firmware. The identifier may be used as a seed to an encryption block with or without a decryption block. In one embodiment, the encryption block may be a triple-DES block.","Referring to , a method according to an embodiment is directed to media including an identifier, and more particularly, to a secure method of extracting data from media. Block  includes enabling access to the data via firmware. The data may be stored in blocks and accessible via a block driver within the firmware. Block  provides for preventing access to the data outside the firmware. In one embodiment, the firmware is included within an application specific integrated circuit (ASIC). The firmware and the ASIC may be within a host. In one embodiment, the firmware may include, a TPDRM API, a CKDRM API and\/or a DFS APT.","Referring back to , the block diagram further shows that access to the secure APIs  and secure content  and  is further restricted by requiring a certificate . According to a certification procedure shown in , in block  hosts receive a certificate  from an entity controlling certification of hosts. The certificate  specifies the secure APIs  to which an application  may have access. In this embodiment, a host includes any physical device that embeds an engine, a TPDRM, an application running in an open computing environment, or a clearinghouse server. More particularly, CKDRM Certificates may be signed by a private key assigned according to a class of device. In one embodiment, private keys are used only for one class, and the corresponding public key belongs to a class of devices. The device classes may include engines, host devices embedding an engine, but with no external digital I\/O port, host devices embedding an engine, and with digital I\/O ports, and host applications not embedding an engine. In one embodiment, engines have the public keys for the devices they wish to authenticate, and the engine may need only to authenticate one embedding host.","Referring to , in block , to enable an engine-to-engine copy function, each engine receives a certificate. Engines also need to authenticate host applications not embedding an engine by receiving a certificate. In block , the entity controlling certification cryptographically signs certificate . The certificate  specifies a category that designates the secure APIs  to which the certificate holder host receives access. In one embodiment, certificates  specify the company to which the certificate  was issued. In another embodiment, certificate  also specify one or more of the product category, product line, model, revision and serial number of the engine and\/or host.","A certificate in accordance with an embodiment is shown below in Table 2A.",{"@attributes":{"id":"p-0150","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2A"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Field #","Field Name","Assignment responsibility (source)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","CA Identifier,","Assigned by entity controlling certification"]},{"entry":[{},"Version","of hosts"]},{"entry":["2","Sign Key ID","Assigned by CA"]},{"entry":["3","Exposed Methods","Assigned by CA to restrict host permis-"]},{"entry":[{},{},"sions"]},{"entry":["4","Company","Assigned by CA"]},{"entry":["5","Model ID, Revision","Assigned by Company"]},{"entry":["6","Metadata ID","Allocated by CA"]},{"entry":["7","Host Signature Key","Assigned by Company for Host Signature"]},{"entry":[{},{},"verification"]},{"entry":["8","CA Signature","Verifies all of 1-7"]},{"entry":["9","Serial Number","Assigned by Company"]},{"entry":["10","Protocol Key","Assigned by Company for Secure Key Ex-"]},{"entry":[{},{},"change"]},{"entry":["11","Host Signature","Assigned by Company. (The host protocol"]},{"entry":[{},{},"public key signed by the private key cor-"]},{"entry":[{},{},"responding to the host signature public"]},{"entry":[{},{},"key) Verifies 1-10"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The first eight items in Table 2A are supplied to a certifying authority (CA) by the company requesting a certificate. A company retains a private key that corresponds to the Host Signature Key. The CA signature is created using a private key that corresponds to a public key specified in a Signature Key ID. The first eight fields are returned to the manufacturer when a device passes qualification. The last three fields, 9-11, are added by the manufacturer.","As one with skill in the art with the benefit of this disclosure appreciates, the certificate enables an entity to control quality of hosts and engines by invalidating false devices, and devices with latent defects. In one embodiment, the fields 1-8 are issued by the entity controlling hosts and engines and provided to a device manufacturer. The device manufacturer then appends fields 9-11.","In one embodiment, the certificates have certificate classes that provide a set of methods that may be exposed as specified by a CKDRM certificate. Any combination of methods may be exposed by the certificate format. However, an example of possible exposed methods that may be exposed via the certificate class is provided in Table 2B.","As shown, the classes may include an engine, a player, a TPDRM domain, a CKDRM mastering tool domain, a kiosk, and a clearinghouse server domain. The exposed methods are TPDRM and CKDRM methods. Although any combination of exposed methods is possible for any particular class, Table 2B shows one possible embodiment.",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Class","Exposed Methods"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Engine","CKDRM Copy"]},{"entry":[{},"Player","CKDRM Record"]},{"entry":[{},{},"CKDRM Play"]},{"entry":[{},"TPDRM","CKDRM Record"]},{"entry":[{},{},"TPDRM Copy"]},{"entry":[{},{},"Read Secure"]},{"entry":[{},{},"Metadata"]},{"entry":[{},{},"Write Secure"]},{"entry":[{},{},"Metadata"]},{"entry":[{},"CKDRM Mastering Tool,","CKDRM Record"]},{"entry":[{},"Kiosk","Write Secure"]},{"entry":[{},{},"Metadata"]},{"entry":[{},"Clearinghouse","CKDRM Record"]},{"entry":[{},{},"CKDRM Unlock"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Referring back to , in one embodiment, in block , a SEC system may provide for host sanctioning. More particularly, in host sanctioning CKDRM secure APIs are available only to hosts that are officially and formally sanctioned by an entity, such as DataPlay, Inc. The authorization, in an embodiment includes issuance in block  by the entity, such as DataPlay, Inc., of a certificate indicating the CKDRM secure APIs that are available.","Another more specific form of a CKDRM Certificate Format is provided below in Table 2C:",{"@attributes":{"id":"p-0158","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2C"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0:1","CAIdentifier","U16 (Unsigned","Assigned by entity such as"]},{"entry":[{},{},"16 bit value)","DataPlay\u2009\u2122."]},{"entry":["2:3","CertificateFormat","U16","Assigned by CA."]},{"entry":[{},"Version"]},{"entry":["4:5","CASignaturePublic","U16","Assigned by CA."]},{"entry":[{},"KeyId"]},{"entry":["6:7","CryptographyVersion","U16","Assigned by CA."]},{"entry":["8:9","ExposedMethods","EXPOSED","Assigned by CA. Identifies"]},{"entry":[{},{},"METHODS: Set","exposed methods by"]},{"entry":[{},{},"of 16 flags","horizontally encoding each"]},{"entry":[{},{},"representing","method with an assigned bit."]},{"entry":[{},{},"methods in Table"]},{"entry":[{},{},"2B"]},{"entry":["10:15","Reserved1","U16[3]","Reserved."]},{"entry":["16:17","Company","U16","Assigned by CA."]},{"entry":["18:19","Division","U16","Assigned by Company."]},{"entry":["20:21","Product Line","U16","Assigned by Company."]},{"entry":["22:23","Model","U16","Assigned by Company."]},{"entry":["24:25","Revision","U16","Assigned by Company."]},{"entry":["26:27","MetadataIdentifier","U16","Allocated by CA."]},{"entry":["28:31","Reserved2","U16[2]","Reserved."]},{"entry":["32:77","CompanySignature","PublicKey (46 bytes)","Assigned by Company."]},{"entry":[{},"PublicKey",{}]},{"entry":["\u200278:121","CASignature","Signature (44 bytes)","Assigned by CA. The value is"]},{"entry":[{},{},{},"the above data signed by the"]},{"entry":[{},{},{},"private key corresponding to"]},{"entry":[{},{},{},"CASignaturePublicKeyId."]},{"entry":["122:137","DeviceIdentifier","U128 (16 bytes)","Assigned by Company."]},{"entry":["138:183","ProtocolPublicKey","PublicKey","Assigned by Company. Used"]},{"entry":[{},{},{},"by engine for public key"]},{"entry":[{},{},{},"encryptions in some protocol"]},{"entry":[{},{},{},"steps such as session key"]},{"entry":[{},{},{},"exchange."]},{"entry":["184:227","CompanySignature","Signature","Assigned by Company. The"]},{"entry":[{},{},{},"value is the rest of the"]},{"entry":[{},{},{},"certificate signed by the"]},{"entry":[{},{},{},"private key corresponding to"]},{"entry":[{},{},{},"the Host Signature Public Key."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The fields in Table 2C include the following: CAIdentifier uniquely identifies the CA; CertificateFormatVersion uniquely identifies this version of the CKDRM certificate format; CASignaturePublicKeyId is selected by the CA; CryptographyVersion uniquely identifies the cryptographic methods used by the certificate; ExposedMethods identifies the CKDRM methods to which this certificate allows access","The fields ExposedMethods fields are shown in Table 2D (EXPOSED_METHODS type):",{"@attributes":{"id":"p-0161","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2D"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Bit Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HOST_CKDRM_COPY","Indicates whether the CKDRM Copy"]},{"entry":[{},"method is allowed."]},{"entry":["HOST_CKDRM_RECORD","Indicates whether the CKDRM Record"]},{"entry":[{},"method is allowed."]},{"entry":["HOST_CKDRM_PLAY","Indicates whether the CKDRM Play"]},{"entry":[{},"method is allowed."]},{"entry":["HOST_CKDRM_UNLOCK","Indicates whether the CKDRM Unlock"]},{"entry":[{},"method is allowed."]},{"entry":["HOST_DRM_COPY","Indicates whether the TPDRM Copy"]},{"entry":[{},"method is allowed."]},{"entry":["HOST_READ_SECURE","Indicates whether the Read Secure"]},{"entry":["METADATA","Metadata method is allowed."]},{"entry":["HOST_WRITE_SECURE","Indicates whether the Write Secure"]},{"entry":["METADATA","Metadata method is allowed."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The fields in Table 2C further include fields that are more specifically described below.","A company may uniquely identify the company to which the certificate is issued. In one embodiment, for example, the field size supports 65,536 different companies. However, as one of skill in the art appreciates, a larger or smaller size field is within the scope of the present invention. The exemplary field size shown in Table 2C supports, at a rate of 10 per day, 365 days per year, 18 years of valid certificates.","The company may further supply the Division, ProductLine, Model and Revision values of their choice to the CA. Together, the information supplied uniquely identifies the product design to which the certificate is issued.","The CA allocates MetadataIdentifier values. These uniquely identify access to secure metadata in the Read Secure Metadata and Write Secure Metadata methods, as explained in greater detail below.","The Company also supplies the HostSignaturePublicKey with the Company retaining the corresponding private key. CompanySignature is created using this corresponding private key and is verified with CompanySignaturePublicKey.","CASignature is created using the private key that corresponds to the public key specified by CASignaturePublicKeyId.","The last three fields may be added by the Company on a device-by-device basis. DeviceIdentifier is a value such as a serial number that uniquely identifies the device to which the certificate is issued. ProtocolPublicKey is selected by the Company; the corresponding private key is embedded in the device.","In one embodiment, when encrypting with the host's public key in the CKDRM protocols, ProtocolPublicKey is used, not CompanySignaturePublicKey. CompanySignaturePublicKey is used only to authenticate ProtocolPublicKey through CompanySignature.","Each of the fields discussed above may be presented as the CKDRM Certificate. Further, the MetadataIdentifier field in combination with the Company field identifies a host for purposes of access to secure metadata. The values may be allocated by the CA in response to requests for new values from the Company.","The fields in the certificate are designed to carry 326-bit public key values for 163-bit elliptic curve cryptography. However, other sized values and types of cryptography are within the scope of the invention.","There are a number of circumstances in which an invalidated device can be discovered using the certificate. Referring to , one of revocation methods  includes transmitting an encrypted identifier from the device via a communication channel and receiving a certificate identifying the device as one of an authenticated device and a non-authenticated device.","In one embodiment, revocation methods  revoke compromised certificates and cryptographic keys. Specifically, revocation methods  revoke compromised certificates and private keys. In one embodiment, information as to whether certificates and\/or private keys have been revoked is stamped on the media. Thus, revocation is enforced in stand alone, unconnected environments.","APIs  and  shown in  may be encrypted. Further, cryptographic keys with which the content\/API is encrypted may themselves be encrypted. By encrypting content it is possible to allow open file system read access to files containing content. The file system reads and delivers the encrypted content without the decryption keys. When access is made through a secure protocol, the content may be delivered in a form that is different from the stored form. Thus, according to an embodiment, even if playback keys are compromised there is not enough information to decrypt any open API files.","According to a further embodiment, cryptographic keys are bound to the media. Thus, content access follows the media and access rights are not bound to a particular playback device. In the embodiment, key binding not only stores the keys on the media, but also encrypts the keys to media identifiers. Therefore, the content being doubly encrypted, when and if bound play or copy keys are compromised there is not enough information to decrypt the content. Referring to , the binding of keys to the media is described in a flow diagram. As shown, block  provides that a method of securing content stored on media includes attaching content rights to the media. The attaching of the content rights to the media may preclude content being located in a player or engine. Rather, a player or engine may operate to render the content stored on the media only. Block  provides for permitting access under predetermined conditions. The access to the content as described in block  may include one or more of playback of contents, copying of content, allowing one or more copies or a limited number of copies. The predetermined conditions identified in block  may include following an authentication procedure as outlined in , and may include authenticating a channel for delivery of content, checking a revocation list and unlocking content. In one embodiment, the unlocking is according to a method performed between an engine and a server as further explained below. Unlocking may entail, connecting with a server, following a protocol to retrieve a secure key, and using the secure key to unlock one or more portions of the content. Block  provides for performing one or more of authenticating a channel, checking a revocation list and unlocking content.",{"@attributes":{"id":"p-0176","num":"0175"},"figref":["FIG. 6","FIG. 6"],"b":["600","602","604","606","606","610","606","612","610","604","612","612","612","612"]},"In block , the host is verified for revocation. Revocation is available at all of the levels of granularity of the certificate as implied by all of the fields. Part of the validation, in one embodiment, requires checking a revocation list  on media . The engine  retrieves the revocation list  from the media . If the validation process  passes at block , the engine  generates a random number via random number generator  to obtain a first portion of a secure session key . The engine  performs a public key encryption  using the first portion of the secure session key  and a protocol public key  retrieved from the certificate . The host  receives the encrypted session key, decrypts the encrypted session key at block  and produces the secure session key .","Referring now to  in combination with , the apparatus that performs the verification process is shown. In one embodiment, the apparatus is part of the engine .  illustrates that a communication channel couples the engine  to a host holding a certificate . The certificate  is received and an identifier , which could be implemented as a public key, is compared within the engine with a verify function . More specifically, the verify function  receives both the identifier and an output from a validation engine . The validation engine  produces a global pass\/fail indication that is output to the verify function . The verify function , if it receives a fail indication from the validation engine , will deny further access to content. If a global pass indication is received, the verify function  communicates a pass indication to permissions block . Permissions block  includes multiple pass\/fail permissions for the player  that are provided to validation engine . After processing the permissions, the validation engine  outputs a session key  permitting data delivery.","According to one embodiment, each time a device is coupled via a communication channel an authentication process begins. Each device is qualified each time the encrypted identifier is received. Thus, a method for certifying a device includes transmitting an encrypted identifier from the device via a communication channel and receiving a certificate identifying the device as one of an authenticated device and a non-authenticated device. Referring to , a method for securely delivering data across a channel is shown in flow diagram form. The method for authenticating a destination for the data includes receiving a certificate from the destination in block  and, in block , using an identifier to qualify the destination. The method continues in block  with transmitting a session key. The session key allows the delivery of the data according to predetermined criteria in the certificate.","As described above, the certification procedure certifies and the authentication procedure authenticates hosts and engines. Authentication allows an entity to verify and validate another. The result of a successful authentication is that one entity knows the public key and other attributes of the other entity. Successful authentication also results in the establishment of an authenticated channel through which the allowed secure API's are exposed.","The host, according to an embodiment, is one of a player, a player in a PC, a player in a device, a clearinghouse, a server, and a TPDRM application. According to one embodiment, a revocation list is stored on media inserted into an engine. The revocation list is used in the validation process. Thus, if a known serial number for a device relates to a compromised or later rejected manufacturer, the host will not be authenticated. In a further embodiment, the revocation list can be copied on each device to prevent the device from playing, or the revocation list can remain media dependent. Thus, when disks are released to market with pre-recorded content, or when blank disks are manufactured, new revocation lists may be included on the disks so that appropriate players and hosts may be found and invalidated. Additionally, in another embodiment, revocation lists may be maintained by a server such that players communicating with a server will receive updated revocation lists a directly to the engine during changing state processes, such as unlock and lock.","In a further embodiment, a plurality of revocation lists are stored on media on a file by file basis, such that one or more files on the media may have a revocation list associated with the file. In this embodiment, the revocation list(s) is accessed, not during an authentication process, but during a file access process, or a combination of both an authentication and a file access process.","Referring to , a method for revoking a content rendering device is provided.  begins with block , wherein a revocation list is evaluated upon a file access. In one embodiment, each file may have one list, with duplicative entries being limited by centrally storing the details and providing each file with a list of identifiers or pointers that reference a location of complete details regarding revocation information. The revocation information, hereinafter referred to as a node, is centrally located with a unique identifier. Each file may optionally have list node identifiers instead of storing complete revocation information. In block , upon a file access and evaluation of revocation information, the result for each node is stored. The authentication process may include reading evaluation results rather than re-executing an evaluation, i.e., each node may be pre-evaluated.","In one embodiment, as shown in block , the revocation list is copied onto the engine from media and could include a \u201cpoison pill\u201d that prevents a player from working if it is not a proper player, if the manufacturer had defects, latent defects, or the like. The revocation list can be updated, as shown in block , when a player is connected to a server to unlock data.","In one embodiment, revocation of a content rendering device includes at least revocation of one or more signature keys. In the embodiment, the revocation of the one or more signature keys also revokes, in block , a set of CKDRM Certificates signed with the one or more keys. More specifically, the revocation of a signature key will revoke any corresponding signature.","In one embodiment, the key signature list that is stored in non-volatile memory in an engine is not capable of update outside of a manufacturing process. In this embodiment, the key signature list may be revoked on a per-media basis by revoking a particular index value in the CA Signature Public Key ID field of the CKDRM Certificate.","Referring back to , revocation lists are used to provide a mechanism to prevent access to CKDRM methods for a given device or set of devices. The CKDRM revocation method allows revocation to occur on any of the fields within the host certificate. Therefore, revocation may be as explicit as a single Device Identifier or Protocol Public Key, or as broad as an entire company, or perhaps a particular product line, or a particular product model as shown in block .","As discussed above, each file may have an associated revocation list. The revocation list is associated with the file during a create-file command. The revocation list is transmitted to the destination copy during the CKDRM Copy method.","A revocation list may be made up of a list of revocation nodes. Each revocation node is made up of a list of clause nodes and a rule of how to combine the clauses to determine revocation for the node. Each clause node is made up of a set of data and functions that define how to apply the data and evaluate them against the fields in a received CKDRM Certificate.","Referring to , the evaluation of a revocation list is described. Block  provides for evaluation of the data in a clause node according to the function results of a true or false result when evaluated against the contents of a CKDRM certificate. A set of results from the clause nodes are combined in block  according to the clause rules to result in a true or false result for the revocation node. If any revocation node in the revocation list evaluates to true, in block  the host is revoked.","Table 2F provides one exemplary embodiment of a revocation list.",{"@attributes":{"id":"p-0192","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2F"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Byte",{},{},{},{}]},{"entry":["Offset","Field Name","Type","Value","Description\/Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0:1","ByteCount","U16 (unsigned 16 bit","i","The number of bytes, i, in this revocation"]},{"entry":[{},{},"value)",{},"list including this field. This value must be"]},{"entry":[{},{},{},{},"greater than or equal to 4. The NodeCount"]},{"entry":[{},{},{},{},"field must be present."]},{"entry":["2:3","NodeCount","U16","j","Number of nodes, j, in this revocation list."]},{"entry":["\u20034:i-1","RevocationNodeList","REVOCATION",{},"Each entry defines a revocation"]},{"entry":[{},{},"NODE[j]",{},"node."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Table 2G provides an embodiment of a revocation node structure.",{"@attributes":{"id":"p-0194","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2G"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Byte",{},{},{},{}]},{"entry":["Offset","Field Name","Type","Value","Description\/Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{"sup":"\u2003"},"ByteCount","U16","k","The number of bytes, k, in this revocation node"]},{"entry":[{},{},{},{},"including this field. This value must be greater than 4."]},{"entry":[{},{},{},{},"Empty ClauseNodeLists are not allowed. This value"]},{"entry":[{},{},{},{},"must be less than 1500. No revocation node may be"]},{"entry":[{},{},{},{},"over 1500 bytes in size."]},{"entry":["2","ClauseCount","U8","l","Number of clauses, 1, in this revocation node."]},{"entry":["3","ClauseRules","U8",{},"Defines the rules associated with evaluating"]},{"entry":[{},{},{},{},"the combination of clauses. See ClauseRules"]},{"entry":[{},{},{},{},"encoding for values."]},{"entry":[{"sup":"\u2009\u2009"},"ClauseNodeList","CLAUSE_NODE[l]",{},"Each entry defines a clause."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Table 2H provides an embodiment of a clause node structure to support multiple functions with a general format.",{"@attributes":{"id":"p-0196","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2I"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Byte",{},{},{},{}]},{"entry":["Offset","Field Name","Type","Value","Description\/Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0:1\u2003\u2002","ByteCount","U16","2m+","The number of bytes, 2m+4, in this clause node"]},{"entry":[{},{},{},"4","including this field. The value of m must be positive."]},{"entry":[{},{},{},{},"Empyt FunctionData arrays are not allowed."]},{"entry":["2:3\u2003\u2002","Function","U16",{},"The function to perform for this clause of the revocation."]},{"entry":[{},{},{},{},"The only defined function is Match."]},{"entry":["4:2m+3","FunctionData","U16[m]",{},"The m words of data to use to perform the function"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Table 2J provides for an exemplary clause node structure for a match function:",{"@attributes":{"id":"p-0198","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2J"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Byte",{},{},{},{}]},{"entry":["Offset","Field Name","Type","Value","Description\/Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0:1\u2003\u2009\u2009","ByteCount","U16","2n+8","The number of bytes, 2n+8, in this clause node including this field."]},{"entry":[{},{},{},{},"This value of n must be positive. Empty MatchData arrays are not"]},{"entry":[{},{},{},{},"allowed."]},{"entry":["2:3\u2003\u2009\u2009","Function","U16","Match","The function to perform for this clause of the revocation is the Match"]},{"entry":[{},{},{},{},"function."]},{"entry":["4:5\u2003\u2009\u2009","StartWord","U16",{},"The offset in the ContentKey Certificate at which to start the Match"]},{"entry":[{},{},{},{},"function."]},{"entry":["6:7\u2003\u2009\u2009","WordCount","U16","n","The number of words to match, n, starting at offset StartWord."]},{"entry":["8:2n+7","MatchData","U16[n]",{},"The value of the n words to match."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment and engine receives revocation lists during the CKCMD_CREATE_FILE or CKCMD_SET_KEYBOX command. The revocation list for multiple files may contain revocation nodes that are already present on the media.","On the media, a revocation list may be maintained as an object within the DFS file system with a separate and distinct handle that is not a file or directory. The DfsId field may be used as a reference number for files to use in the RevocationIdList field of the ContentKey metadata structure.","For this embodiment, an exemplary revocation node structure may be that shown in Table 2K.",{"@attributes":{"id":"p-0202","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2K"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Type","Name","Description\/Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["struct META*","psNext","Internal pointer for linked list."]},{"entry":["DFSID","DfsId","Handle of the revocation node."]},{"entry":["DFSFLAG","Flags","Internal use flags - a bit defining"]},{"entry":[{},{},"this item as a"]},{"entry":[{},{},"REVOCATION_NODE is set."]},{"entry":["U8","Evaluation","A tri-state flag indicating"]},{"entry":[{},"Result","REVOKED, NOT_REVOKED,"]},{"entry":[{},{},"NOT_EVALUATED."]},{"entry":["REVOCATION_NODE","Revocation","The actual data contained in the"]},{"entry":[{},"Node","revocation node, as passed in by"]},{"entry":[{},{},"the host."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Referring to , a method performed by an engine when presented with a revocation list is provided.","Block  provides that during allocation of the CKDRM metadata, use the NodeCount value to create enough space in memory for a list of 16-bit identifiers that will reference each revocation node. In block , for each node in the revocation list, the engine compares the node to each node that is in the existing revocation list. In block , if an identical node is found, add the DfsId number of the existing node to the RevocationIdList in the CKDRM metadata structure. In block , if the node is not found, create a new node with a unique DfsId. In block , the engine adds the new DfsId value into the ContentKey metadata structure.","Referring to , the evaluation method for revocation list results is explained in detail. As shown, in block , the revocation list is evaluated each time the CKCMD_AUTHENTICATE command occurs, or when a new piece of media is inserted into the engine. In block , the revocation list is evaluated against a received CKDRM Certificate. For each node of the revocation list, in block , the evaluation results in a revoked or not revoked status for that node. Because nodes are file dependent, these states are evaluated each time a CKDRM operation that is specific to a particular file is attempted. Therefore, revocation results are finalized not by CKCMD_AUTHENTICATE, but rather from CKCMD_DRM_PLAY, CKCMD_GET_METADATA, CKCMD_GET_PLAY_KEY, CKCMD_PLAY, CKCMD_RECORD_APPEND, CKCMD_SET_KEYBOX, CKCMD_SET_METADATA, and CKCMD_UNLOCK_FILES. The commands are discussed in further detail below. In block , the results of evaluation are stored in a EvaluationResult field of the Revocation node structure.","Mastering Process","Another part of the security system requires a mastering process. The media disks discussed herein, in an exemplary embodiment, organize content according to the method shown in . As shown, the method begins with block , wherein content is organized on the media using a predetermined application. In one embodiment, the application uses a dongle attached to a machine that is running a tool. Within the dongle, an ASIC with an embedded random key generator may act as a secret key generator. In another embodiment, the application is not part of the mastering process, but is delivered as a DLL or library to third-party authoring houses. The DLL or library may require a third-party authoring house to authenticate itself to the DLL or library prior to creating CKDRM content. In another embodiment, the dongle and the application work together such that the dongle does not work except with a particular registered version of a DLL or library.","In one embodiment, the application is responsible for content security by, as shown in block , creating a public identifier and a CKDRM identifier; in block , encrypting the content files; in block , adding engine-managed copy and play rules as specified by the content owner; in block , adding TPDRM specific rules as specified by the content owner; in block , adding a revocation list. As one of skill in the art will appreciate, however, the functions performed by the mastering application may include a portion, all or one of the above-provided functions.","The application discussed above could be a part of a mastering, an authoring or a premastering portion of manufacturing a media disk. Thus, for example, the application includes a business method for creating locked and unlocked content on a disk wherein the mastering process is followed by an authoring process, followed by a premastering process.","In one embodiment, the use of mastered content on the disk provides a method of detecting counterfeit disks posing as pre-mastered disks. For example, as discussed below, in an embodiment, an identifier for pre-mastered disks has at least a portion of the identifier pre-mastered. This enables detection of identifiers posing as pre-mastered, as more fully explained herein.","Referring now to , a process flow diagram presents one embodiment of a process flow for a process including a mastering process for creating media and setting up a clearing type server. The process begins at block . Block  provides for a new release process for asset and information procurement. Block  provides that one or more of content files, metadata information, security information and package collection information is transferred to media. Content files may include files that a consumer or user will play and any asset files tied to particular content. In one embodiment, the process assumes that all files are encoded with a proper media coder-decoder (codec). The metadata information provides a description of the assets that will accompany a content file. The metadata information may include graphics and lyrics. In an embodiment, the information is provided in a structured format which may are may not be in a standard format for all content providers. In one embodiment, the metadata is on a per-track and per-media basis. The security information transferred to the media provides rules governing the way the consumer or user can interact with the content. The interactions with the content may include copying, rendering, and manipulating the content, as in, for example, placing notes in a margin or electronic highlighting of electronic books.","In one embodiment the rules provide a revocation list and TPDRM rules for a third-party digital rights management scheme. The TPDRM rules provide the rules that the consumer may be restricted to regarding playing and copying content. The TPDRM rules further include details such that authoring and mastering process as described herein receive data as to the files that are initially locked. In one embodiment, a revocation list is defined by a content provider, the revocation list providing a list of all player devices, player applications and servers that have been revoked for reasons determined by a revoking party. The package collection information provides a specification as to how any secondary content is to be grouped and how it should be displayed to a user or consumer. The package collection information must include specifications for each package, such as display images and package description.","Block  provides for an authoring process wherein all the files provided by a content provider are packaged according to predetermined specifications. In one embodiment, the specifications include organizing the data in a directory structure such as a DataPlay MMF directory structure. In one specification, the structure requires directories containing encoded content files, a directory structure, a content manager, an autorun.inf and a contents.ddl file. More specifically, the content manager provides files that are used to present the content on media to a consumer or a user, such as an executable file, a mini-website, or a proprietary or form defined by a content provider. The autorun.inf file provides data to the autorun handler as discussed herein and interacter therewith to launch the content manager. The contents.ddl file may be stored within the MMF directory structure to be used with a TPDRM. The contents.ddl file may include a package collection, advertisements and package SKUs. More particularly, a package collection may include a unique identifier for all secondary content on a side of a media and may contain a reference to one or more advertisements The advertisements may be grouped as a package and used by a presentation layer to display the secondary content and offers. An SKU herein may be defined by a content provider and reference one or more files on the media. The MMF DDL files include files that describe the relationship between content and asset files.","As part of an authoring process, a content provider chooses whether to use a CKDRM, TPDRM, or a combination of both DRMs. After and depending on the DRM chosen, content files are packaged with encryption and all content and files as necessary for the chosen DRM to work properly. Block  provides for a pre-mastering process in which a master file set is stored and delivered on a media, such as a tape. In one embodiment, each file set may provide a single side on a media disk. Another process performed in the premastering process is generating a keyComplement.ddl file that configures a secure database, such as the CKDRM secure database. The KeyComplement.ddl file may include a package collection identifier including a full file path, a file handle, a key complement such as a complement to a 128 bit number and a key version. Finally, the premastering process includes passing the contents.ddl file.","Block  and  provide for passing the mastered file set on a media such as a tape to a glass master for stamping the content in manufacturing to produce, in block , a media disk. The glass masters create one or more stampers for mass producing the media disks that may be distributed to consumers or other users. On the server side, block  provides that a master server receive data in a secure database. More particularly, a server process includes loading a key complement and package to a key mapping database table or tables with information specified in the keycomplement.ddl and contents.ddl files.","Referring now to , the process described in  is performed with another process that may be performed at the same time as the process described in . More particularly,  provides for creation of a package collection, packaged advertisements and SKUs to be provided during the process of . Block  provides for a start of the process to set up an Internet retailer (eTailer). Block  provides for a content provider to perform a package setup and a change process \u201cpackage definition.\u201d More particularly, in blocks  and , content providers provide eTailers with a contents.ddle file  and package display graphics and information  that may be part of a package presentation to a consumer or user. Generally, eTailers are interested in a packageCollectionSKU. ETailers may not be interested in a PackageCollectionID, which is passed to the eTailer via a URL. An eTailer may pass the PackageCollectionID to a clearinghouse server and then discard.","Block  provides that an eTailer sets up and changes pricing for packages received based on packages specified as available by a content provider. In one embodiment, the configuring a database with package pricing and package presentation data is defined completely or in pertinent part by an eTailer such that the configuration conforms with an existing format of the eTailer, such as a \u201cshopping cart,\u201d or \u201ccatalog maintenance\u201d format. Another configuration performed by an eTailer may include choosing to specify discount models and advertising. This embodiment enables an eTailer to advertise based on demographics and particular consumers and users.","Another aspect of the security provided by the SEC system relates to the use of one or more random number generators. As discussed, in one embodiment, a random number reaches the media via a mastering process. In another embodiment, a random number generator is also present within an engine. For example, each engine produced may include non-volatile memory holding a random number. One method of generating the random number, is by using high quality generation software, such as FIPS-186-compliant software. The random number generator within an engine may be receptive to seeding by one or more techniques. For example, a seed may be a random number created at the time a master is created; a random number created upon manufacturing of the engine; a random number created and embedded in the firmware; a PublicSideId; a number generated from a spin up time number; a number generated from a servo calibration time number; a seek time; BCA fields; a number generated from long-term collection data such as spin-up count, read\/write error rate, or the like; a number generated from servo\/read\/write calibration values from manufacturing stored in the non-volatile memory; a number generated from calculating read-write-read timing; a number generated from inputs to analog-to-digital converters; and any number that may be a function of any of the above numbers.","Functions Between an Engine and a Host","Referring now to Table 3, functions for exchanging information between an engine and a host are illustrated. The host may be a Player, DRM, kiosk or server. In a copy mode, as further discussed below, a destination engine is a host.",{"@attributes":{"id":"p-0221","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"TPDRM",{}]},{"entry":["CKDRM Functions","Functions","DFS Functions"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CKDRM Play 312","TPDRM Play 320","File System Write 374"]},{"entry":["CKDRM Unlock 360","TPDRM Copy 340","File System Read 372"]},{"entry":"CKDRM Copy 330"},{"entry":"Record Unlocked"},{"entry":"content 362"},{"entry":"Record Locked content 364"},{"entry":"CKDRM Record 350"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"As shown, the primary functions include CKDRM play , TPDRM play , CKDRM copy , TPDRM copy , record content , including recording locked content  and recording unlocked content  and CKDRM Unlock . One media optionally holds both content  and  as pre-recorded CKDRM content. The authoring, pre-mastering and mastering tools each play a role. For example, a content provider may specify the CKDRM properties including the lock\/unlock state, play\/no-play state, number of allowed CKDRM copies, number of allowed TPDRM copies, and the number of copies a TPDRM may make from its copy. Additional TPDRM rules may be specified for specific TPDRMs.","Play Function","More specifically, CKDRM play  permits unlocked, playable CKDRM content to play on any player. The CKDRM play function delivers electronic content from an engine to a player along with the information needed to decrypt and render the delivered format. The engine governs whether permissions exist for the play  function. In one embodiment, function  does not decrement a play count. Rather, play permissions for unlocked and playable CKDRM content are implicitly unbounded by count or time.","Referring to , a flow diagram illustrates the API for the CKDRM play function . The API requires that a player or host be certified following a certification procedure prior to opening the API. The host is not allowed to store the content in any way that allows access to any other entity, even encrypted until the host is authenticated. The API further does not permit players to temporarily store decrypted content or transfer decrypted content via an insecure channel. According to a host authentication procedure , block  provides for a host to deliver a certificate qualifying a host. An engine coupled to the host in block , transmits a session key. After authentication, the engine selects a decryption play session key . Block  requires delivery of a play session key from the engine to the host, such as a player. A player receives this play session's decryption key for a specified file. Block  provides that a host decrypts the play session key using a session key. Block  provides that the player receives encrypted content. Block  provides that the play session decryption key received at block  decrypts the content.","Unlike CKDRM play, the TPDRM play  permits unlocked CKDRM content to play via a TPDRM. The TPDRM play function  delivers electronic content from an engine to the TPDRM along with the information needed to decrypt and render the delivered format. The governance of whether permissions exist for this function is enforced by the TPDRM. The CKDRM does not decrement play counts, check for time restrictions or any other governance. Rather, the TPDRM is capable of governing and\/or changing its own metadata as part of its play function.","Copy Function","Another function is the CKDRM copy function . Function  permits copying of pre-recorded, unlocked content from one media to another media when there are remaining copy permissions. The CKDRM copy function  decrements the number of permissible copies remaining on an original media. More particularly, CKDRM, in one embodiment, provides for creating a limited number of copies. Any copies from media with a limited number of copies using the CKDRM copy function  share the qualities of the original copy in that they are playable in any player. The copies, however, may not themselves be copied. A content provider optionally specifies the number of copies that may be made from an original. Each time a copy is made the CKDRM copy function  decrements the number of remaining allowed copies.","Referring to , the method for the CKDRM copy API protocol is illustrated. Block  provides for authentication of the destination engine. More specifically, a source engine makes sure that the destination is a valid engine so that secure content is not given out indiscriminately. Block  provides that the destination engine delivers a media identifier to which the new copy is to be bound. Block  provides for delivering of a key box for the destination. In block  the destination engine receives the keys necessary to use the content. In particular, these are the decryption keys for playing the content. In an exemplary embodiment, the keys are delivered pre-bound to the destination media. Block  provides for copying the encrypted content. DFS commands are used for copying the content. In one embodiment, the copy function  is supported in environments with one engine and sufficient buffer for temporary storage of content, as well as in environments with two engines.","TDDRM copy function  permits unlocked content to be copied by a TPDRM if there are remaining TPDRM copy permissions. The TPDRM copy function  decrements the number of permissible copies remaining for a source file. Like CKDRM copy function , TDDRM copy function  provides for creating a limited number of copies. The resultant copies are governed by the TPDRM. A content provider may specify the number of copies that may be made from a file.","To receive a copy of content, a certified TPDRM copies content from the domain of the CKDRM to the TPDRM. The content delivered will be encrypted and the decryption key(s) will be delivered to the receiving DRM.",{"@attributes":{"id":"p-0232","num":"0231"},"figref":["FIG. 10","FIG. 6"],"b":["1010","1020","1030","1040"]},"Record Function","Another function provided by the CKDRM is recording content . Recording content  permits content providers that author, pre-master and master content to provide electronic content that may be replicated as unlocked content. The data imported as unlocked is readable and encrypted. Conversely, recording content  permits content providers that author, pre-master, and master pre-recorded to provide content that may be replicated as locked content. This content is not playable until it is unlocked. The locked content may, however, be unlocked using the CKDRM, after which the content has the same qualities as unlocked content.","CKDRM record  further includes importing to the domain of CKDRM from a kiosk, player or a TPDRM. In this form, the content will play in any player. Other types of CKDRM recording  include acquiring content through electronic distribution and playing the content on players.",{"@attributes":{"id":"p-0236","num":"0235"},"figref":"FIG. 11","b":["1110","1120","1130","1140"]},"Governed content can be brought into the CKDRM domain in three ways. One way is to use a TPDRM that governs the content and is capable of a handoff into CKDRM. Another is to construct a server that governs the content and uses the CKDRM record protocol. In contrast to the CKDRM unlock method, recording requires transfer of all of the content information. The third way is to construct a kiosk. The kiosk, in an embodiment, has its own engine and functions as a server with an engine.","Unlock Function","CKDRM unlock  is another function shown in Table 3. In one embodiment, the unlock content  function applies only to locked content. An application that can connect to a clearinghouse is required for the unlock transaction. When a user operating a media, such as a disk, satisfies predetermined transaction requirements, a secure method changes the state of the content on a media from locked to unlock.","According to an embodiment, locked content can be unlocked by authorized transactions. The authorized transactions include those transactions following rules selected by a content provider. For example, a content provider may control whether content can be played and the number of copies that may be made by TPDRMs.","Content that is pre-recorded in a locked state can be unlocked. In one embodiment, in the locked state the set of keys on the media are not sufficient to render the content. The unlock method delivers the complement of the keys. In another embodiment, the unlock method delivers data that matches the keys on the media to prove the authenticity of the clearing house. This data may also be referred to as key complements.",{"@attributes":{"id":"p-0242","num":"0241"},"figref":"FIG. 12","b":["1210","1220","1220","1230"]},"File System Functions","A default function of CKDRM is governed by the file system  of Table 3, above. The file system allows access at the file level. The file system API does not participate in rules governance or the encryption methods used by the CKDRM.","The file system functions include a file read . More particularly, only data in the file storage area may be read by any device via the file system. In one embodiment, an engine interface and the file system are open architectures, with a file system API that is open without requiring an authenticated host. According to an embodiment, the file read  may be used by any host, such as a player, to access data without establishing an authenticated connection and without using cryptographic methods that may be in an engine.","Write function  identifies a file system write function, whereby a device writes data into the file storage area through the file system API. Like the file system read function , the write function  is optionally part of an open architecture such that an engine interface and the file system are open and the file system API is open, obviating the need for an authenticated host. The file write function  may be used by any host to store data without establishing an authenticated connection and without using an engine's cryptographic methods.","Methods Performed by the Engine","The functions of the CKDRM described above gives an overview of the CKDRM and functions. An engine performs these functions in conjunction with other parts of the SEC system as described above with reference to . An engine, as referred to herein, is a component that provides read and write access to digital media. The engine may reside in a host or be coupled to a host and performs the functions using commands that one of skill in the art will appreciate are exemplary in nature and can be defined according to system and design requirements. Additional functions between components and applications in a host application are within the scope of the present invention. The term host application may refer to the device to which the engine is directly attached, an application on a connected device such as a PC, or a server implementing the CKDRM clearinghouse.","Each of the methods of a protocol includes either or both CKDRM and file system commands. The methods described below are available to any certified entity as limited by the entity's certificate. Devices embedding an engine are required to expose the file system and CKDRM APIs through data I\/O interfaces implemented by the device. In one embodiment, exposing the file system and CKDRM APIs allows a device embedding an engine to act as a surrogate for another entity.","Communication with an engine, according to an embodiment, requires a secure session. The authentication procedure described above results in a new secure session and a secure session key.  illustrates an exemplary embodiment for obtaining a secure session via an authentication procedure. Block  provides that the secure session key is transferred under asymmetric cryptography. In this embodiment, the session key is a symmetric key, thereby allowing for fast encryption and decryption of data. Block  asks whether a host change occurred or if media was ejected from a device. When block  is true, the secure session is ended in block . If false, the secure session continues in block . Thus, a secure session is unique to a particular host, engine and media combination.","Once a secure session is established, the engine is able to perform functions. The engine firmware provides functionality to the CKDRM and TPDRM methods, including lock\/unlock, CKDRM play, CKDRM copy permissions, and CKDRM copy permissions. For CKDRM and TPDRM copy permissions, the engine allows one of copy freely, counted first generation copies and unlimited first generation copies.","A secure session enables an engine to enter the CKDRM domain, including performing the CKDRM and TPDRM functions. The CKDRM functions performed by an engine follow protocols. Each protocol from the perspective of an engine is explained in further detail below.","CKDRM Copy",{"@attributes":{"id":"p-0254","num":"0253"},"figref":["FIG. 14","FIG. 14"],"b":["1410","1420","1420","1420","1440","1430","1450","1450","1420"]},"According to one embodiment of the copy protocol, a secure session is established between, for example, two engines, a source engine  and destination engine . In an embodiment, source engine  runs a secure API and is exposed only to hosts with CKDRM Copy permissions. The destination engine  includes an open API. Thus, the method is exposed to all hosts. Each engine has a host. A single device may be the host for both the source and destination engines, or each engine may have a different host. In the latter case, the two hosts must communicate according to a host protocol.","The CKDRM Copy protocol uses commands that one of skill in the art appreciates are exemplary in nature, but are provided for purposes of explanation. The protocol uses the CKDRM commands CKCMD_AUTHENTICATE and CKCMD_GET_CKDRM_COPY.","The command CKCMD_AUTHENTICATE provides that the destination engine  authenticates itself to source engine  to establish the trust that source engine must have in the destination engine to allow CKDRM methods to be used. The source host sends the destination engine's CKDRM certificate in the command packet. The source engine responds with the session key for the secure session.","In response to the command CKCMD_GET_CKDRM_COPY a key box is requested for a specified file and destination. The source engine  returns the key box  and a revocation list for the file and the destination.","CKDRM Record","Another method performed by an engine is the CKDRM record, which provides a method of bringing content into the CKDRM domain. The method assumes that a source is governed content that is outside the CKDRM domain. The destination is the CKDRM domain. The resulting copy is governed content.","The CKDRM Record method begins with establishing a secure session between an engine and a host. Thus, the method is a secure API that is exposed only to hosts with CKDRM record permissions. The commands CKCMD_AUTHENTICATE, CKCMD_GET_CERTIFICATE, CKCMD_CREATE_FILE and CKCMD_RECORD_APPEND are included in the record protocol. More particularly, CKCMD_AUTHENTICATE provides that the host supplying the content authenticates itself to an engine to establish the trust that the engine must have in the host to allow CKDRM methods to be used. Accordingly, the host sends its CKDRM certificate in a command packet, and the engine responds with the session key for the secure session.","The command CKCMD_GET_CERTIFICATE directs the host supplying the content to authenticate the engine to establish the trust that the host must have in the engine to allow content to be sent. The engine sends its CKDRM certificate in the data transfer.","The command CKCMD_CREATE_FILE creates a new CKDRM file. More particularly, the host specifies the record session key for transferring content and the content is transferred with CKCMD_RECORD APPEND commands from the host to the engine.","The command packet sent by the host includes basic DFS elements including the location in the directory structure and the file name, which may be explicitly specified in the command packet. The command packet further explicitly specifies CKDRM rules and a revocation list. In one embodiment, the balance of the command packet includes other objects in a file that may be set to defaults and may be modified using DFS commands. In one embodiment, the received content is appended to the end of the file.","From the viewpoint of a host, the record scenario is described with reference to . In block , a host application determines the file to import into CKDRM and its directory path. In block , the host determines the attributes of the file to be created including its directory path, file name, attributes, MIME type, CKDRM permissions, revocation list, allowed CKDRM copies and allowed DRM copies. In block , the host determines the DFS handle of the destination directory.","In block , the host issues the command CKCMD_AUTHENTICATE to initiate a secure session between the host and the engine. Certificate is set to the host's CKDRM certificate. In block , the engine returns the secure session key in ESessionKey. In block , the host issues CKCMD_GET_CERTIFICATE to authenticate the engine. Certificate is set to the engine's CKDRM certificate. In block , the host verifies the engine and extracts its public key. In block , the host creates the destination file using CKCMD_CREATE_FILE.","The created destination file, in one embodiment, includes data that controls the use of the file. For example, the data optionally includes information such as: the handle of the destination directory; the length of the revocation list; the encoded CKDRM permissions and attributes; the allowed CKDRM copies; the allowed DRM copies; the encrypted secure session key; and the value which is the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. Additional data includes the encrypted record session key selected by the host; the message authentication code calculated by the host for the revocation list data; the message authentication code calculated by the host for the command packet; the name of the file encoded as a DFSNAME data type; and the revocation data associated with the file.","In block , the host issues a DFSCMD_GETHANDLE command to retrieve the handle for the newly created file. In bock , the host sets the attributes and MIME type to the correct state. In block , the host writes the content to the file using one or more CKCMD_RECORD_APPEND commands. The CKCMD_RECORD_APPEND command includes the following fields: RecordOptions, which may have RECORD_FOREVER asserted; RecordFile, which is the DFS handle of the file to which to write and the Handle field returned by the engine for the preceding CKCMD_CREATE_FILE command; ByteCount, which is the number of bytes in the file, and if RECORD_FOREVER is asserted in Record options then ByteCount may be any value; EsessionKey, which is the encrypted secure session key, and same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE; and ErecordKey, which is the encrypted record session key selected by the host, and the ERecordKey value sent by the host in the CKCMD_CREATE FILE command.","In block  the host sends the entire file in the data transfer. In one embodiment, if more than one CKCMD_RECORD_APPEND command is used then ERecordKey must always be the same and the data must always be the content encrypted with the single record session key represented by the single ERecordKey value. In another embodiment, the ErecordKey may change for each CKCMD_RECORD_APPEND command.","CKDRM Play","CKDRM Play is a method of playing content governed by CKDRM. As shown in , a source is governed content that is within the CKDRM domain. According to the method, the source file must be unlocked and have CKDRM play permissions. The destination is a host acting in the role of a Player.","According to the protocol shown in , the CKDRM play protocol first establishes a secure session between an engine and a host. According to an exemplary embodiment, the CKDRM Play method is a secure API and is exposed only to hosts with CKDRM Play permissions. The CKDRM Play protocol uses the commands CKCMD_AUTHENTICATE, CKCMD_GET_CKDRM_PLAY_KEY and CKCMD_PLAY.","The method begins in block  with the command CKCMD_AUTHENTICATE which directs the host Player to authenticate itself to the engine to establish the trust that the engine must have in the destination to allow CKDRM methods to be used. In block , the host sends its CKDRM certificate in the command packet. The engine responds in block  with the session key for the secure session.","Next, in block , the command CKCMD_GET_CKDRM_PLAY_KEY directs that the CKDRM Play permissions be checked. In block , the play session is established and the play session key is returned for a specified file. In block , the command CKCMD_PLAY directs the engine to return the content from the specified file.",{"@attributes":{"id":"p-0275","num":"0274"},"figref":"FIG. 17","b":["1710","1720","1720","1740"]},"In block  the host issues a CKCMD_GET_CKDRM_PLAY_KEY command to establish a play session and get the play session key for the file. The ESessionKey is the encrypted secure session key, and holds the same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. In block , the engine returns the play session key in EplayKey. In block , the host issues one or more CKCMD_PLAY commands to retrieve the contents. In response, the engine returns the contents in block .","In one embodiment of the invention, the CKCMD_Play command provides that the contents are retrieved and does not stop retrieving due to unrecoverable errors. More specifically, in one embodiment, a field PlayOptions is set with PLAY_STREAMING asserted, which provides for streamed play and no stopping on a play error. Additionally, with the command PLAY_TO_EOF asserted, the content is played to the end of file, ignoring the ByteCount field.","The CKDRM for the play commands works with the DFS API. For example, the command PlayFile is a DFS command that is set to specify the DFS handle of the file to play. As in other methods performed by the CKDRM the Play function ESessionKey is the encrypted secure session key, and the same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. Other useful data fields include ByteOffset, which is set to zero to start the play at the start of the file; and ByteCount, which may be set to the number of bytes the host wishes to receive.","CKDRM Unlock","Another method performed by the CKDRM is illustrated in . CKDRM Unlock is a method of changing the state of a CKDRM file from locked to unlocked. The target is governed content that is within the CKDRM domain. Upon successful completion of this method, the target file will be unlocked. The permissions and metadata are otherwise unchanged.",{"@attributes":{"id":"p-0281","num":"0280"},"figref":"FIG. 18"},"After the host determines the files to unlock in block , the host, in block  gets the handles for the locked files in the form of a list. In one embodiment, the list is obtained by traversing the directory structure and noting all of the files whose attributes indicate that the file is locked. In another embodiment, the associations format also specifies the locked content and some information about offer packages.","In block , the host application issues the CKCMD_AUTHENTICATE command to authenticate itself to the engine and initiate a secure session. Certificate is set to a clearinghouse server's CKDRM certificate. In block , the engine returns the secure session key in field ESessionKey.","In block , the host issues the command CKCMD_GET_CERTIFICATE to authenticate the engine. Certificate is set to the engine's CKDRM certificate. In block  the host verifies the engine and extracts its public key. Next, in block , the command CKCMD_UNLOCK_FILES directs that the host specify the files to unlock. The number of files to unlock is specified in a FileCount field in the data transfer. The DFS handles of the files to unlock are specified in the Handle field of the FileSet array of the data transfer. In block  the engine modifies the Lock attribute of the files specified by field FileSet.","Other data useful to the unlock method includes the following fields: FileCount, which is set to the number of files to unlock; EunlockKey, which is the encrypted unlock key for the encryption and decryption of key complements; EmediaId, which is the encrypted media identifier and the public media identifier of the destination media; FileSet, which is set to the list of identifiers of the files to unlock, including the DFS handle of the file in each entry; and the EKeyComplement field, which is the encrypted key complement, where the key complement comes from the appropriate database. The unlock key is used to encrypt the key complement values. Additionally, the field DataMac is set to the hash of FileSet field of the data packet.","Finally, in block , the host application checks whether the transaction was successful by getting the state of the files that were to be unlocked.","TPDRM Copy is a method of sending governed content out of the CKDRM domain. The source is governed content that is within the CKDRM domain. The source file must be unlocked and have TPDRM copy permissions. The TPDRM copy permissions, according to an embodiment, include either a non-zero TPDRM Copy Count value, a TPDRM Copy Freely state, or an Unlimited First Generation TPDRM Copy state. The destination is the domain of a TPDRM. The resulting copy is governed content governed by the destination TPDRM. In an exemplary embodiment, the source file's remaining TPDRM Copy Count is decremented during the CKCMD_GET_DRM_COPY command, if necessary.",{"@attributes":{"id":"p-0288","num":"0287"},"figref":"FIG. 19"},"In block , the command CKCMD_AUTHENTICATE directs the TPDRM to authenticate itself to the engine to establish the trust that the engine must have in the TPDRM to allow CKDRM methods to be used. In block , the host sends the TPDRM's CKDRM certificate in the command packet. In block , the engine responds with the session key for the secure session.","In block , the command CKCMD_GET_METADATA directs that the TPDRM retrieve secure metadata associated with the file to be played. In block , the engine returns a key for decrypting the metadata. The engine also returns, in block , the encrypted metadata.","In block , the command CKCMD_GET_DRM_COPY directs that the engine checks TPDRM Copy permissions, establish the play session and return the play session key and revocation list for a specified file. In block , the command TPDRM Copy Count directs that the value for the file be decremented, if necessary. In block , the command CKCMD_PLAY directs that the engine return the content from the specified file.",{"@attributes":{"id":"p-0292","num":"0291"},"figref":"FIG. 20","b":["2010","2020","2030"]},"In block , the host issues a CKCMD_GET_METADATA command to retrieve the TPDRM's secure metadata associated with the file. The field AssociatedFile is set to the DFS handle of the associated file, the file to copy. ESessionKey is the encrypted secure session key, and has the same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. In block , the engine returns Metadata, i.e., the metadata associated with the file specified by AssociatedFile and with the TPDRM specified by the certificate received in the CKCMD_AUTHENTICATE command.","In an exemplary embodiment, the TPDRM enforces TPDRM governance rules, including the rules specified by its metadata, and determines whether there currently are copy permissions for the TPDRM for the file. In an embodiment of the method, the TPDRM must not copy the content if there are no copy permissions.","In block , the host issues a CKCMD_GET_DRM_COPY command to establish the play session and get the play session key for the file. The field SourceFile is the DFS handle of the file to be copied. In block , the engine returns the play session key in EPlayKey, and the revocation list in RevocationList. In block , according to one embodiment, the host issues one or more CKCMD_PLAY commands to retrieve the contents. The fields of the play commands include: PlayOptions, which is set with PLAY_STREAMING deasserted (play normal; stop on play error) and PLAY_TO_EOF asserted (play to the end of the file; ignore the ByteCount field); PlayFile, which is set to specify the desired file, which may be the DFS handle of the file to copy; ByteOffset, which is set to zero to start the play (copy) at the start of the file; ByteCount, which may be set to any value; and EsessionKey, which is the encrypted secure session key, and the same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. In block , the engine returns the content.","Read Secure Metadata","Read Secure Metadata is a method of accessing content that is in the CKDRM domain and owned by a third party. In one embodiment, the associated file must be unlocked. The metadata is associated with the file and with the host identified for the secure session.","As with other methods, the protocol first establishes a secure session between an engine and a host. Thus, the Read Secure Metadata method is a secure API and is exposed only to hosts with Read Secure Metadata permissions.",{"@attributes":{"id":"p-0299","num":"0298"},"figref":"FIG. 21"},"The command CKCMD_GET_METADATA directs the host to read its secure metadata associated with the file. In response, the engine returns a key for decrypting the metadata and also returns the encrypted metadata.","Referring to , in block , the host first determines the file associated with the metadata to be read. Accordingly, the exchange includes, in block , a user inserting the source media in the engine. In block , the host issues a CKCMD_AUTHENTICATE command to initiate a secure session between the engine and the host. The certificate is set to the host's CKDRM certificate. In block , the engine returns the secure session key in ESessionKey. In block , the host issues a CKCMD_GET_METADATA command to retrieve the host's secure metadata associated with the file. The field AssociatedFile is set to the DFS handle of the file with which the metadata is associated. The field ESessionKey is the encrypted secure session key, and holds the same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. In block , the engine returns Metadata, the metadata associated with the file specified by AssociatedFile and with the host specified by the certificate received in the CKCMD_AUTHENTICATE command.","Write Secure Metadata","The Write Secure Metadata provides a method asserting content that is in the CKDRM domain and owned by a third-party. In one embodiment, the associated source file must be unlocked, however, the status of the associated source file may be altered according to design requirements. The metadata is associated with the file and with the host identified for the secure session.","The protocol establishes a secure session between an engine and a host. Thus, the Write Secure Metadata method is a secure API and is exposed only to hosts with Write Secure Metadata permissions. The Write Secure Metadata protocol uses the commands CKCMD_AUTHENTICATE, CKCMD_GET_CERTIFICATE and CKCMD_SET_METADATA.","As discussed above, the command CKCMD_AUTHENTICATE directs a host to authenticate itself to an engine to establish the trust that the engine must have in the destination to allow CKDRM methods to be used. In response, the host sends its CKDRM certificate in the command packet. The engine responds with the session key for the secure session.","The command CKCMD_GET_CERTIFICATE directs the host supplying the content to authenticate the engine to establish the trust that the host must have in the engine to allow content to be sent. The engine sends its CKDRM certificate in the data transfer.","The command CKCMD_SET_METADATA directs the host to write its secure metadata associated with the file. In response, the host sends a key for decrypting the metadata and the encrypted metadata.",{"@attributes":{"id":"p-0308","num":"0307"},"figref":"FIG. 22A","b":["2210","2220","2230","2240","2250","2260"]},"In block , the host issues a CKCMD_SET_METADATA command to send the host's secure metadata associated with the file. The field AssociatedFile is set to the DFS handle of the file with which the metadata is associated. The field ESessionKey is the encrypted secure session key, and same value as the ESessionKey value returned by the engine for CKCMD_AUTHENTICATE. The field Metadata is the metadata associated with the file specified by AssociatedFile and with the host specified by the certificate received in the CKCMD_AUTHENTICATE command.","Referring to Table 4A, below, the permissions are given for the commands provided above.","Permissions for Commands:",{"@attributes":{"id":"p-0311","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4A"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},"Current",{},{},{},{}]},{"entry":[{},"Secure","Locked","Host","Objects"]},{"entry":["Command","Session","Object","Permissions","Permissions","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CKCMD","Current","Not","Valid","Not","The signatures in the"]},{"entry":["AUTHENTI-","session","applicable","CKDRM","applicable","CKDRM Certificate"]},{"entry":["CATE","broken, new",{},"Certificate",{},"must verify with the"]},{"entry":[{},"session",{},{},{},"public keys, including"]},{"entry":[{},"initiated",{},{},{},"the CA public key"]},{"entry":[{},{},{},{},{},"from the Valid"]},{"entry":[{},{},{},{},{},"Signature Key List."]},{"entry":["CKCMD","Required","Not","CKDRM","Parent","The directory in which"]},{"entry":["CREATE",{},"applicable","Record","directory: DFS","the new file is to be"]},{"entry":["FILE",{},{},{},"Write","created must have"]},{"entry":[{},{},{},{},{},"DFS Write"]},{"entry":[{},{},{},{},{},"permissions."]},{"entry":["CKCMD GET","Not required","Not",{},"Not applicable","This is a non-secure"]},{"entry":["CERTIFICATE",{},"applicable",{},{},"command in the"]},{"entry":[{},{},{},{},{},"CKDRM API."]},{"entry":["CKCMD GET","Required","Disallowed","CKDRM","Non-zero CK"]},{"entry":["CONTENT",{},{},"Copy","Copy Count,"]},{"entry":["KEY COPY",{},{},{},"CK Copy"]},{"entry":[{},{},{},{},"Freely or"]},{"entry":[{},{},{},{},"Unlimited First"]},{"entry":[{},{},{},{},"Generation CK"]},{"entry":[{},{},{},{},"Copies"]},{"entry":["CKCMD GET","Not required","Not",{},"Not applicable","This is an non-secure"]},{"entry":["CKDRM ID",{},"applicable",{},{},"command in the"]},{"entry":[{},{},{},{},{},"CKDRM API."]},{"entry":["CKCMD GET","Required","Disallowed","CKDRM","CKDRM Play,"]},{"entry":["CKDRM",{},{},"Play","DFS Read"]},{"entry":["PLAY KEY",{},{}]},{"entry":["CKCMD","Required","Disallowed","TPDRM","Non-zero"]},{"entry":["GET",{},{},"Copy","TPDRM Copy"]},{"entry":["TPDRM",{},{},{},"Count, TPDRM"]},{"entry":["COPY",{},{},{},"Copy Freely or"]},{"entry":[{},{},{},{},"Unlimited First"]},{"entry":[{},{},{},{},"Generation"]},{"entry":[{},{},{},{},"TPDRM Copies"]},{"entry":["CKCMD GET","Required","Disallowed","Read Secure",{},"The file must have"]},{"entry":["METADATA",{},{},"Metadata",{},"metadata for the host."]},{"entry":["CKCMD","Required","Disallowed","CKDRM","CKDRM Play"]},{"entry":["PLAY",{},{},"Play","or TPDRM"]},{"entry":[{},{},{},{},"Copy,"]},{"entry":[{},{},{},{},"DFS Read"]},{"entry":["CKCMD","Required","Allowed","CKDRM","CKDRM","Turn off DFS Write"]},{"entry":["RECORD",{},{},"Record","Record,","and DFS Write"]},{"entry":["APPEND",{},{},{},"DFS Write","Modification to"]},{"entry":[{},{},{},{},{},"disallow further"]},{"entry":[{},{},{},{},{},"recording."]},{"entry":["CKCMD SET","Not required","Disallowed",{},{},"The file must not have"]},{"entry":["KEYBOX",{},{},{},{},"CKDRM metadata."]},{"entry":[{},{},{},{},{},"This is an non-secure"]},{"entry":[{},{},{},{},{},"command in the"]},{"entry":[{},{},{},{},{},"CKDRM API."]},{"entry":["CKCMD SET","Required","Disallowed","Write"]},{"entry":["METADATA",{},{},"Secure"]},{"entry":[{},{},{},"Metadata"]},{"entry":["CKCMD","Required","Allowed","CKDRM",{},"The file must have"]},{"entry":["UNLOCK",{},{},"Unlock",{},"CKDRM metadata."]},{"entry":"FILES"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}},"Referring to Table 4A, the following commands, RECORD_APPEND, PLAY, GET_DRM_PLAY_KEY, GET_DRM_COPY, GET_CKDRM_PLAY_KEY, GET_CKDRM_COPY and CREATE_FILE each include as part of their protocol a consideration of a media identifier. One media identifier is a unique identifier that is created during the mastering or pre-mastering process of a media. It may be unique for a master or for each media, depending on design requirements. Another media identifier is a unique identifier that is created during field use of the media. It is unique for each media, e.g., media disk. In each case, however, the media identifier may be pre-recorded on a disk for content that was mastered or pre-mastered, or the like. Further, in each case, the media identifier may be written on media, such as a disk, for content that was written. The pre-recorded media identifier may, therefore, exist only in that portion of media dedicated to mastered\/pre-mastered content, and the written media identifier will exist only in that portion of a media dedicated to written information. Referring to Table 4B, below, the types of identifiers that are possible in the SEC system are provided. As shown, there are four types of identifiers including pre-recorded identifiers for pre-recorded content, pre-recorded identifiers for written content, written identifiers for pre-recorded content and written identifiers for written content. Pre-recorded locked content and pre-recorded locked content that was later unlocked uses only the media identifier that was pre-recorded. The SEC system, in one embodiment, uses two of the four types of identifiers, so the existence of the other two types indicates a counterfeit disk.",{"@attributes":{"id":"p-0313","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Pre-Recorded Content","Written Content"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Pre-Recorded Media Identifier","Used by the SEC","Counterfeit"]},{"entry":[{},"system"]},{"entry":["Written Media Identifer","Counterfeit","Used by the"]},{"entry":[{},{},"SEC system"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Referring to Table 4A, the following commands, RECORD-APPEND, PLAY, GET_DRM_PLAY_KEY, GET_DRM_COPY, GET_CKDRM_PLAY_KEY, GET_CONTENT_KEY_COPY and CREATE_FILE each include as part of their protocol a consideration of a media identifier. The media identifier is unique identifier that is created during the mastering or pre-mastering process for media. It may be unique for a master or for each disk, depending on design requirements. In each case, however, the media identifier will be pre-recorded on a disk if the content was mastered or pre-mastered, or the like. The media identifier, will, therefore, exist only in that portion of a disk dedicated to mastered\/pre-mastered content. Referring to Table 4B, below, the types of identifiers that are possible in the SEC system are provided. As shown, there are four types of identifiers, including pre-recorded, hybrid with both pre-recorded and written components to the identifiers, written-only identifiers, and counterfeit. The media types for the four types of identifiers include media holding pre-recorded locked content that was later unlocked, media holding only unlocked content, and those holding a mixture of both types. According to an unlock protocol, when content is unlocked, the identifier for the content has a portion of the identifier that is pre-recorded and a portion of the identifier that is written. Thus, for media holding pre-recorded content later unlocked, the identifier will always have a pre-recorded identifier associated with it.",{"@attributes":{"id":"p-0315","num":"0314"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Pre-Recorded","Hybrid","Written","Counterfeit"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Media holds pre-","YES","YES","YES","NO"]},{"entry":"recorded locked"},{"entry":"content that was"},{"entry":"later unlocked"},{"entry":["Media holds Pre-","YES","NO","N\/A","NO"]},{"entry":"Recorded unlocked"},{"entry":"at purchase"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Referring to Table 4B in combination with , a method for determining whether content is counterfeit is provided. The method may operate during the commands RECORD-APPEND, PLAY, GET_DRM_PLAY_KEY, GET_DRM_COPY, GET_CKDRM_PLAY_KEY, GET_CONTENT_KEY_COPY and CREATE_FILE, or any other commands according to design requirements. Block  provides for performing a key box lookup. Block  provides for retrieving the key box for a file. In an embodiment, the key box is encrypted and bound to a location. In block , an engine determines whether the media identifier should be written or pre-recorded according to the action desired by the command. In block  the key box binding identifier flag is compared with a key box read method, however, the implementation depends on the command chosen. Further, in block , the method according to the command chosen is compared against the associated media identifier for the command and\/or an identifier flag associated with the media identifier. If the identifier or identifier flag is not pre-recorded for those identifiers that require a pre-recorded identifier or flag, block  provides for a revocation of some or all of the functionality of the command. In one embodiment, an identifier that is a counterfeit will identify itself to an engine as a pre-recorded identifier, when, in fact, the identifier is located in a portion of a disk for written content. The determination by the engine of whether the identifier is pre-recorded or written will depend on how the identifier identifies itself as well as the location of the identifier on the media. Thus, counterfeit media disks will be prevented from full functionality.","Table 5, below provides DFS command permissions, including the suggested state for pre-recorded and CKDRM files:",{"@attributes":{"id":"p-0318","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":[{},"Read\/","Write\/","Move\/","Rename\/","Delete\/",{}]},{"entry":["File type","Modify","Modify","Modify","Modify","Modify","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["After file creation but","On\/","On\/","Off\/","Off\/","Off\/","Leave write permissions on"]},{"entry":["before recording is","Off","On","On","On","Off","while recording."]},{"entry":"complete"},{"entry":["After recording is","On\/","Off\/","Off\/","Off\/","Off\/","Turn off DFS Write and DFS"]},{"entry":["complete","Off","Off","On","On","Off","Write Modification. Disallow"]},{"entry":[{},{},{},{},{},{},"move, rename and delete, but"]},{"entry":[{},{},{},{},{},{},"allow these permissions to be"]},{"entry":[{},{},{},{},{},{},"modified."]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}}},"The first part of each entry is the state of the DFS permission attribute, and the second part is the state of the field in the DFS Attribute Modification Mask. When the Attribute Modification Mask is off further changes to the permission attribute are disallowed.","CKDRM Commands discussed above are part of the CKDRM and function according to the tables provided below:","CKCMD_AUTHENTICATE: Verifies and validates host authenticity and establishes a secure session.",{"@attributes":{"id":"p-0322","num":"0321"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control Reg","FUNCTION CODE = 011","Reset byte count"]},{"entry":[{},{},"pointer to low byte."]},{"entry":["Byte Count","CKCMD_AUTHENTICATE_SIZE","Command packet"]},{"entry":["Reg",{},"size."]},{"entry":["Control Reg","FUNCTION CODE = 001","Start command."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0323","num":"0322"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003","HostCmd","U8","Command code."]},{"entry":["1\u2003","CkSubCmd","U8","Sub-command code."]},{"entry":["2:241","Certificate","CKDRM_CERTIFICATE","The host's CKDRM"]},{"entry":[{},{},{},"certificate."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0324","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:37","ESessionKey","WRAPPED_KEY","The session key for the new"]},{"entry":[{},{},{},"secure session."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"According to an embodiment, any host is allowed access to CKCMD_AUTHENTICATE. The host must deliver a valid CKDRM Certificate for the command to be successful. Any current secure session is broken. A successful execution results in a new current secure session. The parameters for the command and the settings include: HostCmd set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_AUTHENTICATE; Certificate is set to the host's CKDRM certificate; and ESessionKey is the secure session key encrypted using Protocol Public Key from the host's CKDRM Certificate. An implicit authentication occurs if the host can correctly decrypt ESessionKey.","As discussed above with reference to the methods performed by the engine, the authenticate command causes a host to deliver its CKDRM certificate to the engine. The engine verifies and validates the certificate. The engine also extracts the method permissions. The engine creates a secure session key and saves the key and the host certificate. The host becomes the current host for the secure session and subsequent CKDRM commands. In an exemplary embodiment, initiating the authenticate command terminates any existing secure session. A successful command initiates a new secure session. The ESessionKey value also serves as the secure session identifier.","CKCMD_GET_CERTIFICATE: Transfers the engine's CKDRM certificate to the host.",{"@attributes":{"id":"p-0328","num":"0327"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control Reg","FUNCTION CODE = 011","Reset byte"]},{"entry":[{},{},"count pointer"]},{"entry":[{},{},"low byte."]},{"entry":["Byte Count","CKCMD_GET_CERTIFICATE_SIZE","Command"]},{"entry":["Reg",{},"packet size."]},{"entry":["Control Reg","FUNCTION CODE = 001","Start command."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0329","num":"0328"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0","HostCmd","U8","Command code."]},{"entry":["1","DfsSubCmd","U8","Sub-command code."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0330","num":"0329"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:239","Certificate","CKDRM_CERTIFICATE","The engine's CKDRM"]},{"entry":[{},{},{},"Certificate."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Any host is allowed access to CKCMD_AUTHENTICATE.","The parameters used by the command include: HostCmd set to DPICMD_CK_COMMAND; CkSubCmd set to CKCMD_GET_CERTIFICATE; Certificate, i.e., the engine's CKDRM certificate. The CKCMD_GET_CERTIFICATE command transfers the engine's CKDRM certificate to the host so that the engine's certificate may be sent to another engine (through CKCMD_AUTHENTICATE) as part of the CKDRM Copy method, Record method, Write Metadata method and Unlock method, as required.","CKCMD_CREATE_FILE: Checks CKDRM Record permissions, creates a new CKDRM file object within the given directory and establishes a write\/record session.",{"@attributes":{"id":"p-0334","num":"0333"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte"]},{"entry":["Reg",{},"count pointer to"]},{"entry":[{},{},"low byte."]},{"entry":["Byte","CKCMD_CREATE_FILE_SIZE_NO","Command"]},{"entry":["Count Reg","NAME + n","packet size."]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0335","num":"0334"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2003\u2009","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3\u2003\u2002","RevocationByteCount","U16","The number of bytes"]},{"entry":[{},{},{},"to expect in the"]},{"entry":[{},{},{},"revocation list."]},{"entry":["4:7\u2003\u2002","Parent","DFSHANDLE","The directory in"]},{"entry":[{},{},{},"which to create the"]},{"entry":[{},{},{},"file."]},{"entry":["8:9\u2003\u2002","CKDRMState","CKDRM","Encoded CKDRM"]},{"entry":[{},{},"STATE","attributes and"]},{"entry":[{},{},{},"permissions for this"]},{"entry":[{},{},{},"file. Refer to the"]},{"entry":[{},{},{},"encoding."]},{"entry":["10\u2003\u2003","CKDRMCopies","U8","The number of"]},{"entry":[{},{},{},"CKDRM copies"]},{"entry":[{},{},{},"allowed."]},{"entry":["11\u2003\u2003","DrmCopies","U8","The number of"]},{"entry":[{},{},{},"DRM copies"]},{"entry":[{},{},{},"allowed."]},{"entry":["12:15\u2003\u2002","Reserved","U16[2]","Reserved."]},{"entry":["16:31\u2003\u2002","ESessionKey","WRAPPED","The current secure"]},{"entry":[{},{},"KEY","session key."]},{"entry":["32:47\u2003\u2002","ERecordKey","WRAPPED","The record session"]},{"entry":[{},{},"KEY","key."]},{"entry":["48:67\u2003\u2002","RevocationMac","MAC","The MAC for the"]},{"entry":[{},{},{},"attached revocation"]},{"entry":[{},{},{},"list."]},{"entry":["68:87\u2003\u2002","CommandMac","MAC","The message"]},{"entry":[{},{},{},"authentication code."]},{"entry":["88:n + 87","Name","DFSNAME","File name of n"]},{"entry":[{},{},{},"bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0336","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CKDRMState fields (CKDRM_STATE type)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bit Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FILE_CKDRM_COPY_FREELY","Indicates whether the"]},{"entry":[{},"CKDRM copies may"]},{"entry":[{},"be made without"]},{"entry":[{},"restriction."]},{"entry":["FILE_CKDRM_LOCKED","0 = create an unlocked"]},{"entry":[{},"file 1 = create a locked"]},{"entry":[{},"file"]},{"entry":["FILE_CKDRM_PLAY","Indicates whether the"]},{"entry":[{},"CKDRM Play method"]},{"entry":[{},"is allowed."]},{"entry":["FILE_DRM_COPY_FREELY","Indicates whether the"]},{"entry":[{},"DRM copies may be"]},{"entry":[{},"made without"]},{"entry":[{},"restriction."]},{"entry":["FILE_UNLIMITED_FIRST_GENERATION","Indicates whether first"]},{"entry":["CK_COPIES","generation CKDRM"]},{"entry":[{},"copies may be made"]},{"entry":[{},"without limit."]},{"entry":["FILE_UNLIMITED_FIRST_GENERATION","Indicates whether first"]},{"entry":["DRM_COPIES","generation DRM"]},{"entry":[{},"copies may be made"]},{"entry":[{},"without limit."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0337","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from host to engine)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:RevocationByte","Revocation",{},"The revocation list for the"]},{"entry":["Count-1","List",{},"file."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The command CKCMD_CREATE_FILE requires a current secure session. Only hosts with CKDRM Record method permissions are allowed access to CKCMD_CREATE_FILE. Parent must specify a directory with write permissions. The parameters of the command with settings includes: HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_CREATE_FILE; RevocationByteCount is the number of bytes to expect in the data phase of the command; Parent is the handle of the directory in which to create the file.","CKDRMState are the CKDRM attributes and permissions of the file. The member fields of the CKDRMState field is specified by the CKDRMState Fields table. CKDRMCopies specifies the number of CKDRM copies that are allowed for the file. This is the initial value of the CKDRM Copy Count value. The CKDRM Copy method must be allowed to make use of a non-zero value.","DrmCopies specifies the number of DRM copies that are allowed for the file. This is the initial value of the DRM Copy Count value. The DRM Copy method must be allowed to make use of a non-zero value.","ESessionKey is the current secure session key and is related to the CKDRM method CKCMD_AUTHENTICATE.","ERecordKey is the record session key for this file and is encrypted with the engine's public key. This is the ERecordKey value that must be used for all CKCMD_RECORD_APPEND commands for this file. This implies that the data for the CKCMD_RECORD_APPEND commands for this file are encrypted with this record session key. RevocationMac is the message authentication code of the data phase. CommandMac is the message authentication code for the command packet. It is calculated over the preceding fields of the command packet, bytes  through , inclusive. Name is the DFS name of the file. RevocationList is the revocation list for the file.","The command CKCMD_CREATE_FILE creates a CKDRM file object in the specified directory. The file initially has a file length of zero. The handle for the created file may be obtained using the DFSCMD_GETHANDLE command. The handle is used in subsequent CKCMD_RECORD_APPEND commands. The file attributes, and MIME type are set to default values. The CKDRM metadata is set as specified by the CKDRMState, CKDRMCopies, DrmCopies and RevocationList fields.","CKCMD_GET_CKDRM_COPY: Checks CKDRM Copy permissions and transfers the key box for a particular file and destination identifier. Decrements the CKDRM Copy Count for the file, if necessary. The transfer is from the engine to the host.",{"@attributes":{"id":"p-0345","num":"0344"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 19"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer to"]},{"entry":["Reg",{},"low byte."]},{"entry":["Byte","CKCMD_GET_CKDRM","Command packet size."]},{"entry":["Count Reg","COPY_SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0346","num":"0345"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 20"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0","HostCmd","U8","Command code."]},{"entry":["1","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3","Reserved","U16","Reserved."]},{"entry":["4:7","SourceFile","DFSHANDLE","The file for which to get the key"]},{"entry":[{},{},{},"box."]},{"entry":["\u20028:39","CKDRMId","U256","The identifier for the destination"]},{"entry":[{},{},{},"of the copy."]},{"entry":["40:55","ESessionKey","WRAPPED","The current secure session key."]},{"entry":[{},{},"KEY"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0347","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 21"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:n","KeyBox",{},"The key box for SourceFile and the"]},{"entry":[{},{},{},"destination."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"In an embodiment, the command CKCMD_GET_CKDRM_COPY functions only during a current secure session. Only hosts with CKDRM Copy method permissions are allowed access to CKCMD_GET_CKDRM_COPY. Sourcefile must have either a non-zero CKDRM Copy Count value, a CKDRM Copy Freely state or an Unlimited First Generation CKDRM Copies state. In one embodiment, CKCMD_GET_CKDRM_COPY is allowed for locked files or files with zero copy counts in cases in which the destination file is marked as locked.","The parameters of the fields provided in the tables include: HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_GET_CKDRM_COPY; SourceFile is the DFS handle for the file for which to get the key box; CKDRMId is the identifier the destination to which the delivered key box belongs. The identifier must be the delivered results of a CKCMD_GET_CKDRM_ID command to the destination engine. ESessionKey is the current secure session key. KeyBox is created by the engine. KeyBox is the keys and revocation list for the file specified by SourceFile and the destination specified by CKDRMId. The engine returns KeyBox to the host.","The command CKCMD_GET_CKDRM_COPY is used during the CKDRM Copy method to obtain a key box which may be delivered to a destination. This key box is associated with SourceFile. It provides the necessary information for accessing (playing) the content that is secured in the file in the copy that resides at the destination. If SourceFile has a CKDRM Copy Freely state then the resulting copy also has a CKDRM Copy Freely State. Otherwise, the resulting copy has no CKDRM copy permissions.","If SourceFile has an Unlimited First Generation CKDRM Copy state then the CKDRM Copy Count is unchanged. Otherwise, if the CKDRM Copy Count is not zero then the CKDRM Copy Count is decremented by the engine and stored back to the media prior to completion of the command. Delivery of KeyBox is associated with decrementing the Copy Count.","If SourceFile has a CKDRM Copy Freely state then the resulting copy also has a CKDRM Copy Freely State. Otherwise, the resulting copy has no DRM copy permissions. The field KeyBox must subsequently be delivered to the destination engine to complete the CKDRM Copy transaction as described by the CKDRM Copy Method section.","CKCMD_GET_CKDRM_ID: Returns information for the currently inserted media.",{"@attributes":{"id":"p-0354","num":"0353"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 22"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer"]},{"entry":["Reg",{},"to low byte."]},{"entry":["Byte","CKCMD_GET_CKDRM_ID","Command packet size."]},{"entry":["Count Reg","SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0355","num":"0354"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 23"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0","HostCmd","U8 (unsigned 8","Command code."]},{"entry":[{},{},"bit value)"]},{"entry":["1","CkSubCmd","U8","Sub-command code."]},{"entry":[{"sup":"\u2003"},"Reserved","U16","Reserved."]},{"entry":["\u20024:19","ESessionKey","WRAPPED","The current secure session key."]},{"entry":[{},{},"KEY"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0356","num":"0355"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 24"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:31","CKDRM","U256","The CKDRM identifier for the currently"]},{"entry":[{},"Id",{},"inserted media."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"According to an embodiment, the command CKCMD_GET_CKDRM_ID allows any host access to CKCMD_GET CKDRM ID. However, the engine must have media inserted.","The parameters shown in the tables above include: HostCmd, which may be set to DPICMD_CK_COMMAND. CkSubCmd, which may be set to CKCMD_GET_CKDRM_ID. ESessionKey is the current secure session key. CKDRMId represents the identifier for the currently inserted media and the current secure session. CKCMD_GET_CKDRM_ID returns information specific to the media and is used by various CKDRM methods to provide media-specific information. Other identifiers, such as a public media identifier are available through the DFS API.","CKCMD_GET_CKDRM_PLAY_KEY: Checks CKDRM Play permissions and establishes a play session.",{"@attributes":{"id":"p-0360","num":"0359"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 25"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count"]},{"entry":["Reg",{},"pointer to low byte."]},{"entry":["Byte","CKCMD_GET_CKDRM_PLAY","Command packet"]},{"entry":["Count Reg","KEY_SIZE","size."]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0361","num":"0360"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 26"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2009","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3\u2002","Reserved","U16","Reserved"]},{"entry":["4:7\u2002","PlayFile","DFSHANDLE","The file handle for which the"]},{"entry":[{},{},{},"key is needed."]},{"entry":["8:23","ESessionKey","WRAPPED","The current secure session key."]},{"entry":[{},{},"KEY"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0362","num":"0361"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 27"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:15","EPlayKey","AES","The play session key for the"]},{"entry":[{},{},"KEY","specified file."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The command, according to one embodiment, requires a current secure session. Further, only hosts with CKDRM Play method permissions are allowed access to CKCMD_GET_CKDRM_PLAY_KEY. PlayFile must specify a file that is unlocked and has CKDRM Play and DFS Read permissions.","The parameters used by the command include: HostCmd set to DPICMD_CK_COMMAND; CkSubCmd set to CKCMD_GET_CKDRM_PLAY_KEY; PlayFile is the DFS handle for the file for which the play session key is to be returned; ESessionKey is the current secure session key. EPlayKey is the play session key encrypted with the secure session key. The play session key is specific to the file specified by PlayFile. More particularly, the play session key is the key with which the file will be encrypted in the subsequent CKCMD_PLAY commands for PlayFile.","The command CKCMD_GET_CKDRM_PLAY_KEY transfers the decryption key for a particular file from the engine to the host. The command must be issued prior to every CKDRM play session. The key value selected is used for the duration of the play session. The host must not assume that the key will be the same for the file each time it is played off the media. The content of the file in the form that can be decrypted by the play session key may be obtained through the CKCMD_PLAY command.","CKCMD_GET_DRM_COPY: Checks TPDRM Copy permissions and establishes a play session. Decrements the TPDRM Copy Count value, if necessary.",{"@attributes":{"id":"p-0367","num":"0366"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 29"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer"]},{"entry":["Reg",{},"to low byte."]},{"entry":["Byte","CKCMD_GET_DRM_COPY_","Command packet size."]},{"entry":["Count Reg","SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0368","num":"0367"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 30"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2009","DfsSub","U8","Sub-command code."]},{"entry":[{},"Cmd"]},{"entry":["2:3\u2002","Reserved","U16","Reserved"]},{"entry":["4:7\u2002","SourceFile","DFSHANDLE","The file for which to get the"]},{"entry":[{},{},{},"key."]},{"entry":["8:23","Esession","WRAPPED","The current secure session"]},{"entry":[{},"Key","KEY","key."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0369","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 31"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:15","EPlayKey","AES","The play session key for the specified"]},{"entry":[{},{},"KEY","file."]},{"entry":["16:n\u2003","Revocation",{},"The CKDRM revocation list associated"]},{"entry":[{},"List",{},"with the file."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The command CKCMD_GET_DRM_COPY requires a current secure session. Only hosts with TPDRM Copy method permissions are allowed access to CKCMD_GET_DRM_COPY. SourceFile must specify a file that is unlocked. Source file must have either a non-zero TPDRM Copy Count value, a TPDRM Copy Freely state or an Unlimited First Generation TPDRM Copies state.","The parameters required by CKCMD_GET_DRM_COPY and settings include: HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_GET_DRM_COPY; SourceFile is the DFS handle for the file for which to get the key; ESessionKey is the current secure session key. The field EPlayKey is the play session key encrypted with the secure session key. The play session key is specific to the file specified by SourceFile. That is, the play session key is the key with which the content is encrypted in subsequent CKCMD_PLAY commands for SourceFile. RevocationList is the revocation list for the file.","The command CKCMD_GET_DRM_COPY is used to obtain the key for a file. It is used in the DRM Copy method. If the DRM Copy Count value associated with the file is not zero then the DRM Copy Count is decremented and rewritten to the media prior to completion of the command. CKCMD_GET_DRM_COPY is used during the DRM Copy method to obtain a play session key which may be stored along with the contents from a CKCMD_PLAY command. The files revocation list is also obtained and must be delivered whenever this content is imported to CKDRM. If SourceFile has a CKDRM Copy Freely state then the resulting copy also has a CKDRM Copy Freely State. Otherwise, the resulting copy has no CKDRM copy permissions. If SourceFile has a TPDRM Copy Freely or Unlimited First Generation CKDRM Copy state then the TPDRM Copy Count is unchanged. Otherwise, if the TPDRM Copy Count is not zero then the TPDRM Copy Count is decremented by the engine and stored back to the media prior to completion of the command. Delivery of EPlayKey is associated with decrementing the TPDRM Copy Count.","CKCMD_GET_METADATA: Checks Read Secure Metadata permissions and transfers third-party, host-specific secure metadata from the media to the host.",{"@attributes":{"id":"p-0374","num":"0373"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 32"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer"]},{"entry":["Reg",{},"to low byte."]},{"entry":["Byte","CKCMD_GET_METADATA","Command packet size."]},{"entry":["Count Reg","SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0375","num":"0374"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 33"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2009","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3\u2002","Reserved","U16","Reserved"]},{"entry":["4:7\u2002","Associated","DFSHANDLE","The file handle with which the"]},{"entry":[{},"File",{},"metadata is associated."]},{"entry":["8:23","ESessionKey","WRAPPED","The current secure session key."]},{"entry":[{},{},"KEY"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0376","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 34"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from engine to host)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:n\u22121","Metadata",{},"The metadata associated with a particular file"]},{"entry":[{},{},{},"and host; n bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The command CKCMD_GET_METADATA functions during a current secure session. Only hosts with Read Secure Metadata method permissions are allowed access to CKCMD_GET_METADATA. SourceFile must specify a file that is unlocked. SourceFile must specify a file that has metadata specific to the MetadataIdentifier value for the host.","The parameters required by the command and settings include: HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_GET_METADATA; ESessionKey is the current secure session key. See CKCMD_AUTHENTICATE for more information; Metadata is the metadata for the file that is securely stored. The metadata may be limited to 1024 bytes per file per host.","CKCMD_GET_METADATA returns third-party, host-specific secure metadata associated with a file. The metadata returned may be the metadata written by the last CKCMD_SET_METADATA for this host and file. If there has been no such command issued then the metadata pre-recorded for this file and host is returned. In an exemplary embodiment, the engine does not interpret the metadata in any way. The metadata may only be accessible to the host for the current secure session and only the metadata for that specific host may be accessible.","CKCMD_PLAY: Transfers secure content from the engine to the host under an established play session.",{"@attributes":{"id":"p-0381","num":"0380"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 35"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE =","Reset byte count pointer to low"]},{"entry":["Reg","011","byte."]},{"entry":["Byte","CKCMD_PLAY_SIZE","Command packet size."]},{"entry":["Count Reg",{}]},{"entry":["Control","FUNCTION CODE =","Start command."]},{"entry":["Reg","001"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0382","num":"0381"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 36"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2009","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3\u2002","PlayOptions","U16","Play options. Refer to the"]},{"entry":[{},{},{},"encoding."]},{"entry":["4:7\u2002","PlayFile","DFSHANDLE","File to play."]},{"entry":["8:15","ByteOffset","U64","Byte offset within the file from"]},{"entry":[{},{},{},"which to play."]},{"entry":["16:23\u2002","ByteCount","U64","Number of bytes to transfer."]},{"entry":["24:39\u2002","ESessionKey","WRAPPED","The current secure session key."]},{"entry":[{},{},"KEY"]},{"entry":["40:55\u2002","EPlayKey","AES_KEY","The current play session key."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0383","num":"0382"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 37"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PlayOptions Encoding"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bit",{},{}]},{"entry":["Number","Bit Mask Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","PLAY","0 = play normal; stop on play error"]},{"entry":[{},"STREAMING","1 = streamed play; no stop on play error"]},{"entry":["1\u2003\u2009","PLAY_TO_EOF","0 = play normal; stop when given byte"]},{"entry":[{},{},"count reached 1 = play to the end of the"]},{"entry":[{},{},"file; ignore the ByteCount field in the"]},{"entry":[{},{},"command packet"]},{"entry":["2:15",{},"Reserved."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"According to an embodiment, the command operates during a current secure session. Only hosts with CKDRM Play or DRM Copy method permissions are allowed access to CKCMD_PLAY. PlayFile must specify a file that is unlocked. PlayFile must specify a file that has DFS Read permissions. PlayFile must specify a file that has CKDRM Play or DRM Copy permissions. In the CKDRM Play method the received content may not be stored; in the DRM Copy method the received content may be stored.","The parameters required by the command include: HostCmd, which may be set to DPICMD_CK_COMMAND; CkSubCmd may be set to CKCMD_PLAY; PlayOptions are the options for this command. PlayFile is the DFS handle of the file to access; ByteOffset is the location within the file to start the transfer.","Because of the encryption of the file, the ByteOffset value could be a multiple of 16. In one embodiment, the value must be a multiple of 16. ByteCount is the number of bytes to transfer. If the PLAY_TO_EOF bit is asserted in PlayOptions then this field is ignored; otherwise, ByteCount must be a multiple of 16. ESessionKey is the current secure session key. See CKCMD_AUTHENTICATE for more information. EPlayKey is the play session key for the file specified by PlayFile, encrypted with the secure session key. The value may be the same as the value returned by the engine in the EPlayKey field in a preceding command for the same file. For the CKDRM Play method the preceding command is CKCMD_GET_CKDRM_PLAY_KEY. For the DRM Copy method, the preceding command is CKCMD_GET_DRM_COPY. The data returned is the file contents, encrypted with the play session key.","CKCMD_PLAY returns the content of the file encrypted with the play session key. Other than the encryption of content, CKCMD_PLAY is functionally equivalent to DFS_READFILE. Refer to the DataPlay File System commands specification for a complete description of the options and end-of-file behavior.","CKCMD_RECORD_APPEND: Checks CKDRM Record permissions and transfers secure content from a host to the end of a file.",{"@attributes":{"id":"p-0389","num":"0388"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 38"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer to low"]},{"entry":["Reg",{},"byte."]},{"entry":["Byte","CKCMD_RECORD","Command packet size."]},{"entry":["Count Reg","APPEND_SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0390","num":"0389"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 39"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2009","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3\u2002","RecordOptions","U16","Record options. Refer to the"]},{"entry":[{},{},{},"encoding."]},{"entry":["4:7\u2002","RecordFile","DFSHANDLE","File to record."]},{"entry":["8:15","ByteCount","U64","Number of bytes to transfer."]},{"entry":["16:31\u2002","ESessionKey","WRAPPED","The current secure session"]},{"entry":[{},{},"KEY","key."]},{"entry":["32:47\u2002","ERecordKey","WRAPPED","The current record session"]},{"entry":[{},{},"KEY","key."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0391","num":"0390"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 40"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"RecordOptions Encoding"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bit",{},{}]},{"entry":["Number","Bit Mask Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","RECORD_FOREVER","0 = record normal; transfer the number"]},{"entry":[{},{},"of bytes specified by ByteCount"]},{"entry":[{},{},"1 = record forever; the ByteCount field"]},{"entry":[{},{},"is ignored"]},{"entry":["1:15",{},"Reserved."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The CKCMD_RECORD_APPEND, in one embodiment, requires a current secure session. Only hosts with CKDRM Record method permissions are allowed access to CKCMD_RECORD_APPEND. RecordFile must specify a file with CKDRM Record and DFS Write permissions. The file may be locked or unlocked.","The parameters used by the command include: HostCmd, which may be set to DPICMD_CK_COMMAND; CkSubCmd may be set to CKCMD_RECORD_APPEND; RecordOptions are the options for this command and are encoded and behave as described by a RecordOptions Encoding table; RecordFile is the DFS handle of the file to access; ByteCount is the number of bytes to transfer, however, if the RECORD_FOREVER bit is asserted in RecordOptions then this field is ignored; ESessionKey is the current secure session key; ERecordKey is the current record session key and may be encrypted with the engine's protocol key. In an embodiment, the same record session key must be used for all instances of this command, and must match the record session key from the CKCMD_CREATE_FILE command that created the file. The data received is the content to add to the file. The data is encrypted with at least the record session key.","According to an embodiment, CKCMD_RECORD_APPEND adds content to the end of the file specified. CKCMD_RECORD_APPEND is functionally the opposite of CKCMD_PLAY. It is functionally equivalent to DFSCMD_WRITE_APPEND except for the encryption of the data.","CKCMD_SET_KEYBOX: Transfers a key box from the host for a particular file. The key box provides keys for unlocking data and may be bound to the media when content is pre-mastered.",{"@attributes":{"id":"p-0396","num":"0395"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 41"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer to"]},{"entry":["Reg",{},"low byte."]},{"entry":["Byte","CKCMD_SET_KEYBOX","Command packet size."]},{"entry":["Count Reg","SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0397","num":"0396"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 42"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2009\u2002","HostCmd","U8","Command code."]},{"entry":["1\u2009\u2002","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3","Reserved","U16","Reserved"]},{"entry":["4:7","AssociatedFile","DFSHANDLE","The file associated with"]},{"entry":[{},{},{},"KeyBox."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0398","num":"0397"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 43"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from host to engine)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:n","KeyBox",{},"The key box for the"]},{"entry":[{},{},{},"file."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"There must be a current secure session. Any host may be allowed access to CKCMD_SET_KEYBOX. AssociatedFile must specify a file that is unlocked and does not have a key box or CKDRM metadata.","The parameters required by the command include: HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_SET_KEYBOX; AssociatedFile is the DFS handle for the file with which KeyBox is associated; KeyBox is the key box for the file specified by AssociatedFile and the destination specified by CKDRMId.","The command directs that the engine writes the key box to the media and associates it with the specified file, thereby enabling the file for permissible CKDRM methods.","CKCMD_SET_METADATA: Checks Write Secure Metadata permissions and transfers third-party, host-specific secure metadata from the host to the media.",{"@attributes":{"id":"p-0403","num":"0402"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 44"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control","FUNCTION CODE = 011","Reset byte count pointer to"]},{"entry":["Reg",{},"low byte."]},{"entry":["Byte","CKCMD_SET_METADATA","Command packet size."]},{"entry":["Count Reg","SIZE"]},{"entry":["Control","FUNCTION CODE = 001","Start command."]},{"entry":"Reg"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0404","num":"0403"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 45"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2003\u2009","HostCmd","U8","Command code."]},{"entry":["1\u2003\u2009","DfsSubCmd","U8","Sub-command code."]},{"entry":["2:3\u2002","Reserved","U16","Reserved"]},{"entry":["4:7\u2002","Associated","DFSHANDLE","The file with which the metadata"]},{"entry":[{},"File",{},"is associated."]},{"entry":["8:23","ESessionKey","WRAPPED","The current secure session key."]},{"entry":[{},{},"KEY"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0405","num":"0404"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 46"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from host to engine)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"The secure metadata associated with a"]},{"entry":["1:n-l","Metadata",{},"particular file and host; n bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"There must be a current secure session. Only hosts with Write Secure Metadata method permissions are allowed access to CKCMD_SET_METADATA. AssociatedFile must specify a file that is unlocked. AssociatedFile may already have metadata specific to the MetadataIdentifier value for the host.","The parameters HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_SET_METADATA; AssociatedFile is the DFS handle for the file with which the metadata is associated; ESessionKey is the current secure session key. See CKCMD_AUTHENTICATE for more information; Metadata is the metadata associated with the file for the current host to be securely stored.","CKCMD_SET_METADATA is the complement function to CKCMD_GET_METADATA. This command writes DRM- or host-specific secure metadata to the DataPlay media for a particular file. The metadata received will be returned for subsequent CKCMD_GET_METADATA commands for this host and file. If AssociatedFile already has metadata specific to the MetadataIdentifier value for the host then it is overwritten by the new metadata.","The engine writes the metadata to the media and associates it with the specified file and the host for the current secure session. The engine does not interpret the metadata in any way.","The secure metadata will only be accessible to the host specified by the Metadata Identifier fields of the host CKDRM certificate for the current secure session.","CKCMD_UNLOCK_FILES: Checks CKDRM Unlock permissions and unlocks files.",{"@attributes":{"id":"p-0412","num":"0411"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 47"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Initiation:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Control Reg","FUNCTION CODE =","Reset byte count pointer to low"]},{"entry":[{},"011","byte."]},{"entry":["Byte Count","CKCMD_UNLOCK","Command packet size."]},{"entry":["Reg","SIZE",{}]},{"entry":["Control Reg","FUNCTION CODE =","Start command."]},{"entry":[{},"001"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0413","num":"0412"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 48"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Command Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Field",{},{}]},{"entry":["Byte Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0\u2009\u2002","HostCmd","U8","Command code."]},{"entry":["1\u2009\u2002","CkSubCmd","U8","Sub-command code."]},{"entry":["2:3","FileCount","U16","Number of files to unlock, n."]},{"entry":["4:7","Reserved","U16[2]","Reserved."]},{"entry":["\u20028:23","EUnlockKey","WRAPPED_KEY","The unlock key for EKeyComplement"]},{"entry":[{},{},{},"decryption."]},{"entry":["24:39","EMediaId","U128","The public unique media identifier."]},{"entry":["40:59","DataMac","MAC","The message authentication code for the"]},{"entry":[{},{},{},"data transfer."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0414","num":"0413"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 49"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Transfer (from host to engine)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte","Field",{},{}]},{"entry":["Offset","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:24n-1","FileSet","FILE_SET[n]","A list of identifiers of the files to"]},{"entry":[{},{},{},"unlock."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0415","num":"0414"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 50"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"FILE_SET data structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Byte",{},{},{}]},{"entry":["Offset","Field Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0:3\u2002","Handle","DFSHANDLE","The file to unlock."]},{"entry":["4:23","EKeyComplement","U160","The complement of the"]},{"entry":[{},{},{},"key set for the file."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"There must be a current secure session. Only hosts with CKDRM Unlock method permissions are allowed access to CKCMD_UNLOCK_FILES. The Handle fields in the FileSet list must each specify a file and must have CKDRM metadata.","The parameters for the CKCMD_UNLOCK_FILES include: HostCmd is set to DPICMD_CK_COMMAND; CkSubCmd is set to CKCMD_UNLOCK_FILES; FileCount is the number of files to unlock; EUnlockKey is the encrypted unlock key and is the key with which key complements are encrypted to form EKeyComplement values; EMediaId is the encrypted media identifier; DataMac is the message authentication code for the data packet. It is calculated over the FileSet field; FileSet is an array of identifiers of the files to unlock, the number of entries for which is the value specified by FileCount, each entry for which is a FileSet Element; the Handle field is the DFS handle of the file to unlock; the EKeyComplement field is the complement of the key set for the file, i.e., the complete key box may not be on the media and this field provides the remaining key box information needed to decrypt the file; and EKeyComplement is the complement value encrypted with the engine's public key.","The command CKCMD_UNLOCK_FILES instructs the engine to unlock a set of files. A secure session must be active with the host, and the host must have CKDRM Unlock permissions. In a successful CKCMD_UNLOCK_FILES command, the engine completes each file's key box and changes the attribute from locked to unlocked.","Cryptographic Algorithms","The above-described methods for the TPDRM, CKDRM and DFS use cryptographic algorithms. The manner in which the cryptographic algorithms apply to the methods depends on design requirements. Encryption techniques disclosed herein, therefore, are exemplary in nature, with the number of bits applicable to encrypted techniques being a function of available bit space and cost-efficiency. In one embodiment, AES functions may use 128-bit keys. The public key cryptography may be elliptic curve cryptography or another appropriate type of cryptography.","Referring back to the CKDRM methods, key encryption applies to key complements in the UNLOCK methods. For example, the method CKCMD_UNLOCK_FILES requires that key complements be transported. Thus, an embodiment provides that key complements are transported in EKeyComplement fields. The key complement may be encrypted and decrypted using AES with the unlock key as the AES key pair. Other fields applicable to the UNLOCK method include media identifiers and EmediaId fields. In an embodiment, the method CKCMD_UNLOCK_FILES provides that media identifiers are transported in EMediaId fields. The media identifier may be encrypted and decrypted using AES with a secure session key as the AES key.","The fields for Message Authentication Codes, CommandMac, DataMac, and RevocationMac also apply to the UNLOCK method, and further apply to the CKDRM CREATE FILE method. More specifically, message authentication codes are transported in CommandMac, DataMac, and RevocationMac fields. The message authentication code may be generated using the SHA-1 MAC function. The key for the MAC function is the current secure session key.","Play Session Content Encryption applies to the CKDRM method CKCMD_PLAY. More specifically, play session content may be transported in the data transfer phase of the CKCMD_PLAY method. The content may be encrypted and decrypted using AES with the play session key as the AES key.","Play Session Key encryption applies to the CKDRM methods CKCMD_GET_CKDRM_PLAY_KEY, CKCMD_GET_DRM_COPY and CKCMD_PLAY. In one embodiment, play session keys may be transported in EPlayKey fields or another appropriate field. The play session key may be encrypted and decrypted using AES with the secure session key as the AES key.","For record session content encryption, the CKDRM uses the method CKCMD_RECORD_APPEND. Record session content may be transported in the data transfer phase of the CKCMD_RECORD_APPEND method. The content may be encrypted and decrypted using AES with the record session key as the AES key. Similarly, for Record Session Key Encryption, ErecordKey, the method CKCMD_CREATE_FILE and CKCMD_RECORD_APPEND.","Record session keys are transported in ERecordKey fields. For one embodiment, the record session key is encrypted using the public key encryption function with the engine's Protocol Public Key as the public key. This public key is from the engine's CKDRM certificate. The encrypted record session key may be decrypted using the private key decryption function with the engine's private key corresponding to the engine's Protocol Public Key.","For Secure Session Key Encryption, the field EsessionKey is for the CKDRM methods CKCMD_AUTHENTICATE, CKCMD_CREATE_FILE, CKCMD_GET_CKDRM_COPY, CKCMD_GET_CKDRM_PLAY_KEY, CKCMD_GET_CKDRM_ID, CKCMD_GET_DRM_COPY, CKCMD_GET_METADATA, CKCMD_PLAY, CKCMD_RECORD_APPEND, CKCMD_SET_METADATA, and CKCMD_UNLOCK_FILES.","Secure session keys may be transported in ESessionKey fields. The secure session key is encrypted using the public key encryption function with the host's Protocol Public Key as the public key. This public key is from the host's CKDRM certificate for the current secure session. The encrypted secure session key may be decrypted using the private key decryption function with the private key corresponding to the host's Protocol Public Key.","For unlock key encryption, an embodiment uses the EunlockKey fields with the CKDRM method CKCMD_UNLOCK_FILES. For this method, the unlock keys are transported in EUnlockKey fields. For an embodiment, the unlock key is encrypted using the public key encryption function with the engine's Protocol Public Key as the public key. The public key may be from the engine's CKDRM Certificate. The encrypted unlock key may be decrypted using the private key decryption function with the engine's private key corresponding to the engine's Protocol Public Key.","One embodiment includes manifest constants including the opcodes below, which of ordinary skill in the art appreciates can be any opcode that doesn't collide. The manifest constants provided below pertain to one exemplary embodiment of non-colliding opcodes.",{"@attributes":{"id":"p-0431","num":"0430"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* --------- ----------------------- Simple Type Definitions ----------------------------------- *\/"},{"entry":"\/\/ CKDRM standard type definitions and bit mask definitions."},{"entry":"\/\/ Certicom types (sb_PublicKey, sb_SignatureECDSA) are defined in Certicom headers."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TYPEDEF (U128, AES_KEY);","\/\/ a 128-bit AES key"]},{"entry":["TYPEDEF (U160, MAC);","\/\/ a 160-bit Message Authentication Code"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ EXPOSED_METHODS definition, methods exposed by CKDRM Certificate."},{"entry":"TYPEDEF (U16, EXPOSED_METHODS) ;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define HOST_CKDRM_COPY","0x0001","\/\/ bit 0"]},{"entry":[{},"#define HOST_CKDRM_PLAY","0x0002","\/\/ bit 1"]},{"entry":[{},"#define HOST_DRM_COPY","\u2003\u2003\u20020x0004","\u2003\u2003\u2002\/\/ bit 2"]},{"entry":[{},"#define HOST_READ_SECURE_METADATA","\u2003\u2003\u20020x0008","\u2003\u2003\u2002\/\/ bit 3"]},{"entry":[{},"#define HOST_WRITE_SECURE_METADATA","\u2003\u2003\u20020x0010","\u2003\u2003\u2002\/\/ bit 4"]},{"entry":[{},"#define HOST_CKDRM_RECORD","0x0020","\/\/ bit 5"]},{"entry":[{},"#define HOST_CKDRM_UNLOCK","0x0040","\/\/ bit 6"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ CKDRM_STATE definition, CKDRM permission and attribute flags."},{"entry":"TYPEDEF (U16, CKDRM_STATE) ;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define FILE_CKDRM_COPY_FREELY","0x0001","\/\/ bit 0"]},{"entry":[{},"#define FILE_CKDRM_LOCKED","0x0002","\/\/ bit 1"]},{"entry":[{},"#define FILE_CKDRM_PLAY","0x0004","\/\/ bit 2"]},{"entry":[{},"#define FILE_DRM_COPY_FREELY","\u2003\u2003\u20020x0008","\u2003\u2003\u2002\/\/ bit 3"]},{"entry":[{},"#define FILE_UNLIMITED_FIRST_GENERATION_CK_COPIES","\u2003\u2003\u20020x0010","\u2003\u2003\u2002\/\/ bit 4"]},{"entry":[{},"#define FILE_UNLIMITED_FIRST_GENERATION_DRM_COPIES","\u2003\u2003\u20020x0020","\u2003\u2003\u2002\/\/ bit 5"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/* ----------------------------------------------------------- Constants ------------------------------------------------------------ *\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define DPICMD_CK_COMMAND","0x10"]},{"entry":"\/\/ CKDRM sub-command opcode definitions."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define CKCMD_AUTHENTICATE",{},"0xF2"]},{"entry":["#define CKCMD_CREATE_FILE",{},"0xF3"]},{"entry":["#define CKCMD_GET_CERTIFICATE",{},"0xF4"]},{"entry":["#define CKCMD_GET_CKDRM_COPY","0xF5"]},{"entry":["#define CKCMD_GET_CKDRM_ID","0xF6"]},{"entry":["#define CKCMD_GET_CKDRM_PLAY_KEY","0xF7"]},{"entry":["#define CKCMD_GET_DRM_COPY",{},"0xF8"]},{"entry":["#define CKCMD_GET_DRM_PLAY_KEY",{},"0xF9"]},{"entry":["#define CKCMD_GET_METADATA",{},"0xFA"]},{"entry":["#define CKCMD_PLAY",{},"0xFB"]},{"entry":["#define CKCMD_RECORD_APPEND",{},"0xFC"]},{"entry":["#define CKCMD_SET_KEYBOX",{},"0xFD"]},{"entry":["#define CKCMD_SET_METADATA",{},"0xFE"]},{"entry":["#define CKCMD_UNLOCK_FILES",{},"0xFF"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* ------------------------------ General CKDRM Data Structures ----------------------------- *\/"},{"entry":"\/\/ CKDRM Certificate"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U16","CAIdentifier;","\/\/ 0:1"]},{"entry":[{},"U16","CertificateFormatVersion,","\/\/ 2:3"]},{"entry":[{},"U16","CASignaturePublicKeyId;","\/\/ 4:5"]},{"entry":[{},"U16","CryptographyVersion;","\/\/ 6:7"]},{"entry":[{},"EXPOSED_METHODS","ExposedMethods;","\/\/ 8:9"]},{"entry":[{},"U16","Reserved1[3];","\/\/ 10:15"]},{"entry":[{},"U16","Company;","\/\/ 16:17"]},{"entry":[{},"U16","Division;","\/\/ 18:19"]},{"entry":[{},"U16","ProductLine;","\/\/ 20:21"]},{"entry":[{},"U16","Model;","\/\/ 22:23"]},{"entry":[{},"U16","Revision;","\/\/ 24:25"]},{"entry":[{},"U16","MetadataIdentifier;","\/\/ 26:27"]},{"entry":[{},"U16","Reserved2[2];","\/\/ 28:31"]},{"entry":[{},"sb_PublicKey","CompanySignaturePublicKey,","\/\/ 32:77"]},{"entry":[{},"sb_SignatureECDSA","CASignature;","\/\/ 78:121"]},{"entry":[{},"U128","DeviceIdentifier;","\/\/ 122:137"]},{"entry":[{},"sb_PublicKey","ProtocolPublicKey;","\/\/ 138:183"]},{"entry":[{},"sb_SignatureECDSA","CompanySignature;","\/\/ 184:227"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKDRM_CERTIFICATE;"},{"entry":"\/\/ CKCMD_AUTHENTICATE definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8 HostCmd,",{},"\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8 CkSubCmd,",{},"\/\/ 1, value = CKCMD_AUTHENTICATE"]},{"entry":[{},"CKDRM_CERTIFICATE Certificate;","\/\/ 2 241"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_AUTHENTICATE_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_CREATE_FILE definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["{","\/\/ Bytes"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"U8","HostCmd;",{},"\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;",{},"\/\/ 1, value = CKCMD_CREATE_FILE"]},{"entry":[{},"U16","RevocationByteCount;",{},"\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","Parent;",{},"\/\/ 4:7"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CKDRM_STATE CKDRMState;","\/\/ 8:9"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"U8","CKDRMCopies;",{},"\/\/ 10"]},{"entry":[{},"U8","DrmCopies;",{},"\/\/ 11"]},{"entry":[{},"U16","Reserved[2];",{},"\/\/ 12:15"]},{"entry":[{},"AES_KEY","ESessionKey;",{},"\/\/ 16:31"]},{"entry":[{},"AES_KEY","ERecordKey;",{},"\/\/ 32:47"]},{"entry":[{},"MAC","RevocationMac;",{},"\/\/ 48:67"]},{"entry":[{},"MAC","CommandMac;",{},"\/\/ 68:87"]},{"entry":[{},"DFSNAME","Name;",{},"\/\/ 88:n+87"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_CREATE_FILE_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_GET_CERTIFICATE definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},"\/\/ Bytes"]},{"entry":[{},"U8 HostCmd;","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8 CkSubCmd;","\/\/ 1, value = CKCMD_GET_CERTIFICATE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_GET_CERTIFICATE_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_GET_CKDRM_COPY definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd;",{},"\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;",{},"\/\/ 1, value = CKCMD_GET_CKDRM_COPY"]},{"entry":[{},"U16","Reserved;",{},"\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","SourceFile;",{},"\/\/ 4:7"]},{"entry":[{},"U256","CKDRMId;","\/\/ 8:39"]},{"entry":[{},"AES_KEY","ESessionKey;",{},"\/\/ 40:55"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_GET_CKDRM_COPY_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_GET_CKDRM_ID definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd;","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_GET_CKDRM_ID"]},{"entry":[{},"U16","Reserved;","\/\/ 2:3"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 4:19"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_GET_CKDRM_ID_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_GET_CKDRM_PLAY_KEY definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd;","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_GET_CKDRM_PLAY_KEY"]},{"entry":[{},"U16","Reserved;","\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","PlayFile,","\/\/ 4:7"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 8:23"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_GET_PLAY_KEY_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_GET_DRM_COPY definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd,","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd,","\/\/ 1, value = CKCMD_GET_DRM_COPY"]},{"entry":[{},"U16","Reserved,","\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","SourceFile;","\/\/ 4:7"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 8:23"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_GET_DRM_COPY_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_GET_METADATA definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd,","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd,","\/\/ 1, value = CKCMD_GET_METADATA"]},{"entry":[{},"U16","Reserved;","\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","AssociatedFile;","\/\/ 4:7"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 8.23"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_GET_METADATA_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_PLAY definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd;","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_PLAY"]},{"entry":[{},"U16","PlayOptions;","\/\/ 2:3, see bit field definitions below"]},{"entry":[{},"DFSHANDLE","PlayFile;","\/\/ 4:7"]},{"entry":[{},"U64","ByteOffset;","\/\/ 8:15"]},{"entry":[{},"U64","ByteCount;","\/\/ 16:23"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 24:39"]},{"entry":[{},"AES_KEY","EPlayKey;","\/\/ 40:55"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} CKCMD_PLAY_COMMAND_PACKET;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ PlayOptions bit fields.",{}]},{"entry":[{},"#define PLAY_STREAMING 0x0001","\/\/ bit 0"]},{"entry":[{},"#define PLAY_TO_EOF \u2003\u2002\u20090x0002","\/\/ bit 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ CKCMD_RECORD_APPEND definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd;","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_RECORD_APPEND"]},{"entry":[{},"U16","RecordOptions;","\/\/ 2:3, see bit field definitions below"]},{"entry":[{},"DFSHANDLE","RecordFile;","\/\/ 4:7"]},{"entry":[{},"U64","ByteCount;","\/\/ 8:15"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 16:31"]},{"entry":[{},"AES_KEY","ERecordKey;","\/\/ 32:47"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} CKCMD_RECORD_APPEND_COMMAND_PACKET;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ RecordOptions bit field.",{}]},{"entry":[{},"#define RECORD_FOREVER 0x0001","\/\/ bit 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ CKCMD_SET_KEYBOX definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd;","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_SET_KEYBOX"]},{"entry":[{},"U16","Reserved;","\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","AssociatedFile;","\/\/ 4:7"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_SET_KEYBOX_COMMAND_PACKET;"},{"entry":"\/\/ CKCMD_SET_METADATA definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd,","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_SET_METADATA"]},{"entry":[{},"U16","Reserved;","\/\/ 2:3"]},{"entry":[{},"DFSHANDLE","AssociatedFile;","\/\/ 4:7"]},{"entry":[{},"AES_KEY","ESessionKey;","\/\/ 8:23"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_SET_METADATA_COMMAND_PACKET;"},{"entry":"TYPEDEF (CKCMD_SET_METADATA_COMMAND_PACKET, sCKCMD_SET_METADATA_COMMAND_PACKET) ;"},{"entry":"\/\/ CKCMD_UNLOCK_FILES definitions"},{"entry":"typedef struct"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{},{},"\/\/ Bytes"]},{"entry":[{},"U8","HostCmd,","\/\/ 0, value = DPICMD_CK_COMMAND"]},{"entry":[{},"U8","CkSubCmd;","\/\/ 1, value = CKCMD_UNLOCK_FILES"]},{"entry":[{},"U16","FileCount,","\/\/ 2:3"]},{"entry":[{},"U16","Reserved[2],","\/\/ 4 7"]},{"entry":[{},"AES_KEY","ESessionKey,","\/\/ 8:23"]},{"entry":[{},"U128","EMediaId,","\/\/ 24:39"]},{"entry":[{},"MAC","DataMac,","\/\/ 40:59"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"385pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CKCMD_UNLOCK_FILES_COMMAND_PACKET;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Methods Performed with a Server","Another embodiment of the present invention is directed to interactions between servers and other entities, such as players. Thus, the secure electronic content system includes interactions between servers and hosts and engines to unlock and render secure content. The CKDRM, DFS and TPDRMs described above interact to permit unlocking content in a secure environment.","Referring to , an architecture diagram provides an embodiment of the interactions between servers, hosts and engines. As shown, the server, such as a digital clear server  interacts with both an electronic retailer (eTailer) via web-enabled communication line  and with a device connected to a personal computer (PC)  via a secure access channel . The device connected to the PC  receives the communications from server  via a web browser  wherein a CKU client  receives the communication. The web browser  further includes a dynamic web page(s) that is generated by an eTailer , which receives signals from an application server . Application server , in one embodiment includes a HTML and a GUI generator object , a package display and pricing object , a customer management object , a session management object , a credit card authorization object , a digital clearing server (DCS) interface  and a database connection layer  that couples the application server  to a plurality of databases . The plurality of databases  and the application server  are part of the eTailer web store front . In particular, the databases included in the eTailer web store front  include a customer database , package and pricing database  and a session and transaction database . As one of ordinary skill in the art will appreciate, however, the databases in the eTailer web store front are according to design requirements and may include more or less of the objects and databases described herein. Referring to the device connected to the personal computer , as described above, the web browser  within the device connected to the PC connects via a secure access channel  to a server, such as the digital clearing server . The web browser  is further connected via a secure access channel  to a USB driver  which also follows a secure access protocol to connect the USB driver  to a USB port  and to an engine  coupled within a device . The device  is coupled to media . The USB driver  is coupled, not only via secure access channel , but also via a signal line  to an Installable File System (IFS) . IFS  is coupled to an auto run handler  as described herein, as well as a content manager . Content manager receives signals from both the IFS  and the auto run handler  and provides content as managed by the content manager  to the web browser . The server , receiving signals via both signal line  and signal line  communicates with both the eTailer web store front  and with the device connected to the PC  using HTTP or other appropriate protocol in a web environment. The signal line  coupling the application server  to the digital clearing house server  receives signals at an eTailer interface  within a clearing server . The digital clearing server  includes a clearing server . Clearing server  includes the eTailer interface  which communicates with a plurality of databases, including a packaged database , a customer and eTailer database , a customer database , and a session and transactions database . Also included in the clearing server  is a digital clearing services object . The clearing server  is coupled to a integration object  within the clearing server . Integration object includes a database, more particularly a package to key mapping database . Also included in integration object  is a communication protocol or API . Communication protocol object is coupled to a CKU master server  as well as the package database  within the clearing server . CKU master server  is within the content key server . Content key server  includes at least a key complement database  and a transactions database , each of which are coupled to the CKU master server . CKU master server  is further coupled to a CKU server  which communicates via signal line  to the CKU client  located in the device connected to the PC .",{"@attributes":{"id":"p-0435","num":"0434"},"figref":"FIG. 23B","b":["2300","2310","2320","2350","2330","2340"]},"According to an embodiment, media and clearing house type servers are set up as part of a mastering process, or in other embodiments as part of a setup process for a server and media. More particularly, referring to , a flow diagram illustrates a setup process that results in a secure database and a media, such as a media disk. The clearing house server database configuration flow diagram provides a method of setting up a clearing house type server. Specifically, the process begins with block . Block  provides for a content provider to provide a new release of content to the server in a procurement process such as an \u201cAsset and Information Procurement\u201d as shown. The components included in the procurement process include content files, metadata information, security information, and package collection information, if any. The content files refer to files tied to a particular type or categorized content. These content files, in one embodiment, may include an appropriate media coder-decoder (codec). Metadata information includes any description of components that accompany a content file, such as graphics and lyrics. In one embodiment, the metadata is in a structured format, in other embodiments the format may be determined by individual content providers. Further, an embodiment requires that metadata must be provided on a per-track and per-album basis. The security information refers to rules governing the way the consumer interacts with the content. For example, the information may include a revocation list and TPDRM and CKDRM rules. The revocation list may be denied by a content provider and may include a list of all player devices, player applications and servers that have been revoked. Also included in the components received from a content provider are DRM rules providing restrictions on consumers regarding playing and copying of content. The DRM rules may also include details so that an authoring and mastering process or processes will know the files that require initial locking. Also included in block  is package collection information that specifies how secondary content is to be grouped and how to display the secondary content to the user.","Block  relates to an authoring process which may be accomplished via a DataPlay or third party. Specifically, the authoring process includes packaging all files received by a content provider according to predetermined specifications. In one embodiment, directories are established with the following data: content files (encoded); direction structure; content manager; autorum.inf; and contents.ddl.","The content manager includes files used to present content or media to the consumer, such as an executable, mini-website or some of the form defined by the content provider. The autorun.inf launches the content manager. The contents.ddl file is stored in a common area for use with any DRM. The contents.ddl may include a package collection, advertisements and SKUs. The SKUs may reference one ore more files. The package collection is, in one embodiment, a unique identifier (PCID) for all secondary content or for a side of media. The package collection may include a reference to one or more advertisements, for example, referring to a package collection. Block  provides that part of the authoring process includes providing DPMMF DDL files for describing the relationship between content and asset files.","Block  provides for a pre-mastering process to begin after the authoring process described with regard to block . More particularly, the pre-mastering process includes a content provider providing content subject to a DLM. The pre-mastering process includes three components, , , and . Flag  refers to a key component.ddl function wherein a file called KeyComplement.ddl is generated that will be used to configure a secure content key database. The KeyComplement.ddl file includes a package collection identifier. The package collection identifier, in one embodiment, includes a full file path name, a file handle, a key complement, which may be 128 bits, and a key version. The pre-mastering process further includes a function of passing along a file, contents.ddl that was created during authoring. The file, contents.ddl  is input into a next process, content key packaging process into a content key packaging process. Another portion of the pre-mastering process  is a DataPlay media mastering process wherein files are set on a tape. More particularly, the mastering file set is created in block  that is stored and delivered on a tape, in one embodiment. In other embodiments, the mastering file may be at another type of media. Each mastering file set refers to, in one embodiment, a single side on a media disc. Block  is shown coupled to the contents.ddl block  and the KeyComponent.ddl block . Block , more specifically refers to a master server key complement setup process also known as a digital clearing server setup process that relates to the data migration to a secured database . The master server key complement setup process  provides for loading tables for packaging a key mapping database such that the tables are loaded with information specified in the KeyComponent.ddl and Contents.ddl files. The block , DataPlay mastering file set on tape is shown coupled to the pre-mastering process . More particularly the mastering file set on a tape process  refers to creating one or more \u201cglass masters\u201d if the media is a optical disc. In other embodiments, the mastering file set will be mastered on to an appropriate media type. In an embodiment, glass masters are used to create one or more stampers. Stampers are then used to mass produce media  that will be distributed or available for purchase. The stamping process is a manufacturing process.","Referring now to  in combination with , a setup process is provided in a flow diagram for setting up the electronic retailer (eTailer). Referring to , the eTailer web store front  is shown including an application server  and databases . The setup for that process is described in . More particularly, the process starts at . Block  provides that the content provider package is setup and a change process occurs regarding a package definition. The eTailers generally require a package collection SKU for auditing purposes and other purposes and may not use a package collection ID as described above. Rather, the package collection ID is passed on to an eTailer through a URL, and the eTailer will simply hold it until passing it to a digital clearing server. In one embodiment, the eTailer discards the package collection ID. The content provider, as described above, supplies the eTailers with Contents.dll file as described with reference to , and any graphics that are to be a part of the package presentation to a consumer in block  and . Blocks  and  are shown coupled to block , the eTailer to package and pricing setup and change process \u201cpricing definition.\u201d More particularly, after a content provider has supplied available packages, the eTailers setup their pricing roles. Technical details for configuring a database with package, pricing, and package presentation data may be completely defined by an eTailer and may conform to an existing \u201cshopping cart\u201d and\/or catalog maintenance functionality of the eTailer. In addition to pricing, an eTailer, in one embodiment, may choose to specify discount models and advertising specifications. For example, a customer may choose a particular package along with an advertisement tailored for that consumer. Block  is shown coupled to database , eTailer secure database package pricing and presentation tables, the end product of the eTailer database setup. The eTailer secure database tables shown in block  are included in  as package and pricing database  and may it further include customer database .",{"@attributes":{"id":"p-0441","num":"0440"},"figref":"FIG. 26","b":["2600","2610","2620","2630"]},"Referring to , an exemplary user interface  is shown. The user interface may be generated by a web server and may include the presentation of a user option that allows the user to elect not to be presented with offers of some sort on future insertions of this media. If the user selects this option, a notation must be made either on the user's system or on the media denoting such. The user interface  shows an embodiment enabling an unlock transaction. More particularly, the interface  may be a web page with hyperlinks, such as  that direct the user to an activation center for entering data necessary to complete an unlock method. Also shown on the web page are indications  of status as to whether media read and interpreted for the interface  contains locked and unlocked files. If a file on the media is locked, a hyperlink to buy  may be presented to the user. For unlocked files, the interface provides a hyperlink  allowing the user to play a selection on the media.","The unlock portion of the SEC system is a framework of several components that work together. On embodiment is shown in . As shown, several components work together to unlock secondary mastered content that is stored on pre-mastered media. The framework for the CKU portion of the SEC system, according to one embodiment of the present invention, includes communication protocols that allow flexibility in user choice of both client and server platforms. Further, according to an embodiment, the communication protocols support various business models for unlocking and clearing which may include different components residing at different related component locations.  shows an embodiment of connectivity among components included in , and a broader perspective of the SEC system.","As shown in , the unlock system includes one or more databases coupled to a master server. In one embodiment, the databases coupled to the master server include a key complement database , a transactions database  and a revocation list database . The master server  is coupled to a web server  that is further coupled to a secure CKU server .","CKU Master Server  may be hosted by a Certificate Authority or other entity responsible for authenticating both engine certificates and CKU Server certificates by checking them against a revocation list. CKU Master Server  may also be responsible for securely delivering Key Complements from a master Key Complement database  to the CKU Servers  that may deliver them to engines .","The CKU Server  may be a server-side runtime object that works with a web application server  and several databases ,  and  to manage portions of the CK unlock. CKU server  may be hosted by any entity that requires the capabilities to transact and unlock CKDRM secondary content such as a clearing partner (Reciprocal, DWS, Magex, etc.), retailer website or DataPlay.","Each CKU Server  may be issued a unique CKDRM Certificate and public-private encryption key pair for use in establishing the secure authenticated channels (SAC) with the engine  and the CKU Master server . Further, The CKU Server  may incorporate cryptography functionality. For example, the CKU Server  may include functions such as PKI, AES, triple-DES and MAC algorithms. Further, a Random Number Generator (RNG) algorithm, such as one that complies with FIPS-140, may be appropriate.","The web server  is coupled to one or more databases, depending on requirements of the system, such as co-branded elements from third party distributors , offers database , and a transactions database . The CKU server  is coupled to a client server  and a web page  hosted by the client server . The web page  provides an interface for a user to communicate with the other components in the secure electronic content system. More particularly, a host device  holding an engine  may communicate via the web page . The communication between components may be via a standard TCP\/IP protocol. The user interface is presented by a web-server  through a browser to an end-user.","As will be appreciated by one of skill in the art, administrative and reporting tools may be appropriate.  shows an offers database  that may contain information about the available secondary content on each pre-mastered media disk, including, for example, pricing, titles, descriptions, etc. Either content providers or retailers may maintain this database.","Also shown is transactions database  which provides a place for recording unlock transactions. The data collected may be used to determine payments to the various entities that take part in the value chain of unlock transactions. The transactions database  may also store temporary state information about transactions in progress. The CKU Server  and Web Server  may require access to this temporary data.","The UI Elements database  may contain information that the web server  uses to construct custom branded pages and sites. This may include branding at the retailer level as well as individual branding based on the particular SKU of media that is being offered.","The databases Key Compliment database  may include unlock codes, such as Key Complements for mastered media. Each individual file that is locked on a piece of media may have a unique Key Complement. These Key Complements, in an exemplary embodiment, are securely delivered from the pre-mastering for manufacturing and stored with corresponding SCID information about the media. Access to this database is strongly guarded. Only a valid CKU Master Server  may have access to this database.","The revocation database  may contain information about revoked engine certificates and revoked CKU Server certificates. The revocation database , in one embodiment, is checked in every transaction to ensure that only authorized participants are allowed to take part in the unlock process.","The transactions database  may record transactions between CKU Servers  and the CKU Master Server .","In one embodiment, CKU Master Server  has exclusive access to the Key Complements Database. The CKU Master Server  may be similar in construction to the CKU Server  and sets up an active \u201clisten\u201d socket that accepts incoming connections. It accepts connections from CKU Servers  seeking to obtain Key complements to perform unlocking operations.",{"@attributes":{"id":"p-0456","num":"0455"},"figref":["FIG. 29","FIG. 30"],"b":["2952","2950","2710","2720","2730","2740","2760","2680","2670","3010","3020","3030","3040"]},"Referring to , according to one embodiment, media may be purchased at a number of facilities such as those shown in . A consumer may purchase a pre-mastered disk  in a primary transaction and render the content available, as shown in block . In a secondary transaction , the consumer may choose to exercise offers presented via an Internet connection coupled to an engine in  to unlock content  via a secure clearing house .","Referring to , the user interface, and, more particularly, an auto-run handler associated with a user interface performs method . The auto-run handler may be responsible for detecting when media, such as a disk, is inserted into a device connected to a personal computer. Upon detecting the media insertion, the auto-run connects to an engine and determines the state of the media. The state may include identifying the specific media and side and whether or not there is any content available to offer for sale to the consumer. The auto-run handler may also check either the user's system or the media to determine if the user has requested not to be presented any more offers for this disk. Block  determines whether there is locked content that could be offered to the consumer via a user interface. One embodiment of the present invention is directed to a method for a user interface which may be operable via a driver for an engine, or operate in conjunction with the auto-run handler that executes at system startup or upon user selection. The user interface may present menu options to the user including PLAY, EJECT, PURCHASE ADDITIONAL CONTENT, and EXIT.","If there is locked content, the interface determines in block  whether the user previously requested not to see the offers from this media again. If so, the method ends at block . If not, block  provides that the interface determine the SCID (Side Content ID) and the locked state flags for the media. Block  provides for connecting to a URL, such as for a CKDRM compliant unlock server address or associated server address that may be mastered onto the media and pass the data to the server, such as by a query string in the URL. In other embodiments, block  connects to a URL that is according to a serial number mastered on the media. The number mastered on the media may be a time stamp, indicating the date of the master, a serial number associated with a server or URL, neither or both. In one embodiment, for example, the serial number or time stamp advantageously allows distributors of pre-mastered media to return media disks to their source.","Block  provides for connecting to a URL, such as for a CKDRM compliant unlock server address or associated server address that may be mastered onto the media and pass the data to the server, such as by a query string in the URL. In other embodiments, block  connects to a URL that is according to a serial number mastered on the media. The number mastered on the media may be a time stamp, indicating the date of the master, a serial number associated with a server or URL, neither or both. In one embodiment, for example, the serial number or time stamp advantageously allows distributors of pre-mastered media to return media disks to their source.","More particularly, in one embodiment a method is directed to identifying one or more vendors associated with a media disk. The method includes providing instructions for the media disk, such as including a URL in the instructions, or providing a code that may be associated with a URL. Further, during an install of the media disk into a host according to the instructions, the method provides for installing an identifier on the media disk. The identifier may be a code identifying the vendor from which the media disk originated. For example, one method of identifying a location associated with a vendor of a media disk holding hidden content can include finding a location associated with the vendor, the location being associated with the vendor of the media disk and independent of any vendors that are not associated with the media disk. The instructions for the media disk may include identifying a vendor from whom the media disk was purchased. For example, the media disk may provide instructions that include a code, a universal resource locator (URL), a cryptographic key associated with the vendor, and a part of a cryptographic key associated with the vendor, each of which may be a explicit or implicit location. A system in accordance with such a method may include instructions for the media disk, and a software installation component associated with the media disk, the software installation component instantiable during an install of the media disk into a host according to the instructions. Specifically, the software installation component may be operable to install an identifier on the media disk, the identifier including a code associated with the vendor. In one embodiment, the identifier is associated with a location of the vendor such that a connection between the host and a server is operable to open the location. For example, the location could be an Internet location including web pages for unlocking content stored on the media disk, the Internet location further providing optional offers for purchase over the Internet by the vendor.","In another embodiment, a method of identifying a location via a media disk relates to the media disk having at least a writeable portion and a non-rewriteable portion. In the embodiment, the method includes writing the location on the writeable portion, distributing one or more of the media disks to one or more entities, the location associating the media disks to the one or more entities, and if a return of the media disks occurs, altering the location according to predetermined conditions. The location may be universal resource locator (URL) and the predetermined conditions may include determining a market share of the one or more entities. The altering the location may be by a content provider, the content kilo provider receiving the media disk, including one or more media disks, and distributing the returned media disks to same or different entities of the one or more entities after the altering. For example, the distributing may be pursuant to a lease agreement for media disks, the lease agreement allowing return of unsold media disks.","In general, content providers provide media holding content to distributors via a lease arrangement under which distributors pay only for those media disks that are sold. Unsold media disks are returned to the content providers. In the embodiment, the pre-mastered media disks may or may not permanently identify a distributor or content provider URL for unlocking content. For example, a distributor that desires having a pre-mastered media disk being associated with the distributor's URL for presenting offers, coupons, etc., and also desires the flexibility of returning unsold media disks, may receive media disks with serial numbers and\/or time stamps that allow a main server to direct a user to the distributor's URL. Other distributors may be satisfied with a sticker identifying a URL for unlocking content. In one embodiment, the main server URL is permanently mastered on the media disk along with a serial number and\/or time stamp. The main server receives direction from a plurality of content providers and\/or authorized distributors that identify URLs for distributors that are associated with serial numbers. In the event that a distributor returns one or more media disks to a content provider for re-distribution, the time-stamp associated with the serial number may be used to more specifically identify a group of media disks with a same serial number, or the serial number alone may identify the media disks. The identified media disks are then redirected from the distributor's URL to a second distributor's URL or to a generic URL.","In another embodiment, each media disk is directed to a main server and redirected according to a market share percentage such that the number of accesses that are redirected to a distributor URL is proportional to the market share held by the distributor.","In block , if the media has no locked content or the user elected not to see offers for this media, the interface determines whether there is an authored autorun INF file on the media.","If the user selects PLAY, the PLAY method as described above is executed in block . The auto-run handler may cause a URL connection. A web server may then generate a client side script to embed an object and call an entry point with variables according to a client object API. The commands for the object may include: ConnectCKUServer(VARCHAR ServerIP, UINT Port, UINT SessionID, UINT ContentID, UINT USBDriverID). In an embodiment, ServerIP is a string variable that describes the URL to which the object is to connect. Port is the listening port number for the CKU Server. SessionID is a unique identifier assigned by the server. The SessionID may associate a Socket connection with the particular web session that was initiated so that the server can synchronize its state. The SessionID may also be stored as the key in the temporary portion of a transaction database, such as database , shown in , for information passing between a web server  and the CKU Server . ContentID is an identifier for the side and disk that contains the content to be offered to a consumer. USBDriverID is an identifier that allows a CKU Client  to locate a specific instance of a drive that generated an auto-Insert notification that started an unlock session. In one embodiment, the autorun connects to a CKU Server  by passing the SCID and locked-state flags in a query string to a URL mastered onto the disk, a URL identified by a user, or a default URL. In an embodiment, the URL is connected to by a \u201cShell Executing\u201d the URL launches a browser on a user's system and connect to server . The URL may optionally point to a CKU Portal, which may be an intelligent redirector. The redirector may decide, based on, for example, Media identification information, the web server to which the client will be connected. Referring back to B, block  provides for presenting offers according to the URL, auto run, or other mechanism for presenting offers.","Referring to , a method for connection to CKU Server  is shown. In one embodiment, the method may be called by a script performed by a client object. Block  provides for locating a driver for a connected device. Block  provides for connection to an engine and retrieving a CKDRM certificate, such as those described above. Block  provides for connecting to a CKU Server , using, for example, a socket mode set such as BSD\/WinSock with SOCKET_STREAM mode set. Block  provides for awaiting acknowledgment from the CKU Server . Block  provides for delivering the engine's CKDRM Certificate to the CKU Server . Block  provides for receiving the CKU Server  CKDRM Certificate. Block  provides for passing the server certificate to the engine  using CKCMD_AUTHENTICATE. Block  provides for retrieving a ESessionKey and passing it to the CKU Server . Block  provides for receiving the unlock data block from the server  and passing it to the engine  using CKCMD_UNLOCK_FILES. Block  provides for reporting status of the unlock operation to the server . Block  provides for updating a play list on media that is coupled to the engine  to include newly unlocked content.","Referring now to  in combination with , the CKU Server  manages many concurrent connections and unlock-transactions as described, for example in . Once a connection is requested from a client the server must accept the connection and proceed with the method shown in . As shown, in block , the CKU Server  acknowledges a client connection. In block , the CKU Server  receives an engine's CKDRM Certificate and Session ID from the client . In block , the CKDRM retrieves SCID and a list of DFS file handles to be unlocked from the Transaction Database  using the SessionID as the index or key. In block  the CKU Server  connects to the CKU Master Server . In block , the CKU Server  awaits the connection acknowledgement from CKU Master Server . In block , the CKU Server  passes a Server CKDRM Certificate, the engine  CKDRM Certificate, media SCID and DFS file handles to the Master CKU Server . In block , the CKU Server  receives the Key Complements from the CKU Master Server . In one embodiment the keys are encrypted using the CKU Server  public key. In block , the CKU Server  acknowledges the receipt to the CKU Master Server . In block , CKU Server  disconnects from CKU Master Server . In block  CKU Server  passes the Server CKDRM Certificate to the Client . In block  CKU Server  receives the ESessionKey from the Client  that may be encrypted with the CKU Server  public key. In block , CKU Server  decrypts the Session Key using a Server Private Key. In block , CKU Server  decrypts Key Complements, for example, using PKI with a Server Private Key and add Session Key information. In block , CKU Server  generates a random key using, for example, AES and\/or triple-DES to be used to re-encrypt the Key Complements that provide unlock capability. Block  provides that the CKU Server  encrypts the Key Complements using the Unlock Key, using, for example, AES and\/or triple-DES. In block , CKU Server  encrypts the Unlock Key using the engine public key using, for example, PKI. In block , CKU Server  constructs a CKCMD_UNLOCK_FILES data block and transmit to the Client . In block , CKU Server  constructs a MAC for the data portion of the block. In block , CKU Server  transmits the data block to the Client . In block , CKU Server  receives unlock status from Client . In block , the transaction status is marked in the Transaction Database . In block , the CKU Server  disconnects from Client.","In one embodiment, in block , a web server  completes the financial transaction after receiving indication from the CKU Client  that the unlock has completed successfully.","Referring to , a method performed by the Master Server  of  is provided. Block  provides that Master Server  accept connection from CKU Server . In block , the Master Server  acknowledges the connection. In block , Master Server  receives the CKU Server  CKDRM Certificate, the engine's CKDRM Certificate, media SCID and DFS file handles from the CKU Server . In block , Master Server  verifies the validity of both certificates by, for example, checking MAC and PKI signatures. In block , the Master Server  checks the Revocation database  to make sure there are no revoked certificates participating. In block , Master Server  retrieves requested Key Complements from Key Complement Database . In block , Master Server  encrypts the Key Complements using the CKU Server  Public Key. In block , Master Server  transmits the encrypted data to the CKU Server . In block , Master Server  receives an acknowledgment from CKU Server  and disconnects.","The methods described above for the servers shown in  begin with a client, such as CKU Client  beginning a method. Referring to , the method for web page  and CKU client server  is described. A client  begins the method in  by accessing a formatted URL, such as a URL on a media disk as described above, or a URL associated with a serial number on a media disk or other source. In block , the client  presents a query string containing the SCID and locked content status. In block , web server  constructs a page to present the offers to a consumer using data from the Offers database  and the UI Elements  databases. After user selections have been made in block , and the conditions of the transaction have been satisfied web server  delivers an \u201cUnlocking in Progress\u201d page to the client. In block  the web server  generates a unique SessionID that is used later to commit the transaction after the unlock process is verified. In block , the web page  embeds a CKU Client  object and contains client-side script that tells the CKU Client  to begin the unlock process. The web server  may also store in block  the SCID and a list of DFS File Handles indexed by the SessionID in the Transaction Database for later use by the CKU Server object. CKU Client  may be an embedded object within the web page delivered to an end user's computer. The object may be developed as both an ActiveX control and Netscape Plug-in to support the majority of browser client environments. The objects methods and properties may be accessed via Java Script. The object sends an OLE event to the page at the completion or error of the transaction.","When the web server receives a connection from a client browser with media information, it constructs the first page of the offers presentation. In some cases the SCID and locked-state flags will be enough data to determine the branding of the page (if the media was mastered with a unique ID specific to a single retailer or promotion) In other cases the user may have to be prompted to enter a code from a sticker on the packaging or select the retailer where they purchased the disk. Offers and pricing are retrieved from the Offers Database and presented to the consumer in a branded page.","The user makes selections from the offers and must satisfy the conditions of the transaction. These conditions may require the entry of payment information or demographic data in exchange for unlocking the content.","Once the conditions of the transaction have been met the web server constructs an \u201cUnlock in Progress\u201d page. This page embeds a CKU Client object and script to instantiate the object with the correct parameters. The web server also makes a temporary entry in the Transactions Database that contains a unique SessionID, SCID, authorization code for the credit card transaction and a list of DFS file handles to be unlocked.","Referring to , a method according to one embodiment for unlocking content is provided with a system viewpoint. Block  provides for delivering a page to the client, the CKU Client object is instantiated and initialized with the Session ID, SCID and the IP: PORT address for the CKU Server. In block , the CKU Client locates a driver for the device that contains the media with content to be offered. In block , CKU Client obtains the engine's CKDRM Certificate. In block , CKU Client makes a connection, for example, a socket connection, to a listening port on the CKU Server. In block , CKU Server accepts the incoming connection from the client and acknowledges the connection with an acknowledgment message. In block , the CKU Client transmits the engine's CKDRM Certificate and the SessionID to the CKU Server using a connect message. In block , the CKU Server responds with either an acknowledgment or a retransmit message. In block , CKU Server then locates the corresponding record in the Transaction Database by indexing the unique SessionID for this session. In block , CKU Server connects to the CKU Master Server listening port using a socket connection. In block , CKU Master Server accepts the connection and replies with an acknowledgment message. In block  CKU Server assembles a message packet to request keys and transmits it to the CKU Master server. The packet may contain an engine CKDRM Certificate, the CKU Server CK Certificate, SCID for the media and the list of DFS File Handles for which Key Complements are requested.","In one embodiment, the message sent by CKU Server to CKU Master Server to request the keys to unlock content takes the form as shown in Table 51 In the embodiment, message shown in Table 51 contains both the engine and server CKDRM certificates, the identifier (SCID) for the media containing the files and the list of DFS Handles for each file to be unlocked.",{"@attributes":{"id":"p-0477","num":"0476"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 51"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Byte Offset","Type","Field Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0:1","U16","MessagelD = 5","0x0005 CKU_REQ_KEYS"]},{"entry":["2:3","U16","MessageLength","Total byte length including"]},{"entry":[{},{},{},"header"]},{"entry":["4:7","U32","Reserved","Reserved for later use"]},{"entry":["\u20038:247","CK_CERTIFICATE","ServerCert","CKU Server CK Certificate"]},{"entry":["248:487","CK_CERTIFICATE","EngineCert","Engine CK Certificate"]},{"entry":["\u2009488:491:","U32","NumHandles","Number of DFS Handles"]},{"entry":["492:n\u2003","DFS_HANDLE","HandleList","List of DFS Handles"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Referring back to , in block , CKU Master Server responds with an acknowledgment or, if any problems occur a retransmit packet.","In block , CKU Master Server validates or denies the CKDRM certificates of both the engine and CKU Server. Validation could include verifying digital signatures using, for example, Certicom\u2122. In block , CKU Master Server checks for the presence of the certificates in the Revocation database. If the certificates are invalid or revoked, the CKU Master Server responds in  with an error message. If the certificates are valid, CKU Master Server retrieves in block  the Key Complements from an associated database, encrypts them, using for example, PKI, using for example, a Server Public Key from a Server Certificate. In block , the CKU Master Server transmits the key complements to CKU Server.","Referring to Table 52, the message sent by CKU Master Server may be an encrypted list of Key Complements for requested files as shown. The Key Complements may be encrypted using the CKU Server's public key or another appropriate public key.",{"@attributes":{"id":"p-0481","num":"0480"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 52"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Byte",{},{},{}]},{"entry":["Offset","Type","Field Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0:1","U16","MessageID = 6","0x0006 CKU_KEYS"]},{"entry":["2:3","U16","MessageLength = 8","Total byte length including"]},{"entry":[{},{},{},"header"]},{"entry":["4:7","U32","Reserved","Reserved for later use"]},{"entry":["\u20028:11","U32","NumKeys","Number of key complements in"]},{"entry":[{},{},{},"list"]},{"entry":["12:n\u2002","U160","EKeyComplimentList","Encrypted list of Key"]},{"entry":[{},{},{},"Complements"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"In block , CKU Server receives the Key Complements, acknowledges the receipt of the data by sending an acknowledgment message, and disconnects from the CKU Master Server. In the event of a data mismatch or receive error, in block  CKU Server responds with a retransmit message. In block , CKU Server transmits its CK Certificate to the CKU Client using an authenticate message. In block , CKU Client responds with either an acknowledgment or a retransmit. In block , CKU Client constructs an authentication command packet to send through the driver to the engine. In response, in block , engine responds with an encrypted session key that the CKU Client then passes in block  to the CKU Server in a session key message.","In block , CKU Server responds with either a server acknowledgment or a retransmit message. In block , CKU Server decrypts the session key and the key complements with a private key. The CKU Server generates in  a random key, for example, a 128-bit AES key to re-encrypt the key complements. A session key may be used to encrypt an unlock key and to construct an unlock message. The message may contain a complete packet for an unlock command to the engine. In one embodiment, the command may require calculation of the MAC for the data.","In block , CKU Server sends an unlock message to CKU Client. In block , CKU Client responds with an acknowledgment or a retransmit message. In block , CKU Client uses the data to send a command to unlock files to the engine. After receiving status from the engine, in block  CKU Client sends either an error or an unlock complete message to CKU Server. In block , CKU Server marks the status of the unlock operation in the Transaction Database and disconnects from the CKU Client. In block , CKU Client reports the status of the transaction to the web page by sending an event to an event handler in the web page. In block , the web page displays the transaction status.","In the method shown in , a number of opportunities occur for errors. As shown in Table 53, those errors that may be sent in a message include those listed.",{"@attributes":{"id":"p-0486","num":"0485"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 53"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Error",{},{}]},{"entry":["Code","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","CKU_ERR_UNKNOWN","An unknown or undefined"]},{"entry":[{},{},"error has occurred"]},{"entry":["1","CKU_ERR_INVALID_DATA","Some data in the last packet"]},{"entry":[{},{},"sent was invalid"]},{"entry":["2","CKU_ERR_INVALID_MESSAGE","Invalid message ID"]},{"entry":["3","CKU_ERR_ECERT_INVALID","Invalid Engine Certificate"]},{"entry":["4","CKU_ERR_SCERT_INVALID","Invalid Server Certificate"]},{"entry":["5","CKU_ERR_ECERT_REVOKED","Engine certificate is"]},{"entry":[{},{},"revoked"]},{"entry":["6","CKU_ERR_SCERT_REVOKED","Server certificate is revoked"]},{"entry":["7","CKU_ERR_INVALID_MEDIA","The media ID is invalid"]},{"entry":["8","CKU_ERR_INVALID_HANDLE","There is an invalid handle"]},{"entry":[{},{},"in the DFS file handle list."]},{"entry":[{},{},"The index of the bad handle"]},{"entry":[{},{},"is reported in the"]},{"entry":[{},{},"ContextData field."]},{"entry":["9","CKU_ERR_SAUTH_FAILED","Server authentication failed."]},{"entry":[{},{},"(Either with the Engine or"]},{"entry":[{},{},"CKU Master)"]},{"entry":["10","CKU_ERR_UNLOCK_FAILED","For some reason the engine"]},{"entry":[{},{},"reported a failure"]},{"entry":[{},{},"unlocking. Status code"]},{"entry":[{},{},"from Engine is reported in"]},{"entry":[{},{},"ContextData field."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The security of the SEC system, in one embodiment or more, is enhanced by a plurality of identifiers located on the media. The identifiers may be public, private or both. As described above, the identifiers may be created during a mastering process or later during other transactions, depending on system requirements as shown in Table 54.",{"@attributes":{"id":"p-0488","num":"0487"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 54"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Access","Location and Creation","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Public","Created by the mastering","GUID for each stamper master"]},{"entry":[{},"process","created."]},{"entry":["Public","Identifier structure.","Statistically unique identifier created"]},{"entry":[{},"Created in the field.","in the field."]},{"entry":["Private","Identifier structure.","Statistically unique identifier for each"]},{"entry":[{},"Created by the","master with ContentKey content. This"]},{"entry":[{},"mastering process","is the identifier to which pre-recorded"]},{"entry":[{},{},"content is bound."]},{"entry":["Private","Identifier structure.","Statistically unique for each"]},{"entry":[{},"Created in the field.","individual media with written"]},{"entry":[{},{},"ContentKey content. This is the"]},{"entry":[{},{},"identifier to which written or field-"]},{"entry":[{},{},"recorded (non-mastered, not pre-"]},{"entry":[{},{},"recorded) content is bound."]},{"entry":["Private","Non-volatile memory.","GUID for each engine created."]},{"entry":[{},"Created by the engine"]},{"entry":[{},"manufacturing process."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The method for unlocking content stored on media shown in , illustrates a protocol for authenticating and performing an unlock protocol. From an engine perspective, the unlock protocol includes the method shown in . In block  the engine receives a handle, and a key complement to a key box. The key box may be bound to a written identifier. In block , the engine performs a key box look up. In block , the keys within the key box are unbound and decrypted. In block , the transaction is completed and keys are rebound, encrypted and locked. As a result of the methods shown in , the APIs are protected when data passes from a server. As a result of the authentication on both sides of an unlock transaction, communication is established with a data session key. In one embodiment, the data session key is received as a PKI encryption block along with a public key. Thus, the communication channel is encrypted when sent to a host. The host holds a private key and decrypts the data to receive a secret session key. The secret session key is received by an encrypted block, such as an AES block, along with data, which may be a key box.",{"@attributes":{"id":"p-0490","num":"0489"},"figref":"FIG. 37","b":["3700","3702","3704","3706","3708","3706"]},"The content manager is Block  provides an optional CKDRM portal for those CKDRM content files. In one embodiment, the need for a CKDRM portal is necessary only if one of the following situations are present. First, a package collection ID appended to a URL points to a package or set thereof that can be unlocked by more than one eTailer, such as a secondary music transaction for unlocking by another eTailer. Second, a package collection ID that was appended to the URL that points to two or more packages that can be unlocked by a different eTailer. In either case, the presence of optional eTailers requires a user or consumer to choose an eTailer before continuing the transaction.","Block  provides for a login into the CKDRM domain. More particularly, a login a process may be according to the particular eTailer. Thus if a customer or user does not have an account with a desired eTailer, they can establish an account at block  or, depending on the eTailer, choose a guest login access and provide valid billing data for processing transaction with credit card authorization required. After a login procedure is completed, block  provides for a package\/pricing presentation to a consumer or other user. The consumer of user selects content to unlock or ends the procedure if no selection is made. A package listing in block  provides a customer with a procedure to select one or more packages to unlock. In block , a customer information questionnaire is presented to the customer\/user in which billing or other data is required or requested to be entered. Block  provides for a presentation of the transaction summary, for example according to data entered in the questionnaire. Block  provides for credit card authorization, which may or may not be desired depending on system requirements. For example, a code may allow for free unlocking of content in return for other or no compensation at the questionnaire . Block  provides for digital clearing server notification of the transaction. More particularly, an eTailer may be responsible for using a protocol required by a digital clearing server to communicate that an unlock transaction has taken place. In one embodiment, an eTailer must provide the digital clearing server with the package collection ID and list of packages that a customer\/user desired\/purchased. Also, the digital clearing server may also require a certain level of customer information to be provided.","Block  provides for a presentation to the user or consumer of CKDRM enabling status. Block  provides for an engine and a server conversing according to an authentication procedure. Block  provides for a key complement lookup and delivery and writing of the key complement to the device\/disk or other location requiring a key complement to complete cryptographic requirements. Block  provides for an update of a contents.ddl file. Block  provides for a procedure to complete the CKDRM transaction for unlocking content. Block  provides for a transaction by an eTailer, e.g., a party that retails over the Internet, to complete the notification of the completed transaction. Block  provides for an optional congratulations presentation to the user or consumer.","Referring to  in combination,  provides a flow diagram of a method according to one embodiment for a process to unlock content. The object interaction among components of the SEC system is shown in . More particularly, referring to , block  provides for the Digital Clearing Server (DCS) Order Management Server  to insert records DCS_STAGE table with or without a media identifier to the DataPlay (DP) Secure Database  in  shown by INSERT INTO DCS_STAGE .","Specifically, referring to the DP Secure Database , an embodiment of a schema of the database is provided below in table 55 A through D.",{"@attributes":{"id":"p-0496","num":"0495"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 55 A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"CKDRM_MASTER_KEY"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MASTER_ITEM_ID","NUMERIC(0,0)","NOT NULL"]},{"entry":[{},"PC_ID","VARCHAR(40)","NOT NULL"]},{"entry":[{},"ITEM_NAME","VARCHAR(400)","NOT NULL"]},{"entry":[{},"ITEM_HANDLE","VARCHAR(8)","NOT NULL"]},{"entry":[{},"KEY_COMPLEMENT","VARCHAR(50)","NULL"]},{"entry":[{},"KEY_VERSION","NUMERIC(3,0)","NULL"]},{"entry":[{},"BUSINESS_ENTITY_ID","NUMERIC(3,0)","NULL"]},{"entry":[{},"CHANGE_ID","VARCHAR(8)","NOT NULL"]},{"entry":[{},"CHANGE_DT","DATE","NOT NULL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0497","num":"0496"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 55 B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"CKDRM_MASTER_PKG"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MASTER_PKG_ID","NUMBERIC(0,0)","NOT NULL"]},{"entry":[{},"PC_ID","VARCHAR(40)","NOT NULL"]},{"entry":[{},"PKG_ID","VARCHAR(40)","NOT NULL"]},{"entry":[{},"CHANGE_ID","VARCHAR(8)","NOT NULL"]},{"entry":[{},"CHANGE_DT","DATE","NOT NULL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0498","num":"0497"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 55 C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"CK_MASTER_PKG_KEY"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MASTER_PKG_ID (FK)","NUMERIC(0,0)","NOT NULL"]},{"entry":[{},"MASTER_ITEM_ID (FK)","NUMERIC(0,0)","NOT NULL"]},{"entry":[{},"CHANGE_ID","VARCHAR(8)","NOT NULL"]},{"entry":[{},"CHANGE_DT","DATE","NOT NULL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0499","num":"0498"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 55 D"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"DCS_STAGE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TRANSACTION_ID","VARCHAR(200)","NOT NULL"]},{"entry":[{},"PCID","VARCHAR(40)","NOT NULL"]},{"entry":[{},"PKGID","VARCHAR(40)","NOT NULL"]},{"entry":[{},"MEDIA_ID","VARCHAR(36)","NULL"]},{"entry":[{},"STATUS","NUMERIC(1,0)","NOT NULL"]},{"entry":[{},"CREATE_DT","DATE","NOT NULL"]},{"entry":[{},"KEY_REQUEST_DT","DATE","NOT NULL"]},{"entry":[{},"COMPLETE_DT","DATE","NOT NULL"]},{"entry":[{},"CHANGE_ID","VARCHAR(8)","NOT NULL"]},{"entry":[{},"CHANGE_DT","DATE","NOT NULL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Referring back to , block  provides that the DCS Order Management Server  generates a web page with a CKU client  instantiated with a transaction identifier. The connection  of the branded Web Page with CKU client Embedded is shown. Block  provides for the CKU client  obtaining the engine's  CKDRM certificate as shown by CKCMD_GET_CERTIFICATE command connection . Block  provides that engine  responds by passing CKU client  a CKDRM certificate, as shown connection . CKU client  sends the DFSCMD_GET_MEDIA_METADAT command to engine  to retrieve the unique media identifier. Block  provides that the CKU client  obtains the unique media identifier shown as connection . In one embodiment, if the obtaining the unique media identifier is not established, engine  obtains the identifier.","Following the obtainment of the unique media identifier, CKU client  sends an HTTP post , or a post according to another protocol appropriate for client server communication, to CKU server . As a result of the post, CKU server  instantiates a GetServerCert servlet , which runs function GetServerContentKeyCertificate ( )  including the CKU master , which in one embodiment is a Java class master, and retrieves the required string. CKU master  obtains the certificate requested from Crypto Library  with the GetServerContentKeyCertificate (function to the Crypto Library  via connection .","Block  provides for the CKU client  obtaining the server  content key certificate. As shown in , either a certificate or an error is sent back from the Crypto Library  to the CKU master  via connection  and . CKU client  requests an ESessionKey with the received certificate by the command in connection  CKCMD_AUTHENTICATE (server certificate) from the client  to the engine .","Block  provides for the CKU client  obtaining the ESessionKey from the engine  via  using the CKU server  CKDRM certificate, via connection .","Block  provides for the client  making a final unlock request for validating and\/or updating a table with the media identifier. In one embodiment, the table is a DCS_STAGE table. Further, block  provides for the client  requests authenticating the engine , obtaining the File Handle\/Key Complement\/Version list and wrapping the File Set. The CKU client , by connection , sends an HTTP Post to CKU server  of, for example: EsessionKey, Engine Certificate, Media ID and Transaction ID. The UnlockContent Servlet  within CKU server  connects via  using function UnlockContent (EsessionKey, Engine Certificate, Media ID, Transaction ID) to make the unlock request from CKU master . CKU master  accesses the DP Secure Database  and, by connection , sends the command P_KEY (Transaction ID, Media ID, Password, ResultSet Out). The DP Secure Database  responds via connection  with a ResultSet (File Handle-Key-Version) or an error. CKU master also requests the Wrap File Set via function WrapFileSet (ESessionKey, Engine Certificate, File Set String, Key Count, Media ID) by connection  to the Crypto Library .","Block  provides for CKU client  sending the wrapped file to engine  so the engine  can unlock the content. More particularly, Crypto Library  sends either the Wrapped File Set or an error via connection  to the CKU master . CKU Master  sends the transmission to the CKU server  by connection , and then from the CKU server  to the CKU client  by connection . CKU client  sends a command CKCMD_UNLOCK_FILES to the engine , via connection , with the wrapped file set. Engine  sends back to the CKU client  either a message of success, success with qualification, or failure by connection .","Block  provides that CKU client  sends a final transaction status message to CKU server  and displays a transaction complete (\u201cTrx Complete\u201d) message to a customer\/user. Specifically, CKU client  sends an HTTP Post: Transaction ID and Status Message  to CKU server .","Block  provides for the DCS Order Management Server  to receive the status complete notice, and delete the DCS_STAGE records for that transaction and update transaction. The UpdateStatus Servlet  responds to the post  by sending function UpdateStatus (Transaction ID and Status Message) by connection  to DCS Order Management Server . The UpdateStatus servlet  connects with the DP Secure Database  with the function Update SQL Statement(s) (Transaction ID, Status Message) .","Referring now to  in combination,  provides a flow diagram of an unlock transaction according to an embodiment, with  providing a block diagram of object interactions among components of the SEC system. Block  provides for reception of media containing locked content, for example, a disk being placed in a player or device coupled to a computer system, each of which is coupled to an engine . Block  provides that auto-run handler , or a Content Manager, requests a contents.ddl file. Referring to , the request is shown by engine  transmitting a signal to the Auto-Run Handler of the Disc Insert Event being fired shown as connection . The auto-run handler  sends a command  of DFSCMD_GET_FILE to engine . Engine  responds by sending a contents.ddl file as shown by .","Block  provides for auto-run handler  (or Content Manager) to parse the contents.ddl file to obtain one or more of a PackageCollectionID, PackageCollectionSKU, UnlockURL, Primary PackageSKU list and Business Entity ID, and a list of previously unlocked PackageSKUs. Auto-run handler  includes internal logic  that operates after the contents.ddl file is returned.","Block  provides that auto-run handler  or a Content Manager appends the data to a URL and open a default browser that will display a web page created by an eTailer . The choice of eTailer may be according to an embodiment described above.","Block  provides that the Etailer  presents user\/customer with a series of pages to process an eCommerce transaction. A User\/customer interacts with the eTailer's  \u201cshopping cart\u201d web pages .","Block  provides that after a user\/customer completes the transaction, for example, by clicking a button and prompting eTailer , thereby requesting eTailor to notify the DCS of the ContentKey Unlock Transaction. ETailor passes the DCS to the PCID, and a list of PackageSKU's that are to be unlocked as shown in the HTTP Post (PCID, Package List)  from the eTailor  to the DCS Order Management Server .","Block  provides that the DCS Order Management Component generates a unique transaction ID and insert one record for each package purchased. The command Insert SQL Statement(s) (Transaction ID, PCID, Package ID)  is transmitted from the DCS Order Management Server  to the DCS Order Management Database . At this point, the media identifier is not known, so it will contain a null value.","Block  provides that the DCS Order Management Server  replies to the eTailer  with a failure message or a URL . A user\/customer uses the URL to unlock content. The unlock URL contains the Transaction Identifier that was generated by the DCS Order Management Server .","Block  provides that the eTailor  generates a final confirmation and unlock instructions page that contains the Unlock URL .","Those skilled in the art will appreciate that embodiments disclosed herein may be implemented as software program instructions capable of being distributed as one or more program products, in a variety of forms including computer program products, and that the present invention applies equally regardless of the particular type of program storage media or signal bearing media used to actually carry out the distribution. Examples of program storage media and signal bearing media include recordable type media such as floppy disks, CD-ROM, and magnetic tape transmission type media such as digital and analog communications links, as well as other media storage and distribution systems.","Additionally, the foregoing detailed description has set forth various embodiments of the present invention via the use of block diagrams, flowcharts, and\/or examples. It will be understood by those skilled within the art that each block diagram component, flowchart step, and operations and\/or components illustrated by the use of examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or any combination thereof. The present invention may be implemented as those skilled in the art will recognize, in whole or in part, in standard Integrated Circuits, Application Specific Integrated Circuits (ASICs), as a computer program running on a general-purpose machine having appropriate hardware, such as one or more computers, as firmware, or as virtually any combination thereof and that designing the circuitry and\/or writing the code for the software or firmware would be well within the skill of one of ordinary skill in the art, in view of this disclosure.","Although particular embodiments of the present invention have been shown and described, it will be obvious to those skilled in the art that, based upon the teachings herein, changes and modifications may be made without departing from this invention and its broader aspects and, therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features and advantages made apparent to those skilled in the art by referencing the accompanying drawings. The use of the same reference number throughout the several figures designates a like or similar element.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 7E"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7F"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 7G"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 7H"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 7I","FIG. 7H"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 22A"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 22B"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 23A"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 23B"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 31A"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 31B"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 31C"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 41"}]},"DETDESC":[{},{}]}
