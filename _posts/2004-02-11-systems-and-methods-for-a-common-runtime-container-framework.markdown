---
title: Systems and methods for a common runtime container framework
abstract: An extensible container framework can be used to create and deploy software runtime containers. Such a framework can allow containers to inherit functionality and runtime environment attributes of other such containers. An extensible container framework can support multiple component types, and can provide the ability to add incremental features through a common component architecture. A framework can provide a common set of container infrastructure and services, and can expand the leverage of capabilities built around each container. This description is not intended to be a complete description of, or limit the scope of, the invention. Other features, aspects, and objects of the invention can be obtained from a review of the specification, the figures, and the claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444620&OS=07444620&RS=07444620
owner: BEA Systems, Inc.
number: 07444620
owner_city: San Jose
owner_country: US
publication_date: 20040211
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims priority from the following application, which is hereby incorporated by reference in its entirety:","U.S. Provisional Application No. 60\/451,012, entitled SYSTEMS AND METHODS FOR A COMMON RUNTIME CONTAINER FRAMEWORK, by Kyle Marvin, filed on Feb. 28, 2003.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document of the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention relates to software runtime containers and software frameworks.","The use of software containers provides several advantages when developing and deploying software applications. Containers provide software developers and users with a high level of abstraction. In other words, containers provide software functionality that can be neatly packaged and delivered while hiding significant implementation complexity. As an example, container packaging is often used to develop and deploy modular units of \u201cpluggable\u201d software functionality known as controls. In spite of these advantages, the design, construction, and deployment of containers at runtime have been a complex process, requiring software developers to have a large skill set.","The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.","While details of certain embodiments are discussed in this section, it should be clear that other suitable embodiments exist and can be used to achieve similar capabilities. Further, some of these embodiments may include additional functionality not discussed herein, and\/or may not contain all of the functionality described herein.","Systems and methods in accordance with embodiments of the present invention provide a complete framework useful in the design, construction, and deployment of software runtime containers, useful to both software developers and end users. Such a framework can allow runtime containers to inherit the functionality and runtime environment attributes of other containers. Having a single runtime container framework, which is extensible to support multiple component types, can provide benefits such as the following:\n\n","Services inherited from the use of a common runtime container framework can include, but is not limited to:\n\n","An overview of one exemplary framework for a common runtime container is shown in . Within this exemplary framework , the external routing and event handling services or components  can be used for communications of requests and responses with external client entities. These services or components can communicate with an invocation component  within the runtime container. In some embodiments, these services or components will use a uniform or standardized protocol to communicate with the container. The use of a uniform interface allows for the support of a large number of external interfaces without the need for explicit support for more than one type of interface.","Within the exemplary framework for a common runtime container, invocation component can receive requests and dispatch them to the correct interfaces of service components  inside the container . This dispatch process can be dependent on the nature of the request, the state information, and context information or other information stored in metadata . The metadata herein includes context, state, and\/or other information about the data and objects being processed upon the requests. The invocation component can route or manage the returned responses as required, based on the nature of the response, the state information, and context information or other information stored in the metadata.","The container can invoke the services provided by the components within the container to process requests and produce responses. The container can provide state information and context information to these components at runtime. If external services  are used during the processing, those services can be engaged through one or more interfaces provided by a control component . For embodiments using the Java programming language, the components can be created in the form of Java beans.","Within such a framework, the invocation component and the container can receive both state information and context information. The invocation component or the container can query the state manager  to retrieve state from nonvolatile storage . Likewise, the invocation component or the container can query the context manager  to receive context or other information from the metadata.","Services provided by the components in the common runtime container can perform either preprocessing or post-processing of requests and responses sent to or returned from the hosted components. For example, these processing services can include the processing of message protocols (e.g. SOAP), and request management (e.g. the tracking of session IDs or callback management). The preprocessing and post-processing of messages can be decoupled in that the preprocessing may not depend on post-processing and vice versa.","In some embodiments, common runtime containers are extensible via a hierarchical architecture, i.e., they can be created from a container class. The services of the runtime containers can be exposed through the methods of the container class. Contents of the containers can be accessed through the containers' interfaces. These common runtime containers can be sub-classed through an inheritance mechanism. Using inheritance mechanisms, developers can extend the functionality of common runtime containers. For example, methods and attributes can be inherited from one container to another and extended as required. These common runtime containers can be nested so that containers can inherit functionality and properties from other containers through several levels. Software components, typically supplied by the application developer or user, can be contained within or wrapped by the one or more runtime containers.","One possible example showing the inheritance structure of a set of runtime containers is shown in . In this example, a Web services container  inherits from the base container , and the workflow container  inherits from the Web services container. Other containers can follow arbitrary complex inheritance structures. In no case should this particular example imply a limitation on the scope, functionality or spirit of the invention.","At the same time, metadata, including context information used by the containers and components, is contained within one or more metadata objects. The metadata objects can also be subclassed through a hierarchical architecture. These objects can be nested so that metadata objects can inherit properties from other metadata objects. The metadata object is of a metadata class (the base class can be referred to Metadata ) and can have methods (metadata methods) and interfaces (metadata interfaces), that are generally used to get or set metadata values. In some embodiments, the root metadata object is a singleton.","One possible example showing an inheritance structure of a set of metadata object classes is shown in . In this example, a Web services metadata object  inherits from the base metadata object , and the workflow metadata object  inherits from the Web services metadata object. Other metadata object objects can follow arbitrary complex inheritance structures.","In some embodiments, metadata objects and containers are organized in a duality, wherein containers at one level in the hierarchical architecture can access metadata contained in the metadata objects at that same level in the hierarchical architecture. In other words, there can be a mapping between the metadata objects and the containers. This duality is illustrated in . The arrows connect the containers at each level to the metadata objects at the same level. In this example, a Web services container  inherits from the base container , and a Web services metadata object  inherits from the base metadata object . The workflow container  inherits from the Web services container, and the workflow metadata object  inherits from the Web services metadata object . This type of structure can be useful in cases where a workflow application is exposed as Web services, for example. It can be seen that the structure or hierarchy of the objects in this example follow that shown in .","In some embodiments, a well-defined Application Programming Interface (API) can be used to create more levels in the runtime container and metadata object hierarchies. Extensions to this API can allow developers to create new types of containers or customize existing containers with incremental features. In some embodiments, the API will be in the form of one or more public interfaces to the container class. As an example, a \u201cfactory pattern\u201d can be used to create other levels in the hierarchy of runtime containers or metadata objects. The created component types can be pluggable in some cases.","As has already been discussed herein, a common runtime container can provide invocation services using components contained therein. Such services can traverse several layers in the hierarchy of runtime containers. The invocation component can encompass both pre-invoke (for processing requests) and post invoke (for processing responses). As an example, some embodiments will use a process such as the following to pass control from one level to the next. Referring to the exemplary structure shown in , the following sequence of steps may occur:\n\n","An exemplary architecture that can be used with some embodiments for a common runtime container is shown in . In embodiments using the Java programming language, this architecture can be built in the J2EE runtime environment. Other architectures can be applied in alternative embodiments.","Starting at the left hand side of , one or more servlets - are used to manage communications between the common runtime container  and external entities such as clients. A servlet is a computer program (such as a Java Bean) that can run on a computer and provide certain kind of services. The servlet  is typically associated with a listener  that monitors incoming communications on the external interface of the servlet. Clients or other external entities can send requests and receive responses, using one or more protocols with servlets capable of processing those protocols. As an example only, communications with a servlet can include TCP\/IP, HTTP, SOAP, and perhaps application specific (e.g. an XML schema) protocols. Specific servlets can be created to support specific sets of protocols. In some embodiments, the servlets communicate with a dispatcher component  using a common or uniform protocol. Thus, the servlets can translate both requests and responses between wide varieties of \u201cwire\u201d protocols and common a communication protocol used by the dispatcher. In some embodiments, the servlets can use a proxy for this communication. Some exemplary protocols include JMS and CORBA messages, and clearly many more are possible. Not all protocols need to be transformed by the servlets. For example, an application specific protocol in the payload of a message may need to be passed unaltered to the application-specific components in the common runtime container. In some embodiments, the servlets can be stateless and synchronous. In some embodiments, the servlets can be modeled as top-level controls.","Still referring to , a first dispatcher  receives and processes requests sent from one or more servlets. In some cases, the dispatcher receives direct requests from other components within the same process space. The dispatcher will determine which components to invoke based on the contents of the request and information on context retrieved from metadata (Meta) . Requests requiring asynchronous processing are dispatched to the queue . Requests requiring synchronous processing can be routed directly to a stateful component (for stateful processing)  or a stateless component (for stateless processing) . A second dispatcher  receives the asynchronous requests dispatched to the queue . The dispatcher will determine which components to invoke based on the contents of the request and information on context retrieved from metadata . In some embodiments, the queue can follow a FIFO scheme, while some other embodiments can allow requests to be ordered by priority. This second dispatcher can dispatch requests requiring synchronous processing be routed directly to a stateful component (for stateful processing) or a stateless component (for stateless processing). In some embodiments using the Java programming language, the dispatcher can be in the form of an Enterprise Java Bean (EJB).","Still referring to , stateless processing can be performed by one or more stateless components. The stateless component  can derive context information (e.g. information related to the session) from the metadata . A stateless component can contain an arbitrary amount of code for the processing logic . In many cases this logic is application-specific. A stateless component can call other stateless components within the common runtime container as part of a processing chain. A stateless component can call one or more external services . In some embodiments, synchronous or asynchronous controls  associated with the component are used for communications with these external services. Other architectures can be used in other embodiments. In some embodiments using the Java programming language, these components can be constructed as Java Beans.","Still referring to , stateful processing can be performed by one or more stateless components. The stateful component  can derive context information (e.g. information related to the session) from metadata . State information is retrieved from nonvolatile storage  through a state management component . In some embodiments, the state information can be stored in the form of one or more Binary Large Objects (BLOBs). In other embodiments, the state information can be stored in relational tables in a Relational Database Management System (RDBMS). In yet other embodiments, both BLOBs and relational tables can be used. A stateful component can contain an arbitrary amount of code for the processing logic . In many cases this logic is application specific. A stateful component can call stateless components or other stateful components within the common runtime container as part of a processing chain. A stateful component can call one or more external services . In some embodiments, synchronous or asynchronous controls  associated with the component are used for communications with these external services. Other architectures can be used in other embodiments. In some embodiments using the Java programming language, these components can be constructed as Java Beans.","In some embodiments, the following process can be used to generate and use the common runtime container and other associated software. User supplied source code can be compiled in the usual manner with a suitable complier. The automatic code generation and class assembly for the container, servlets, components and controls can be performed at load time. In some cases, metadata or deployment descriptors created by the developer or system administrator are used to guide the automatic code generation and assembly process. In some embodiments, the runtime environment may perform configuration verification at runtime to prevent problems with configuration mismatch to runtime environment. When a new session is initiated, an instance of the containers and associated components and controls are generated. Processing for this session is then carried out as has already been described for the duration of the session. When the session completes, the containers and their contents are destroyed and the process space and system resources are reclaimed.","In some embodiments of the present invention, the invocation component in a common runtime container framework can be event-driven. Event delivery (calls in from a primary client or callbacks from controls) to a component as well as event generation (callbacks to a primary client or calls into controls) from a component can be synchronous or asynchronous. This invocation component can include synchronous and asynchronous capabilities such as the following:\n\n","In some embodiments of the present invention, the runtime container in a common runtime container framework can define simplified component abstractions that are transparently mapped (perhaps through code generation and assembly) to a more complex set of runtime environment components to create and deploy applications. For example, in some Java enterprise application environments, the runtime environment components are associated with the J2EE platform which hosts the Java beans comprising the application. This runtime container to generate and deploy application services can include capabilities such as the following:\n\n","In some embodiments of the present invention, the runtime container in a common runtime container framework can expose a common configuration model for how components and control attributes are specified declaratively and programmatically by the developer, as well as providing a common model for declarative configuration override at application deployment time. A common configuration model provided by the runtime container can include capabilities such as the following:\n\n","In some embodiments of the present invention, the state manager in a common runtime container framework can provide the ability to develop stateful components where the physical mechanisms used to locate, manage, and persist state are largely transparent to the developer. This state manager can include capabilities such as the following:\n\n","In some embodiments of the present invention, the context manager in a common runtime container framework can expose component-level services and events to the programmer. This context manager can include capabilities such as the following:\n\n","In some embodiments of the present invention, the control component in a common runtime container framework can support the concept of controls to provide a simplified and common interaction model for how a programmer interacts with external subsystems. This control component can include capabilities such as the following:\n\n","One embodiment may be implemented using a conventional general purpose or a specialized digital computer or microprocessor(s) programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.","One embodiment includes a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a computer to perform any of the features presented herein. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, micro drive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and\/or data.","Stored on any one of the computer readable medium (media), the present invention includes software for controlling both the hardware of the general purpose\/specialized computer or microprocessor, and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include, but is not limited to, device drivers, operating systems, execution environments\/containers, and applications.","The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Particularly, while the concept \u201ccomponent\u201d is used in the embodiments of the systems and methods described above, it will be evident that such concept can be interchangeably used with equivalent concepts such as, service, event, control, class, object, bean, and other suitable concepts. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention, the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
