---
title: Reuse of rounder for fixed conversion of log instructions
abstract: A method for converting a signed fixed point number into a floating point number that includes reading an input number corresponding to a signed fixed point number to be converted, determining whether the input number is less than zero, setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero, computing a first intermediate result by exclusive-ORing the input number with the sign bit, computing leading zeros of the first intermediate result, padding the first intermediate result based upon the sign bit, computing a second intermediate result by shifting the padded first intermediate result to the left by the leading zeros, computing an exponent portion and a fraction portion, conditionally incrementing the fraction portion based on the sign bit, correcting the exponent portion and the fraction portion if the incremented fraction portion overflows, and returning the floating point number.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08626807&OS=08626807&RS=08626807
owner: International Business Machines Corporation
number: 08626807
owner_city: Armonk
owner_country: US
publication_date: 20090108
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT OF GOVERNMENT INTEREST","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention was made with Government support under Contract No. HR0011-07-9-0002 awarded by DARPA. The Government has certain rights in this invention.","The present invention relates to floating point units (FPUs), and more specifically, to the reuse of the normalizer and rounder of the FPU for conversion from a fixed point format to a floating point data format which enables the execution of the log estimate in a single loop through a fused-multiply-add (FMA) data path and thereby improves the latency of log estimate instructions executed on the FPU within the FMA data path.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":["FIG. 1","FIG. 1","FIG. 2","FIG. 2","FIG. 1","FIG. 1"],"b":["10","10","15","20","25","30","35","2","4","12","14","14","100","100","105","15","105","115","115","120","25","110","120","125","25"],"sup":"e\u2032","sub":["L","L "]},"At operation , the output of the adder  is padded with zeros. Then at operation , in the normalizer  (depicted in ), the result is shifted to the left by the number of leading zeros counted. From operation , the process moves to operation , where in the rounder  (depicted in ), the exponent and fraction are calculated and the floating point number including the sign bit, the exponent, and the fraction is returned at operation . There are several disadvantages regarding the conventional data flow . For example, the implementation of log estimate instructions in the conventional data flow  reuses the entire data flow for converting from a fixed format to a floating point format. Therefore, resulting in a 10-cycle latency as shown in .","According to an embodiment of the present invention, methods for converting a signed fixed point number into a floating point number and computer program product for performing the method are provided. The methods utilize the normalizer and the rounder unit in the FPU.","According to one embodiment, a method for converting a signed fixed point number into a floating point number is provided. The method includes reading an input number corresponding to a signed fixed point number to be converted into a floating point number, determining whether the input number is less than zero, setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero, computing a first intermediate result by exclusive-ORing the input number with the sign bit, computing a number of leading zeros of the first intermediate result, padding the first intermediate result with ones or zeros based upon the sign bit, computing a second intermediate result by shifting the padded first intermediate result to the left by a number based on the number of leading zeros, computing an exponent portion using the number of leading zeros, computing a fraction portion using the second intermediate result, conditionally incrementing the fraction portion based on the sign bit, correcting the exponent portion and the fraction portion if the incremented fraction portion overflows, and returning, the floating point number including the sign bit, and the exponent portion and fraction portion.","According to another embodiment of the present invention, a computer program product comprising a computer useable medium including a computer readable program, wherein the computer readable program when executed on a computer causes the computer to implement a method for converting a signed fixed point number into a floating point number is provided. The method includes reading an input number corresponding to a signed fixed point number to be converted into a floating point number, determining whether the input number is less than zero, setting a sign bit based upon whether the input number is less than zero or greater than or equal to zero, computing a first intermediate result by exclusive-ORing the input number with the sign bit, computing a number of leading zeros of the first intermediate result, padding the first intermediate result with ones or zeros based upon the sign bit, computing a second intermediate result by shifting the padded first intermediate result to the left by a number based on the number of leading zeros, computing an exponent portion using the number of leading zeros, computing a fraction portion using the second intermediate result, conditionally incrementing the fraction portion based on the sign bit, correcting the exponent portion and the fraction portion if the incremented fraction portion overflows, and returning, the floating point number including the sign bit, and the exponent portion and fraction portion.","Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with the advantages and the features, refer to the description and to the drawings.","With reference now to , there is a floating point unit (FPU)  of a processor according to an embodiment of the present invention. The dataflow of the FPU  may operate according to a fused multiply-add (FMA) data flow, for example, where (\u201cR=C+A*B\u201d), where \u201cA\u201d is the multiplicand, \u201cB\u201d is the multiplier, \u201cC\u201d is the addend, and \u201cR\u201d is the result. The dataflow includes an aligner , a multiplier , an adder , a normalizer  and a rounder . In the dataflow, the addend is aligned by the aligner  prior to being combined with the product of the multiplier  at the adder . The result of the adder  is normalized via the normalizer  and the normalized result is then rounded into the instruction specific format via the rounder .","According to an embodiment of the present invention, a system for converting a signed fixed point number into a floating point number within the FPU  of a processor is provided. The system includes a preparation circuit, the normalizer  and the rounder . The preparation circuit reads an input number corresponding to a signed fixed point number to be converted into a floating point number. An estimate normalize block  and a table lookup  are also provided. The preparation circuit may be included in the table lookup . The standard data flow for log estimate instructions includes normalizing the input operand, if necessary at block , and computing a log estimate using the table lookup , along a single loop indicated by reference numeral . The loop  then continues to the normalizer  and the rounder  for performance of the conversion from a fixed format to a floating point format as discussed below with reference to . Therefore, the result is a 6-cycle latency.","According to embodiments of the present invention, a floating point number format includes a single sign bit \u201cs\u201d, an exponent \u201ce\u201d that includes multiple bits, and a significand that includes a single integer bit \u201ci\u201d and a fraction part \u201cf\u201d that includes multiple bits. All the bits within the floating point number are binary integer value bits (i.e., either a binary logic \u201c0\u201d or \u201c1\u201d). The value for the floating point number is (\u22121)*2*i.f, normalizing converts this number to the unique number with sign bit s, exponent e\u2032, fraction f\u2032, and an integer bit with value \u201c1\u201d. The log function is defined as log (2*1.f)=log(2)+log(1.f\u2032)=e\u2032+log(1.f\u2032). The number e+log(1.f) is called the intermediate significand with integer part e\u2032 and fraction part log(1.f).",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 3"],"b":["400","405","410","405","415","410","415","420","400","420","314"]},"From operation , the process moves to operation  where it is determined whether the input number n is less than zero or greater than or equal to zero. If it is determined that the input number n is greater than or equal to zero, the process moves to operation  where the result of the table lookup  (\u201cn\u201d) (i.e., a first intermediate result) is padded with zeros on a least significant bit side. From operation , the process moves to operation  where a second intermediate result is computed by normalizing the first intermediate result by shifting the results (\u201cn\u201d) (i.e., the padded first intermediate result) to the left by a number equal to the number of leading zeros counted. According to an embodiment of the present invention, operations  through  are performed via the normalizer  of the floating-point fused multiply-add computation (depicted in ). Further shown in , \u201cp\u201d represents the number of fraction bits and \u201cbias\u201d denotes the exponent bias of the precision of the floating point number.","From operation , the process moves to operation  where the sign bit s is set to zero and the exponent e and the fraction part f are computed and from operation , the process moves to operation  where the floating point number including the sign bit s, exponent e and the fraction f are returned. According to an embodiment of the present invention, operations  and  are performed in the rounder  of the floating-point fused multiply-add computation (depicted in ).","If it is determined at operation , that n is less than zero, the process moves to operation  where the result of the table lookup (\u201cn\u201d) (i.e., the first intermediate result) is padded with ones on a least significant bit side. From operation , the process moves to operation , where the result (\u201cn\u201d) (i.e. the padded first intermediate result) is then shifted to the left by a number equal to the number of leading zeros counted. According to an embodiment of the present invention, operations  and  are performed at the normalizer .","From operation , the process moves to operation  where it is determined whether the fraction f is equal to all ones. If it is determined that the fraction f is not equal to all ones, the process moves to operation  where the sign bit is set to one, the exponent e is computed and the fraction f is incremented by adding a \u201c1\u201d to the LSB. On the other hand, if it is determined in operation  that the fraction f is equal to all ones, then the process moves to operation  where the sign bit s is set to one and the exponent e and the fraction f are corrected by incrementing the exponent e and setting the fraction f to all zeros. As can be seen in , according to an embodiment of the present invention, the fraction f is conditionally incremented based on the sign bit. That is, the fraction f is incremented if the sign bit is set to one (operation ) and the fraction is not incremented if the sign bit is set to zero (operation ). From operation , the process moves to operation  where the floating point number including the sign bit s, exponent e and the fraction f is returned. According to an embodiment of the present invention, operations  through  are performed in the rounder .","The following is an example of a conversion from a fixed format to a floating point format. In the following example, the input number is \u221218.625=11101101.01100000 at operation . Since \u221218.625 is less than zero, the process moves to operation  where the input number is inverted to 00010010.10011111. From operation , the process moves to operation , where the leading zeros are counted. For this example, the leading zeros counted equals 3. From operation , the process moves to operation , where it is determined whether the input number is less than zero. Since the input number (00010010.10011111) is less than zero, at operation , the inverted input number is padded with ones to 00010010.1001111111111111111. From operation , the process moves to operation  where the result is shifted to the left by the number of zeros to 1.00101001111111111111111. From operation , the process moves to operation  where it is determined whether the fraction equals all ones. In this example, the fraction does not equal all ones, therefore the process moves to operation  where the sign bit is set to 1 and the exponent is computed and the fraction is incremented by 1 resulting in 1.0010101000000. From operation , the process moves to operation  where the floating point number is returned, for this example, the floating point number equals \u22121*2*1.0010101=\u221216*1.1640625=\u221218.625.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5","FIG. 5","FIG. 3"],"b":["330","335"]},"At operation , the two's complement input number n is read. From operation , the process moves to operation  where it is determined whether the input number n is less than zero or greater than or equal to zero. If it is determined in operation  that the input number n is greater than or equal to zero, the process moves to operation  where the signed bit is set to zero and the rounding mode is set to round-to-zero according to the IEEE 754 standard for floating point numbers. If it is determined in operation , that the input number n is less than zero, the process moves to operation  where the signed bit is set to one and the rounding mode is set to round-nearest-even according to the IEEE 754 standard. The standard rounding mode is well known in the art. According to an embodiment of the present invention, operations  through  are performed via the table lookup  (depicted in ).","From operations  and , the process moves to operation , where the signed fixed point number (\u201cn\u201d) is logically exclusively-ORed with the sign bit giving a first intermediate result. From operation , the process moves to operation  where the leading zeros (lz) of the first intermediate result is computed. Operations  and  are also performed via the table lookup . Thus, as mentioned above, the setting of the sign bit, the exclusive-ORing of the input number, the computing of the leading zeros and the padding of ones or zeros are performed as a part of a table lookup for the logarithm estimate.","From operation , the process moves to operation , where the first intermediate result is padded with ones or zeros on a least significant bit side based upon the sign bit. Then in operation , a second intermediate result is computed by shifting the padded first intermediate result to the left by a number based on the number of leading zeros. According to one embodiment, the operations  and  are performed via the normalizer  within the floating-point fused multiply-add computation, for example. The normalizer  is configured to perform a desired function by setting the normalizer  to a default normalization function as used in a computation of a fused multiply-add instruction. Further shown in , \u201cp\u201d represents the number of fraction bits and \u201cbias\u201d denotes the exponent bias of the precision of the floating point number.","From operation , the process moves to operation , where the sign bit s, the exponent e, and the fraction f are calculated by rounding the result of the normalizer , via the rounder  in the floating-point fused multiply-add computation. The rounder  is configured to performed a desired function by setting the rounder  to a default rounding function as used in the computation of a fused multiply-add instruction and applying an appropriate rounding mode. Further, according to an embodiment of the present invention, the exponent e is computed using the number of leading zeros and the fraction f is computed using the second intermediate result. From operation , the process moves to operation  where the floating point number is returned including the sign bit s, the exponent e, and the fraction f calculated.","According to one embodiment of the present invention, the method of converting from a fixed point to a floating point format is used for the log2 estimate instruction in the FPU. However, the present invention is not limited hereto, and may vary as necessary.","Embodiments of the present invention reuse the normalizer and the rounder. Therefore, it is possible to implement the log instruction in a fully pipelined way with the same latency as a FMA instruction. In addition, the present invention also eliminates the need for extra hardware in the pipeline, to manage the additional loop through the pipeline.","For the sake of description,  assume that the number of leading zeros (lz) computed in steps  and  is exact. However, a state-of-the-art rounder supports a number of leading zeros that is off by one. Such a rounder determines whether the number of leading zeros is either correct or off by one based on the most significant bit of the second intermediate result. It corrects the second intermediate result and the number of leading zeros prior to the computing of the exponent e and the fraction f, i.e., directly after the steps , , and . The correction of the second intermediate result includes adding or subtracting one to or from the number of leading zeros and shifting the second intermediate result by one.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising,\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one ore more other features, integers, steps, operations, element components, and\/or groups thereof.","The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated","The flow diagrams depicted herein are just one example. There may be many variations to this diagram or the steps (or operations) described therein without departing from the spirit of the invention. For instance, the steps may be performed in a differing order or steps may be added, deleted or modified. All of these variations are considered a part of the claimed invention.","While the preferred embodiment to the invention had been described, it will be understood that those skilled in the art, both now and in the future, may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The subject matter which is regarded as the invention is particularly pointed out and distinctly claimed in the claims at the conclusion of the specification. The forgoing and other features, and advantages of the invention are apparent from the following detailed description taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
