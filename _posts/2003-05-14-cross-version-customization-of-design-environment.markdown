---
title: Cross version customization of design environment
abstract: A client or Web application assembly or group of assemblies is bound to a version of shared assemblies associated with a particular targeted execution environment. The targeted execution environment (and thus the version of shared assemblies associated with it) may be selected or detected. A file such as a configuration file is automatically modified. The selected or detected execution environment may be the same as or different than the local version. The client or Web assembly is automatically bound to the targeted shared assemblies. A user interface enables the selection of a particular execution environment. Alternatively, a user interface informs of the detected targeted execution environment and enables the reconfiguration of the Web assembly. This invention provides a mechanism and process for maintaining legacy software after a new software development tool is installed, without deploying a new version of shared assemblies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694277&OS=07694277&RS=07694277
owner: Microsoft Corporation
number: 07694277
owner_city: Redmond
owner_country: US
publication_date: 20030514
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["The invention relates to software development and in particular to binding an application to a selected version of a set of shared assemblies.","In the early days of programming, each application typically was self-contained. A simple application program might comprise a single executable file (frequently denoted by the extension \u201c.exe\u201d), while a complex application might comprise several executables chained together. Because the executables comprising a particular application could be used only by that application, the likelihood that applications would interfere with each other was remote.","Over the years, however, the size of application files grew dramatically, encouraging the sharing of code modules by applications via dynamic linking. For example, the code modules containing the functions that make an operating system work may be shared by all the applications written to run on that operating system. A file comprising a code module that can be shared in this way is sometimes called an assembly or dynamic link library and may have the extension \u201c.dll\u201d.","Initially, file-sharing was not a problem. Most applications only used the dlls provided with the operating system or else used private (unshared).dlls. As operating systems evolved, additional dynamic link libraries were often created, some designed to be shared among the applications developed by the operating system vendor, and others designed to be used by all developers creating applications designed to run on the operating system. Typically, these dynamic link libraries contain groups of functions that provide a standard functionality, eliminating the need for each application to implement that functionality independently.","Initially, an application that used a particular .dll might require a separate distribution of the library containing the .dll if the .dll was not included with the operating system. Software development companies frequently update the .dlls accompanying an updated version of their operating system or application to fix bugs or to add new functionality. If a new version of a .dll appeared, even if the new .dll was used in all new builds of a product, at least some of the previous distribution disks would be likely to have an older version of the .dll. Hence, frequently an individual might own several programs each using a particular dll, each program having a different version of the .dll on its distribution disks. This state of affairs can be problematic.","For example, a user may have software that uses one version of a .dll and then install software that uses a newer version of the same .dll which does not work with the first software package. Similarly, users often reinstall software\u2014either during a system upgrade or to change configurations. In many cases a user would install software that included an older version of a particular .dll on a system that already contained a newer version. This would cause the more recently installed version of the .dll to replace the newer version of the .dll. As soon as the user attempted to run a program that required the newer version, problems might occur ranging from operational difficulties to general protection faults.","In \u201cComponent-Solution\u201d programming, programmers take advantage of reusable, cost-effective \u201coff the shelf\u201d software components that implement specific functions. \u201cOff the shelf\u201d software components may comprise classes, custom controls and other application programming interfaces (APIs). Use of the component-solution framework for programming has resulted in the generation of hundreds of dlls that may be shared by literally thousands of applications.","If a single .dll is missing from, present in an older version in, or present in an incompatible newer version in the library of shared assemblies installed on a computing device, an application may fail. A poorly designed installation program, user error, registration error or a change in the user's PATH environment variables are a few of the ways in which this problem can occur. This suite of problems has been collectively referred to as \u201cDll Hell\u201d. Dll Hell is a problem of ongoing maintenance as well as an installation problem.","One approach to solving the problem of Dll Hell is to bind an application to a particular instance of its associated .dll. In this scenario, when a user installs a first program, a first .dll will be stored with the first program. If the user installs a second program using a different version of the same .dll, the old version of the .dll will remain and the new version of the .dll will be installed with the second program. Hence, installing a new application will have no impact on the operation of the old application. One way to accomplish this outcome is to associate a version number with each .dll. When an application is built, it is bound (typically at compile time) to a version of the dlls associated with the software that generates the executable. A consequence of this approach is that a deployed application program executable generated from a specific version of the software development software, has to have the specific version of the shared assemblies associated with that version of the software development software in order to run.","Now suppose someone has developed, for example, a collection of programs using a design time development environment version 1 which is associated with shared assemblies version 1. Suppose further that subsequently, someone installs a new version, version 2, of the design time development environment which is associated with a new version of the shared assemblies, shared assemblies version 2. Suppose the collection of programs developed using design time development environment version 1 is deployed to a number of desktops. Suppose further that a developer decides to fix a bug in one of the programs using design time environment version 2. The mere act of fixing a bug in one of the programs after installation of version 2 of the design time development environment will force an upgrade of the shared assemblies to version 2 of the shared assemblies on all the desktops running the collection of programs, because when the modified program is recompiled, it will be bound to version 2 of the shared assemblies. One can readily see the magnitude of the problem created if one considers that a particular application may be deployed to hundreds or thousands of desktops. It would be helpful, if there were a way to maintain older applications without having to upgrade the shared assemblies with which the older software is run, while still enabling an upgrade to a new version of a software development tool.","A client or Web application assembly or group of assemblies may be bound to a version of shared assemblies associated with a particular targeted execution environment. The targeted execution environment (and thus the version of shared assemblies associated with it) may be selected or detected. The selected or detected execution environment may be the same as or different than the local version. The client or Web executable is automatically bound to the targeted shared assemblies. A user interface enables the selection of a particular execution environment. Alternatively, for a Web application, a user interface informs of the detected targeted execution environment and enables the reconfiguration of the Web application assembly. This invention provides a mechanism and process for maintaining legacy software after a new software design environment or development tool is installed, without requiring new assemblies with to be deployed with the legacy application.","Overview","A user interface enables the selection of a execution environment associated with a version of shared assemblies to which a client application will be bound at runtime, so that existing software modified after a new or upgraded software design environment or development tool has been installed does not force the upgrade of the shared assemblies to the new version in order for the modified software to run. In one embodiment, a rebinding is performed automatically to the desired set of shared assemblies, not to each individual assembly, eliminating the need to create a plurality of binding redirect statements. A binding redirect statement overrides the binding of an assembly to an application so that instead of the application being bound to one assembly, the application is bound to another.","New software can be developed under a new (e.g., upgraded) software design environment or development tool while enabling the maintenance of existing software that uses the previously installed version of shared assemblies. The version of execution environment on which the software is desired to run (the targeted execution environment) and thus the version of shared assemblies to be bound to the application assembly, may be selected via a user interface. In one embodiment of the invention, an application configuration file is used to store the information which determines which version of shared assemblies will be bound to the application assembly. A configuration file, as used herein, is a system or application file which holds software settings that enable a particular computer to be set up or configured in a particular way. In one embodiment the information that determines which version of shared assemblies are bound to the application assembly are one or more binding redirect statements. Alternatively, the information that determines which version of shared assemblies are bound to the application assembly may be XML tags or a combination of XML tags and binding redirect statements. Multiple sections containing binding redirect statements for multiple execution environments may exist in the file.","In the case of a Web application, the execution environment determining the version of shared assemblies installed on the targeted Web server may be dynamically detected. A user may be prevented from binding the application to a set of shared assemblies that is not installed on the targeted Web server.","One or more execution environments may be selected or targeted. An application bound to a particular version of shared assemblies may be prevented from installing onto a computing device that lacks that version of shared assemblies. One copy of source code can be used to generate one or more versions of configuration files for the same application assembly. In one embodiment of the invention, the configuration file determines which set or sets of shared assemblies are bound to the application assembly.","A user interface enables a user to select one or more execution environments and thus versions of shared assemblies with which one or more application assemblies will be bound.","Exemplary Computing Environment",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers, or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation, illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only, illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory . GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  a illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a stand alone computing device, having programming language functionality, interpretation and execution capabilities.","System and Method for Binding Executables to a Selected or Detected Execution Environment Associated with a Particular Version of Shared assemblies",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"i":["a ","a ","a ","a ","a "],"b":["206","1","204","1","1","202","204","222","204","220","200","220","220","1","201","202","200","1","201","202","200","204","204","202","204","202","201","208"]},"Referring now to , suppose that a new software design environment or development tool, such as but not limited to IDE version 2 , is installed on computer . IDE version 2  may be installed side-by-side with IDE version 1 , as shown in or may replace IDE version 1 . IDE version 2  in accordance with one embodiment of the invention, may, by default, be associated with shared assemblies version 2  and execution environment  . Thus source code  if opened by IDE version 2  may produce an application assembly that is, by default, bound with shared assemblies version 2 , generating application assembly version 2 bound to shared assemblies version 2  (represented in by \u201cAPP VER \u201d, reference numeral ). Shared assemblies version 2  may represent a shared assembly or a library of shared assemblies with which IDE version 2  by default binds application assembly version 2  at compile time.","In accordance with one embodiment of the invention, however, the application assembly generated from source code  may be bound with shared assemblies version 1  or the application assembly generated from source code  may be bound with shared assemblies version 2  or the application assembly generated from source code  may be bound with both versions of shared assemblies ( and ), as discussed in more detail below.","A system or other suitable file, such as a configuration file, (e.g., configuration file version 1  or configuration file version 2 , etc.), may be accessed by IDE version 2  to determine the version of shared assemblies to be bound to the application assembly to be generated. In one embodiment of the invention, the configuration file (e.g., configuration file version 1  or configuration file version 2 , etc.) is an XML file. The configuration file may be an application or a Web configuration file. Installed execution environment datastore  in one embodiment of the invention includes information used to create or modify the configuration file (configuration file version 1  or configuration file version 2 , etc.) and may be a file or database.","It will be understood by one skilled in the art that although the example depicted in and illustrate an existing piece of source code  which is modified or at least opened in IDE version 2 , the system thus described is equally applicable to source code which is newly written (using for example, a \u201ccreate\u201d option), or copied from another source.","IDE version 2  may represent a new version of IDE version 1  or may represent a new software development environment, tool, compiler or the like. In one embodiment of the invention, IDE version 1  represents MICROSOFT VISUAL STUDIO .NET 2002, IDE version 2  represents MICROSOFT VISUAL STUDIO NET 2003, execution environment   represents MICROSOFT .NET COMMON LANGUAGE RUNTIME 1.0, execution environment   represents MICROSOFT .NET COMMON LANGUAGE RUNTIME 1.1, shared assemblies version 1 represents the shared assemblies associated with VISUAL STUDIO NET 2002 and COMMON LANGUAGE RUNTIME 1.0: .NET FRAMEWORK 1.0 and shared assemblies version 2 represents the shared assemblies associated with VISUAL STUDIO .NET 2003 and .NET COMMON LANGUAGE RUNTIME 1.1: NET FRAMEWORK 1.1, however, as described above, it will be understood that the invention is not so limited. IDE versions 1 and 2 may equally represent, for example, DREAMWEAVER by MACROMEDIA or BORLAND C++ BUILDER STUDIO, execution environments 1 and 2 may represent, for example, JAVA or other execution environments, and shared assemblies versions 1 and 2 may represent, for example, the libraries associated with DREAMWEAVER by MACROMEDIA or BORLAND C++ BUILDER STUDIO and the like. In one embodiment of the invention, the shared assemblies exist in a device-independent intermediate language, which may comprise interpreted binary code. Alternatively, the shared assemblies may exist in a native (device-specific) binary code. The shared assemblies may be referred to as assemblies or executables and may include code modules such as classes, custom controls and the like, representing functionalities and so on that may be useful in the development of applications.","Application assembly version 2  may be loaded onto a computer such as exemplary computer  (e.g., a user computer) and run. Computer  may already have shared assemblies version 1  loaded onto it or shared assemblies version 1  may be loaded concurrently with application assembly version 2 . Computer  may already have execution environment   loaded onto it or execution environment   may be loaded concurrently with application assembly version 2 .","Similarly application assembly version 2  may be loaded onto a computer such as computer  (e.g., a user computer) and run. Computer  may already have shared assemblies version 2  loaded onto it or shared assemblies version 2  may be loaded concurrently with application assembly version 2 . Computer  may already have execution environment   loaded onto it or execution environment   may be loaded concurrently with application assembly version 2 .","Computer  and\/or computer  may be a client or may be a Web server hosting an application for one or more clients (not shown) or may be any other type of server capable of running an execution environment as discussed above, such as a SQL server or any of the commonly known servers typically found in a business, home or office setting.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 3","b":"350"},"At step , if the application is a Web application, the version of the execution environment running on the Web server may be detected. The version of the execution environment of the Web server may be detected from Web page header information or may be deduced from one or more attributes known to be associated with a particular version of the execution environment.","At step , in one embodiment of the invention, a user interface may be initialized according to settings stored in the configuration file. To initialize the interface, the application configuration file (for client projects) or Web configuration file (for Web projects) or other suitable file may be examined. If no application configuration file exists or there is no entry for the supported execution environments, a default option may be selected. In the exemplary user interface of , the MICROSOFT NET FRAMEWORK v1.1 radio button is checked in this case.","At step , the initialized user interface such as a dialog box or other suitable user interface is displayed. For a Web application, if the version of the execution environment running on the Web server is execution environment version 1, a user interface such as the one illustrated in may be displayed. The exemplary user interface illustrated in provides an option to stop to allow the Web server to be upgraded to a higher version or to build the application using the shared assemblies version 1 associated with execution environment version 1. If the upgrade option is not chosen, and the version of the execution environment detected on the targeted Web server is version 1, the application will be bound to the version 1 shared assemblies. If the version of the execution environment detected on the targeted Web server is version 2, the application will be bound to the version 2 shared assemblies.","For a client application, in one embodiment of the invention, the user interface provides a series of options such as radio buttons, check boxes or other suitable means for displaying options and accepting at least one selection. An exemplary screen shot is illustrated in for a client application, in which an explanatory message is displayed followed by the following radio buttons:\n\n","It will be understood that although the exemplary interface displays three options, the invention as contemplated is not so limited: any suitable number of options and supported execution environments may be displayed and selected. Furthermore, the options displayed may be dynamically determined from a database or file containing the versions of execution environments that can be targeted. For example a file (e.g., InstalledRuntimes.xml) including a list of execution environments that can be targeted may be loaded, each installed execution environment element may be examined, and for each element the function may retrieve information such as but not limited to the version number of the execution environment and the friendly name of the execution environment. This information may be returned and displayed in the dialog box.","At step , if an existing application configuration file was found, any existing binding redirect statements may be removed. For each version of the execution environment being targeted, each binding redirect that represents a component that is found in the installed execution environment database is removed. Any elements not found in the installed execution environments database are assumed to have been manually added and thus are not removed.","At step , the selected version of the framework is examined. In one embodiment of the invention, a parameter in a set configuration execution environment bindings function called by the dialog box is passed. In the exemplary user interface of , if MICROSOFT .NET Framework v1.0 (advanced) is selected, 1.0 will be passed, if MICROSOFT .NET Framework v1.1 (default) is selected, 1.1 will be passed and if Both Microsoft .NET Framework v1.1 and v1.0 (advanced) is selected, both 1.0 and 1.1 will be passed.","At step  the application configuration file is modified in accordance with the option selected. The configuration file in one embodiment of the invention is an XML file that travels with the client application. The configuration file may be used to specify aspects of the application, including assembly rebindings and may include one or more binding redirect statements. A binding redirect statement may comprise one or more statements having the following general format or other suitable format:\n\n","In one embodiment of the invention, one or more files or datastores (e.g., the installed execution environments database) are maintained to keep track of what version numbers are associated with the old version of shared assemblies, the version of the shared assemblies to be rebound to, the version numbers associated with the various execution environments, and the different binding possibilities. The binding redirect statements placed in the configuration file thus may be data-driven, by accessing and modifying a separate file or datastore. In one embodiment of the invention the datastore is an XML file. The above functionality may be provided as a service, enabling third party plug-ins to have access to the same information.","For each version of the execution environment being targeted, the installed execution environments datastore may be examined to see if the datastore has any binding redirects for the version of the execution environment being targeted. If any binding redirect statements are present, the binding redirect statements may be inserted into the application configuration or Web configuration file. In one embodiment of the invention, required execution environment and supported execution environment tags are modified or inserted into the application configuration file even if no binding redirect statements are present in the installed execution environments datastore for the version of the execution environment being targeted. If no application configuration file is present, an appropriate application configuration file may be added to the application project.","Thus, to determine the appropriate binding redirect statements to be inserted into the configuration file, in one embodiment of the invention, the installed execution environments datastore is loaded. In one embodiment of the invention, the installed execution environment file is an XML file comprising a number of sections, one section for each installed version of shared assemblies. The section of the installed execution environments datastore corresponding to the selected version of shared assemblies to be bound to the executable is found. The section corresponding to the version of shared assemblies may include a list of these binding redirect statements. The binding redirect statements may be rewritten verbatim to the application configuration file or may undergo a syntactical transformation before being written to the application configuration file.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4","i":"b "}]},"DETDESC":[{},{}]}
