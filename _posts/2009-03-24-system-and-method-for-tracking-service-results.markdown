---
title: System and method for tracking service results
abstract: Various embodiments of a system and method for tracking service requests are described. Embodiments may include call tree generation logic configured to receive multiple request identifiers associated with a respective one of multiple service requests. Each given request identifier may include an origin identifier, a depth value, and a request stack comprising one or more interaction identifiers. The call tree generation logic may also be configured to, based on multiple request identifiers that each include an origin identifier associated with a particular root request, generating a data structure that specifies a hierarchy of services called to fulfill that particular root request. Based on one or more of the interaction identifiers and one or more of the depth values, the generated data structure may specify for each given service of the hierarchy: a parent service that called the given service, and one or more child services called by the given service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09391825&OS=09391825&RS=09391825
owner: Amazon Technologies, Inc.
number: 09391825
owner_city: Reno
owner_country: US
publication_date: 20090324
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION OF EMBODIMENTS","Introduction"],"p":["The Internet, sometimes called simply \u201cthe Net,\u201d is a worldwide system of computer networks in which a client at any one computer may, with permission, obtain information from any other computer. The most widely used part of the Internet is the World Wide Web, often abbreviated \u201cWWW,\u201d which is commonly referred to as \u201cthe web.\u201d The web may be defined as all the resources (e.g., web pages and web sites) and users on the Internet that use the Hypertext Transfer Protocol (HTTP) or variations thereof to access the resources. A web site is a related collection of web files that includes a beginning file called a home page. From the home page, the user may navigate to other web pages on the web site. A web server program is a program that, using the client\/server model and HTTP, serves the files that form the web pages of a web site to the web users, whose computers contain HTTP client programs (e.g., web browsers) that forward requests and display responses. A web server program may host one or more web sites.","Various applications of the Internet, and of the web, involve marketplaces that provide goods and\/or services for sale. For instance, consumers may visit a merchant's website to view and\/or purchase goods and services offered for sale by the merchant (and\/or third party merchants). Some network-based marketplaces (e.g., Internet- or web-based marketplaces) include large electronic catalogues of items offered for sale. For each item offered for sale, such electronic catalogues typically include product detail pages (e.g., a web page) that specifies various information about the item, such as a description of the item, one or more pictures of the item, as well as specifications (e.g., weight, dimensions, capabilities) of the item. In various cases, such network-based marketplaces may rely on a service-oriented architecture to implement various business processes and other tasks.","While the system and method for tracking service requests is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the system and method for tracking service requests is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the system and method for tracking service requests to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the system and method for tracking service requests as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude,\u201d \u201cincluding,\u201d and \u201cincludes\u201d mean including, but not limited to.","Various embodiments of a system and method for tracking service requests are described. The system and method for tracking service requests may include a framework for tracking a series of requests that propagate through a service-oriented system, such as a system structured according to a service-oriented architecture (SOA). Such a system may include multiple services configured to communicate with each other (e.g., through message passing) to carry out various tasks, such as business process functions. In some embodiments, such services may be loosely coupled in order to minimize (or in some cases eliminate) interdependencies among services. This modularity may enable services to be reused in order to build various applications through a process referred to as orchestration.","Service-oriented systems may be configured to process requests from various internal or external systems, such as client computer systems or computer systems consuming networked-based services (e.g., web services). For instance, an end-user operating a web browser on a client computer system may submit a request for data (e.g., data associated with a product detail page, a shopping cart application, a checkout process, search queries, etc.). In another example, a computer system may submit a request for a web service (e.g., a data storage service, a data query, etc.). In general, services may be configured to perform any of a variety of business processes.","The services described herein may include but are not limited to one or more of network-based services (e.g., a web service), applications, functions, objects, methods (e.g., objected-oriented methods), subroutines, or any other set of computer-executable instructions. In various embodiments, such services may communicate through any of a variety of communication protocols including but not limited to the Simple Object Access Protocol (SOAP). In various embodiments, messages passed between services may include but are not limited to Extensible Markup Language (XML) messages or messages of any other markup language or format. In various embodiments, descriptions of operations offered by one or more of the services may include Web Service Description Language (WSDL) documents, which may in some cases be provided by a service broker accessible to the services.","To process a given received request, the system described herein may invoke one or more of the types of services described above. As used herein, an initial request may be referred to as the \u201croot request.\u201d In various embodiments, the root request may but need not originate from a computer system outside of the service oriented system described herein. In many embodiments, a root request may be processed by an initial service, which may then call one or more other services. Additionally, each of those services may also call one or more other services (and so on until the root request is completely fulfilled). Accordingly, the particular services called to fulfill a request may be represented as a \u201ccall tree\u201d hierarchy that specifies, for each particular service of multiple services called to fulfill the same root request, the service that called the particular service and any services called by the particular service. For instance, a call tree hierarchy may in some cases be a deep and broad tree with multiple branches each representing a series of related service calls.","For clarity of description, various terms may be useful for describing elements of a call tree hierarchy. Note that the following terminology may only be applicable to services and requests of a given call tree hierarchy. In other words, the following terminology may only be applicable for services and requests associated with the same root request. From the perspective of a particular service, any service that calls the particular service may be referred to as a \u201cparent service.\u201d Furthermore, from the perspective of a particular service, any service that the particular service calls may be referred to as a \u201cchild service.\u201d In a similar fashion, from the perspective of a particular request, any request from which the particular request stems may be referred to as a \u201cparent request.\u201d Furthermore, from the perspective of a particular request, any request stemming from the particular request may be referred to as a \u201cchild request.\u201d Additionally, as used herein the phrases \u201crequest,\u201d \u201ccall,\u201d \u201cservice request\u201d and \u201cservice call\u201d may be used interchangeably. Note that this terminology refers to the nature of the propagation of a particular request throughout the present system and is not intended to limit the physical configuration of the services. As may sometimes be the case with service-oriented architectures employing modularity, each service may in some embodiments be independent of other services in the service-oriented system (e.g., the source code of services or their underlying components may be configured such that interdependencies among source and\/or machine code are not present).","As described above, a given parent request may result in multiple child service calls to other services. In various embodiments of the system and method for tracking service requests, request identifiers embedded within such service calls (or located elsewhere) may be utilized to generate a stored representation of a call tree hierarchy for a given request. In various embodiments, such request identifiers may be stored in log files associated with various services. For instance, a service may store identifiers for inbound requests in an inbound request log and\/or store identifiers for outbound requests in an outbound request log. In various embodiments, call tree generation logic may generate a representation of a call tree hierarchy from identifiers retrieved from such logs. Such representations may be utilized for diagnosing errors with request handling, providing developer support, and performing traffic analysis.","Request Identifiers",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1","FIG. 1"],"b":"100"},"Origin Identifier\u2014","origin identifier (ID)  may be an identifier assigned to all requests of a given call tree hierarchy, which includes the initial root request as well as subsequent requests spawned as a result of the initial root request. For example, as described above, the service-oriented systems of various embodiments may be configured to process requests from various internal or external systems, such as client computer systems or computer systems consuming networked-based services. To fulfill one of such requests, the service-oriented system may call multiple different services. For instance, service \u201cA\u201d may be the initial service called to fulfill a request (e.g., service \u201cA\u201d may be called by an external system). To fulfill the initial request, service \u201cA\u201d may call service \u201cB,\u201d which may call service \u201cC,\u201d and so on. Each of such services may perform a particular function or quantum of work in order to fulfill the initial request. In various embodiments, each of such services may be configured to embed the same origin identifier  into a request of (or call to) another service. Accordingly, each of such requests may be associated with each other by virtue of containing the same origin identifier. As described in more detail below, the call tree generation logic of various embodiments may be configured to determine that request identifiers having the same origin identifier are members of the same call tree hierarchy.","The manner in which the origin identifier may be represented may vary according to various embodiments and implementations. One particular example of an origin identifier may include a hexadecimal string representation of a standard Universally Unique Identifier (UUID) as defined in Request for Comments (RFC) 4122 published by the Internet Engineering Task Force (IETF). In one particular embodiment, the origin identifier may contain only lower-case alphabetic characters in order to enable fast case-sensitive comparison of request identifiers (e.g., a comparison performed by the call tree generation logic described below). Note that these particular examples are not intended to limit the implementation of the origin ID. In various embodiments, the origin ID may be generated according to other formats.","Transaction Depth\u2014","transaction depth  may indicate the depth of a current request within the call tree hierarchy. For instance (as described above), service \u201cA\u201d may be the initial service called to fulfill a root request (e.g., service \u201cA\u201d may be called by an external system). To fulfill the initial request, service \u201cA\u201d may call service \u201cB,\u201d which may call service \u201cC,\u201d and so on. In various embodiments, the depth of the initial request may be set to 0. For instance, when the first service or \u201croot\u201d service receives the root service request, the root service (e.g., service \u201cA\u201d) may set the transaction depth  to 0. If in response to this request the originating service calls one or more other services, the transaction depth for these requests may be incremented by 1. For instance, if service \u201cA\u201d were to call two other services \u201cB\u201d and \u201cB,\u201d the transaction depth of the request identifiers passed to such services would be equivalent to 1. The transaction depth for request identifiers of corresponding requests sent by B and B would be incremented to 2 and so on. In the context of a call tree hierarchy, the transaction depth of a particular request may in various embodiments represent the distance (e.g., number of requests) between that request and the root request. For example, the depth of the root request may be 0, the depth of a request stemming from the root request may be 1, and so on. Note that in various embodiments, such numbering system may be somewhat arbitrary and open to modification.","The manner in which the origin identifier may be represented may vary according to various embodiments and implementations. One particular example of a transaction depth may be represented as a variable-width base-64 number. In various embodiments, the value of a given transaction depth may be but need not be a value equivalent to the increment of the previous transaction depth. For instance, in some embodiments, each transaction depth may be assigned a unique identifier, which may be included in the request identifier instead of the illustrated transaction depth .","Interaction Identifier(s)\u2014","interaction identifiers -, collectively referred to as interaction identifier(s) , may each identify a single request (or service call) for a given call tree hierarchy. For instance (as described above), service \u201cA\u201d may be the initial service called to fulfill a request (e.g., service \u201cA\u201d may be called by an external system). To fulfill the root request, service \u201cA\u201d may call service \u201cB,\u201d which may call service \u201cC,\u201d and so on. In one example, the call of service \u201cB\u201d by service \u201cA\u201d may be identified by interaction identifier , the call of service \u201cC\u201d by service \u201cB\u201d may be identified by interaction identifier and so on.","Note that in various embodiments separate service requests between the same services may have separate and unique interaction identifiers. For example, if service \u201cA\u201d calls service \u201cB\u201d three times, each of such calls may be assigned a different interaction identifier. In various embodiments, this characteristic may ensure that the associated request identifiers are also unique across service requests between the same services (since the request identifiers include the interactions identifiers).","Note that in various embodiments the interaction identifier may be but need not be globally unique (e.g., unique with respect to all other interaction identifiers). For instance, in some embodiments, a given interaction identifier for a given request need be unique only with respect to request identifiers having a particular origin identifier  and\/or a particular parent interaction identifier, which may be the interaction identifier of the request preceding the given request in the call tree hierarchy (i.e., the interaction identifier of the request identifier of the parent service). In one example, if service \u201cA\u201d were to call two other services \u201cB\u201d and \u201cB,\u201d the request identifier of service \u201cB\u201d and the request identifier of service \u201cB\u201d would have separate interaction identifiers. Moreover, the parent interaction identifier of each of such interaction identifiers may be the interaction identifier of the request identifier associated with the call of service \u201cA.\u201d The relationship between interaction identifiers and parent interaction identifiers is described in more detail below.","In various embodiments, interaction identifiers may be generated randomly or pseudo-randomly. In some cases, the values generated for an interaction identifier may have a high probability of uniqueness within the context of parent interaction and\/or a given transaction depth. In some embodiments, the size of the random numbers that need to be generated depends on the number of requests a service makes.","Request Stack\u2014","request stack  may include one or more of the interaction identifiers described above. In various embodiments, the request stack may include the interaction identifier of the request to which the request identifier belongs. In some embodiments, the request stack may also include other interaction identifiers, such as one or more parent interaction identifiers of prior requests (e.g., a \u201cstack\u201d or \u201chistory\u201d of previous interaction identifiers in the call tree hierarchy). In various embodiments, the request stack may have a fixed size. For instance, the request stack  may store a fixed quantity of interaction identifiers including the interaction identifier of the request to which the request identifier belongs and one or more parent interaction identifiers.","In various embodiments, the utilization of a request stack having a fixed length (e.g., fixed quantity of stored interaction identifiers) may provide a mechanism to control storage and bandwidth throughout the service-oriented system. For example, the service-oriented system of various embodiments may in some cases receive numerous (e.g., thousands, millions, or some other quantity) of services requests per a given time period (e.g., per day, per week, or some other time period), such as requests from network-based browsers (e.g., web browsers) on client systems or requests from computer systems consuming network-based services (e.g., web services). In some embodiments, a request identifier adhering to the format of request identifier  may be generated for each of such requests and each of any subsequent child requests. Due to the shear number of requests that may be handled by the service-oriented systems of various embodiments, even when the request stack of a single request identifier is of a relatively small size (e.g., a few bytes), the implications on storage and bandwidth of the overall system may in some cases be significant. Accordingly, various embodiments may include ensuring that each request identifier contains a request stack equal to and\/or less than a fixed stack size (e.g., a fixed quantity of interaction identifiers). Similarly, various embodiments may include fixing the length of each interaction identifier stored as part of the request stack (e.g., each interaction identifier could be limited to a single byte, or some other size). By utilizing interaction identifiers of fixed size and\/or a request stack of a fixed size, various embodiments may be configured to control the bandwidth and\/or storage utilization of the service-oriented system described herein. For instance, in one example, historical request traffic (e.g., the number of requests handled by the service oriented system per a given time period) may be monitored to determine an optimal request stack size and\/or interaction identifier size in order to prevent exceeding the bandwidth or storage limitations of the service-oriented system.","In various embodiments, the utilization of a request stack having a fixed length (e.g., fixed quantity of stored interaction identifiers) may provide a mechanism to control one or more fault tolerance requirements of the system including but not limited to durability with respect to data loss and other errors (associated with individual services and host systems as well as the entire service-oriented system). For example, in some embodiments, the larger the size of the request stack (e.g., the more interaction identifiers included within a given request identifier), the more fault tolerant the system becomes.","In embodiments where request stack  includes multiple interaction identifiers, the request stack may serve as a history of interaction identifiers. For instance, in the illustrated embodiment, interaction identifier -may represent a series of interaction identifiers in ascending chronological order (where interaction identifier corresponds to the oldest service call and interaction identifier corresponds to the most recent service call).","In addition to the illustrated elements, request identifier  may in various embodiments include one or more portions of data for error detection and\/or error correction. Examples of such data include but are not limited to various types of checksums.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 2","FIG. 3"],"b":["220","230","240","250","210","250"]},"In the illustrated example, each request identifier - includes a request stack of a fixed size (e.g., three interaction identifiers). In other embodiments, larger or smaller request stacks may be utilized as long as the request stack includes at least one interaction identifier. Furthermore, in some embodiments, request stack sizes may be of uniform size across the service-oriented system (as is the case in the illustrated embodiment). However, in other embodiments, subsets of services may have different request stack sizes. For instance, a portion of the service-oriented system may utilize a particular fixed stack size for request identifiers whereas another portion of the service-oriented system may utilize another fixed stack fixed stack size for request identifiers.","Referring collectively to  and , a representation of the receipt of an inbound service request (or service call)  as well as the issuance of an outbound request  by service  is illustrated. Request identifiers  and  of  may correspond to the like-numbered elements of . As illustrated, service  may receive an inbound service request . Service  may receive the inbound service request from another service within the service-oriented system, according to various embodiments. Inbound service request  may include the requisite instructions or commands for invoking service . In various embodiments, inbound service request  may also include a request identifier , which may include values for an origin identifier, transaction depth, and request stack, as described above with respect to . In various embodiments, request identifier  may be embedded within inbound service request  (e.g., as metadata). For example, according to various embodiments, the request identifier may be presented as part of metadata in a service framework, as part of a Hypertext Transfer Protocol (HTTP) header, as part of a SOAP header, as part of a Representational State Transfer (REST) protocol, as part of a remote procedural call (RPC), or as part of metadata of some other protocol, whether such protocol is presently known or developed in the future. In other embodiments, request identifier  may be transmitted to service  as an element separate from inbound service request . In various embodiments, request identifier  may be located elsewhere and inbound service request  may include information (e.g., a pointer or memory address) for accessing the request identifier at that location.","In response to receiving the inbound service request, service  may perform a designated function or quantum of work associated with the request, such as processing requests from client computer systems or computer systems requesting web services. In various embodiments, service  may be configured to store a copy of request identifier  within inbound log . In some cases, service  may require the services of another service in order to fulfill a particular request, as illustrated by the transmission of outbound service request .","As is the case in the illustrated embodiment, service  may be configured to send one or more outbound service requests  to one or more other services in order to fulfill the corresponding root request. Such outbound service requests may also include a request identifier  based at least in part on the received request identifier . Request identifier  may be generated by service  or some other component with which service  is configured to coordinate. Since outbound service request  is caused at least in part by inbound service request  (i.e., request  stems from request ), the outbound service request  and the inbound service request  can be considered to be constituents of the same call tree hierarchy. Accordingly, service  (or some other component of the service-oriented framework) may be configured to generate request identifier  such that the request identifier includes the same origin identifier as that of the inbound service request . In the illustrated embodiment, such origin identifier is illustrated as \u201c343CD324.\u201d For instance, in one embodiment, service  may be configured to determine the value of the origin identifier of the request identifier of the inbound service request and write that same value into the request identifier of an outbound service request. In various embodiments, service  (or some other component of the service-oriented framework) may also be configured to generate request identifier  such that the request identifier includes a transaction depth value that indicates the transaction depth level is one level deeper than the transaction depth of the parent request (e.g., inbound service request ). For instance, in one embodiment, any given call tree hierarchy may have various depths that each have their own depth identifier. In some embodiments, such depth identifiers may be sequential. Accordingly, in order to generate request identifier  such that it includes a transaction depth value that indicates the transaction depth level is one level deeper than the transaction depth of the parent request (e.g., inbound service request ), service  may be configured to determine the value of the transaction depth from the parent request, sum that value with an increment value (e.g., 1, or some other increment value), and store the result of such summation as the transaction depth value of the request identifier of the outbound service request. In the illustrated embodiment, the transaction depth value of the inbound request identifier  is 3 whereas the transaction depth value of the outbound request identifier  is 4.","In some cases, transaction depth identifiers may instead have identifiers that are not necessarily related to each other sequentially. Accordingly, in some embodiments, service  may be configured to determine the transaction depth value from the request identifier of the parent request. From that value, service  may determine the actual depth level corresponding to the transaction depth value (e.g., via a lookup table that provides a sequential listing of transaction depth levels to corresponding transaction depth values). From that depth level, service  may be configured to determine the next sequential transaction depth (e.g., via a lookup table that provides a sequential listing of transaction depth levels to corresponding transaction depth values) as well as the transaction depth value corresponding to that transaction depth. Service  may be configured to store such transaction depth value as the transaction depth value of the request identifier of the outbound service request.","Service  may also be configured to generate request identifier  of the outbound service request such that the request identifier has a request stack that includes an interaction identifier associated with the outbound service request and all of the interaction identifiers of the request stack of request identifier  except for the oldest interaction identifier, which in many cases may also be the interaction identifier corresponding to a request at the highest transaction depth level when compared to the transaction depth levels associated with the other interaction identifiers of the request stack. For example, the root request may occur at transaction depth \u201c0,\u201d a subsequent request may occur at transaction depth \u201c1,\u201d another subsequent request may occur at transaction depth \u201c2,\u201d and so on. In some respects, the request stack may operate in a fashion similar to that of a first in, first out (FIFO) buffer, as described in more detail below.","To generate the request stack of request identifier , service  may be configured to determine the interaction identifiers present within the request stack of request identifier . Service  may also be configured to determine the size of the request stack that is to be included within request identifier  (i.e., the quantity of interaction identifiers to be included within the request stack). In some embodiments, this size may be specified by service , another service within the service-oriented system (e.g., the service that is to receive request ), or some other component of the service-oriented system (e.g., a component storing a configuration file that specifies the size). In other embodiments, the size of the request stack may be specified by service . In one embodiment, the size of the request stack may be dynamically determined by service  (or some other component of the service-oriented system). For instance, service  may be configured to dynamically determine the size of the request stack based on capacity and\/or utilization of system bandwidth and\/or system storage. In one example, service  may be configured to determine that bandwidth utilization has reached a utilization threshold (e.g., a threshold set by an administrator). In response to such determination, service  may be configured to utilize a smaller request stack size in order to conserve bandwidth. In various embodiments, a similar approach may be applied to storage utilization.","Dependent upon the size of the inbound request stack and the determined size of the outbound request stack (as described above), a number of different techniques may be utilized to generate the request stack of request identifier , as described herein. In one scenario, the size of the inbound request stack may be the same as the determined size of the outbound request stack, as is the case in the illustrated embodiment. In this scenario, if the size of the outbound service request stack is to be n interaction identifiers, service  may be configured to determine the (n\u22121) most recent interaction identifiers of the request stack of the inbound request identifier. Service  may be configured to embed the (n\u22121) most recent interaction identifiers of the inbound request stack into the request stack of the outbound request identifier  in addition to a new interaction identifier that corresponds to request  issued by service . In the illustrated embodiment, for each request identifier, the oldest interaction identifier is illustrated on the leftmost portion of the request stack and the newest interaction identifier is illustrated on the rightmost portion. In the illustrated embodiment, to generate the request stack of the outbound request identifier, service  may be configured to take the request stack of the inbound request identifier, drop the leftmost (e.g., oldest) interaction identifier, shift all other interaction identifiers to the left by one position, insert a newly generated interaction identifier for the outbound request, and embed this newly generated request stack in the request identifier of the outbound request.","In another scenario, the size of the request stack of the inbound service request identifier  may be less than the size of the determined request stack size for the outbound service request identifier . In these cases, the request stack size of the outbound service request may enable all of the interaction identifiers of the request stack of the inbound service request identifier to be included within the request stack of the outbound service request identifier. Accordingly, in various embodiments, service  may be configured to embed all of the interaction identifiers in the request stack of the outbound request identifier  in addition to a new interaction identifier that corresponds to request  issued by service .","In an additional scenario, the size of the request stack of the inbound service request identifier  may be greater than the size of the determined request stack size for the outbound service request identifier . For instance, if the size of the request stack for the outbound service request identifier is m interaction identifiers and the size of the request stack for the inbound request identifier is m+x interaction identifiers (where x and m are positive integers), service  may be configured to determine the (m\u22121) most recent interaction identifiers of the request stack of the inbound request identifier. Service  may also be configured to embed such (m\u22121) most recent interaction identifiers of the request stack of the inbound request identifier into the request stack of the outbound request identifier in addition to a new interaction identifier that corresponds to request issued by service .","As described above, inbound request log  may be managed by service  and include records of one or more inbound service requests. In one embodiment, for each inbound service request received, service  may be configured to store that request's identifier (which may include an origin identifier, transaction depth, and request stack, as illustrated) within the inbound request log. In various embodiments, service  may also store within the log various metadata associated with each inbound service request identifier. Such metadata may include but is not limited to timestamps (e.g., a timestamp included within the request, such as a timestamp of when the request was generated, or a timestamp generated upon receiving the request, such as a timestamp of when the request was received by service ), the particular quantum of work performed in response to the request, and\/or any errors encountered while processing the request. In various embodiments, outbound request log  may include information similar to that of inbound request log . For example, for each outbound request issued, service  may store a record of such request within outbound request log . For instance, service  may, for each outbound request, store that request's identifier within outbound request log . As is the case with inbound request log , service  may also store within outbound request log  various metadata associated with requests including but not limited to metadata such as timestamps and errors encountered.","Log Data Collection","Referring collectively to  and , each service within the service-oriented system may include a log reporting agent, such as log reporting agent . Log reporting agent  may in various embodiments report the contents of inbound request log  and\/or outbound request log  to a log repository (e.g., a data store, such as a database or other location in memory). One example of such a repository is illustrated log repository  of . Various protocols for transmitting records from the logs of a service  to a log repository may be utilized according to various embodiments. In some embodiments, the log reporting agent may periodically or aperiodically provide log information to the log repository. In various embodiments, the log reporting agent may be configured to service requests for log information, such as a request from the log repository or some other component of the service-oriented system. In some embodiments, in addition to or as an alternative to reporting log information from logs  and , log reporting agent  may report log information to the log repository in real-time (in some cases bypassing the storage of information within the logs altogether). For instance, as a request is detected or generated, the log reporting agent may immediately report the information to the log repository. In various embodiments, log data may specify, for each request identifier, the service that generated the request identifier and\/or the service that received the request identifier.","Call Tree Generation","As illustrated in , multiple services -within the service-oriented system may be configured to transmit respective log data -to log repository . The data stored within log repository  (e.g., service request identifiers and associated metadata) may be accessed by call tree generation logic . Call tree generation logic may be configured to generate a data structure representing a call tree hierarchy, such as call tree data structure . As described above, the particular services called to fulfill a root request may be represented as a \u201ccall tree\u201d hierarchy that specifies, for a particular service called, the service that called the particular service and any services called by the particular service. For instance, since a root request may result in a service call which may propagate into multiple other services calls throughout the service oriented system, a call tree hierarchy may in some cases be a deep and broad tree with multiple branches each representing a sequences of service calls.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 5"],"b":["420","500","510"]},"To generate such a call tree, call tree generation logic may be configured to collect request identifiers (e.g., request identifiers , , , ,  and ) that each include the same origin identifier. In the illustrated embodiment, \u201c563BD725\u201d denotes an example of such an origin identifier. In various embodiments, call tree generation logic may mine (e.g., perform a search or other data analysis) log data associated with various services in order to find a collection of request identifiers that correspond to the same origin identifier (and thus correspond to the same root request, e.g., root request ).","In various embodiments, inbound and outbound request logs may be maintained for each service. In these cases, call tree generation logic  may be configured to compare request identifiers in order to determine that a given service called another service in the process of fulfilling the root request. For example, in one embodiment, the call tree generation logic may compare a request identifier from a given service's outbound request log to the request identifier from another service's inbound request log. If a match is detected, the call tree generation logic may indicate that the service corresponding to that outbound request log called the service corresponding to that inbound request log. For example, call tree generation logic may discover a request identifier equivalent to request identifier  within the outbound request log associated with service . In this example, call tree generation logic may also locate a request identifier equivalent to request identifier  within the inbound log of service . In response to this match, call tree generation logic may indicate that an edge (representing a service call) exists between two particular nodes of the call tree (e.g., the node corresponding to service  and the node corresponding to service ). The above described process may be repeated to determine the illustrated edges that correspond to request identifiers , , ,  and . In other embodiments, since the manner in which interaction identifiers are generated may ensure that each interaction identifier is unique for a given depth level and origin identifier, the call tree generation logic may instead search for matching interaction identifiers between request identifiers of adjacent depth levels instead of searching for matching request identifiers.","In other embodiments, only one type of log (e.g., either inbound or outbound) may be maintained for a given service. For example, if only outbound request logs are maintained for each of the services, then the call tree generation logic  may utilize different techniques for determining an edge that represents a service call in the call tree data structure. In one example, call tree generation logic may compare two request identifiers that have adjacent depth values. For instance, in the illustrated embodiment, the call tree generation logic may be configured to compare request identifier  to request identifier , since such request identifiers contain the adjacent depth values of 1 and 2. In this case, the call tree generation logic may determine whether the most recent interaction identifier of request identifier  (e.g., B) is equivalent to the 2nd most recent interaction identifier of request identifier  (e.g., B). For request identifier , the 2nd most recent interaction identifier is evaluated since the most recent interaction identifier position will be fill with a new interaction identifier inserted by the service that generated request identifier  (in this case, service ). In the illustrated embodiment, this comparison returns a match since the values for the interaction identifiers are equivalent. In response to such match, the call tree generation logic may be configured to indicate within the data structure that an edge (representing a service call) exists between service  and .","In various embodiments, the call tree generation logic  may be configured to generate a call tree in the presence of data loss. For instance, consider the case where the service oriented system maintains outbound service logs and the log data for service  is lost, as might be the case in the event of a failure on the host system on which service  runs or in the case of a failure of log repository . Since the request identifiers of various embodiments may include a request stack of multiple interaction identifiers, multiple layers of redundancy may be utilized to overcome a log data loss. In this example, since the outbound log data for service  is lost, request identifiers , , and  may not be available. Accordingly, the call tree generation logic may be configured to utilize a request identifier from a lower depth level to reconstruct the pertinent portion of the call tree. While request identifiers , , and  may be not be available due to data loss, the request identifier  (and ) is available. Since request identifier  includes a stack or \u201chistory\u201d of interaction identifiers, that request identifier may be utilized to obtain information that would have been available if request identifier  were not lost to data failure. Since request identifier  has a depth level that is two levels lower than the depth level of request identifier , the call tree generation logic may utilize the third most recent (not the second most recent as was the case in the previous example) interaction identifier. In this example, the third most recent interaction identifier is evaluated since that position would contain the interaction identifier generated by service  in the illustrated embodiment. If the call tree generation logic determines that the most recent interaction identifier of request identifier  matches the third most recent interaction identifier of request identifier , the call tree generation logic may determine that service  called service  even if the log data for service  is unavailable (e.g., due to data loss). Accordingly, the call tree generation logic may indicate an edge (representing a service call) exists between service  and service  within the generated call tree data structure.","Various metadata may also be included within such call tree data structure, such as timestamps, the particular quantum of work performed in response to a given request, and\/or any errors encountered while processing a given request. For example, the illustrated services may record timestamps of when a request is received, when a request is generated, and\/or when a request is sent to another service. These timestamps may be appended to the call tree data structure to designate latency times between services (e.g., by calculating the time difference between when a request is sent and when it is received). In other cases, metadata may include error information that indicates any errors encountered or any tasks performed while processing a given request. In some embodiments, such metadata may include host address (e.g., an Internet Protocol address of a host) in order to generate a tree structure that indicates which host machines are processing requests (note that in some embodiments host machines may host multiple different services).","The system and method for tracking service requests described herein may be configured to perform a variety of methods, an example of which is illustrated by . The call tree generation logic described herein may be configured to perform the illustrated method, according to various embodiments. As illustrated, the method may begin with block , which may include receiving multiple request identifiers each associated with a respective one of multiple service requests. Each given request identifier may includes an origin identifier associated with a root request, a depth value specifying a location of the associated service request within a sequence of service requests, and a request stack including one or more interaction identifiers assigned to a service request issued from one service to another service. For example, receiving multiple request identifiers may in some cases include receiving log data that includes such request identifiers. For instance, the method may include receiving log data directly from host systems that host the services of the service-oriented system described herein. In some cases, the method may include receiving log data from one or more log repositories such as log repository  described above. In general, the method may include utilizing any of the techniques for obtaining request identifiers described above with respect to call tree generation logic .","As illustrated by block , the method may further include, based on multiple ones of the request identifiers that each include an origin identifier associated with a particular root request, generating a data structure that specifies a hierarchy of services called to fulfill that particular root request; wherein, based on one or more of the interaction identifiers and one or more of the depth values, the generated data structure specifies, for a given service of said hierarchy: a parent service that called the given service, and one or more child services called by the given service. For example, in various embodiments, generating the data structure may include determining that each of a subset of the multiple request identifiers includes the same origin identifier as well as indicating each associated service request as a node of the hierarchy within the data structure. Examples of such nodes are illustrated in  as services , , , , ,  and . Generating such data structure may also include, for each node within the hierarchy, assigning the node to a level within the hierarchy based on the transaction depth value of the request identifier associated with the service request corresponding to that node. Examples of such depth level values are described above with respect to transaction depth  of . Generating the data structure may also include determining that the request stack of a given node at a given level within the hierarchy includes an interaction identifier that is the same as an interaction identifier of the request stack of an other node located within an adjacent level of the hierarchy. For instance, the method may include any of the various interaction identifier comparison techniques described above with respect to . In response to determining such match, the method may include indicating a service call as an edge between said given node and said other node. Examples of such an edge are illustrated as the edges coupling the nodes of  described above.","In various embodiments, the techniques for analyzing request identifiers and generating a call tree may be performed on an incremental basis. For example, as request identifiers are updated (e.g., as logs and\/or log repositories receive new data), the call tree generation logic described herein may be configured to incrementally update the generated call tree data structure to reflect the newly reported requests. In some embodiments, the techniques described herein may be performed on a depth level basis. For example, as request identifiers are received (e.g., by the log repository or call tree generation logic described herein), each identifier may be categorized (e.g., placed in a categorized directory) based on transaction depth.","In various embodiments, the generated call tree data structures described herein may be utilized for diagnostic purposes. For instance, as described above, the call tree data structure may include metadata, such as a record of error(s) that occur when processing a request. Since this metadata may be associated with specific nodes and\/or service calls, various embodiments may include determining sources of errors or faults within the service oriented system. In some embodiments, the generated call tree data structures described herein may be utilized for analytical purposes. For example, based on call tree data structures generated as described herein, various embodiments may include determining historical paths of service calls and\/or path anomalies. For instance, various embodiments may include detecting that, for a given root request, one or more services are being called unnecessarily. For instance, such services may not be needed to fulfill the particular root request. Accordingly, in some embodiments, such services may be culled from processing further requests similar to or the same as the root request that originally initiated the unnecessary service calls (e.g., a re-orchestration process may be employed to modify the particular services called for a particular type of request). By removing such unnecessary service calls, various embodiments may conserve resources such as storage and\/or bandwidth. In other embodiments, the generated call tree data structures described herein may be utilized for auditing purposes. For example, in the case that the service oriented system provides network-based services (e.g., web services) to consumers of such services (who may provide remuneration for the consumption of services), such consumers may desire to at least occasionally view information that confirms they are being charged in a fair manner. To provide such information to the consumer, various embodiments may include providing the consumer with various records such as records that indicate how frequent they consume network-based services and in what quantity. Such information may be generated based on the call tree data structures described herein.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 6B","FIG. 3","FIG. 3"],"b":["300","650","240","300"]},"As illustrated by block , the method may also include generating a new request stack. The new request stack may include all of the interaction identifiers of the first request identifier except for an oldest one of the interaction identifiers. For instance, as illustrated in , the request stack of outbound request identifier  does not include \u201c6F,\u201d which is the oldest interaction identifier of the inbound service request identifier . The new request stack may also include a new interaction identifier associated with an outbound service request. For instance, as illustrated in , the request stack of outbound service request identifier  includes a new interaction identifier \u201c2C.\u201d","As illustrated by block , the method may also include generating a second request identifier associated with the outbound service request. The second request identifier may include the origin identifier, a new depth value specifying a location of the outbound service request within the sequence of service requests, and the new request stack. One example of such a second request identifier is illustrated as outbound service request identifier  of .","In various embodiments, the method may also include generating the new depth value such that the new depth value is a result of incrementing the first depth value. For example, in the illustrated embodiment of , the depth value of the outbound request identifier (i.e., \u201c4\u201d) may be the result of incrementing the depth value of the inbound request identifier (i.e., \u201c3\u201d). In various embodiments, the method may include storing either of (or both of) the first request identifier and the second request identifier as log data accessible to one or more computer systems. For instance, in the illustrated embodiment of , the inbound and outbound request identifiers may be stored in inbound request log  and outbound request log , respectively.","Example System Configurations","The system and method for tracking service requests may include various system configurations, according to various embodiments. One example system configuration is illustrated in . As illustrated the various components of the example system are coupled together via a network . Network  may include any combination of local area networks (LANs), wide area networks (WANs), some other network configured to communicate data to\/from computer systems, or some combination thereof. Each of host systems -and  may be implemented by a computer system, such as computer system  described below. Call tree generation logic  may be implemented as software (e.g., program instructions executable by a processor of host system ), hardware or some combination thereof. Call tree data structure  may be generated by host system logic  and stored in a memory of host system . Log repository  may be implemented as a data store (e.g., database, memory, or some other element configured to store data) coupled to network . In other embodiments, log repository  may be implemented as a backend system of host system  and accessible to host system  via a separate network. Host system may be configured to execute program instruction to implements one or more services . Such services may include but are not limited to one or more of network-based services (e.g., a web service), applications, functions, objects, methods (e.g., objected-oriented methods), subroutines, or any other set of computer-executable instructions. Examples of services  include any of the services described above. Host systems -and services -may be configured in a similar manner.","In various embodiments, the various services of the illustrated embodiment may be controlled by a common entity. However, in some embodiments, external systems, such as a system controlled by another entity, may be called as part of a sequence of requests for fulfilling a root request. In some cases, the external system may adhere to the request identifier generation techniques described herein and may integrate with the various services described above. In the event that an external system does not adhere to the various techniques for generating request identifiers as described herein, the external system may be treated as a service that is not visible in the call tree or, alternatively, requests sent back from the external system may be treated as new requests altogether (e.g., as root requests). In various embodiments, the system configuration may include one or more proxy systems and\/or load balancing systems. In some cases, the system configuration may treat these systems as transparent from a request identifier generation perspective. In other cases, these systems may generate request identifiers according to the techniques described above.","In some embodiments, the service-oriented system described herein may be integrated with other external systems that may utilize different techniques for identifying requests. For instance, the request identifiers described herein may in various embodiments be wrapped or enveloped in additional data (e.g., additional identifiers, headers, etc.) to facilitate compatibility with various external systems.","Example System","Various embodiments of a system and method for tracking service requests, as described herein, may be executed on one or more computer systems, which may interact with various other devices. One such computer system is computer system  illustrated by , which in the illustrated example may implement host system . Computer system  may be capable of implementing call tree generation logic, such as call tree generation logic . In the illustrated embodiment, computer system  includes one or more processors  coupled to a system memory  via an input\/output (I\/O) interface . Computer system  further includes a network interface  coupled to I\/O interface , and one or more input\/output devices , such as cursor control device , keyboard , and display(s) . In some embodiments, it is contemplated that embodiments may be implemented using a single instance of computer system , while in other embodiments multiple such systems, or multiple nodes making up computer system , may be configured to host different portions or instances of embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system  that are distinct from those nodes implementing other elements.","In various embodiments, computer system  may be a uniprocessor system including one processor , or a multiprocessor system including several processors  (e.g., two, four, eight, or another suitable number). Processors  may be any suitable processor capable of executing instructions. For example, in various embodiments processors  may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x86, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors  may commonly, but not necessarily, implement the same ISA.","System memory  may be configured to store program instructions  and\/or data  accessible by processor . In various embodiments, system memory  may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile\/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions and data implementing call tree generation logic, such as call tree generation logic  described above, are shown stored within system memory  as call tree generation logic . Additionally, a call tree data structure  (which may be generated by logic ) may be stored with data  of memory . In other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory  or computer system . Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD\/DVD-ROM coupled to computer system  via I\/O interface . Program instructions and data stored via a computer-accessible medium may be transmitted by transmission media or signals such as electrical, electromagnetic, or digital signals, which may be conveyed via a communication medium such as a network and\/or a wireless link, such as may be implemented via network interface .","In one embodiment, I\/O interface  may be configured to coordinate I\/O traffic between processor , system memory , and any peripheral devices in the device, including network interface  or other peripheral interfaces, such as input\/output devices . In some embodiments, I\/O interface  may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory ) into a format suitable for use by another component (e.g., processor ). In some embodiments, I\/O interface  may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I\/O interface  may be split into two or more separate components, such as a north bridge and a south bridge, for example. Also, in some embodiments some or all of the functionality of I\/O interface , such as an interface to system memory , may be incorporated directly into processor .","Network interface  may be configured to allow data to be exchanged between computer system  and other devices attached to a network (e.g., network ), such as log repository  and\/or host system and service(s) , or between nodes of computer system . In various embodiments, network interface  may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications\/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and\/or protocol.","Input\/output devices  may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or accessing data by one or more computer systems . Multiple input\/output devices  may be present in computer system  or may be distributed on various nodes of computer system . In some embodiments, similar input\/output devices may be separate from computer system  and may interact with one or more nodes of computer system  through a wired or wireless connection, such as over network interface .","As shown in , memory  may include program instructions  configured to implement call tree generation logic, such as call tree generation logic . In one embodiment, call tree generation logic  may implement the methods described above, such as the method illustrated by . In other embodiments, different elements and data may be included. As illustrated, note that data  may include call tree data structure .","Those skilled in the art will appreciate that computer system  is merely illustrative and is not intended to limit the scope of embodiments. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions, including computers, network devices, Internet appliances, PDAs, wireless phones, pagers, etc. Computer system  may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and\/or other additional functionality may be available.","Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a computer-accessible medium separate from computer system  may be transmitted to computer system  via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and\/or a wireless link. Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Accordingly, various embodiments may be practiced with other computer system configurations.","The methods described herein may be implemented in software, hardware, or a combination thereof, in different embodiments. In addition, the order of the blocks of the methods may be changed, and various elements may be added, reordered, combined, omitted, modified, etc. Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. The various embodiments described herein are meant to be illustrative and not limiting. Many variations, modifications, additions, and improvements are possible. Accordingly, plural instances may be provided for components described herein as a single instance. Boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally, structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component. These and other variations, modifications, additions, and improvements may fall within the scope of embodiments as defined in the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
