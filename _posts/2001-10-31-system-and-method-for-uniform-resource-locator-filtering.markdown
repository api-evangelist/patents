---
title: System and method for uniform resource locator filtering
abstract: A system and method for Uniform Resource Locator (URL) filtering is disclosed. The method comprises receiving an event notification upon the occurrence of an event associated with a received URL; searching, in response to the event notification, a lexical search tree data structure storing a plurality of URLs for the received URL; and processing the received URL in response to the received URL not matching any of the plurality of URLs stored in the lexical search tree data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07472167&OS=07472167&RS=07472167
owner: Hewlett-Packard Development Company, L.P.
number: 07472167
owner_city: Houston
owner_country: US
publication_date: 20011031
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["The present patent application is related to concurrently filed U.S. patent application Ser. No. 10\/002,381, entitled, \u201cSYSTEM AND METHOD FOR SEARCHING A SIGNATURE SET FOR A TARGET SIGNATURE\u201d, the disclosure of which is incorporated herein by reference.","The present invention relates generally to intrusion detection and more particularly to a system and method for Uniform Resource Locator (URL) filtering.","Computer system security issues have become extremely important as more and more computers are connected to networks, like the Internet. Attacks on computer systems have become increasingly sophisticated due to the evolution of new hacker tools.","In response to more sophisticated attacks, new intrusion detection systems (IDS) are being developed and deployed to monitor and prevent attempts to intrude into computer networks. Intrusion detection systems attempt to identify unauthorized or malicious attempts against a computer system or network of computer systems. An IDS may comprise one or more event generation mechanisms that report identifiable events to one or more management facilities. A countermeasure mechanism may also be included within the IDS for executing an action intended to thwart or negate a detected event.","Applications including hostile attack applications responsible for transmitting data across a network medium will often have a distinctive signature within the transmitted data. The signature may comprise recognizable data that is contained within one or more packets. Signature analysis is often performed by the IDS. A signature analysis algorithm may search for a particular string that has been identified as associated with a hostile application. Once the string is identified within a network data stream, the one or more packets carrying the string may be identified as \u2018hostile\u2019 or exploitative, and the IDS may then perform any one or more of a number of actions, such as logging the identification of the string, performing a countermeasure, or simply ignoring the string.","In general, an IDS will scan received packets for an occurrence of a given signature included within a plurality of known attack signatures. Because the signature analysis is performed in real time, that is as the packets are received, performance is critical because positive identifications may require proactive actions on the part of the IDS.","In accordance with an embodiment of the present invention, a method for Uniform Resource Locator (URL) filtering is disclosed. The method comprises receiving an event notification upon the occurrence of an event associated with a received URL; searching, in response to the event notification, a lexical search tree data structure storing a plurality of URLs for the received URL; and processing the received URL in response to the received URL not matching any of the plurality of URLs stored in the lexical search tree data structure.","In accordance with another embodiment of the present invention, a system for URL filtering is disclosed. The system comprises a web server operable to receive a URL request from a client. The system also comprises a filter operable, upon receiving an event notification relating to the URL request from the web server, to search a lexical search tree data structure storing a plurality of URLs for the received URL, the filter further operable to process the received URL in response to the received URL not matching any of the plurality of URLs.","The preferred embodiment of the present invention and its advantages are best understood by referring to  of the drawings, like numerals being used for like and corresponding parts of the various drawings.","A system and method for Uniform Resource Locator (URL) filtering that involves searching a signature set, such as a plurality of URLs, for a target signature, such as a target URL, while reducing the number of comparisons is disclosed.","In the preferred embodiment, a lexical search tree data structure is used to store the data to be searched in a structured and organized way. The data may represent a plurality of signatures of a signature set. The lexical search tree data structure may be implemented in software or hardware. For example, object-oriented programming techniques may be used to implement the lexical search tree data structure. Comparisons between the target signature and the data stored in the lexical search tree are performed to determine whether the lexical search tree data includes the target signature. In the preferred embodiment, this may be accomplished by scanning the target signature only once for comparison with the signature(s) in the signature set instead of scanning it multiple times for comparison with multiple signatures.","A signature may comprise a character string, for example a URL. A character string comprises of one or more characters. Preferably, the characters that may be used in the character strings correspond to the ASCII (American Standard Code for Information Interchange) character set which includes 128 characters, each of which may be denoted by a number from 0 to 127. However, if desired, characters from other types of character sets, such as EBCDIC (Extended Binary-Coded Decimal Interchange Code), extended ASCII, and\/or the like, may be in the character strings. The use of characters from other types of character sets is especially useful in the case of URLs that include characters from languages other than English.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["10","10","12","10","16","16","16","12","14","12","16","14"]},"Web server  preferably includes one or more filters. For example, an IIS server typically includes one or more ISAPI (Internet Server Application Programming Interface) filters. In a preferred embodiment of the present invention, web server  includes a URL filter . URL filter  is activated when web server  is initialized and preferably remains active until web server  is shut down.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["20","22","18","16","16","18","16","16","18","18","16","18","16","16"]},"Once URL filter  has registered with web server , it waits to receive event notification from web server  (step ). When a URL map event occurs, web server  notifies URL filter  of the URL map event (step ), preferably by calling a filter entry point function, for example a HttpFilterProc function, and passing a notification parameter which preferably points to a data structure storing the received URL.","In step , a signature set comprising of a plurality of URLs and stored in a lexical search tree data structure is searched to determine if the received signature, for example the received URL, matches any of the URLs in the signature set. URL filter  preferably determines the data structure pointed to by the notification parameter and retrieves the received URL. The search is preferably performed using a method, such as that described herein with reference to . The URLs in the signature set are preferably URLs that are considered hostile. Such URLs may, for example, request access to data that is not intended to be accessible over a public network. In the preferred embodiment, the signature set is stored in a lexical search tree data structure. An exemplary lexical search tree data structure is described herein with reference to . A preferred embodiment method for storing multiple strings in the lexical search tree data structure is described herein with reference to .","If a match is found, then the URL request is not allowed to be processed (steps , ) thereby filtering the URL request. If a match is not found, then the URL request is allowed to be processed (steps , ) in a conventional manner. In step , URL filter  notifies web server  of the result of the search. URL filter  may also notify web server  that it is ready for the next event. Preferably, URL filter  passes a flag to web server  notifying web server  of the result of the search. The process starting at step  is preferably repeated until web server  is shut down.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3","b":["100","100","102","104","102","100","102","102","100","128","102","100"]},"Each branch  is associated with at least one root node . A branch  in lexical search tree  comprises one or more leaf nodes . Branch  may also comprise one or more twigs . A twig  comprises a twig node . Twig  may also comprise one or more leaf nodes . A leaf node  is a continuation of a branch  or a twig  at the next lower level. A twig  is a divergence of a branch  at a leaf node . A twig node  is typically the first node of twig . Twig node  and the leaf node  from which it diverges are at the same level in lexical search tree . In the FIGURES, a link between a twig node  and a leaf node  from which it diverges is shown by dotted lines. A leaf node may have multiple twig nodes at the same level as the leaf node. However, in the embodiment illustrated in , a leaf node only has one other leaf node directly linked to it at the next lower level.","Each leaf node  and each twig node  may be represented by a data object that includes a value field, a leaf node pointer field and a twig node pointer field. The value field contains the character represented by the node. The leaf node pointer field contains a pointer to a leaf node at the next lower level, if any. The twig pointer field contains a pointer to a twig node at the same level, if any.","A branch along with its corresponding root node represents one or more signatures, for example one or more URLs, having a common first character. The common first character in each signature is represented by root node  and the other characters in each signature are stored in leaf nodes  and\/or twig nodes . Twig  is a substring of a signature whose first character is represented by the corresponding root node. The first character of the substring is stored in the corresponding twig node .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 4"]},"character string : \u201c\/cgi-bin\/root.pl\u201d","character string : \u201c\/cgi-bin\/b.bat\u201d","character string : \u201c\/cgi-bin\/c.exe\u201d","character string : \u201c\/bin\/c.exe\u201d","character string : \u201cabc\u201d","The lexical search tree of  includes 128 root nodes, each root node corresponding to a character in the ASCII character set. The five character strings have the characters \u2018\/\u2019 and \u2018a\u2019 as the first character. The hash value for \u2018\/\u2019 is 47 and the hash value for \u2018a\u2019 is 97. Therefore, in the lexical search tree the root nodes  corresponding to the hash value of those two characters do not have NULL pointers. All other root nodes have NULL pointers indicating that there are no character strings in the signature set that have the characters corresponding to those root nodes as the first character.","For character string , the next character \u2018b\u2019 is stored in a leaf node at the next lower level to the root node corresponding to \u2018a\u2019. The last character \u2018c\u2019 in character string  is stored in a leaf node at the next lower level than the leaf node for character \u2018b\u2019. Therefore, branch  along with the root node for \u2018a\u2019 to which branch  is linked represents character string .","Since \u2018\/\u2019 is the first character for character strings  through , branch  along with the root node for \u2018\/\u2019 to which branch  is linked represents character strings  through . The leaf nodes in branch  are populated in a similar manner to the leaf nodes of branch . Furthermore, as the first character of character string  and character string  are the same but the second character of the two character strings are different, node  storing character \u2018b\u2019 of character string  is designated as a twig node as character string  diverges from character string  at leaf node . Similarly, nodes  and  are designated as twig nodes as character string  and character string  both diverge from character string  at leaf node .","The signature set may include one or more URLs, such as:","character string : http:\/\/www.xyz.org","character string : https:\/\/www.xyz.com","In such a case, the root node  corresponding to the hash value for \u2018h\u2019 would not have a NULL pointer. For character strings  and , the next three characters \u2018t\u2019, \u2018t\u2019 and \u2018p\u2019 are stored in leaf nodes at successive lower levels. For character string , the remaining characters \u2018:\u2019, \u2018\/\u2019, \u2018\/\u2019, \u2018w\u2019, \u2018w\u2019, \u2018w\u2019, \u2018.\u2019, \u2018x\u2019, \u2018y\u2019, \u2018z\u2019, \u2018.\u2019, \u2018o\u2019, \u2018r\u2019, and \u2018g\u2019 are stored in leaf nodes at successive lower levels. On the other hand, for character string , the next character \u2018s\u2019 is stored in a twig node diverging from the leaf node which stores character \u2018:\u2019 of character string . The next character \u2018:\u2019 of character string  is stored in a leaf node at the next lower level from the twig node and the remaining characters of character string , namely, \u2018\/\u2019, \u2018\/\u2019, \u2018w\u2019, \u2018w\u2019, \u2018.\u2019, \u2018x\u2019, \u2018y\u2019, \u2018z\u2019, \u2018.\u2019, \u2018c\u2019, \u2018o\u2019, and \u2018m\u2019 are stored in leaf nodes at successive lower levels starting from the leaf node which stores character \u2018:\u2019 of character string .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5A","b":["126","128","130","132"]},"In step , the status of the root node corresponding to the determined index value is determined. This is preferably accomplished by looking up the status of the root node in an index table. The index table includes a hash value for each character in the character set and its corresponding status information. Status information preferably includes information as to whether the root node is empty or not. A root node is considered empty if no other signatures with the same first character as the signature being processed have been stored in the lexical search tree. Status information may also include a pointer to a leaf node linked to the root node. If the root node is empty, then the leaf node pointer is NULL. In step , a determination is made as to whether the root node is empty. If the root node is empty then in step  a new branch is populated as discussed in more detail with reference to . If the root node is not empty then in step  a new twig is populated as discussed in more detail with reference to . In step , a determination is made as to whether there are any more signatures to be processed. If there are more signatures to be processed then the process starting at step  is repeated.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5B","b":["144","146","148","150","152","154"]},"In step , the end of the branch from the root node corresponding to the first character of the signature being processed is set to point to the allocated leaf node, preferably by setting the current node pointer to point to the allocated leaf node. In step , the signature pointer is incremented to point to the next character in the signature. In step , a determination is made as to whether the end of the signature has been reached. If the end of signature has not been reached then in step , a new leaf node for the next character is allocated. In step , the allocated leaf node is installed on the branch, preferably by setting the leaf node pointer of the current node to point to the allocated leaf.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 5C","b":"166"},"In step , one or more pointers, such as a current node pointer, a signature pointer, a last match pointer and\/or the like are initialized. The current node pointer is preferably initialized to point to the root node. The last match pointer is preferably initialized to point to the current node.","In step , a determination is made as to whether the current node pointer value is NULL. If the current node pointer value is not NULL, then in step , a determination is made as to whether the value of the character pointed to by the signature pointer is equal to the value of the current node. If the two values are the same then it indicates that there is no divergence. In step , the signature pointer is updated, preferably to point to the next character in the signature, for example the URL being processed. In step , the last match pointer is updated, preferably to point to the current node. In step , the current node pointer is updated preferably to point to the next node, thereby making the next node the current node. Thus, in steps  and , the last match pointer is updated to point to the current node and the current node pointer is updated to point to the next node in the lexical search tree.","If in step , a determination is made that the value of the character pointed to by the signature pointer is not equal to the value of the current node, then in step , a divergence flag is set indicating that the current signature and the signature already stored in the lexical search tree diverge. In step , a determination is made as to whether the twig pointer of the node pointed to by the last match pointer is equal to NULL. A twig pointer value that is not NULL indicates that there are other twigs that diverge from the current node. In step , the current node pointer is updated preferably to point to the twig of the node pointed to by the last match pointer. In step , the last match pointer is updated to point to the current node. In step , the divergence flag is reset. The process starting at step  is then repeated.","A determination in step  that the current node pointer value is NULL indicates that the last node of the lexical search tree has been reached. In step  a determination is made as to whether the divergence flag, which indicates a divergence between the signature being processed and a signature having at least the same first character as the signature being processed, is set. If the divergence flag is set, then in step , a new branch is populated starting from the node where the last match was found and the signature to be inserted diverged from the lexical search tree. For this purpose, the method described with reference to  for populating a branch of the lexical search tree may be used, if desired.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":["12","202","204","206","208"]},"In step , a determination is made as to whether the end of the target signature has been reached. If the end of the target signature has not been reached then in step , a determination is made as to whether the current node is empty. A NULL value for the current node pointer may indicate an empty current node. If the current node is not empty then in step , a determination is made as to whether the value of the current node is equal to the value of the character pointed to by the target signature pointer. If the current node value is equal to the value of the character pointed to by the target signature pointer, then in step , the Match Found flag is set indicating a match. In step , the target signature pointer is updated, preferably to point to the next character in the target signature. In step , the last match pointer is updated, preferably to point to the current node. In step , the current node pointer is updated, preferably to point to the next node, thereby making the next node the current node. Thus, in steps  and , the last match pointer is updated to point to the current node and the current node pointer is updated to point to the next node in the lexical search tree.","If in step  it is determined that the current node is empty, then in step  a determination is made as to whether the Match Found flag is set. If the Match Found flag is set, then this along with the other conditions discussed above indicates that a match was found between the target signature and a signature in the lexical search tree. If Match Found is not set, then in step , the target signature pointer is updated, preferably to point to the next character in the target signature and the operation starting at step  is repeated.","A signature, for example a URL, in the lexical search tree may include a wild card character, such as an asterisk. An exemplary signature including a wild card character may look like \u201cabc*.exe\u201d. The preferred embodiment of the present invention allows wild card character processing. Thus, if the target signature is \u201cabcdefg.exe\u201d an exact match for the target signature may not be found in the lexical search tree. However, because in a preferred embodiment, the present invention allows wild card processing, in the above example the result of the search of the lexical tree would indicate that a match was found.","If in step , a determination is made that the value of the current node is not equal to the value of the character pointed to by the target signature pointer, then in step , a determination is made as to whether the current node value is equal to the value of the wild card character. In step , a determination is made as to whether the value of the character pointed to by the target signature pointer is equal to the value of the next node, i.e. the leaf node of the current node. In step , the current node pointer is updated preferably to point to the leaf node of the next node, thereby making the leaf node of the next node the current node. In step , the target signature pointer is updated, preferably to point to the next character in the target signature and the process starting at step  is repeated.","If in step , it is determined that the current node value is not equal to the wild card character, then the twigs starting at the current node are searched. In step , a determination is made as to whether the twig pointer of the node pointed to by the last match pointer is equal to NULL. A twig pointer value that is not NULL indicates that there are twigs that diverge from the node. In step , the current node pointer is updated, preferably to point to the twig node of the node pointed to by the last match pointer. In step , the last match pointer is updated, preferably to point to the current node. In step , the Match Found flag is reset and the process starting at step  is repeated.","The hashing technique used in the preferred embodiment allows easy identification of the root node in the lexical search tree which corresponds to the first character of the target signature, for example the URL received from HTTP client . Thus, all the root nodes do not have to be searched to determine if there is a match between the first character of the target signature and the first character of any of the signatures represented by the lexical search tree.","A single scan of the target signature enables determination of whether the target signature matches any of a plurality of signatures which are represented by the lexical search tree. Moreover, in the preferred embodiment of the present invention wild card searching is supported thereby reducing the number of signatures that need to be stored in the lexical search tree.","Embodiments of the present invention, or parts thereof, may be stored on a storage medium. The storage medium may be stored, for example on web server  or URL filter . The storage medium may have stored thereon instructions which can be used to program a computer to perform the methods according to the present invention. The storage medium may be part of the computer or may be separate from the computer and may include, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMS, DVDs, magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, or any type of media suitable for storing electronic instructions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, the objects and advantages thereof, reference is now made to the following descriptions taken in connection with the accompanying drawings in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 5A-5C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
