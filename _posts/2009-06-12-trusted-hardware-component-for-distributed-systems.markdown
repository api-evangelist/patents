---
title: Trusted hardware component for distributed systems
abstract: Techniques for utilizing trusted hardware components for mitigating the effects of equivocation amongst participant computing devices of a distributed system are described herein. For instance, a distributed system employing a byzantine-fault-resilient protocol—that is, a protocol intended to mitigate (e.g., tolerate, detect, isolate, etc.) the effects of byzantine faults—may employ the techniques. To do so, the techniques may utilize a trusted hardware component comprising a non-decreasing counter and a key. This hardware component may be “trusted” in that the respective participant computing device cannot modify or observe the contents of the component in any manner other than according to the prescribed procedures, as described herein. Furthermore, the trusted hardware component may couple to the participant computing device in any suitable manner, such as via a universal serial bus (USB) connection or the like.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09455992&OS=09455992&RS=09455992
owner: Microsoft Technology Licensing, LLC
number: 09455992
owner_city: Redmond
owner_country: US
publication_date: 20090612
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A simple yet remarkably powerful tool of selfish and malicious participants in a distributed system is \u201cequivocation\u201d: making conflicting statements to others. Multiple techniques exist to combat the ability of participants to effectively equivocate within distributed systems. For instance, envision that a distributed system consists of participants \u201cA\u201d, \u201cB\u201d, and \u201cC\u201d. Here, when Participant C sends a message to Participant A, Participant A may ask Participant B if, in the past, Participant C has sent a conflicting message to Participant B. If Participant B answers in the affirmative, then Participant A may determine that Participant C is untrustworthy, and may remove Participant C from the view of Participant A. While these and other existing techniques prove effective, more efficient techniques may exist.","Techniques for efficiently and securely mitigating the effects of participant equivocation within a distributed system are described herein. These techniques provide a trusted hardware component for each of multiple participants of the distributed system. In some instances, this trusted hardware component includes a monotonically non-decreasing counter and a cryptographic key.","Just before a first participant sends a message to a second participant, the first participant may provide a representation (e.g., a hash value) of the message to the trusted hardware component of the first participant. In response, the trusted hardware component may increment the counter and sign a statement attesting that the trusted hardware component incremented the counter in response to receiving the representation of the message. At this point, the trusted hardware component may provide the signed statement to the first participant, who in turn may store the signed statement in a log maintained in un-trusted memory of the first participant. The first participant may also provide the signed statement along with the actual message to the second participant. The second participant may then verify the validity of the message with use of the signed statement and, in some instances, with use of a log provided by the first participant upon request.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The term \u201ctechniques,\u201d for instance, may refer to device(s), system(s), method(s) and\/or computer-readable instructions as permitted by the context above and throughout the document.","The disclosure describes techniques for utilizing trusted hardware components for mitigating the effects of equivocation amongst participant computing devices of a distributed system. For instance, a distributed system that employs a byzantine-fault-resilient protocol\u2014that is, a protocol intended to mitigate (e.g., tolerate, detect, isolate, etc.) the effects of byzantine faults\u2014may employ these techniques. Other types of distributed protocols may also use these techniques to mitigate the effects of faults.","To mitigate the effects of faults, the techniques may utilize a trusted hardware component comprising a non-decreasing counter and a key. This hardware component may be \u201ctrusted\u201d in that the respective participant computing device (also referred to as a \u201cparticipant device\u201d or, simply, a \u201cparticipant\u201d) cannot modify the contents of the component in any manner other than according to the prescribed procedures, as described below. In addition, this hardware component is \u201ctrusted\u201d in that participants of the distributed protocol cannot inspect the contents of the device, such as any stored private or symmetric keys described below. Furthermore, the trusted hardware component may couple to the participant computing device in any suitable manner, such as via a universal serial bus (USB) connection, directly on the motherboard of the computing device or in any other manner.","Before a first participant computing device sends a message to a second participant device, the first participant may initially provide a representation (e.g., a hash value or any other suitable representation) of the message to the trusted hardware component associated with the first participant device. In response, the trusted hardware component may increment a current value of the counter of the component to a new, greater value. For example, the counter may update the value from \u201c0\u201d to \u201c1\u201d for a first message representation.","Furthermore, the trusted hardware component may use the key of the component to sign a statement attesting to the incrementing of the counter in association with the representation of the message.","At this point, the trusted hardware component may provide the signed statement to the participant device (that is, to a portion of the device outside of the trusted hardware component). Upon receiving the signed statement, the participant device may store the signed statement in a log that maintains the signed statements received from the trusted hardware component for the current conversation and protocol.","Furthermore, the participant device may maintain this log in un-trusted memory (e.g., a conventional disk drive or the like) or otherwise external to the trusted hardware component. By doing so, the techniques allow the size of the trusted hardware component to remain small. In addition, this allows the log to continue to grow in size, with only the size of the disk drive of the computing device constraining its size. As such, storing the log in un-trusted memory may further allow for a nearly unbounded size of the log, given the size of conventional disk drives. As a result, the participant computing device may truncate this log according to the protocol\u2014rather than by necessity due to storage-size constraints.","In any event, after logging this signed statement, the participant device may send the signed statement along with the associated message to the second participant device. In response, the second participant device may verify the validity of the signed statement to ensure that the trusted hardware component of the first participant device did indeed attest to the signed statement. The trusted hardware component may verify the statement with use of a public key of the trusted hardware component associated with the first participant device, or with a symmetric key shared by both trusted hardware components, as discussed below.","In addition, the second participant device may store the signed statement (or an indication based on the signed statement) for the purpose of ensuring a complete understanding of everything the first participant device has said in the conversation. Stated otherwise, the signed statement along with the associated counter values may enable the second participant device to maintain a record of messages sent by the first participant device. This information may help the second participant device track what the first participant device has said in order to help determine whether the first participant device has made equivocating statements to other participant devices.","In addition, if the second participant device desires to view some or all of the statements made by the first participant device (e.g., because the second participant is new to the conversation or for any other reason), the second participant device may request a portion or the entire log that the first participant device maintains. In response, the first participant device, which may then send some or all of the log that the first participant device maintains to the second participant.","In response to receiving the log, the second participant may verify the validity of the signature and may thereafter use the received log to inspect previous messages sent by the first participant. If the second participant locates a discrepancy or another cause of concern in the log, the second participant may choose to remove the first participant from the view of the second participant in the protocol (i.e., may no longer continue communicating with the first participant).","The discussion begins with a section entitled \u201cExample Computing Architecture,\u201d which describes one non-limiting environment that may implement the described techniques. This section depicts and describes a high-level architecture, as well as illustrative components of a participant computing device. Next, a section entitled \u201cExample Flow Diagrams\u201d illustrates and describes the techniques in the context of participant devices setting up a distributed protocol and using the described techniques to mitigate the effects of equivocation within the protocol. This section includes sub-sections entitled \u201cAllocating Counters\u201d, \u201cVerifying Message Validity\u201d, \u201cGenerating Symmetric Keys\u201d and \u201cMaintaining Security in the Event of a Power Failure\u201d. A third section, entitled \u201cExample Processes\u201d, illustrates and describes example processes using the described techniques in a distributed system. A fourth section (\u201cAdditional Details of Example Techniques\u201d) and its sub-sections follow and describe additional details of certain implementations of the techniques. Finally, the discussion ends with a brief conclusion.","This brief introduction, including section titles and corresponding summaries, is provided for the reader's convenience and is not intended to limit the scope of the claims, nor the proceeding sections.","Example Computing Architecture",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","100","102","1","102","2","102","104","102","1","104","104"]},"Within the distributed system, the computing devices ()-(N) may converse via any agreed-upon distributed protocol. For instance, the computing devices ()-(N) may employ a byzantine-fault-resilient protocol\u2014a protocol designed to mitigate the effects of byzantine faults within a distributed system. A byzantine-fault-resistant protocol may include a byzantine-fault-tolerant protocol, a byzantine-fault-detection protocol and\/or a byzantine-fault-isolation protocol, possibly in addition to any other protocol that mitigates the effects of byzantine faults. As illustrated, the architecture  may also include a trusted administrator  to assist in setting up the distributed protocol that the computing devices ()-(N) may employ, as discussed in greater detail below.","Each of the computing devices ()-(N) may include a respective processor (), (), . . . , (N) as well as memory (), (), . . . , (N). In addition, each of the computing devices ()-(N) may include or otherwise have access to a respective trusted hardware component (), (), . . . , (N). In some instances, and as illustrated, the trusted hardware components ()-(N) reside physically proximate or within the respective computing devices ()-(N). For instance, one or more of the trusted hardware components ()-(N) may reside as a piece of hardware physically within a housing of a respective computing device ()-(N) or may connect via a serial bus (e.g., USB) or the like. In other instances, meanwhile, one or more of the trusted hardware components ()-(N) may reside remotely (e.g., over a network) from a corresponding computing device ()-(N).","In either instance, the trusted hardware components ()-(N) function to efficiently and securely assist in preventing the computing devices ()-(N) from effectively making equivocating statements within the distributed system. Stated otherwise, these components help to mitigate the effects of any such equivocation within the system.","As illustrated, each trusted hardware component ()-(N) may include a meta-counter (), (), . . . , (N) and a physical portion of memory (), (), . . . , (N) reserved for allocation to one or more logical counters (\u201cPhysical Counter Memory\u201d). Each meta-counter ()-(N) essentially comprises a counter of logical counters. That is, and as described below, a meta-counter may assign its current value to a new logical counter when the respective participant device requests allocation of a new logical counter.","In addition, each trusted hardware component ()-(N) may comprise a unique identifier (), (), . . . , (N) associated with the hardware component and a certificate (), (), . . . , (N) that leads back to a root of trust that can verify the validity of the trusted hardware component with reference to the unique identifier ()-(N).","Each trusted hardware component ()-(N) may provide its respective certificate ()-(N) to the other computing devices participating in the protocol to allow these devices to verify the legitimacy of the trusted hardware component. Note that, in some instances, each trusted hardware component ()-(N) may refrain from storing this certificate ()-(N) but may instead provide the certificate to the devices in other ways. For example, in some instances the certificate may reside on the physical packaging of the trusted hardware component, thus allowing a user of the trusted hardware component to share the certificate with the other participant devices.","In addition, each trusted hardware component ()-(N) may include a public key (), (), . . . , (N) and a corresponding private key (), (), . . . , (N). The trusted hardware component ()-(N) may use the private key ()-(N) to sign certain attestations, as discussed in detail below, while the hardware component may provide its respective public key ()-(N) to the other participant devices to allow these devices to verify the signature. Again, however, note that the trusted hardware components ()-(N) may refrain from actually storing the public keys ()-(N). Instead, a respective trusted hardware component may again provide the public key in other ways. For example, the public key may reside on the physical packaging of the trusted hardware component, thus allowing a user of the trusted hardware component to share the public key with the other participant devices. Each trusted hardware component ()-(N) may also comprise logic (), (), . . . , (N) comprising computer-executable instructions and embodied as hardware, software or a combination thereof.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["110","1","102","1","128","1","128","2","128","130","1","130","2","130","132","1","132","2","132"]},"In combination, these elements enable a secure and efficient fault-resilient distributed system. First, when the participant computing devices ()-(N) set up a distributed protocol, each computing device ()-(N) asks the respective trusted hardware component ()-(N) to allocate a logical counter to the new protocol. In response, the logic ()-(N) of the hardware component locates an available logical counter and asks the respective meta-counter ()-(N) to assign an identifier to the logical counter. In some instances, this logical counter comprises a monotonically non-decreasing counter as discussed in detail below.","In addition, the logic ()-(N) may associate the private key ()-(N) of the local hardware component or a symmetric key (), (), . . . , (N) common to each hardware component to the logical counter and, hence, to the protocol. As discussed in detail below, the trusted administrator  may include a symmetric key generation module  (stored in memory  and executable on one or more processors ) to generate the shared symmetric key ()-(N) and to provide copies of the respective symmetric key to the trusted hardware components ()-(N).","After set up of the protocol and allocation of the counters, the computing device () may desire to send a message to one or more other participant devices of the architecture . At this point, the trusted incrementer module () may first send a representation (e.g., a hash value) of the message to the trusted hardware component () associated with the participant device. The logic () of the trusted hardware component () may receive this representation of the message and, in response, may increment the assigned logical counter by one or by another value specified by the device () (e.g., specified with the sending of the representation of the message). In addition, the logic () may use either the private key () or the symmetric key () to sign a statement attesting to the increment of the counter in association with the representation of the message.","At this point, the logic () of the trusted hardware component () may store the signed statement to a respective recent attestation queue (RAQ) (), (), . . . , (N), which may store a predetermined number of recent signed statements (e.g., five, ten, fifty, one hundred, etc.). In addition, the logic () may provide the signed statement to the trusted incrementer module () of the participant computing device (). In response, the trusted incrementer module () may store the signed statement in the log () associated with this particular conversation. As discussed in detail below, this log () may store some or all of the previously-signed statements provided by the trusted hardware component (). With this information, the participant computing device () may show to the other participant devices ()-(N) each statement that the participant computing device () has made during the conversation.","After storing this signed statement in the appropriate log (), the participant computing device () may send the message along with the signed statement to the intended recipient participant device. In response to receiving this signed statement, the receiving participant device may either use the public key to verify the signed statement (if the trusted hardware component () signed the statement with the private key ()) or the device may pass the signed statement to its associated trusted hardware component (if the trusted hardware component () signed the statement with the symmetric key ()). In the latter instances, the trusted hardware component may attempt to verify the message and, in order to keep the symmetric key secret, may simply inform the receiving computing device as to whether or the not the signature was verified.","In addition to maintaining each device's own log ()-(N), each participant computing device ()-(N) may maintain the information ()-(N) about the other participant devices. More particularly, this information ()-(N) may comprise information relevant to the particular protocol in which the devices participate. This information () may include each signed statement sent by the other participant devices (i.e., may comprise each log of each other participant device) or may instead include an indication as to whether everything that each participant device previously said has been consistent and non-equivocating. In either instance, by requiring each participant device to send a signed statement along with each message, each participant device may determine whether or not each other device has been making equivocating statements or is otherwise untrustworthy.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 1","FIG. 1","FIG. 1"],"b":["102","1","102","1","112","1","114","1","114","1","112","1"]},"Then, when the computing device () first requests to set up a new protocol while employing the trusted hardware component (), the logic () may assign the current value (one) of the meta-counter () to the deployed logical counter. In addition, the logic () may increment the meta-counter by one (here, from one to two).",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 2","b":["116","1","202","1","202","2","202","126","1","112","1","202","1","202","4","116","1","112","1","102","1"]},"As illustrated, each logical counter ()-(P) may be associated with a counter identification (\u201ci\u201d) , a current counter value (\u201cc\u201d) and a key (\u201cK\u201d). As discussed immediately above, the counter ID \u201ci\u201d may comprise the value of the meta-counter () when the logic () originally deploys the particular logical counter. As such, even if a future logical counter employs the same physical memory space as a previous logical counter, the future logical counter will be associated with a unique, higher-value counter ID (because the meta-counter can only be increased, never decreased).","The counter value \u201cc\u201d, meanwhile, comprises the current value of the counter. As discussed above, before the participant computing device () sends a message to another participant device, the participant device () may send a representation of the message to the trusted hardware component (). In turn, the logic () may increment the current value, c, of the counter (or move the counter value in place as discussed below), sign a statement attesting to the increment and provide the signed statement to the computing device (). As such, the counter value  comprises a value that steadily increases as the participant device () sends communications within the conversation associated with the logical counter (). The counter value  can only be reset if a new logical counter is associated to this counter, in which case the meta-counter assigns a different (higher) counter ID () to this counter.","Finally, the key  comprises the key associated with the particular counter and, hence, with the particular protocol and conversation associated with the counter. As discussed above and as discussed in greater detail below, the logic () may assign the unique private key () to the logical counter and protocol or may assign a commonly-held symmetric key to the logical counter and protocol.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2","FIG. 2"],"b":["102","1","130","1","112","1","102","1","130","1","112","1","102","1","130","1","1","130","1","2","130","1","4","202","1","4","112","1"]},"To illustrate a single signed statement from the log associated with the logical counter (), this example and non-limiting log includes the following statement: \u201c4:2=>3:Y\u201d as signed by the symmetric key. This statement indicates that the trusted hardware component () incremented the logical counter () (having an \u201ci\u201d of 4) from a \u201cc\u201d value of 2 and to a next value (\u201cc\u2032 (prime)\u201d) of 3. Furthermore, this statement indicates that the trusted hardware component incremented the counter in response to the participant device () sending a representation of a message \u201cY\u201d to the trusted hardware component ().","Example Flow Diagrams","Having described an illustrative architecture that may implement the trusted hardware components ()-(N) in a distributed system, as well as details of the trusted hardware components themselves, the discussion proceeds to an example process for allocating a logical counter to a particular protocol. Next, the discussion describes use of the trusted hardware components ()-(N) in practice. Finally, the discussion describes an example process for generating symmetric keys for these hardware components as well as an example process for maintaining security of the logs in the event of a power failure of a participant device.","Allocating Counters",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 2"],"b":["300","202","102","1"]},"The process  includes an operation , at which point the computing devices ()-(N) set up a distributed conversation to follow a particular protocol. For instance, these devices may set up a byzantine-fault-resilient protocol or another distributed protocol. In the former instances, the devices may set up a byzantine-fault-tolerant protocol, a byzantine-fault-detection protocol, a byzantine-fault-isolation protocol or another protocol designed to mitigate the effects of byzantine faults.","At operation , the computing device () may request that the trusted hardware component () assign a new logical counter to the new conversation at operation . In response, the logic () of the trusted hardware component () may determine a current value of the meta-counter () of the trusted hardware component (). In the instant example, the meta-counter () has a current value of five. As such, the logic () finds a free logical counter and assigns the counter identity (i) of \u201c5\u201d to this logical counter at operation . In addition, the value of the meta-counter is increased, by one (in this example) to a new current value of \u201c6.\u201d","At this point, the logic () of the trusted hardware component () may also zero out the counter value (c) of any previous logical counter that occupied this physical counter space as well as the previous key used by this previous logical counter at operation . For instance, if a previous logical counter had been used in this physical memory space, then the values from that previous logical counter may still exist in the memory. As such, the logic () may delete this information to make way for the new logical counter.","In addition, at operation  the logic () may also assign, to this logical counter, a key chosen by the computing device () for this protocol. For instance, if the computing devices ()-(N) agree to use respective private keys for this protocol, then the logic () may assign the private key () to the counter. In other instances, meanwhile, the computing devices ()-(N) may agree to use a symmetric key that each trusted hardware component (and each logical counter used for the protocol) will share. In these instances, the computing devices ()-(N) may request that the trusted administrator  generate a symmetric key (as illustrated and described below with reference to ). Here, after receiving the symmetric key from the trusted administrator , the computing device () may assign the symmetric key () to this counter. In either instance, the completed process  results in a trusted hardware component () having a logical counter configured for use in the new conversation in which the computing device () participates.","Verifying Message Validity",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIGS. 4-6","FIG. 3"],"b":["400","112","1","400"]},"The process  begins at operation  with the computing device () sending a message to another computing device participating in the distributed protocol. To do so, however, the techniques may call for the computing device () to first request and receive an attestation from the trusted hardware component (). As such, the process  may first include the computing device () sending, to the trusted hardware component (), a hash of the message \u201cW\u201d that is for distribution to the other participant. While this process describes hashes, it is to be appreciated that other implementations may employ other suitable representations of the message, including the message itself.","The process  continues to operation , at which point the trusted hardware component () may increment the logical counter assigned to this particular conversation and protocol. For instance, the trusted hardware component () may increment logical counter \u201c5\u201d from a current counter value of \u201c0\u201d to a new counter value of \u201c1\u201d. In addition, the trusted hardware component () may sign a statement attesting that the trusted hardware component () incremented the counter at least in part in response to receiving the hash (\u201c(W)\u201d) of the message from the participant device (). Here, the trusted hardware component () may sign that statement with a symmetric key that is common to each trusted hardware component of the protocol.","In some implementations, this signed statement may take the following form: \u201c(i:c=>c\u2032:M)K\u201d, where M comprises the message or the representation of the message. As such, the example signed statement here comprises the following: \u201c(5:0=>1:W)K\u201d. This statement indicates that the trusted hardware component () incremented the logic counter  from a value of 0 to a value of 1 in response to receiving the representation of the message W. In addition, the trusted hardware component () signed this statement with the symmetric key ().","The trusted hardware component () may store the signed statement in the recent attestation queue (RAQ) () at operation . While this operation is illustrated as occurring after the incrementing of the counter at operation , in some implementations the signed statement is stored atomically with the incrementing of the counter or, in some instances, even before the counter is incremented. As discussed above, the RAQ () may store a predetermined number or size of the most recent statements that the trusted hardware component () has signed. As discussed below in detail with reference to , the RAQ is useful to maintain log legitimacy in the event of a power failure. Returning to the process , meanwhile, the trusted hardware component () may also send the signed statement to the computing device ().","Next, at operation , the computing device () may write the signed statement to the log () associated with this conversation and protocol. In some implementations, this log resides in un-trusted (that is, conventional) memory of the device and outside of the trusted hardware component (). Note that while the log () resides in un-trusted memory, the log nonetheless comprises a trusted log because of the unique signed statement(s) stored therein. Operation  then represents that the computing device () may send the actual message, W, and the corresponding signed statement \u201c(5:0=>1:W)K\u201d to the recipient participant devices, such as the participant device (N).",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 5","b":["400","412","402","410","102","1","112","1","102","1"]},"At operation , the participant device (N) may request the log () associated with the current conversation and protocol from the participant device (). In addition, the participant device (N) may also include a randomly-generated \u201cnumber used once\u201d, or \u201cnonce\u201d. That is, the device (N) may include a nonce that would be exceedingly difficult and statistically unlikely for the receiving device () to predict. In addition, the requesting device (N) may request that the trusted hardware component () move the logical counter in place in response to receiving the nonce and sign a statement attesting to that move. As such, the requesting device can assure itself that the participant device () sent the full contents of the log (or, at least, that it has not avoided sending more recent signed statements than what is provided in the sent log).","At operation , the computing device () may request that the trusted hardware component () move the counter in place in response to receiving the nonce and sign a statement attesting to the move. At operation , the trusted hardware component () may oblige by moving in place the counter and signing the statement. As illustrated, this statement comprises the following: \u201c5:7=>7:n\u201d. At operation , the trusted hardware component () may then send the signed statement to the computing device ().",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 6","b":["400","102","1","130","1","102","1","422","400","102","1","102","1","102","1"]},"At operation , the computing device () then sends the log to the requesting device (N). In addition, in instances where computing device () does not store the signed statement associated with the nonce within the log, computing device () may also send this signed statement along with the log to the requesting computing device (N).","Generating Symmetric Keys",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIGS. 7-8","b":["700","112","1","700","102","1","702","704","112","1","122","1","120","1","106","134","1"]},"At operation , the trusted administrator  may generate a symmetric key with use of the symmetric key generation module  of . The trusted administrator  may then verify the validity of some or all of the trusted hardware components () with use of the received certificates at operation . That is, the trusted administrator  may traverse each certificate to the corresponding root of trust. The trusted administrator  may then determine whether the root of trust is indeed a trusted entity. If so, then the trusted administrator  may also encrypt a copy of the symmetric key ()-(N) with each public key of each trusted hardware component ()-(N) at operation .",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 8","b":["700","106","134","1","102","1","710","712","102","1","112","1","124","1","112","1","112","1","134","1","124","1","112","1"]},"Next, each trusted hardware component ()-(N) may store the symmetric key at operation  and assign this symmetric key to the logical counter associated with the newly-set-up conversation. At this point, each participant device ()-(N) is able to participate in the conversation with use of the verification techniques described immediately above with reference to .","Maintaining Security in the Event of a Power Failure",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 9","b":["900","130","1","102","1"]},"The process  includes an operation . This operation may include a computing device () requesting a signed statement attesting to an increment of the counter by the trusted hardware component () in response to the device () providing a representation of a message to the component (). In some instances, before submitting the representation of the message to the trusted hardware component (), the computing device () may log the actual message itself, as discussed below.","In addition to requesting a signed statement, operation  represents that the trusted hardware component () may receive the hash value of the message, increment the counter (from 0 to 1), sign the statement (\u201c5:0=>1:W\u201d) with the symmetric key () and contemporaneously store this signed statement in the RAQ (). In some instances, the RAQ () is read-only in the event of a power failure or other condition that prevents the computing device () from updating the log maintained in un-trusted storage coincidently with the incrementing of the counter.","Operation  represents that a power failure may occur at the computing device () sometime between: (1) the contemporaneous signing and storing of the statement in the RAQ (), and (2) the sending of the signed statement to the computing device ().","Operation  represents that upon restart, the computing device () may request to view the signed statements stored within the RAQ () for comparison with the log () of the device () stored outside of the trusted hardware component (). Here, the computing device () may find the signed statement from above stored in the RAQ (). The device () may also recognize that the log () does not store this signed statement. As such, at operation  the device () may store this signed statement in the log (), thus avoiding the occurrence of an incomplete log. To do so, the computing device () may determine that the signed statement (comprising a representation of the message) stored in the RAQ () corresponds to the message that the computing device () stored in the log before the power failure occurred. After making this determination, the computing device () may store the retrieved signed statement in the log () in association with the message that corresponds to the retrieved signed statement.","Example Processes",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIGS. 10-11","b":["1000","1100"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 10","b":["1000","1002","1004"]},"The process  then proceeds to operation , at which point the signed statement may be stored in a log associated with the byzantine-fault-tolerant protocol and maintained outside of the trusted hardware component. Finally, at operation  the first computing device may provide the message and the signed statement to the second computing device.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 11","b":["1100","1102","1104"]},"The process then proceeds to operation , at which point the trusted hardware component may sign a statement with the key attesting that the trusted hardware component incremented the counter at least in part in response to the receiving of representation of the message. Finally, the process concludes at operation , where the trusted hardware component may provide the signed statement to the first computing device.","Additional Details of Example Techniques","The above discussion has described and illustrated techniques for using the trusted hardware components ()-(N) in a distributed system running a distributed protocol to mitigate the effects of faults caused by an equivocating device. The following sub-sections describe portions of non-limiting embodiments of these techniques in greater detail.","Overview of One Example Embodiment","To gain the benefits of the described techniques, a user may attach the trusted hardware component () to the device of the user. Unlike a typical trusted platform module (TPM), which attests to states of the associated computing device, the API of the trusted hardware component () may depend only on its internal state. As such, the trusted hardware component () may not need access to the state of the computing device. Instead, in some instances the trusted hardware component () only uses an un-trusted channel over which it can receive input and produce output, so even USB may be sufficient.","As described above, when computing device () wishes to send a message \u201cm\u201d to computing device (), device () includes an attestation from the trusted hardware component () that: (1) binds m to a certain value of a counter, and (2) ensures computing device () that no other message will ever be bound to that value of that counter, even messages sent to other participant devices. A trusted hardware component enables such attestation by using a counter that monotonically increases with each new attestation or \u201csigned statement\u201d attesting to the binding. In this way, once the participant computing device () has bound a message m to a certain counter value c, this device will never be able to bind a different message to that value.","Some protocols may benefit from using multiple counters. In theory, anything done with multiple counters can be done with a single counter, but multiple counters allow certain performance optimizations and simplifications, such as assigning semantic meaning to a particular counter value. Furthermore, the user of a trusted hardware component may participate in multiple protocols, each requiring its own counter or counters. Therefore, a trusted hardware component provides the ability to allocate new counters as discussed above. However, the techniques should identify each of them uniquely so that a malicious user cannot create a new counter with the same identity as an old counter and thereby attest to a different message with the same counter identity and value.","As a performance optimization, the trusted hardware component () allows its attestations to be signed with shared symmetric keys, which may improve its performance over using asymmetric cryptography. To ensure that participants cannot generate arbitrary attestations, the symmetric key is stored in trusted memory, so that users of the participant devices cannot read it directly. Symmetric keys are shared among the trusted hardware components using a mechanism that ensures they will not be exposed to un-trusted parties.","Notation","The following discussion uses the notation (x)to mean an attestation of x that could only be produced by an entity knowing K. If K is a symmetric key, then this attestation can be verified only by entities that know K; if K is a private key, then this attestation can be verified by anyone, or more accurately anyone who knows the corresponding public key. The following discussion also uses the notation {x}to mean the value x encrypted with public key K, so that it can only be decrypted by entities knowing the corresponding private key.","State of the Trusted Hardware Component","This sub-section describes an internal state of an example trusted hardware component (). Each trusted hardware component is endowed by its manufacturer with a unique identity \u201cI\u201d and a public\/private key pair (K, K). In some instances, I is the hash of K. The manufacturer may also include in the trusted hardware component an attestation \u201cA\u201d that proves the values I and Kbelong to a valid trusted hardware component, and therefore that the corresponding private key is unknown to un-trusted parties.","This discussion leaves open the question of what form A will take. This attestation is meant to be evaluated by users and\/or by participant devices rather than trusted hardware components and, as such, may take various forms. For instance, it might be a certificate chain leading to a well-known authority trusted to oversee the production of trusted hardware components and ensure their secrets are well kept.","Another element of the state of the trusted hardware component is the meta-counter \u201cM\u201d, discussed above. Whenever the trusted hardware component creates a new logical counter, the trusted hardware component gives the new logical counter identity M and then increments M by one. This allows users (and participant devices) to create new counters at will, without sacrificing the non-monotonicity of any particular counter. Because M only goes up, once a counter has been created it can never be recreated by a malicious user attempting to reset it.","Yet another element is \u201cQ\u201d (corresponding to RAQ ()), a limited-size first-in-first-out (FIFO) queue containing the most recent few counter attestations generated by the trusted hardware component. Storing these recent attestations in the trusted component is useful for allowing users to recover from power failures, described above and in more detail below.","The state of the trusted hardware component may also include an array of counters, not all of which have to be in use at a time. For each in-use counter, the state includes the counter's identity \u201ci\u201d, its current value \u201cc\u201d, and its associated key \u201cK\u201d. The identity \u201ci\u201d is, as described before, the value of the meta-counter when the counter was created. The value c is initialized to 0 at creation time and cannot go down (unless the counter is reset, which changes the counter's identity \u201ci\u201d). The key K contains a symmetric key to use for attestations of this counter; if K=0, attestations will use the private key Kinstead.","Trusted Hardware Component Application Programming Interface (API)","In some instances, the API of the trusted hardware component includes a call labeled \u201cAttest\u201d. Attest takes three parameters: i, c\u2032, and h. Here, i is the identity of a counter to use, c\u2032 is the requested new value for that counter, and h is a hash of the message m to which the user wishes to bind the counter value. Attest works as follows in some instances:","Attest(i, c\u2032, h, n)\n\n","Note that Attest allows calls with c\u2032=c. This is crucial to allowing peers to attest to what their current counter value is without incrementing it. To allow for this while still keeping peers from equivocating, this example of the trusted hardware component includes both the prior counter value and the new one in the signed statement. One can easily differentiate attestations intended to learn a trusted hardware component's current counter value (c=c\u2032) from attestations that bind new messages (c<c\u2032).","Verifying Attestations","Suppose that the computing device () with the trusted hardware component () wants to send a message to the computing device () with the trusted hardware component (). The computing device () first invokes \u201cAttest\u201d on the trusted hardware component () using the hash of the message, and may thereby obtain an attestation, a. Next, the device () sends the message to the device () along with this attestation. However, for the device () to accept this message, the device () has to be convinced that the attestation was created by a valid trusted hardware component. There are two cases to consider: first, that the attestation used the private key of the trusted hardware component () and, second, that the attestation used a shared symmetric key.","In the first case, an API call such as a call \u201cGetCertificate\u201d may be useful. This call returns a certificate C of the form (I, K, A), for which I is the identity of the trusted hardware component, Kis its public key, and A is an attestation that I and Kbelong to a valid trusted hardware component. The computing device () can call this API routine and send the resulting certificate to the device (). The device () can then learn the public key of the device () and verify that this is a valid public key of a trusted hardware component. After this, the device () can verify the attestation that the device () attached to the message, as well as any future attestations that the device () attaches to messages.","In the second case, an API call such as a call \u201cCheckAttestation\u201d may be useful. When CheckAttestation(a, i) is invoked on a trusted hardware component, the trusted hardware component checks whether a is the output of invoking Attest on a trusted hardware component using the same symmetric key as the one associated with the local counter i. It returns a boolean indicating whether this is so. So, if the device () sends the device () an attestation signed with a shared symmetric key, the device () can invoke CheckAttestation on the trusted hardware component of the device to learn whether the attestation is valid.","Allocating Counters","Since a trusted hardware component may contain many counters, another important component of the API is the creation of these counters. The trusted hardware component creates new logical counters and allows counters to be deleted, but never resets an existing counter. Logical counters are identified by a unique ID, generated using a non-deletable, monotonic meta-counter M. Every trusted hardware component may have precisely one meta-counter, and when it expires, the trusted hardware component can no longer be used. The described techniques may compensate for this by making M 64 bits, by only incrementing M, and by assigning no semantic meaning to the value of M. The trusted hardware component exports a \u201cCreateCounter\u201d function that allocates a new counter with identity i=M, initial value 0, and initial key K=0; and returns this new identity i. The current value of M is then incremented by one. When the device no longer needs the counter, the device may call \u201cFreeCounter\u201d to free it and thereby provide space in the trusted hardware component for a new counter.","Using Symmetric Keys","The trusted hardware component allows its attestations to be signed with shared symmetric keys, which may improve its performance over using asymmetric cryptography or even secure hashes. A session refers to a set of users using a single symmetric key for a certain purpose. Creating a session requires a session administrator (i.e., trusted administrator ), a user trusted by all participants to create a session key and keep it safe (i.e., trusted to not reveal it to any un-trusted parties).","To create a session, the \u201csession administrator\u201d or \u201ctrusted administrator\u201d simply generates a random, fresh symmetric key as the session key K. To allow a certain device to join the session, the administrator asks that device for the certificate of the trusted hardware component of the device. If the administrator is satisfied that the certificate represents a valid trusted hardware component, the administrator encrypts the key in a way that ensures it can only be decrypted by that trusted hardware component. Specifically, the administrator creates {KEY, K}K, where Kis the public key in the certificate. The administrator then sends this encrypted session key to the device that wants to join the session.","Upon receipt of an encrypted session key, the device can join one of his counters to the session by using an API call such as a call \u201cImportSymmetricKey(S, i)\u201d. This call checks that S is a valid encrypted symmetric key, meant to be decrypted by the local private key. If so, the trusted hardware component decrypts the session key and installs it as K for local counter i. From this point forward, attestations for this counter will use the symmetric key. Also, the device will be able to verify any attestation from a trusted hardware component using this symmetric key by invoking \u201cCheckAttestation(a, i)\u201d.","Handling Power Failures","As discussed above, the techniques described herein also provide a safe and efficient manner of handling a power failure. If there is a power failure between the time that the trusted hardware component advances its counter and the application of the participant device writes the attestation to disk, then the attestation is lost. This can be problematic for many protocols, which rely on the device being able to attest to a message with a particular counter value. For instance, if the computing device () cannot produce an attestation for counter value v, another computing device () may suspect this is because device () has already told a device (N) about some message m associated with that counter value. Not wanting to be wrong about the absence of such a message, the device () may lose all willingness to trust the device (). In addition, the computing device can not simply \u201crepeat\u201d the attestation for counter value v, because the counter value of the counter in the trusted component has already been incremented. Because the counter may not be decreased (unless reset), no other message can be attested to using a counter value v.","To alleviate this, a trusted hardware component includes a queue Q containing the most recent attestations it has created. To limit the storage requirements, this queue only holds a certain fixed number k of entries, perhaps 10. In the event of a power failure, after recovery the device can invoke an API call such as a call \u201cGetRecentAttestations\u201d to retrieve the contents of Q. Thus, to protect against power failure, a device is to ensure that it writes an attestation to disk before the device makes a knext attestation request. As long as k is at least 1, the device can safely use the trusted hardware component for any application. Higher values of k are useful as a performance optimization, allowing greater pipelining between writing to disk and submitting attestations.","The techniques may also protect against a power failure that occurs to the trusted hardware component. The Attest algorithm ensures that the attestation is inserted into the queue before the counter is updated, so the trusted hardware component cannot enter a situation where the counter has been updated but the attestation is unavailable. It can, however, enter the dangerous situation in which the attestation is in Q, and thus available to the device, but the counter has not been incremented. This window of vulnerability could potentially be exploited by a user of a device to generate multiple attestations for the same counter value, if the user could arrange to shut off power at precisely this intervening time. However, the described techniques guard against this case by having the trusted hardware component check Q whenever it starts up. At startup, before handling any requests, it checks all attestations in Q and removes any that refer to counter values beyond the current one.","Local Adversaries","Mutually distrusting principals on a single computing device will share access to a single trusted hardware component, creating the potential for conflict between them. Although they cannot equivocate to remote parties, they can hurt each other. They can impersonate each other by using the same counter, and they can deny service to each other by exhausting shared resources within the trusted hardware component. Resource exhaustion attacks include allocating all available counters, submitting requests at a high rate, and rapidly filling the queue Q to prevent the pipelining performance optimization.","The operating system can solve this problem by mediating access to the trusted hardware component, just as it mediates access to other devices. In this way, the OS can prevent a principal from using counters allocated to other principals, and can use rate limiting and quotas to prevent resource exhaustion. Equivocation to remote parties is impossible, even if an adversary has root access to the computing device, since cryptography allows the trusted hardware component to communicate securely even over an un-trusted channel.","Use of the Trusted Hardware Component for Attested Append-Only Memory (A2M)","Attested Append-only Memory (A2M) is another proposed trusted hardware design with the intent of combating equivocation. A2M offers trusted logs, to which devices can only append. The fundamental difference between the designs of A2M and techniques describes herein is in the amount of state and computation required from the trusted hardware. To demonstrate that the decreased complexity of the described techniques is enough, the following sections discuss how to build A2M using the techniques described herein.","A2M Overview","A2M's state consists of a set of logs, each containing entries with monotonically increasing sequence numbers. A2M supports operations to add (append and advance), retrieve (lookup and end), and delete (truncate) items from its logs. The basis of A2M's resilience to equivocation is append, which binds a message to a unique sequence number. For each log q, A2M stores the lowest sequence number, L, and the highest sequence number, H, stored in q. A2M appends an entry to log q by incrementing the sequence number Hand setting the new entry's sequence number to be this incremented value. The low and high sequence numbers allow A2M to attest to failed lookups; for instance, if a user requests an item with sequence number s>H, A2M returns an attestation of H.","Trusted Logs with the Described Techniques","In the design of A2M using the described techniques, logs are stored in un-trusted memory as opposed to within the trusted hardware component. As in A2M, the techniques make use of two counters per log, representing the highest (H) and lowest (L) sequence number in the respective log q.","Algorithm 2, reproduced immediately below, illustrates the design's characteristics. Note the power of the API of the described techniques, as the design is built predominately on calls to an Attest function of a trusted hardware component. The described protocol also uses advance attestations for moving the high sequence number when appending to the log, and for moving the low sequence number when deleting from the log. The techniques perform status attestations of the low counter value to attest to failed lookups, and of the high counter to attest to the end of the log. No additional attestations are necessary for a successful lookup, even if the lookup is to a skipped entry. Conversely, A2M requires calls to the trusted hardware even for successful lookups.",{"@attributes":{"id":"p-0110","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Algorithm 2:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Init( )"},{"entry":"\u2003\u20031. Create low and high counters:"},{"entry":"\u2003\u2003\u2003\u2003L<= CreateCounter( ); H<= CreateCounter( )"},{"entry":"\u2003\u20032. Return {L, H}"},{"entry":"Append(queue q, value x)"},{"entry":"\u2003\u20031. Bind h(x) to a unique counter (the current \u201chigh counter\u201d):"},{"entry":"\u2003\u2003\u2003\u2003A <= Attest(H.id, H.ctr + 1, h(x))"},{"entry":"\u2003\u20032. Store the attestation in un-trusted memory:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003q.append(a, x)"},{"entry":"Lookup(queue q, sequence number n, nonce z)"},{"entry":"\u2003\u20031. If n < L, the entry was truncated. Attest to this by returning an"},{"entry":"\u2003\u2003attestation of the supplied nonce using the low-counter:"},{"entry":"\u2003\u2003\u2003\u2003Attest(L.id, L.ctr, h(FORGOTTEN||z))"},{"entry":"\u2003\u20032. If n > H, the query is too early. Attest to this by returning an"},{"entry":"\u2003\u2003attestation of the supplied nonce using the high-counter:"},{"entry":"\u2003\u2003\u2003\u2003Attest(H.id, H.ctr, h(TOOEARLY||z))"},{"entry":"\u2003\u20033. Otherwise, return the entry in q that spans n, i.e., the one such"},{"entry":"\u2003\u2003that a.c < n is less than or equal to a.c\u2032. Note that if n < a.c\u2032, this"},{"entry":"\u2003\u2003means n was skipped by an Advance."},{"entry":"End(queue q, sequence number n, nonce z)"},{"entry":"\u2003\u20031. Retrieve the latest entry from the given log:"},{"entry":"\u2003\u2003\u2003\u2003{a, x} <= q.end( )"},{"entry":"\u2003\u20032. Attest that this is the latest entry with a high-counter attestation"},{"entry":"\u2003\u2003of the supplied nonce:"},{"entry":"\u2003\u2003\u2003\u2003a\u2032 <= Attest(H.id, H.ctr, z)"},{"entry":"\u2003\u20033. Return {a\u2032, {a, x}}"},{"entry":"Truncate(queue q, sequence number n)"},{"entry":"\u2003\u20031. Remove the entries from un-trusted memory:"},{"entry":"\u2003\u2003\u2003\u2003q.truncate(n)"},{"entry":"\u2003\u20032. Move up the low counter:"},{"entry":"\u2003\u2003\u2003\u2003a <= Attest(L.id, n, FORGOTTEN)"},{"entry":"Advance(queue q, sequence number n, value x)"},{"entry":"\u2003\u20031. Append a new item with sequence number n:"},{"entry":"\u2003\u2003\u2003\u2003a <= Attest(H.id, n, h(x))"},{"entry":"\u2003\u20032. Store the attestation in un-trusted memory:"},{"entry":"\u2003\u2003\u2003\u2003q.append(a, x)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The resulting system of using the described techniques with A2M demonstrates that the described techniques can be applied to byzantine fault tolerant protocols, SUNDR protocols, and Q\/U protocols, among others. In addition, implementing trusted logs using the techniques described herein has several benefits over a completely in-hardware design like A2M. Because the described techniques store the logs in un-trusted storage, the techniques decouple the usage demand of the trusted log from the amount of available trusted storage. Conversely, limited by the amount of trusted storage, A2M must make more frequent calls to truncate to keep the logs small. Some systems, meanwhile, benefit from large logs, making the techniques described herein a more suitable addition.","Conclusion","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claims"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is described with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The same numbers are used throughout the drawings to reference like features and components.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 4-6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 7-8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 10-11"}]},"DETDESC":[{},{}]}
