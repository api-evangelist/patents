---
title: DV metadata extraction
abstract: A set of interfaces, data structures and events represent a DV metadata extraction tool. The DV metadata extraction tool includes an API (application programming interface) for describing DV metadata packs that are to be extracted from a DV data stream. The extraction API supports methods for specifying and removing DV metadata packs to be extracted from DV frames. The DV metadata extraction tool also includes an API for describing a container that holds DV metadata once it has been extracted from a DV frame. The container API supports methods for adding and removing DV structures to the container and for retrieving data from the container, removing data from the container, and iterating through the container. The DV metadata extraction tool also includes a collection of higher-level structures that represent unpacked DV metadata packs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08165449&OS=08165449&RS=08165449
owner: Microsoft Corporation
number: 08165449
owner_city: Redmond
owner_country: US
publication_date: 20031001
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure generally relates to processing multimedia data, and more particularly, to extracting metadata from DV formatted multimedia data.","DV is a digital video format used world-wide for digital video cameras. The DV format is an international standard that was created by a consortium of companies typically referred to as the DV consortium. DV, originally known as DVC (Digital Video Cassette), uses a metal evaporate tape to record very high quality digital video. The DV video specification, IEC 61834, specifies the content, format and recording method of data blocks forming helical records on the digital tape. It also describes the common specifications for cassettes, modulation method, magnetization and basic system data, for digital video cassette recording systems using 6.35 mm (\u00bc inch) magnetic tape, and the electrical and mechanical characteristics of equipment which provides for the interchangeability of recorded cassettes.","DV video information is carried in a data stream at a rate of about 29 megabits per second (3.7 MByte\/sec). A DV video frame typically includes 10 DIF sequences, each of which consists of 150 DIF blocks having 80 bytes of data each. In addition to video and audio data, each DV video frame includes extra data associated with the video and audio data called DV metadata.","DV metadata can include a wide range of data associated with the video data in a DV frame. For example, DV metadata can include the time and date that video was recorded, various settings on the camcorder at the time the video was recorded, and so on. According to IEC 61834-4, DV metadata is divided into 256 separate \u201cpacks\u201d. Although 256 packs are reserved for DV metadata, many of the packs have yet to be defined. Each pack consists of 5 bytes. The first byte in each DV metadata pack is the pack ID, and the next four bytes consist of binary fields.","The DV format permits each DV video frame to stand on its own without having to rely on any data from preceding or following frames. For example, the same metadata is repeated numerous times within a DV frame. The redundancy built into each DV frame and the wealth of additional data (i.e., metadata) inherent to the DV format make DV video an ideal format for editing. However, various difficulties prevent current DV editing applications from taking full advantage of the unique features of DV video that make it ideally suited for editing.","In a typical DV scenario, video is recorded and converted to digital form in a camcorder. The video data on the digital tape can be played in a digital tape drive, such as the one in the camcorder, in a DVCR, or in a standalone unit. DV data can be transferred electronically via firewire to a computer's hard disk. The transfer process is typically performed by a capture driver, a standalone utility, or a component of an editing application executing on a computer such as a desktop personal computer. During the transfer process, the DV data is \u201cwrapped\u201d into a file format commonly understood by computers, such as AVI for Windows or Quicktime for the Mac. Therefore, once the transfer process is finished, the DV data on the computer hard drive is wrapped in a file format that standard editing applications can process. Various editing applications, such as Adobe\u00ae Premiere\u00ae Pro, enable nonlinear video editing through real-time video and audio editing tools.","However, as indicated above, current DV editing applications take little or no advantage of the rich information provided in the DV video format that makes it ideally suited for editing. The main reason for this is that it is difficult to extract the DV metadata from within DV video frames. DV metadata extraction currently requires an application developer to write its own custom code for extracting specifically desired metadata. In addition, an extraction process implemented by a DV editing application would be very processor intensive, which would hinder the performance of other editing functions of the application. One consequence of these difficulties is that DV metadata is generally not exploited by most DV editing applications.","Accordingly, a need exists for a way to extract DV metadata from DV data streams.","Extraction of DV metadata from a DV data stream is described herein.","In accordance with one implementation, an instruction is received specifying additional per-frame DV metadata to be extracted from a DV data stream. The metadata is extracted from DV frames of the DV data stream.","In accordance with another implementation, metadata is stored in a container and the container is attached to a DV sample of a DV frame. The container is manageable to have additional DV metadata structures stored within it and to provide for the retrieval of metadata items that have been stored within it.","In accordance with yet another implementation, a DV metadata structure is stored within the container. The DV metadata structure is an unpacked version of a DV metadata pack. The DV metadata structure includes binary values unpacked from the DV metadata pack and a different variable name associated with each binary value.","Overview","The following discussion is directed to a set of interfaces, data structures and events for representing a DV metadata extraction tool. The DV metadata extraction tool includes an API (application programming interface) for describing DV metadata packs that are to be extracted from a DV data stream. The extraction API is called IMFExtractDVMetadata, and it supports methods for specifying and removing DV metadata packs to be extracted from DV frames. The extraction API also supports methods for determining the number of DV metadata packs in an extraction list and determining the ID of a DV metadata pack at a given index in the extraction list.","The DV metadata extraction tool also includes an API for describing a container that holds DV metadata once it has been extracted from a DV frame. The container API is called IMFDVMetadataContainer, and it supports methods for adding and removing DV structures to the container and for retrieving data from the container, removing data from the container, and iterating through the container. The DV metadata extraction tool also includes a collection of higher-level structures that represent unpacked DV metadata packs.","The DV metadata extraction tool is generally described within the context of the Media Foundation architecture by Microsoft\u00ae Corporation. However, it is noted that the DV metadata extraction tool is designed and described herein in a manner that enables its use in any suitable multimedia architecture.","Exemplary Environment",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104"]},"DV video input sources  can be any type of device or communication network capable of transferring DV video content to computer , including for example, portable storage media () (e.g., magnetic discs, media cards, optical discs), a DV video recording device () (e.g., a digital camcorder), or a network () such as the Internet, a corporate network, or a home network.","Video recording device () can be any of various digital recording devices capable of recording live-motion video and audio in DV format (i.e., on a digital tape) for later replay via a digital tape drive, for example, in a DVCR, a camcorder, or a personal computer such as computer . A video recording device () is typically capable of being connected directly to computer  using an i.LINK (IEEE 1394) or FireWire digital interface, so that DV video content can be edited directly on the computer .","Computer  may be implemented as various computing devices generally capable of receiving video content from various sources  and manipulating the video content for editing and playback through a resident multimedia architecture such as the Media Foundation architecture by Microsoft Corporation, for example. Computer  is otherwise typically capable of performing common computing functions, such as email, calendaring, task organization, word processing, Web browsing, and so on. In the described embodiments, computer  runs an open platform operating system, such as the Windows\u00ae brand operating systems from Microsoft\u00ae. Computer  may be implemented, for example, as a desktop computer, a server computer, a laptop computer, or other form of personal computer (PC). One exemplary implementation of computer  is described in more detail below with reference to .","As discussed in greater detail below with reference to the exemplary embodiments, computer  is generally configured with a multimedia architecture that includes a DV metadata extraction tool enabling the extraction of DV metadata from DV data.","Exemplary Embodiments",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 8"],"b":["102","2","102","102"]},"The DV metadata extraction tool  shown in  may operate in the context of a multimedia architecture  such as Microsoft's Media Foundation. However, the DV metadata extraction tool  is not limited to operation in such an architecture . Thus, the DV metadata extraction tool  might also be implemented, for example, as a stand alone component or a subcomponent of another application program. Prior to describing the DV metadata extraction tool , a brief description of the multimedia architecture  will be provided with reference to .","As shown in , multimedia architecture  includes various component layers: In addition, multimedia architecture  also generally includes supporting or associated media applications . Such applications  are illustrated in  separately from the multimedia architecture , but might also be shown as a part of the architecture . The component layers of multimedia architecture  include control component layer , core component layer , base component layer , development platform layer  and definition layer .","Components of control component layer  include media processor , basic editor , basic encoder , media session , topology loader , media engine , and source resolver . These components generally make up task oriented API's (application programming interfaces) that may be fully managed or un-managed. The control components  generally provide management functions that perform tasks such as linking together appropriate core layer components  for processing media. For example, the topology loader  checks the multimedia data type of an incoming media file and determines which processing components (i.e., , , , , ) of the core layer components  need to be linked into a processing chain in order to properly render the data type. Note that for purposes of this disclosure, the media data type is DV data. A media engine component  of the control layer  manages the processing of the data through the chain of processing components (i.e., , , , , ) assembled by the topology loader . For example, the media engine  pushes the data through the processing chain, controlling when to stop playback, start playback play backwards, jump to a particular time, and so on.","Core layer components  include media sources , metadata read\/write , MUX\/Dmux , transforms , and media sinks . Media sources  provide multimedia data through a generic, well-defined interface. The media sources  describe the presentation, including video data streams to be accessed. There are many implementations of media sources for providing multimedia data from different multimedia file types or devices. However, the present disclosure is directed to multimedia in a DV format.","The transforms  of core layer  each perform some type of transformation operation on multimedia data through a generic, well-defined interface. Transform examples include codecs, DSPs, video resizers, audio resamplers, statistical processors, color resamplers, and others. Although the MUX\/Dmux  (Dmux , hereinafter) is illustrated separately within core layer , it is one representation of a transform  that takes interleaved multimedia data as an input, and separates the data into individually useful media streams of multimedia data. Thus, in the context of this disclosure, the Dmux  is a DV Dmux  that, among other things, splits out the video and audio components of DV frames or samples from a DV media source .","The Dmux  is also illustrated within the multimedia architecture  of  as including DV metadata extraction tool . As described in further detail herein below, Dmux  supports DV metadata extraction through the DV metadata extraction tool . The DV metadata extraction tool  generally allows the user to create and manage an extraction list of DV Metadata packs to be extracted from a DV data stream. Once a DV metadata pack ID is added to the extraction list, the DV Dmux  extracts the associated DV metadata pack from each DV frame as it splits out the video and audio components of the DV frame. The DV Dmux  stores the DV metadata pack in a container and attaches the container to the outgoing video sample as an extended attribute. Although the DV metadata extraction tool  is discussed herein in conjunction with, or as a part of, Dmux , this is not intended as a limitation as to where the DV metadata extraction tool  can be implemented within the core layer  or elsewhere. Implementing the DV metadata extraction tool  within the Dmux  is a preferred embodiment because of the benefits of efficiency provided by the splitting function of the Dmux . Thus, the DV metadata extraction tool  may just as easily be part of the media source , a DMO (DirectX Media Object), or a stand-alone software component anywhere else that has access to the DV data stream. The DV metadata extraction process is discussed in greater detail below with reference to subsequent figures.","Media sinks (sinks)  are also included in the core layer  processing components. Sinks  generally accept multimedia data as input through a generic, well-defined interface. There are many implementations of media sinks for performing different functions with multimedia data, such as writing multimedia data to a given file type or to a network, or displaying the multimedia data on a video monitor using a video card.","The base components  and development platform  of multimedia architecture  generally make up mostly un-managed API's. The base components  include media container , networking , DRM , MPEG format support , and audio\/video engine . These components generally perform individual functions in support of multimedia architecture . The development platform  generally includes resource management infrastructure and common primitive types such as samples, clocks, events, buffers, and so on. The definitions layer of multimedia architecture  includes definitions and policies related to schemas, protocols, and formats (e.g., metadata, device models, types, etc.).",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3","FIG. 4"],"b":["208","200","234","300","234","302","304","302","308","310","312","304","314","316","234","300","300","234","306","306","302"]},"For a certain subset of DV metadata packs, the DV metadata extraction tool  also provides extended support of DV pack-specific data structures, called DV_METADATA structures (see ). In addition to storing the DV metadata packs in the container  for these extended support packs, the Dmux  also stores the unpacked DV_METADATA structures in the container . Thus, for certain extended support DV metadata packs, the DV metadata extraction tool  breaks down the packed data into usable DV pack-specific data structures, or DV_METADATA structures.  illustrates a container  having one or more DV metadata packs  and one or more unpacked DV_METADATA structures  that correspond with the DV metadata packs .","According to IEC 61834-4, there are 256 DV metadata packs in the DV format. The 256 DV metadata packs are shown herein below in a reference section of this disclosure entitled Interface Definition Language. Although 256 packs are reserved for DV metadata, many of the packs have yet to be defined. The binary pack layout for various DV metadata packs is shown in the Interface Definition Language reference section. The DV metadata pack binary layouts included are for those DV metadata packs that are specifically supported as unpacked DV pack-specific data structures (i.e., DV_METADATA structures). Thus, the Interface Definition Language section also includes the unpacked DV_METADATA structures for the specifically supported DV metadata packs. In general, each DV metadata pack consists of 5 bytes in its binary layout. The first byte in each DV metadata pack is the DVPackID, and the next four bytes consist of binary fields.","Referring again to , the DV metadata extraction tool  supports an extraction API  (application programming interface) that maintains the extraction list  through various methods. The DV metadata extraction tool  also supports a container API  that will be discussed below.  illustrates the DV metadata extraction tool  along with the extraction API  and container API  it supports. Also shown in  is the extraction list , which may contain various DVPackIDs. The extraction API  is called the IMFExtractDVMetadata API, and the methods it supports include AddPack, RemovePack, RemoveAllPacks, GetCount, and GetPack.","The AddPack method adds the specified pack to the extraction list  of DV Packs to be extracted on each DV frame  according to the following syntax:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT AddPack("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BYTE DVPackID"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"DVPackID is an input parameter that specifies the PackID for a DV metadata pack. This is a member of the DVPACKID enum. In a resulting DV_METADATA structure the PackID is in DvMetadata.Pack[0]. The only pack that cannot be added to the extraction list  is DVPAC_NO_INFO (0xFF) (see the Interface Definition Language section).","If the AddPack method succeeds, it returns S_OK. However, an E_INVALIDARG will be returned if the DVPackID is DVPACK_NO_INFO. Other errors may also be returned.","A call to AddPack from an editing application , for example, adds a DVPackID to the extraction list . The function will succeed even if the pack (i.e., the DVPackID) has previously been added. The packs are not reference counted so a pack needs only to be removed once even if it has been added twice.","The RemovePack method removes the specified pack from the extraction list  of packs to be extracted on each DV frame  according to the following syntax:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT RemovePack("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BYTE DVPackID"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"DVPackID is an input parameter that specifies the PackID for a DV metadata pack. This is a member of the DVPACKID enum. In a resulting DV_METADATA structure, the PackID is in DvMetadata.Pack[0].","If the RemovePack method succeeds, it returns S_OK. If the pack is not in the extraction list  then the function returns E_ITEM_NOT_FOUND. Other error codes may also be returned.","A call to RemovePack from an editing application , for example, removes the specified pack from the extraction list .","The RemoveAllPacks method clears the extraction list  of DV Packs that the Dmux  would extract according to the following syntax:","HRESULT RemoveAllPacks( );\n\n","The GetCount method returns the number of DV packs that are in the extraction list  according to the following syntax:",{"@attributes":{"id":"p-0060","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT GetCount("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DWORD* pCount"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The pCount parameter is an output parameter that specifies the number of packs in the extraction list . If the method succeeds, it returns S_OK. Calling GetCount retrieves the number of items (i.e., DVPackID's) in the extraction list .","The GetPackID method returns the DVPackID of a pack at a given index in the extraction list  according to the following syntax:",{"@attributes":{"id":"p-0063","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT GetPack("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD Index,"]},{"entry":[{},"BYTE* pDVPackID"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The Index parameter is an input parameter that is the index in the extraction list  of the desired DVPack ID. The pDVPackID is an output parameter that is a pointer to a byte where the object will copy the DVPack ID of the item found at the specified index.","If the GetPackID method succeeds, it returns S_OK. If the Index is out of range, the method returns the error code, MF_E_INVALIDINDEX. If an error is returned the value OF pDVPackID is DVPACK_NO_INFO (0xFF).","The GetPackID method allows the caller (e.g., application ) to retrieve the full list of items to be extracted by repeatedly calling GetPackId and incrementing the index until E_INVALIDARG is returned.","As mentioned above, the DV metadata extraction tool  also supports a container API  (see ). The container  () is placed as a sample attribute on the video sample  that is split out by the Dmux . The container API  is called the IMFDVMetadataContainer API, and the methods it supports include Add, Remove, RemoveAll, GetCount, Lock, Unlock, GetFirst and GetNext. In general, the IMFDVMetadataContainer API provides a general mechanism for adding attributes to the list, removing attributes from the list, clearing the container  and iterating through the container .","The Add method adds a DV pack-specific data structure, or DV_METADATA structure, to the container  according to the following syntax:",{"@attributes":{"id":"p-0069","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT Add("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const DV_METADATA* pMetadata,"]},{"entry":[{},"UINT32* puIndex"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The pMetadata parameter is an input parameter that is a constant pointer to a DV_METADATA structure. pMetadata->cbSize is used to allocate memory in the container  and a copy of the entire DV_METADATA structure placed in the newly allocated memory.","The ulIndex is an output parameter that returns the index of the newly added DV_METADATA structure. The index may change if additional structures are added or deleted from the container .","If the Add method succeeds, it returns S_OK. It may also return E_OUTOFMEMORY if it is unable to allocate sufficient space for the new item. This operation will complete in constant time O(k). This operation will block until the lock is released if the container has been locked by another thread. (see Lock and Unlock methods below).","The Remove method removes a DV pack-specific data structure, or DV_METADATA structure, from the container  according to the following syntax:",{"@attributes":{"id":"p-0074","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT Remove("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UINT32 uIndex"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The uIndex parameter is an input parameter that indicates the index of the item that is to be removed from the container . When an item is removed from the container  the index of items that remains in the container  may change.","If the method succeeds, it returns S_OK. It may also return E_INVALIDARG if an item with a matching index cannot be found. This includes the case when the container  is empty. This operation will complete in linear time O(n), where n is the number of items stored in the list. This operation will block until the lock is released if the container has been locked by another thread. (see Lock and Unlock methods below).","The RemoveAll method clears all items (e.g., DV metadata packs and DV pack-specific data structures) from the container  according to the following syntax:",{"@attributes":{"id":"p-0078","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT RemoveAll(\u2009);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"There are no parameters input with the RemoveAll method. If the method succeeds, it returns S_OK and there will be no more items in the container . However, it does not necessarily follow that the memory will be freed. The container  may implement a pooling scheme to avoid repeated small allocations. This operation will complete in linear time O(n), where n is the number of items in the container . This operation will block until the lock is released if the lock has been acquired on another thread. (see Lock and Unlock methods below)."}}}},"The GetCount method returns the count of items in the container  according to the following syntax:",{"@attributes":{"id":"p-0080","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT GetCount("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UINT32* puCount"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The puCount parameter is an output parameter that returns number of items currently in the container . If the method succeeds, it returns S_OK.","This operation will complete in constant time O(k). The count returned is only valid at the time that the call was made. Objects may be added or removed by other threads. Locking the object will prevent other threads from adding or removing items from the container until the lock is released. (see Lock and Unlock methods below).","The Lock method is used to lock the container  for exclusive access. This guarantees that the container  can be iterated and the returned pointers to DV_METADATA structures will remain valid as long as the lock owner does not add or remove items. The syntax for this method is as follows:",{"@attributes":{"id":"p-0084","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT Lock(\u2009);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"There are no input parameters with the Lock method. If the method succeeds, it returns S_OK. It may return other error codes. If the Lock is unavailable, the call will block until the lock can be acquired.","The Unlock method releases the lock obtained via the Lock method according to the following syntax.",{"@attributes":{"id":"p-0087","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT Unlock(\u2009)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT32* puIndex,"]},{"entry":[{},"const DV_METADATA** pMetadata"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"There are no input parameters with the Unlock method. If the method succeeds, it returns S_OK. It may return other error codes.","The GetFirst method starts iterating from the beginning of the container  according to the following syntax:",{"@attributes":{"id":"p-0090","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT GetFirst("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT32* puIndex,"]},{"entry":[{},"Const DV_METADATA** ppMetadata"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The puIndex parameter is an output parameter that specifies the index of the item retrieved from the container . The ppMetadata parameter is an output parameter that specifies a pointer to the objects internal data structure containing the metadata. This pointer may be invalidated if items are added or removed from the container .","If the method succeeds, it returns S_OK. The method may return E_INVALIDARG if the index is out of range or the container  has had an item added or removed from it since the last call to GetFirst( ). The method will return MF_E_INVALIDREQUEST if the object has not been locked. Calling the Lock method ensures that items are not added or removed from the container  by other threads while iterating the list.","The GetNext method iterates through each item in the container  according to the syntax:",{"@attributes":{"id":"p-0094","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT GetNext("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UINT32* puIndex,"]},{"entry":[{},"Const DV_METADATA** ppMetadata"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The puIndex parameter is an output parameter that specifies the index of the item retrieved from the container . The ppMetadata parameter is an output parameter that specifies a pointer to the objects internal data structure containing the metadata. This pointer may be invalidated if items are added or removed from the container .","If the method succeeds, it returns S_OK. The method may return E_INVALIDARG if the index is out of range or the container  has had an item added or removed from it since the last call to GetFirst( ). The method will return MF_E_INVALIDREQUEST if the object has not been locked. Calling the Lock method ensures that items are not added or removed from the container  by other threads while iterating the list.","Exemplary Methods","Example methods for extracting DV metadata from a DV data stream will now be described with primary reference to the flow diagrams of . The methods apply generally to the exemplary embodiments discussed above with respect to . The elements of the described methods may be performed by any appropriate means including, for example, by hardware logic blocks on an ASIC or by the execution of processor-readable instructions defined on a processor-readable medium.","A \u201cprocessor-readable medium,\u201d as used herein, can be any means that can contain, store, communicate, propagate, or transport instructions for use by or execution by a processor. A processor-readable medium can be, without limitation, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples of a processor-readable medium include, among others, an electrical connection (electronic) having one or more wires, a portable computer diskette (magnetic), a random access memory (RAM) (magnetic), a read-only memory (ROM) (magnetic), an erasable programmable-read-only memory (EPROM or Flash memory), an optical fiber (optical), a rewritable compact disc (CD-RW) (optical), and a portable compact disc read-only memory (CDROM) (optical).",{"@attributes":{"id":"p-0100","num":"0101"},"figref":"FIG. 6","b":["600","602","200","202","102","204","102","400","200","400","400","404","404","404","400","404","404"]},"At block , the DV metadata specified in the instruction is extracted from a DV frame of the DV data stream. In one implementation, a Dmux  within a core layer  of the multimedia architecture  extracts the specified DV metadata as it splits the DV frame  into component video  and audio  samples. The extraction includes the Dmux  looking at the DV metadata extraction list  to determine which DV metadata packs to extract. At block , the DV metadata is stored in a container . At block , the container is attached to a video sample  split off of the DV frame  by the Dmux .","At block , the container is managed by the DV metadata extraction tool . The DV metadata extraction tool  includes a container interface  that supports methods by which applications  can access and manage data in the container . Method calls supported by the container interface  are an Add method call that adds a DV_METADATA structure to the container, a Remove method call that removes a DV_METADATA structure from the container, a RemoveAll method call that removes all items from the container, a GetCount method call that returns a number indicating an amount of items present in the container, a Lock method call that locks the container for exclusive access, an Unlock method call that unlocks the container, a GetFirst method call that retrieves an item from the container at a beginning index of the container, and a GetNext method call that retrieves an item from the container at a next index of the container.",{"@attributes":{"id":"p-0103","num":"0104"},"figref":"FIG. 7","b":["700","702","404","404","200","200","400","400","404","404","404","400","404","404"]},"At block , a DV metadata pack is extracted from a DV frame  based on a DVPackID in the extraction list . In one implementation, a Dmux  within a core layer  of the multimedia architecture  extracts the specified DV metadata pack as it splits the DV frame  into component video  and audio  samples. The extraction includes the Dmux  looking at the DV metadata extraction list  to determine which DV metadata packs to extract. At block , the DV metadata pack is stored in an IMFDVMetadataContainer .","At block , the DV metadata pack is unpacked into a DV pack-specific data structure. The DV pack-specific data structure breaks out the packed binary data from the DV metadata pack and assigns binary values to corresponding variable names, making it easy for an application program  to utilize the data from the DV metadata pack. At block , the DV pack-specific data structure is stored in the IMFDVMetadataContainer , and at block , the IMFDVMetadataContainer  is attached to a DV video sample  split off of the DV frame  by the Dmux .","At block , the IMFDVMetadataContainer  is managed by the DV metadata extraction tool . The DV metadata extraction tool  includes a container interface  that supports methods by which applications  can access and manage data in the container . Method calls supported by the container interface  are an Add method call that adds a DV pack-specific data structure (called a DV_METADATA structure) to the container, a Remove method call that removes a DV_METADATA structure from the container, a RemoveAll method call that removes all items from the container, a GetCount method call that returns a number indicating an amount of items present in the container, a Lock method call that locks the container for exclusive access, an Unlock method call that unlocks the container, a GetFirst method call that retrieves an item from the container at a beginning index of the container, and a GetNext method call that retrieves an item from the container at a next index of the container.","While one or more methods have been disclosed by means of flow diagrams and text associated with the blocks of the flow diagrams, it is to be understood that the blocks do not necessarily have to be performed in the order in which they were presented, and that an alternative order may result in similar advantages. Furthermore, the methods are not exclusive and can be performed alone or in combination with one another.","Exemplary Computer",{"@attributes":{"id":"p-0109","num":"0110"},"figref":"FIG. 8","b":["800","102","102"]},"The computing environment  includes a general-purpose computing system in the form of a computer . The components of computer  can include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus  structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. An example of a system bus  would be a Peripheral Component Interconnects (PCI) bus, also known as a Mezzanine bus.","Computer  typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media. The system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  can also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by a SCSI interface (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more application programs , other program modules , and program data . Each of such operating system , one or more application programs , other program modules , and program data  (or some combination thereof) may include an embodiment of a caching scheme for user network access information.","Computer  can include a variety of computer\/processor readable media identified as communication media. Communication media typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.","A user can enter commands and information into computer system  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer system .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet. When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components, such as the operating system, are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer system , and are executed by the data processor(s) of the computer.","Interface Definition Language","As indicated above, this IDL (Interface Definition Language) section lists the 256 DV metadata packs as well as the binary pack layout for various of those packs specifically supported in an extended manner as DV pack-specific data structures (i.e., DV_METADATA structures) by the DV metadata extraction tool . This section also includes the specific layouts of the unpacked DV metadata packs for the supported DV_METADATA structures. The DV metadata packs that have extended support are identified in the following table:",{"@attributes":{"id":"p-0124","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CONTROL",{}]},{"entry":[{},"CASSETTE ID","0X00"]},{"entry":[{},"TAPE LENGTH","0x01"]},{"entry":[{},"TEXT HEADER","0x08"]},{"entry":[{},"TEXT","0x09"]},{"entry":[{},"TAG","0x0B"]},{"entry":[{},"TITLE"]},{"entry":[{},"TIME CODE","0x13"]},{"entry":[{},"BINARY GROUP","0x14"]},{"entry":[{},"TEXT HEADER","0x18"]},{"entry":[{},"TEXT","0x19"]},{"entry":[{},"PROGRAM"]},{"entry":[{},"PROGRAM REC","0x42"]},{"entry":[{},"DTIME"]},{"entry":[{},"AAUX"]},{"entry":[{},"SOURCE","0x50"]},{"entry":[{},"SOURCE","0x51"]},{"entry":[{},"CONTROL"]},{"entry":[{},"REC DATE","0x52"]},{"entry":[{},"REC TIME","0x53"]},{"entry":[{},"BINARY GROUP","0x54"]},{"entry":[{},"CLOSED CAPTION","0x55"]},{"entry":[{},"TR","0x56"]},{"entry":[{},"VAUX"]},{"entry":[{},"SOURCE","0x60"]},{"entry":[{},"SOURCE","0x61"]},{"entry":[{},"CONTROL"]},{"entry":[{},"REC DATE","0x62"]},{"entry":[{},"REC TIME","0x63"]},{"entry":[{},"BINARY GROUP","0x64"]},{"entry":[{},"CLOSED CAPTION","0x65"]},{"entry":[{},"TR","0x66"]},{"entry":[{},"CAMERA"]},{"entry":[{},"CONSUMER","0x70"]},{"entry":[{},"CAMERA 1"]},{"entry":[{},"CONSUMER","0x71"]},{"entry":[{},"CAMERA 2"]},{"entry":[{},"CAMERA","0x7F"]},{"entry":[{},"SHUTTER"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Each DV pack-specific data structure (i.e., DV_METADATA structure) that has extended support by the DV metadata extraction tool  starts with a size and a DV Pack. The size member contains the size of the complete DV_METADATA structure. The DVPack (5 byte array) is the raw DV metadata. Each pack consists of 5 bytes. The first byte is the pack ID from Table 1 above. The next four bytes contain bit-fields containing the data. Each of the extended support packs has an associated structure where the bit-fields are unpacked and lightly processed into a more useable form. The full definition of the DV Packs is found in IEC 61834-4.","The 256 DV metadata packs and DV pack-specific data structures (i.e., DV_METADATA structures) supported by the DV metadata extraction tool  are as follows: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","Conclusion","Although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same reference numerals are used throughout the drawings to reference like components and features.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 8","FIG. 2"]}]},"DETDESC":[{},{}]}
