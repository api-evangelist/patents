---
title: Methods and systems for processing a geometry shader program developed in a high-level shading language
abstract: Methods and systems for processing a geometry shader program developed in a high-level shading language are disclosed. Specifically, in one embodiment, after having received the geometry shader program configured to be executed by a first processing unit in a programmable execution environment, the high-level shading language instructions of the geometry shader program is converted into low-level programming language instructions. The low-level programming language instructions are then linked with the low-level programming language instructions of a domain-specific shader program, which is configured to be executed by a second processing unit also residing in the programmable execution environment. The linked instructions of the geometry shader program are directed to the first processing unit, and the linked instructions of the domain-specific shader program are directed to the second processing unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958498&OS=07958498&RS=07958498
owner: NVIDIA Corporation
number: 07958498
owner_city: Santa Clara
owner_country: US
publication_date: 20061130
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","The Geometry Shader Extensions"],"p":["The current application claims the benefit of U.S. Provisional Application No. 60\/833,978, filed on Jul. 28, 2006 and having the title, \u201cAPI Extensions for Advanced Graphics Processing Units.\u201d This related application is hereby incorporated by reference in its entirety. The current application also is a continuation-in-part of U.S. application Ser. No. 10\/883,893, filed on Jul. 2, 2004 now U.S. Pat. No. 7,426,724 and having the title, \u201cOptimized Chaining of Vertex and Fragment Programs.\u201d This additional related application is also hereby incorporated by reference in its entirety.","1. Field of the Invention","Embodiments of the present invention relate generally to graphics processing and more specifically to processing of a geometry shader program developed in a level-high shading language.","2. Description of the Related Art","Over the past decade, the cost of adding on-chip logic to processors has substantially decreased. Consequently, certain types of processors, such as advanced graphics processing units (GPUs), now include functionality not previously available in earlier GPU designs. For example, the newest GPUs are now able to perform geometry processing operations; whereas, such operations traditionally had been left to the central processing unit (CPU). One benefit of this shift in responsibilities is that more graphics processing may now be performed on the GPU instead of the CPU, thereby reducing performance bottlenecks in the graphics pipeline.","To fully realize additional processing capabilities of advanced GPUs, as much GPU functionality as possible needs to be exposed to application developers. Among other things, doing so enables application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new GPU processing capabilities, like geometry processing, to application developers requires that the application programming interface (\u201cAPI\u201d) be configured with new calls and libraries that make new features and functionalities directly accessible by developers.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1","b":["100","106","102","106","108","108","108","100","130","136","132","133","134"]},"With GPU driver  supporting compiler , GPU microcode assembler , and GPU microcode assembler , specialized application , such as vertex shader program  or fragment shader program , can be written in a high-level shading language (e.g., the High Level Shader Language for Direct3D or the OpenGL\u2122 Shading Language) tailored to one of these programmable processing units. Vertex shader program  is generally constructed using unified program instructions and with self-contained variables and functions. Likewise, fragment shader program  is constructed using unified program instructions and also with self-contained variables and functions. Compiler  optionally translates these high-level shading programs into distinct software objects of vertex shader assembly code  and fragment shader assembly code . Based on the translated assembly code, GPU microcode assemblers  and  then generate vertex shader microcode  and fragment shader microcode , respectively, for GPU . It should be noted that compiler  may reside outside of GPU driver  in other prior art programming models.","One drawback of the aforementioned programming model  is the lack of programmability for certain components in rendering pipeline . For instance, since rendering pipeline  lacks a programmable processing unit in between vertex processing unit  and fragment processing unit , application  is unable to manipulate or process the output data of vertex processor unit  until that data reaches fragment processing unit . Another drawback of programming model  is the potential inefficiencies relating to developing and deploying separate domain-specific shader programs, because application developers need to rationalize the various shader programs they develop.","As the foregoing illustrates, what is needed in the art is a programming model that exposes new programmability and processing capabilities of GPUs, such as the ability to program and perform geometry processing operations, and enables efficient development of the various shader programs that execute within the different domains of the rendering pipeline.","Methods and systems for processing a geometry shader program developed in a high-level shading language are disclosed. Specifically, in one embodiment, after having received the geometry shader program configured to be executed by a first processing unit in a programmable execution environment, the high-level shading language instructions of the geometry shader program are converted into low-level programming language instructions. The low-level programming language instructions are then linked with the low-level programming language instructions of a domain-specific shader program, which is configured to be executed by a second processing unit also residing in the programmable execution environment. The linked instructions of the geometry shader program are directed to the first processing unit, and the microcode instructions of the domain-specific shader program are directed to the second processing unit.","One advantage of the disclosed methods and systems is that a geometry shader program or other domain-specific shader programs can be efficiently developed using a high-level shading language for programmable processing units in a rendering pipeline.","Methods and systems for processing a geometry shader program developed in a high-level shading language are described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details.","Throughout this disclosure, a \u201cdomain-specific\u201d shader program generally refers to a shader program specifically constructed to operate in a particular stage in a rendering pipeline. For instance, vertex shader program  shown in  is executed during the vertex processing stage of rendering pipeline . Likewise, geometry shader program  is executed during the primitive processing stage, and fragment shader program  is executed during the fragment processing stage. A \u201cshader program\u201d broadly refers to a software program that operates on the individual elements in a stream of elements. A \u201cshader engine,\u201d on the other hand, refers to a programmable processing unit which performs the processes defined in a shader program. Thus, primitive processing unit  of  is a shader engine, because it is configured to perform the processes defined in geometry shader program . Some examples of the types of elements that may be operated on by a shader program include, without limitation, vertices, pixels, and fragments. \u201cVarying variables\u201d provide the interface between a vertex shader and a geometry shader and also between a geometry shader and a fragment shader. A \u201clow-level programming language\u201d generally refers to a programming language that provides little or no abstraction from a processing unit. Some examples of this low-level programming language include, without limitation, assembly code and microcode. Also, some examples of the \u201ccomputer-readable medium\u201d referred herein include, without limitation, volatile memory and non-volatile storage media (e.g., optical or magnetic disks).",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","200","210","212","214","220"]},"Moreover, in programming model , GPU driver , which is the device driver for GPU , supports compiler\/linker . Compiler\/linker , which includes code generator  and unified instruction set library , provides cross-domain linking capabilities. Specifically, compiler\/linker  translates the shader programs designated for different domains (e.g., vertex shader program , geometry shader program , and fragment shader program ), which are written in high-level shading language, into distinct compiled software objects in the form of assembly code. Further, instead of sending these compiled objects of assembly code individually to separate GPU microcode assemblers as shown in , compiler\/linker  also \u201clinks\u201d the compiled assembly code to generate a collection of up to three separate chunks of assembly code with the inputs\/outputs of each chunk lined up as described below. This collection is referred to as compiled\/linked program object . To link multiple compiled objects from different domains (also referred to as to \u201crendezvous\u201d), compiler\/linker  needs to reconcile the use of symbols across the domains. Specifically, there are generally two types of symbols, the first type being defined or exported symbols, and the second type being undefined or imported symbols. The first type of symbols broadly refers to functions or variables that are present in one compiled object (e.g., vertex shader assembly code) and should be made available for use by other compiled objects (e.g., geometry shader assembly code and\/or fragment shader assembly code). The second type of symbols broadly refers to functions or variables that are called or referenced by one compiled object (e.g., vertex shader assembly code) but are not internally defined within this compiled object. The compiler\/linker  and optimizations related to linking shader programs for concurrent execution are discussed in greater detail in the patent application titled, \u201cOptimized Chaining of Vertex and Fragment Programs,\u201d filed on Jul. 2, 2004 and having U.S. patent application Ser. No. 10\/883,893. The subject matter of this patent application is hereby incorporated by reference in its entirety.","Additionally, compiler\/linker  supports two types of linking, linking by name and linking by semantics. To illustrate linking by name, suppose Color is the name of a variable containing color values to be passed from the vertex shader program to the fragment shader program. Suppose also that Color is defined in this vertex shader program. In programming model , compiler\/linker  facilitates the establishment and maintenance of the input\/output relationship between vertex shader program  and, for example, geometry shader program  without requiring any explicit variables-to-hardware mappings in the shader programs, so long as the two shader programs use the name Color consistently. To link by semantics, on the other hand, the variable names are not required to be the same. Suppose vertex shader program  declares a variable with the name of Vertex_Color for storing the color type X to be passed to geometry shader program , and geometry shader program  declares a variable with the name of Geometry_Color for receiving the color type X. In this scenario, compiler\/linker  is still capable of establishing and maintaining the input\/output relationship between vertex shader program  and geometry shader program , so long as Vertex_Color and Geometry_Color are assigned the same semantics corresponding to the color type X. Alternatively, instead of explicitly assigning semantics as discussed above, for GLSL, well-defined names corresponding to specific semantic meaning, such as gl_TexCoord[0] corresponding to texture coordinate zero and gl_FrontColor corresponding to a front-facing color value, are utilized to interface not only with other GLSL shaders, but also with OpenGL fixed-function processing or separate programs written in assembly code.","In addition to cross-domain linking, compiler\/linker  also supports error reporting and optimization capabilities. Using the \u201clinking by name\u201d example above, if geometry shader program  uses a different variable name than Color, then compiler\/linker  is configured to generate a linking error to indicate the inconsistent usage of the variable name. In addition, if Color were declared in a different manner in geometry shader program  than in vertex shader program , for example, then a linking error would occur. If the input of geometry shader program  does not have a corresponding output, a linking error would also occur. This error reporting mechanism enables application developers to efficiently identify any programming mistakes and as a result improve the robustness of their programs. Also, compiler\/linker  searches for and removes programming inefficiencies across domains. For example, suppose vertex shader program  generates multiple output variables destined for geometry shader program . Compiler\/linker  is capable of identifying the output variables that are not used by geometry shader program  and then excluding these unused output variables from compiled\/linked program object .","Further details about compiler\/linker  may be found in the patent application Ser. No. 10\/883,893 previously referred to herein. Compiled\/linked program object  generated by compiler\/linker  is optionally directed to a single GPU microcode assembler , which generates three software objects of domain-specific microcode for GPU  to execute: vertex shader microcode , derived from vertex shader program , geometry shader microcode , derived from geometry shader program , and fragment shader microcode , derived from fragment shader program . GPU microcode assembler  further directs each of these three objects of microcode to an appropriate programmable processing unit. More particularly, GPU microcode assembler  directs vertex shader microcode , geometry shader microcode , and fragment shader microcode  to vertex processing unit , primitive processing unit , and fragment processing unit , respectively. Vertex shader microcode  executes on vertex processing unit  to process the attributes of the received vertex typically associated with a geometric primitive. Similarly, fragment shader microcode  also executes on fragment processing unit  to process fragment data, which may include raster position, depth or interpolated vertex attributes, such as texture coordinates, opacity, and other relevant per-pixel data, to produce final pixel values. It should be apparent to a person with ordinary skill in the art that the various examples given above relating to compiler\/linker  are for illustrative purposes only and should not be construed to limit the scope of the claimed invention.","As also shown in  and previously mentioned herein, another programmable processing unit in rendering pipeline  includes a programmable primitive processing unit, , which can be configured to execute geometry shader microcode . Execution of geometry shader microcode  generally takes place after the transformation of vertices but prior to color clamping and flat shading and clipping. As discussed above, geometry shader microcode  is derived from geometry shader program , which broadly refers to a program developed in a high-level shading language to operate on geometric primitives. In one implementation, geometry shader program  accepts geometric primitives such as points, lines, triangles, lines with adjacent vertices, and triangles with adjacent vertices shown in  as input and generates new geometric primitives such as points, line strips, or triangle strips shown in  as output. Geometry shader program  is capable of receiving a set of vertices making up the input geometric primitive, reading the attributes of any of these received vertices, and \u201cemitting\u201d zero or more vertices making up the output geometric primitive. Geometry shader program  can even emit vertices making up multiple disconnected geometric primitives. To \u201cemit\u201d a vertex, geometry shader program  collects all the output values, places the collected data in a packet, and transmits the packet as one vertex with certain attributes. A detailed description supporting the processing of the different input and output primitive types by a geometry shader program is set forth below in the next section of the present application.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["238","212","212"]},"void main (void)","{",{"@attributes":{"id":"p-0031","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["vec4 vertOut;","vec4 colorOut;","int i;","for (i=0; i<gl_VerticesIn; ++i)","{\n        \n        ","}\n\n}\n\nBefore a geometry shader program is invoked, the type of its input geometric primitive and the type of its output geometric primitive need to be declared. For the example shown above, suppose the input type is declared to be any of the geometric primitives shown in  and the output type is declared to be a set of points. In step , the vertex attributes of an input geometric primitive are placed in input variables such as gl_PositionIn and gl_FrontColorIn. It should be noted that gl_PositionIn and gl_FrontColorIn are arrays of size <N>, where N is the number of vertices in the input geometric primitive type. Also, these two arrays are both pre-declared across multiple domains. Alternatively, instead of reading from these pre-declared variables, the vertex attributes may be read from input varying variables declared with the \u201cvarying in\u201d qualifier. Because geometry shader program  is written to operate on geometric primitives (i.e., potentially a collection of vertices), the built-in variables, like gl_PositionIn and gl_FrontColorIn, are pre-declared as arrays, and user-defined variables (using \u201cvarying in\u201d) are also declared as arrays. In step , the vertex attributes (e.g., coordinates and colors) are processed and the results are written to the output variables such as gl_FrontColor and gl_Position. Alternatively, the results may be written to output varying variables declared with the \u201cvarying out\u201d qualifiers.\n"]}}}},"Step  determines when all the output values have been collected, and the collected data are written out as a vertex with its attributes in step . In one implementation, EmitVertex( ) is called to specify the completion of processing on this vertex and to add this vertex to the current output geometric primitive. Step  determines if a geometry shader has requested to terminate its current primitive, built up from the vertices emitted in step . If so, step  sends the current primitive to rasterizer  and starts a new empty primitive of the same type. In one implementation, EndPrimitive( ) is called in step  to specify the end of the current primitive. Step  identifies the end of the geometry shader execution. When the geometry shader finishes, as in step , the current primitive is sent to the rasterizer  in step  and a new geometry shader may be invoked with new input vertices. EndPrimitive( ) does not need to be called under certain conditions. One condition is if the declared output type for geometry shader program  is a point, and the other condition is if geometry shader program  generates only a single output geometric primitive.",{"@attributes":{"id":"p-0033","num":"0043"},"figref":["FIG. 5","FIG. 4"],"b":["212","202","500","212","216","502","504","212","506","216","508","508","510","238","512","212"]},{"@attributes":{"id":"p-0034","num":"0044"},"figref":["FIG. 6","FIG. 2"],"b":["600","600","602","604","610","206","660","670","602","610","604","602","610","610","206","604","602","206","602","206","604","206","610","602","610","602","604","206","602","660","206","660","670"]},"System memory  includes an application program , one or more high-level shader programs , such as vertex shader program , geometry shader program , and fragment shader program  shown in , an API , and GPU driver  as shown in . Application program  generates calls to the API  in order to produce a desired set of results, typically in the form of a sequence of graphics images. Application program  also transmits one or more high-level shading programs  to API  for processing within GPU driver . The high-level shading programs are typically source code text of high-level programming instructions that are designed to operate on one or more shaders within GPU . In one implementation, the source code text is written in GLSL, and API  is the OpenGL\u2122 API. GPU driver  includes compiler\/linker , GPU microcode assembler , vertex shader microcode , geometry shader microcode , and fragment shader microcode  as shown in  and discussed above.","GPU driver  transmits the aforementioned microcode shader programs to GPU local memory  to be stored as microcode . In addition, GPU local memory  also includes a uniform storage buffer , a texture buffer , and a frame buffer . Uniform storage buffer  stores one or more uniform variables, also called \u201cuniforms.\u201d A uniform variable is held constant during a given invocation of the associated shader but may be altered between invocations. Texture buffer  stores data elements typically organized in one-dimensional, two-dimensional or three-dimensional structures. Frame buffer  includes at least one two-dimensional surface that is used to drive display .","GPU  includes vertex processing unit , primitive processing unit , and fragment processing unit  as discussed above. The execution of microcode  (e.g., vertex shader microcode , geometry shader microcode , and fragment shader microcode ) on the programmable processing units (e.g., vertex processing unit , primitive processing unit , and fragment processing unit ) imparts specific processing behavior according to specific requirements and specifications of application program .","Display  is an output device capable of emitting a visual image corresponding to an input data signal. For example, the display may be built using a cathode ray tube (CRT) monitor, a liquid crystal display, or any other suitable display system. The input data signal to display  is typically generated by scanning out the contents of one or more frames of image data that is stored in frame buffer .","Extensions to the OpenGL Shading Language (GLSL) and related APIs to support a geometry shader are discussed in this section. Persons skilled in the art will appreciate that the information in this section should be considered in conjunction with the current OpenGL 2.0\u2122 specification.","Input Primitives","A geometry shader can operate on one of five input primitive types. Depending on the input primitive type, one to six vertices are available when the shader is executed. Each input primitive type supports a subset of the primitives provided by the GL. If a geometry shader is active, Begin, or any function that implicitly calls Begin, will produce an INVALID_OPERATION error if the <mode> parameter is incompatible with the input primitive type of the currently active program object, as discussed below.","The input primitive type is a parameter of the program object, and must be set before linking by calling ProgramParameteriNV with <pname> set to GEOMETRY_INPUT_TYPE_NV and <value> set to one of POINTS, LINES, LINES_ADJACENCY_NV, TRIANGLES or TRIANGLES_ADJACENCY_NV. This setting will not be in effect until the next time LinkProgram has been called successfully. Note that queries of GEOMETRY_INPUT_TYPE_NV will return the last value set. This is not necessarily the value used to generate the executable code in the program object. After a program object has been created it will have a default value for GEOMETRY_INPUT_TYPE_NV.","The supported input primitive types are: (1) POINTS: Geometry shaders that operate on points are valid only for the POINTS primitive type. There is only a single vertex available for each geometry shader invocation; (2) LINES: Geometry shaders that operate on line segments are valid only for the LINES, LINE_STRIP, and LINE_LOOP primitive types. There are two vertices available for each geometry shader invocation. The first vertex refers to the vertex at the beginning of the line segment and the second vertex refers to the vertex at the end of the line segment; (3) LINES_ADJACENCY_NV: Geometry shaders that operate on line segments with adjacent vertices are valid only for the LINES_ADJACENCY_NV and LINE_STRIP_ADJACENCY_NV primitive types. There are four vertices available for each program invocation. The second vertex refers to attributes of the vertex at the beginning of the line segment and the third vertex refers to the vertex at the end of the line segment. The first and fourth vertices refer to the vertices adjacent to the beginning and end of the line segment, respectively; (4) TRIANGLES: Geometry shaders that operate on triangles are valid for the TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN, QUADS, QUAD_STRIP, and POLYGON primitive types. For QUADS, QUAD_STRIP, and POLYGON primitives, individual polygons are decomposed into one or more triangles, where the orientation of each triangle is consistent with the orientation of the original primitive. For such primitives, the shader is executed once for each triangle in the decomposition. There are three vertices available for each program invocation. The first, second and third vertices refer to attributes of the first, second and third vertex of the triangle, respectively; and (5) TRIANGLES_ADJACENCY_NV: Geometry shaders that operate on triangles with adjacent vertices are valid for the TRIANGLES_ADJACENCY_NV and TRIANGLE_STRIP_ADJACENCY_NV primitive types. There are six vertices available for each program invocation. The first, third, and fifth vertices refer to the first, second, and third vertices of the triangle. The second, fourth, and sixth vertices refer to adjacent vertices on the other side of the triangle edge connecting the neighboring vertices.","Ouput Primitives","A geometry shader can generate primitives of one of three types. The supported output primitive types are points (POINTS), line strips (LINE_STRIP), and triangle strips (TRIANGLE_STRIP). The vertices output by the geometry shader are decomposed into points, lines, or triangles based on the output primitive type. If the number of vertices emitted by the geometry shader is not sufficient to produce a single primitive, nothing is drawn.","The output primitive type is a parameter of the program object, and can be set by calling ProgramParameteriNV with <pname> set to GEOMETRY_OUTPUT_TYPE_NV and <value> set to one of POINTS, LINE_STRIP or TRIANGLE_STRIP. This setting will not be in effect until the next time LinkProgram has been called successfully.","Variables in General","Geometry shaders can access the transformed attributes of all vertices for its input primitive type through input varying variables. A vertex shader, writing to output varying variables, generates the values of these input varying variables. This includes values for built-in as well as user-defined varying variables. Values for any varying variables that are not written by a vertex shader are undefined. Additionally, a geometry shader has access to a built-in variable that holds the ID of the current primitive. This ID is generated by the primitive assembly stage that sits in between the vertex and geometry shader.","Additionally, geometry shaders can write to one, or more, varying variables for each primitive it outputs. These values are flat shaded (if enabled) and clipped, then the clipped values interpolated across the primitive (if not flat shaded). The results of these interpolations are available to a fragment shader, if one is active. Furthermore, geometry shaders can write to a set of built-in varying variables, defined in the OpenGL Shading Language, that correspond to the values required for the fixed-function processing that occurs after geometry processing.","Input Variables","The OpenGL Shading Language specification describes the set of built-in variables that are available as inputs to the geometry shader. This set receives the values from the equivalent built-in output variables written by the vertex shader. These built-in variables are arrays; each element in the array holds the value for a specific vertex of the input primitive. The length of each array depends on the value of the input primitive type, as determined by the program object value GEOMETRY_INPUT_TYPE_NV, and is set by the GL during link. Each built-in variable is a one-dimensional array, except for the built-in texture coordinate variable, which is a two-dimensional array. The vertex shader built-in output gl_TexCoord[ ] is a one-dimensional array. Therefore, the geometry shader equivalent input variable gl_TexCoordIn[ ][ ] becomes a two-dimensional array.","Some examples of the built-in variables include: (1) gl_FrontColorIn[ ], gl_BackColorIn[ ], gl_FrontSecondaryColorIn[ ] and gl_BackSecondaryColorIn[ ] hold the per-vertex front and back colors of the primary and secondary colors, as written by the vertex shader to its equivalent built-in output variables; (2) gl_TexCoordIn[ ][ ] holds the per-vertex values of the array of texture coordinates, as written by the vertex shader to its built-in output array gl_TexCoord[ ]; (3) gl_FogFragCoordIn[ ] holds the per-vertex fog coordinate, as written by the vertex shader to its built-in output variable gl_FogFragCoord; (4) gl_PositionIn[ ] holds the per-vertex position, as written by the vertex shader to its output variable gl_Position; (5) gl_ClipVertexIn[ ]holds the per-vertex position in clip coordinates, as written by the vertex shader to its output variable gl_ClipVertex; (5) gl_PointSizeIn[ ] holds the per-vertex point size written by the vertex shader to its built-in output varying variable gl_PointSize, even if the mode VERTEX_PROGRAM_POINT_SIZE is disabled; and (6) gl_PrimitiveIDIn is not an array and has no vertex shader equivalent. It is filled with the number of primitives processed since the last time Begin was called (directly or indirectly via vertex array functions).","Similarly to the built-in varying variables, user-defined input varying variables need to be declared as arrays. If no size (vertex count) is specified, it will be inferred by the linker from the input primitive type. If a size is specified, it has to be of the size matching the number of vertices of the input primitive type, otherwise a link error will occur. The built-in variable gl_VerticesIn, if so desired, can be used to size the array correctly for each input primitive type. User-defined varying variables can be declared as arrays in the vertex shader.","Output Variables","In one implementation, a geometry shader is limited in the number of vertices it may emit per invocation. Providing this limit allows the hardware to manage its internal buffers more efficiently. The maximum number of vertices a geometry shader can possibly emit needs to be set as a parameter of the program object that contains the geometry shader. This limit needs to be set before executing the geometry shader. To do so, call ProgramParameteriNV with <pname> set to GEOMETRY_VERTICES_OUT_NV and <value> set to the maximum number of vertices the geometry shader will emit in one invocation. There are two implementation-dependent limits on the value of GEOMETRY_VERTICES_OUT_NV. First, the total number of vertices may not exceed the value of MAX_GEOMETRY_OUTPUT_VERTICES_NV. Second, the product of the total number of vertices and the sum of all components of all active varying variables may not exceed the value of MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_NV. If it does, ProgramParameteriEXT will generate the error INVALID_VALUE.","A geometry shader can write to built-in as well as user-defined varying variables. These values are expected to be interpolated across the primitive it outputs, unless they are specified to be flat shaded. In order to seamlessly be able to insert or remove a geometry shader from a program object, the rules, names and types of the output built-in varying variables and user-defined varying variables are the same as for the vertex shader.","Some examples of the built-in output variables include:","(1) gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor, and gl_BackSecondaryColor hold the front and back colors for the primary and secondary colors for the current vertex; (2) gl_TexCoord[ ] is an array and holds the set of texture coordinates for the current vertex; (3) gl_FogFragCoord is used as the \u201cc\u201d value, as described in section 3.10 \u201cFog\u201d of the OpenGL 2.0 specification; (4) gl_Position is intended to hold the homogeneous vertex position; (5) gl_ClipVertex holds the vertex coordinate used in the clipping stage; (6) gl_PointSize, if written, holds the size of the point to be rasterized, measured in pixels; and (7) Additionally, a geometry shader can write to the built-in special variables gl_PrimitiveID and gl_Layer, whereas a vertex shader cannot. The built-in gl_PrimitiveID provides a single integer that serves as a primitive identifier. This written primitive ID is available to fragment shaders. If a fragment shader using primitive IDs is active and a geometry shader is also active, the geometry shader must write to gl_PrimitiveID or the primitive ID number seen by the fragment shader is undefined. The built-in variable gl_Layer is used in layered rendering.","More specifically, layered rendering allows an application to bind an entire \u201ccomplex\u201d texture to a framebuffer object, and render primitives to arbitrary layers computed at run time. For example, this mechanism can be used to project and render a scene onto all six faces of a cubemap texture in one pass. The layer to render to is specified by writing to the built-in output variable gl_Layer. Layered rendering requires the use of framebuffer objects. When a geometry shader using layered rendering is active, rasterizer  shown in  selects a provoking vertex from each point, line, or triangle emitted by the geometry shader. When rendering that primitive, the layer of the complex texture used is given by the value of gl_Layer for the provoking vertex.","Some Examples of the Functions Supported by the OpenGL\u2122 API","The following are some functions, or otherwise referred to as commands, supported by the OpenGL\u2122 API.\n\n","The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. The above examples, embodiments, and drawings should not be deemed to be the only embodiments, and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
