---
title: Cloning using an extent-based architecture
abstract: An extent-based storage architecture is implemented by a storage server. The storage server generates a new extent identifier for cloning a source extent identified by a source extent identifier and stored at a source data structure that includes a length value providing a length of the source extent, an offset value and a reference count value that provides a number of data containers that reference the source extent identifier. The storage server updates a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier and includes an extent length value and offset value different from length value and the offset value of the source data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918378&OS=08918378&RS=08918378
owner: NetApp, Inc.
number: 08918378
owner_city: Sunnyvale
owner_country: US
publication_date: 20110831
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","COPYRIGHT NOTICE\/PERMISSION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This patent application is related to U.S. patent application filed on Apr. 29, 2011, Ser. No. 13\/098,310, entitled \u201cExtent Based Architecture\u201d, the disclosure of which is incorporated herein by its entirety.","The present disclosure relates to storage systems.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings hereto: Copyright \u00a9 2011, NetApp, Inc., All Rights Reserved.","Various forms of network-based storage systems exist today. These forms include network attached storage (NAS), storage area networks (SAN's), and others. Network-based storage systems are commonly used for a variety purposes, such as providing multiple users with access to shared data, backing up critical data (e.g., by data mirroring), etc.","A network-based storage system typically includes at least one storage server, which is a processing system configured to store and retrieve data on behalf of one or more client processing systems (clients). The data is stored and retrieved as storage objects, such as blocks and\/or files. A block is a sequence of bytes or bits of data having a predetermined length. A data container (for example, a file) is a collection of related bytes or bits having an arbitrary length. In the context of NAS, a storage server operates on behalf of one or more clients to store and manage file-level access to data. The files may be stored in a storage system that includes one or more arrays of mass storage devices, such as magnetic or optical disks or tapes, by using a data storage scheme such as Redundant Array of Inexpensive Disks (RAID). In a SAN context, a storage server provides clients with block-level access to stored data, rather than file-level access.","Conventional systems typically use a multi-tiered, tree-like structure that includes a virtual volume block number (VVBN) space and a physical volume block number (PVBN) space managing information at storage devices and processing input\/output requests. The block size used by the storage system and by other entities (for example, virtual machines) may be different. This may result in misalignment and hence may complicate operations involving cloning and use of compression in storing data containers.","One option for handling the misalignment is to use an extent based architecture where an extent is a contiguous blocks used for storing a data container (for example, a file, directory and others) and is identified by an extent identifier. Continuous efforts are being made to use an extent based solution for efficiently perform cloning operations without having to use conventional VVBNs.","In one embodiment, a machine implemented method using an extent based architecture for a storage server is provided. In response to a cloning request to clone a portion of a source extent, the storage server generates a new extent identifier that is stored at a source data structure. The source extent includes a group of contiguous blocks for storing a data container. The source data structure includes a length value providing a length of the source extent, an offset value that refers to a distance in blocks from a known location of the data container and a reference count value that provides a number of data containers that reference the source extent identifier.","The storage server updates a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier. The updated data structure also includes an extent length value that is different from the length value of the source data structure and an offset value that is different from the offset value of the source data structure.","In another embodiment, a machine implemented method is provided. The method includes generating, by a storage server new extent identifier for cloning a portion of a source extent identified by a source extent identifier stored at a source data structure. The source extent includes a group of contiguous blocks for storing a data container and the source data structure includes a length value providing a length of the source extent, an offset value that refers to a distance in blocks from a known location of the data container and a reference count value that provides a number of data containers that reference the source extent identifier.","The method further includes updating a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier. The updated data structure includes an extent length value that is different from the length value of the source data structure and an offset value that is different from the offset value of the source data structure.","In yet another embodiment, a storage server is provided. The storage server includes a memory and a processor coupled to the memory through a bus. The processor executes instructions that cause the processor to generate a new extent identifier for cloning a portion of a source extent identified by a source extent identifier that is stored at a source data structure. The source extent includes a group of contiguous blocks for storing a data container and the source data structure includes a length value providing a length of the source extent, an offset value that refers to a distance in blocks from a known location of the data container and a reference count value that provides a number of data containers that reference the source extent identifier.","The processor also updates a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier. The updated data structure includes an extent length value that is different from the length value of the source data structure; and an offset value that is different from the offset value of the source data structure.","In another embodiment, a machine implemented method is provided. The method includes generating by a storage server a new extent identifier for cloning a portion of a source extent identified by a source extent identifier that is stored at a source data structure used for providing attributes of the source extent. The source extent includes a group of contiguous block for storing a data container and the source data structure includes a length value providing a length of the source extent, an offset value that refers to a distance in blocks from a known location of the data container and a reference count value that provides a number of data containers that reference the source extent identifier.","The method further includes updating a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier and the updated data structure includes an extent length value that is different from the length value of the source data structure; and an offset value that is different from the offset value of the source data structure. When a cloning request is to clone the entire source extent then the source extent identifier is also used for the cloned version and a reference count value of the data structure for the cloned version indicates that the source extent identifier is referenced by both the data container and the cloned version.","In yet another embodiment, a storage server is provided. The storage server includes a memory for storing an indirect volume entry for a source extent identified by a source extent identifier that is stored at a source data structure that maps to a physical block number (PVBN), which points to a physical storage space where information for the source extent is stored. The source extent includes a group of contiguous blocks for storing a data container and the source data structure includes a length value providing a length of the source extent, an offset value that refers to a distance in blocks from a known location of the data container and a reference count value that provides a number of data containers that reference the source extent identifier.","The server further includes a processor coupled to the memory via an inter-connect. The processor executes instructions that cause the processor to generate a new extent identifier for cloning a portion of the source extent and update a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier. The updated data structure includes an extent length value that is different from the length value of the source data structure and an offset value that is different from the offset value of the source data structure.","The embodiments using the extent based architecture described above have advantages in performing cloning\/partial cloning. The storage system does not have to navigate through a complex conversion process involving VVBN, especially where compression and partial cloning is involved. Instead, extent map entries are efficiently used for generating complete and\/or partial clones.","This brief summary has been provided so that the nature of this disclosure may be understood quickly. A more complete understanding of the disclosure can be obtained by reference to the following detailed description of the various embodiments thereof in connection with the attached drawings.","In the following detailed description of embodiments of the invention, reference is made to the accompanying drawings in which like references indicate similar elements, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that logical, mechanical, electrical, functional, and other changes may be made without departing from the scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims. References in this specification to \u201can embodiment,\u201d \u201cone embodiment,\u201d or the like, mean that the particular feature, structure or characteristic being described is included in at least one embodiment of the present invention. However, occurrences of such phrases in this specification do not necessarily all refer to the same embodiment.","As a preliminary note, the terms \u201ccomponent\u201d, \u201cmodule\u201d, \u201csystem,\u201d and the like as used in this disclosure are intended to refer to a computer-related entity, either programmable instructions-executing general purpose processor, hardware, firmware and a combination thereof. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer.","By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers. Also, these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and\/or remote processes such as in accordance with a signal having one or more data packets (e.g., data from one component interacting with another component in a local system, distributed system, and\/or across a network such as the Internet with other systems via the signal).","Computer executable components can be stored, for example, on computer readable media including, but not limited to, an ASIC (application specific integrated circuit), CD (compact disc), DVD (digital video disk), ROM (read only memory), floppy disk, hard disk, EEPROM (electrically erasable programmable read only memory), memory stick, flash memory device or any other non-volatile memory device, or any other storage device, in accordance with the claimed subject matter.","In one embodiment, a machine implemented method and an extent-based architecture for a storage server is provided. In response to a cloning request to clone a portion of a source extent, the storage server generates a new extent identifier that is stored at a source data structure. The source extent includes a group of contiguous blocks for storing a data container. The source data structure includes a length value providing a length of the source extent, an offset value that refers to a distance in blocks from a known location of the data container and a reference count value that provides a number of data containers that reference the source extent identifier.","The storage server updates a data structure for a cloned version of the data container for storing the new extent identifier that points to the source extent identifier. The updated data structure also includes an extent length value that is different from the length value of the source data structure and an offset value that is different from the offset value of the source data structure.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 1","b":["100","100","110","120","130"]},"WAFL aggregate  is a physical storage container that can store data in the WAFL file system. Flexible volume  is a logical volume that allows virtualization of the allocation of volumes on physical storage . Thereby multiple, independently managed flexible volumes  can share the same physical storage (e.g., physical storage ). The virtualization requires mapping between virtual volume block numbers (VVBNs) used by flexible volume  and physical volume block numbers (PVBNs) used by WAFL aggregate  to access data stored in physical storage . A PVBN, as used herein, refers to storage device blocks that have been abstracted into a single linear sequence in the aggregate.","The term storage volume or volume as used herein means a logical data set which is an abstraction of physical storage, combining one or more physical mass storage devices or parts thereof into a single logical storage object. However, each storage volume can represent the storage space in one storage device, an aggregate of some or all of the storage space in multiple storage devices, a RAID group, or any other set of storage space.","Each volume container  corresponds to a flexible volume . Volume container  contains all the data blocks for a corresponding flexible volume .","As used herein, a block offset or an offset refers to a distance in blocks from the beginning of a storage object\/data container such as a volume, file, or extent etc. Block addresses used within flexible volume  refer to block offsets within volume container . Since volume container  contains every block within flexible volume , there are two ways to refer to the location of a particular block. The PVBN specifies the location of a block within WAFL aggregate . The VVBN specifies the offset of the block within the container file.","When a block in a file is requested, flexible volume  translates the file offset into a VVBN. The VVBN is passed from flexible volume  to volume container . Volume container  translates the VVBN to a PVBN. The PVBN is then used to access the requested block in physical storage . Additionally, when a PVBN is initially written, the block pointer for the PVBN in flexible volume  is written to include the PVBN for the VVBN. Thereby, when the requested block is required, the flexible volume  can use the stored PVBN to access physical storage .","Current implementations of WAFL define a file as a tree of indirect blocks. Each indirect block in the tree has a fixed span i.e. a fixed number of entries, each pointing to another block in the tree. As a result, the amount of indirect block metadata is linear with respect to the size of the file. Additionally, storage device gardening techniques, such as segment cleaning, file reallocation, etc., are complicated by caching PVBN pointers in VVBN blocks.","Storage systems often use a predetermined block size for all internal operations. For example, WAFL may use 4 KB (e.g., 4096 bytes) blocks for both VVBN and PVBN, as do client-side file systems for file block numbers (FBN). Block boundaries are expected to occur every 4 KB from an initial offset (e.g., FBN 0). Since file systems usually offset individual data containers based on these block boundaries, application writers take advantage of a file system's block size and alignment to increase the performance of their input\/output (\u201cI\/O\u201d) operations\u2014for example, always performing I\/O operations that are a multiple of 4 KB, and always aligning these operations to the beginning of a file. Other file systems or applications, such as a virtual machine, may use a block boundary of a different size (e.g., a virtual machine environment in which an initial master boot record block of 512 bytes is followed by the expected 4 KB blocks), resulting in misalignment between FBN's and PVBN's. Additionally, multiple virtual machines may share a single volume container  and each virtual machine may misaligned by a different amount.","The embodiments disclosed herein provide an extent based architecture that overcomes the shortcomings of the architecture of . Extents are represented using an entry for each block within an extent. An extent, as used herein, refers to a contiguous group of one or more blocks.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 2A","FIG. 5"],"b":["200","495","495"]},"Storage servers (may also be referred to as storage systems)  (storage servers A, B) each manage multiple storage units  (storage A, B) that include mass storage devices. These storage servers  provide data storage services to one or more clients  through a network . Network  may be, for example, a local area network (LAN), wide area network (WAN), metropolitan area network (MAN), global area network (GAN) such as the Internet, a Fibre Channel fabric, or any combination of such interconnects. Each of clients  may be, for example, a conventional personal computer (PC), server-class computer, workstation, handheld computing or communication device, a virtual machine, or other special general purpose computer.","Data storage at storage units  is managed by storage servers , which receive and respond to various I\/O requests from clients , directed to data stored in or to be stored in storage units . Data is accessed (e.g., in response to the I\/O requests) in units of blocks, which in the present embodiment are 4 KB in size, although other block sizes (e.g., 512 bytes, 2 KB, 8 KB, etc.) may also be used. For one embodiment, 4 KB as used herein refers to 4,096 bytes. For an alternate embodiment, 4 KB refers to 4,000 bytes. Storage units  constitute mass storage devices which can include, for example, flash memory, magnetic or optical disks, or tape drives, illustrated as disks  (A, B). The storage devices  can further be organized into arrays (not illustrated) implementing a Redundant Array of Inexpensive Disks\/Devices (RAID) scheme, whereby storage servers  access storage units  using one or more RAID protocols. Although illustrated as separate components, for one embodiment, a storage server  and storage unit  may be a part of\/housed within a single device.","Storage servers  can provide file-level service such as used in a network-attached storage (NAS) environment, block-level service such as used in a storage area network (SAN) environment, a service which is capable of providing both file-level and block-level service, or any other service capable of providing other data access services. Although storage servers  are each illustrated as single units in , a storage server can, in other embodiments, constitute a separate network element or module (an \u201cN-module\u201d) and disk element or module (a \u201cD-module\u201d). In one embodiment, the D-module includes storage access components for servicing client requests. In contrast, the N-module includes functionality that enables client access to storage access components (e.g., the D-module) and may include protocol components, such as Common Internet File System (CES), Network File System (NFS), or an Internet Protocol (IP) module, for facilitating such connectivity. Details of a distributed architecture environment involving D-modules and N-modules are described further below with respect to  and embodiments of a D-module and a N-module are described further below with respect to .","In yet other embodiments, storage servers  are referred to as network storage subsystems. A network storage subsystem provides networked storage services for a specific application or purpose. Examples of such applications include database applications, web applications, Enterprise Resource Planning (ERP) applications, etc., e.g., implemented in a client. Examples of such purposes include file archiving, backup, mirroring, etc., provided, for example, on archive, backup or secondary storage server connected to a primary storage server. A network storage subsystem can also be implemented with a collection of networked resources provided across multiple storage servers and\/or storage units.","In the embodiment of , one of the storage servers (e.g., storage server A) functions as a primary provider of data storage services to client . Data storage requests from client  are serviced using disks A organized as one or more storage objects. A secondary storage server (e.g., storage server B) takes a standby role in a mirror relationship with the primary storage server, replicating storage objects from the primary storage server to storage objects organized on disks of the secondary storage server (e.g., disks B). In operation, the secondary storage server does not service requests from client  until data in the primary storage object becomes inaccessible such as in a disaster with the primary storage server, such event considered a failure at the primary storage server. Upon a failure at the primary storage server, requests from client  intended for the primary storage object are serviced using replicated data (i.e. the secondary storage object) at the secondary storage server.","It will be appreciated that in other embodiments, network storage system  may include more than two storage servers. In these cases, protection relationships may be operative between various storage servers in system  such that one or more primary storage objects from storage server A may be replicated to a storage server other than storage server B (not shown in this figure). Secondary storage objects may further implement protection relationships with other storage objects such that the secondary storage objects are replicated, e.g., to tertiary storage objects, to protect against failures with secondary storage objects. Accordingly, the description of a single-tier protection relationship between primary and secondary storage objects of storage servers  should be taken as illustrative only.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 2B","FIG. 2B"],"b":["220","220","210","210","210","271","210","225"]},"Nodes  may be operative as multiple functional components that cooperate to provide a distributed architecture of system . To that end, each node  may be organized as a network element or module (N-module A, B), a disk element or module (D-module A, B), and a management element or module (M-host A, B). In one embodiment, each module includes a processor and memory for carrying out respective module operations. For example, N-module  may include functionality that enables node  to connect to client  via network  and may include protocol components such as a media access layer, IP layer, Transport Control Protocol (TCP) layer, User Datagram Protocol (UDP) layer, and other protocols known in the art.","In contrast, D-module  may connect to one or more storage devices  via cluster switching fabric  and may be operative to service access requests on devices . In one embodiment, the D-module  implements an extent-based storage architecture , as will be described in greater detail below. In one embodiment, the D-module  includes storage access components such as a storage abstraction layer supporting multi-protocol data access (e.g., the CFS protocol, the NFS protocol, and the Hypertext Transfer Protocol), a storage layer implementing storage protocols (e.g., RAID protocol), and a driver layer implementing storage device protocols (e.g., Small Computer Systems Interface (SCSI) protocol) for carrying out operations in support of storage access operations.","In the embodiment shown in , a storage abstraction layer (e.g., file system) of the D-module divides the physical storage of devices  into storage objects. Requests received by node  (e.g., via N-module ) may thus include storage object identifiers to indicate a storage object on which to carry out the request.","Also operative in node  is M-host  which provides cluster services for node  by performing operations in support of a distributed storage system image, for instance, across system . M-host  provides cluster services by managing a data structure such as a RDB  (RDB A, RDB B) which contains information used by N-module  to determine which D-module  \u201cowns\u201d (services) each storage object. The various instances of RDB  across respective nodes  may be updated regularly by M-host  using conventional protocols operative between each of the M-hosts (e.g., across network ) to bring them into synchronization with each other. A client request received by N-module  may then be routed to the appropriate D-module  for servicing to provide a distributed storage system image.","It should be noted that while  shows an equal number of N- and D-modules constituting a node in the illustrative system, there may be different number of N- and D-modules constituting a node in accordance with various embodiments disclosed herein. For example, there may be a number of N-modules and D-modules of node A that does not reflect a one-to-one correspondence between the N- and D-modules of node B. As such, the description of a node comprising one N-module and one D-module for each node should be taken as illustrative only.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 3","FIG. 2A","FIG. 8"],"b":["300","210","210","300","5","300"]},"Storage server  includes a processor , a memory , a network adapter , a user console  and a storage adapter  interconnected by a bus system . The bus system , may include, for example, a system bus, a Peripheral Component Interconnect (PCI) bus, a HyperTransport or industry standard architecture (ISA) bus, a small computer system interface (SCSI) bus, a universal serial bus (USB), or an Institute of Electrical and Electronics Engineers (IEEE) standard 1394 bus (sometimes referred to as \u201cFirewire\u201d). Certain standard and well-known components, which are not germane to the understanding of embodiments of the present invention, are not shown.","Storage server  includes a processor , configured to operate as a central processing unit (CPU) and, thus, control the overall operation of storage server . Processor  may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific integrated circuits (ASICs), programmable logic devices (PLDs), or the like, or a combination of such devices.","Processor  executes software stored in memory . For one embodiment, multiple processors  or one or more processors  with multiple cores are included in the storage server . For one embodiment, individual adapters (e.g., network adapter  and storage adapter ) each include processor and memory for carrying out respective module operations.","Memory  includes storage locations addressable by processor , network adapter  and storage adapter  for storing processor-executable instructions and data structures associated with implementation of an extent-based storage architecture. Storage operating system , portions of which is typically resident in memory  and executed by processor , functionally organizes the storage server  by invoking operations in support of the storage services provided by the storage server . It will be apparent to those skilled in the art that other processing means may be used for executing instructions and other memory means, including various computer readable media, may be used for storing program instructions pertaining to the inventive techniques described herein. It will also be apparent that some or all of the functionality of the processor  and executable software can be implemented by hardware, such as integrated currents configured as programmable logic arrays, ASICs, and the like.","Network adapter  comprises one or more ports to couple the storage server to one or more clients over point-to-point links or a network. Thus, network adapter  includes the mechanical, electrical and signaling circuitry needed to couple the storage server to one or more client over a network. The network adapter  may include protocol components such as a Media Access Control (MAC) layer, CIFS, NFS, IP layer, TCP layer, UDP layer, and other protocols known in the art for facilitating such connectivity. Each client may communicate with the storage server over the network by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP\/IP.","Storage adapter  includes a plurality ports having input\/output (I\/O) interface circuitry to couple the storage devices (e.g., disks) to bus  over an I\/O interconnect arrangement, such as a conventional high-performance, FC or SAS link topology. Storage adapter  typically includes a device controller (not illustrated) comprising a processor and a memory for controlling the overall operation of the storage units in accordance with read and write commands received from storage operating system . In one embodiment, the storage operating system  implements an extent-based storage architecture , as will be described in greater detail below. As used herein, data written by a device controller in response to a write command is referred to as \u201cwrite data,\u201d whereas data read by device controller responsive to a read command is referred to as \u201cread data.\u201d","User console  enables an administrator to interface with the storage server to invoke operations and provide inputs to the storage server using a command line interface (CLI) or a graphical user interface (GUI). In one embodiment, user console  is implemented using a monitor and keyboard.","When implemented as a node of a cluster, such as cluster  of , the storage server further includes a cluster access adapter  (shown in phantom\/broken lines) having one or more ports to couple the node to other nodes in a cluster. In one embodiment, Ethernet is used as the clustering protocol and interconnect media, although it will be apparent to one of skill in the art that other types of protocols and interconnects can by utilized within the cluster architecture.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 4","FIG. 3","FIG. 5","FIG. 8"],"b":["314","495","314","314"]},"The storage operating system  comprises a series of software layers executed by a processor, such as processor  of , and organized to form an integrated network protocol stack or, more generally, a multi-protocol engine  that provides data paths for clients to access information stored on the storage server using block and file access protocols.","Multi-protocol engine  includes a media access layer  of network drivers (e.g., gigabit Ethernet drivers) that interface with network protocol layers, such as the IP layer  and its supporting transport mechanisms, the TCP layer  and the UDP layer . A file system protocol layer provides multi-protocol file access and, to that end, includes support for one or more of the Direct Access File System (DAFS) protocol , the NFS protocol , the CIFS protocol  and the HTTP protocol . A VI layer  implements the VI architecture to provide direct access transport (DAT) capabilities, such as RDMA (remote direct memory access), as required by the DAFS protocol . An iSCSI driver layer  provides block protocol access over the TCP\/IP network protocol layers, while a FC (Fibre Channel) driver layer  receives and transmits block access requests and responses to and from the storage server. In certain cases, a Fibre Channel over Ethernet (FCoE) layer (not shown) may also be operative in multi-protocol engine  to receive and transmit requests and responses to and from the storage server. The FC and iSCSI drivers provide respective FC and iSCSI-specific access control to the blocks and, thus, manage exports of luns to either iSCSI or FCP or, alternatively, to both iSCSI and FCP when accessing data blocks on the storage server.","The storage operating system also includes a series of software layers organized to form a storage server  that provides data paths for accessing information stored on storage devices. Information may include data received from a client, in addition to data accessed by the storage operating system in support of storage server operations such as program application data or other system data. Preferably, client data may be organized as one or more logical storage objects (e.g., volumes) that comprise a collection of storage devices cooperating to define an overall logical arrangement.","The file system  implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules (illustrated as a SCSI target module ). The SCSI target module  is generally disposed between drivers ,  and the file system  to provide a translation layer between the data block (lun) space and the file system space, where luns are represented as data blocks. In one embodiment, the file system  implements a WAFL file system having an on-disk format representation that is block-based using, e.g., 4 KB blocks and using a data structure such as index nodes (\u201cinodes\u201d) to identify files and file attributes (such as creation time, access permissions, size and block location). File system  uses files to store metadata describing the layout of its file system, including an mode file, which directly or indirectly references (points to) the underlying data blocks of a file. For one embodiment, the file system  includes an extent-based architecture  as an extension to WAFL.","Operationally, a request from a client is forwarded as a packet over the network and onto the storage server where it is received at a network adapter. A network driver such as layer  or layer  processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to forwarding to file system . There, file system  generates operations to load (retrieve) the requested data from the disks if it is not resident \u201cin core\u201d, i.e., in memory . If the information is not in memory, file system , in cooperation with the extent-based architecture , accesses an indirect volume to retrieve an extent identifier, accesses an extent-to-physical block map to retrieve a PVBN as described in greater detail below. For one embodiment, the file system  passes the PVBN to the RAID system . There, the PVBN is mapped to a disk identifier and device block number (disk, DBN) and sent to an appropriate driver of disk driver system . The disk driver accesses the DBN from the specified disk and loads the requested data block(s) in memory for processing by the storage server. Upon completion of the request, the node (and operating system ) returns a reply to the client over the network.","It should be noted that the software \u201cpath\u201d through the storage operating system layers described above needed to perform data storage access for the client request received at the storage server adaptable to the teachings of the invention may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by the storage server in response to a request issued by a client. Moreover, in another alternate embodiment of the invention, the processing elements of adapters ,  may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor , to thereby increase the performance of the storage service provided by the storage server. It is expressly contemplated that the various processes, architectures and procedures described herein can be implemented in hardware, firmware or software.","When implemented in a cluster, data access components of the storage operating system may be embodied as D-module  for accessing data stored on disk. In contrast, multi-protocol engine  may be embodied as N-module  to perform protocol termination with respect to a client issuing incoming access over the network, as well as to redirect the access requests any other N-module in the cluster. A cluster services system  may further implement an M-host (e.g., M-host ) to provide cluster services for generating information sharing operations to present a distributed file system image for the cluster. For instance, media access layer  may send and receive information packets between the various cluster services systems of the nodes to synchronize the replicated databases in each of the nodes.","In addition, a cluster fabric (CF) interface module  (CF interface modules A, B) may facilitate intra-cluster communication between N-module  and D-module  using a CF protocol . For instance, D-module  may expose CF application programming interface (API) to which N-module  (or another D-module not shown) issues calls. To that end, CF interface module  can be organized as a CF encoder\/decoder using local procedure calls (LPCs) and remote procedure calls (RPCs) to communicate a file system command to between D-modules residing on the same node and remote nodes, respectively.","Although embodiments of the present invention are shown herein to implement an extent-based architecture within the illustrated components and layers of a storage server, it will be appreciated that an extent-based architecture may be implemented in other modules or components of the storage server in other embodiments. In addition, an extent-based architecture may be implemented as one or a combination of a software-executing processor, hardware or firmware within the storage server. As such, an extent-based architecture may directly or indirectly interface with modules of the storage operating system in accordance with teachings of the present invention.","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable on a computer to perform a storage function that manages data access and may implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel, an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the invention described herein may apply to any type of special-purpose (e.g., file server or storage serving appliance) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system. Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write anywhere file system, the teachings of the present invention may be utilized with any suitable file system, including conventional write-in-place file systems.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 5","b":["495","495","314"]},"The extent-based architecture  includes a volume layer  and an aggregate or region manager layer . The volume layer  includes one or more indirect volumes  to indirectly map an I\/O request from a client  to one or more physical blocks within storage devices  ().","In one embodiment, the storage server  uses one entry in the indirect volumes  for each extent, as opposed to prior art block-based implementations that used one indirect volume entry (e.g., in a flexible volume ) for each data block. For one embodiment, the I\/O request references data by way of a file block number (FBN). An FBN refers a data block in an indirect volume  as referenced by a client . The storage server  uses the FBN as a key to access an extent identifier (or extent ID). An extent refers to a contiguous group of one more data blocks in a FBN space. The aggregate layer  includes an extent-to-physical block map  and one or more physical volumes . The extent-to-physical block map  maps an extent identifier (e.g., accessed by way of an FBN in the volume layer ) to a pointer to another extent or to one or more PVBN in the physical volume .","The extent-based entries of the extent-to-physical block map  provide per-aggregate indirection. In contrast, virtual volume block numbers (VVBN) of volume containers  provide per-volume indirection. A per-aggregate extent-based entry, as used herein, refers to an extent being unique across volume boundaries within an aggregate. A per-volume indirect entry refers to an entry being unique within volume boundaries. For per-aggregate indirection, when the storage server  copies, moves, or makes other changes to physical blocks, the changes are reflected within the aggregate layer  in the extent-to-physical block map . These changes, however, do not need to be propagated into the volume layer  because the extent identifier does not need to change. This enables compression, decompression, sharing, and the termination of sharing of extents to occur without communication with the volume layer  as described below in more detail. Blocks can be easily shared across volume boundaries, enabling cross-volume de-duplication. Segment cleaning and related disk gardening techniques can be performed on the extent-to-physical block map  in a single pass, all without having to propagate changes up into the volume layer .",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 6","b":["600","495","600","605","600","620","610","615","610","615","620","605","610","615","605","620","610","615","620"]},"For one embodiment, the lengths of extents vary. For one embodiment the length of an extent is expressed as the number of data blocks of a fixed size within the extent. For example, an extent containing only a single 4 KB block would have a length of 1, an extent containing two 4 KB blocks would have a length of 2, etc. For one embodiment, extents have a maximum length driven by user I\/O or write allocation (e.g., extents having a maximum length of 64 blocks). For an alternate embodiment, the length of extents may be consistently defined (e.g.,  blocks).","For one embodiment, the storage server  uses an extent-based sorted data structure  to implement an indirect volume .  shows an exemplary volume layer indirect entry  for a leaf node  of an extent-based data structure  used to implement an indirect volume . The volume layer indirect entry  stores an FBN , a corresponding extent identifier , and a length of the extent . The storage server  uses the FBN  as the primary sorting key to navigate the extent-based sorted data structure  and find the extent identifier  that corresponds to the FBN . For one embodiment, the FBN  is 48 bits, the extent identifier  is 48 bits, and the length  is 8 bits. Alternatively, the storage server  uses different sizes for one or more of the FBN , extent identifier , or length . For example, the extent identifier  may be 64 bits long in an alternate embodiment to, e.g., provide for 512 byte granularity in the offsets of blocks. For one embodiment, extent lengths  vary. For an alternate embodiment, extent lengths  are fixed.","The storage server  allocates extent identifiers  during write allocation. For one embodiment, the storage server  allocates extent identifiers  from a finite pool. Alternatively, extent identifiers  are monotonically increasing values that never wrap. For one embodiment, the length  of an extent is used for a consistency check as described with reference to  below.","The per-volume container files  () of previous implementations of WAFL are not used in an extent-based sorted data structure  used to implement an indirect volume . Instead of per-volume container files , the storage server  uses an extent-to-physical block map . As described above, the use of the extent-to-physical block map  can result in reduced indirect metadata. The indirect volume blocks, however, no longer contain cached pointers to PVBN's.","Access to an extent involves the storage server  looking up an extent identifier  in the indirect volume  and looking up the PVBN (e.g., by way of a pointer) in the extent-to-physical block map . The computational overhead of this additional I\/O look-up is offset by some of the features of extent-based architecture . For example, I\/O accesses are per extent rather than per block and, therefore, multiple blocks are accessed by a single I\/O access of each the indirect volume  and the extent-to-physical block map . Additionally, the extent-based architecture  gains advantages in compression, deduplication, segment cleaning, etc., which can be performed with altering the extent identifier . Actions such as deduplication can easily span the aggregate rather than just a single volume and many changes to blocks, e.g., resulting from compression and segment cleaning, do not need to be propagated up to the indirect volume  (e.g., to correct cached indirect pointers as in previous implementations of WAFL).",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 8","b":["800","620","800","805","810","815","820","800","825","830"]},"As used herein, an offset for an extent is a distance in blocks from the first block for the contiguous group of blocks that make up an extent. For one embodiment, the extent identifier  is 48 bits, the pointer\/extent identifier  is 48 bits, the offset  is 8 bits, and the length  is 8 bits. For an alternate embodiment, different numbers of bits are used for each portion of an extent map entry .","For one embodiment, each extent map entry  includes either a pointer or other reference  directly to a PVBN or to another extent identifier  that directly references a PVBN. For one embodiment, each PVBN is owned by only one extent and any other extent that references the PVBN does so by way of referencing the owner extent. As a result, the maximum additional look-up for a given extent to get to a PVBN should be no more than one. This maximum prevents the level of indirect references in extent map entries  from becoming arbitrarily deep and taking an arbitrary amount of time (as measured in terms of disk I\/O operations, assuming that each extent entry is likely to be stored within a different disk block). As a result of extents having a single owner, the storage server  can use the owner extent identifier as a tag, unique number, or other context for the purpose of lost write detection.","For an alternate embodiment, all extent identifiers map directly to a PVBN and PVBN's can be owned by more than one extent. For an embodiment including lost write detection, the storage server  creates a context, tag, or unique number, e.g., via a separate table, that is separate\/different from the extent identifiers  due to the possibility of multiple extent identifiers referencing a single PVBN.","For one embodiment, the storage server  utilizes a finite number of extent identifiers. If an extent identifier is a candidate to be reused, e.g., upon a request to delete the extent, the storage server  first determines whether or not other extents refer to that extent identifier. If one or more extents reference the candidate extent identifier, the storage server  ensures that the one or more extents continue to point to the same data (e.g., by altering one of the extents to directly reference the corresponding PVBN and the other extents to reference that altered extent).","Reference count  is maintained by storage server  in extent map entry  to indicate how many storage objects may be referencing a particular extent identifier. Reference count  enables the storage server  to be aware of whether or not other extents would be affected by operations performed on an extent\/PVBN. In one embodiment, storage server  tracks increments and decrements the reference count in one or more log files. For example, the storage server  would increment a reference count when a new extent\/PVBN is allocated, when an extent identifier is shared (e.g., via clone creation, snapshot creation, or de-duplication). For one embodiment, the storage server  accumulates increments and decrements using a log file and makes batch updates to reference count metafiles, e.g., at a consistency point. For one embodiment, the storage server  increments a reference count from 0 to 1 for a PVBN directly (bypassing the log file) when allocating a new extent\/PVBN and executes all other increments and decrements of the reference counts via the respective reference count log file.","Compression value  may be used to indicate if blocks within an extent are compressed. The use of compression value  is described below in more detail.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 9","b":["505","510","525","210","705","210","515","710","700","210","710","800","520","210","810","905","525","815","210","905","910","915","820","210","905","910","915"]},{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 10","FIG. 9","FIG. 10"],"b":["505","510","525","210","705","515","710","700","210","710","800","520","805","810","905","810","1000","1005","1010","1020","1025","1030","800","810","800","805","810","815","820","810","815","820","210","810","905","525","210","810","1000","520","210","1010","915","525"]},{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 11","b":["1100","810","825","1100","24","24"]},"Extent map entry  is used when the data container represented by  is compressed. In this example, the 24 blocks of the data container, P1-P24, are compressed into 12 blocks as shown by the compression value of 12. Because the length field  is 24 and the compression value is 12, one can infer that the 24 blocks are compressed into 12 physical blocks. The reference count value for entry  is still 1, which means that only one data container references the extent.","Extent map entry  is used when extent E1 of entry  is cloned. In this example, extent map entries  and  use the same extent identifier E1. The clone and the parent extent (E1) in both entries  and  have the same pointer value (P1), offset value I(0), length value (24) and compression value (12). The reference count  in the extent map entry  is 2 because the original data container associated with extent map entry  and the cloned version associated with extent map entry  reference the same extent, E1.","In this example, storage operating system  uses the compression value 12 to determine how to process compression blocks while cloning E1. Because the entire extent is cloned, storage operating system  can use the original compressed blocks \u201cas-is\u201d without having to de-compress them.","Extent map entry  shows an example of a partial clone of a data container, according to one embodiment. As an example, assume that only 14 blocks i.e. blocks P10-P24 of the data container represented by extent identifier E1 in extent map entry  are cloned. A new extent identifier, E2, is generated and stored in extent map entry . For the partial clone, E2 points to extent E1, offset value is 10 for the starting block P10. The length value of 14 indicates that only 14 blocks are cloned. The compression value is 14 indicating that no compression is used. The reference count  in this example is 1 because E2 is only referenced by the cloned version that simply points to the source extent identified by E1.","If the partial cloning included any compressed blocks then it is indicated by the compression value . Storage operating system  handles the compressed blocks based on the location of the compressed blocks within the partial data container that is cloned. For example, in some instances, storage operating system  may be able to directly point to the compressed blocks within the partial data container. In other cases, storage operating system  may decompress the compressed blocks and then compress them for the partial clone based on efficiency and user preference.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 12","b":["1200","1205","210"]},"In block S, the storage server  determines if the cloning request involves a complete source extent with an extent identifier, for example,  as described above. If yes, then in block S, the entire source extent is cloned. The extent map entries for the cloned version are the same as the extent map entry for the source data container, except, the reference count value that is increased in block . The reference count of the clone is 2 because both the source data container and the clone reference the same extent identifier, for example, E1 in extent map entry  and  of .","In one embodiment, because the entire extent is cloned, storage operating system  can use any original compressed blocks \u201cas-is\u201d without having to de-compress them. The number of compressed blocks is indicated by compression value  described above in detail.","If the request involves a partial extent, then in block S, a new extent identifier is generated by the storage server , for example, E2 of extent map entry  described above with respect to . In block S, the new extent map entry is updated by storage server . The new extent identifier points to the original extent identifier with a different offset value and length. For example, as shown in , the extent map entry  has an offset value of 10, instead of 0 in . The length in extent map entry  is 14 which means that 14 blocks of the source data container identified by  are cloned. The reference count of the cloned version is 1 because only the cloned data container references the new extent identifier, E2.","The compression value  is used in block S to process any compressed blocks within the partial extent that is cloned. In some instances, the compressed blocks may be used \u201cas-is\u201d and in other instances, the compressed blocks may be de-compressed and then compressed for the partial clone.","In block S, the storage server  determines if there is another extent identifier for the cloning request in block S. Storage server  determines if there is another extent identifier if pointer  points to another extent identifier, as shown in  and described above in detail. If there is another extent identifier, the process moves back to block S, otherwise, the process ends in block S.","The extent based architecture described above has advantages in performing cloning\/partial cloning. The storage system does not have to navigate through a complex conversion process involving VVBN, especially where compression and partial cloning is involved. Instead, extent map entries are efficiently used for generating complete and\/or partial clones.","Thus, embodiments of an extent-based architecture are implemented in a computer system as described herein. In practice, the methods described above may constitute one or more programs made up of computer-executable instructions. The computer-executable instructions may be written in a computer programming language, e.g., software, or may be embodied in firmware logic or in hardware circuitry. The computer-executable instructions to implement a persistent cache may be stored on a machine-readable storage medium. A \u201ccomputer-readable storage medium,\u201d or a \u201cnon-transitory computer-readable storage medium,\u201d as the terms are used herein, include any mechanism that provides (i.e., stores and\/or transmits) information in a form accessible by a machine (e.g., a computer, network device, personal digital assistant (PDA), manufacturing tool, any device with a set of one or more processors, etc.). A \u201cnon-transitory computer-readable storage medium,\u201d as the term is used herein, does not include a signal, carrier wave, etc. The term RAM as used herein is intended to encompass all volatile storage media, such as dynamic random access memory (DRAM) and static RAM (SRAM). Computer-executable instructions can be stored on non-volatile storage devices, such as magnetic hard disk, an optical disk, and are typically written, by a direct memory access process, into RAM\/memory during execution of software by a processor. One of skill in the art will immediately recognize that the terms \u201cmachine-readable storage medium\u201d and \u201ccomputer-readable storage medium\u201d include any type of volatile or non-volatile storage device that is accessible by a processor. For example, a machine-readable storage medium includes recordable\/non-recordable media (e.g., read-only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; etc.).","Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense.","Therefore, it is manifestly intended that embodiments of this invention be limited only by the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing features and other features will now be described with reference to the drawings of the various embodiments. In the drawings, the same components have the same reference numerals. The illustrated embodiments are intended to illustrate, but not to limit the present disclosure. The drawings include the following Figures:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
