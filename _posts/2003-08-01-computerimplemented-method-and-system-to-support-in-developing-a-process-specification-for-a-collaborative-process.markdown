---
title: Computer-implemented method and system to support in developing a process specification for a collaborative process
abstract: A computer-implemented method or computer system develops a process specification for a collaborative process involving distributed computer-based participant systems exchanging messages through an asynchronous messaging network. In operation, a computer retrieves, from a first computer system, information on process states and process state transitions in relation to each participant system. Information on collaboration states and collaboration state transitions of the process are stored in a second computer system and used to generate information on dead-end collaboration states.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07096230&OS=07096230&RS=07096230
owner: SAP Aktiengesellschaft
number: 07096230
owner_city: 
owner_country: DE
publication_date: 20030801
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["The present invention generally relates to the development of a specification for a collaborative process involving computer-based participant systems collaborating through exchange of messages over an asynchronous messaging network. More particularly, the present invention is concerned with developing a complete and consistent process specification.","Asynchronous messaging is a widely used means of communication between loosely coupled participant systems engaged in a collaborative process such as, e.g., an electronic business process involving distributed business partners. Generally, a collaborative process is one that is characterized by a plurality (two or more) of participants collaborating through exchange of messages in order to accomplish an overall goal or result. Collaborative business processes can be conducted among participants within a single enterprise. They can also involve business partners from different enterprises. Electronic financial controlling\/budgeting systems, electronic material resource planning\/controlling systems, and electronic purchase\/sales order systems are but examples of modern electronic business\/commerce applications that may involve collaborative processes of distributed participants, or clients.","Generally, a participant system engaged in a computer-implemented collaborative process can be viewed as comprising the entirety of hardware and software components required to make up a full-fledged participant to the process. In a more specific perspective, a participant system is formed by a software system implemented and executed on a computer and providing one or more software applications capable of consuming and producing messages received from, and sent to, other participant systems. The participant system may include, or have access to, one or more databases allowing storage of various application-related data such as, e.g., financial figures, fabrication figures, stock figures, etc. The messages exchanged between the participant systems may, e.g., contain requests or reports specifying business actions. The exchange of the messages is asynchronous in that an application sending a message does not need to wait for a remote application to receive that message. Thus, there is no need for all elements of the infrastructure linking the participant systems to be available at all times.","A conventional way of specifying a collaborative process is using UML (Unified Modeling Language) state chart diagrams. A state chart diagram specifies states that can be assumed by a participant system or a sub-system thereof in the course of the collaborative process as well as state transitions of the participant system\/sub-system. A sub-system of a participant system can, e.g., be a software object that forms part of a software application program. Software objects can, e.g., represent business objects in a business application. Each participant system of a collaborative process can comprise multiple software sub-systems each having unique sub-system states and sub-system state transitions. The term software sub-system as used herein is to be given the broadest and most general meaning. A software sub-system simply refers to a functional and\/or logical and\/or physical part or portion of the entirety of software that is present in a participant system. In particular, the term software sub-system as used herein expressly supports a concept in which the processing of data in two or more software sub-systems of the same participant system can be done, and the sub-systems' states can be updated, in one transaction.","Generally, a state transition is defined by a starting state, a target state, a triggering event and a resulting event. The starting state and the target state can be different, or be the same. In the first case, the participant system\/sub-system experiences a transition from one state to another, in the second case, a transition-to-self. A triggering event can, e.g., be a message transmitted over the messaging network from another participant system. It can also be a local event unrelated to communication over the messaging network, e.g., a data input through a local user interface or by another local software application. A triggering event can even be a message that is outside the scope of the process analysis. From the sight of the process model, such external message can be triggered as unmotivated as any local event due to, e.g., user action or batch transaction. Similarly, a resulting event can include the sending of a message to another participant system and\/or an event local to the respective participant system, e.g., an output of data for display on a monitor or storage in a database.","Optimally, a collaboration specification deals with every possible scenario of occurring messages, states, and state transitions of the software systems\/sub-systems involved in the process. However, when developing a collaborative process it may easily happen that one or more potentially occurring scenarios are not considered and remain unspecified. If the collaboration process is implemented using a specification that is incomplete, such unspecified situations lead to errors in the collaboration. The user typically does not have a straight solution for this problem. This requires that a provider of customer support be informed, causing costs for maintenance. In some instances these costs can be small compared with losses in revenue or business that may result from the failure.","For humans it is a hard to achieve a fully consistent and complete collaboration specification. Only very experienced personnel will be capable of doing so. This is particularly true as the complexity of the collaboration specification grows dramatically with the number of messages that can be communicated. Even harder is it to achieve this goal of completeness of the process specification in a distributed team of developers, a case normal in today's world of software development. It is therefore highly desirable to provide a developer engaged in developing a specification for a collaborative process with a tool that supports him in achieving a complete and consistent process specification.","According to one aspect, the present invention provides a computer-implemented method to support in developing a process specification for a collaborative process involving distributed computer-based participant systems exchanging messages through an asynchronous messaging network, the method embodied by a computer program product executable by a computer system and causing, when executed, the computer system to carry out the steps of retrieving from a first storage location, sub-system state information on sub-system states and sub-system state transitions in relation to a plurality of software sub-systems of each participant system, the sub-system state information specifying in relation to each sub-system state transition, starting and target sub-system states of the corresponding software sub-system and events triggering, and resulting from, the respective sub-system state transition; processing the retrieved sub-system state information to generate, and store in a second storage location, collaboration state information on collaboration states and collaboration state transitions of the process, the collaboration states being defined by a sub-system state for each software sub-system of each participant system and a communication status of each message exchangeable between the participant systems, the collaboration state transitions being determined based on the sub-system state transitions; upon generation and storage of the collaboration state information, retrieving the collaboration state information from the second storage location; processing the retrieved collaboration state information to generate information on incompletely specified terminal collaboration states among the collaboration states, an incompletely specified terminal collaboration state being a terminal collaboration state in which at least one message is underway between the participant systems; and generating a result data object containing information on every incompletely specified terminal collaboration state found.","The method of the present invention detects any incompleteness present in the process specification, thus allowing a developer, who may be the single designer of the collaborative process, but may also be part of a distributed team, to eliminate inconsistencies in, and perfect, the process specification early in the design phase. This avoids errors that may occur in practice, which may entail considerable cost and time for rectification. The invention allows for a completion of test cases relevant to the process to be designed. More test cases can be considered and therefore less errors occur at the customer.","Processing the sub-system state information can include the steps of processing the sub-system state information to generate, and store in a third storage location, local state information on local states and local state transitions of each participant system, the local state information specifying in relation to each local state transition, starting and target local states of the corresponding participant system and events triggering, and resulting from, the respective local state transition, the local states being defined by a sub-system state for each software sub-system of the respective participant system, the local state transitions being defined by applying the sub-system state transitions to said local states; upon generation and storage of the local state information, retrieving the local state information from the third storage location; and processing the retrieved local state information to generate the collaboration state information, the collaboration state transitions being determined by applying the local state transitions to the collaboration states.","Processing the sub-system state information can further include identifying an initial sub-system state from the sub-system states of each software sub-system; and generating the local state information by determining an initial local state for each participant system from the initial sub-system states of the software sub-system of the respective participant system, determining subsequent local states by applying the sub-system state transitions to the initial local states, and reiterating applying the sub-system state transitions to local states identified in a previous iteration until no further local states are found.","In one embodiment, the step of processing the retrieved local state information can include generating, and storing in the second storage location, information on a set of virtual global states, the virtual global states being defined each by a local state for each participant system and a communication status of each message, the set of virtual global states comprising states of any combination of local states of the participant systems and communication statuses of the messages.","The virtual global states can be represented each by a global state vector composed of first global state vector elements indicating a local state for each participant system and one or more second global state vector elements, one in relation to each message, each second global state vector element indicating a communication status of the respective message, the set of virtual global states comprising states of any combination of values of the first and second global state vector elements.","Processing the retrieved local state information can include identifying an initial global state among the virtual global states, this initial global state being one in which at least one local state transition as specified by the local state information and involving a local trigger is applicable to the initial global state and no message is underway between the participant systems, the local state transition causing a global state transition from the initial global state to another virtual global state; determining every virtual global state reachable when starting from the initial global state; and determining the initial global state and every virtual global state reachable from the initial global state to be collaboration states.","According to an alternate embodiment, processing the retrieved local state information can include the step of generating the collaboration state information by: determining an initial collaboration state, the initial collaboration state being defined by an initial local state for each participant system and a non-presence communication status of each message; determining subsequent collaboration states by applying the local state transitions to the initial collaboration state; and reiterating applying the local state transitions to collaboration states identified in a previous iteration until no further collaboration states are found.","In another aspect, the present invention provides a computer-implemented method to support in developing a process specification for a collaborative process involving distributed computer-based participant systems exchanging messages through an asynchronous messaging network, the method embodied by a computer program product executable by a computer system and causing, when executed, the computer system to carry out the steps of: retrieving from a third storage location, local state information on local states and local state transitions in relation to each participant system, the local state information specifying in relation to each local state transition, starting and target local states of the corresponding participant system and events triggering, and resulting from, the respective local state transition; processing the retrieved local state information to generate, and store in a second storage location, information on collaboration states and collaboration state transitions of said process, the collaboration states defined by a local state for each participant system and a communication status of each message exchangeable between the participant systems, the step of processing the local state information including the steps of identifying an initial local state from the local states of each participant system and generating the collaboration state information by: determining an initial collaboration state, the initial collaboration state being defined by the initial local state of each participant system and a non-presence communication status of each message; determining subsequent collaboration states by applying the local state transitions to the initial collaboration state; and reiterating applying the local state transitions to collaboration states identified in a previous iteration until no further collaboration states are found; upon generation and storage of said collaboration state information, retrieving the collaboration state information from the second storage location; processing the retrieved collaboration state information to generate information on incompletely specified terminal collaboration states among the collaboration states, an incompletely specified terminal collaboration state being a terminal collaboration state in which at least one message is underway between the participant systems; and generating a result data object containing information on every incompletely specified terminal collaboration state found.","The result data object can be stored in a fourth storage location. The first, second, third, and fourth storage locations as used herein refer to any of a database, a file, a register or set of registers, a memory, a cache, etc that allow to permanently or temporarily store information.","The result data object can be forwarded to a graphical output device to visually present on a display a presentation object indicating every incompletely specified terminal collaboration state found. Presenting the presentation object may include presenting a result list enumerating every collaboration state. The result list may contain in relation to each collaboration state one or more annotation objects indicating, e.g., whether or not the respective collaboration state is an incompletely specified terminal collaboration state.","The communication status is preferably a binary status indicating whether or not the respective message is underway between said participant systems.","According to yet another aspect of the present invention, a computer system is provided to support in developing a process specification for a collaborative process involving distributed computer-based participant systems exchanging messages through an asynchronous messaging network, the computer system provided with a computer program product that, when executed, causes the computer system to carry out the steps of retrieving from a first storage location, sub-system state information on sub-system states and sub-system state transitions in relation to a plurality of software sub-systems of each participant system, the sub-system state information specifying in relation to each sub-system state transition, starting and target sub-system states of the corresponding software sub-system and events triggering, and resulting from, the respective sub-system state transition; processing the retrieved sub-system state information to generate, and store in a second storage location, collaboration state information on collaboration states and collaboration state transitions of the process, the collaboration states being defined by a sub-system state for each software sub-system of each participant system and a communication status of each message exchangeable between the participant systems, the collaboration state transitions being determined based on the sub-system state transitions; upon generation and storage of the collaboration state information, retrieving the collaboration state information from the second storage location; processing the retrieved collaboration state information to generate information on incompletely specified terminal collaboration states among the collaboration states, an incompletely specified terminal collaboration state being a terminal collaboration state in which at least one message is underway between the participant systems; and generating a result data object containing information on every incompletely specified terminal collaboration state found.","Still another aspect of the present invention provides a computer system to support in developing a process specification for a collaborative process involving distributed computer-based participant systems exchanging messages through an asynchronous messaging network, the computer system provided with a computer program product that, when executed, causes the computer system to carry out the steps of retrieving from a third storage location, local state information on local states and local state transitions in relation to each participant system, the local state information specifying in relation to each local state transition, starting and target local states of the corresponding participant system and events triggering, and resulting from, the respective local state transition; processing the retrieved local state information to generate, and store in a second storage location, information on collaboration states and collaboration state transitions of the process, the collaboration states defined by a local state for each participant system and a communication status of each message exchangeable between the participant systems, the step of processing the local state information including the steps of identifying an initial local state from the local states of each participant system and generating the collaboration state information by determining an initial collaboration state, the initial collaboration state being defined by the initial local state of each participant system and a non-presence communication status of each message; determining subsequent collaboration states by applying the local state transitions to the initial collaboration state; and reiterating applying the local state transitions to collaboration states identified in a previous iteration until no further collaboration states are found; upon generation and storage of the collaboration state information, retrieving the collaboration state information from the second storage location; processing the retrieved collaboration state information to generate information on incompletely specified terminal collaboration states among the collaboration states, an incompletely specified terminal collaboration state being a terminal collaboration state in which at least one message is underway between the participant systems; and generating a result data object containing information on every incompletely specified terminal collaboration state found.","In , distributed participant systems , (in the following simply referred to as participants) are linked to each other through an asynchronous messaging network generally designated . Participants , collaborate to carry out an electronic process such as, e.g., a trade or other business process. To effect collaboration, participants , exchange messages between each other. Messaging network  ensures transport and delivery of such messages in an asynchronous fashion. The messages are produced and consumed by software applications embodying the participants. An order posting system for electronically posting purchase orders for goods with a supplier of such goods, and an order management system electronically handling incoming purchase orders on the part of that supplier are but two examples of software applications that can collaborate through exchange of messages.","The number of participants collaborating via messaging network  is at least two but can be any number greater than that. As an example, two additional participants depicted in dashed lines in  may partake in the collaborative process. It is to be understood that the present invention is not intended to be limited to a certain number of participants or a certain minimum or maximum number of participants.","Messaging network  may use for message transfer any form of wired or wireless, dedicated or public communications network such as, e.g., a local area network (LAN), a wide area network (WAN), a mobile communications network, or the Internet. Suitable transmission protocols, mechanisms and data formats to effect asynchronous communication between participants , are widely known to those skilled in the art and need not be further detailed.","In the following, a purely illustrative and non-limiting example of a collaborative process is described for sake of facilitating understanding of the invention. This process is a bilateral process carried out between participants and . The activity diagram depicted in  illustrates the way participants and interact in this process","According to the activity diagram of , participant , in response to a local triggering event not further specified, produces and emits a message Mx while in a local state S. Message Mx is delivered through messaging system  to participant . After having sent message Mx, participant is in a local state S. That is, the sending of message Mx is accompanied by a state transition of participant from S to S.","Participant receives and consumes message Mx in a local state S. In response to receipt of message Mx, participant generates and emits a message My, which is sent over messaging system  to participant . Having sent message My, participant remains in local state S. That is, receipt of message Mx triggers a local state transition of participant that is a transition-to-self. Resulting event of this local state transition is the sending of message My.","Participant receives message My in local state S and remains in this local state even after consumption of message My. Receipt of message My thus triggers a local transition-to-self of participant , with local state S being the starting state and the target state of this state transition. Consumption of message My will cause some form of a local event to occur at participant . As the type and nature of this local event are of no relevance for the purpose of the present invention, it is not further specified in the activity diagram of .","While in local state S, participant may also produce a message Mz in response to a local triggering event. Message Mz is then sent to participant . Emission of message Mz is accompanied by a local state transition of participant from S to S, i.e., a transition-to-self. Message Mz can be received and consumed by participant while the latter is in local state S. Reception of message Mz triggers a local transition-to-self of participant with S as the starting state and the target state of this state transition. Again, local events serving as a trigger for the emission of message Mz by participant and resulting from consumption of message Mz on the part of participant are not detailed in the activity diagram of .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3","FIG. 2","FIG. 3","FIG. 3"],"b":["10","10","10","10","10","10"],"sub":["1","2 ","1 ","2","1","2"]},"UML state chart diagrams such as shown in  provide a simple means of specifying the choreography of the collaboration between various distributed participants. Yet they only specify scenarios that have been explicitly considered by the designer or the team of designers of the collaborative process. In case of collaborative processes that involve a great many of messages and local states of the participants, it is not unlikely for the process designer(s) to inadvertently leave some scenarios unconsidered that nevertheless may occur in practice. Such unspecified scenarios, in the event of their occurring, will lead to an error and interrupt proper execution of the process.","The present invention provides a tool that enables a process designer to verify completeness and consistency of a collaborative process specification during the design phase. A main feature of this tool is an examination procedure that draws on data that describes the participants' local state transition behavior, and calculates from this data a global state machine model of the collaboration process taking into account both the local states of all participants and the messages that may be exchanged between the participants. Such data can be readily available from UML state chart diagrams as conventionally used by software developers as a means for specifying the process. Once established, the state machine model of the collaborative process allows easy identification of any unspecified scenarios, giving the process designer(s) an early opportunity in the design phase to perfect the process specification.","The task of designing a collaborative process can be assigned to a single developer. In practice, however, such a task is often times assigned to a team of distributed developers.  illustrates an exemplary computer system that can serve as a development environment for the development of software for a computer-implemented collaborative process. The computer system, generally designated , comprises at least one computer workstation , preferably a number of computer workstations , ,  . . . coupled to each other via a network . In the case of distributed developers partaking in the process design, each developer can work from one of computer workstations , ,  . . . . Computer workstation  comprises a processor , a memory , a bus , and one or more input devices  and output devices  acting as a user interface. The components of workstation  interoperate in a manner conventionally known in the art. A collaboration checking procedure according to the present invention is embodied in a computer program product (CPP) stored in memory  and\/or in a storage location outside computer workstation , e.g., on a separate program carrier .","Computer workstations , ,  . . . are also referred to as remote computers. They can be servers, routers, peer devices, or other common network nodes, and will typically include many or all of the components indicated in regard of computer workstation . Hence, components \u2013 of computer workstation  may collectively illustrate corresponding components in other computer workstations connected to network .","Computer workstation  can, e.g., be a personal computer (desktop or notebook computer), a minicomputer, a multiprocessor computer, a mainframe computer, a mobile computing device, a programmable personal digital assistant, or the like. Processor  can, for example, be a central processing unit (CPU), a digital signal processor (DSP), a micro-controller, or the like.","Memory  symbolizes components that allow to store data and\/or instructions permanently or temporarily. Although memory  is illustrated in  as a distinct component part of computer workstation , it can be implemented by suitable storage resources within processor  itself (register, cache, etc.), in nodes of network , in other computer workstations, or elsewhere. Specifically, memory  can include a read only memory (ROM) portion, e.g., for permanently storing program files, and\/or a random access memory (RAM) portion for storing data such as variables and operation parameters. It can be physically implemented by any type of volatile and non-volatile, programmable and non-programmable, magnetic, optical, semiconductor and other information storage means conventionally known in the art, for example, hard disk, floppy disk, CD-ROM, DVD, DRAM, SRAM, EPROM, EEPROM, memory stick, etc.","Memory  can store software support modules such as, for example, a basic input\/output system (BIOS), an operating system, a program library, a compiler, an interpreter, communication programs, driver, protocol converters, and application software programs (e.g., text processor, browser, database application, etc.).","The CPP provides in a computer readable manner, program code executable by processor . When loaded, the program code causes processor  to carry out steps of the before-mentioned collaboration checking procedure. A detailed description of the collaboration checking procedure will be given further below. The CPP controls operation of computer workstation  and, if necessary, its interaction with other components of computer system . It may be available as source code in any suitable programming language, e.g., C++, or as object code in a compiled presentation. Although  illustrates the CPP as stored in memory , it may as well be located on program carrier  outside computer workstation . If the CPP is stored on program carrier , input device  will be adapted to allow insertion of program carrier  into input device  to retrieve the CPP. Rather than storing the program code in memory  or on program carrier , the CPP can also be provided to processor  in the form of program signals delivered through network  from a remote computer. The steps embodied by the program code of the CPP can be carried out solely within computer workstation  or in a distributed manner by more than one of computer workstations , ,  . . . .","Input device  serves to input data and\/or instructions for being processed by computer workstation . The term input device encompasses, for example, a keyboard, a pointing device (mouse, trackball, cursor direction keys), a reading device for reading information stored on a separate information carrier (e.g., a drive for reading information from a disk, or a card reader for retrieving data from a memory card), a receiver for receiving information transmitted to computer workstation  from other components of computer system  through a wired or wireless link, a scanner, etc.","Output device  serves to present information resulting from processing activities within computer workstation . Output device  can, e.g., include a monitor or display, a plotter, a printer, or the like. Similarly to input device , output device , while mainly communicating with a user through visual or other presentation of processing results, may also communicate with other components of computer system . Thus, output device  may communicate a processing result through a wired or wireless link to a remote recipient.","Input device  and output device  can be combined in a single device.","Bus  and network  provide logical and physical connections by conveying instruction and data signals. While connections and communications within computer workstation  are handled by bus , connections and communications between different computers of computer system  and handled by network . Network  may comprise gateway and router computers dedicatedly programmed to effect data transmission and protocol conversion.","Input and output devices ,  are coupled to computer workstation  through bus  (as illustrated in ) or through network  (optionally). While signals inside computer workstation  will mostly be electrical signals, signals occurring across network  can be any signal type, e.g., electrical, optical, or radio.","Network  can be one with wired or wireless access and wired or wireless signal transmission across network . It can, e.g., include a LAN, a WAN, a wireless LAN, a public switched telephone network (PSTN), an integrated services digital network (ISDN), or a mobile communications network such as a UMTS (Universal Mobile Telecommunications System), GSM (Global System for Mobile Communication), or CDMA (Code Division Multiple Access) network.","Suitable transmission protocols, mechanisms and data formats to effect communication between computers of computer system  can, for example, include Transmission Control Protocol\/Internet Protocol (TCP\/IP), Hyper Text Transfer Protocol (HTTP), secure HTTP, Wireless Application Protocol (WAP), Unique Resource Locator (URL), Unique Resource Identifier (URI), Hyper Text Markup Language (HTML), Extensible Markup Language (XML), Extensible Hyper Text Markup Language (XHTML), Wireless Application Markup Language (WML), Electronic Data Interchange (EDI), which governs the electronic exchange of business information between or within organizations and their IT (Information Technology) infrastructure in a structured format, Remote Function Call (RFC), an application programming interface (API), etc.","In the following, one embodiment is described of a collaboration checking procedure for conducting an examination of a design for a collaborative process using the computer topology illustrated in .  depicts by way of a flow chart diagram, main steps of the collaboration checking procedure.","First, a user effects start of execution of the program code included in the CPP. To this end, a control signal is generated through user-operation of an activator element. The activator element can, e.g., a control button displayed on a graphical user interface created on a monitor by a software program application resident on computer workstation . The user can activate the control button on the screen by means of a mouse pointer. Activation of the control button generates a control signal that causes processor  to execute the collaboration checking procedure (step  in )","In executing the collaboration checking procedure, processor  retrieves data specifying the process to be examined from a storage location DB (step  in ). This process specification data includes information on local states and local state transitions of the process participants along with associated triggering and resulting events. In one embodiment, the participants' local states can be made up of a single state each. In an alternate embodiment, they can be made up of a plurality of states each associated with a respective one of various sub-systems of the respective participant. Such a sub-system can, e.g., be a software object representing a business object used in a business software program application. The process specification data can be stored in a database, a file, or any other organizational structure. The storage location DB can be within memory  of computer workstation , or on any other computer workstation ,  . . . connected to computer system , or even on a network server of network . The storage location DB can be a shared resource giving all developers in a development team access to the data in the storage location DB.","Taking the example process specified by the UML state chart diagrams of , the participants' , process specification data can, e.g., be stored in the storage location DB as a list of local state transition vectors (LSTV) each representing a single local state transition (LST) such as illustrated in the following table:",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"LSTV","LST"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(10_1; S1; S2; #; Mx)","1"]},{"entry":[{},"(10_1; S2; S2; My; #)","2"]},{"entry":[{},"(10_1; S1; S1; Mz; #)","3"]},{"entry":[{},"(10_2; S3; S3; #; Mz)","4"]},{"entry":[{},"(10_2; S3; S3; Mx; My)","5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The first element in each LSTV vector represents the participant affected by the particular local state transition, i.e., participant or . The second and third vector elements represent the starting local state and the target local state, respectively. The fourth and fifth elements in each LSTV vector represent the triggering and resulting events of the local state transition considered, with the same denotation used for these events as in the state chart diagrams of . One skilled in the art will be readily able to verify that the five local state transition vectors listed above cover all the scenarios specified by the state chart diagrams of .","Having retrieved the process specification data from storage location DB, processor , under control of the program code provided by the CPP, processes this data to generate, and store in another storage location DB, information representing a set of global state vectors (step  in ). In one embodiment, each global state vector is composed of a plurality of first global state vector elements, one in relation to each participant, and a plurality of second global state vector elements, one in relation to each message Mx, My, Mz. The first global state vector elements indicate a local state of the respective participant, and the second global state vector elements indicate whether or not the respective message is underway between participants and . To this end, the second global state vector elements can conveniently be binary values.","In an alternate embodiment, the global state vectors are composed of a plurality of first global state vector elements, one in relation to each participant, and second global state vector elements in relation to those messages only that are underway between the participants. Thus, a global state vector will have no second global state vector element if no message is underway, and one or more second global state vector elements if a corresponding number of messages is underway. Each second global state vector element will indicate a particular one of messages Mx, My, Mz that is underway.","In any event, the global state vectors are formed in dependence of each participant's local state and each message's communication status, i.e., whether the respective message is being communicated (underway) or not. For the purpose of the example process described herein, it is assumed in the following that the global state vectors contain a binary value for each message.","Using global state vectors an imaginary global state machine can be defined whose states, hereinafter referred to as virtual global states, are each represented by a respective global state vector and whose current virtual global state hence depends on the current local states of all participants of the collaborative process as well as the state of presence or non-presence of each message, i.e., whether or not the corresponding message is being communicated.","The storage location DB can, e.g., be within memory  of computer workstation, as is illustrated in . Alternately, it can be a storage location external to computer workstation , for example, in a node of network  or in another one of computer workstations ,  . . . connected to network . The global state vectors can be stored at the storage location DB in any organizational form such as a simple data set, a database, a file, etc. The global state vectors can even be kept in one or more internal registers of processor  and deleted, or removed to another location, after completion of the calculations performed by processor  in the course of the collaboration checking procedure.","The set of global state vectors determined by processor  is comprised of vectors of any combination of values of the first and second global state vector elements. The total number N of global state vectors to be generated by processor  can be calculated by:\n\n\u00d72(1, 2)\n\nwhere \u03a0 represents a mathematical product, mrepresents the total number of local states of an individual process participant , with \u03a0 mthus representing the product of the total local state numbers of all process participants , . . . , and k represents the total number of messages that may occur.\n","In the example process specified by the UML state chart diagrams of , the total number of local states of participant is 2 (S, S), the total number of local states of participant is 1 (S), and the total number k of messages is 3 (Mx, My, Mz). The total number N of global state vectors, hence virtual global states, for the example process is therefore:\n\n2\u00d71\u00d72=16\n","The global state vectors will have five vector elements each, two indicating the local states of participants , and three others indicating presence or non-presence of messages Mx, My, and Mz. The following table illustrates all 16 global state vectors (GSV) and corresponding virtual global states (VGS) that can be formed in the case of the example process:",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"GSV","VGS"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(S2; S3; 1; 1; 1)","0"]},{"entry":[{},"(S2; S3; 1; 1; 0)","1"]},{"entry":[{},"(S2; S3; 1; 0; 1)","2"]},{"entry":[{},"(S2; S3; 1; 0; 0)","3"]},{"entry":[{},"(S2; S3; 0; 1; 1)","4"]},{"entry":[{},"(S2; S3; 0; 1; 0)","5"]},{"entry":[{},"(S2; S3; 0; 0; 1)","6"]},{"entry":[{},"(S2; S3; 0; 0; 0)","7"]},{"entry":[{},"(S1; S3; 1; 1; 1)","8"]},{"entry":[{},"(S1; S3; 1; 1; 0)","9"]},{"entry":[{},"(S1; S3; 1; 0; 1)","10"]},{"entry":[{},"(S1; S3; 1; 0; 0)","11"]},{"entry":[{},"(S1; S3; 0; 1; 1)","12"]},{"entry":[{},"(S1; S3; 0; 1; 0)","13"]},{"entry":[{},"(S1; S3; 0; 0; 1)","14"]},{"entry":[{},"(S1; S3; 0; 0; 0)","15"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In the above table, the first element of each global state vector indicates the local state of participant , the second vector element indicates the local state of participant . The last three vector elements are associated to messages Mx, My, and Mz, in that order. Here, a binary value 1 may symbolize presence of a particular message, whereas a value 0 may represent non-presence of that message, or conversely.","As an example, virtual global state VGS  defines a constellation where participant is in local state S, participant assumes local state S, message Mx is non-present (assuming an interpretation of \u201c0\u201d as being indicative of non-presence), message My is also non-present, and message Mz is underway.","Having generated and stored information representing the set of global state vectors in the above-described manner, processor  proceeds by generating global state transition information that describes the global state transition behavior of the above-mentioned virtual global state machine having all the virtual global states. Specifically, processor  determines all global state transitions that may occur in the virtual global state machine as a consequence of the local state transitions as specified by the process specification data stored in storage location DB.","Even more specifically, taking one of the local state transitions and one of the virtual global states, processor  checks if the starting local state of that local state transition is identical to the local state indicated for the corresponding participant in the virtual global state. If the starting local state of the local state transition is different from that participant's local state as indicated in the virtual global state, the local state transition is impossible to occur in that virtual global state, i.e., it is not applicable. However, if there is identity between the starting local state of the local state transition and the local state indicated for the participant in the virtual global state, it is additionally checked if the trigger of the local state transition is a local event or an incoming message that is indicated as present, or underway, in the virtual global state. If this is true, the local state transition may occur in the virtual global state, i.e., it is applicable. On the other hand, if the trigger of the local state transition is a message that is non-present in the virtual global state considered, the local state transition is impossible to occur in that virtual global state, i.e., it is not applicable.","Once a local state transition has been found applicable to a virtual global state, a new, or target, virtual global state is determined that will result from that local state transition. To this end, it is determined what is the target local state of the participant experiencing the local state transition. Taking into account the fact that any triggering message is consumed as a consequence of the local state transition and therefore ceases to exist, and taking also into account any resulting message that may come into existence as an accompaniment to the local state transition, the new virtual global state can be easily determined based on the target local state, which is taken as the local state of the corresponding participant in the new virtual global state, and also based on the consumption and production of any messages.","To facilitate understanding of the above, a description of an example follows where it is checked which of local state transitions LST \u2013LST  of the example process are applicable to virtual global state VGS  from the table above. One finds easily that only two local state transitions are applicable, while the remaining three are impossible to occur in VGS . The applicable local state transitions are LST , defined by vector (_; S; S; #; Mz), and LST , defined by vector (_; S; S; Mx; My). LST  is a local state transition of participant from local state S to that same state, i.e., a transition-to-self, in response to a local triggering event #, with the emission of message Mz as the resulting event. As the starting local state of LST  is identical to the local state indicated for participant in virtual global state VGS , namely S, and as the trigger of the local state transition is an event local to participant , the conclusion is that LST  is applicable to VGS . Application of LST  to VGS  results in a global state transition from VGS  to VGS . No message is consumed in this local state transition as it is triggered by a local event. On the other hand, LST  causes production and emission of message Mz. From a global perspective, LST  thus adds a further message, Mz, to message Mx already existent in VGS . Target virtual global state of the global state transition caused by LST  is therefore a virtual global state in which participant is in local state S (participant is left unaffected by this local state transition), participant is in local state S (participant experiences a transition-to-self), and both messages Mx and Mz are existent. The one virtual global state meeting this scenario is VGS .","Local state transition LST  is likewise applicable to virtual global state VGS . LST  is a transition-to-self of participant from local state S to that same state, with message Mx triggering the transition and message My being emitted as a result. Therefore, LST  has a starting local state identical to that which is required by VGS  as the local state of participant , S. Moreover, message Mx, the trigger of LST , is a message existent in VGS , as indicated by the value \u201c1\u201d of the third vector element in the global state vector corresponding to VGS . Consequently, local state transition LST  is possible to occur in virtual global state VGS .","Application of LST  to VGS  results in a global state transition from VGS  to VGS . As before, participant remains unaffected by this local state transition, and participant undergoes a transition-to-self. However, LST  leads to consumption of message Mx while message My is produced by participant . Therefore, target virtual global state of the global state transition caused by LST  is a virtual global state in which participants , are in local states S and S, respectively, and message My is present only. Virtual global state VGS  represents this scenario.","The remaining local state transitions LST , LST , and LST  are not applicable to virtual global state VGS . LST , represented by vector (_; S; S; #; Mx), requires local state S to be the starting local state of participant , much like LST , represented by vector (_; S; S; Mz; #). This, however, contrasts with the requirement of VGS  that participant be in local state S. Finally, LST , represented by vector (_; S; S; My; #), needs message My as the trigger. In virtual global state VGS , however, no message My is underway as indicated by the value \u201c0\u201d of the fourth vector element in the global state vector corresponding to VGS . Therefore, local state transitions LST , LST , and LST  are impossible to occur in virtual global state VGS .","Generally, processor  checks applicability of every local state transition in relation to every virtual global state, and then determines for each applicable situation what is the target virtual global state that will result from application of a particular local state transition to a particular virtual global state. In this way, processor  obtains global state transition information that is added to storage location DB (step  in ). Thereafter, storage location DB includes all the information necessary to create a global state transition graph of a virtual global state machine having all the virtual global states. The virtual global states form nodes of the graph, and connections between nodes represent global state transitions experienced by the virtual global state machine when subjected to local state transitions. As with the local state transitions, global state transitions can involve a transition from one virtual global state to another, or a transition-to-self looping back to the same virtual global state.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 6","FIG. 3","FIG. 6","FIG. 6"],"b":["0","15","1","5","0","15","3","3","5","3","2"]},"Having entirely generated, and stored in storage location DB, all the information on the virtual global states and the global state transitions in the above manner, processor  uses this information to determine a subset of valid global states from the virtual global states (step  in ). That is, not all virtual global states may actually occur when carrying out the collaborative process under examination. In practice, the collaborative process will start with no message being underway. Further, there must be specified at least one local state transition applicable to one of the participants to the collaborative process at the time the collaborative process starts. The trigger of such local state transition must be an event local to the corresponding participant, since no message is underway at the time the collaborative process starts. These restraints will limit the number of virtual global states that may actually be entered when carrying out the collaborative process to a subset of virtual global states called valid global states hereinafter.","To determine the valid global states, processor  retrieves the information from storage location DB and proceeds with identifying one or more initial global states among the virtual global states, with an initial global state being defined as one in which at least one local state transition as specified by the local state transition data and involving a local trigger is applicable to the initial global state and no message is being communicated between the participants. Further, the local state transition must not result in a global state transition looping back to the same starting global state.","Referring to the example process specified by the state chart diagrams of , the only virtual global states that have no messages underway are VGS  and VGS . In VGS , participant is in local state S and participant is in local state S. A comparison of local state transitions LST \u2013LST  shows that LST  is applicable to VGS  since it has a local trigger and requires a starting local state that is identical to the local state of one of participants , in VGS . Application of LST  to VGS  leads to VGS , which is different from the starting virtual global state VGS . Therefore, virtual global state VGS  is an initial global state. No other local state transition is applicable to VGS  though.","As for VGS , this is a virtual global state to which local state transitions LST  and LST  are applicable, both requiring a local trigger and having starting local states identical to the local state of one of participants , in VGS . Application of LST  and LST  to VGS  leads to VGS  and VGS , respectively. Again, the target virtual global states are different from the starting virtual global state. Hence, virtual global state VGS  is another initial global state.","Next, processor  determines for each initial global state found, all virtual global states that can be reached by the virtual global state machine when starting from an initial global state. The initial global state and every virtual global state reachable from that initial global state are then determined to be valid global states.","As an example, by screening the global state transition graph of  for valid virtual global states, or nodes, one can easily find that, in addition to starting nodes  and , nodes , , , , , and  are valid nodes. These are the only nodes that can be reached in the global state transition graph of  when starting from either of nodes  and . The remaining nodes , , , , , , and , cannot be reached from nodes  and  and therefore represent invalid virtual global states. Eliminating in the global state transition graph of  any invalid nodes and any connections between invalid nodes and between invalid and valid nodes results in the partial graph shown in , which represents a valid global state machine model of the collaboration process specified by the state chart diagrams of .","In an alternate embodiment, only one virtual global state may be allowed as an initial global state. Further, the definition of an initial global state may be altered or supplemented to refer to a virtual global state for which no state transition exists of which it is the target virtual global state.","Hereinafter, a valid global state machine model of a collaborative process is referred to as a collaboration state machine model of the process. Its states are called collaboration states and are constituted by the valid virtual global states forming the valid nodes of the global state transition graph. A collaboration state machine model for a process specification under examination is thus defined by the entirety of valid virtual global states of the process as specified and the entirety of valid global state transitions, i.e., global state transitions involving valid virtual global states both on the starting and the target sides. Such valid global state transitions are referred to hereinafter as collaboration state transitions. In a step  in , processor  labels every valid global state stored in storage location DB to be a collaboration state, by adding a suitable annotation object.","Subsequently, processor  analyzes the collaboration state machine model for presence of incompletely specified terminal collaboration states (step  in ). A terminal, or dead-end, collaboration state is one that is never the starting state of a collaboration state transition that would lead to a different collaboration state. In other words, a terminal collaboration state is a node in the collaboration state machine model that has no outbound state transitions and therefore can not be left.","There may exist one or more terminal collaboration states where no messages are underway. Such terminal collaboration states may be acceptable and are not deemed incompletely specified. Only a terminal collaboration state where one or more messages are underway indicates an incompleteness in the process specification. In order for the process specification to be complete and consistent, any such incompletely specified terminal collaboration states need to be corrected by the process designer(s).","To explain this by way of an example, it is referred to . There, it can be seen that while each of collaboration states , , , , , , and  can be left through a collaboration state transition, collaboration state  is a terminal (dead-end) state. This collaboration state is associated with three collaboration state transitions, one pointing from collaboration state  to collaboration state , another one leading from collaboration state  to collaboration state , and a third one beginning with collaboration state  but looping back to its origin, i.e., a transition-to-self. There is no collaboration state transition originating from collaboration state  and leading to a different collaboration state.","Terminal collaboration state  points at an unspecified scenario in the design of the collaboration process. In fact, collaboration state  represents a situation where participant is in local state S, participant is in local state S, and message Mz is on its way. The specification of the example process does not deal with this situation; it leaves unanswered how message Mz shall be processed. The process specification is therefore incomplete and needs to be amended accordingly. On the other hand, if no message were underway in collaboration state , the situation might be tolerable as no processing of a message were necessary. In such case, collaboration state  would not be deemed incompletely specified.","In a following step designated  in , processor  effects generation, and preferably storage in a further storage location DB, of a result data object containing information on every incompletely specified terminal collaboration state found. The storage location DB can be a database, a file, or any other suitable data repository that allows to hold data in an organized or structured manner. This location can be a resource accessible by some or all of the software developers involved in designing the process so as to enable plural developers to learn of the examination result of the collaboration checking procedure. To this end, it is conceivable that the result data object is stored on a network computer (server) of the computer system . Of course, storing the result data object in memory  of computer workstation  or anywhere else in the computer system  is also possible. For sake of illustration only, the result data object is shown in  as being stored in memory  of computer workstation .","In a preferred embodiment, the result data object can be forwarded to output device  to visually present on a display a graphical presentation object indicating every incompletely specified terminal collaboration state found. Specifically, processor  may effect display, or printing, of a result list containing at least every incompletely specified dead-end collaboration state. In one embodiment, the result list specifies every virtual global state as determined by processor  and indicates for each virtual global state whether or not the respective virtual global state is valid, whether or not it is a dead-end state, and whether or not it represents an incompleteness in the process specification. In an alternate embodiment, the result list may specify only those valid virtual global states that are found to be incompletely specified terminal collaboration states.","Part of an exemplary result list that may be presented to the developer on the graphical user interface displayed on output device  of computer workstation  is depicted in . There, a number indicating the respective virtual global state is followed by an annotation object AO that indicates whether or not the particular virtual global state is valid or invalid (i.e., a collaboration state). Another annotation object AO indicates in relation to every virtual global state whether or not the respective virtual global state is a dead-end state or a live-end state. A further annotation object AO, finally, indicates whether or not the process specification under examination is complete in relation to the respective virtual global state.","Summarizing briefly the above collaboration checking procedure, processor  retrieves in response to a user-effected control signal, process specification data from a storage location DB and generates, and at least temporarily stores in another storage location DB, information on virtual global states, global state transitions, and which of the virtual global states are valid global states, i.e., collaboration states. Thereafter, processor  retrieves the information stored in the storage location DB to determine incompletely specified dead-end collaboration states. Finally, processor  generates a result data object containing information on every incompletely specified terminal collaboration state found. The result data object can be stored in yet another storage location and\/or forwarded to a graphical output device for visual presentation of a presentation object on a display, for example, in the form of a result list indicating every incompletely specified dead-end collaboration state.","The collaboration checking procedure as briefly summarized above has been described in the foregoing as starting out from process specification data specifying local states and state transitions for each participant system. In some cases, however, information on the participants' local states and local state transitions may not be readily available. That is, in some cases the collaborative process may be specified by the process designer(s) in relation to individual software objects of a participant system rather than the participant system as a whole. Each participant system can comprise a plurality of such software objects, which form functional units having unique states and experiencing unique state transitions in response to triggering events such as incoming messages or local events.","Examples of software objects, which can represent business objects such as a purchase order object or other business-related objects, are given in .  shows a schematic state chart diagram for an object , and  shows a schematic state chart diagram for another object O, both objects being part of the same participant system, e.g., or . Object Ocan assume four different states O, O, O, and O, and object Ocan assume five different states O, O, O, O, and O. Both objects O, Ocan experience state transitions as indicated by arrows and associated descriptions in . Similar to , Ma\u2013Mi refer to various messages and # refers to a local event, which can, e.g., be a transaction. It is possible that a transaction or message triggers state transitions of two or more objects in the same participant system.","Hereinafter, an embodiment of a collaboration checking procedure is described that is adapted to draw on state transition information of multiple objects of each participant system to determine a collaboration state machine model of a process under examination. This embodiment first determines a local state machine for each participant system from the objects' state transition information and then determines the collaboration state machine model based on the local state machines in the manner described above. Main steps of the procedure are illustrated in the flowchart diagram of . First, in a step , processor , under control of the CPP embodying the procedure according to this embodiment, retrieves the objects' state transition information from a storage location DB where it has been stored by the designer(s) of the process. Similarly to storage location DB, storage location DB can be within memory  of computer workstation , or on any other computer workstation ,  . . . connected to computer system , or even on a network server of network . The storage location DB can be a shared resource giving all process developers access to the data in the storage location DB. The objects' state transition information stored in storage location DB indicates for each object, states and state transitions of the respective object along with messages and events that trigger, and result from, that object's state transitions.","In a following step , processor  identifies initial local states of the participant systems. Each initial local state is a vector comprised of an initial object state of all objects of a respective participant system, with an initial object state being one that has no predecessor, i.e., no inbound state transition from another object state. In one embodiment, only one initial local state per participant system may be allowed. In an alternate embodiment, more than one initial local state may be allowed for each participant system.","For example, in the state chart diagrams of objects Oand Oshown in , object state O of object Ohas no predecessor and is therefore an initial object state for object O. Likewise, object state O of object Ohas no predecessor and is therefore an initial object state for object O. Assuming that objects Oand Oare the only objects of a participant system, an initial local state Sof that participant system would be defined as a vector comprising vector elements O and O, i.e., S=(O; O). As all other object states of objects Oand Ohave predecessors, O and O are the only initial object states, and no further initial local state can be identified for the particular participant system.","Having identified at least one initial local state for each participant system, processor  determines in an ensuing step  subsequent local states for each participant system. This is done by applying object state transitions as specified by the state transition information retrieved from storage location DB to the initial local states. Specifically, processor  checks for each object state transition if the respective object state transition is possible to occur (applicable) in a respective initial local state by comparing the starting object state of the respective object state transition with the corresponding object's state in the initial local state. If there is identity between the starting object state and the object's state as given by the initial local state, then the particular object state transition is applicable.","Further above, it has already been indicated that a transaction or message may trigger state transitions of two or more objects in the same participant system. This is unlike the virtual global state machine where a local event or message can trigger one global state transition only. In the case of the object state transitions, the same message can be consumed by two or more objects at the same time, causing this multiplicity of objects to concurrently experience a state transition each. The same is true of local triggering events such as a transaction, which can be processed by two or more objects at the same time. Therefore, a new local state that is subsequent to an initial local state is determined by taking a particular triggering event and simultaneously applying to the initial local state all object state transitions that are initiated by this triggering event and are applicable to the initial local state considered. Thereafter, a further triggering event is taken, and all object state transitions that are initiated by this further triggering event are applied, if possible, to the initial local state, thus giving another subsequent local state. This is repeated for all triggering events, which can be messages, transactions, and other local events.","Having determined all subsequent local states to all initial local states, processor  proceeds be determining further new local states by applying object state transitions to the local states just found, in the same manner as is done with the initial local states. This is repeated until no new local states are found and a complete local state machine (local state transition graph) is determined for each participant system.","Having determined the local state machines of all participant systems, processor  proceeds by storing these local state machines as local state transition information in storage location DB (step  in ). The local state transition information thus generated and stored serves as input to the next level of analysis where a collaboration state machine model and incompletely specified terminal collaboration states are determined from the local state transition information (step  in ). To this end, the procedure explained and illustrated in connection with  can be employed.","Further above, an embodiment has been described where the collaboration state machine model of the process under examination is determined from a virtual global state machine by identifying and extracting valid global states from a set of virtual global states of the virtual global state machine. In cases where a number of messages are exchangeable between the participant systems and the latter can assume a number of different local states, the number of virtual global states and global state transitions can be very high, requiring considerable memory space for storing the virtual global state machine. In the following an embodiment is described with reference to the flow chart diagram of  that consumes less memory for generating the collaboration state machine model by ignoring irrelevant global states.","In this embodiment, the collaboration state machine model is generated directly from the local state transition information stored in DB without first generating a maximum possible set of virtual global states. Specifically and as illustrated in , processor  retrieves the local state transition information from DB (step ) and then determines a list of initial collaboration states from the retrieved local state transition information (step ). An initial collaboration state is defined by each participant system assuming an initial local state and each message having a non-presence communication status. In other words, an initial collaboration state is a global state in which each participant system is in an initial local state and no messages are underway. An initial local state is a local state that has no predecessor, i.e., no inbound state transition from another local state. There may be allowed a single initial local state for each participant system only. In this case, the list of initial collaboration states will be comprised of a single initial collaboration state. Alternatively, there may be allowed more than one initial local state per participant system. Then, the list of initial collaboration states may contain more than one list member.","In the example process illustrated by the state chart diagram of , S is an initial local state of participant system since this local state has no predecessor. On the other hand, local state S of participant system is no initial local state as it has an inbound transition from S. Further, local state S is an initial local state of participant system : it is the only local state. Therefore, an initial collaboration state of the process specified by the state chart diagram of  is (S; S; ; ; ), which corresponds to VGS  of the above table of virtual global states. There are no more initial collaboration states.","Having determined every initial collaboration state, processor  determines in a following step  subsequent collaboration states by applying the local state transitions specified by the information retrieved from DB to the initial collaboration state(s). Application of local state transitions to a collaboration state, which is a global state, has already been described in detail hereinabove. A further explanation is therefore omitted. New or subsequent collaboration states are determined by applying the local state transitions to every initial collaboration state. These subsequent collaboration states are in turn subjected to application of the local state transitions to determine further collaboration states. This is reiterated until no further collaboration states are found and the complete collaboration state transition graph is determined. Processor  then stores the collaboration state transition information thus generated in storage location DB (step  in ) and continues with an analysis of the collaboration state transition graph to identify any incompletely specified terminal collaboration states (step ).","Referring again to the example process specified by the state chart diagram of , a person skilled in the art will be readily able to verify that starting from VGS  as an initial collaboration state all other collaboration states of the collaboration state machine model of , i.e., VGS , , , , , , and , can be obtained using the above-described technique.","While the invention has been described with reference to preferred embodiments, those skilled in the art will readily appreciate that various changes may be made thereto without departing from the scope of the invention. The invention is therefore intended to include all embodiments that are within the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Hereinafter, the present invention is described in more detail in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 7","FIG. 2"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 9 and 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
