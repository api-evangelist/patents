---
title: Method of handling overlapping notification requests in networks with open application programming interfaces
abstract: In the method of handling overlapping notification requests in a network with an open application programming interface, a response is received from a server to a notification request sent to the server based on a notification request entry in a plist. The notification request requests access to at least one object. Then, notification request entries in an rlist associated with the notification entry in the plist are identified, and the response is sent to an application associated with one of the identified notification request entries in the rlist. When a new notification request is received from an application, the new notification request is added to the rlist, and at least one of the plist and links between the notification request entries in the rlist and plist are altered. When a disable request requesting that a notification request be disabled is received from an application, at least one of the plist and links between the notification request entries in the plist and the rlist are altered.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07599986&OS=07599986&RS=07599986
owner: Alcatel-Lucent USA Inc.
number: 07599986
owner_city: Murray Hill
owner_country: US
publication_date: 20020326
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to networks with open application programming interfaces, and more particularly, a method of handling overlapping notification requests in such networks.","2. Description of Related Art","The well-known Parlay specification, as well as other specifications such as OSA and JAIN, define an architecture that enables service application developers to make use of network functionality through an open standardized interface. The Parlay Application Programming Interface (API) contains the Framework APIs and Service APIs for Call Control, User Interaction, Messaging, and others. Similarly, OSA contains Service Capability Servers that include the Framework, Call Control, User Interaction, and others. OSA is based on Parlay, but emphasizes mobility. The Parlay Call Control API contains the interfaces IpCallControlManager and IpAppCallControlManager. The IpCallControlManager offers the enableCallNotification( ) method, which can be used by client applications to indicate their interest to be notified when certain call events take place. Its peer, the IpAppCallControlManager, offers the callEventNotify( ) method, which can be used to inform the application of the occurrence of a call event.","Events, such as call events in Parlay, are identified by event criteria in a notification request. The event criteria define the events required by the application. For example, the event criteria consist of OriginatingAddress, DestinationAddress, CallEventName, CallNotificationType, and MonitorMode in the enableCallNotification( ) method of Parlay. Actual events that meet these criteria are reported via the callEventNotify( ) method.","Because the method according to the present invention will be described, in part, based on examples with respect to Parlay, the event criteria of this specification will now be defined.","The OriginatingAddress and DestinationAddress are assumed to be E.164 addresses of length at least one satisfying {, , . . . , }{?}{*}, and n, m\u22670. In other words, address strings have length at least one, start with zero or more digits followed by zero or more question marks followed by zero or one *. The wildcard \u2018?\u2019 stands for any digit, and \u2018*\u2019 stands for a sequence of zero or more digits. Examples of valid addresses are , ?, *, ?, ??, *, and ??*.","CallEventName specifies a call event. Possible events are OFFHOOK_EVENT=1, ADDRESS_COLLECTED_EVENT=2, ADDRESS_ANALYSED_EVENT=4, CALLED_PARTY_BUSY=8, CALLED_PARTY_UNREACHABLE=16, NO_ANSWER_FROM_CALLED_PARTY=32, ROUTE_SELECT_FAILURE=64, ANSWER_FROM_CALL_PARTY=128.","The CallNotificationType P_ORIGINATING specifies that the application is interested in triggers generated by the originating call state model, while P_TERMINATING specifies that the application is interested in triggers generated by the terminating call state model. This terminology is derived from the intelligent network.","The MonitorMode INTERRUPT specifies that the application will get access to the call object when it receives the callEventNotify( ) method, and control how call processing proceeds, while NOTIFY specifies that the application will only get a notification that a certain call state occurred in the network.","The Parlay specifications state that if some application issues a notification request with criteria that overlap the specified criteria in previously received notification requests, the newly issued request is refused. For example, in Parlay, the criteria are said to overlap if both originating and terminating ranges overlap and the same number plan is used and the same CallNotificationType is used. The point is that it should not be possible for applications to request access to the same object more than once. In Parlay and OSA, overlap can occur only between event criteria for which the monitor mode is set to INTERRUPT, since if the monitor mode is set to NOTIFY, no access to a call object is requested.","The approach of not allowing overlap between event criteria is robust, but has a number of disadvantages. For example,\n\n","In the method according to the present invention, the no overlap requirement of conventional open API specifications, such as Parlay, OSA, JAIN etc., is satisfied while still permitting receipt of overlapping notification requests from applications. In one embodiment of the present invention, notification requests from applications are stored in a first list called an rlist. The entries made in the rlist are permitted to overlap. However, a second list called a plist, created from the entries in the rlist, contains no overlapping notification requests. Databases of links from the rlist to the plist and from the plist to the rlist are maintained. The notification requests in the plist are sent to one or more servers. When a server returns a response, the interested applications are identified using at least the rlist and in one embodiment the plist and the links from the plist to the rlist. The response is then delivered to one of the interested applications.","The delivery of the response is managed, in one embodiment, according to a methodology for prioritizing the interested applications, and is simply random or first come first serve in other embodiments.","In an implementation, an overlap handler logically disposed between the applications and the server or servers keeps and manages the notification requests, responses, rlist, plist and links according to the methodologies of the present invention. Specifically, the overlap handler includes methodologies for handling a new notification request from an application, handling a request to disable a notification request from an application, and handling a request to change a notification request.","In the methodology for handling a new notification request, the new notification request is added to the rlist, and at least one of the plist and the links between the entries in the plist and rlist are updated based on a comparison of the new notification request with one or more of the notification requests in the plist.","In the methodology for handling a request to disable\/delete a notification request, the notification request is removed from the rlist and at least one of the plist and the links between the entries in the plist and rlist are updated.","In handling a request to change a notification request, the notification request being changed is disabled according to the methodology for handling a request to disable\/delete a notification request, and changed version of the notification request is added according to the methodology of handling a new notification request. Either of the disabling and the adding can be performed first. Also, alternatively or additionally, in handling a request to change a notification, a determination is made as to whether changes can be made directly or whether no changes are required.","While still meeting the no overlap requirement for notification requests sent to the server or servers, the methodologies of the present invention also permit overlapping notification requests from the applications such that at least (1) a single application can not block requests for notifications from other applications; (2) new requests with overlapping event criteria are not refused (even if there is only partial overlap with criteria in already requested notifications); (3) if applications disable or change notifications (e.g., using the disableCallNotification( ) or changeCallNotification( ) methods), other applications do not miss events covered by those disabled or changed notifications; and (4) it is possible to control dispatching of actual events to applications.","The general architecture and functionality of the overlap handler according to the present invention will be described with respect to . This will be followed by a detailed description of the handling of a new notification request, handling of a request to disable\/delete a notification request, handling of a request to change a notification request, and handling of a response to a notification request.","General Architecture and Functionality",{"@attributes":{"id":"p-0028","num":"0031"},"figref":"FIG. 1","b":["10","12","20","20","12","20","12","20","22","24"]},"Notification requests issued by the applications  are received by the overlap handler  and added to (i.e., stored in) the rlist. Specifically, the notification request indicates by event criteria the objects required by the application (e.g., the enableCallNotification( ) method of Parlay and OSA for call events). The overlap handler  then compares the received notification request to the notification request entries in the plist and possibly modifies the plist, the links from the rlist notification request entries to the plist notification request entries, and the links from the plist notification request entries to the rlist notification request entries based on the comparison.","The overlap handler  delivers notification request entries in the plist to the server . When a response to a notification request is received, the overlap handler  accesses the plist, the rlist and the links between the plist and the rlist entries to determine to which of the applications  to deliver the response.","Handling of a New Notification Request","For the purposes of simplifying the explanation only, the handling of a new notification request will be described in the context of an open API specification according to Parlay. Also, suppose all event criteria in enableCallNotification( ) methods from applications satisfy CallEventName=4, CallNotificationType=P_ORIGINATING, and MonitorMode=INTERRUPT. If an application  sends a new notification request, the overlap handler  adds an entry to a database referred to as the rlist. The rlist is a database stored in the memory unit . In the rlist, the notification request is stored as an entry and an identifier for the application  is associated with the entry. The rlist is used to store notification requests issued by the applications  and identifiers identifying which notification requests are associated with which applications . In storing notification requests in the rlist, there is no prohibition against storing overlapping notification requests.","Next, the overlap handler  checks whether the event criteria in the new notification request entry in the rlist overlap with the event criteria that already exist in a database referred to as the plist. The plist is another database stored in the memory unit . Unlike the rlist, no overlapping notification request entries are permitted in the plist. As discussed above, it is from the plist that notification requests are sent to the server . Because the plist notification entries do not overlap, the notification requests sent to the server  comply with the no overlap requirement of open API standards like Parlay and OSA. The plist also stores an identifier, assigned by the server , in association with each of the notification request entries sent to the server .","To explain the process of checking the new notification entry in the rlist with notification entries in the plist, examine the following four cases that result when comparing OriginatingAddress Oand OriginatingAddress O:",{"@attributes":{"id":"p-0034","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Notation","Description","Example"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"O \u2260 O","O and O are","O = 1111   O = 8888"]},{"entry":[{},{},"different and non-"]},{"entry":[{},{},"overlapping"]},{"entry":[{},"O = O","O equals O","O = 1111   O = 1111"]},{"entry":[{},"O \u2282 O","O is a subset of O","O = 1111   O = 11??"]},{"entry":[{},"O \u2283 O","O is a superset of","O = 111?   O = 1111"]},{"entry":[{},{},"O"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Now, examine the 16 cases that can occur when O\u2192D(Ocalls D) is the only entry currently in the plist, and it is compared with O\u2192D(Ocalls D), which is added to the rlist:",{"@attributes":{"id":"p-0036","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Compare (O \u2192",{}]},{"entry":["Number","Case","D, O \u2192 D)","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","O \u2260 O   D \u2260 D","ADD","1111 \u2192 2222"]},{"entry":[{},{},{},"(O \u2192 D)"]},{"entry":[{},{},{},"8888 \u2192 9999"]},{"entry":[{},{},{},"(O \u2192 D)"]},{"entry":["2","O \u2260 O   D = D","ADD","1111 \u2192 2222"]},{"entry":[{},{},{},"8888 \u2192 22222"]},{"entry":["3","O \u2260 O   D \u2282 D","ADD","1111 \u2192 2222"]},{"entry":[{},{},{},"8888 \u2192 22??"]},{"entry":["4","O \u2260 O   D \u2283 D","ADD","1111 \u2192 222?"]},{"entry":[{},{},{},"8888 \u2192 2222"]},{"entry":["5","O = O   D \u2260 D","ADD","1111 \u2192 2222"]},{"entry":[{},{},{},"1111 \u2192 9999"]},{"entry":["6","O = O   D = D","NO","1111 \u2192 2222"]},{"entry":[{},{},{},"1111 \u2192 2222"]},{"entry":["7","O = O   D \u2282 D","UPDATE","1111 \u2192 2222"]},{"entry":[{},{},{},"1111 \u2192 22??"]},{"entry":["8","O = O   D \u2283 D","NO","1111 \u2192 222?"]},{"entry":[{},{},{},"1111 \u2192 2222"]},{"entry":["9","O \u2282 O   D \u2260 D","ADD","1111 \u2192 2222"]},{"entry":[{},{},{},"11?? \u2192 9999"]},{"entry":["10","O \u2282 O   D = D","UPDATE","1111 \u2192 2222"]},{"entry":[{},{},{},"11?? \u2192 2222"]},{"entry":["11","O \u2282 O   D \u2282 D","UPDATE","1111 \u2192 2222"]},{"entry":[{},{},{},"11?? \u2192 22??"]},{"entry":["12","O \u2282 O   D \u2283 D","EXPAND","1111 \u2192 222?"]},{"entry":[{},{},{},"11?? \u2192 2222"]},{"entry":["13","O \u2283 O   D \u2260 D","ADD","111? \u2192 2222"]},{"entry":[{},{},{},"1111 \u2192 9999"]},{"entry":["14","O \u2283 O   D = D","NO","111? \u2192 2222"]},{"entry":[{},{},{},"1111 \u2192 2222"]},{"entry":["15","O \u2283 O   D \u2282 D","EXPAND","111? \u2192 2222"]},{"entry":[{},{},{},"1111 \u2192 22??"]},{"entry":["16","O \u2283 O   D \u2283 D","NO","111? \u2192 222?"]},{"entry":[{},{},{},"1111 \u2192 2222"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The result of this comparison has four possible outcomes as indicated in the above table:\n\n","Next the methodology to update the plist when an entry is added to the rlist will be described in detail. For the purposes of this discussion, consider the situation that the length of the plist is arbitrary. Also assume a plist of event criteria for which enableCallNotification( ) methods are invoked on the server .","If a new notification request entry is added to the rlist, the new notification request, namely, the new event criteria are compared with the criteria of all the entries in the plist. Assume, for the purposes of explanation, a plist of length l\u22671, since if the plist has length 0, no comparisons are necessary. The following different cases can be distinguished when the new event criteria are compared with all the entries in the plist:\n\n","Given the above possible results to the comparison, the overlap handler  proceeds as follows:\n\n",{"@attributes":{"id":"p-0041","num":"0062"},"figref":"FIG. 2","ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["4. If m (m\u22671) comparisons return with outcome EXPAND, k (k\u22670) comparisons return with outcome UPDATE, and the others return with outcome ADD, the overlap handler  removes the k UPDATE entries from the plist and expands the m EXPAND entries together with the new entry such that the length of the plist remains as short as possible. The length of the plist can increase considerably. Also, the r-to-p link database and the p-to-r link database are updated accordingly.","Example of fourth case (m=1, k=1)","plist: {\u2192?, \u2192, \u2192}","New event criteria: *\u2192","Comparison gives:{EXPAND, ADD, UPDATE}","Updated plist: {\u2192, *\u2192, \u2192, \u2192, \u2192, . . . , \u2192}","Example of fourth case (m=2, k=0)","plist: {\u2192?, \u2192?, \u2192}","New criterion: ??\u2192","Comparison gives: {EXPAND, EXPAND, ADD}","Updated plist: {\u2192, ??\u2192, \u2192, \u2192, \u2192, . . . , \u2192, \u2192, \u2192, \u2192, . . . , \u2192}"]}}}},{"@attributes":{"id":"p-0042","num":"0074"},"figref":"FIG. 3","ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["Example of fourth case (m=1, k=0)","plist: {\u2192*}","New event criteria: *\u2192","Comparison gives: {EXPAND}","Updated plist: {\u2192*, *\u2192, *\u2192, *\u2192, . . . , *\u2192, *\u2192, *\u2192, *\u2192, . . . , *\u2192, ?*\u2192}","Example of fourth case (m=1, k=0)","plist: {????\u2192}","New event criteria: \u2192??","Comparison gives: {EXPAND}","Updated plist: {????\u2192, \u2192?, \u2192?, \u2192?, . . . , \u2192?, \u2192, \u2192, \u2192, . . . , \u2192}"]}}}},"As will be readily appreciated from the above description, the methodology of handling a new notification request, while described with respect to the Parlay specification, is equally applicable to other open APIs like OSA. Furthermore, it will be appreciated that the overlap handler according to the present invention permits the handling of overlapping notification requests from applications, while still complying with the no overlap requirement of open API specifications like Parlay and OSA.","Handling of a Request to Disable\/Delete a Notification Request","For the purposes of simplifying the explanation only, the handling of a request to disable\/delete a notification request will be described in the context of an open API specification according to Parlay. Also, suppose all event criteria in enableCallNotification( ) methods from applications satisfy CallEventName=4, CallNotificationType=P_ORIGINATING, and MonitorMode=INTERRUPT.","For purposes of explanation, assume the methodology discussed below is implemented with a plist of event criteria for which enableCallNotification( ) methods have been invoked on the server. After receiving a disable notification request from an application , the overlap handler  performs the following:\n\n","As an example, the table below shows the rlist and the plist when applications first send four enableCallNotification( ) methods and then two disableCallNotification( ) methods. Note that the event criteria of the fourth enableCallNotification( ) method overlap with all entries in the plist. More specifically, the comparison operation of the overlap handler  discussed in the previous section yields UPDATE three times. Therefore, all three entries in the plist are replaced by the new entry with event criteria ??\u2192. The first disableCallNotification( ) method requires no changes in the plist, while the second disableCallNotification( ) requires modification of the plist.",{"@attributes":{"id":"p-0047","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Assignment",{},{}]},{"entry":[{},"ID to"]},{"entry":["Applications","application","rlist","plist"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["enableCallNotification( )","1","1:","1111 \u2192 2222"]},{"entry":["with 1111 \u2192 2222",{},"1111 \u2192 2222"]},{"entry":["enableCallNotification( )","2","1:","1111 \u2192 2222"]},{"entry":["with 1113 \u2192 2222",{},"1111 \u2192 2222","1113 \u2192 2222"]},{"entry":[{},{},"2:"]},{"entry":[{},{},"1113 \u2192 2222"]},{"entry":["enableCallNotification( )","3","1:","1111 \u2192 2222"]},{"entry":["with 1117 \u2192 2222",{},"1111 \u2192 2222","1113 \u2192 2222"]},{"entry":[{},{},"2:","1117 \u2192 2222"]},{"entry":[{},{},"1113 \u2192 2222"]},{"entry":[{},{},"3:"]},{"entry":[{},{},"1117 \u2192 2222"]},{"entry":["enableCallNotification( )","4","1:","11?? \u2192 2222"]},{"entry":["with 11?? \u2192 2222",{},"1111 \u2192 2222"]},{"entry":[{},{},"2:"]},{"entry":[{},{},"1113 \u2192 2222"]},{"entry":[{},{},"3:"]},{"entry":[{},{},"1117 \u2192 2222"]},{"entry":[{},{},"4:"]},{"entry":[{},{},"11?? \u2192 2222"]},{"entry":["disableCallNotification( )","NA","2:","11?? \u2192 2222"]},{"entry":["with assignmentID 1",{},"1113 \u2192 2222"]},{"entry":[{},{},"3:"]},{"entry":[{},{},"1117 \u2192 2222"]},{"entry":[{},{},"4:"]},{"entry":[{},{},"11?? \u2192 2222"]},{"entry":["disableCallNotification( )","NA","2:","1113 \u2192 2222"]},{"entry":["with assignmentID 4",{},"1113 \u2192 2222","1117 \u2192 2222"]},{"entry":[{},{},"3:"]},{"entry":[{},{},"1117 \u2192 2222"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Note that in the implementation of the methodology above, refinements can be made that can improve the efficiency in certain cases. For example, if the rlist contains {\u2192, *\u2192}, the plist contains {*\u21922222}, and the entry \u2192 is removed from the rlist, it is not most efficient to first remove *\u2192 from the plist (step 8), and then add it again to the plist (step 12).","As will be readily appreciated from the above description, the methodology of handling a request to disable\/delete a notification request, while described with respect to the Parlay specification, is equally applicable to other open APIs like OSA.","Handling of a Request to Change a Notification Request","When a request to change a notification request is received from an application  by the overlap handler , the overlap handler  first disables the notification request being changed according to the methodology discussed in the Handling of a Request to Disable\/Delete a Notification Request section, and then treats the changed version of the notification request as a new notification request according to the methodology described in the Handling of a New Notification Request section.","In an alternative embodiment, when a request to change a notification request is received from an application  by the overlap handler , the overlap handler  first treats the changed version of the notification request as a new notification request according to the methodology described in the Handling of a New Notification Request section, and then disables the notification request being changed according to the methodology discussed in the Handling of a Request to Disable\/Delete a Notification Request section.","Additionally, or alternatively, the overlap handler  examines the event criteria being changed by the request, and makes only those changes to the rlist, plist and links between the notification request entries in the rlist and plist to effect the change without performing the addition and disable methodologies. For example, if (for some reason) the notification request being changed and the changed version of the notification request are the same, the overlap handler  will determine that no changes are required. As another example, if the rlist and plist each contain entries which are only linked to each other and are the notification request entry being changed, then the entry in the rlist and plist is changed to the changed version of the notification request.","Handling of a Response to a Notification Request","For the purposes of simplifying the explanation only, the handling of a response to a notification request will be described in the context of an open API specification according to Parlay. Also, suppose the event info in callEventNotify( ) methods from the server  satisfies CallEventName=4, CallNotificationType=P_ORIGINATING, and MonitorMode=INTERRUPT. If the server  sends callEventNotify( ), it is possible that multiple applications are interested in the call event, since the rlist can contain overlapping event critiria. The set of interested applications can be determined in one of the following two different ways:\n\n","Which of the two ways is most efficient, depends on the lengths of the rlist and plist. The complexity of the first way depends on the length of the plist, while the complexity of the second way depends on the length of the rlist.","The overlap handler  then prioritizes the applications  in the set of interested applications. The overlap handler  can order the applications at random or use parameters like, for example, (1) time of day of the occurrence of the call event, (2) event criteria in the event of the call event, (3) application type, etc.","Example of Dispatching the Response to a Notification Request to an Application","Suppose (1) the event \u2192 occurs at 1006 hours, (2) the set of interested applications contains app#, app#, and app# as shown in , (3) the priority methodology uses the three parameters APLType, OriginatingAddressList, and TimeOfDay in that order, and (4) the parameters are configured as follows:",{"@attributes":{"id":"p-0057","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"OriginatingAddress",{}]},{"entry":["clientAppID","APLType","List","TimeOfDay"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["app#1","2","1111, 2*","0700\u20130900, 1100\u2013"]},{"entry":[{},{},{},"1200"]},{"entry":["app#2","2","1*","1000\u20131015"]},{"entry":["app#3","3","2222","0700\u20130900"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"First, the overlap handler  looks at APLType. Since app# has the highest APLType, it has the lowest priority (by convention). Then, it looks at OriginatingAddressList to bring down the choice. However, this parameter is not conclusive in this case. Next, the overlap handler  continues with TimeOfDay, which gives the highest priority to app#. Therefore, the order of the applications (from lower to higher priority) is app#, app#, app#, and the overlap handler  dispatches the event to app#.","If no decision can be made based on the parameters, the overlap handler  orders the remaining applications at random Such a random choice is needed for example if the event in the example above occurred at 1030 hours, or if the parameters for two different applications are exactly the same. If the event can not be dispatched to the application with the highest priority (for example because it crashed), the next application in line can be tried, and so on and so forth.","As will be readily appreciated from the above description, the methodology of handling a response from the server, while described with respect to the Parlay specification, is equally applicable to other open APIs like OSA and JAIN. Furthermore, while still meeting the no overlap requirement for notification requests sent to the server , the overlap handler  also permits overlapping notification requests from the applications  such that at least (1) a single application can not block requests for notifications from other applications; (2) new requests with overlapping event criteria are not refused (even if there is only partial overlap with criteria in already requested notifications); (3) if applications disable or change notifications (e.g., using the disableCallNotification( ) or changeCallNotification( ) methods), other applications do not miss events covered by those disabled or changed notifications; and (4) it is possible to control dispatching of actual events to applications.","Multiple Server Embodiment","While the method of the present invention has been described as implemented in a system including a single server, the method is not limited to this implementation. Instead, the methodology is equally applicable to a multiple server system as illustrated in . In the multiple server  embodiment of , a server selector  determines for each entry in the plist to which of the servers  a notification request should be sent. The logic of the server selector  can use the event criteria in the plist as well as configuration and status information for each of the servers  in making these decisions as will be readily appreciated by those skilled in the art.","The invention being thus described, it will be obvious that the same may be varied in many ways. Such variations are not to be regarded as a departure from the spirit and scope of the invention, and all such modifications are intended to be included within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will become more fully understood from the detailed description given herein below and the accompanying drawings which are given by way of illustration only, wherein reference numerals designate corresponding parts in the various drawings, and wherein:",{"@attributes":{"id":"p-0022","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0029"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
