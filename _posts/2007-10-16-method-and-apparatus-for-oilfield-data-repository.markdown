---
title: Method and apparatus for oilfield data repository
abstract: The invention relates to a method for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a first data repository, obtaining a first target metamodel comprising structural description of a first plurality of data entities of the first data repository, obtaining a domain metamodel interleaved with a first mapping specification, the domain metamodel comprising structural description of a domain model for representing the plurality of oilfield entities in an application programming interface, obtaining a mapping specification associating the first target metamodel with the domain metamodel and forming the application programming interface based on the domain metamodel, the first target metamodel, and the first mapping specification using a computer implemented method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07895241&OS=07895241&RS=07895241
owner: Schlumberger Technology Corp.
number: 07895241
owner_city: Houston
owner_country: US
publication_date: 20071016
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application claims priority under 35 U.S.C. \u00a7119 to U.S. Provisional Patent Application No. 60\/852,175, filed on Oct. 16, 2006.","1. Field of the Invention","The present invention relates to techniques for performing oilfield operations relating to subterranean formations having reservoirs therein. More particularly, the invention relates to techniques for performing oilfield operations involving an analysis of reservoir operations, and the impact on such oilfield operations.","2. Background of the Related Art","Oilfield operations, such as surveying, drilling, wireline testing, completions, simulation, planning and oilfield analysis, are typically performed to locate and gather valuable downhole fluids. Various aspects of the oilfield and its related operations are shown in . As shown in , surveys are often performed using acquisition methodologies, such as seismic scanners to generate maps of underground structures. These structures are often analyzed to determine the presence of subterranean assets, such as valuable fluids or minerals. This information is used to assess the underground structures and locate the formations containing the desired subterranean assets. Data collected from the acquisition methodologies may be evaluated and analyzed to determine whether such valuable items are present, and if they are reasonably accessible.","As shown in , one or more wellsites may be positioned along the underground structures to gather valuable fluids from the subterranean reservoirs. The wellsites are provided with tools capable of locating and removing hydrocarbons from the subterranean reservoirs. As shown in , drilling tools are typically advanced from the oil rigs and into the earth along a given path to locate the valuable downhole fluids. During the drilling operation, the drilling tool may perform downhole measurements to investigate downhole conditions. In some cases, as shown in , the drilling tool is removed and a wireline tool is deployed into the wellbore to perform additional downhole testing.","After the drilling operation is complete, the well may then be prepared for production. As shown in , wellbore completions equipment is deployed into the wellbore to complete the well in preparation for the production of fluid therethrough. Fluid is then drawn from downhole reservoirs, into the wellbore and flows to the surface. Production facilities are positioned at surface locations to collect the hydrocarbons from the wellsite(s). Fluid drawn from the subterranean reservoir(s) passes to the production facilities via transport mechanisms, such as tubing. Various equipments may be positioned about the oilfield to monitor oilfield parameters and\/or to manipulate the oilfield operations.","During the oilfield operations, data is typically collected for analysis and\/or monitoring of the oilfield operations. Such data may include, for example, subterranean formation, equipment, historical and\/or other data. Data concerning the subterranean formation is collected using a variety of sources. Such formation data may be static or dynamic. Static data relates to, for example, formation structure and geological stratigraphy that define the geological structure of the subterranean formation. Dynamic data relates to, for example, fluids flowing through the geologic structures of the subterranean formation over time. Such static and\/or dynamic data may be collected to learn more about the formations and the valuable assets contained therein.","Sources used to collect static data may be seismic tools, such as a seismic truck that sends compression waves into the earth as shown in . These waves are measured to characterize changes in the density of the geological structure at different depths. This information may be used to generate basic structural maps of the subterranean formation. Other static measurements may be gathered using core sampling and well logging techniques. Core samples may be used to take physical specimens of the formation at various depths as shown in . Well logging typically involves deployment of a downhole tool into the wellbore to collect various downhole measurements, such as density, resistivity, etc., at various depths. Such well logging may be performed using, for example, the drilling tool of  and\/or the wireline tool of . Once the well is formed and completed, fluid flows to the surface using production tubing as shown in . As fluid passes to the surface, various dynamic measurements, such as fluid flow rates, pressure, and composition may be monitored. These parameters may be used to determine various characteristics of the subterranean formation.","Sensors may be positioned about the oilfield to collect data relating to various oilfield operations. For example, sensors in the drilling equipment may monitor drilling conditions, sensors in the wellbore may monitor fluid composition, sensors located along the flow path may monitor flow rates, and sensors at the processing facility may monitor fluids collected. Other sensors may be provided to monitor downhole, surface, equipment or other conditions. The monitored data is often used to make decisions at various locations of the oilfield at various times. Data collected by these sensors may be further analyzed and processed. Data may be collected and used for current or future operations. When used for future operations at the same or other locations, such data may sometimes be referred to as historical data.","The processed data may be used to predict downhole conditions, and make decisions concerning oilfield operations. Such decisions may involve well planning, well targeting, well completions, operating levels, production rates and other operations and\/or conditions. Often this information is used to determine when to drill new wells, re-complete existing wells, or alter wellbore production.","Data from one or more wellbores may be analyzed to plan or predict various outcomes at a given wellbore. In some cases, the data from neighboring wellbores or wellbores with similar conditions or equipment may be used to predict how a well will perform. There are usually a large number of variables and large quantities of data to consider in analyzing oilfield operations. It is, therefore, often useful to model the behavior of the oilfield operation to determine the desired course of action. During the ongoing operations, the operating conditions may need adjustment as conditions change and new information is received.","Techniques have been developed to model the behavior of various aspects of the oilfield operations, such as geological structures, downhole reservoirs, wellbores, surface facilities as well as other portions of the oilfield operation. Typically, there are different types of simulators for different purposes. For example, there are simulators that focus on reservoir properties, wellbore production, or surface processing. Examples of simulators that may be used at the wellsite are described in U.S. Pat. No. 5,992,519 and WO2004\/049216. Other examples of these modeling techniques are shown in Patent\/Publication Nos. U.S. Pat. No. 5,992,519, U.S. Pat. No. 6,313,837, WO1999\/064896, WO2005\/122001, US2003\/0216897, US2003\/0132934, US2005\/0149307, and US2006\/0197759.","Recent attempts have been made to consider a broader range of data in oilfield operations. For example, U.S. Pat. No. 6,980,940 to Gurpinar discloses integrated reservoir optimization involving the assimilation of diverse data to optimize overall performance of a reservoir. In another example, Patent Application No. WO2004\/049216 to Ghorayeb discloses an integrated modeling solution for coupling multiple reservoir simulations and surface facility networks. Other examples of such recent attempts are disclosed in Patent\/Publication\/Application Nos. U.S. Pat. No. 6,018,497, U.S. Pat. No. 6,078,869, U.S. Pat. No. 6,106,561, U.S. Pat. No. 6,230,101, U.S. Pat. No. 7,164,990, GB2336008, US2006\/0129366, US2004\/0220846, US2006\/0184329, and U.S. Ser. No. 10\/586,283. Some techniques involve mapping data between a data base format and an object oriented format are described, for example, in European Patent Application Nos. 1383056, 1385100, 1696348, U.S. Pat. Nos. 694,598, 5,765,159, 5,829,006, and PCT Patent Application No. WO1999\/032996.","Despite the development and advancement of managing oilfield data for oilfield operations, there remains a need to provide techniques capable of automatically generating an object-oriented application programming interface (or object API) allowing oilfield data to be accessed from a data repository of various formats. It would be desirable to have a system that allows oilfield data throughout the oilfield operation to be stored in a data repository suitable for retrieving large amounts of very specific information. One such example is a relational database, which has a constant time overhead associated with each query therefore suitable for applications that retrieve large datasets infrequently. In some cases, it may be desirable to access oilfield data through object APIs, which emphasize object-to-object navigation. In other cases, it may be desirable to eliminate expensive overhead caused by frequent suboptimal queries that retrieve single items of information. It is further desirable that such techniques be capable of one of more of the following, among others: mapping one application programming interface to multiple data repositories with different formats, accessing oilfield data from different oilfield functions using consistent interface to request data based on oilfield entities, automatically producing and maintaining mappings associating relational data with object data, implementing such mappings by generating a source code of an object library, that when compiled, provides an object view of relational data.","In general, in one aspect, the invention relates to a method for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a first data repository, obtaining a first target metamodel comprising structural description of a first plurality of data entities of the first data repository, obtaining a domain metamodel interleaved with a first mapping specification, the domain metamodel comprising structural description of a domain model for representing the plurality of oilfield entities in an application programming interface, obtaining a mapping specification associating the first target metamodel with the domain metamodel and forming the application programming interface based on the domain metamodel, the first target metamodel, and the first mapping specification using a computer implemented method.","In general, in one aspect, the invention relates to a method for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a data repository, obtaining a first structural description of a plurality of data entities of the data repository, obtaining a second structural description of a representation of the plurality of oilfield entities in an application programming interface, at least a portion of the representation of the plurality of oilfield entities is obtained from a reference metamodel, obtaining a mapping specification associating the first structural description with the second structural description, and forming the application programming interface based on the first structural description, the second structural description, and the mapping specification using a computer implemented method.","In general, in one aspect, the invention relates to a system for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The system includes a first structural description of a representation of a plurality of oilfield entities in an application programming interface, wherein the application programming interface comprises an interface layer and an implementation layer, wherein oilfield data associated with the plurality of oilfield entities is stored in a data repository accessible through the application programming interface, a first plurality of hierarchical tasks for forming the interface layer of the application programming interface based on the first structural description, and a code generator kernel for receiving user inputs and invoking the plurality of hierarchical tasks.","In general, in one aspect, the invention relates to a system for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The system includes a first structural description of a plurality of data entities of a data repository, a second structural description of a representation of a plurality of oilfield entities in an application programming interface, wherein oilfield data associated with the plurality of oilfield entities is stored in the data repository, a mapping specification associating the first structural description with the second structural description, a plurality of hierarchical tasks for forming the application programming interface based on the first structural description, the second structural description, and the mapping specification using a computer implemented method, and a code generator kernel for receiving user inputs and invoking the plurality of hierarchical tasks to form the application programming interface.","In general, in one aspect, the invention relates to a method for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a data repository, obtaining a first structural description of a plurality of data entities of the data repository, obtaining a second structural description of a representation of the plurality of oilfield entities in an application programming interface, obtaining a mapping specification associating the first structural description with the second structural description, forming an interface layer of the application programming interface based on the second structural description, and forming an implementation layer of the application programming interface based on the first structural description, the second structural description, and the mapping specification using a computer implemented method.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","Presently preferred embodiments of the invention are shown in the above-identified figures and described in detail below. In describing the preferred embodiments, like or identical reference numerals are used to identify common or similar elements. The figures are not necessarily to scale and certain features and certain views of the figures may be shown exaggerated in scale or in schematic in the interest of clarity and conciseness.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 1A-D","b":"100"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIGS. 1A-1D","FIG. 1A","FIG. 1A","FIG. 1"],"b":["100","102","104","100","106","112","112","110","114","116","112","118","118","120"],"i":"a"},"In response to the received sound vibrations) () representative of different parameters (such as amplitude and\/or frequency) of the sound vibration(s) (). The data received () is provided as input data to a computer () of the seismic recording truck (), and responsive to the input data, the recording truck computer () generates a seismic data output record (). The seismic data may be further processed as desired, for example by data reduction.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 1B","b":["106","128","102","136","130","106","132","106","106","104","106","106","133","133"],"i":["b","b","b","b","b","b"]},"A surface unit () is used to communicate with the drilling tool () and offsite operations. The surface unit () is capable of communicating with the drilling tool () to send commands to drive the drilling tool (), and to receive data therefrom. The surface unit () is preferably provided with computer facilities for receiving, storing, processing, and analyzing data from the oilfield (). The surface unit () collects data output () generated during the drilling operation. Computer facilities, such as those of the surface unit (), may be positioned at various locations about the oilfield () and\/or at remote locations.","Sensors (S), such as gauges, may be positioned throughout the reservoir, rig, oilfield equipment (such as the downhole tool), or other portions of the oilfield for gathering information about various parameters, such as surface parameters, downbole parameters, and\/or operating conditions. These sensors (S) preferably measure oilfield parameters, such as weight on bit, torque on bit, pressures, temperatures, flow rates, compositions and other parameters of the oilfield operation.","The information gathered by the sensors (S) may be collected by the surface unit () and\/or other data collection sources for analysis or other processing. The data collected by the sensors (S) may be used alone or in combination with other data. The data may be collected in a database and all or select portions of the data may be selectively used for analyzing and\/or predicting oilfield operations of the current and\/or other wellbores.","Data outputs from the various sensors (S) positioned about the oilfield may be processed for use. The data may be historical data, real time data, or combinations thereof. The real time data may be used in real time, or stored for later use. The data may also be combined with historical data or other inputs for further analysis. The data may be housed in separate databases, or combined into a single database.","The collected data may be used to perform analysis, such as modeling operations. For example, the seismic data output may be used to perform geological, geophysical, reservoir engineering, and\/or production simulations. The reservoir, wellbore, surface and\/or process data may be used to perform reservoir, wellbore, or other production simulations. The data outputs from the oilfield operation may be generated directly from the sensors (S), or after some preprocessing or modeling. These data outputs may act as inputs for further analysis.","The data is collected and stored at the surface unit (). One or more surface units () may be located at the oilfield (), or linked remotely thereto. The surface unit () may be a single unit, or a complex network of units used to perform the necessary data management functions throughout the oilfield (). The surface unit () may be a manual or automatic system. The surface unit () may be operated and\/or adjusted by a user.","The surface unit () may be provided with a transceiver () to allow communications between the surface unit () and various portions (or regions) of the oilfield () or other locations. The surface unit () may also be provided with or functionally linked to a controller for actuating mechanisms at the oilfield (). The surface unit () may then send command signals to the oilfield () in response to data received. The surface unit () may receive commands via the transceiver or may itself execute commands to the controller. A processor may be provided to analyze the data (locally or remotely) and make the decisions to actuate the controller. In this manner, the oilfield () may be selectively adjusted based on the data collected to optimize fluid recovery rates, or to maximize the longevity of the reservoir and its ultimate production capacity. These adjustments may be made automatically based on computer protocol, or manually by an operator. In some cases, well plans may be adjusted to select optimum operating conditions, or to avoid problems.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 1C","FIG. 1B","FIG. 1C"],"b":["106","128","136","106","136","106","106","143","102"],"i":["c","c","e","c"]},"The wireline tool () may be operatively linked to, for example, the geophones () stored in the computer () of the seismic recording truck () of . The wireline tool () may also provide data to the surface unit (). As shown, data output () is generated by the wireline tool () and collected at the surface. The wireline tool () may be positioned at various depths in the wellbore () to provide a survey of the subterranean formation.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 1D","FIG. 1C"],"b":["106","128","136","142","104","136","142","144","100","142","135","134"],"i":"d"},"While  depict monitoring tools used to measure properties of an oilfield (), it will be appreciated that the tools may be used in connection with non-oilfield operations, such as mines, aquifers or other subterranean facilities. Also, while certain data acquisition tools are depicted, it will be appreciated that various measurement tools capable of sensing properties, such as seismic two-way travel time, density, resistivity, production rate, etc., of the subterranean formation and\/or its geological structures may be used. Various sensors (S) may be located at various positions along the subterranean formation and\/or the monitoring tools to collect and\/or monitor the desired data. Other sources of data may also be provided from offsite locations.","The oilfield configuration in  is not intended to limit the scope of the invention. Part, or all, of the oilfield () may be on land and\/or sea. Also, while a single oilfield at a single location is depicted, the present invention may be used with any combination of one or more oilfields (), one or more processing facilities and one or more wellsites. Additionally, while only one wellsite is shown, it will be appreciated that the oilfield () may cover a portion of land that hosts one or more wellsites. One or more gathering facilities may be operatively connected to one or more of the wellsites for selectively collecting downhole fluids from the wellsite(s).",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIGS. 2A-2D","FIGS. 1A-D","FIG. 2A","FIG. 1A","FIG. 2B","FIG. 2C","FIG. 1C","FIG. 2D","FIG. 1D"],"b":["202","106","133","106","133","204","106","206","106","206"],"i":["a","b","c","d"]},"The respective graphs of  contain static measurements that describe the physical characteristics of the formation. These measurements may be compared to determine the accuracy of the measurements and\/or for checking for errors. In this manner, the plots of each of the respective measurements may be aligned and scaled for comparison and verification of the properties.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 3","FIG. 1"],"b":["300","302","302","302","302","304","302","302","106","106","302","302","308","308"],"i":["a","b","c","d","a","d","a","d","a","d","a","d"]},"Data plots (-) are examples of static data plots that may be generated by the data acquisition tools (-), respectively. Static data plot () is a seismic two-way response time and may be the same as the seismic trace () of . Static plot () is core sample data measured from a core sample of the formation (), similar to the core sample () of . Static data plot () is a logging trace, similar to the well log () of . Data plot () is a dynamic data plot of the fluid flow rate over time, similar to the graph () of . Other data may also be collected, such as historical data, user inputs, economic information, other measurement data, and other parameters of interest.","The subterranean formation () has a plurality of geological structures (-). As shown, the formation has a sandstone layer (), a limestone layer (), a shale layer (), and a sand layer (). A fault line () extends through the formation. The static data acquisition tools are preferably adapted to measure the formation and detect the characteristics of the geological structures of the formation.","While a specific subterranean formation () with specific geological structures is depicted, it will be appreciated that the formation may contain a variety of geological structures. Fluid may also be present in various portions of the formation. Each of the measurement devices may be used to measure properties of the formation and\/or its underlying structures. While each acquisition tool is shown as being in specific locations along the formation, it will be appreciated that one or more types of measurement may be taken at one or more location across one or more oilfields or other locations for comparison and\/or analysis.","The data collected from various sources, such as the data acquisition tools of , may then be evaluated. Typically, seismic data displayed in the static data plot () from the data acquisition tool () is used by a geophysicist to determine characteristics of the subterranean formation (). Core data shown in static plot () and\/or log data from the well log () is typically used by a geologist to determine various characteristics of the geological structures of the subterranean formation (). Production data from the production graph () is typically used by the reservoir engineer to determine fluid flow reservoir characteristics.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 4","FIG. 4"],"b":["400","402","454"]},"Each wellsite () has equipment that forms a wellbore () into the earth. The wellbores extend through subterranean formations () including reservoirs (). These reservoirs () contain fluids, such as hydrocarbons. The wellsites draw fluid from the reservoirs and pass them to the processing facilities via surface networks (). The surface networks () have tubing and control mechanisms for controlling the flow of fluids from the wellsite to the processing facility ().",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 5","FIG. 4","FIG. 5"],"b":["400","402","444","402","43","6","436","404"]},"Wellbore production equipment () extends from a wellhead () of wellsite () and to the reservoir () to draw fluid to the surface. The wellsite () is operatively connected to the surface network () via a transport line (). Fluid flows from the reservoir (), through the wellbore (), and onto the surface network (). The fluid then flows from the surface network () to the process facilities ().","As further shown in , sensors (S) are located about the oilfield () to monitor various parameters during oilfield operations. The sensors (S) may measure, for example, pressure, temperature, flow rate, composition, and other parameters of the reservoir, wellbore, surface network, process facilities and\/or other portions (or regions) of the oilfield operation. These sensors (S) are operatively connected to a surface unit () for collecting data therefrom. The surface unit may be, for example, similar to the surface unit () of .","One or more surface units () may be located at the oilfield (), or linked remotely thereto. The surface unit () may be a single unit, or a complex network of units used to perform the necessary data management functions throughout the oilfield (). The surface unit may be a manual or automatic system. The surface unit may be operated and\/or adjusted by a user. The surface unit is adapted to receive and store data. The surface unit may also be equipped to communicate with various oilfield equipment. The surface unit may then send command signals to the oilfield in response to data received or modeling performed.","As shown in , the surface unit () has computer facilities, such as memory (), controller (), processor (), and display unit (), for managing the data. The data is collected in memory (), and processed by the processor () for analysis. Data may be collected from the oilfield sensors (S) and\/or by other sources. For example, oilfield data may be supplemented by historical data collected from other operations, or user inputs.","The analyzed data (e.g., based on modeling performed) may then be used to make decisions. A transceiver (not shown) may be provided to allow communications between the surface unit () and the oilfield (). The controller () may be used to actuate mechanisms at the oilfield () via the transceiver and based on these decisions. In this manner, the oilfield () may be selectively adjusted based on the data collected. These adjustments may be made automatically based on computer protocol and\/or manually by an operator. In some cases, well plans are adjusted to select optimum operating conditions or to avoid problems.","To facilitate the processing and analysis of data, simulators may be used to process the data for modeling various aspects of the oilfield operation. Specific simulators are often used in connection with specific oilfield operations, such as reservoir or wellbore simulation. Data fed into the simulator(s) may be historical data, real time data or combinations thereof. Simulation through one or more of the simulators may be repeated or adjusted based on the data received.","As shown, the oilfield operation is provided with wellsite and non-wellsite simulators. The wellsite simulators may include a reservoir simulator (), a wellbore simulator (), and a surface network simulator (). The reservoir simulator () solves for hydrocarbon flow through the reservoir rock and into the wellbores. The wellbore simulator () and surface network simulator () solves for hydrocarbon flow through the wellbore and the surface network () of pipelines. As shown, some of the simulators may be separate or combined, depending on the available systems.","The non-wellsite simulators may include process () and economics () simulators. The processing unit has a process simulator (). The process simulator () models the processing plant (e.g., the process facilities ()) where the hydrocarbon(s) is\/are separated into its constituent components (e.g., methane, ethane, propane, etc.) and prepared for sales. The oilfield () is provided with an economics simulator (). The economics simulator () models the costs of part or the entire oilfield () throughout a portion or the entire duration of the oilfield operation. Various combinations of these and other oilfield simulators may be provided.","As described above, data plots (-) are examples of oilfield data entities collected from various sources, such as the data acquisition tools of . These oilfield data entities are associated with oilfield entities. For example, the seismic trace () may be associated with the formation () and the core sample data () may be associated with a portion of the formation () such as the sandstone layer (), the limestone layer (), the shale layer (), the sand layer (), or the fault line () where the core sample is collected. In another example, the logging trace () may be associated with a well monitored by the data acquisition tool () and the fluid flow rate plot () may be associated with the well monitored by the data acquisition tool (). The collected oilfield data may be stored in a data repository or multiple data repositories () as shown in  later. The data repository or multiple data repositories () may; be located in the surface unit () of . Data may then be simulated, analyzed, or otherwise processed by wellsite and non-wellsite simulators or other modeling tools as described above. The processed data, such as results generated by the wellsite and non-wellsite simulators, may then be further stored in the data repository or multiple data repositories. Data may be stored using different formats depending on, for example a particular oilfield function (e.g., drilling function, production function, reservoir engineering, economic function, etc.) for which data is collected or generated. In general, in one aspect the invention relates to technology for accessing data (e.g., oilfield data) stored in a data repository or multiple data repositories using an interface independent of the various formats of the data repository or multiple data repositories. This interface may be automatically generated. Examples of such data repository include relational database, object oriented database, or other forms of database or data store. An example of this interface is an object oriented application programming interface (e.g., the Object API () as shown in  later). Object-relational mapping (ORM) is a term that describes software technology that allows a program to view data stored in a database (e.g., a relational database) through an object-oriented application programming interface.","Relational databases are designed to store large amounts of information. Information in relational databases is stored in different tables, each defined to contain one or more columns, each column containing a primitive item of information\u2014for example, a string or a number. Programs add information to a relational database by adding rows (containing values for one or more defined table-defined columns) to database tables, and find information in relational databases by issuing queries. Typically, all operations on a relational database are performed by operations expressed in a textual query language, such as Structured Query Language (SQL). The relational database is an example of the data repository or multiple data repositories described above. The tables, columns, rows, and the primitive item of information are examples of data base entities. The relational interface such as queries or SQL are examples of commands for accessing data in the data repository or multiple data repositories.","The term \u201crelational database\u201d refers to the fact that a column in a row of one table can identify a row of another (or the same) table. This reference mechanism supports relations between rows of information. Relational databases can enforce consistency of information both between table rows and within table rows. Database designers may choose to declare integrity constraints that ensure that column data is valid; for example that a column can never refer to a non-existent table row. Defining such constraints is a recommended good practice, but is not mandatory. Even when integrity constraints are designed, they are not as readily visible to database programmers, as is table structure. Thus, while the physical model of data in the database\u2014the tables and their columns\u2014may be visible to developers, the conceptual model\u2014the high-level concepts represented by the tables and the relationships between tables, which gives significant meaning to the data\u2014is not immediately obvious.","In addition, the definitions of the tables included within a relational database can change over time. When these definitions change, any application using a relational interface to access data in the database may also change to assure proper operation of the application. When a database is used by many, independently-developed applications, it can be extremely difficult to identify all applications that are to be changed in response to a database definition change.","More importantly, designers desire the flexibility to make applications store their data in a plurality of relational databases (e.g., the multiple data repositories described above) having different physical models (e.g., based on a particular oilfield entity associated with the stored data) and conceptual models (e.g., based on a particular oilfield function for which data is collected or generated for). Good software engineering practices include the use of a software layer that insulates the application from the underlying database. The adaptor presents a single, stable interface for the application program, while supporting multiple \u201cbackend\u201d implementations that are specific to each underlying database to be used. This approach solves the database portability problem for the application programmer, but still requires significant coding investment for each backend database to be used. Moreover, when the backend coding task is difficult (because programming against relational databases is difficult), the adaptor layer tends toward exposing a least-common-denominator view over the intersection of databases to be supported. Such views can ultimately render the adaptor useless, as often critical and\/or valuable information cannot be stored and retrieved through the adaptor, leading programmers to circumvent the adaptor.","These characteristics of relational programming can be the root-level cause of many errors that only occur after an application has been delivered to its end users, and has motivated the software industry to develop ORM tools.","Object-oriented application programming interfaces (APIs) (e.g., the Object API () of ) are designed to make types and relationships explicit and obvious for programmers. Object interfaces such as the object APIs are well-suited to expressing high-level \u201cdomain-specific\u201d concepts. Domain refers to a relevant set of entities. For example, oilfield domain may refer to a collection of oilfield data. In other examples, a domain associated with a particular oilfield function (e.g., drilling function, production function, reservoir engineering, economic function, etc.) may refer to a portion of the collection of oilfield data related to the particular oilfield function. In these exemplary domains, data object may be defined relating to physical oilfield entities (e.g., a formation, a well, a process facility, etc.). Entities (or domain entities) such as object types may be defined within a taxonomic hierarchy of a domain, in which subtypes inherit the generic behavior of super types, but either refine that behavior or add additional behavior. Furthermore, well-designed object interfaces completely encapsulate implementation details from applications that use the interfaces. This encapsulation allows the interface to remain stable while the underlying implementation changes.","Object-based programming languages (e.g., used for application () as shown in  later) in general do not provide query, persistence, or integrity that relational databases provide. However, a developer may explicitly declare types and relationships in object interfaces, and a compiler for an object-oriented programming language can verify that the application is performing legal operations on objects in an object-oriented interface. The explicit declarations are a significant advantage for developers because the compiler can verify that the application is not attempting to violate domain-level concepts, before the application runs.","However, query and persistence remains an issue for programmers using an object API. It is common practice in the software industry for developers to write his\/her own persistence mechanisms from scratch, and also to simply not provide a query mechanism. Developers develop some mission-critical software for a long life cycle, and occasionally for accessing large persistent data stores. These issues also motivate tools to create object-relational mapping adaptors.","ORM tools adapt relational programming interfaces (such as queries or SQL) to object-oriented application programming interfaces, and give programmers the encapsulation, expressiveness, and compile-time safety of object interfaces while taking advantage of the efficiency and integrity offered by relational databases. The fundamental service of object-relational mapping is to translate between data stored in columns of database table rows and data expressed through properties of related objects defined in a type hierarchy. ORM allows applications to perform the database operations of create, update, delete through the compile-time-safe object API while storing the data in the relational database. Some ORM tools also permit applications to perform the database operation of find with respect to data. Data may be, for example, oilfield data shown in  and .","It should be noted that relational databases excel at retrieving large amounts of very specific information. This is because relational databases retrieve data in a set-oriented manner, efficiently returning data that matches a query predicate in a single (potentially very large) dataset. This relational query interface lends itself to applications that retrieve large datasets infrequently. Consequently, there is a constant time overhead associated with each query. Ultimately, the overhead causes frequent queries that retrieve single items of information to be very expensive. Unfortunately, object APIs, which emphasize object-to-object navigation, can end up exercising a relational database for these suboptimal queries when the object model is mapped onto a relational database.","ORM tools come in many forms. Common to all tools is the need to state how relational data will be mapped to object data. Producing and maintaining these mappings can be an onerous task. An example of this invention includes an embodiment of an ORM tool that implements the mapping between an object interface and a relational interface by generating the source code of an object library, that when compiled, provides an object view (e.g., for accessing data through the object APIs) of relational data (e.g., stored in the relational data base). The tool reduces the workload of software developers when creating and maintaining the object-relational mapping. The ORM tool infers (or derive) much of the information that would ordinarily be entered manually by a person developing or maintaining a mapping. The inferred information includes: 1) defaults for properties of domain objects, 2) queries to find database entities that map to domain objects, 3) queries to preload domain object properties with information from a complex web of interrelated database entities (thus minimizing the suboptimal small query result usage pattern), and 4) queries to follow relationships between database entities that are equivalent to relationships between domain objects.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 6","FIG. 6"],"b":["2111","2113","2117","2111","2101","2101","2103","2103","2101","2105","2105","2103","2107","2101","2107","2101","2107","2105"]},"The metamodels used as the target relational metamodel () and possibly the reference metamodel () are typically developed independently of the domain metamodel (). Developers can expect that the information needed to populate them already exists in some machine-readable form when they begin to define the domain metamodel (). In particular, the metamodel of a database can be used to supply information missing from the domain metamodel (), allowing the developer of the domain metamodel () to specify only as much information as needed to make the combination of the domain metamodel () and the reference metamodel () complete.","The output from the code generator () is source code () in a particular programming language. The source code () can be compiled by a compiler () into a compiled domain model (), which may include a library of domain objects (i.e., an object library). A domain object may relate to a type of oilfield entity (e.g., a well, a formation, etc.). Domain object instances may be created (or instantiated) during execution (or run time) of the application () from a domain object. A domain object instance may relate to a particular oilfield entity (e.g., a particular well in an oilfield, a particular portion of a formation, etc.) Accordingly, an object API () may be formed using the compiled domain model () that allows an application () to create, update, delete, and find data () in a relational database () described by the input database metamodel, for example, the target relational metamodel (). More details of an exemplary implementation of the object API () are described in  below.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 7","FIG. 6"],"b":["2111","2209","2211","2215","2101","2105","2103","2213","2101","2105","2103","2111","2201","2203","2211","2215","2211","2215"]},{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 8","FIG. 7"],"b":["2213","2213","2101","2105","2107","2213","2102","2101","2101","2301","2302","2103","2109","2213"]},"For describing the target relational metamodel (), the IEntityMeta () contains structural description of a database entity (e.g., a table of a relational database), the IPropertyMeta () contains structural description of non-relational data associated with the database entity (e.g., an attribute of a relational database), and IRelationalMeta () contains structural description of relations between database entities (e.g., a foreign key of a relational database).",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 9","FIG. 7"],"b":["2213","2103","2103","2502","2503","2503","2504","2505","2507","2505","2507","2506","2503","2504","2506","2501"]},{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 9"},"The UML standard is well known to those skilled in art. For clarity, the significance of the decorations at the end of the links between the interfaces is reiterated here.","The \u201c*\u201d and \u201c1\u201d at the end of a link indicate cardinality of the object at that end of the link. \u201c1\u201d indicates one; \u201c*\u201d indicates zero or more. The use of the cardinality decorators is generally implicit in the UML. For example, one ILinkMapping () can refer to multiple IMappingConstraints . Similarly, one IAttributeMapping () and one IEntityMapping () can also refer to many IMappingConstraints. One IEntityMapping can refer to multiple IEntityPartMappings (), IRelationMappings () and IAttributeMappings.","The solid diamond indicates that the link is a \u201ccomposition.\u201d For example, an IMappingConstraint cannot exist without being referred to from an IEntityMapping, IAttributeMapping or ILinkMapping. For example, to support the ability to delete an IEntityMapping, any IMappingConstraint objects that the IEntityMapping also refers to need to be deleted.","The simple arrowheads (such as pointing into IMappingConstraint) indicate that the relation is navigable; it is possible to enumerate all of the IMappingConstraints associated with an IEntityMapping, IAttributeMapping or ILinkMapping.","The triangular arrowhead (such as pointing into the bottom of ILinkMapping) indicates an inheritance relation. IEntityPartMapping and IRelationMapping are both subtypes (or subclasses) of ILinkMapping.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 10","FIG. 10","FIG. 10","FIG. 8"],"b":["2103","2101","2105","2103","2101","2105","2301","2302","2101"]},"As shown in , the domain metamodel () includes fmp:IMetaProvider (), fe:IEntityMeta (), fe:IEntityMeta (), fp:IProperty (), and fr:IRelationMeta (). The mapping specification () includes mm:IModelMapping (), em:EntityMapping (), am:IAttributeMapping (), lm:ILinkMapping (), and emp:IEntityPartMapping (). The target relational metamodel () includes dmmp:IMetaProvider (), dme:IEntityMeta (), dme:IEntityMeta (), dmp:IProperty (), and dmr:IRelationMeta (). Each of the fmp:IMetaProvider () and dmmp:IMetaProvider () is an instance of the IMetaProvider (). Each of the fe:EntityMeta (), fe:IEntityMeta (), dme:IEntityMeta () and dme:IEntityMeta () is an instance of the IEntityMeta (). Each of the fp:IProperty () and dmp:IProperty () is an instance of the IMetaProvider ()). Each of the fr:IRelationMeta () and dmr:IRelationMeta () is an instance of the IMetaProvider (). The mm:IModelMapping () is an instance of the IModelMapping (). The am:IAttributeMapping () is an instance of the IAttributeMapping (). The lm:ILinkMapping () is an instance of the ILinkMapping (). The emp:IEntityPartMapping () is an instance of the IEntityPartMapping ().","Further shown in , the mm:IModelMapping () maps the fmp:IMetaProvider () to the dmmp:IMetaProvider () using a hierarchical and recursive mapping structure by way of mappings performed by the em:IEntityMapping (), am:IAttributeMapping (), lm:ILinkMapping (), and emp:IEntityPartMapping (). The emp:IEntityPartMapping () is shown to have a recursive structure ().","One example of a metamodel used as a target metamodel or a reference metamodel is the data dictionary of Seabed. Seabed is a relational database produced by Schlumberger Information Solutions for holding exploration and production information in support of a borehole operation. Other metamodels may also be used by configuring the metametamodel illustrated above to describe the structural format of the information contained in the metamodels so that the information may be provided to the Model Mapping Code Generator Task () (see, ).",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 11","FIG. 6","FIG. 6"],"b":["600","600","2101","2103","600"]},"Within the XML file (), line () is an example of a structure described by IEntityMeta () of , line () is an example of a structure described by IEntityMapping () of , line () is an example of a structure described by IEntityMeta () of , line () is an example of a structure described by IEntityMapping () of , line () is an example of a structure described by IEntityPartMapping () of , line () is an example of a structure described by IMappingConstraint () of , line () is an example of a structure described by IPropertyMeta () of , line () is an example of a structure described by IRelationMeta () of , line () is an example of a structure described by IEntityMapping () of , line () and line () are examples of a structure described by IEntityPartMapping () of . The indention between the lines (), (), and () indicate three levels of hierarchical nesting as an example of the hierarchical recursive structure of mapping specification () illustrated in .","The ORM tool implements nine distinct mapping capabilities based on the structure of the mapping specification and the abstraction of the domain model and data models described above:","1. Subsetting exposes a subset of a data entity's attributes as domain object properties.","2. Renaming exposes data entities and their attributes using different names.","3. Composition exposes one or more related data entities through a single domain object.","Capabilities 1, 2, and 3 are provided in object-relational mapping tools. In the present invention, the implementation of composition, the relational queries that compose one database entity with another are not supplied by the developer of the mapping specification. Instead, based on the structure of the mapping specification described above, the developer of the mapping specification defines a domain object mapping in terms of a \u201croot\u201d database entity (e.g., line () in the XML file ()) and zero or more ancillary part entities (e.g., lines () and () in the XML file ()). Part entities may in turn be composed of other subpart entities, in a recursive manner. The properties of a domain object map to attributes of the root entity or one of the ancillary part entities.","The queries to compose database entities are constructed automatically during code generation by analysis of the mapping specification (i.e., the relationship between the root and its parts, and parts and their subparts) and the underlying relational metamodel. A part is specified by its database type. In many cases, this is the only information the developer need provide in the specification for the code generator to determine the relational query that links entities in the database. Where there is more than one way to compose entities, the developer needs to name the database relationship with which to compose the entities. In order to establish recursive relationships, a developer specifies the directionality of the relationship. A recursive relationship is a relationship that links entities of the same type, such as one used to compose a part-whole hierarchy. Directionality specifies, between two entities, which entity is the parent and which entity is the child.","4. Hidden relationships allow one domain object to relate directly to another, while in the data model, the underlying data entities relate indirectly, through intermediate data entities that are not exposed in the data model. Hiding relationships is a form of composition (capability #3), but is well suited to hiding indirect relations that create one-to-many or many-to-many relationships. In this case, the part entity may be many-valued (typically, because it is related to the root or super part through a relation in which the subpart is the child). From each individual entity comprising the part, the mapping then follows a single-valued relation to a single entity, which is then inversely mapped to a domain object. The collection of such entities is a multi-valued relation in the domain model.","5. Hidden redundancy allows domain object to update a denormalized data model property or relation consistently. The mapping specification can contain any number of mappings for a domain property or relation; the code generator creates code to set each such mapping.","6. Defaulting provides values for properties of newly created domain objects. This capability supports creating domain objects that map to root entities or compose parts with mandatory attribute values, or which maintain a usage rule invariant.","7. Conditional attributes expose data entity attribute values through domain object properties when specified constraints are met; the property has null value if the constraints are not met.","8. Relation abstraction allows the implementation of a domain model relation to be insulated from the underlying implementation of a data model relation (e.g., direction or implementation technique). The mapping specification refers to relations that compose parts and subparts, or which are exposed as domain object relation values by name only. The code generator is responsible for creating queries to expose the relation value; the code that it generates is dependent upon the relation type (e.g., traditional foreign key join or proprietary techniques that support non-relational concepts), relation directionality, and cardinality. If the relation implementation changes in future versions of the database, the mapping specification, and the domain API exposed to programmers does not change.","9. Natural key semantics recognize that some domain object properties map onto data entity attributes controlled by unique-key constraints; such properties cannot be updated arbitrarily, but instead, must be treated as creating a reference to a different object (which itself must be created if nonexistent).",{"@attributes":{"id":"p-0129","num":"0128"},"figref":["FIG. 12","FIG. 12","FIG. 7","FIG. 12"],"b":["715","705","706","717","719","720","715","2215","706","2103","715","705","715","705","715","705","705","705"]},"As shown in , ICodeGenerationHelper () is an interface that identifies three additional interfaces: IEntityGenerationHelper (), lPropertyGenerationHelper () and IRelationGenerationHelper (). In one example, implementations of IEntityGenerationHelper () contain methods that the DOGEntityGenerationTask () uses to help to form the implementation of a domain type within the implementation of the domain API for a specific target database. In another example, implementations of IPropertyGenerationHelper () contain methods that DOGPropertyGenerationTask () uses to form the implementation of a property of a domain type within the implementation of the domain API for a specific target database. In yet another example, implementations of IRelationGenerationHelper () contain methods that DOGRelationGenerationTask () uses to form the implementation of a relation between one domain type and another domain type within the implementation of the domain API for a specific target database. The same DOGEntityGenerationTask (), DOGPropertyGenerationTask (), and DOGRelationGenerationTask () can be used to generate code that implements the domain API for different target databases by using different implementations of IEntityGenerationHelper (), lPropertyGenerationHelper (), and IRelationGenerationHelper ().",{"@attributes":{"id":"p-0131","num":"0130"},"figref":["FIG. 13","FIG. 11","FIG. 14","FIG. 13","FIG. 11","FIG. 13","FIG. 14"]},"Consider the UWI property () of the BoiBorehole domain object (). Referring back to , the UWI property () maps to the UBHI attribute () of the Seabed Borehole entity portion () of the XML file (). This is a straightforward mapping. The code for mapping the BoiBorehole domain object () is generated by the following process using tasks illustrated in .","1. The DOGEntityGenerationTask () of  creates the declaration of the BoiBorehole domain object:",{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class BoiBorehole: BoiEntity {"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"2. Next, the DOGPropertyGenerationTask () adds the declaration of the UWI property:",{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class BoiBorehole: BoiEntity {"]},{"entry":[{},"\u2003public String UWI { get; set; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Finally, DOGPropertyGenerationTask () invokes the lPropertyGenerationHelper () implementation for the Seabed database to create the code to set and get the UWI property. There are many possible ways to implement these operations. Fundamentally, they involve a query to load the property and a query to save the updated property:","SELECT UBHI FROM Borehole WHERE Id=@p0","UPDATE Borehole SET UBHI=@p0 WHERE Borehole.Id=@p1","The tokens @p0 and @p1 represent parameters that allow the same queries to be executed multiple times referring to different boreholes or UBHI string values. The actual values to use in the query are provided externally to the parameters. A relational database may substitute the actual values into the actual query when it processes the query request.","Next, referring back to , consider the BusinessAssociateList () relation exposed by BoiBorehole (). This is a significantly more complicated query, because it involves relation hiding and abstraction.","1. Once again, the DOGEntityGenerationTask () and DOGPropertyGenerationTask () objects of  are responsible for creating the BoiBorehole domain object declaration:",{"@attributes":{"id":"p-0141","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class BoiBorehole: BoiEntity {"]},{"entry":[{},"\u2003public String UWI { get; set; }"]},{"entry":[{},"\u2003public IList<BoiBusinessAssociate> BusinessAssociateList"]},{"entry":[{},"\u2003\u2003{ get; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that the BusinessAssociateList () property is \u201cget\u201d only. This is because the DOGRelationGenerationHelper () recognizes that the relation is multi-valued. When the relation is multi-valued, application code may only get the value of the relation, but can subsequently add and remove from the returned collection.","2. The DOGRelationGenerationTask () asks the IRelationGenerationHelper () implementation for the Seabed database to supply code that queries the database to find the BBAI part of the BoiBorehole domain object. Referring to , BBAI () is defined as the set of Borehole_BA_Involvement () entities whose Involvement_Role () is the value \u201cProject_Team\u201d (). Implicit in the relationship between the Borehole and the Borehole_BA_Involvement entities is the Borehole relation that links the Borehole_BA_Involvement to its Borehole. Thus, the query to find the set of Borehole_BA_Involvement entities that includes the BBAI part is:","SELECT Id FROM","Borehole_BA_Involvement","WHERE Borehole_Id=@p0","AND Involvement_Role=@p1","In this query, the parameter p1 is bound to the string \u201cProject_Team.\u201d Passing the constraint value by parameter allows the relational database to reprocess the same query, with potentially different bindings for p1. More importantly, passing the constraint value by parameter prevents a \u201cSQL Injection Attack.\u201d A SQL injection attack involves passing malformed strings to the relational query interface that causes the database server to damage or destroy critical data.","3. The DOGRelationGenerationTask () asks the IRelationGenerationHelper () implementation for Seabed to supply code that queries the database to find the set of Business_Associate entities associated with the BBAI part. The helper () generates code that executes this query:","SELECT Business_Associate.Id FROM","Business_Associate WHERE Id IN","(SELECT Borehole_BA_Involvement.Id FROM","Borehole_BA_Involvement","WHERE Borehole_BA_Involvement.Borehole_Id=@p0","AND Borehole_BA_Involvement.Involvement_Role=@p1)","This query nests the previous query as a subquery. It is also within the scope of the invention for the generated implementation to cache the Id values of the entities that comprise the BBAI part, and to supply those values in the query to find the Business_Associate entities:","SELECT Business_Associate.Id FROM","Business_Associate WHERE Id IN","(1234567, 34736205, 353294, 3134503, . . . , 1462084)","4. The DOGRelationGenerationTask () creates code to respond to add and remove events from the multi-valued collection. In response to a BoiBusinessAssociate being added to the list, the IRelationGenerationHelper () generates code that creates a new Borehole_BA_Involvement and relates it to the Borehole and the Business_Associate entities in the database. In response to removing a BoiBusinessAssociate from the list, it generates code that removes the appropriate Borehole_BA_Involvement from the database.","Also shown in , BOI3::BoiSurvey (), BOI3::BoiBusinessAssociate (), BOI3::BoiWell (), and BOI3::BoiActivity () describe other types in the \u201cBOI\u201d drilling domain model.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":["FIG. 14","FIG. 13","FIG. 14"],"b":["923","920","921","919","918","916","918","918"]},"As shown in , the relational metamodel may include multiple Generic_Borehole_Activities (), Deviation_Surveys (), Borehole_BA_Involvement (), and Borehole_Statuses () associated with one Borehole. Here BA stands for Business Associate (e.g., company, person, etc.) and Borehole_BA_Involvement () supports encoding a many-to-many relationship between boreholes and business associates.","A single well may be associated with multiple boreholes. A Deviation_Survey () and a Borehole_Activity () are subtypes of Activity (). A Generic_Borehole_Activity () is a subtype of Borehole_Activity (). A Business_Associate (), Well (), Borehole (), and Activity () are all subtypes of Entity (), which is a subtype of IT_Object ().","Some of the links in  are labeled for clarity. For example, the link between Borehole () and Borehole_BA_Involvement () is labeled \u201cBorehole.\u201d This identifies the name of the relation in the Seabed metamodel that associates a Borehole_BA_Involvement () with a Borehole (). There is a link from Activity () to itself called \u201cSuper.\u201d This means an activity can have zero or one parent activities, and is a concise way of illustrating that activities can form a tree hierarchy. The decoration \u201c0 . . . 1\u201d in  indicates zero or one objects.","The invention may be implemented on virtually any type of computer regardless of the platform being used. For example, as shown in , a computer system () includes a processor (), associated memory (), a storage device (), and numerous other elements and functionalities typical of today's computers (not shown). The computer () may also include input means, such as a keyboard () and a mouse (), and output means, such as a monitor (). The computer system () is connected to a local area network (LAN) or a wide area network () (for example, the Internet) via a network interface connection or transceiver (not shown). A transceiver is a device that transmits data by a wired or wireless connection. Those skilled in the art will appreciate that these input and output means may take other forms.","Further, those skilled in the art will appreciate that one or more elements of the computer system () may be located at a remote location and connected to the other elements over a network. Further, the invention may be implemented on a distributed system having a plurality of nodes, where each portion of the invention (for example, object store layer, communication layer, simulation logic layer, etc.) may be located on a different node within the distributed system. In one embodiment of the invention, the node corresponds to a computer system. Alternatively, the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor with shared memory and\/or resources. Further, software instructions to perform an embodiment of the invention may be stored on a computer readable medium such as a compact disc (CD), a diskette, a tape, a file, or any other computer readable storage device.",{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 16"},"Specifically, the architecture includes a visualization and graphical user interface infrastructure sub-system (), a process\/workflow sub-system (), a data sub-system (), and a core system implementation and Ocean services sub-system (). In addition, such an architecture may support a product family () including Schlumberger Information Solutions products, such as Core Petrel, and Petrel AppShell. Furthermore, a pluggable application module () may connect to one or more subsystems. The pluggable application module () may be made by a third party or by Schlumberger Information Solutions.",{"@attributes":{"id":"p-0170","num":"0169"},"figref":"FIG. 17","b":["1307","1309","1310"]},{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 18","b":["1400","1401","1403","1401","1405"]},{"@attributes":{"id":"p-0172","num":"0171"},"figref":["FIG. 19","FIG. 6","FIG. 6","FIG. 6"],"b":["1501","1503","1501","1504","1505","2132","1","1506","2","1507","1508","1509","2132","2132","2111","2101","2132","2111","2101","2105","2103","2107"]},{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 20","b":["1605","1607","1620","1601","1605","1605","1620","1603","1605"]},"Further,  provides context for understanding the relationship between domain object services and the broader Ocean program. Domain object services include a portion of the Data-Centric Software Infrastructure. Product family developers (or programmers), in turn, use domain object services to create domain data classes.","Domain object services help to deliver a productive development environment for all Ocean developers. Domain object services extend the Core's domain object hosting service, providing capabilities that are expected to fit the needs of the data-centric product families. These include:\n\n","Domain object services extend the Ocean Core's Domain Object Hosting (DOH) layer. Domain object services complement DOH. Ocean is establishing rules for domain object behavior (e.g., multithreading support, unit, and coordinate data exposure); domain objects must comply with these rules.","Domain object services may also be involved in the bridge between domain objects, which represent entity and attribute data in a data model, and bulk data, which represents open-ended streams of data associated with a variety of entities.","Product families may require domain APIs to access data from different data sources. These include commercial third-party databases as well as proprietary customer databases.","Some data-centric products may need to work with data exposed through a classic connections (as opposed to meta-driven API connections). Access to data exposed through an object model, instead of a relational model, has architectural significance for domain object services.",{"@attributes":{"id":"p-0180","num":"0182"},"figref":["FIG. 21","FIG. 21","FIG. 21"],"b":["1701","1700","1751","1751","1760"]},{"@attributes":{"id":"p-0181","num":"0183"},"figref":["FIG. 22","FIG. 21"],"i":"a ","b":["1800","1801","1811","1815","1812","1812","1705","1830"]},"As shown in , a domain object from application () may present a query () at the domain object API (). Domain object services may then be performed. Prior to presenting the query () to the data store (), a query () may be revised by refactoring (), broadening (), and through query formation (). The query formation module () may convert a query () to a format native to the data store ().","Next, a data object management module () may convert results from queries into data objects. The data object management module () may rely upon cached data objects for data, and update such cached data objects. Next, a data object refactoring module () may aggregate multiple data objects into a single data object. Alternatively, the data object re-factoring module () may convert a data object into separate data objects, each of which can be shared between multiple domain objects. The unseparated data object may have been created because of a join into separate data objects. In addition, the data object re-factoring module () may rename attributes. Such data objects are passed to the domain object management module ().","Data object management module () may map data objects to domain objects according to mapping specifications. Mapping specifications may be, for example, mapping specification () of .","Runtime metadata () provides a machine-interpretable description of a data model schema. This meta data is used for a number of tasks. This metadata is used for a number of tasks, such as enumerating the entity types in a data model, enumerating the attributes of an entity, identifying the type and constraints that apply to an attribute, and identifying the relations in which entities may participate.","Further, shows the architecturally significant design packages that include domain object services. The runtime domain object services package may be compared to a pipeline; operations on the domain model (e.g., create, read, update, delete) enter at the top of the pipeline, and \u201cflow\u201d down to the data store level, being modified by stages in the pipeline. Results flow back up the pipeline, ultimately exiting at the top in the appropriate form (as domain objects or as status indications). Responsibility and collaboration information for each package follows.","Optional elements can be configured into the pipeline according to the demands of the application. This configuration can be specified globally, but can be overridden on a per-domain-object-type basis. In the component collaboration discussion that follows, components are marked as mandatory or optional; however, collaborations are discussed as if each possible component is configured. One skilled in the art should understand that if a collaborator component is not be configured into the pipeline, then the specific component being discussed collaborates with the next component in the pipeline instead. Also, in the discussion that follows, for each component of the pipeline, the \u201cResponsibility\u201d section describe the function of the component, the \u201cRationale\u201d section describes the purpose of the function, and the \u201cCollaborators\u201d section describes other components that collaborate with this component in performing the function. It is noted that collaborations with other components in the pipeline are only described where needed.",{"@attributes":{"id":"p-0188","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Domain Object API (Mandatory) (1801)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","The domain object query service implements create,"]},{"entry":[{},"read, update, and delete operations on domain objects."]},{"entry":["Rationale","Encapsulate significant complexity of"]},{"entry":[{},"domain-to-data-model mapping, cache management,"]},{"entry":[{},"in-memory query, and query optimization."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Model mapping","Passes domain object queries to the"]},{"entry":[{},"(1802)","model mapping stage to be translated"]},{"entry":[{},{},"into data model query specifications."]},{"entry":[{},"Domain Object","Receives domain object instances from"]},{"entry":[{},"Management","the domain object management stage"]},{"entry":[{},"(1840)","and returns them to the caller."]},{"entry":[{},"Data object ","Receives an enumerable object"]},{"entry":[{},"query service","indirectly from the data object query"]},{"entry":[{},{},"service, in the case that a query can be"]},{"entry":[{},{},"satisfied by the in-memory cache."]},{"entry":[{},{},"Calls the data object query service"]},{"entry":[{},{},"back to step the enumerator to retrieve"]},{"entry":[{},{},"data objects."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0189","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Model Mapping (mandatory) (1802)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","Manages the mapping between domain objects"]},{"entry":[{},"and their properties to data objects and their attributes."]},{"entry":[{},"Converts CRUD operations posed with respect to a"]},{"entry":[{},"domain model into CRUD operations relative to a"]},{"entry":[{},"data model. This is a key service required to map from"]},{"entry":[{},"domain object models to data bases."]},{"entry":["Rationale","Ocean's vision of sharable components encourages"]},{"entry":[{},"developers to create small, for-purpose domain models"]},{"entry":[{},"that can be adapted to work with one or more data stores."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Domain object","Enumerable objects returned from data"]},{"entry":[{},"query service","store queries are passed back to the"]},{"entry":[{},{},"calling program through the domain"]},{"entry":[{},{},"object query service."]},{"entry":[{},"Data object","Model mapping calls upon the data"]},{"entry":[{},"query service","object query service to perform CRUD"]},{"entry":[{},{},"operations on the data entities"]},{"entry":[{},{},"underlying data objects. Model"]},{"entry":[{},{},"mapping also receives an enumerable"]},{"entry":[{},{},"object from this service, which it"]},{"entry":[{},{},"passes back to the domain object query"]},{"entry":[{},{},"service."]},{"entry":[{},"Domain","Model mapping provides context to"]},{"entry":[{},"Object","domain object management, so that"]},{"entry":[{},"Management","domain objects can be created for data"]},{"entry":[{},"(1840)","objects, and domain object properties"]},{"entry":[{},{},"can be populated from data object"]},{"entry":[{},{},"attributes."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0190","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Object API (1803)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","Optimize performance by providing an"]},{"entry":[{},"in-memory data cache that can satisfy certain queries"]},{"entry":[{},"without calling upon the persistent data store. If a query"]},{"entry":[{},"cannot be satisfied by the data object query service, it is"]},{"entry":[{},"passed onto the next stage in the pipeline."]},{"entry":[{},"If the incoming operation from model mapping is a"]},{"entry":[{},"create, update, or delete operation, it is passed onto"]},{"entry":[{},"the transaction state management service."]},{"entry":["Rationale","Analysis of data access behavior indicates"]},{"entry":[{},"that a substantial number of database queries generated"]},{"entry":[{},"by the workspace are unnecessary, because the data "]},{"entry":[{},"required satisfying these queries is already in cache."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Query Spec","This optional stage is capable of"]},{"entry":[{},"Refactoring","combining multiple queries into a single"]},{"entry":[{},"(1804)","query, or partitioning a single query (a"]},{"entry":[{},{},"join, for instance) into multiple queries,"]},{"entry":[{},{},"as a means for opportunistically caching"]},{"entry":[{},{},"data."]},{"entry":[{},"Runtime","Runtime meta data describes the schema"]},{"entry":[{},"meta data","of the data model in the persistent data"]},{"entry":[{},"(1850)","store. This is used by the data object"]},{"entry":[{},{},"query service to properly format queries"]},{"entry":[{},{},"and to process query results. It is also"]},{"entry":[{},{},"used to identify relations between"]},{"entry":[{},{},"entities, so that placeholder data objects"]},{"entry":[{},{},"can be created to allow data integrity"]},{"entry":[{},{},"constraints to be maintained efficiently."]},{"entry":[{},"Transaction","Create, update, and delete operations are"]},{"entry":[{},"state","passed onto the transaction state"]},{"entry":[{},"management","management service. Attribute value"]},{"entry":[{},"(1807)","requests are also passed onto the"]},{"entry":[{},{},"transaction service, so that values are"]},{"entry":[{},{},"returned to calling programs consistent"]},{"entry":[{},{},"with the current transaction."]},{"entry":[{},"Domain","Data objects resident in the in-memory"]},{"entry":[{},"object","cache are passed onto domain object"]},{"entry":[{},"management","management, so that corresponding"]},{"entry":[{},"(1840)","domain object instances can be returned"]},{"entry":[{},{},"to calling programs."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0191","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Query Spec Refractoring (optional) (1804)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","This optional stage is capable of combining multiple"]},{"entry":[{},"queries into a single query, or partitioning a single query"]},{"entry":[{},"(a join, for instance) into multiple queries, as a"]},{"entry":[{},"means for opportunistically caching data."]},{"entry":["Rationale","There is no strong rationale for this pipeline"]},{"entry":[{},"element, except hold open the possibility that totally"]},{"entry":[{},"unforeseen sorts of elements may be configured"]},{"entry":[{},"into the data access pipeline."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Query spec","Passes potentially modified query"]},{"entry":[{},"broadening","requests onto the query spec"]},{"entry":[{},"(1804)","broadening, to take advantage of"]},{"entry":[{},{},"opportunistic caching possibilities."]},{"entry":[{},"Data object","Combines or splits data objects, to"]},{"entry":[{},"refactoring","make the effect of query spec refactoring"]},{"entry":[{},"(1830)","invisible to upper level stages"]},{"entry":[{},{},"in the data access pipeline."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0192","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Query Spec Broadening (optional) (1806)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","This element generalizes incoming queries"]},{"entry":[{},"by adding additional attributes to be retrieved or by"]},{"entry":[{},"relaxing query constraints so as to cause a larger result"]},{"entry":[{},"set to be retrieved. This stage implements an"]},{"entry":[{},"opportunistic caching policy that may be beneficial"]},{"entry":[{},"for certain applications that are willing to devote"]},{"entry":[{},"additional memory to cache in exchange for"]},{"entry":[{},"potentially fewer data store hits."]},{"entry":["Rationale","Amortizing the cost of data store hits over"]},{"entry":[{},"larger result sets can effectively reduce the total time"]},{"entry":[{},"spent waiting for data to be returned from the data store."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Query formation","Passes query specifications to the"]},{"entry":[{},{},"query formation element, which"]},{"entry":[{},{},"ultimately accesses the data store."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0193","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Query Formation (mandatory) (1810)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","This element accepts query (and other data store"]},{"entry":[{},"operation) specifications, and converts them to the"]},{"entry":[{},"native format of the data store. For a relational data store,"]},{"entry":[{},"this would typically be an SQL statement, whereas"]},{"entry":[{},"for an XML file, this might be an XPath query statement."]},{"entry":["Rationale","Native query generation should be delayed"]},{"entry":[{},"until after all pipeline stages have had a chance to modify"]},{"entry":[{},"the specifics of the query."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Data store query","This element is responsible for"]},{"entry":[{},"execution (1811)","executing the query or data store"]},{"entry":[{},{},"modification operations."]},{"entry":[{},"Data object","Data object management creates data"]},{"entry":[{},"management","objects that correspond to entities"]},{"entry":[{},"(1820)","returned by queries. If necessary,"]},{"entry":[{},{},"query formation provides context to"]},{"entry":[{},{},"data object management to aid in this"]},{"entry":[{},{},"process."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0194","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Object Management (mandatory) (1820)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","This element is responsible for converting"]},{"entry":[{},"results from queries into data objects. For each row"]},{"entry":[{},"returned by a query, a corresponding data object is"]},{"entry":[{},"returned up the pipeline, being created if necessary."]},{"entry":[{},"If a data object already exists in cache, this element"]},{"entry":[{},"finds it, and updates any cached attributes from attributes"]},{"entry":[{},"returned by the query."]},{"entry":["Rationale","Data objects are the common in-memory"]},{"entry":[{},"representation for data store entities in Puffin; data store"]},{"entry":[{},"results should be converted to"]},{"entry":[{},"data objects as soon as possible."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Data object","Data objects returned up the pipeline"]},{"entry":[{},"refactoring","by data object management may be"]},{"entry":[{},"(1830)","aggregated into fewer objects or split"]},{"entry":[{},{},"into more objects."]},{"entry":[{},"Runtime meta","Runtime meta data provides the means"]},{"entry":[{},"data (1850)","for the data object manager to create"]},{"entry":[{},{},"placeholder objects for inverse"]},{"entry":[{},{},"relations."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0195","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data Object Refactoring (optional) (1830)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","This element is responsible for aggregating"]},{"entry":[{},"multiple data objects into one (i.e., performing an"]},{"entry":[{},"in-memory join), or for converting a data object created"]},{"entry":[{},"as a result of a join into separate data objects, each of"]},{"entry":[{},"which can be shared between multiple domain objects."]},{"entry":[{},"Part of this process may involve renaming attributes."]},{"entry":["Rationale","For a variety of reasons, queries to a data store"]},{"entry":[{},"might be made with a different level of granularity than"]},{"entry":[{},"is required by code that maps between data and domain"]},{"entry":[{},"models. This and the query spec refactoring element"]},{"entry":[{},"make it possible to change the level of granularity"]},{"entry":[{},"between the data object query service and the data store."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Domain object","Re-factored data objects are passed up"]},{"entry":[{},"management","the pipeline to domain object"]},{"entry":[{},"(1840)","management, which creates domain"]},{"entry":[{},{},"object instances that correspond to data"]},{"entry":[{},{},"objects."]},{"entry":[{},"Query Spec","Query spec re-factoring provides the"]},{"entry":[{},"Refactoring","context needed to aggregate multiple"]},{"entry":[{},"(1804)","data objects or to split individual data"]},{"entry":[{},{},"objects."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0196","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Domain Object Management (mandatory) (1840)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","Data objects map to domain objects according"]},{"entry":[{},"to a mapping specification. Each domain object"]},{"entry":[{},"corresponds to exactly one \u201croot\u201d data object. As"]},{"entry":[{},"data objects flow up the pipeline, corresponding domain"]},{"entry":[{},"objects are found in the domain object"]},{"entry":[{},"cache, being created if necessary, and their"]},{"entry":[{},"properties are populated as required."]},{"entry":["Rationale","This element fits into domain object hosting"]},{"entry":[{},"architecture. There must be one element responsible"]},{"entry":[{},"for mapping between data and domain objects, to"]},{"entry":[{},"prevent multiple domain objects of the same"]},{"entry":[{},"type being created for a root data object. There"]},{"entry":[{},"must be at most one instance of a domain object"]},{"entry":[{},"of a given type that maps onto a given data entity."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Model mapping","Model mapping provides the necessary"]},{"entry":[{},"(1802)","context to choose the appropriate"]},{"entry":[{},{},"domain object type to create or return"]},{"entry":[{},{},"for a data object."]},{"entry":[{},"Domain object","Domain objects found in cache or"]},{"entry":[{},"query","created by domain object management"]},{"entry":[{},"service","are passed up the pipeline to the"]},{"entry":[{},{},"domain object query service, to be"]},{"entry":[{},{},"returned to the calling program."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0197","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Transaction State Management (mandatory) (1847)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","The transaction state management component"]},{"entry":[{},"holds uncommitted state for a transaction. It provides"]},{"entry":[{},"\u201cread uncommitted\u201d isolation for multiple threads"]},{"entry":[{},"accessing data in the in-memory data object cache."]},{"entry":[{},"It provides the means for application code to change data"]},{"entry":[{},"atomically and to abandon a collection of changes"]},{"entry":[{},"without committing any to the data store. Transaction"]},{"entry":[{},"management must be flexibly implemented"]},{"entry":["Rationale","Ocean software infrastructures are intended"]},{"entry":[{},"to be multithreaded. Transactional suppott is a good idea"]},{"entry":[{},"for multithreaded applications. Osprey's intent to use"]},{"entry":[{},"the staging area to hold a transaction is a novel idea"]},{"entry":[{},"that bridges the age-old traditional divide between"]},{"entry":[{},"applications that continually persist their data"]},{"entry":[{},"to a database and applications that require users to"]},{"entry":[{},"explicitly save their state."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Cache","Committed state is stored in data"]},{"entry":[{},"management","objects managed by the cache."]},{"entry":[{},"(1808)"]},{"entry":[{},"Data object","Create, update, and delete operations"]},{"entry":[{},"query service","are passed from the data object query"]},{"entry":[{},{},"service to the transaction service,"]},{"entry":[{},{},"where they are held until the"]},{"entry":[{},{},"transaction is committed."]},{"entry":[{},"Query formation","When (outer) transactions are"]},{"entry":[{},{},"committed, uncommitted state in the"]},{"entry":[{},{},"transaction is persisted to the data"]},{"entry":[{},{},"store through (for example) SQL"]},{"entry":[{},{},"commands."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0198","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Cache Management (optional) (1808)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","Cache management provides an"]},{"entry":[{},"in-memory searchable cache of entities loaded from"]},{"entry":[{},"a data store. The cache can be queried through"]},{"entry":[{},"an API that has the expressive power of a subset"]},{"entry":[{},"of SQL sufficient to find entities constrained by type and"]},{"entry":[{},"predicates on attribute values. The search API"]},{"entry":[{},"supports a basic \u201cinner join\u201d capability. The cache"]},{"entry":[{},"allows both actual and derived attribute data to be"]},{"entry":[{},"associated with data objects. (Derived attributes"]},{"entry":[{},"are used chiefly to represent inverse relations.)"]},{"entry":["Rationale","The cache is optional. Applications that"]},{"entry":[{},"cannot afford the extra memory requirements for"]},{"entry":[{},"supporting a data cache, and that are willing to"]},{"entry":[{},"trade smaller memory footprints for increased"]},{"entry":[{},"data access overhead can run without the cache."]},{"entry":[{},"Avoiding calls to the persistent data store through"]},{"entry":[{},"optimistic caching is a well-understood mechanism"]},{"entry":[{},"for obtaining good performance from a"]},{"entry":[{},"data-centric application."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Transaction","Requests for data objects not found in"]},{"entry":[{},"management","the state of a transaction fall through to the"]},{"entry":[{},"(1807)","cache."]},{"entry":[{},"Data object","The cache provides data objects"]},{"entry":[{},"management","corresponding to data entities returned"]},{"entry":[{},"(1820)","in query results, and holds new data"]},{"entry":[{},{},"objects created for data entities not"]},{"entry":[{},{},"found in the cache."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0199","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Runtime meta data (mandatory) (1850) "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Responsibility","Runtime meta data provides a machine-interpretable"]},{"entry":[{},"description of a data model schema. This meta"]},{"entry":[{},"data is used for a number of tasks, such as enumerating"]},{"entry":[{},"the entity types in a data model, enumerating"]},{"entry":[{},"the attributes of an entity, identifying the type and"]},{"entry":[{},"constraints that apply to an attribute, and identifying the"]},{"entry":[{},"relations in which entities may participate."]},{"entry":["Rationale","A runtime meta description of data is mandatory"]},{"entry":[{},"for an in-memory data cache. Identifying relations"]},{"entry":[{},"between entities is mandatory for properly maintaining"]},{"entry":[{},"integrity in a network of data objects."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Collaborators","Data object ","Runtime meta data provides the means for"]},{"entry":[{},"query service","data object queries to properly type"]},{"entry":[{},{},"retrieved attributes."]},{"entry":[{},"Data object","Runtime meta data provides the means"]},{"entry":[{},"management","for the data object manager to create"]},{"entry":[{},"(1820)","placeholder objects for inverse"]},{"entry":[{},{},"relations."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0200","num":"0202"},"figref":"FIGS. 22","i":["b","d "],"b":"22"},{"@attributes":{"id":"p-0201","num":"0203"},"figref":"FIG. 22","i":"b "},"As shown in , the application finds all BoiActualOperationDataPoint objects that reflect a drilling rig in the \u201cTest\u201d state by creating a QueryCriteria object for BoiActualOperationDataPoint. Each type in the domain model defines a nested type called QueryCriteria. The properties of the QueryCriteria object correspond directly to the properties of the associated domain model type. For example, BoiActualOperationDataPoint has a RigState property, which holds a string value. The corresponding QueryCriteria object also has a RigState property, but the value of QueryCriteria.RigState is a QueryConstraint, which allows the application to support a value and a comparison operator. This is useful, for example, to find all boreholes with a bottom depth greater than 2000 m, or all BoiActualOperationDataPoint objects with a RigState whose name begins with \u201cT.\u201d The QueryCriteria object is automatically generated by the code generator, by examining the properties of the corresponding domain model type in the domain metamodel. The significance is that queries are the same regardless of the underlying relational metamodel that are ultimately being queried. This insulates application code from changes in the underlying database.","As shown in , this simple case of finding a value using an exact string match, the QueryConstraint type assigns a simple string value, and converts the string value to a QueryConstraint object using an exact match comparison operator and the given string value. The application hands the completed QueryCriteria object to the fa\u00e7ade accessor for BoiActualOperationDataPoint. Accessors are a type generated to perform bookkeeping over objects in the domain. Every domain object has a corresponding accessor type, which is used to create new objects, delete existing objects, perform queries for objects, and to raise notification events upon object creation, deletion and change. More details can be found in .","All of the above steps are performed in the Domain Object API () of ","In addition to what is shown in the fa\u00e7ade accessor finds the appropriate \u201cimplementation accessor\u201d for the domain type in the specific data source being queried. The implementation accessor analyzes the QueryCriteria object and generates a query that corresponds to what the application wanted at the domain level, but in the terms of the relational data model associated with the specific data source being queried. This happens in the Model Mapping () of . The query is pushed down into the data access stack in the rest of the U-shaped figure of . Results from the query are pushed back up to the Domain Object Management (), where implementation objects are materialized for the resulting table rows found by the query, and then fa\u00e7ade objects are materialized for the implementation objects.",{"@attributes":{"id":"p-0206","num":"0208"},"figref":["FIG. 22","FIG. 22","FIG. 22","FIG. 22"],"i":["c ","b ","b","b "],"b":["1904","1904","1905","1907","1904","1907"]},"It can be seen in that the \u201cSuper\u201d relationship between Generic_Borehole_Activity () and Deviation_Survey () is a so-called \u201cAssoc-type\u201d relation, which is implemented through a relational view onto a special table. This is because the Super relation needs to encode semantics that cannot be directly encoded by relational database technology: it is many-to-many and it is abstract. As a result, each instance of the Super relation is held in a table row in a view called (in this case) Deviation_Survey_Ref, which points at both the source and target of the relation and identifies the types of relational entities involved in the relation instance. It is evident from the above description that the query created at the domain level in is complex when expressed at the data level.",{"@attributes":{"id":"p-0208","num":"0210"},"figref":["FIG. 22","FIG. 22"],"i":["d ","b"]},"The code necessary to convert the domain query to the relational query is automatically generated by the domain object generator, using information in the mapping specification, the domain metamodel and the relational metamodel. The steps in and are performed in the model mapping () of ",{"@attributes":{"id":"p-0210","num":"0212"},"figref":"FIGS. 22","i":["e","f "],"b":"22"},"For better performance, the application provides the data access stack with information regarding properties of domain object that the application may access. It is usually just as fast to load multiple columns from a relational database as it is to load a single column. For example, the data may be preloaded rather than hitting the database for every domain object as it is used. This process is called \u201cpriming.\u201d illustrates the application finding all boreholes in the data source, and then asking the stack to prime the TopDepth and UWI properties of that collection of objects. This is performed in the Domain Object API () of ",{"@attributes":{"id":"p-0212","num":"0214"},"figref":"FIG. 22","i":"f "},{"@attributes":{"id":"p-0213","num":"0215"},"figref":"FIGS. 22","i":["g","h "],"b":"22"},{"@attributes":{"id":"p-0214","num":"0216"},"figref":["FIG. 23","FIG. 1"]},"As shown in , oilfield data (e.g., seismic survey, well log, etc.) associated with oilfield entities (e.g., wellbore, reservoir, etc.) is stored in a first data repository (Step ) (e.g., a relational database, etc.) A first target metamodel (such as the metamodel described in  above) is then obtained (Step ). The first target metamodel includes structural description of data entities (e.g., database rows and columns, etc.) of the first data repository. A domain metamodel (such as the metamodel described in  above) and a first mapping specification (such as the metamodel described in  above) are also obtained (Step ). The domain metamodel includes structural description of a domain model for representing the oilfield entities in an application programming interface (e.g., an object oriented API). The first mapping specification associates the domain metamodel and the first target metamodel, such as the example described in  above. In some examples, the domain metamodel and the first mapping specification may be interleaved such as the example described in  above. In other examples, a portion of the domain model representing the oilfield entities is obtained from a reference metamodel (Step ) (e.g., the reference metamodel () of ). Finally, based on the domain metamodel, the first target metamodel, and the first mapping specification, the application programming interface is formed using a computer implemented method (Step ) (e.g., the code generator () of ). Oilfield data may then be accessed from the first data repository using the application programming interface (Step ). In (Step ), an interface layer of the application programming interface may be formed based on only the domain metamodel using the computer implemented method, while an implementation layer of the application programming interface may be formed based on the domain metamodel, the first target metamodel, and the first mapping specification using the computer implemented method.","Optionally, oilfield data (e.g., seismic survey, well log, etc.) associated with oilfield entities (e.g., wellbore, reservoir, etc.) may also be stored in a second data repository (Step ) (e.g., a relational database, etc.). A second target metamodel (such as the metamodel described in  above) may then be obtained (Step ). The second target metamodel includes structural description of data entities (e.g., database rows and columns, etc.) of the second data repository. A second mapping specification (such as the metamodel described in  above) may also be obtained (Step ). The second mapping specification associates the domain metamodel and the second target metamodel, such as the example described in  above. The application programming interface may then be further formed based on the second target metamodel and the second mapping specification using the same metamodel and the same computer implemented method as above (Step ). Oilfield data may then be accessed from the second data repository using the application programming interface (Step ).","An exemplary result of the method described above is illustrated in a drilling domain model application using Seabed database. Seabed is a relational database produced by Schlumberger Information Solutions for holding exploration and production information in support of a borehole operation. The exemplary domain model and mapping statistics for Seabed includes 100 domain objects, 91 Seabed entities, 618 simple properties, 144 relations, and 3,400 lines of indented XML. The exemplary generated code statistics include 250,000 lines of code (half comment and half non-comment) and 291 compile-time SQL queries. The exemplary results show that the code generation is a powerful mechanism for implementing mapping between data and domain models. The method described above creates code with consistent quality and completeness, allows data models to evolve without affecting domain models, and enables experimentation with alternative model mappings.","Furthermore, the steps of portions or all of the process may be repeated as desired. Repeated steps may be selectively performed until satisfactory results achieved. For example, steps may be repeated after adjustments are made. Adjustments to the oilfield operation may be made based on the oilfield data, the simulation results, the arrangement, and other factors. Various combinations may be tried and compared to determine the best outcome. The process may be repeated as desired.","It will be understood from the foregoing description that various modifications and changes may be made in the preferred and alternative embodiments of the present invention without departing from its true spirit. For example, the object API, data repository, and arrangement of the system may be altered to achieve the desired results. The data repository may be a relational database, a non-relational database, or other types of data store. In an example, the inputs to the code generator may be structured descriptions of physical models of oilfield entities and conceptual models of data entities in the form of a metamodel, in which case the code generator includes a metametamodel for interpreting the input metamodels. In another example, the inputs to the code generator may be in the form of a model, in which case the code generator includes a metamodel for interpreting the input models. The metametamodel may have different number of components than given in the example above and describe various different structures of the domain metamodel, the mapping specification, and the target relational metamodel. Although details are given in examples above regarding the domain metamodel, the mapping specification, and the target relational metamodel, each of them may consist of different number of components than described in the examples. Different structures of the domain metamodel may be used, the mapping specification may consist of various forms of hierarchical structures (e.g., varying number of nested levels and\/or different recursive structures), and different structures of the target relational metamodel may also be used. For another example, the interleaving structure of the domain metamodel and the mapping specification may vary, the condition and structure of the mapping constraints may change, and the hierarchical structure of the code generator tasks may also be altered to achieve the desired results.","This description is intended for purposes of illustration only and should not be construed in a limiting sense. The scope of this invention should be determined only by the language of the claims that follow. The term \u201ccomprising\u201d within the claims is intended to mean \u201cincluding at least\u201d such that the recited listing of elements in a claim are an open group. \u201cA,\u201d \u201can\u201d and other singular terms are intended to include the plural forms thereof unless specifically excluded."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["So that the above recited features and advantages of the present invention can be understood in detail, a more particular: description of the invention, briefly summarized above, may be had by reference to the embodiments thereof that are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 1A-1D","FIG. 1A","FIG. 1B","FIG. 1C","FIG. 1B","FIG. 1D"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 2A-2D","FIGS. 1A-1D","FIG. 2A","FIG. 1A","FIG. 2B","FIG. 1B","FIG. 2C","FIG. 1C","FIG. 2D","FIG. 1D"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 22","i":"a "},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIGS. 22","i":["b","d "],"b":"22"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIGS. 22","i":["e","f "],"b":"22"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 22","i":["g","h "],"b":"22"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 23","FIG. 1"]}]},"DETDESC":[{},{}]}
