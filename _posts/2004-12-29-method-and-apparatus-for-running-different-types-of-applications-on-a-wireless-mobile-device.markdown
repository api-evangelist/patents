---
title: Method and apparatus for running different types of applications on a wireless mobile device
abstract: A method and wireless mobile device runs different types of applications and groups a set of common application interfaces (APIs) that are associated with an application type to produce an application container (). The wireless mobile device and method translates calls between at least one of the linked or grouped common APIs of the application container and a shared API that is shared for example among applications of different types (). If desired the method and device also groups a set of common application interfaces associated with another application type to produce another application container. The applications of different types use APIs from the multiple application containers. In one embodiment, the translating of calls is accomplished by employing a class loading structure using, for example, a class loader that looks at certain path locations to obtain resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07810105&OS=07810105&RS=07810105
owner: Motorola, Inc.
number: 07810105
owner_city: Schaumburg
owner_country: US
publication_date: 20041229
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to the field of apparatus and methods for running different types of applications on a single virtual machine, and more particularly to methods and apparatus for running different types of applications in a wireless mobile device.","Computing devices and other devices may have different capabilities and features based on the applications installed in their memory. Firmware and applications may be pre-installed to a computing device before purchase by a customer or installed after purchase by a customer or service technician via a storage media, such as a magnetic or optical disk. For computing devices that communicate with a computer network, applications may be installed after a customer or service technician downloads the applications to the computing device.","Wireless mobile devices, such as hand held cell phones, PDA's, non-handheld devices such as lap tops, or any other suitable wireless mobile devices may utilize JAVA applications or may be compliant with various standards and may be for example J2ME compliant devices. Such devices have security managers which enforce security policies which are a type of rule or rules to ensure that various security constraints are maintained within the device. One security policy may be that only certain applications supplied by certain authors or sources can invoke SMS messaging. Numerous other security policies are also known and enforced by the security policy manager. In addition, certain mobile device platforms may use defined JAVA specification requests (JSR) which is a set of API's defined for a particular mobile device operational platform. One JAVA specification for mobile devices is a J2ME compliant device that employs mobile information device profiles (MIDP). MIDlets are JAVA applications that run in a MIDP environment. An execution environment is a set of API's and rules governing its usage and security model that are defined for that particular type of an application. Therefore a MIDP environment is an environment that uses a defined set of JSR's and other API's.","There are multiple types of applications used on wireless mobile devices today. Some examples include MIDlet applications, Doja applications, Xlet applications, native applications, and others. Each different application may, for example, use a different set of APIs and libraries that are expected differ by the different types of applications. The different types of applications may be written in the same languages, or different languages. For example, Linux native applications, JAVA based MIDlet applications, binary run time environment applications and other different types of applications for example assume a certain set of features exist in a platform in a wireless mobile device. One type of application may expect a certain engine and associated libraries, whereas another application type may expect a different set of libraries and APIs and further, each application type may use a different security model. Wireless mobile devices need to support different application types and each application type may require an execution environment, security policies and API\/libraries in the format that they expect. For example, where a wireless mobile device utilizes two or more JAVA execution environments, there may be different security models employed by the different execution environments.","Wireless operators for example want different types of applications to be supported within the same device and may also require the provisioning of additional application types after the device ships, such as by over the air provisioning. In addition, wireless operators may like to have upgrades of APIs also be made over the air if possible and also allow the control of security policies for the different application types. From the users perspective, the user of the wireless mobile device likely does not want to distinguish between different types of applications running on a given device.","However, from a wireless mobile device manufacturer's perspective, supporting multiple application types can be very expensive since there is development and testing costs associated with the different application types, additional flash\/RAM sizes of the device which can vary and increase the costs, and there may be a different application life cycle interaction, security aspects and application management aspects that need to be addressed for each application type.","One way of handling multiple application types would be to duplicate sets of APIs, libraries and engines that are required by each application type, but with processor constrained and memory constrained devices such as wireless mobile devices RAM and Flash\/Disk can be expensive and is typically a precious resource. Therefore duplicating such sets of libraries typically come at additional cost.","Devices are known for example that employ Linux Wine, which uses a set of libraries at run time that adapt Windows operating system APIs to APIs of a Linux operating system to allow one execution environment to communicate with another. These emulators typically emulate the instruction set at the hardware level and therefore are not portable when the underlying hardware changes and moreover these come at additional cost in terms of RAM and Flash.","Therefore a need exists for a method and apparatus that facilitates the running of different types of applications in a wireless mobile device.","Briefly, a method and wireless mobile device runs different types of applications and groups a set of common application interfaces (APIs) that are associated with an application type to produce an application container. The wireless mobile device and method translates calls between at least one of the linked or grouped common APIs of the application container and a shared API that is shared for example among applications of different types. If desired the method and device also groups a set of common application interfaces associated with another application type to produce another application container. The applications of different types use APIs from the multiple application containers. In one embodiment, the translating of calls is accomplished by employing a class loading structure using, for example, a class loader that looks at certain path locations to obtain resources. As such a hierarchy of class loaders is used to translate for example JAVA API function calls to different JAVA API calls.","In one embodiment, the shared APIs are APIs that are used, to access hardware operations of the device. In one example the shared APIs are written in a native language and may for example run on top of an operating system directly and not through a JAVA virtual machine. As another example, the shared APIs are written as JAVA APIs that are common across all the application types and run directly on the JAVA virtual machine.","An application container may include for example an API to communicate with an application manager, a group of common application interfaces and an API call translator. The API call translator translates calls between at least one of the linked or grouped common APIs of the application container and a shared API, such as a native API that is shared among applications of different types. An application container is run time code that runs one type of application, security model and all necessary code for APIs and each application container uses shared APIs and libraries that are shared among multiple types of different application types.","The API call translator is translation code that translates API call functions, for example, from APIs provided by a container to the calling application and translates calls into calls for the shared APIs and may call multiple shared APIs in a shared API layer. The wireless mobile device and method uses a single JAVA virtual machine, for example, to reduce the flash\/RAM size so that a single JAVA virtual machine may be used even though there are different application types. In one embodiment, an OSGi framework and a class loader are used to implement the API call translator. In one example, application containers use class loaders for enforcing and mapping application specific security models to, for example, the JAVA 2 Security model. API Isolation is accomplished for example, by using a configuration file that allows or denies access to specific classes and packages. In one example, application container uses a configuration file to selectively isolate the classes. This configuration file may also be modified as necessary to allow additional APIs to be loaded. The application containers map the life cycle of the application and the life cycle expected by an application manager. An application life cycle is a state of the application as it goes through various stages of execution, for example, start, stop, suspend, resume etc. These life cycle states are implemented in one embodiment as a set of life cycle API method calls for a particular application type. The application container provides a generic API that used by the application manager to control the life cycle of the applications executing within it. The APIs provided by the application container translate the generic APIs into the life cycle method calls for the application type.","Referring to , there is provided a schematic view illustrating an embodiment of a wireless communication system . The wireless communication system  includes a wireless communication device  communicating with a wireless communication network  through a wireless link . Any type of wireless link  may be utilized for the present invention, but it is to be understood that a high speed wireless data connection is preferred. For example, the wireless communication network  may communicate with a plurality of wireless communication devices, including the wireless communication device , via a cellular-based communication infrastructure that utilizes a cellular-based communication protocols such as AMPS, CDMA, TDMA, GSM, iDEN, GPRS, EDGE, UMTS, WCDMA and their variants. The wireless communication network  may also communicate with the plurality of wireless communication devices via a peer-to-peer or ad hoc system utilizing appropriate communication protocols such as Bluetooth, IEEE 802.11, IEEE 802.16, and the like.","The wireless communication network  may include a variety of components for proper operation and communication with the wireless communication device . For example, for the cellular-based communication infrastructure shown in , the wireless communication network  includes at least one base station  and a server . Although a variety of components may be coupled between one or more base stations  and the server , the base station and server shown in  is connected by a single wired line  to simplify this example.","The server  is capable of providing services requested by the wireless communication device . For example, a user of the device  may send a request for assistance, in the form of a data signal (such as text messaging), to the wireless communication network , which directs the data signal to the server . In response, the server  may interrogate the device and\/or network state and identify one or more solutions. For those solutions that require change or correction of a programmable module of the device , the server  may send update data to the device via the wireless link  so that the programmable module may be updated to fulfill the request. If multiple solutions are available, then the server  may send these options to the device  and await a response from the device before proceeding.","The wireless communication system  may also include an operator terminal , managed by a service person , which controls the server  and communicates with the device  through the server. When the server  receives the request for assistance, the service person may interrogate the device and\/or network state to identify solution(s) and\/or select the best solution if multiple solutions are available. The service person  may also correspond with the device  via data signals (such as text messaging) to explain any issues, solutions and\/or other issues that may be of interest the user of the device.","The wireless communication system  may further include a voice communication device  connected to the rest of the wireless communication network  via a wired or wireless connection, such as wired line , and is available for use by the service person . The voice communication device  may also connect to the network via the server  or the operator terminal . Thus, in reference to the above examples, a user of the device  may send a request for assistance, in the form of a voice signal, to the wireless communication network , which directs the data signal to the server . While the server  and or the service person  is interrogating the device and\/or network state, identifying one or more solutions, and\/or selecting an appropriate solution, the service person may correspond with the device  via voice signals to explain any issues, solutions and\/or other issues that may be of interest the user of the device.","Referring to , there is provided a schematic view  illustrating another embodiment of the wireless communication system. For this embodiment, operator requirements  are received by a service terminal  via a first connection  and a service person  operates the service terminal , if necessary. For example, the service person  may provide information about a desired operator and\/or needs of a device user so that the appropriate operator requirements  are received. The service terminal  may optionally be connected to a server  by a second connection . Regardless of whether the server  is used, the service terminal  generates appropriate components  that should be sent to a wireless communication device  operated by the user in accordance with the operator requirements  and associated information. The device  may be coupled to the service terminal  or the server  via a wired connection ,  such as a cable or cradle connection to the device's external connector, or a wireless connection. The wireless connection may include a wireless communication network that includes a base station  connected to the service terminal  or the server  and a wireless link  communication with the device .","Referring to , there is provided a block diagram illustrating exemplary internal components of various servers, controllers and devices that may utilize the present invention, such as the wireless communication devices ,  and the servers ,  of . The exemplary embodiment includes one or more transceivers , a processor , a memory portion , one or more output devices , and one or more input devices . Each embodiment may include a user interface that comprises at least one input device  and may include one or more output devices . Each transceiver  may be a wired transceiver, such as an Ethernet connection, or a wireless connection such as an RF transceiver. The internal components  may further include a component interface  to provide a direct connection to auxiliary components or accessories for additional or enhanced functionality. The internal components  preferably include a power supply , such as a battery, for providing power to the other internal components while enabling the server, controller and\/or device to be portable.","Referring to the wireless communication devices ,  and the servers ,  of , each machine may have a different set of internal components. Each server ,  may include a transceiver , a processor , a memory  and a power supply  but may optionally include the other internal components  shown in . The memory  of the servers ,  should include high capacity storage in order to handle large volumes of media content. Each wireless communication device ,  must include a transceiver , a processor , a memory , one or more output devices , one or more input devices  and a power supply . Due to the mobile nature of the wireless communication devices , , the transceiver  should be wireless and the power supply should be portable, such as a battery. The component interface  is an optional component of the wireless communication devices , .","The input and output devices ,  of the internal components  may include a variety of visual, audio and\/or mechanical outputs. For example, the output device(s)  may include a visual output device  such as a liquid crystal display and light emitting diode indicator, an audio output device  such as a speaker, alarm and\/or buzzer, and\/or a mechanical output device  such as a vibrating mechanism. Likewise, by example, the input devices  may include a visual input device  such as an optical sensor (for example, a camera), an audio input device  such as a microphone, and a mechanical input device  such as a flip sensor, keyboard, keypad, selection button, touch pad, touch screen, capacitive sensor, motion sensor, and switch.","The internal components  may include a location circuit . Examples of the location circuit  include, but are not limited to, a Global Positioning System (GPS) receiver, a triangulation receiver, an accelerometer, a gyroscope, or any other information collecting device that may identify a current location of the device.","The memory portion  of the internal components  may be used by the processor  to store and retrieve data. The data that may be stored by the memory portion  include, but is not limited to, operating systems, applications, and data. Each operating system includes executable code that controls basic functions of the communication device, such as interaction among the components of the internal components , communication with external devices via the transceiver  and\/or the component interface , and storage and retrieval of applications and data to and from the memory portion . Each application includes executable code utilizes an operating system to provide more specific functionality for the communication device, such as file system service and handling of protected and unprotected data stored in the memory portion . Data is non-executable code or information that may be referenced and\/or manipulated by an operating system or application for performing functions of the communication device.","The processor  may perform various operations to store, manipulate and retrieve information in the memory portion . Each component of the internal components  is not limited to a single component but represents functions that may be performed by a single component or multiple cooperative components, such as a central processing unit operating in conjunction with a digital signal processor and one or more input\/output processors. Likewise, two or more components of the internal components  may be combined or integrated so long as the functions of these components may be performed by the communication device.","In accordance with the present invention, an expansion of known frameworks for more suitability to a wireless device operability is disclosed herein. , illustrates a basis architecture of a mobile device in accordance with the present invention. Existing known mobile devices are typically architected such that applications are loaded on top of a fixed base platform. APIs for applications are fixed at manufacture. Therefore it is not possible to postpone, for example, new media types and\/or other upgrades without re-flashing the entire device. Turning to , a mobile device of the present invention utilizes an open OS, such as for example, Linux or Windows. Additionally, a modem interface is abstracted such that it is agnostic to the particular interface, for example radio interfaces such as GSM, CDMA, UMTS, etc. that would traditionally utilize dedicated functionality.","Referring to , there is provided a block diagram generally representing functional layers  included in the memory portion  (shown in ) of a client device, such as the wireless communication device , . The functional layers  include low-level layers  including a modem layer  and an operating system layer , a mid-level layer  also known as a framework layer , and high-level layers  including a user interface layer  and a services layer . The modem layer  may be an abstracted interface to a modem circuit of the client device in which services are accessed through message passing. The modem layer  may be air-interface agnostic, i.e., may operate using a wide variety of air interface protocols. The modem layer  may also be an abstracted interface to an RTOS, and executive application programming interfaces (API's) may be encapsulated in a thin interface layer. Further, the modem code may be on a separate processor or co-resident with application code.","The operating system layer  operates above the modem layer  and provides basic platform services for the client device, such as process management, memory management, persistent storage (file system), Internet networking (TCP\/IP), and native access security and application-to-application protection. The operating system layer  may expose native services based upon standards-defined API's (POSIX). The operating system layer  may host native applications, such as system daemons, specific-language interpreters (such as JAVA), and second-party native applications (such as a browser). Daemons are executable code that run as separate background processes and provide services to other executable code(s) or monitor conditions in the client device.","The framework layer  provides an operable interface between the low-level layers  and the high level layers  that provides ample opportunities for current and future functions and, yet, is efficient enough to avoid provide unnecessary code that may waste precious memory space and\/or slow-down the processing power of the client device. Key features of the framework layer  may include, but are not limited to, hierarchical class loaders, application security, access to native services, and compilation and translation technology for performance. Although the operating system layer  may host system daemons and specific-language interpreters, the framework layer  should actually include such system daemons and specific-language interpreters. The framework layer  may also include a framework for managing a variety of services and applications for the client device. For one embodiment, the framework layer  is an always-on CDC\/FP\/PBP JVM running OSGi framework.","The services layer  is adapts the framework layer  to wireless communication services. The services layer  includes services packaged in modular units called bundles that are separately life-cycle managed (e.g., start, stop); are separately provisioned, upgraded and withdrawn; and abstracts the complexity of the service implementation from a user of the client device. Services are modular, extensible and postponeable so that, within the services layer , services may be added, upgraded and removed dynamically. In particular, the services layer  includes a lookup mechanism so that services may discover each other and applications may discover services used by other services, e.g., service provider interfaces (SPI's), and services used by applications, e.g., application programming interfaces (API's).","An API is a formalized set of function and\/or method calls provided by a service for use by a client device, whereas an SPI is a set of interfaces and\/or methods implemented by a delegated object (also called provider) providing an API to the client device. If an API is offering methods to client devices, more API's may be added. Extending the functionality to offer more functionality to client devices will not hurt them. The client device will not use API's that are not needed. On the other hand, the same is not true for SPI's. For SPI's, the addition of a new method into an interface that others must provide effectively breaks all existing implementations.","The user interface layer  provides application management functionality for managing applications and the user interface for the client device. The user interface layer  includes lightweight APIs for coordinating user interaction among the underlying services of the services layer . Also, the user interface layer  is also capable of managing native applications and language-specific application, such as JAVA. The user interface layer  creates a unifying environment for the native applications and the language-specific applications so that both types of applications have a similar \u201clook and feel\u201d. The native applications utilize components of a native toolkit, and the language-specific applications utilized components of a corresponding language-specific toolkit. For the user interface layer , a language-specific user interface toolkit is built on the native toolkit, and MIDlets are mapped to the language-specific user interface toolkit.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5","FIG. 5","FIG. 5"]},"Unlike prior art architectures, as previously mentioned, wherein applications are loaded on top of a fixed base platform, applications as shown in the embodiments illustrated by  are architected in a more flexible structure. In accordance with the embodiments of , application and feature upgrades, new content types, new standards-based upgrades, new operator specific service libraries, and component upgrade and repair are facilitated.","Referring to , there is provided a block diagram illustrating a first client embodiment  included in the memory portion  of the client device, such as the wireless communication device , . The first client embodiment  includes a UE layer , a plurality of services , , , a service\/application framework , an other or language-specific interpreter  (such as JAVA Virtual Machine), native libraries and daemons , an operating system , and a modem services interface . The UE layer  interacts with native applications  and language-specific applications , such as JAVA. The modem services interface interacts  with a baseband processor  of the client device.","The applications are user-initiated executable code whose lifecycle (start, stop, suspend, pause, resume) may be managed. The applications may present a User Interface and\/or may use services. Each daemon is an operating system (OS) initiated, executable code that runs as a separate background process. Daemons may provide services to other executable code or monitor conditions in the client.","There is organizational cooperation of the services , ,  with the mid-level layer  which includes the service\/application framework , the language-specific interpreter  and the native libraries and daemons  as well as the UE layer . As represented by , the types of available services include native-based services  which rely on one or more components of the native libraries and daemons , language-specific services  which rely on components associated with the language-specific interpreter , and native or language-specific services  that further rely on components of the UE layer .","A service is a set of functionality exposed via a well-defined API and shared among applications. A service has as least two characteristics, namely a service interface and a service object. The service interface is the specification of the service's public methods. The service object implements the service interface and provides the functionality described in the interface. A service may provide methods that present a User Interface. Invoking a method on a service is done in the caller's context (thread\/stack). Services may return a value to the requesting client by depositing it on the caller's stack, unlike an invoked application. The implementation of the service may be replaced without affecting its interface. Examples of services include, but are not limited to, messaging, security, digital rights management (DRM), device management, persistence, synchronization and power management.","A system service is a low-level service specific to an operating system or MA (CDMA, TDMA, GSM, 3G etc.) and is not part of the abstract set of services exposed to the applications directly. System service APIs should not be used by any component that is intended to portable across all instantiations of the platform. A framework service is a service that exposes a higher level abstraction over system services and provides OS-independent and MA-independent access to infrastructure components and services. An application service is a service that exposes application-specific functionality (both UI and non-UI) via a well defined API. A native service is a service written in native code.","A library is a set of services contained in an object that can either be statically linked or dynamically loaded into executable code. Library services may invoke other library services or services contained in daemons, which are external to the library and may also run in a different process context.","Referring to , there is provided a block diagram illustrating a second client embodiment  of the lower level functional layers of the client device. The first client embodiment  represents a dual processor architecture of a client device, whereas the second client embodiment  represents a single core architecture of a client device. For the second client embodiment , the operating system  includes the modem services interface  and a baseband code . In addition, the operating system  may include other components, such as an RTOS abstraction  and an RTAI .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 7","b":["700","702","704","702","706","708","708","700","700","704"]},"The processor  is shown as executing a plurality of code modules which in this example include an application\/service manager , an operating system , a JAVA virtual machine  (JVM) (such as a JAVA 2 virtual machine that may employ for example a JAVA 2 security model), shared APIs  defined herein to include libraries if desired, and a plurality of application containers .","In this example, the plurality of application containers  include a MIDlet application container , other application containers such as an OSGi based application container  (e.g. JAVA 2 application container), and a native application container . As shown, in this example the native application container  communicates with the operating system  but does not interface with the JAVA virtual machine . However, it will be recognized that any suitable configuration may be employed. Each of the functional blocks, as shown, communicate with one another through conventional communication links shown by the arrows, such as through suitable API method calls or any other suitable techniques.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 8","FIG. 7"],"b":["704","720","800","802","720","722","804","806","720","722","710","800","802"]},"As also shown, the application containers  and  include a group of common application interfaces  and  respectively associated with application types. In one embodiment the isolation of common APIs are accomplished by using a configuration file. As such, the processor  creates a configuration file that identifies the API's (and any other suitable information) in a given group. In addition, each application container  and  includes an API call translator  and  that receives for example calls  and  from respective APIs common in each container to interface with shared APIs . The API call translator  in each application container translates calls between one of the linked common API's  and a shared API  that is shared among applications but use API's from a first and second application container. In this example, application  is of a different application type from applications  and , however, applications  and  for example both use the shared APIs . The application container  also includes code that provides a runtime environment for the applications  and . The application container executes the application on behalf of the application service manager.","In this example, the shared API's  are shared APIs that are used to interface with hardware components or processes of the wireless mobile device. As shown in this example, the shared APIs  may include for example a multimedia API, a device management API, a telephone API, an accessory API, or any other suitable shared APIs generally shown as .","The API call translator  also links libraries and security policies common to a given application type to further define each application container. In one embodiment each API call translator is written to translate one or more API calls provided by the shared APIs.","The JAVA virtual machine  employs a JAVA 2 security model in this example and as shown application  may be a JAVA 2 application such as in OSGi bundle. The application container itself may be packaged as a OSGi bundle and can be provisioned into the device via over the air provisioning mechanisms. MIDlet applications  also use the JAVA virtual machine  since the API call translators  and  translate API calls into appropriate formats for the shared APIs  that are used by the JAVA virtual machine .","The application service manager  manages applications running within the application containers by using the generic API  and  provided by the application containers  and  respectively. This application service manager is utilized by the User Interface layer  and  to provide a unified application and service management for all the applications within the device. The application service manager also determines which application container to use for providing the runtime execution environment when a new bundle containing an application is provisioned to the device.","An application container  is a managed run time environment for deploying and executing applications. The application containers  and  for example determine what APIs are exposed to the respective applications ,  and , the life cycle of the applications, and the security mechanisms and policies exposed to the applications and utilize respective API call translators  and  to translate function calls or other calls to the shared APIs . The API call translators  and  are part of a framework and include a set of JAVA classes and class loaders that provide APIs to one or more application containers. As used herein, managed run time environment is code for deploying and executing applications.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 9","b":["720","722","900","700","718","902","718","902","904","818","814","906","818","716","716","810"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 10","b":["814","800","720","814","1002","1004","1004","800","802","810","1004","800","802","1002"]},"The MIDlet container class loader  then loads, for example one or more commons APIs in  such as a JSR , JSR  or other APIs and common APIs . In one embodiment, the JVM  provides a system class loader  and the OSGi provides a bundle class loader  and a framework class loader  and the implementation of  includes the MIDlet container class loader  and MIDP MIDlet suite class loader . A bundle class loader  for other services may also be employed if desired.","In one embodiment, the class loaders , , ,  and  are organized hierarchically. The system class loader  and Framework class loader  are responsible for loading shared APIs  and platform APIs . The bundle class loader  is responsible for loading the MIDlet application container . MIDlet container class loader is responsible for loading the common API classes  and the MIDlet suite class loader is responsible for loading the application specific classes  and .","For example, the MIDlet container class loader  maintains a configuration of classes that are imported and maintains a table that maps MIDP security models to JAVA 2 permissions in a configuration file . As such, security mapping is also provided. The system class loader for example loads the shared APIs required by all the application containers.","Application container upgrades may also be accomplished by dynamic class import updates since a table may be modified that controls the imported classes dynamically. As such, an API  may be included to modify the entries of the table that controls access to classes and the API  may be used to modify the security policies settings for the application container.","As such, the application containers may provide isolation by selectively filtering out the classes exposed by the system class loader , framework class loader  and bundle class loader , security and scope\/visibility even though applications that are running on a mobile wireless device for example may have different application containers that may have different concurrency, life cycle, and interaction models. Multiple application containers can coexist at the same time and can be dynamically isolated by using class loaders. Once the applications are executing within the application containers, they are basically indistinguishable to an end user. A single application management interface can be used to manage applications deployed on any container and new containers may be dynamically added if desired by over the air provisioning. Containers that are not used may also be unprovisioned or stopped to save Flash\/RAM on the wireless device.","While the preferred embodiments of the invention have been illustrated and described, it is to be understood that the invention is not so limited. Numerous modifications, changes, variations, substitutions and equivalents will occur to those skilled in the art without departing from the spirit and scope of the present invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
