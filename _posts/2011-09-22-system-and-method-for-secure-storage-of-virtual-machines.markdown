---
title: System and method for secure storage of virtual machines
abstract: A virtual file system is described that is implemented in a virtualization platform as a stackable file system layer that intercepts file operations between a hypervisor and a physical file system. The virtual file system encrypts (at least in part) VM files to be stored, organizes the encrypted VM files into VM sets, and then maps and stores the encrypted VM sets into storage pools. Storage and access to files within the VM sets is controlled through the use of administrator-determined policies governing storage, security, access control, authentication, and auditing. The system and method described herein allow a seamless integration between a data center (e.g., a private cloud) and computing resources served across the internet and supported by cloud service providers (e.g., public clouds) while ensuring that the security needs of customers and cloud service providers are met.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09053339&OS=09053339&RS=09053339
owner: HyTrust, Inc.
number: 09053339
owner_city: Mountain View
owner_country: US
publication_date: 20110922
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the benefit of U.S. Provisional Patent Application No. 61\/407,133 filed on Oct. 27, 2010 and entitled \u201cCAFS-A Cloud Aware File System,\u201d incorporated herein by reference in its entirety.","1. Field of the Invention","The present invention relates generally to computer file storage, particularly storage of virtual machine files.","2. Description of the Prior Art","Server virtualization is a technology that allows the transition from distinct physical servers each running different operating systems and applications to a virtualized server that enables multiple physical servers to run concurrently as independent virtual machines (VMs) on one single physical server (the \u201cvirtual server\u201d). The software component that allows multiple guest operating systems (\u201cguests\u201d) to run simultaneously on the virtual server is the hypervisor (e.g., the VMware\u00ae ESX Server, Citrix\u00ae XenServer, and Microsoft\u00ae Hyper-V). The hypervisor is responsible for creating, releasing, and managing the resources of the guest VMs installed.","Server virtualization offers savings over traditional dedicated physical servers. Using virtual servers minimizes up-front capital costs, requires less hands-on management, and may even reduce software costs since most software that runs on a given operating system can be installed on virtual servers, often with fewer restrictions than for software installed in shared hosting environments. Due to the number of VMs typically running on a single machine, however, a virtual physical server tends to have limited processor time, RAM, and disk space available.","Storage and security products that have worked well in the physical computing world, however, are not well suited to server virtualization and cloud computing environments. The cost benefits of server virtualization are offset by poor storage utilization which results in increased storage costs and a new set of security threats that did not exist in the physical computing world. These security threats are one of the major reasons why information technology (IT) organizations are reluctant to use VMs for storing sensitive data and have turned instead to cloud service providers (CSPs) who provide computation, software, data access, and storage services without requiring end-user knowledge of the physical location and configuration of the system that delivers the services.","Storage vendors, as a group, have done little to accommodate the influx of server virtualization. Lack of innovation and security capabilities has resulted in the use of traditional and expensive storage solutions that are ill-equipped to deal with the new virtualization and cloud computing worlds. Placing cloud-stored sensitive data in the hands of strangers (unknown CSPs) is not just unnerving, but could also engender major legal issues when dealing with auditors and regulatory bodies (e.g., the Payment Card Industry (PCI) Security Standards Council), especially in light of data breach laws now common across the United States and in other countries.","Virtualization servers are typically set up as shown in . A guest operating system  (e.g., Microsoft\u00ae Windows XP VM) is accessed and managed by a hypervisor  on a virtualization server . The hypervisor communicates with a physical file system  which organizes VM files  stored on a local disk or via network-attached storage accessed via protocols such as an Internet-based Small Computer System Interface (iSCSI) protocol or a Network File System (NFS) protocol.","In the older, physical hardware-based computing world when mainframes and mini-computers ran in the data center and Intel-based PCs were found at home, an average consumer was not sophisticated enough to access mainframes and mini-computers to steal stored data. Current virtual servers are more vulnerable, however, both because VMs are very mobile and because home and office computing hardware (Intel\u00ae x86 architecture) is often the same as that used in a data center so an average computer user is often knowledgeable enough to access a VM which is stored in a folder on a disk. In short, what would be the operating system's physical disks (for example C: and D:) are now regular files that are easily viewable and easy to copy. Stealing a VM then, is simply a matter of copying (e.g., to a USB thumb drive)  the set of VM files, and carrying them out of a data center without authorization. Alternatively, the set of files can be copied over a network () to another machine, again without authorization. These appropriated files can run on a home personal computer using free tools from all the major hypervisor vendors.","Virtual servers can be secured, but that security comes at a cost. And, if that security impedes the technological benefits that virtualization provides, some companies will avoid virtualization when sensitive data is being processed and thereby miss out on the benefits of virtualization and cloud computing.","In one example is provided a computing system for secure storage of one or more virtual machine file comprising: a file system driver of a first computing system configured to intercept from a hypervisor of the first computing system a command to store one or more virtual machine file; a communication module of the first computing system configured to communicate securely with a key store on a second computing system to retrieve one or more encryption key and with a policy store on the second computing system to retrieve one or more policy rule; a key management module of the first computing system configured to obtain the one or more encryption key from the communication module; and a storage management module of the first computing system configured to obtain the one or more policy rule from the communication module and to inform the file system driver based on the obtained one or more policy rule how to store the one or more virtual machine file in one or more storage pool of a third computing system; wherein the file system driver is further configured to encrypt at least partially the one or more virtual machine file using the one or more obtained encryption key received from the key management module; and transfer the one or more at least partially encrypted virtual machine file through a virtual machine file system of the first computing device to the one or more storage pool based on the retrieved one or more policy rule.","In another example is provided a computing system for accessing one or more virtual machine file stored securely and at least partially encrypted, the system comprising: a file system driver of a first computing system configured to intercept from a hypervisor of the first computing system a command to access the one or more at least partially encrypted virtual machine file; a communication module of the first computing system configured to communicate securely with a key store on a second computing system to retrieve one or more encryption key and with a policy store on the second computing system to retrieve one or more policy rule; a storage management module of the first computing system configured to obtain the one or more policy rule from the communication module and to inform the file system driver based on the one or more obtained policy rule how to access the one or more at least partially encrypted virtual machine file in one or more storage pool of a third computing system; and a key management module of the first computing system configured to obtain the one or more encryption key from the communication module; wherein the file system driver is further configured to retrieve the one or more at least partially encrypted virtual machine file through a virtual machine file system of the first computing device; decrypt the one or more at least partially encrypted virtual machine file using the one or more obtained encryption key received from the key management module; and transfer the one or more decrypted virtual machine file to the hypervisor.","In another embodiment is provided a method for secure storage of one or more virtual machine file, the method comprising: intercepting with a file system driver on a first computing system from a hypervisor of the first computing system a command to store the one or more virtual machine file; retrieving with a communication module of the first computing system through a secure communication channel one or more encryption key from a key store on a second computing system and one or more policy rule from a policy store on the second computing system; obtaining with a key management module of the first computing system the one or more encryption key from the communication module; obtaining with a storage management module of the first computing system the one or more policy rule from the communication module and informing the file system driver how to store the one or more virtual machine file in one or more storage pool of a third computing system based on the one or more received policy rule; encrypting at least partially one or more virtual machine file using the one or more encryption key received from the key management module; and transferring with the file system driver the at least partially encrypted one or more virtual machine file through a virtual machine file system of the first computing system to the one or more storage pool based on the retrieved one or more policy rule.","In another embodiment is provided a method to access one or more virtual machine file stored securely and at least partially encrypted, the method comprising: intercepting with a file system driver on a first computing system from a hypervisor of the first computing system a command to access the one or more at least partially encrypted virtual machine file; retrieving with a communication module of the first computing system through a secure communication channel one or more policy rule from a policy store on a second computing system and one or more encryption key from a key store on the second computing system; obtaining with a storage management module of the first computing system the one or more policy rule obtained from the communication module; accessing through a virtual machine file system of the first computing system the one or more at least partially encrypted virtual machine file in the one or more storage pool of the third computing system based on the obtained one or more policy rule; obtaining with a key management module of the first computing system the one or more encryption key from the communication module; decrypting the one or more accessed partially encrypted virtual machine file based on the one or more obtained encryption key; and transferring with the file system driver the decrypted one or more virtual machine file to the hypervisor.","In yet another embodiment is provided a non-transitory computer readable medium having stored thereupon computing instructions comprising: a code segment to intercept with a file system driver on a first computing system from a hypervisor of the first computing system a command to store the one or more virtual machine file; a code segment to retrieve with a communication module of the first computing system through a secure communication channel one or more encryption key from a key store on a second computing system and one or more policy rule from a policy store on the second computing system; a code segment to obtain with a key management module of the first computing system the one or more encryption key from the communication module; a code segment to obtain with a storage management module of the first computing system the one or more policy rule from the communication module and informing the file system driver how to store the one or more virtual machine file in one or more storage pool of a third computing system based on the one or more received policy rule; a code segment to encrypt at least partially one or more virtual machine file using the one or more encryption key received from the key management module; and a code segment to transfer with the file system driver the at least partially encrypted one or more virtual machine file through a virtual machine file system of the first computing system to the one or more storage pool based on the retrieved one or more policy rule.","In yet another embodiment is provided a non-transitory computer readable medium having stored thereupon computing instructions comprising: a code segment to intercept with a file system driver on a first computing system from a hypervisor of the first computing system a command to access the one or more at least partially encrypted virtual machine file; a code segment to retrieve with a communication module of the first computing system through a secure communication channel one or more policy rule from a policy store on a second computing system and one or more encryption key from a key store on the second computing system; a code segment to obtain with a storage management module of the first computing system the one or more policy rule obtained from the communication module; a code segment to access through a virtual machine file system of the first computing system the one or more at least partially encrypted virtual machine file in the one or more storage pool of the third computing system based on the obtained one or more policy rule; a code segment to obtain with a key management module of the first computing system the one or more encryption key from the communication module; a code segment to decrypt the one or more accessed partially encrypted virtual machine file based on the one or more obtained encryption key; and a code segment to transfer with the file system driver the decrypted one or more virtual machine file to the hypervisor.","A cloud-aware file System (CAFS) is described herein that bridges physical and virtual computing worlds and the traditional storage servers that still dominate the IT industry today. CAFS ensures that VMs are protected, regardless of where they are used or whether they are moved, and allows CSPs to support secure, multi-tenant environments in which different customer workloads can be run securely but with no overlap in administrative, access, or auditing capabilities. CAFS offers a variety of features which provide a seamless integration between on-line access, backup and cloud migration to achieve security and maximize the use of existing storage technologies.","CAFS provides support for standard protocols that allow client machines to retrieve files from a server machine. CAPS' ability to integrate with standard protocols allows CAFS to be plugged into any virtualization platform that supports NFS (e.g., VMware\u00ae ESX, Microsoft\u00ae Hyper-V, Citrix\u00ae XenServer, and Red Hat KVM) or similar protocols.","Although most virtualization platforms support iSCSI and Fiber Channel, CAFS offers greater flexibility by being able to see individual files of the VM and then store and access those files according to storage policies (described in greater detail below). By having access to the different files within the VM, files can be encrypted on an as-needed basis as data is written through CAFS to back-end storage. CAFS minimizes the impact on computing performance caused by encryption by only encrypting those parts of the VM that customers require to be encrypted (e.g., application data). CAFS further reduces any performance penalty associated with encryption by utilizing any hardware cryptographic support available.","CAFS integrates policy and encryption key management thereby allowing CAFS to build storage, encryption, and access controls that apply to a single VM or a set of VMs. By grouping one or more related VMs into VM sets, and having policies that apply to a VM set, CAFS provides a separation of duties at the storage layer, a feature that would be beneficial to multi-tenant providers such as CSPs. To maintain security, encryption keys and policies are created and managed on an external key and policy server which is a hardened appliance with no login access. The encryption keys themselves are protected on disk by being encrypted with a symmetric key which is itself encrypted with a Master Key. CAFS further supports automatic (i.e., while the VM is being accessed) key rotation (a process that requires decrypting with an old key and re-encrypting with a new key) while on-line (i.e., without the need to shut down the VM). This can be significant since routine encryption key rotation processes are often required by regulatory bodies such as PCI.","CAFS implements a flexible storage model in which a storage pool mapper is able to store separate files of a VM in one or more storage pool (a collection of similar local or remote storage devices) and migrate VM files among the storage pools while the VM is being accessed for other purposes. One of skill in the art will understand that the one or more storage pool can exist on the same physical host on which CAFS is running, and\/or one or more storage pool can be located on non-direct-attached, separate storage devices. At an administrator-defined time interval, CAFS makes VM replicas which can be sent to remote servers for disaster recovery purposes or to move the VMs into and out of the cloud.","When a VM is accessed, CAFS provides audit records that aid in support of various compliance requirements for an organization or service provider. Furthermore, CAFS provides information about VM usage and sets of VMs that allow cloud service providers to provide per-customer billing.","CAFS Fundamentals. One of skill in the art will recognize that although CAFS is discussed herein as using NFS as an exemplary standards-based file system protocol, CAFS can interface with any standards-based file system or storage protocol that allows client machines to retrieve files from a server machine.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["102","101","203","102","104","206","105","207","203","203","102","102"]},"CAFS  is a virtual file system (VFS), preferably implemented as a stackable file system layer preferably in a FreeBSD file system framework, although one of skill in the art will understand that CAFS  can be implemented in other computing frameworks and environments.  illustrates how CAFS functions as a stackable file system layer. CAPS  intercepts file operations at a VFS\/vnode interface layer . Physical file system  is unaware of the presence of CAFS . The kernel responds to any file-related system calls by packaging arguments and invoking the top-most layer of the stack through a set of VFS or vnode interfaces . VFS interfaces are application programming interfaces (APIs) in the kernel that allow file system-level operations  such as mount, unmount, and stat (for printing file system statistics). Vnode operations are file-level operations  such as open, read, write, close and stat (for printing file statistics). Through the use of private data structures  (which are referenced from the v_data field of the vnode structure), CAFS  is able to maintain the mapping between its vnode structure and the vnode structure of the underlying file in the physical file system. Further details about the BSD VFS are accessible at http:\/\/www.cs.berkeley.edu\/\u02dcpal\/os\/vfs.ps, which is incorporated herein by reference in its entirety.","Each open file in FreeBSD UNIX is represented by a vnode structure. All VM files  have entries in the physical file system where CAFS is mounted, an area used by CAFS as the default backing store. Some of those entries are special redirector links that reference files in one of the available storage pools. In this case, the CAFS vnode private structure will point to the vnode of the file in that particular storage pool.","As shown in the block diagram of , several components collectively form the CAPS framework. Some of these components run in user space  as background applications (e.g., daemons) while others run inside the operating system kernel . The specific components are a CAFS file system driver , a CAFS portal , a storage management module , a secure communications module , and an encryption\/key management module .","CAFS driver  is a virtual file system driver conforming to the VFS\/vnode architecture as described above. CAFS driver  is preferably implemented as a stackable file system driver, as for example, in a UNIX FreeBSD kernel. Stacking CAFS driver  on top of physical file system  provides additional capabilities above those of physical file system , thereby achieving greater flexibility because new file system features can be added without modifying physical file system . CAFS driver  sits on top of one or more storage pool that can be represented by a file system exporting local physical storage or one of a number of other storage pools comprised of different storage types such as iSCSI and NFS.","CAFS portal  is a pseudo device driver used for communication between CAFS driver  and storage management module .","Storage management module  is a management module (preferably a daemon) responsible for performing tasks that are best suited to running outside of kernel  (i.e., those tasks easier to implement in user space). Storage management module  is responsible for handling policy decisions, including informing CAFS of where to store VM files  (i.e., into which storage pools) as the VM files  are created.","CAFS driver , CAFS portal , and storage management module  also act in concert as a storage pool mapper  (as discussed in greater detail herein).","Secure communications module  is a module (preferably a daemon) that is responsible for communications with a key and policy server  to fetch policies and keys as VMs are accessed.","Encryption\/key management module  is a kernel module that interfaces with the operating system's cryptographic interfaces as well as with secure communications module  to fetch encryption keys on an as-needed basis (as discussed in greater detail below).","Storage pools. CAFS stores each VM in one or more storage pool  through the use of storage pool mapper  with individual plugin modules that make use of the API (e.g., one plug-in module may be for SCSI storage, and another may be for cloud storage, but both will use the same API). Storage pool mapper  is a software interface between CAFS driver , storage management module , and CAFS portal  which provides a set of functions that make each storage pool look identical regardless of whether the storage pool is backed by physical disks or by a layer that supports backup and\/or replication. Storage pool mapper  maps components of each VM (i.e., VM files ) to their various storage pools (for example, C: uses mirrored storage, D: uses encrypted SSD storage), and is also able to move VM files  among storage pools while the VM is still being accessed.","The operations exported by each storage pool mapper  to the storage pools  allow the seamless migration of VM components between different pools, the dynamic rekeying of encrypted VM files , and the shredding of VM files . Operations supported by each storage pool mapper include, without limitation:\n\n","Storage pool  can be any back-end storage device, including, without limitation, locally attached storage (e.g., SATA (Serial Advance Technology Attachment (SATA) drives, solid-state drives (SSD), or a redundant array of independent disks (RAID) controller), network-attached storage (NAS), storage area networks (SAN) (via Fiber Channel), an archive server located on a separate server, a tape archive, a cloud portal (a pool that has storage in the cloud), and\/or block storage over internet protocols (e.g., iSCSI). Storage pools may comprise local storage for on-line access, local or remote storage for secure backups, and\/or remote storage for disaster recovery or for interaction between the data center and the cloud.","Administrators can use different classes of storage and different levels of redundancy when provisioning storage for a physical system depending on the data being stored. In a UNIX database server running Oracle, for example, a root file system (\u201c\/\u201d) of the operating system does not need to be stored in a device with high access speeds, but should be mirrored because losing the file system would render the machine unusable. Access performance and redundancy are critical, however, for customer database files (\u201c\/uo1\u201d, \u201cuo2\/\u201d), so the fastest storage available should be used and the storage will be mirrored. Swap space files (\u201c\/swap\u201d), on the other hand, are not critically important, so the data can be stored unmirrored in inexpensive storage. And temporary files (\u201c\/tmp\u201d, files which are not expected to survive a reboot) can be stored in any storage pool. When using virtualization technology such as VMware's ESX Server, however, this logical separation of data types becomes blurred. VMs may be stored on an external server using NFS, in which case the storage backing the NFS exported data store is all one type. In this scenario, expensive enterprise storage could end up being used for both \/swap and \/tmp, with the consequent result that the move to virtualization (which should reduce costs) could end up costing more than physical servers because of increased storage costs.","CAFS allows individual files from any given VM to be mapped to separate storage pools (each of which may have different characteristics) regardless of the guest operating system. A major advantage of this purpose-directed storage provisioning is that storage and performance costs can be minimized. As one example, storage provisioning can be arranged as follows:\n\n","To migrate stored VM files  from one storage pool to another, a snapshot of the VM is taken and copied (entirely or incrementally) elsewhere (to disk or tape). The same principle applies for replication for disaster recovery or for moving in or out of a cloud: a copy of the VM is made and moved to another server in a\u2033different physical location.","Multi-tenancy features (VM sets). Many CSPs operate \u201ccustomer islands\u201d to customize multi-tenant virtualization environments. Each customer is given a group of physical machines and the CSP provides a way to segregate these machines into customer islands so that there is no overlap between the workloads and data of one customer and those of another customer. This practice is an inefficient way of managing physical servers and diminishes the benefits of using cloud storage. CAFS instead enables multi-tenant virtualization environments through the use of VM sets.","A VM set is a collection of VMs that are related and governed by the same customer-specific policies. VM sets share a similar set of properties such as: storage type (mirroring, de-duplication, number of replicas), security (keys, key states, and associated encryption policies), access controls, and audit records. Grouping VMs into sets with different policies based on customer-specific needs ensures that customers' groups of VMs do not overlap in either use or storage. In a multi-tenant environment, grouping of VMs into a VM set allows one tenant's VMs to be virtually (but not necessarily physically) separated from those of another tenant and to be managed independently, even if the same physical servers and the same storage are being used by one or more tenant. In a CSP model where multi-tenant capabilities are needed, each tenant has a separate administrator who controls its own VM sets, as well as separate administrators managing encryption keys and VM storage. Referring again to , for example, VM set  for Customer A may have VM files  in local storage pools, SAN\/NAS pools, and backup pools, VM set  for customer B may have VM files  in backup pools, disaster recovery pools, and public clouds, and VM set  for customer C may have VM files  stored in SAN\/NAS pools, backup pools, disaster recovery pools, and public clouds. Customers A, B, C may all have VM files  in the same backup pool, but since VM files  are grouped into sets, customer A's policies restrict access to its VM files  such that only customer A's administrators\/users can access VM set  belonging to A. Likewise, customer B's policies and customer C's policies restrict access to their respective administrators\/users. Yet each customer A, B, and C gains the benefit of lower storage costs because each has optimized its storage based on the type of storage needed for its VM files.","Grouping VMs into VM sets can be beneficial within an IT department as well as in a multi-tenant cloud environment. Within a company's IT department's infrastructure, for example, VM sets may be preferred because:\n\n","VM set policies. Each VM set has associated policies that establish the administrator-determined rules governing storage, security, access, authentication, and auditing for that VM set. The defined parameters of each policy are defined within the policy descriptor and include information such as, without limitation:\n\n","Because NFS has limited security mechanisms, CAFS uses these policy descriptors as authentication and access controls for any VM set accessed through NFS. For example, when a VM set is created, the servers that are allowed to access the VM are specified within the policy for that VM set. Access by any server not listed will be denied and an audit record will be generated. Policies also designate access windows (the specific time periods during which the VM can be accessed). As an example, a customer workload running in the cloud should only be accessed during business hours Monday to Friday. Any attempt to access the VM at night or over the weekend will result in a denial and an audit record being generated.","In a preferred embodiment, policies themselves are not stored with the VM set or with any of the VMs. Instead, CAFS stores a globally unique identifier (GUID) with each VM file. The GUID is a reference to an object (or file) that is stored on the key and policy server and used to fetch the associated policy keys when VM files are accessed. The object or file referenced by the GUID contains CAFS-specific metadata that travels with the VM and has enough information to allow CAFS to find the appropriate key and policy server to fetch the associated policies and encryption keys. Such a reference system is desirable for two reasons. First, VMs are not static. They can be accessed on-line, moved to backup media, migrated from one storage platform to another (including in and out of a cloud), and moved from large servers to desktops and notebooks. Because of security concerns, policy descriptors and encryption keys should not be stored directly with the VM. Second, VM sets names can be reused. For example, a VM set called my_vmset that is accessible through NFS mount point \/mnt could be archived and deleted from primary storage. In the meantime, another VM with the same name and mount point could be created. At some stage in the future, restoration of one of these VMs could be problematic because both have the same name and mount point. If each VM contains encrypted data, CAFS needs to know which policy descriptor and which encryption keys to use, and which storage policy to apply on restore.",{"@attributes":{"id":"p-0057","num":"0100"},"figref":"FIG. 5","b":["407","405","403","401","105","501","502"]},"Shown below is an exemplary XML representation of VM set information that is received from the key and policy server:",{"@attributes":{"id":"p-0059","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002","<?xml version=\u20331.0\u2033 encoding=\u2033ISO-8859-I\u2033?>"]},{"entry":[{},{},"<vmset>"]},{"entry":[{},{},"\u2003<name>my_vmset<\/name>"]},{"entry":[{},{},"\u2003<mnt>\/nfs<\/mnt>"]},{"entry":[{},{},"\u2003<pd>45aa9e57-bf64-11df-8d3e-000c29abeb4d<\/pd>"]},{"entry":[{},{},"\u2003<vmserv>755083456<\/vmserv>"]},{"entry":[{},{},"<\/vmset>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The mount point (mnt tag) and name of the VM set (name tag) contain enough information to create an appropriate path from which the VM set can be accessed. The vmserv tag lists the virtualization servers that are able to access this VM set. The policy descriptor (pd tag), also referenced by a GUID, is fetched in response to a VM access or creation. Once fetched, policy descriptors are cached in memory so that they can be easily retrieved on a subsequent access from a virtualization server.","CAFS reacts to vnode operations that affect the VM set. As an example shown in , when an attempt is made to access a VM, stored under \/nfs\/my_vmset\/windows_xp and for which there is no cached policy descriptor, CAFS driver  executes the following sequence:\n\n","CAFS driver  reacts in a similar manner to other vnode operations that affect the VM set (e.g., an NFSPROC_READDIR( ) request to view the contents of the VM set directory). Regardless of the operation requested. CAPS driver  responds by informing storage management module  which, in turn, requests that secure communications module  retrieve the policy descriptor from the key and policy server .","Mapping VMs to storage pools. VM files are created based on properties of the policy descriptor. The policy descriptor contains, in addition to the policy parameters, a set of virtual objects that describe the mapping between VM files and the different storage pools available. The virtual objects also determine whether the file will be encrypted and if so, with what encryption key.","A VM consists of a number of files that can be divided into two basic types:\n\n","Most storage products used in virtualization environments do not offer any services that are particularly well-suited to the needs of the virtualization environment. For example, if SCSI is being used, the logical unit numbers are carved out from the block-based back-end storage, whereas if NFS is used, the NFS shares are exported and access is controlled through standard UNIX permission mechanisms. One problem with these approaches is that all storage is created equal within the virtualization environment, and therefore less important application data are stored identically to more critical data.","When creating the policy descriptor used by CAFS, the VM administrator is able to determine the type of storage and backup\/disaster recovery capabilities of specific VMs and also of data classes within the VM. For example, a pseudo-storage policy for a VM with three virtual disks might be:","Meta Data:\n\n","Storage:\n\n","Within the policy descriptor, virtual objects are used to determine how to store one or more components within a VM. An exemplary fragment of the policy descriptor XML is shown below. The policy descriptor contains two policy statements (or \u201cvirtual objects\u201d contained within each vobj tag) that map a file within a VM to its storage pool, describe the window in which the file can be accessed, the amount of audit data to be generated, and the encryption key to be used. If encryption is not required, the symkey tag will reference a \u201cclear-text\u201d key.",{"@attributes":{"id":"p-0070","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002","<vobj-list>"]},{"entry":[{},"\u2003<vobj>"]},{"entry":[{},"\u2003\u2003<vglob>*osdisk*<\/vglob>"]},{"entry":[{},"\u2003\u2003<symkey>062b9056-bf64-11df-8d3e-000c29abeb4d<\/symkey>"]},{"entry":[{},"\u2003\u2003<storepol>mirrored_pool_A<\/storepol>"]},{"entry":[{},"\u2003\u2003<access>Mon-Fri(9am-5pm)<\/access>"]},{"entry":[{},"\u2003\u2003<audit>all_records<\/audit>"]},{"entry":[{},"\u2003<\/vobj>"]},{"entry":[{},"\u2003<vobj>"]},{"entry":[{},"\u2003\u2003<vglob>hc_default<\/vglob>"]},{"entry":[{},"\u2003\u2003<symkey>01010101-0101-0101-0101-010101010101<\/symkey>"]},{"entry":[{},"\u2003\u2003<storepol>default_pool<\/storepol>"]},{"entry":[{},"\u2003\u2003<access>at_all_times<\/access>"]},{"entry":[{},"\u2003\u2003<audit>none<\/audit>"]},{"entry":[{},"\u2003<\/vobj>"]},{"entry":[{},"<\/vobj-list>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A default virtual object (a \u201ccatch-all\u201d policy) is included. In this example, an additional virtual object will match one or more virtual disks containing the word \u201cosdisk\u201d:","<vglob>*osdisk*<\/vglob>","Standard regular expressions are preferably used to match against the VM name and files within the VM. These regular expressions are simple enough to match any file within any VM that contains the word \u201cosdisk\u201d. For example, if a VM set is exported through \/nfs\/my_vmset, the virtual object will match against each of the following virtual disks:",{"@attributes":{"id":"p-0074","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","\/nfs\/my_vmset\/windows_xp\/osdisk1.vmdk"]},{"entry":[{},{},"\/nfs\/my_vmset\/windows_xp\/osdisk2.vmdk"]},{"entry":[{},{},"\/nfs\/my_vmset\/rh_linux\/linux_osdisk.vmdk"]},{"entry":[{},{},"\/nfs\/my_vmset\/rh_linux\/root_osdisk.vmdk"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Regular expressions allow CAFS to match against any naming scheme used by any virtualization platform. VM administrators preferably use a meaningful naming scheme within VM templates to simplify VM administration and ensure that VM disks are recognizable.","CAFS Redirector Links. Storage pools managed by CAFS  are separate physical file systems  that are created with the desired storage characteristics and performance. During system initialization, CAFS driver  builds a list of available storage pools so that it can map existing files to their correct location and can store newly created files in the storage pool that policy dictates. An exemplary list for three different storage pools (sp_flat, sp_raid, and sp_raid) is shown in . In this embodiment, storage pool file systems (e.g., symbolically named RAIDS) can be found under the \/storage_pools directory as shown on the right hand side of the figure. Whenever CAFS is running, storage pool mapper  maintains a link to each storage pool file system.","Storage pool mapper  also maintains a mapping between files seen by hypervisor  and actual files stored within each storage pool . Hypervisor , however, is unaware of how files are stored and of the mapping between what the hypervisor sees and the actual storage location of the files. Hypervisor  accesses a VM file  by going through a redirector file created by CAFS driver . As an example, to store file \/hcs\/nfs\/vm_set\/win_xp\/winxp.vmx to a VM, hypervisor  sends a CREATE request which is intercepted by CAFS driver .","If the CREATE request for a specific VM file  matches a rule in the VM policy (obtained from external key and policy server ) that requires a specific storage pool, storage management module  informs CAFS driver  that the VM has been authenticated, that a VM file  can be created, and where the VM file  should reside. CAFS driver  then creates the VM file  in the file system namespace of the storage pool (\/storage_pools\/sp_raid\/vm_set\/win_xp\/winxp.vmx) and creates the redirector file (\/cafs\/vm_set\/win_xp\/winxap.vmx##sp_raid).","Each VM set contains directories for each VM within its correct storage pool along with a list of redirector files. When hypervisor  wants to obtain the list of files in a VM, hypervisor  issues an NFS_READDIR( ) operation which translates to a call into CAFS driver  through vnode operation cafs_readdir( ).","The cafs_readdir( ) vnode operation performs the mapping between what a virtualization server expects and how the files are actually stored on disk. This mapping layer has a number of advantages including the ability to move a file dynamically within the VM from one storage pool to another by modifying only the redirector link for the move to take effect. In the example above, the file \/hcs\/nfs\/vm_set\/win_xp\/winxp.vmx is contained within the sp_raid storage pool. To move this file to the sp_raid storage pool, the file is copied from \/storage_pools\/sp_raid to \/storage_pools sp_raid\/, and the redirector link is changed to \/cafs\/vm_set\/win_xp\/winxp.vmx##sp_raid. Hypervisor  remains unaware of these changes, and of the original or modified location of the VM file .","NFS\/VNODE triggers. CAFS is able to determine actions being taken by any supported hypervisor. For example, in response to an NFS request to access a \/mnt directory, a file handle for the \/mnt directory is returned and two operations are performed:\n\n","Because CAFS sits at the VFS\/vnode layer, the NFS operations described above map to vnode operations at the file system layer. For example, NFSPROC_MKDIR will result in a call to the cafs_mkdir( ) vnode operation. CAPS driver  then responds with an up-call to storage management module  to determine what to do with the call based on the VM set policy.","Referring again to , when an NFS operation is received, this triggers CAPS driver  to invoke storage management module  by placing a request in CAFS portal  request queue. Once the request is received by storage management module , the request is matched to an appropriate VM set policy and associated policy descriptor. As an example, a request may be made from ESX Server 10.2.45.67 to create a directory called windows_vm under the path \/nfs\/my_vmset. This request corresponds to the first step in creation of a new VM. CAFS driver  first determines whether this server has the right privileges and is in the right time window to be able to create this VM. Assuming the server is authenticated, calls to create files within the new directory are matched with the virtual objects list to determine the storage pool needed for the file and whether the file should be encrypted.","Encryption mechanism. CAFS implements encryption on selected portions of the VM using industry standard encryption algorithms such as, without limitation, the Advanced Encryption Standard (AES, e.g., AES-128 or AES-256). The VM components to encrypt are determined by the policy descriptor which in turn references symmetric encryption keys that are used to perform the encryption\/decryption.","VM files are encrypted or decrypted by intercepting read\/write operations (e.g., VOP_READ( ) VOP_STRATEGY( ) and VOP_WRITE( ) at the vnode layer. Encryption or decryption of VM files is performed using an encryption framework, preferably BSD Open Cryptographic Framework (OCF) which also allows the addition of hardware cryptographic support.","CAFS preferably uses Advanced Encryption Standard (AES)-128 or AES-256 encryption with a cipher-block chaining (CBC) mode. CBC generates a cipher text (encrypted data) for a given plaintext (unencrypted data) by XORing the AES-generated cipher text with a previous AES-sized block (16 bytes). This, however, forces the OCF to read the prior block whenever a read\/write request is issued in order to retrieve the previous 16 bytes to use as the initialization vector (IV). The only exception to this process is for the first 16 bytes (i.e., when the file pointer is set to the beginning of the file), in which case a well-known IV can be used. Using this encryption mode negatively impacts performance because so much data need to be read. CAFS attenuates this impact on performance by using an encrypted salt-sector initialization vector (ESSIV) method (e.g., preferably ESSIV 2010) which generates an initial IV for each sector-sized (512 byte) read\/write operation by combining a sector number with a hash of the encryption key used for the file. The ESSIV method is known in the art, as described at http:\/\/en.wikipedia.org\/wiki\/Disk_encryption_theory, incorporated by reference herein.","Authentication. During the bootstrap process, CAFS driver  starts up, and secure communications module  authenticates the virtualization server with key and policy server . This authentication allows CAFS driver  to make subsequent calls to retrieve policy descriptors and encryption keys as VM sets and VMs are being accessed. Specifically, when a subsequent attempt is made to access a VM, CAFS driver  determines whether the request is coming from a previously authorized virtualization server. If so, CAFS driver  obtains from encryption\/key management module  the appropriate VM set policy and encryption keys so that CAFS driver  can decrypt data appropriately (for VMs that already exist) or can know how to store VMs that are being created. Virtualization servers that are not authorized are prevented from accessing VM sets using standard NFS export mechanisms. CAFS can also prevent access to VM sets from authenticated servers during specified time windows.","Access to a particular VM set or VM is determined in part by pathname and NFS operations (NFSPROC_LOOKUP, NFSPROC_CREATE, etc.) and in part by the way that the polices are defined by the administrator and associated with either a mount point or a position with a specific pathname. Specifically, CAFS responds to NFS (vnode) operations that in turn reference VM sets or the VMs contained within. For example:\n\n",{"@attributes":{"id":"p-0089","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/nfs\/vmset-A\/VM-1","VM set 1"]},{"entry":[{},"\/nfs\/vmset-A\/VM-2","VM set 2"]},{"entry":[{},"\/nfs\/vmset-B\/VM-1","VM set 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":{"@attributes":{"id":"ul0026-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":["\u2003In this example, two VM sets reside under the same mount point (\/nfs). As part of policy definition, an administrator designates a position within the pathname where the policy resides. The administrator can specify that a mount point itself is governed by a VM set policy or that multiple VM set polices reside under the same mount point.","Other NFS operations within a specific VM or VM set: Because NFS is stateless, (i.e., there is no NFSPROC_CLOSE operation), CAFS driver  does not know when access to a VM ceases (other than by recording a lack of access over a specific period of time). Thus, any operation within a specific mount point outside of a window of access time is denied."]}}}},"Auditing. Because the operating system under which CAFS runs is preferably securely locked down to prevent tampering, system information is not available using traditional means such as logging into the machine and running diagnostic utilities. Instead, when a VM is accessed, CAFS tracks and generates audit records about VM and VM set usage by the organization or service provider. These records provide information that CSPs use to provide per-customer billing. Specifically, CAPS tracks logging\/auditing information useful in both data centers and within cloud computing environments, including, without limitation: (1) access information (i.e., information about who is accessing which VM set and which VM within the set, when the access occurs, the type of access (lookup, read or write), and the name of the server seeking access); (2) system information (e.g., diagnostic information about the machine environment in which CAFS is running which can be used by administrators to determine faults within the VMs and VM sets); and (3) capacity planning information (e.g., how much storage is available, which VM sets are occupying how much space, and when disk space crosses a predefined thresholds (e.g., 80% full) so CSPs can easily charge their customers based on expected and actual storage use. CAFS has the ability to generate both alerts and log messages. The location to which these alerts and log messages are to be sent is contained within the VM set policy.","Secure Storage of VM files. An exemplary flow chart detailing one embodiment of a method to securely store VM files  is presented in . In step , CAFS driver  intercepts a command from hypervisor  to store one or more VM file . CAFS driver  communicates that request through CAFS portal  to storage management module , which in turn requests secure communications module  to retrieve policies and encryption keys for the VM set containing the one or more VM file .","In step , secure communications module  communicates with external key and policy server  to fetch the policy descriptor containing one or more policy for VM file(s) .","In step , secure communication module  communicates with encryption\/key management module  to determine whether one or more encryption key is needed. If any encryption key is needed, secure communications module  communicates with external key and policy server  to fetch the necessary encryption key(s) for the VM file(s)  to be stored.","In step , encryption\/key management module  obtains (from secure communication module ) the encryption key(s) for the VM file(s)  to be stored, and then transfers the encryption key(s) to CAFS driver . CAFS driver  encrypts (at least in part) the VM file(s) using the encryption key(s) obtained from encryption\/key management module .","In step , storage management module  obtains the policy descriptor from secure communication module . Storage management module  informs CAFS driver  how to store the VM file(s)  based on the policy descriptor obtained from storage management module .","In step , CAFS driver  transfers the at least partially encrypted VM file(s)  through the physical file system to one or more storage pool  based on the policies contained within the policy descriptor.","Access to securely stored VM files. An exemplary flow chart detailing one embodiment of a method to access securely stored VM files  is presented in . In step , CAFS driver  intercepts a command from hypervisor  to access one or more at least partially encrypted VM file  securely stored in one or more storage pool . CAFS driver  communicates that request through CAFS portal  to storage management module . Storage management module  determines whether the policy descriptor for the encrypted VM file(s)  is stored locally. If the policy descriptor is not stored locally, storage management module  requests secure communications module  to retrieve policies and any necessary encryption key(s) for the VM set containing the encrypted VM file(s) . If the policy descriptor is stored locally, storage management module  requests secure communications module  to retrieve the encryption key(s) for the VM set containing the encrypted VM file(s) .","In step , secure communications module  communicates with external key and policy server  to fetch, if necessary, the policy descriptor containing one or more policy for the encrypted VM file(s) . Storage management module  obtains the policy descriptor, if necessary, from secure communications module , and informs CAFS driver  of policies governing access to the encrypted VM file(s) .","In step , secure communication module  communicates with external key and policy server  to fetch the encryption key(s) for the encrypted VM file(s) . Secure communications module  conveys the encryption key(s) to encryption\/key management module .","In step , CAFS driver  accesses (through the physical file system) the encrypted VM file(s)  stored in one or more storage pool. CAFS' access is based on one or more policy contained within the policy descriptor obtained from storage management module .","In step , CAFS driver  decrypts the accessed encrypted VM file(s)  using the encryption key(s) obtained from encryption\/key management module .","In step , CAFS driver  transfers the decrypted VM file(s)  to hypervisor .","It is to be understood that embodiments of the system and method herein can all be implemented in software stored in a computer readable storage medium for access as needed to run such software on the appropriate processing hardware of the computing system.","It is to be understood that the examples given are for illustrative purposes only and may be extended to other implementations and embodiments with different conventions and techniques. For example, although FreeBSD is used as an exemplary operating system for descriptive purposes throughout the specification, there is no intent to limit the disclosure to that operating system, or to any embodiment(s) disclosed herein. On the contrary, the intent is to cover all alternatives, modifications, and equivalents apparent to those familiar with the art.","In the foregoing specification, the invention is described with reference to specific embodiments thereof, but those skilled in the art will recognize that the invention is not limited thereto. Various features and aspects of the above-described invention may be used individually or jointly. Further, the invention can be utilized in any number of environments and applications beyond those described herein without departing from the broader spirit and scope of the specification. The specification and drawings are, accordingly, to be regarded as illustrative rather than restrictive. It will be recognized that the terms \u201ccomprising,\u201d \u201cincluding,\u201d and \u201chaving,\u201d as used herein, are specifically intended to be read as open-ended terms of art."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
