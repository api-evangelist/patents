---
title: System for replaying and synchronizing patterns on a client and external data source devices
abstract: A system, method and computer program product provide functionality via a non-natively coded application on a client device. Initially, user input is received on a device. A pattern is replayed on the device. Navigation of the pattern is managed. Data is retrieved based on the user input utilizing at least one connector, as specified in the pattern. Finally, the retrieved data is output. A system, method and computer program product are also provided for creating an application for a client device. The functionality of the desired application on a device is provided by selecting functional computer code that processes data. The functional computer code does not include coding to the native API's of the device. One or more connectors are selected and programmed to interface with programs on the device for retrieving data for processing. One or more output nodes are generated for outputting the processed data from the device. The functional computer code, connectors, and output nodes are stored in a device-resident pattern for installation on the device. The retrieved data is processed by the functional computer code upon replaying of the pattern for providing the functionality.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07574711&OS=07574711&RS=07574711
owner: NVIDIA International, Inc.
number: 07574711
owner_city: St. Michael
owner_country: BB
publication_date: 20020514
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application claims priority from U.S. Provisional Patent Application Ser. No. 60\/341,340 entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR CREATING DISCONNECTED MOBILE APPLICATIONS, filed Dec. 14, 2001; U.S. Provisional Patent Application Ser. No. 60\/283,781 entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR THE RECORDING AND PLAYBACK OF TRANSACTION MACROS, filed Apr. 12, 2001; U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR THE RECORDING AND PLAYBACK OF TRANSACTION MACROS, filed non-provisionally Aug. 28, 2001 under Ser. No. 09\/942,047; U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PATTERN REPLAY USING STATE RECOGNITION, filed non-provisionally Aug. 28, 2001 under Ser. No. 09\/942,080 (now abandoned); and U.S. Patent Application entitled INTERFACE FOR MOBILIZING CONTENT AND TRANSACTIONS ON MULTIPLE CLASSES OF DEVICES, filed non-provisionally Sep. 14, 2001 under Ser. No. 09\/953,372 (now U.S. Pat. No. 7,185,286); each of which is assigned to common assignee Clickmarks, Inc., and herein incorporated by reference.","The present invention relates to computer-related transactions, and more particularly to quickly creating applications for a disconnected device without requiring coding to native API's.","An application program interface (API\u2014and sometimes spelled application programming interface) is the specific method prescribed by a computer operating system or by an application program by which a programmer writing an application program can make requests of the operating system or another application. An API can be contrasted with a graphical user interface or a command interface (both of which are direct user interfaces) as interfaces to an operating system or a program.","Each particular operating system has its own specific set of API's. Every time a developer wishes to create a new application, the developer must code to the API's of the operating system and any applications with which the new application will interact. For example, a new application for use on a system running MICROSOFT\u00ae Windows must code to the Windows API's. Thus, the developer must be well-versed in coding for the particular operating system.","However, even a seasoned programmer may occasionally make a mistake when coding to particular API's. An error in coding to even one API may cause the new application to malfunction or not even run at all. Thus, great care must be exercised when coding to the API's of the particular operating system. This takes a great amount of time. If there is an error, days and even weeks can be spent debugging the code.","The problem is compounded when a developer wishes to create a new application that interacts with another application that has its own API's. In this scenario, the developer must be versed in both types of API's: the operating system-specific API's and the application-specific API's. If the new application does not run, the developer may have to spend precious time testing the coding to both types of API's.","What is needed is a way to create applications without requiring coding to native API's, thereby significantly reducing development time from days to a few hours.","A system, method and computer program product provide functionality via a non-natively coded application on a client device. The application is represented as a graph of functional nodes (called states) that are transitioned as the user interacts with the application. This graph of states is called a pattern. States may encode e.g. a specific interaction with another application such as a database application, application logic in the form of scripting codes using a scripting language such as JavaScript (ECMAScript) or Visual Basic, user interactions such as displaying information to the user, or soliciting input from the user. To interact with the application, the user launches an interpreter, called the Pattern Replay Engine (PRE) which has been custom coded for each supported device operating system. The PRE manages the navigation of the pattern based on actions taken by the user, and application logic encoded in the pattern. Because the pattern is interpreted on the device by a device specific PRE, the pattern does not need to specify its actions or application logic in a device specific manner. Instead, the application developer can focus entirely on designing the application logic and user interface without concerning himself with the peculiar APIs of the target devices on which the application would be replayed.","States in the pattern are interpreted by means of a connector, which is a system module that interprets a specific type of state. For example, a database connector is used to interpret instructions provided in a database state, and to execute those instructions against a database engine.","In one embodiment, a synchronization pattern can be replayed for synchronizing data between the device and an external data source such as a server via some type of physical and\/or wireless connection. Data synchronization is the act of transferring device resident data to e.g. a server database, and conversely, server resident data to the device. Data synchronization is an integral part of disconnected applications, in the case where the user may modifies data on the device while not connected to the network. These updates may need to be applied to a server resident database, and vice versa. The present invention allows the application developer to specify the synchronization logic in much the same way as the application itself is specified. Specifically, the synchronization logic is also represented as a pattern. However, this pattern is replayed at the server, when the device connects to the server and requests a synchronization. In particular this allows the application developer to create a pattern that retrieves data from applications through their user interface, using the concept of Interaction Level Programming (ILP). This may include data retrieved from a website, a windows application, a database, etc.","During synchronization additional data used by the system is synchronized to the device. Data that can be synchronized includes user profile information, electronic mail, another pattern including an updated pattern, etc. Preferably, the pattern is periodically replayed for retrieving data for later synchronization to the client device.","In another embodiment, user interface screens are included in the pattern. These screens are preferably stored as templates, to be filled in when the pattern is replayed, with specific data, either provided by the user, retrieved from a data source, and\/or computed by the application. The screens may include UI elements such as buttons, input fields, select controls, etc. which are presented to the user for interacting with the application. Input entered by the user is available to the application as variables which can be used to update data in the database, and also can be displayed on subsequent screens.","As an option, pattern replay can be made dependent upon user profile information such as whether the user is authorized to run the pattern, how the pattern functions for a particular user, etc. Note that multiple user profiles can be stored on the device, allowing the device to be shared by multiple users. Further, the connector can interface with a program resident on the device such as a database, an electronic mail program, etc.; a network data site; a remote application (i.e., an application running on a machine external to the device); etc.","A system, method and computer program product are also provided for creating an application for a client device. The functionality of the desired application on a device is provided by selecting functional computer code that processes data. The functional computer code does not include coding to the native API's of the device. One or more connectors are selected and programmed to interface with programs on the device for retrieving data for processing. One or more output nodes are generated for outputting the processed data from the device. The functional computer code, connectors, and output nodes are stored in a device-resident pattern for installation on the device. The retrieved data is processed by the functional computer code upon replaying of the pattern for providing the functionality. In this way, a designer can quickly create an application for any device without having to worry about conforming to the requirements of the API's. The process of creating the application is preferably carried out in a visual manner, using a development environment commonly called a Studio (reference Studio patent).","In one embodiment, a connector for interfacing with a local data source is installed on the device. Such a local data source can be a database, file system, etc. Preferably, the user interface screens of the application are transcoded for display on the target device. This can be done at design time if the target device type is known. Thus, user interface screens stored in the pattern are ready for display, except for variable references in the output pages, which can be resolved during replay of the pattern. The user interface screens may be represented using a markup language such a HTML, XHTML, WML or other markup languages that could be used for this purpose. Alternatively, the user interface screens may be represented using device specific compiled computer code generated by the Studio. Compiled code may include e.g. Java byte codes, or processor specific binary machine codes.","Another method for creating an application for a client device is also provided. A device-resident pattern is created for installation on a client device. Again, the pattern is not coded to native application program interfaces of the client device. Rather, the pattern uses connectors that interface with existing programs and interfaces on the device, thereby circumventing the need for coding with native API's. The device-resident pattern provides functionality when replayed on the client device. The device-resident pattern is transferred to the client device, where it is replayed to provide the functionality. As an option, a synchronization pattern can be generated for managing a data communication between the client device and an external data source. The synchronization pattern can be used to e.g. retrieve data to be stored on the client device during synchronization.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 1","b":["100","102","104","102","104"]},"For example, a transaction, in one embodiment, may refer to: information submitted by the user, actions taken by the user, actions taken by a system enabling the access of the user to the data, actions taken by the data to retrieve\/modify content, results sent back to the user, and\/or any combination or portion of the foregoing entities.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","202"]},"In one embodiment of the present invention, the transaction pattern may include a record of: information submitted by a user, actions taken by the user, actions taken by a system to generate results, and results sent to the user. As an option, the transaction pattern may include a record of actions taken by the system which enable access of the user to data, and actions enabled by the data to retrieve content. Storage in accordance with operation  may take any form with sufficient identification and description of any required step in the transaction process.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 2A","FIG. 2"],"b":["220","202"]},"During use of the present invention, such transaction pattern may be retrieved from memory when desired in operation . Thereafter, the transaction pattern is executed to carry out the transaction in an automated manner. Note operation . An execution, or playback, in accordance with operation  may include the invocation of a stored transaction pattern.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 2B","FIG. 2"],"b":["230","206"]},"A transaction pattern for any transaction need only be recorded once by anyone with sufficient system access privilege. Once recorded, any user may conduct that transaction, any number of times, by the invocation of the recorded transaction pattern, or \u201ctransaction macro.\u201d","Since a transaction macro can be stored in any fashion and invoked, directly or indirectly, by any agent (human or automated), it enables the completion of the transaction it describes in any fashion from any device.","System Architecture",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 3","FIG. 2"],"b":["200","310","312"]},"The workstation shown in  includes a Random Access Memory (RAM) , Read Only Memory (ROM) , an I\/O adapter  for connecting peripheral devices such as disk storage units  to the bus , a user interface adapter  for connecting a keyboard , a mouse , a speaker , a microphone , and\/or other user interface devices such as a touch screen (not shown) to the bus , communication adapter  for connecting the workstation to a communication network  (e.g., a data processing network) and a display adapter  for connecting the bus  to a display device .","The workstation typically has resident thereon an operating system such as the Microsoft Windows NT or Windows\/95 Operating System (OS), the IBM OS\/2 operating system, the MAC OS, or UNIX operating system. Those skilled in the art may appreciate that the present invention may also be implemented on platforms and operating systems other than those mentioned.","Applications","Following is a plurality of exemplary applications of the present invention. It should be noted that such examples are not exhaustive, and should not be construed as limiting.","Scenario I",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":"400"},"In this case, the transaction pattern includes: (i) required parameters submitted by the user (ii) the entire internal process of submission of these parameters to the database by the interface and (iii) the results returned by the database and presented to the user. Note .","Scenario II",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 5","b":"500"},"In this case, the transaction pattern consists of (i) the creation and actions associated with the forms presented in the web-interface with which the user submits information (ii) the information submitted by the user, in every form in every step of the e-commerce flow (iii) the internal process whereby the submitted information is sent to the servers and databases of the e-commerce site (iv) the navigation (automatic or user determined) of the user within the e-commerce process and (v) the results returned by the e-commerce site once the submitted information has been processed. Note .","Scenario III",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 6","b":"600"},"In this case, the transaction pattern consists of (i) the creation and the action associated with the forms presented in the web-interface with which the user submits information (ii) the information submitted by the user, in every form in every step of the login and account access process (iii) the internal process whereby the submitted information is sent to the servers and databases of the user's portfolio account site (iv) the navigation (automatic or user determined) of the user within the portfolio account and (v) all the content that the user desires in every step of his navigation within the portfolio account. Note .","In all of these scenarios, the user submits and retrieves different pieces of information in multiple steps. While it is possible to submit information in this fashion from a desktop computer, it becomes increasingly inconvenient once a user tries to do so through devices other than PC's where the entry of information is not as convenient. Therefore, a process whereby a query or a transaction can be completed and the resulting content sent to the user with a minimum amount of information input and navigation, is highly desirable.","The present invention thus allows any transaction to be automated through the concept of the recording and the playback of a \u201ctransaction macro.\u201d","Mobile Applications","The various embodiments described herein allow developers to quickly build a mobile application that runs on a device such as a disconnected device (not having a network connection all the time). Instead of coding to the native API's of the device, the developer builds a pattern, which is run on the device. Code that provides functionality upon its execution is stored in the pattern. Connectors interface with existing programs and interfaces on the device, thereby circumventing the need for coding to native API's.","The application is represented as a graph of functional nodes (called states) that are transitioned as the user interacts with the application. This graph of states is called a pattern. States may encode e.g. a specific interaction with another application such as a database application, application logic in the form of scripting codes using a scripting language such as JavaScript (ECMAScript) or Visual Basic, user interactions such as displaying information to the user, or soliciting input from the user. To interact with the application, the user launches an interpreter, called the Pattern Replay Engine (PRE) which has been custom coded for each supported device operating system. The PRE manages the navigation of the pattern based on actions taken by the user, and application logic encoded in the pattern. Because the pattern is interpreted on the device by a device specific PRE, the pattern does not need to specify its actions or application logic in a device specific manner. Instead, the application developer can focus entirely on designing the application logic and user interface without concerning himself with the peculiar APIs of the target devices on which the application would be replayed.","States in the pattern are interpreted by means of a connector, which is a system module that interprets a specific type of state. For example, a database connector is used to interpret instructions provided in a database state, and to execute those instructions against a database engine.","Disconnected operation is a user mode in which the user is operating an application on a client device that is not at the time connected to a network that would allow the application logic to reside on a server, and presentation elements to be served up to the device. In this mode, a significant portion of the application logic executes on the device itself, without requiring an active connection.","The various embodiments allow the application developer (designer) to create an application that consists of two closely related components:\n\n",{"@attributes":{"id":"p-0068","num":"0069"},"figref":"FIG. 7","b":["700","702","704","706"]},"Data synchronization is an integral part of disconnected applications, in the case where the user modifies data on the device while not connected to the network. These updates may need to be applied to a server resident database, and vice versa. The present invention allows the application developer to specify the synchronization logic in much the same way as the application itself is specified. Specifically, the synchronization logic is also represented as a pattern. However, this pattern is replayed at the server, when the device connects to the server and requests a synchronization. In particular this allows the application developer to create a pattern that retrieves data from applications through their user interface, using the concept of Interaction Level Programming (ILP), as described in U.S. Provisional Patent Application Ser. No. 60\/283,781 entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR THE RECORDING AND PLAYBACK OF TRANSACTION MACROS, filed Apr. 12, 2001 and from which priority is claimed. This may include data retrieved from a website, a windows application, a database, etc.","With continued reference to , in operation , the functional pattern is replayed on the device. The pattern includes a collection of states, each state including logic for interacting with another program. Navigation of the pattern is managed in operation  based the user input and\/or application logic of the pattern. Data is retrieved from the other program in operation  based on the user input utilizing at least one connector, as specified in the pattern. In operation , the retrieved data is output.","The synchronization pattern is optional, as the application may or may not require it. There may be standalone applications that do not require a data synchronization component. One example is a calorie counting application, which can be used to keep track of how many calories are being consumed. In this example, the data entered by the user is not synchronized to the server. When the application is first synchronized to the device, a database of foods and calories for those foods is synchronized to the device and stored thereon. On the device the user enters what was eaten by picking from the list in the database, or entering custom data. The application calculates average daily caloric consumption, displays a graph, etc.","There may also be applications that only require simple synchronization of data. For example, the calorie counting program above may require that the foods database be synchronized back to the device whenever it is updated. However this would be a very simple synchronization: synchronize \u201cFoods\u201d table to device. A slightly more complicated synchronization Would be: synchronize \u201cFoods\u201d table updates to device, and synchronize device updates to \u201cFoods\u201d table back to the server. Updates such as these may not necessarily require a pattern per se; static SQL statements indicating what to synchronize can be used.","A more complex example would be an application that requires extensive processing before, after or during synchronization of the data. For example, in the calorie application, the list of foods and their caloric values may be available through a web interface. In this case a synchronization pattern would use an XML connector to retrieve this data from the web site, and copy it into a database table. This is not a simple copy. JavaScript is used to pick apart the HTML, and format the data into a two-column table: food item and calories. Finally, this table is synchronized to the device. This would be a complex synchronization pattern, which would be run during every synchronization. The pattern could also check the system time, and only update the table from the website once a week, once a month, etc. to minimize processing.","The example above also illustrates how the XML connector can be used in disconnected applications.","A third type of pattern is a background, or cron, pattern. This is a pattern that runs periodically in the background, possibly fetching data from a website or other source, and populating database tables that are later synchronized to the device. Thus a cron pattern could be used in much the same way as a synchronization pattern described above, where the pattern runs periodically on a fixed schedule, rather than during synchronization itself. This may be a more efficient solution in some cases, especially if the data is shared among many users.","User Experience on the Device","This section briefly describes an exemplary user experience on the device when using a disconnected application created and deployed as described herein. This section makes use of the calorie counting application example introduced above.","There are at least two possible ways for the user to launch the calorie application:\n\n","A separate session may be maintained for each mobile application that is active.","When the user launches the mobile client as in option 1 above, they are first asked to be authenticated, such as by entering a user ID and\/or password. The user is then presented with a list of applications, some of which may already be active. If the user selects an active application, the last output screen presented by that application is output (displayed) and the user can continue interacting with the application from that point. If the user selects an application for which a session for that user does not exist yet, a new session is created, and the application starts replaying from the beginning.","When the user launches the application as in option 2 above, the mobile client application is launched immediately. If an active session exists for the application that was launched, the user immediately is taken to the last output presented by that application. If not, the user is asked to authenticate, and a new session is created.","The session can time out. Two exemplary session timeouts are:\n\n","Preferably, the security timeout is of shorter duration than the system timeout, unless no security is desired, in which case the security timeout is preferably set to the maximum possible value. Both parameters can be system-wide and set by the administrator. Values smaller than the system defaults can be set for applications that require extra security.","The security timeout can be checked whenever the session is accessed, and, as an option, can be reset only when the user successfully re-authenticates.","The system timeout is preferably checked on a regular basis by a background thread. If the device does not support background threads, then the timeout is checked whenever the mobile client runs.","Once an application is launched by the user, two ways for the session associated with that application to end are:\n\n","All critical user data can be persisted to a database during application replay and prior to session termination so that the data is saved upon termination of the session.","User interface screens can be included in the pattern. These screens are preferably stored as templates, to be filled in when the pattern is replayed, with specific data either provided by the user, retrieved from a data source, and\/or computed by the application. The screens may include UI elements such as buttons, input fields, select controls, etc. which are presented to the user for interacting with the application. Input entered by the user is available to the application as variables which can be used to update data in the database, and also can be displayed on subsequent screens.","The user interface screens may be represented using a markup language such a HTML, XHTML, WML or other markup languages that could be used for this purpose. Alternatively, the user interface screens may be represented using device specific compiled computer code generated by the Studio. Compiled code may include e.g. Java byte codes, or processor specific binary machine codes.","Creation of Disconnected Applications",{"@attributes":{"id":"p-0089","num":"0096"},"figref":"FIG. 8","b":["800","802","804","806","808"]},"Note that the synchronization pattern does not necessarily need to be transferred to the client device. Rather, it can be stored and replayed on a server to which the device connects during synchronization, for example.",{"@attributes":{"id":"p-0091","num":"0098"},"figref":"FIG. 9","b":["900","902","904","906"]},"As shown in , one or more output nodes are generated in operation  for outputting the processed data from the device. The output nodes of the pattern are transcoded in operation  for specifying a format of output on the device. This can be done at design time if the device type is known. Thus, output pages stored in the pattern are ready for display, except for variable references in the output pages. Preferably, variable references in the output nodes are resolved during replay of the pattern.","In operation , the functional computer code, connectors, and output nodes are stored in a device-resident pattern for installation on the device. The retrieved data is processed by the functional computer code upon replaying of the pattern for providing the functionality. In this way, a designer can quickly create an application for any device without having to worry about conforming to the requirements of the API's. As an option, a synchronization pattern can be generated for managing a data communication between the device and an external data source.","The process of creating the application is preferably carried out in a visual manner, using a development environment commonly called a Studio. Such a visual development environment is set forth in copending U.S. Patent Application entitled INTERFACE FOR MOBILIZING CONTENT AND TRANSACTIONS ON MULTIPLE CLASSES OF DEVICES, filed non-provisionally Sep. 14, 2001 under Ser. No. 09\/953,372 (now U.S. Pat. No. 7,185,286), and from which priority is claimed.","Functional Components","This section describes several functional components used to create and run the disconnected application.","The platform described in U.S. patent application Ser. No. 09\/942,080 (now abandoned) entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PATTERN REPLAY USING STATE RECOGNITION, from which priority is claimed, gives its users the ability to create (record) functional elements called patterns and use those elements (replay) in their custom applications. A pattern consists of a collection of states. State refers to the state of the application as defined by the user of the platform (the designer). States can be of different types. For example, an action that requires accessing the World Wide Web can be represented by an XML (or other type) state and an action that would require sending e-mail can be a part of an SMTP state. Each type of state has a connector, which is used to create the state definitions and operate on those states. Thus, an XML Connector Module (XCM) is the connector that aids in recording and replaying of XML states. A database connector is used to store and retrieve data from a database, but may or may not point to a next state. An XML Connector points to a next table. For example, the XML Connector in state A would instruct an agent to execute action X to access state C.","The information stored in a pattern may involve (i) the web or non-web interfaces presented to the user, (ii) the actions performed by the user or the system in the submission of the information, (iii) the parameters required to complete the transaction and submitted by the user, (iv) the automatic or manual navigation of the user within the transaction process, (v) processing of data to provide functionality, and\/or (vi) the content or results returned by the system or selected by the user.","Since a transaction pattern can be stored in any fashion and invoked, directly or indirectly, by any agent (human or automated), it enables the completion of the transaction it describes in any fashion from any device.","Mobile Connectors","The connectors interface with programs and interfaces resident on the device such as a database, an electronic mail program, etc. Connectors can also interface with programs and interfaces not resident on the device, such as a network data site, an electronic mail server, a remote application (i.e., an application running on a machine external to the device), etc.",{"@attributes":{"id":"p-0100","num":"0107"},"figref":"FIG. 10","b":"1000"},"Mobile Output Editor (MOE)","The Mobile Output Editor allows a user interface to be built for supported disconnected devices. The MOE allows the user to specify how data is output on the device. The MOE may be part of the Interactive Design Tool, described below.","Interactive Design Tool (IDT)","The Interactive Design Tool according to one embodiment allows a user to mobilize content and transactions on to multiple classes of devices. Some specific examples of the use of the IDT include:\n\n","The IDT graphical user interface provides several views according to one embodiment.","Workplace View","The first view is the Workplace view. Workplace views are the views within which the designer specifies the content and\/or transaction by example. For example, while mobilizing web content, the Web Workplace presents a browser view to the designer where the designer can indicate specific content by clicking on the areas of interest. The workplace records the usage pattern in the background. If the designer is mobilizing content stored in a database, the Database Workplace displays the appropriate database connection dialogs. Thus, the workplace is at all times, aware of the class of content\/transactions the designer is mobilizing and provides the appropriate view. The designer accesses content with multiple types of connectors. Connectors are functional blocks that allow access via various methods such as Web, database connectivity, FTP, etc.","Pattern View","The Pattern View is a view where the designer is able to manipulate the properties of the pattern. The Pattern View can also allow the designer to create a pattern manually and\/or add pattern elements directly. Several functions enabled by the Pattern View follow. Also, see  and related discussion for examples of pattern views.","The Pattern View allows formal pattern specification. Especially for web patterns, the pattern recorded in the Workplace represents only one possible interaction path. For example, the pattern may only represent a successful login into an online account. However, in actual usage, a user may also encounter an unsuccessful login. The Pattern View is used to visually specify such alternate paths in a flowchart format. Note that formal specification may be needed not just for the web connector. For example, some connectors may require error handling alternate interaction paths. See the section on Recording Alternate Paths, below, for further details.","The Pattern View also enables cross-connector flow, including design of complex interactions that span multiple types of connectors. For example, consider an interaction that obtains content like stock quotes from the web and inserts them into a database. The two pieces of this interaction (web and database) are individually recorded within the Workplace. However, the Pattern View is where the information flow across these pieces is coupled, or \u201cglued,\u201d together.","A pattern may be divided into multiple segments. For example, a pattern which aims to check on the price using a price comparison engine and then purchase the item, might be first divided up into two segments (one for the comparison and one for the purchase). The designer can eventually link the individual segments together while applying appropriate selection and transformation using scripts.","Device Editor View(s)","The Device Editor View(s) is a view where the designer is able to specify the view and interaction of the Client Devices as it relates to the pattern under design. For example, consider a pattern for retrieving bank account information. Within the Workplace and Pattern View, the designer is able to specify how to fetch the account information while navigating through multiple web screens. In the Device Editor, the designer may specify, for example, two screens: one in which the bank account number is entered and a second where the account balance is displayed. The Device Editor View is able to accommodate design for multiple classes of devices (e.g. phones, PDAs, etc.). Further, the Device Editor View(s) can function as the screen editors for specific clients, and can depict an accurate rendering of what the client device displays. See  and related description for an illustrative Device Editor View.","Script Editor View","Within the Script View, the designer is able to edit Javascript to manipulate the data flow within the pattern and also serve as gluing logic.","Utility Views","These are views used to enhance the user experience and provide useful information at various points. One Utility View is a Project Explorer. The Project Explorer displays all elements defined in the project thus far in a tree format. The main branches of the tree can include: Pattern (which contains all the states defined thus far in the Pattern View grouped into segments), Scripts (all scripts defined), and\/or Session Data.","Another Utility View is a Data Explorer. Using the Data Explorer, the designer is able to create and inspect the data variables. These variables can be created for a given pattern and\/or can be predefined and provided in a database of the mobilization platform. The variables can be of basic data types but also can belong to User Defined data types that can also be created via this View. These variables are available to be used in different views.","A further Utility View is a Pattern Gallery, which displays a list of available patterns that can be re-used. Various properties of the patterns (inputs, outputs, description, last modification date, etc.) can be shown.","Replay Mode (Testing and Debugging)","According to one embodiment, once a pattern has been recorded, the IDT can be used to replay the pattern. This is critical for testing and debugging the pattern. The designer will have the ability to set breakpoints, step through the pattern and set up variable watch windows to trace the execution of the pattern. Since the pattern is interpreted, it may be possible to stop at a breakpoint, change the pattern that is supposed to follow, and re-start execution of the pattern.","IDT Output","According to an embodiment, the IDT can generate XML descriptions of the pattern called Pattern XML (or other suitable name), the mobile views generated and the data transformations, etc. designed within the data view. In addition, the scripts written by the designer are also recorded. The IDT also stores the current project in a binary document (uses MFC object serialization mechanisms), which has the information of the Pattern defined so far. The project file can be called \u201cCompany Process Document\u201d (*.cpd files) or other suitable name.","Exemplary Pattern Recording Scenario","Pattern recording is done through the IDT interface that allows the user to quickly and easily record patterns. More particularly, a described in the following paragraphs, the IDT interface allows creation of an application for retrieving a variable from a database as well as creation of an interface for displaying the variable on a particular type and\/or model of device.",{"@attributes":{"id":"p-0117","num":"0128"},"figref":"FIG. 11","b":["1100","1102","1104","1106","1108","1110","1112"]},"The following example illustrates creation of an application for retrieving a customer identifier (ID) from a database and creating an interface for displaying the customer ID on a particular type and\/or model of device. As will be discussed in the example, the recording interface allows creation of different interfaces for different devices based on the capabilities of each.","Referring again to , a start screen  is displayed upon selection of the wizard button. The database server is selected from the drop down menu  and the Next button is selected. A database selection screen (not shown) is presented, which allows the user to select the desired database from which the desired data is to be retrieved.",{"@attributes":{"id":"p-0120","num":"0131"},"figref":"FIG. 12","b":"1200"},{"@attributes":{"id":"p-0121","num":"0132"},"figref":"FIG. 13","b":["1300","1302","1304"]},{"@attributes":{"id":"p-0122","num":"0133"},"figref":"FIG. 14","b":["1400","1402","1404","1406"]},{"@attributes":{"id":"p-0123","num":"0134"},"figref":"FIG. 15","b":["1500","1502","1504","1506"]},{"@attributes":{"id":"p-0124","num":"0135"},"figref":"FIG. 16","b":["1600","1602"]},{"@attributes":{"id":"p-0125","num":"0136"},"figref":"FIG. 17","b":["1100","1110","1702","1704","1706"]},{"@attributes":{"id":"p-0126","num":"0137"},"figref":"FIG. 18","b":["1802","1804","1806"]},{"@attributes":{"id":"p-0127","num":"0138"},"figref":"FIG. 19","b":["1900","1902","1904","1906","1908","1910"]},"For example, a database program may have a table having an output with five columns. On a PDA, perhaps only four columns can be displayed on the display. The output can be set to show only four variables. Similarly, if only two columns of the table can be displayed on a phone, the output can be set to show only two variables.","Pattern Compiler","This component takes the validated pattern produced in the IDT described above, and prepares it for deployment to a set of targeted disconnected devices. Specifically, the compiler:\n\n","Note that the pattern compiler is not required to modify the original pattern description. Instead it can add a new pattern description for each target device for which it runs, into the pattern file. This pattern description is stored in a binary representation as outlined above, and is re-created whenever the pattern is changed. This is done by invoking the compiler manually when the pattern is changed (though the IDT can alert the designer and suggest re-running the compiler if he\/she attempts to save a modified pattern).","Platform","The platform residing on the device includes the components shown in the table  of . The platform components are preferably implemented as distinct software modules (e.g. Windows DLLs) which work together to perform the necessary actions on behalf of the application. Depending on the memory constraints of the particular device, it may be preferable that the system does not consist of a single monolithic executable that has to be loaded into memory all at once. For example, connectors, which may not be used by an application at all, can be loaded and unloaded on demand.","Pattern Replay Engine (PRE) ","The Pattern Replay Engine (PRE) is the main controller for the application. The PRE loads and interprets the application, loading and unloading connectors on demand, and managing the state transitions.",{"@attributes":{"id":"p-0133","num":"0148"},"figref":"FIG. 21","b":["2102","2104","2106","2108","2110"]},"Based on the memory constraints on the device, an intelligent timeout mechanism can be used to cause the PRE to persist the session, unload all connectors, and go to \u201csleep\u201d. Ideally, the PRE remains poised for action from the user, and if no actions are detected in a certain amount of time, the PRE goes into sleep mode. Alternatively, the session can persist after each request, though may not be preferable because of performance limitations of the target devices.","The PRE is a request-driven component. The PRE's lifecycle begins when it receives a request from the Request Handler to execute a new pattern. The PRE loads the pattern and begins interpreting it. The pattern can be stored in an optimized and compressed format, such as binary XML. The PRE finds the pattern's start node, and loads the corresponding connector into memory (if it is not already loaded). It then invokes the connector to advance to the next state. This process of advancing to the next state continues until a state with an output node is encountered. In the meantime several states may be traversed, some requiring Javascript execution. Preferably, the Javascript engine is always loaded when the PRE is awake, particularly where the patterns use Javascript to encode the application logic.","When an output node is encountered, the Transcoder is invoked to render the output. The Transcoder is preferably always loaded while the PRE is awake, as it may be heavily used.","According to one embodiment, the PRE receives the request to make a transition from a particular state. Transitions from one state to another are made by executing actions. The PRE communicates with the appropriate connector (of the current state) to execute the current action in the request and get the new resulting state. Next, all script associated with the state is evaluated.","The PRE then calls the Transcoding Page Rendering Engine (TRE) to \u201cflush\u201d its output for display on the device. This means that any content, which has been queued for display in the TRE (while processing the request), is sent to a display screen of the device. Every state can potentially generate output to be displayed on the device, including internal states. This is a desirable feature as it means the designer can generate a status message, e.g. \u201cPlease wait while processing.\u201d etc. Finally, a script is called, which can initiate further state transitions from this script method if necessary.","More information about operation and functionality of the PRE is found in US patent application Ser. No. 09\/942,080 (now abandoned) entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PATTERN REPLAY USING STATE RECOGNITION, from which priority is claimed.","Transcoding Page Rendering Engine (TRE)  ()","The Transcoding Page Rendering Engine (TRE or Transcoder) is a tool used to render content on any display environment. The TRE performs two very important functions:\n\n","When the pattern is saved, the output nodes are compiled and transcoded for the target device. The output pages stored in the pattern that is interpreted on the device therefore are ready for display, except for possible variable references in the page, that have to be resolved prior to displaying the page. The TRE therefore has as one of its functions the resolution of variable references in the output page.",{"@attributes":{"id":"p-0142","num":"0159"},"figref":"FIG. 22","b":["2200","2202","2204","2206","2208","2210","2212"]},"Note that the TRE does not need to perform the initial steps of the transcoding process, because those steps have already been pre-computed at the server when the application was prepared for deployment (using the Pattern Compiler). These steps include:\n\n","Note that the compiler does not perform the final steps of the transcoding process, namely mark-up language translation and user agent module invocation. That is because these steps are not performed prior to variable substitution, which necessarily occurs at runtime.","Note that the TRE can process other types of output, such as audio, human language translation, character set rendering, style-sheet processing, etc.","More information about operation and functionality of the TRE is found in US Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PAGE RENDERING UTILIZING TRANSCODING, filed non-provisionally Aug. 28, 2001 under Ser. No. 09\/942,051 (now abandoned) and assigned to common assignee Clickmarks, Inc., and which is herein incorporated by reference.","User Manager (UM)  ()","The User Manager (UM) manages user profile and privilege information. When the device is synchronized with the server, the current user's profile is also synchronized to the device. The user can be allowed to update the profile from the device. The UM allows multiple user profiles to be resident on the device. In order to use the application, the user may be required to login with his or her username and password on the device so that the UM can unlock that user's profile. Thus, pattern replay can be made dependent upon user profile information such as whether the user is authorized to run the pattern, how the pattern functions for a particular user, etc.","Content Manager (CME) ","The CME manages content identification, retrieval and manipulation.","Mobile PORE & POM","The PORE implements the persistent object repository, using the POM. One feature is object timeout, which is used by the session manager.","Request Handler (RH) ","The RH manages requests from the user, routing them to the appropriate system component, such as the PRE. The RH accepts the following illustrative request types:\n\n","Note that these two request types can be combined in a single request to the request handler, in which case the request handler will first authenticate the user using the UM, and then invoke the PRE.","Mobile Session Manager (SM) ","The SM maintains the session state persistently on the device while the user is logged-on. Session security and system timeout settings are honored by the SM to protect the user's session data. As on the server, the session is used to store the pattern state.","Mobile Database (DB) Connector ","The DB Connector is invoked by the PRE to handle database operations.","Mobile SMTP Connector ","The SMTP Connector is invoked by the PRE to handle SMTP operations. The SMTP connector provides the designer the ability to create a template to send out emails. The message is placed in the local database on the device, and synchronized to the server during device synchronization. During synchronization, the server immediately sends out the message as soon as it is copied from the device. Alternatively, the device's outbox can be used.","Web Server ","The application server is resident on the device and is capable of responding to basic HTTP requests, including a mechanism for invoking server plugins similar to CGI or Servlet mechanism. An HTTP server can be provided which can accept and respond to HTTP requests coming from the browser on the device itself. Specifically, the server may accept requests for serving up static HTML files, as well as invoking the request handler using the CGI standard. Alternatively the Servlet API can be used, but is far more complex to implement as a Servlet container implementation would be required. An HTTP 1.0 or 1.1 compliant server may be used, for example.","Web Browser","Any HTML\/XHTML\/WML or other mark-up based browser can be used to render the application UI and accept user input. The browser is capable of connecting to the application server described above.","Database Server","An SQL compliant database server resident on the device is used to store persistent platform and application data.","Synchronization","Several modules can be provided that integrate with a synchronization server for synchronizing the applications and data to the device. These modules are:\n\n","In addition, an application deployment feature can be added, which allows the application to be deployed. This feature uploads the patterns and updates the necessary synchronization server configuration to synchronize the pattern, and the platform if necessary, to the device. The platform itself is managed as an application using a synchronization application management feature. The patterns installed on a particular device are managed using the platform's own administration tool.","According to one embodiment, pattern deployment for the two types of patterns includes the following steps.","Synchronization Pattern:",{"@attributes":{"id":"p-0161","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["1. Pattern is installed to a host server, in a special Synchronization patterns directory.","2. Synchronization server is updated to call the synchronization pattern during synchronization. This can be done through a plugin.\n\nDisconnected Pattern:\n","1. Pattern is installed to the host server, so it can be administered (assigned to different users\/groups).","2. If the pattern is assigned to a user, the pattern is synchronized to that user's device when the device is next synchronized. This can be done through a plugin, which checks with the pattern manager to see what patterns have been assigned to the current user, and then synchronizes any new or updated patterns to the device. This may be done using any suitable mechanism for synchronizing data files to the device, as will be appreciated by one skilled in the art."]}}}},"Since the patterns are files, they can be read directly through the file system by the Sync server during synchronization. In other words, only a single copy of the file may be needed, which is shared by the host platform server and the synchronization server.","Note that a synchronization client may be installed to the device, and may be installed as a plugin, freestanding application, etc. Also, note that user authentication may be required prior to synchronization.","Platform Sync","This module synchronizes any global platform settings that are needed to run the platform on the device. These settings are updated to the device during each synchronization session.","This module also synchronizes the platform itself to the device, when the device is first synchronized, or whenever the platform is updated. This is most likely done using a synchronization mechanism for deploying applications to the device.","User Profile, Email and Pattern synchronization configuration for the device is also performed when the platform is first synchronized to the device.","User Profile Sync","This module synchronizes all user profiles that are already on the device to the device. In addition, if the current user (the user may be required to authenticate during synchronization) is not on the device, that profile is synchronized as well. User profiles can automatically be removed from the device by the system after a certain period of not being used.","This implies that multiple users can use the device and the applications on the device. However, different users may have different sets of patterns assigned to them. Thus, each user is shown only his or her patterns (associated with the user via short-cuts or filename extension mechanisms).","Verification that the user has permission to replay the pattern may be required before replay is allowed. This requires that the user authenticates prior to starting the replay of any pattern. While the session security timeout period hasn't expired, the session can be used. For example, the user authenticates and starts replaying pattern A. After several interactions, the user turns off the device. Later, the user turns the device back on and launches the Disconnected platform application. The user now sees the last displayed output again, and can continue replaying from there. If the session security timeout has expired, the user can be asked to login again before they can continue. If the session has expired, the user may be asked to login again, and the pattern may start from the beginning.","Email Sync","This module sends out any messages stored in the outbox area of the device resident database. Note that the platform may provide its own outbox for holding messages sent through the SMTP connector. This outbox is synchronized to the server, and the messages are sent through an SMTP server. The platform may also use the device native outbox (e.g. Pocket Outlook).","Pattern Sync","This module is invoked whenever a pattern is being synchronized. It synchronizes any data produced\/changed by the pattern from the device to the server, and vice versa. Which data to synchronize is specified in the synchronization pattern.","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 13","FIG. 11"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 14","FIG. 11"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 15","FIG. 11"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 16","FIG. 11"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 17","FIG. 11"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 19","FIG. 11"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 22"}]},"DETDESC":[{},{}]}
