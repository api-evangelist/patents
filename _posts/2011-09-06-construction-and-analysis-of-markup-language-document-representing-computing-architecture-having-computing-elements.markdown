---
title: Construction and analysis of markup language document representing computing architecture having computing elements
abstract: A markup language document representing computing elements of a computing architecture, such as data storage elements of a data storage architecture, is constructed and analyzed. A first computing element contained by a second computing element is represented; a first tag of the document corresponding to the first computing element is nested within a second tag of the markup language document corresponding to the second computing element. A non-containing/contained relationship from the first computing element to a third computing element is also represented; a pointer tag of the document corresponding to the data access path is nested within the first tag, and references a third tag of the document corresponding to the third computing element. Get-pointer-node and get-child-node application programming interfaces for the markup language are called to traverse among containing/contained relationships. Pointer tags are followed to traverse among non-containing/contained relationships. Redundant attributes among the relationships can thus be detected.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08271458&OS=08271458&RS=08271458
owner: International Business Machines Corporation
number: 08271458
owner_city: Armonk
owner_country: US
publication_date: 20110906
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS","General Embodiments","Exemplary Embodiment"],"p":["The present patent application is a continuation of the patent application filed on May 3, 2009, assigned application Ser. No. 12\/434,658, and having the same title.","The present invention relates generally to computing architectures having computing elements, such as data storage architectures having data storage elements. The present invention relates particularly to constructing and analyzing a markup language document representing such a computing architecture like a data storage architecture.","Large-scale computing architectures made up of computing elements include data storage architecture made up of data storage elements. For example, a number of virtual machines running on a computing device may have virtual file systems with logical data paths, or logical storage volumes, that are implemented by a storage subsystem of the computing device. The storage subsystem of the computing device may itself include a pool of logical storage volumes. As such, the data path of each virtual machine may be implemented on one of the logical storage volumes of the pool of logical storage volumes within the storage subsystem.","The storage subsystem of the computing device may itself be implemented using a storage-array or a storage-area network (SAN), a network-attached storage (NAS), or another type of storage subsystem. In the case of a SAN, the SAN may include a number of logical disks having logical unit numbers (LUN's), where each logical disk is implemented by a physical volume like a physical storage device such as a hard disk drive. Each logical storage volume of the pool of logical storage volumes within the storage subsystem of the computing device may be implemented by multiple physical storage devices. The resulting data storage architecture is thus quite complex, with logical data paths mapping to logical storage volumes, which themselves are mapped to physical storage devices of logical disks of a SAN.","As such, visualizing and analyzing such a data storage architecture can be difficult. This means that undesired redundancies within the data storage architecture may escape detection, such that efficient utilization of data storage resources is not realized. For example, a redundant array of independent disks (RAID) scheme may be employed both in software on the storage subsystem of the computing device, as well as in hardware on the SAN. Such redundant utilization of RAID, however, means that the actual physical storage devices of the SAN are not efficiently employed in an optimal manner, and such inefficient utilization of the SRN's physical storage devices may not be able to be detected by administrators of this data storage architecture.","The present invention relates to constructing and analyzing a markup language document, such as an eXtended Markup Language (XML) document, representing a computing architecture having computing elements, such as a data storage architecture having data storage elements. A computer-readable medium of an embodiment of the invention has one or more computer programs stored thereon. Execution of the computer programs by one or more processors causes a method to be performed. The method is for representing data storage elements of a data storage architecture.","The method represents a first data storage element being contained by a second data storage element within a markup language document representing the data storage architecture. As such, a first tag of the markup language document and corresponding to the first data storage element is nested within a second tag of the markup language document and corresponding to the second data storage element. The method represents a data access path from the first data storage element to a third data storage element within the markup language document. As such, a pointer tag of the markup language document and corresponding to the data access path is nested within the first tag. The pointer tag references a third tag of the markup language document corresponding to the third data storage element. The method outputs the markup language document representing the data storage architecture.","A method of an embodiment of the invention is for analyzing a data storage architecture having data storage elements. The method is implemented by processor-executable instructions, which may be stored on a computer-readable medium, such as a recordable data storage medium, or another type of tangible computer-readable medium. Execution of the processor-executable instructions by one or more processors of one or more computing devices results in performance of the method.","The method receives a markup language document representing the data storage architecture. A first data storage element is represented by a first tag of the markup language document and is contained by a second data storage element represented by a second tag of the markup language document. The first tag is nested within the second tag within the markup language document. From the first data storage element, the method calls a get-parent-node application programming interface (API) for a markup language to traverse to the second data storage element, such that the markup language document is traversed from the first tag to the second tag.","A third data storage element is represented by a third tag of the markup language document and contains a fourth data storage element represented by a fourth tag of the markup language document. The fourth tag is nested within the first tag within the markup language document. From the third data storage element, the method calls a get-child-node API for the markup language to traverse to the fourth data storage element, such that the markup language document is traversed from the third tag to the fourth tag. While traversing the markup language document, the method analyzes attributes of traversed data storage elements.","Furthermore, in one embodiment, a fifth data storage element is represented by a fifth tag of the markup language document and has a data access path to a sixth data storage element represented by a sixth tag of the markup language document. The method follows a pointer tag of the markup language document nested within the fifth tag and corresponding to the data access path to traverse to the sixth data storage element. As such, the markup language document is traversed from the fifth tag to the sixth tag via the pointer tag.","A computing device of an embodiment of the invention is for representing computing elements of a computing architecture. The computing device includes one or more processors and a computer-readable medium. One or more computer programs are stored on the computer-readable medium and are executable by the processors to perform the following. A first computing element being contained by a second computing element is represented within a markup language document representing the computing architecture. As such, a first tag of the markup language document and corresponding to the first computing element is nested within a second tag of the markup language document and corresponding to the second computing element.","A data access path from the first computing element to a third computing element is also represented within the markup language document. As such, a pointer tag of the markup language document and corresponding to the data access path is nested within the first tag. The pointer tag references a third tag of the markup language document corresponding to the third computing element. The markup language document representing the computing architecture is output.","A computing device of another embodiment of the invention is for analyzing a computing architecture having computing elements. The computing device includes one or more processors and a computer-readable medium. One or more computer programs are stored on the computer-readable medium and are executable by the processors to perform the following. A markup language document representing the computing architecture is received. A first computing element is represented by a first tag of the markup language document and is contained by a second computing element represented by a second tag of the markup language document. The first tag is nested within the second tag within the markup language document. From the first computing element, a get-parent-node application API for a markup language is called to traverse to the second computing element, such that the markup language document is traversed from the first tag to the second tag.","A third computing element is represented by a third tag of the markup language document and contains a fourth computing element represented by a fourth tag of the markup language document. The fourth tag is nested within the first tag within the markup language document. From the third computing element, a get-child-node API for the markup language is called to traverse to the fourth computing element, such that the markup language document is traversed from the third tag to the fourth tag.","A fifth computing element is represented by a fifth tag of the markup language document and has a non-containing\/contained relationship to a sixth computing element represented by a sixth tag of the markup language document. From the fifth computing element, a pointer tag of the markup language document nested within the fifth tag and corresponding to the non-containing\/contained relationship is followed to traverse to the sixth computing element. As such, the markup language document is traversed from the fifth tag to the sixth tag via the pointer tag. While traversing the markup language document, attributes of traversed computing elements are analyzed.","Embodiments of the present invention realize certain advantages. In particular, the markup language document representing a computing architecture having computing elements, such as a data storage architecture having data storage elements, permits easier visualization and analysis of the architecture. Therefore, inefficiencies within a data storage architecture or other computing architecture can, for instance, be more easily detected, to ensure that the data storage elements or other computing elements are efficiently employed in an optimal manner. Still other advantages, aspects, and embodiments of the invention will become apparent by reading the detailed description that follows, and by referring to the accompanying drawings.","In the following detailed description of exemplary embodiments of the invention, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized, and logical, mechanical, and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims.","For instance, the detailed description is exemplarily described in relation to a data storage architecture having data storage elements. However, other embodiments of the present invention may be practiced in relation to other types of computing architectures having other types of computing elements. Examples of such other types of computing architecture elements include memory computing elements, such as cache memory computing elements, as well as network computing elements and virtualized computing elements, among other types of computing architecture elements.","In this section of the detailed description, general embodiments of the present invention are presented. Thereafter, in the next section of the detailed description, an illustrative exemplary embodiment is presented that informs to great degree how the general embodiments can be employed in the context of a real-world data storage architecture example. This section of the detailed description, by comparison, provides the basic techniques for constructing and analyzing a markup language document representing a data storage architecture having data storage elements, where such techniques are leveraged in the illustrative exemplary embodiment presented in the next section of the detailed description.","The inventors have developed a novel approach to construct a markup language document that represents a computing architecture having computing elements, such as a data storage architecture having data storage elements. Such a markup language document permits relatively easy visualization and analysis of the architecture that the markup language document represents. For example, with respect to a data storage architecture, a redundant array of independent disks (RAID) scheme may be employed both in software and in hardware, which but for the approach developed by the inventors may be difficult to detect. However, the approach developed by the inventors permits such redundant utilization of RAID to be easily detected by administrators of the data storage architecture, by analyzing and\/or visualizing the markup language document representing this architecture. As such, the data storage elements within the data storage architecture are used more efficiently, which means that organizations leveraging the inventors' novel approach to constructing a markup language document representing this architecture can realize cost and other savings.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","102"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["202","204","102","100","202","204","204","202","202","204","202","204","202","204"]},"The first and the second tags may represent the first and the second data storage elements within the markup language document as follows:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c2222\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c1111\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The utilization of nested tags within a markup language document to represent a containing\/contained relationship between corresponding data storage elements is innovative, insofar as nested tags within a markup language document are ordinarily employed to represent a hierarchical relationship between corresponding elements. By comparison, rather than using nested tags to represent a hierarchical relationship between corresponding elements, the inventors have instead novelly leveraged nested tags to instead represent a containing\/contained relationship between corresponding elements. Utilization of nested tags in such a novel way has heretofore not been accomplished, or recognized as being able to be accomplished.","Referring back to , a data access path from the first data storage element to a third data storage element is represented within the markup language document (). As such, a pointer tag corresponding to the data access path is nested within the first tag. Furthermore, the pointer tag references a third tag corresponding to the third data storage element. The data access path is more generally a non-contained\/containing relationship in one embodiment, in that the third data storage element is not contained by and does not contain the first data storage element.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["202","204","302","304","202","302","104","100","202","204","302","202"]},"In one example, the data storage element  may be a logical data path, such as \u201cc:\\\u201d, \u201ce:\\\u201d, and so on, of a host computing device like a virtual machine or a physical desktop or laptop computer, while the data storage element  may be the host computing device itself. In this example, the data storage element  may be a logical storage volume of a pool of logical storage volumes, where the logical storage volume in question implements the logical data path of the host computing device. As such, the data access path  represents the fact that the data storage element  implements the data storage element .","In a second example, the data storage element  may be a logical storage volume of a pool of logical storage volumes, while the data storage element  may be the pool of logical storage volumes. In this example, the data storage element  may be a physical storage volume of a logical storage disk, where the physical storage volume implements the logical storage volume. As such, the data access path  represents the fact that the data storage element  implements the data storage element .","The first, second, and third tags may represent the first, second, and third data storage elements, and the pointer tag may represent the data access path from the first element to the third element, within the markup language document as follows:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c2222\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c1111\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<chain type=\u201celement\u201d id = \u201c3333\u201d \/>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]},{"entry":[{},"<element id = \u201c3333\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The utilization of a pointer tag within a markup language document, to reference a tag that is not nested within a tag within which the pointer tag is itself nested is innovative, insofar as markup language documents are not ordinarily employed to represent such referential relationships. Rather, markup language documents are typically employed to represent hierarchical relationships among elements. By comparison, the inventors have instead novelly introduced pointer tags that represent non-hierarchical relationships, as well as non-contained\/containing relationships, among elements. Utilization of pointer tags has heretofore not been accomplished, or recognized as being able to be accomplished.","Referring back to , one or more fourth data storage elements contained over a number of fifth data storage elements are represented within the markup language document (), where a given fourth data storage element is contained by at least two selected fifth data storage elements. As such, the given fourth data storage element contained by the at least two selected fifth data storage elements is represented by a given tag that is nested within each of at least two selected tags. The at least two selected tags correspond to the at least two selected fifth data storage elements.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4A","b":["402","404","404","106","106","402","404","404","404","404","402"]},"The fourth tag may represent the fourth data storage element (e.g., the element ), and the fifth tags may represent the fifth data storage elements (e.g., the elements ), within the markup language as follows:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c5551\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c4444\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]},{"entry":[{},"<element id = \u201c5552\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c4444\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4B","FIG. 4A","FIG. 4A","FIG. 4B"],"b":["402","404","402","404","404","402","404","402","404"]},"The duplication of a tag representing a contained data storage element within a markup language document, such that the tag is nested within two or more other tags representing containing data storage elements is innovative. Markup languages like XML do not have any provisions for specifying that a data storage element is hierarchically lower than more than one other data storage element at the same level. Therefore, the inventors have had to invent an approach by which a data storage element that is contained by more than one other data storage element can be represented within a markup language. The devised solution, as represented by , is thus an elegant solution to this shortcoming of markup languages like XML.","Referring back to , once parts , , and  have been performed in relation to the data storage elements of a data storage architecture as appropriate, the method  outputs the markup language document that has been generated (). The markup language document thus represents the data storage architecture. Output can be achieved in a number of different ways. For example, the markup language document may be stored on a computer-readable medium, it may be transmitted to a different computing device than the computing device that performed parts , , and , and\/or the document may be displayed on a display device for viewing by a user.","A visualization of the data storage architecture can further be constructed from the markup language document and displayed on a display device for viewing by a user (). In one embodiment, existing visualization techniques may be employed in part . For example, visualization techniques used by storage resource management software, such as TotalStorage\u00ae Productivity Center software, available from International Business Machines, Inc., of Armonk, N.Y., can be employed. Finally, the data storage architecture can be analyzed and\/or optimized using the markup language document that has been constructed (), as is now described in more detail.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 5","FIG. 1"],"b":["500","502","100"]},"The markup language document is then received (). For example, the markup language document may be read as data from a computer-readable medium, such as a volatile memory or a non-volatile storage like a hard disk drive. The markup language document may also be received by receiving data over a network, such as the Internet, a local-area network (LAN), a wide-array network (WAN), a wireless network, a wired network, and\/or another type of network.","A get-parent-node application programming interface (API) is called to traverse the data storage architecture from a first data storage element to a second data storage element (). The first data storage element is represented by a first tag within the markup language document that is nested within a second tag representing the second data storage element within the markup language document. As such, the markup language document is traversed from the first tag to the second tag.","The get-parent-node API may be an API that is available and callable within markup language processing software, such as XML processing software. An example of XML processing software that exposes a get-parent-node API is the W3C Document Object Model (DOM), available on the Internet at www.w3.org. For example, a function such as element.getParentNode( ) available within the W3C DOM may be used as the get-parent-node API in part .","The traversal of the markup language document in part  of the method  is exemplarily described in relation to the data storage elements  and  of . The data storage element  is represented by a tag that is nested within a tag representing the data storage element . Therefore, the get-parent-node API can be called to traverse the markup language document from the tag representing the data storage element  to the tag representing the data storage element .","Referring back to , a get-child-node API is called to traverse the data storage architecture from a third data storage element to a fourth data storage element (). The third data storage element is represented by a third tag within the markup language document in which a fourth tag representing the fourth data storage element within the markup language document is nested. As such, the markup language document is traversed from the third tag to the fourth tag.","The get-child-node API may be an API that is available and callable within markup language processing software, such as XML processing software. For example, the W3C DOM exposes such a get-child-node API. Particularly, a function such as element.getChildNodes ( ) available within the W3C DOM may be used as the get-child-node API in part . It is noted that the get-child-node API, such as the function element.getChildNodes( ), typically returns all the elements that are contained by a given element. That is, the get-child-node API typically returns all the tags representing elements that are nested within a given tag representing a given element.","The traversal of the markup language document in part  of the method  is also exemplarily described in relation to the data storage elements  and  of . The data storage element  is represented by a tag within which a tag representing the data storage element  is nested. Therefore, the get-child-node API can be called to traverse the markup language document from the tag representing the data storage element  to the tag representing the data storage element .","Referring back to , a pointer tag representing a data access path can be followed within the markup language document to traverse the data storage architecture from a fifth data storage element to a sixth data storage element (). The fifth data storage element is represented by a fifth tag within the markup language document and the sixth data storage element is represented by a sixth tag within the markup language document. The fifth tag may not be nested within the sixth tag, and vice-versa. The pointer tag is nested within the fifth tag and references the sixth tag. As such, the markup language document is traversed from the fifth tag to the sixth tag via the pointer tag.","To perform part , in one embodiment, the child elements of the type chain are first delineated by using an appropriate API, such as the W3C DOM API element.getElementsbyTagName (Constants.CHAIN). Each chain element has two attributes, type and identifier. Therefore, a search is performed across the markup language hierarchy for elements of the type CHAIN, to locate the element having the matching identifier.","The traversal of the markup language document in part  of the method  is exemplarily described in relation to the data storage elements  and  of . The data storage element  is represented by a tag, as is the data storage element . The data storage element  is contained by the data storage element , such that the tag representing the element . The data access path  from the data storage element  to the data storage element  is represented by a pointer, or chain, tag that is nested within the tag representing the element  and that references the tag representing the element . Therefore, following this pointer tag results in traversal of the markup language document from the tag representing the data storage element  to the tag representing the data storage element .","For example, the data storage elements , , and  may be represented by tags within the markup language document as follows.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c0204\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<element id = \u201c0202\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<chain type=\u201celement\u201d id = \u201c0302\u201d \/>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},". . ."]},{"entry":[{},"<element id = \u201c0302\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/element>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["202","302","302","202","302","304","202","302"]},"Referring back to , while the markup language document is being traversed, attributes of the data storage elements that have been traversed, as delineated within the tags of the data storage elements, are analyzed (). Such attributes can include various redundant array of independent disk (RAID) attributes, for instance. For example, various data storage elements may have attributes indicating whether RAID is being performed, and how it is being performed, such as via striping (RAID), mirroring (RAID), parity (RAID), and so on.","Furthermore, based on whether a data storage element is a logical or virtual data storage element or a physical hardware data storage element, it can be determined whether RAID is being implemented on a software or a hardware level. That is, RAID being implemented in relation to logical or virtual data storage elements means that software RAID is being performed, whereas RAID being implemented in relation to physical hardware data storage elements means that hardware RAID is being performed. Finally, a visualization of the data storage architecture may be constructed and displayed using the markup language document (), as has been described in relation to part  of the method  of .","Thus, analyzing and optimizing a data storage architecture using a markup language document that represents this architecture can include acquiring the attributes of the data storage elements of the data storage architecture, by traversing the markup language document. It can be determined whether the attributes of the data storage elements implement redundant characteristics within the storage architecture. For example, such redundant characteristics can include the fact that RAID is being implemented both on a software level and on a hardware level. Where it has been determined that the attributes of the data storage elements implement such redundant characteristics, the data storage architecture can be modified to remove these redundant characteristics. For example, if RAID is being implemented both on a software level and on a hardware level, the data storage architecture may be modified so that RAID is implement just on a software level, or just on a hardware level, and not both on a software level and on a hardware level.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 6","FIGS. 1 and 5"],"b":["600","100","500","600","602","604","606","602","602","604","606"]},"The host computing device  is a data storage element that contains a data storage element that is specifically a data path , like \u201cc:\\\u201d, \u201ce:\\\u201d, and so on. As such, a tag representing the data path  within the markup language document is nested within the tag representing the host computing device . The storage subsystem  is a data storage element that contains a data storage element that is specifically a storage pool of logical storage volumes . As such, a tag representing the storage pool  within the markup language document is nested within the tag representing the storage subsystem . The storage pool  contains a data storage element that is specifically a logical storage volume . As such, a tag representing the logical storage volume  within the markup language document is nested within the tag representing the storage pool .","The LUN  is a data storage element that contains a data storage element that is specifically a logical storage disk . As such, a tag representing the logical storage disk  within the markup language document is nested within the tag representing the LUN . The logical storage disk  contains a data storage element that is specifically a physical storage volume . As such, a tag representing the physical storage volume  within the markup language document is nested within the tag representing the logical storage disk .","The tag within the markup language document representing the data path  of the host computing device  includes a pointer, or chain, tag  that represents a data access path  to the logical storage volume  of the storage pool  of the storage subsystem . The pointer tag  is nested within the tag representing the data path  within the markup language document. The data access path  represents the fact that the data path  is implemented by the logical storage volume .","The tag within the markup language document representing the logical storage volume  of the storage pool  of the storage subsystem  includes a pointer, or chain, tag  that represents a data access path  to the physical storage volume  of the logical storage disk  of the LUN . The pointer tag  is nested within the tag representing the logical storage disk  within the markup language document. The data access path  represents the fact that the logical storage volume  is implemented by the physical storage volume .","The markup language document that has been described in relation to the data storage architecture  is constructed by performing the method  of . Furthermore, the data storage architecture  can be analyzed by performing the method  of  in relation to this markup language document. For example, the pointer tag  can be followed to determine that the data path  is implemented by the logical storage volume , and the attributes of the logical storage volume  can then be analyzed. Because the logical storage volume  is a virtual entity, any redundant array of independent disks (RAID) characteristics associated with the volume  are known to be implemented at a software level.","Next, the markup language document can be traversed from the logical storage volume  to its parent node, the storage pool , and the attributes of the storage pool  can be analyzed. Any RAID characteristics associated with the storage volume  may be known to be implemented at a hardware level. Thus, redundant software and hardware RAID characteristics can be detected by comparing the RAID characteristics associated with the logical storage volume , if any, with the RAID characteristics associated with the storage pool , if any.","Furthermore, it can be verified that the logical storage volume  is ultimately implemented via a LUN, by following the pointer tag  to the physical storage volume , obtaining the parent node of the volume , which is the logical storage disk , and then by obtaining the parent node of the disk , which is the LUN . A LUN is a more general virtualization layer that can contain logical storage disks, such as the logical storage disk , which may be implemented by physical storage volumes, such as the physical storage volume . The attributes of the logical storage disk  of the LUN  and\/or of the physical storage volumes  (ultimately of the LUN ) may be retrieved and analyzed to determine if any reflect RAID characteristics, to further determine whether there are redundant RAID characteristics within the data storage architecture .","It is noted that such a visualization of a data storage architecture, as in , by using a markup language document provides for advantages over competing such visualizations within the prior art. For example, some types of visualization software can display a visualization of computing architectures like the data storage architecture . However, the lines, or edges, between components displayed within such a visualization do not indicate the relationships between these components. By comparison, in the visualization of , the lines between components do indicate the relationships between these components. For example, the data access path  represented by the pointer tag  indicates that the data path  is implemented by the logical storage volume . Likewise, the data access path  represented by the pointer tag  indicates that the logical storage volume  is implemented by the physical storage volume .","Representative Computing Device and Conclusion",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 7","b":["700","700","702","704","706","704","706","700"]},"The computer-readable medium  stores one or more computer programs  that are executed by the processors , as indicated by the dotted line . Execution of the computer programs  by the processors  from the computer-readable medium  results in the performance of one or more methods. Such methods can include the method  of  and\/or the method  of  that have been described.","It is finally noted that, although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This application is thus intended to cover any adaptations or variations of embodiments of the present invention. Therefore, it is manifestly intended that this invention be limited only by the claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The drawings referenced herein form a part of the specification. Features shown in the drawing are meant as illustrative of only some embodiments of the invention, and not of all embodiments of the invention, unless otherwise explicitly indicated, and implications to the contrary are otherwise not to be made.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIGS. 2","FIG. 1","FIG. 1"],"b":["3","4","4"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
