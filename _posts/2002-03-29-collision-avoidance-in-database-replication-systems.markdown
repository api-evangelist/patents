---
title: Collision avoidance in database replication systems
abstract: Database replication systems replicate blocks of transaction steps or operations with synchronous replication, and perform dual writes with queuing and blocking of transactions. Tokens are used to prepare a target database for replication from a source database and to confirm the preparation. Database replication systems switch between a synchronous replication mode and an asynchronous replication mode, and then back to a synchronous replication mode, based on detection of selected events.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07103586&OS=07103586&RS=07103586
owner: Gravic, Inc.
number: 07103586
owner_city: Malvern
owner_country: US
publication_date: 20020329
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation-in-part of U.S. Non-Provisional Application No. 09\/810,674 filed Mar. 16, 2001 entitled \u201cCOLLISION AVOIDANCE IN BIDIRECTIONAL DATABASE REPLICATION.\u201d","The present invention relates to the field of data replication.","\u201cBidirectional Database Replication\u201d is specified as the application of database deltas (i.e., the results of transactions being performed against a database) from either of two databases in a pair to the other one. Transaction I\/O (e.g., inserts, updates, and deletes) applied to one database are applied to the other database and vice-versa. Both databases are \u201clive\u201d and are receiving transactions from applications and\/or end users. U.S. Pat. No. 6,122,630 (Strickler et al.), which is incorporated by reference herein, discloses a bidirectional database replication scheme for controlling transaction ping-ponging.","In the database world, a collision is classically defined as a conflict that occurs during an update. A collision occurs when a client reads data from the server and then attempts to modify that data in an update, but before the update attempt is actually executed another client changes the original server data. In this situation, the first client is attempting to modify server data without knowing what data actually exists on the server. Conventional techniques for minimizing or preventing collisions include database locking and version control checking. These techniques are commonly used in systems that have one database, wherein many users can access the data at the same time.","When a database system includes replicated databases, the problem of collisions becomes greater, since clients may be requesting database changes to the same data at the same physical or virtual location or at more than one physical or virtual locations. Collision or conflict detection schemes have been developed for replicated database systems. After a collision is detected, a variety of options are available to fix or correct the out-of-sync databases. However, it would be more desirable to prevent collisions from happening in the first place.","One conventional distributed transaction scheme used in Oracle distributed database systems is known as the \u201ctwo-phase commit mechanism.\u201d This approach is classically used to treat a \u201cdistributed\u201d transaction, i.e., a transaction that spans multiple nodes in a system and updates databases on the nodes, as atomic. Either all of the databases on the nodes are updated, or none of them are updated. In a two-phase commit system, each of the nodes has a local transaction participant that manages the transaction steps or operations for its node.","The two phases are prepare and commit. In the prepare phase, a global coordinator (i.e., the transaction initiating node) asks participants to prepare the transaction (i.e., to promise to commit or rollback the transaction, even if there is a failure). The participants are all of the other nodes in the system. The transaction is not committed in the prepare phase. Instead, all of the other nodes are merely told to prepare to commit. During the prepare phase, a node records enough information about the transaction so that it can subsequently either commit or abort and rollback the transaction. If all participants respond to the global coordinator that they are prepared, then the coordinator asks all nodes to commit the transaction. If any participants cannot prepare, then the coordinator asks all nodes to roll back the transaction.","A side effect of this scheme is often a degree of collision prevention. Prior to the prepare phase, locks are placed on the appropriate data and the data is updated, thereby preventing many types of collisions. For example, the well-known technique of \u201cdual writes\u201d can be used to lock and update the appropriate data. In this technique, the application originating the transaction (or a surrogate library, device, or process on behalf of the application) performs the local I\/O changes and replicates the I\/O changes as they occur and applies them directly into the target database. Typically, the application's individual I\/O changes to the source database are \u201clock-stepped\u201d with the I\/O changes to the target database. That is, the local I\/O change does not complete until the remote I\/O change is also complete.","The scheme of using two phase commit with a technique such as dual writes (also referred to as \u201ctwo phase commit\u201d in this document) relies on a transaction coordinator for both local and remote database updating. If there are a large number of nodes in the system, the transaction coordinator must actively manage the updating of all of the other nodes. The node coordination puts large processing demands on the transaction coordinator and requires a large amount of messaging to occur throughout the system. Due to its messaging nature, the two-phase commit mechanism is not used for efficient replication of distributed databases.","Accordingly, there is an unmet need for a collision avoidance scheme in a database replication system that is relatively simple to implement, efficiently uses communication medium, scales efficiently and easily, prevents all types of collisions, and which does not place large demands on local application programs to perform complex node coordination duties. The present invention fulfills such a need.","There is also an unmet need for methods to determine when to switch replication systems that normally operate in a synchronous mode to an asynchronous mode, and subsequently back to a synchronous mode. The present invention also fulfills these needs.","Database replication systems replicate blocks of transaction steps or operations with synchronous replication, and perform dual writes with queuing and blocking of transactions. Tokens are used to prepare a target database for replication from a source database and to confirm the preparation. Database replication systems switch between a synchronous replication mode and an asynchronous replication mode, and then back to a synchronous replication mode, based on detection of selected events.","Certain terminology is used herein for convenience only and is not to be taken as a limitation on the present invention. In the drawings, the same reference letters are employed for designating the same elements throughout the several figures.","A. Definitions","The following definitions are provided to promote understanding of the invention. For clarity, the definitions are phrased with respect to a scheme that replicates only two databases. However, the scope of the invention includes schemes where replication occurs between more than two databases.","Replication\u2014duplicating the contents of at least a portion of data records held in a source database to a target database. In the narrowest sense, replication involves duplicating the entire contents and format of the data records so that the two databases are totally identical, and thus interchangeable with each other. In the broadest sense, replication as defined herein involves duplicating at least the contents of a portion of the data records, and not necessarily duplicating the format of the data records. Replication thus may involve data transformation or filtering wherein the source data is altered in some manner before being applied to the target database. The concept of replication vs. transformation of data is discussed in more detail below.","Replication Data\u2014includes both \u201cabsolute\u201d database information (e.g., set the price field to a certain value), as well as \u201crelative\u201d database information (e.g., add $10 or 10% to the price field).","Collector\u2014an object or process that reads an audit trail, transaction log file, database change queue or similar structure of a first database, extracts information about specified changes to the first database (e.g., insertions, updates, deletions), and passes that information to the consumer object or process defined below. In Shadowbase\u00ae (a commercially available product made by ITI, Inc., Paoli, Pa.) executing on a COMPAQ NSK (Tandem) source, the collector reads TMF or TM\/MP audit trails. In a bidirectional database replication scheme, each of the two databases has an associated collector. The extractor process shown in FIG. 1 of U.S. Pat. No. 5,745,753 (Mosher, Jr.) assigned to Tandem Computers, Inc is similar in operation to the collector.","Transaction Transmitter\u2014device or object which sends transactions posted to one database to the other database for replication in the other database. In accordance with preferred embodiments of the present invention, transaction transmitters typically group one or more of the transaction operations or steps into blocks for efficient transmission to the transaction receivers. In one embodiment of the present invention, the transaction transmitter is identical to the collector. In other embodiments, the transaction transmitter performs some, but not all, of the functions of the collector. In a bidirectional database replication scheme, each of the two databases has an associated transaction transmitter.","Consumer\u2014an object or process that takes messages about database changes that are passed by the collector object or process and applies those changes to the second database. In a bidirectional database replication scheme, each of the two databases has an associated consumer. The receiver process shown in FIG. 1 of Tandem's U.S. Pat. No. 5,745,753 is similar in concept to the consumer, except that the consumer described herein can process multi-threaded (i.e., overlapping) transactions, whereas the receiver process in the Tandem patent cannot process multi-threaded transactions.","Transaction Receiver\u2014device or object which receives transactions sent by a transaction transmitter for posting to a database. In accordance with the present invention, transaction receivers typically unblock the transaction operations or steps as they are received and apply them into the database. Depending on the nature of the transaction operations or steps, they may be applied in parallel or serially, and the transaction profile may be serialized or multi-threaded (that is, one transaction may be replayed at a time, the transactional order may be altered, and\/or the transactions may be replayed in the \u201csimultaneous, intermixed\u201d nature that they occurred in the source database). In one embodiment of the present invention, the transaction receiver is identical to the consumer. In other embodiments, the transaction receiver performs some, but not all, of the functions of the consumer. In a bidirectional database replication scheme, each of the two databases has an associated transaction receiver.","Database\u2014in the broadest sense, a database as defined herein comprises at least one table or file of data, or a portion of a table or file of data wherein the data is typically arranged in records called rows. In a narrower sense, a database is also a collection of tables or files, that is, multiple tables or files make up a database. Replication among databases thus has different meanings depending upon how the database is defined. Consider the following examples:","1. A system includes a single database which has two tables or files (i.e., two sub-databases) and the database replicates to itself. Replication thus maintains the two tables or files in the same state. The tables or files are in the same physical location, and each has a respective audit trail, collector and consumer.","2. A system includes a single database which has one table or file partitioned into two parts and the database replicates to itself. The first part has a plurality of records, and the second part has a plurality of records which must be kept in the same state as the first plurality of records. Replication thus maintains the two parts of the table or file in the same state. The two parts of the table or file are in the same physical location, and each has a respective audit trail, collector and consumer.","3. A system includes two databases, each located remotely from the other. Each database may have one or more tables or files, and the two remotely located databases replicate themselves. Replication thus maintains the two databases (including all of their respective tables or files) in the same state. The two databases are in different physical locations, and each has a respective audit trail, collector and consumer. In a typical scenario, each database resides at a different node within a network.","Table\u2014alternative name for a database. In the preferred embodiment of the present invention, replication and copying of data is performed at the file level. However, other levels of replication\/copying are within the scope of the invention, such as diskcopy-type operations which are used to create the databases 126 in FIG. 1 of Tandem's U.S. Pat. No. 5,745,753.","Primary Replication\u2014effectively, unidirectional replication from a first database to a second database.","Row\u2014effectively, a single record out of a database. A row update is an individual step defined to mean a modification (e.g., insert, update, delete) to the database.","Reverse Replication\u2014effectively, unidirectional replication from the second database to the first database.","Transaction\u2014A transaction is a unit of work consisting of one or more individual steps and\/or operations to be applied to one or more local and\/or remote databases as a single atomic unit of work. A characteristic of transactions is the requirement that either all steps and\/or operations are applied or all are rolled back in the case of a problem so that the database(s) is always left in a consistent state. Transactions are often identified by a number or name called the transaction identifier. The transaction identifier is often, though not necessarily, unique. An example of an \u201cindividual step\u201d would be to insert a record (row) into the database. An example of an \u201coperation\u201d would be the procedure which increases the price column of all rows in the database by 10%.","In an unaudited (non-transactional) database, each step or operation will be treated as a separate transactional unit of work. The commit step is akin to unlocking the column, row, page or table. The audit trail is akin to an application, system, replication, or other suitable log, disk cache, or change data file or storage medium.","Filtering\u2014The operation of selectively choosing rows or transactions to replicate.","Restart\u2014the steps that need to be taken in the event that one or more of the primary or secondary replication component(s) is unavailable and a restoration of the failed replication component(s) is needed. For example, if a communication channel fails, then any messages that were lost in transit need to be resent during the restart. The restart might be partial, (i.e., just certain or failed components get restarted), or total (i.e., all replication components are stopped and restarted). In either case, a non-transient source of information is needed to effectuate the restart, for instance, to tell the collectors where in the audit trail to start reading for transaction data. A restart file is often used for this purpose. In normal operation, the replication components periodically, or at certain events, log their current position to the restart file so that it can be used when a restart is needed. Some desirable aspects of effective restarts include: (1) few and non-complex system operator steps needed to effectuate the restart, (2) prevention of duplicate database updates from being applied to the target database, (3) restoration or elimination of missing database updates, and (4) minimal restart time.","Data Transformation\u2014The scope of the present invention also includes schemes which perform transformation of data, instead of strict replication. Examples of transformations include:","1. Replicating Enscribe source data to SQL target tables.","2. Eliminating or adding columns or rows in a target.","3. Combining records from two source files or tables and writing them into one target file or table.","4. Changing the type, structure or length of a field.","5. Taking one source record and writing one target record for each occurrence of a particular field (e.g., data normalization).","6. Writing a source record to a target only when a field contains a specific value (conditional replication).","Deferred transactions\u2014These occur in synchronous replication environments. They are defined as any transactions that have been allowed to commit in one (for example, the originating) environment, and the commit has not yet been sent\/applied into the other peer environment(s). A loss of inter-environment communication when a transaction is in the deferred state allows the transaction changes to be applied\/unlocked in the environment where they are committed, yet the other environment(s) have not been committed\/unlocked. When such a condition exists, the replication engine considers that synchronous replication can no longer be ensured, and may \u201cfall-back\u201d to asynchronous replication to the affected nodes until the problem is resolved and synchronous replication can again be ensured.","Replication latency\u2014elapsed time after an I\/O operation is applied to a source database to when the I\/O operation is applied into a target database by a replication engine.","Data Collection\/Log Techniques\u2014Detailed Definition of Audit Trail","An audit trail (ADT) is akin to an application, system, replication, queue, or other suitable log, disk cache, memory cache, or change data file or storage medium. Its purpose is to hold information about the transaction steps and operations (that is, the database change activity).","The preferred embodiment of the present invention includes many data collection techniques, not just the classic transaction monitor and transaction \u201credo\u201d\/\u201cjournal\u201d log, or audit trail, approach defined and used on certain platforms by the Shadowbase product. The primary features of these data collection techniques are that they collect, retain, and serialize the database update activity. Some even provide transactional integrity (i.e., a set of database updates is either fully applied or fully undone). The collected data is saved in a \u201clog\u201d that may be disk-based, memory-based, an application log file, or other queue structure. The data may be stored in transient or non-transient storage. The present invention includes the following data collection techniques:","(1) Reading database \u201credo\u201d logs. These logs are typically maintained by a transaction processing (tp) subsystem provided by the O\/S or database vendor. They typically contain database \u201cbefore\u201d and\/or \u201cafter\u201d record images, as these images can be used to restore the before state of a record update (abort situation) or to apply the after state of a database update (commit situation). These monitors typically provide transactional database integrity. Access to these logs, and understanding the format of the data in them, is required to use this technique. Salient features include:\n\n","The Compaq Transaction Monitoring Facility (TMF) provides this functionality on an NSK system.","(2) Reading database \u201cimage\u201d logs. These logs are typically maintained by the application itself, and they contain similar information to the redo logs. The application may or may not provide transactional database integrity. Access to these logs, and understanding the format of the data in them, is required to use this technique. Salient features include:\n\n","The Tenera Plant and Information Management System (PIMS) application, commercially available from Tenera Inc., San Francisco, California, provides this functionality in the database \u201ccradle\u201d and log files.","(3) Using database triggers and\/or stored procedures and\/or database \u201cpublish and subscribe\u201d (or similar) features to perform the collection of the database change data, and saving the gathered data into a collection log. This technique requires that the database provide a trigger\/stored procedure\/publish-subscribe mechanism (or something similar) that is available to the replication engine. Salient features include:\n\n","The Shadowbase\u2122 \u201copen\u201d collection environment (e.g., Solaris\/Oracle, Windows\/MS SQL Server, etc) offers this approach for capturing database change data for the replication engine.","(4) Using an \u201cintercept\u201d library that intercepts application disk I\/O calls and saves the database change data into a collection file. This technique requires that the O\/S and\/or application environment provide an intercept mechanism that is available to the replication engine. Salient features include:\n\n","The Golden Gate Extractor\/Replicator product, commercially available from Golden Gate Software, Sausalito, Calif., provides this technique for event capture. The NTI DrNet product, commercially available from Network Technologies International, Inc., Westerville, Ohio, provides this technique for event capture.","(5) Using a \u201ccallable\u201d library application-programming interface (API) that performs the application disk I\/O on behalf of the application. The library performs the data collection similar to the method used by the intercept library. Salient features include:\n\n","The NetWeave product, commercially available from Vertex Interactive, Clifton, N.J., is an example of this technique.","(6) Using a device driver or file system \u201cplug-in\u201d that is executed when database I\/O occurs in the system. The plug-in may be part of the database device drivers or file system, or may be invoked, broadcast, signaled, or similarly notified by these components in a call back, registration, or other announcement fashion when I\/O is occurring against the database. The CONTROL- processing notification, commercially available from Compaq Computer Corporation, Houston, Tex., provides similar functionality for Himalaya Enscribe I\/O database changes.","Transaction Integrity\u2014For those environments that provide transactional integrity, referred to as \u201caudited\u201d systems, the replication engine should (although it is not absolutely necessary) mimic the transactional integrity on the target system. This means that all I\/O's in the source transaction are either committed (applied) or aborted (not applied) depending on the final state of the transaction. (If the transactional integrity of the source is not mirrored, the referential integrity on the target may be violated.) Since some replication implementations will apply the database I\/O's as they occur, the actual transaction profile of commits\/aborts on the source and target databases is preserved. For those implementations that defer applying the I\/O's until the final transaction state is known, and then replay them in commit order, typically only committed transactions are applied.","For those environments that do not provide transactional integrity, referred to as \u201cnon-audited\u201d systems, the replication engine must treat all individual, successful database change I\/O's as if they consist of a transaction begin (implicit), database I\/O, and a transaction commit (implicit). Certain unsuccessful database I\/O's are still treated as if they were successful, for example, if the base table was updated successfully, yet an index path failure occurred (as the file system would allow the base table\/index inconsistency to remain). The scope of the present invention covers non-audited systems.","In the examples of the present invention described below, the first and second transaction transmitters are first and second collectors, the first and second transaction receivers are first and second consumers, and the first and second databases are first and second target tables. Also, the examples below presume that strict database replication occurs without any transformation of the contents of the data or its format. However, the scope of the invention includes unidirectional and bidirectional replication schemes wherein at least the contents of a portion of the data or its format are transformed.","B. Collision Avoidance in Bidirectional Database Replication",{"@attributes":{"id":"p-0069","num":"0080"},"figref":["FIG. 1","FIGS. 2A and 2B"],"b":"10"},"Referring to , the system  has a first node  comprising a first target table , a first audit trail , a first collector , a first consumer  and a restart file . The system  also has a second node  comprising a second target table , a second audit trail , a second collector , a second consumer  and a restart file . To simplify the explanation of the invention, the following terminology is used interchangeably:","first node \u2014node A","first target table \u2014target table A or database A","first audit trail \u2014audit trail A","first collector \u2014collector A","first consumer \u2014consumer A","restart file \u2014restart file A","second node \u2014node B","second target table \u2014target table B or database B","second audit trail \u2014audit trail B","second collector \u2014collector B","second consumer \u2014consumer B","restart file \u2014restart file B","combination of collector A and consumer B\u2014primary replication subsystem","combination of collector B and consumer A\u2014standby\/reverse replication subsystem","In addition to the elements above, one or both of the nodes A and B include one or more local input devices  and , referred to interchangeably as \u201clocal input device A\u201d and \u201clocal input device B.\u201d The local input devices A and B make local modifications (e.g., inserts, updates and deletes) to the data in the respective databases A and B as part of a complete transaction in a similar manner as the application programs described in  of U.S. Pat. No. 6,122,630. Alternatively, the local input devices A and B may be located outside of the nodes A and B, and may be connected via a communication medium to the nodes. The local input devices A and B may be batch programs having no user or terminal I\/O.","The databases A and B, audit trails A and B, collectors A and B and consumers A and B are connected together as discussed above in the definitions section. More particularly, the collector A is connected to the consumer B via communication medium  to provide primary replication, and the collector B is connected to the consumer A via communication medium  to provide standby\/reverse replication.","In operation, any modifications made by the local input device A to the database A must be replicated in the database B. Likewise, any modifications made by the local input device B must be replicated to the database A.","The system  also includes restart files  and  connected to respective collectors  and . The function of the restart files  and  is described above in the \u201cDefinitions\u201d section.","The system  preferably includes additional elements and steps to prevent ping-ponging of transactions, in addition to elements and steps for avoiding collisions. FIGS. 3\u201312 of U.S. Pat. No. 6,122,630 illustrate seven transaction ping-pong prevention schemes. For simplicity, the systems described herein do not show the ping-pong prevention schemes.","As discussed above, collisions may occur in database replication schemes. If a collision is detected, discrepancies between the plural database versions must be investigated and resolved by special programs or by the system operator. The present invention provides a scheme to prevent such collisions, thereby obviating the need for such special programs or system operator intervention.",{"@attributes":{"id":"p-0091","num":"0102"},"figref":["FIGS. 2A and 2B","FIGS. 2A and 2B","FIG. 1"],"b":["44","46","48"]},"The RTC tables A and B may be separate elements of the system , as illustrated in , or they may be physically located in, or part of, the target tables, the consumers, or the local application programs.",{"@attributes":{"id":"p-0093","num":"0104"},"figref":"FIG. 3"},"The present invention is preferably implemented in conjunction with row or table locking, also referred to as row-level locking and table-level locking. The examples provided below use row locking. In multi-version data concurrency control, row-level locking is used when one or more internal fields of a row (i.e., columns) are being added, updated, or deleted. The appropriate rows are locked so that more than one user at a time cannot modify the rows of a particular table of data. The locks are released after the transaction is completed.","The present invention uses the row-level locking feature in conjunction with RTC tokens to ensure that the appropriate rows in each target table are locked before a transaction is committed at the originating node. When an RTC token is received back (returned) from each of the other nodes in the system , then the originating node knows that all of the other nodes in the system  have locked the appropriate rows and are ready to commit the transaction.","Accordingly, the transaction can be committed without a risk of a collision occurring at one of the other nodes in the system . No such transaction pausing or RTC tokens are used in the prior art system .","To summarize, the return of the RTC token at the originating node from each of the other nodes in the system indicates that the corresponding rows in all of the replicated databases are locked before being updated and that the transaction may be committed without a possibility of a collision. If the RTC token fails to return or is prematurely returned with an error indication, this may indicate that a collision will occur if the transaction goes forward, and thus the transaction should not be committed.",{"@attributes":{"id":"p-0098","num":"0109"},"figref":["FIG. 3","FIG. 3"],"b":["101","1","101"],"sub":["1","2","2","3","3"]},"At time t, the local application program A is ready to commit transaction . Instead of immediately initiating the COMMIT operation, the local application program enters an indicia of transaction  into the RTC table A. In this example, the indicia is the transaction identifier. However, the scope of the invention includes other forms of indicia. Optionally, a flag is set for the table entry. Here, the flag is initially set to zero. As described above, a token is generated for each new RTC table entry and is automatically sent to the audit trail A. Thus, at approximately time t, RTC token  is entered into the audit trail A. The RTC token  is sent to node B using the same conventional replication processes that replicate transaction steps or operations.","Upon receipt by the consumer B at node B of the RTC token , consumer B determines whether the appropriate transactions steps or operations that should have been received at node B prior to a commit operation were, in fact, received at node B. In this instance, it must be verified that the debit and credit transaction steps for John Smith and Jane Doe were received at node B, and therefore, their respective rows have been locked and updated. If so, the RTC token  is entered into the audit trail B at time t+\u03b1. Optionally, if no audit record is needed of RTC tokens received at node B, then the RTC token  may be sent directly from the consumer B to the collector B without being entered into the audit trail B. In this embodiment, there would be no entry in the audit trail B shown in  at time t+\u03b1. This alternative scheme is represented by the dashed lines in  that connect the consumers and collectors. Since there is no entry in the audit trail B, this alternative scheme may be used when restart and sequencing issues do not arise.","Assuming that the RTC token  successfully makes it to the collector B, either directly from consumer B or from the audit trail B, then at time t5, the collector B sends the RTC token  back to node A where it is received by the consumer A. At approximately time t, the consumer A sends the RTC token  (or an indicia of transaction identifier ) to the RTC table A. In the RTC table A, the flag for transaction identifier  is changed from zero to one, thereby indicating that the RTC token has been received at all nodes that must replicate the transaction, here only node B.","Alternatively, at time t, the consumer A may send the RTC token  directly to the pause logic of the local application program A, which, in turn, communicates with the RTC table A regarding which transactions are waiting to commit and which transactions can go forward with a commit step.","At time t, the transaction  is committed. The commit step is entered into the audit trail A and is replicated to node B for entry into the audit trail B at time t+\u03b1. The row locks for John Smith and Jane Doe in the target tables A and B are removed after the commit step is completed.","Also, at time t, the table entry for transaction  may be deleted from the RTC table A. If table entries are not automatically deleted, then logic in the RTC tables is provided to prevent RTC tokens from being generated for any table entries that have a flag value equal to \u201c1\u201d or to prevent RTC tokens from being generated more than one time for each unique transaction identifier.","The consumers must process RTC tokens differently depending upon whether the tokens were originated from the consumer's own node or from another node. As described above, tokens that were not originated at the consumer's own node may be sent directly to the collector at the same node (after appropriate logic is executed to ensure that a token return is permissible), whereas tokens that were originated at the consumer's own node must be processed by the pause logic and ready to commit table of the same node to ensure that the transaction is committed if tokens from all other nodes are subsequently returned.","When a consumer receives an RTC token from a node other than its own node, the consumer must verify whether the appropriate transactions steps or operations that should have occurred prior to a commit operation have, in fact, been received and successfully applied at the consumer's node. In the example above, consumer B must verify that the debit and credit transaction operations were actually received and successfully applied at consumer B, and therefore the rows for John Smith and Jane Doe in target table B have been properly locked and updated. One suitable technique for accomplishing this task is to examine packet sequence numbers.","In the example above, the data packets for the BEGIN, DEBIT, CREDIT, COMMIT operations or steps, and the RTC tokens, will have sequential numbers for the respective transaction identifier. For example, one simplified example of numbers is as follows:","BEGIN\u2014101.001","DEBIT\u2014101.002","CREDIT\u2014101.003","RTC TOKEN\u2014101.004","COMMIT\u2014101.005","In this example, when the consumer B receives the RTC token , the consumer B verifies whether sequence numbers  through  for transaction  were received. If so, then the consumer B can forward the RTC token  back to the originating node, here, node A if sequence numbers  through  have been successfully applied. If not, then the consumer B will not forward the RTC token  back to node A and the transaction will not be completed at either node. Alternatively, the consumer B will forward back the RTC token with an indication of failure attached thereto. This RTC token would be treated by the originating node as if the RTC token never returned. By preventing transactions from going forward if the appropriate rows or tables are not locked at each replicated database, collisions can be avoided.","If a flag is used in the RTC table, schemes other than the simple two logic stage flag are within the scope of the present invention. For example, the flag may represent the number of other nodes that the originating node must hear back from before committing the transaction. The flag may then be counted down to zero as tokens are returned.","To summarize some of the various different ways that a node processes incoming RTC tokens, as opposed to RTC tokens associated with locally initiated transactions, three different paths are shown in . First, the RTC tokens may be sent directly to the collector of the node after determining that the node is prepared for a commit operation for the transaction corresponding to the RTC token. Second, the RTC tokens may be sent to the RTC table at the node after determining that the node is prepared for a commit operation for the transaction corresponding to the RTC token. In this embodiment, the RTC token would pass through the RTC table at the node and be entered into the audit trail at the node. The RTC token would not be stored in the RTC table at the node, since the transaction was not initiated at the node. Third, the RTC tokens may be sent directly to the audit trail at the node after determining that the node is prepared for a commit operation for the transaction corresponding to the RTC token. The second and third embodiments allow the system to take advantage of the existing capabilities of the audit trail to replicate any entered transaction steps or operations to other nodes. In this manner, the RTC token may be treated by the audit trail just like any other transaction step or operation. In the first embodiment, additional instructions must be provided in the collectors regarding the processing of RTC tokens. Also, in the second and third embodiments wherein the RTC token is in the audit trail, serialization and proper sequencing of the database operations (both used for a restart operation) are ensured.","In an alternative embodiment of the present invention, the RTC token may be combined, either logically or physically, with the last transaction step or operation. This alternative embodiment may be used in an audited or an unaudited (non-transactional) database scheme.","Referring again to , transactions do not have to start and finish in sequence. For example, a transaction  may start after transaction  has begun, but before transaction  has been committed. Thus, there may be more than one uncommitted transaction at any point in time at each node, and thus more than one entry of an RTC transaction in the RTC tables at any one point in time.","To minimize unnecessary traffic in the communication lines between nodes, particularly in a system that has more than two nodes, logic is preferably provided in the consumers, collectors or audit trails to direct returning tokens only to the originating nodes (a form of selective ping-ponging). Accordingly, the packets that include RTC tokens also preferably include node origin information. To further minimize unnecessary traffic, logic may be provided in the consumers, collectors or audit trails to selectively block the ponging of commit transactions, since the ponging of RTC tokens may be used as a surrogate for a commit transaction.","Logic is also preferably provided in the consumers, collectors or audit trails to prevent ping-ponging of RTC tokens. Any of the schemes described in U.S. Pat. No. 6,122,630 may be used for this purpose.","In an alternative embodiment of the present invention, the RTC token is supplemented by one or more Ready to Sync (RTS) tokens which are created and propagated through the system  in a similar manner as the RTC token.","Some transactions have a very large number of steps or operations. As the succession of transaction steps or operations are performed, resources are allocated and data is locked. As the transaction approaches the commit operation, a large number of resources and data may be allocated and locked. These resources and data are not available for other transactions that may be occuring or waiting to occur. When using only the RTC token, the system  must wait until just before the commit operation to discover whether a collision would occur if the transaction is committed. It would be desirable if the system  can discover at an earlier stage in the transaction whether a collision may occur so that the transaction can be aborted earlier in the process, thereby freeing up system resources and locked data earlier in the process. The longer the transaction, the greater the advantage in detecting problems earlier in the transaction. It would also be desirable to know if certain parts of lengthy transactions have been safe-stored at all nodes.","To implement this alternative embodiment, selected intermediate points in a transaction are designated as checkpoints or restart points (hereafter, \u201csync points\u201d). A sync point may occur after every N transaction steps or operations, or at selected significant transaction steps or operations. At each sync point, indicia of the transaction initiated at the originating node is entered into a Ready To Sync (RTS) table  or , hereafter, RTS table A and RTS table B shown in . The RTS tables A, B are similar in concept to the RTC tables A, B used for RTC tokens. The RTS tables A, B generate RTS tokens for each sync point, in a manner similar to generation of RTC tokens by the RTC tables A, B. The RTS tokens propagate through the system  in a similar manner as the RTC tokens (not shown in ). When using RTS tokens, it is not necessary to pause the transaction to wait for a successful return of the RTS tokens from the other nodes before continuing with additional transaction steps or operations. Thus, there may be more than one RTS token propagating through the system  at one time for each transaction. Each RTS token is transmitted in sequence by the originating node collector. However, in an optional embodiment of the RTS scheme, the transaction may be paused to wait for a return of the RTS tokens from all nodes. The RTS tables A, B and the consumers A, B may use any of the schemes described above with respect to the RTC tables A, B, such as flags and sequence numbers, to track and monitor the sync process.","The RTS tables A, B may be part of the RTC tables A, B. The RTC tables A, B may be separate elements of the system , as illustrated in , or they may be physically located in, or part of, the target tables, the consumers, or the local application programs.","If a failure is detected that is indicative of a potential collision situation for the transaction up until the sync point (e.g., if all of the RTS tokens do not properly and\/or timely return from the other nodes), then the transaction is stopped by logic in the local application program. Two types of transaction stopping are possible. In one mode, the entire transaction is aborted as described above when only an RTC token is used in a pause-before-commit process. In another mode, the transaction is restarted right after the last successful sync point. Since the transaction may be very lengthy, the ability to restart the transaction at an intermediate point has advantages over the all-or-nothing approach when using only an RTC token in a pause-before-commit process. In either mode, the use of RTS tokens allows the system  to provide earlier detection of collision situations, thereby allowing system resources and data files to be released and unlocked earlier in the transaction process. The use of the RTS tokens also allows the system  to know if certain parts of lengthy transactions have been safe-stored at all nodes.","The present invention may be implemented using column-level locking, row-level locking, page-level locking, or table-level locking. The type of locking depends upon the desired granularity level (i.e., the size of the object to be locked). The lowest granularity is at the column level, whereas the highest granularity is at the table level. Generally, the lower the lock granularity, the greater the number of users that can simultaneously access data in the table, because a smaller portion of the data is locked by each user.","The scope of the present invention is not limited to relational database management systems (RDBMS) having tables, rows and columns, but also includes corresponding elements in traditional, relational and conceptual data management systems, summarized as follows:","RDBMS: table, row, column","Traditional: file, record, field","Relational: relation, tuple, attribute","Conceptual: entity set, entity, attribute","The present invention may also be implemented using data locking schemes other than direct row or table locking of the target tables. In one alternative embodiment, a lock table is maintained separate from the database manager locking scheme that directly controls the target tables. In this embodiment, updates (write requests) must go to the separate lock table first to check whether a row of a target table can be modified.","In some topologies, each node is not directly connected to every other node in the system, but instead indirectly communicates with some other nodes through other nodes. The scope of the present invention includes such topologies wherein RTC tokens and transaction data from an originating node are communicated to and from one or more receiving nodes via other nodes.","The present invention has significant advantages over distributed transaction schemes that also provide a degree of collision prevention, such as Oracle's two-phase commit. In the present invention, database replication is handled by elements and software that are independent of the elements and software that process locally initiated transactions and that post transactions to databases. In contrast, Oracle's two-phase commit scheme places all of these burdens on the local application software and transaction coordinator at each node. The present invention may be implemented with less node coordination than the Oracle scheme, and with more efficient communication medium usage (for example, via blocking), thereby allowing for faster speed and greater throughout. Additionally, the two-phase commit scheme starts one \u201cglobal\u201d transaction on the initiating node, and information about this transaction must be propagated to the other \u201cchild\u201d nodes. The initiating node, as well as the child nodes, must communicate significant information about the state of the global transaction as the transaction is replicated and eventually terminated. This overhead is not required in the present invention, as each side performs its own local transaction independent of the other.","C. Collision Avoidance\u2014Replication Engine and Application Engine are Independent from Each Other",{"@attributes":{"id":"p-0135","num":"0146"},"figref":["FIG. 4","FIG. 4","FIG. 2A"]},"As described previously, the two-phase commit scheme is integrated into the application for replicating the application's changes as those changes are made. This degree of tight coupling is not required in the present invention, as the source and target transaction steps occur independently, not gated by the speed of each other, and are only synchronized when the RTC token is sent\/processed. Additionally, the transaction coordinator in the two-phase commit scheme sends messages via separate channels\/connections from the data, causing additional coordination between these channels, whereas the present invention doesn't have this additional coordination as it uses the same channels for the RTC tokens as the data.","In operation, the replication process functions in the following manner:","1. An application at a first node pausing each transaction being executed in a source database at the first node prior to a commit operation for the transaction.","2. A replication engine at the first node assigns a ready to commit token to the transaction in coordination with the application.","3. The replication engine at the first node sends the ready to commit token to the second node.","4. A replication engine at a second node determines whether a target database at the second node is prepared for a commit operation for the transaction corresponding to the ready to commit token, and, if so, sends back the ready to commit token to the first node.","5. The application at the first node executes a commit operation at the source database in coordination with the replication engine only upon receipt from the second node of the ready to commit token originally sent from the first node. In an alternative embodiment, the replication engine executes the commit operation at the source database only upon receipt from the second node of the ready to commit token originally sent from the first node.","For reasons of clarity, the descriptions of the present invention describe the application and replication engine as processing one transaction at a time, whereas in a typical implementation these components would be \u201cmulti-threaded\u201d, that is, able to process many transactions simultaneously.","D. Collision Avoidance\u2014RTC\/RTS Tokens Flow Directly Through Consumers, Bypassing Audit Trails",{"@attributes":{"id":"p-0145","num":"0156"},"figref":["FIGS. 5A and 5B","FIGS. 5A and 5B","FIGS. 2A and 2B","FIGS. 6A"],"b":["6","7","7"]},"E. Collision Avoidance\u2014Less than all Nodes Return RTC Token","In the preferred embodiments of the present invention described above, the commit operation is executed at the originating node only upon receipt from each of the other nodes in the system of the ready to commit token originally sent from the originating node for the transaction. In an alternative embodiment of the present invention, the commit operation is executed as long as the originating node receives back a ready to commit token from at least one of the other nodes, or a specified subset or number of the nodes. This alternative embodiment is useful so that the scheme can recover from certain failures, such as the loss of the interconnecting communications media or the loss of an entire system. For example, if the token is not returned within a specified time period, or if the communication interconnections or other nodes suffer from irrecoverable errors, the originating node can still commit the transaction, mark the failed or inaccessible nodes as \u201cinaccessible\u201d, and remove them from the network. This allows the remaining nodal network to survive the failure and continue to process inputs.","As described below, the inaccessible nodes can later be recovered and re-added into the network using a variety of techniques.","F. Collision Avoidance\u2014Commit to Originating Database Last","In the preferred embodiments of the present invention described above, the commit operation is executed at the originating node (source database) first, and then replicated to the other nodes (target databases). That is, the transactions are first posted to the originating database (upon receipt at the originating node of the RTC tokens), and then the posted transactions are replicated to the other nodes for posting to their respective databases. However, in an alternative embodiment of the present invention, the commit operation is executed first at the other (non-originating or target) nodes, and then second, at the originating or source node.","More specifically, in this alternative embodiment, the transaction operations or steps are still applied to the source database, and replicated to the target database, as they occur, and the application is paused at commit time. The RTC token is then sent to the target side, and if all of the transaction was successfully applied, the target side commits the transaction, and returns the RTC to the originating node. Upon receipt of the RTC, the source side then commits the transaction. In this technique, the target database achieves the commit state sooner than it otherwise would since it doesn't have to wait for the source to commit first, and one less transaction operation (the commit from the source to the target) needs to flow, thereby improving the overall transaction processing rate of the entire system.","In systems with two or more nodes (or replication communication paths between the nodes), any combination of these techniques (source commit first then target vs target commit first then source) can be used. These techniques can be assigned on a replication path by path basis. For example, in a system with three nodes A, B, C, all interconnected with replication paths (i.e., a path from A\u2192B, a path from A\u2192C, a path from B\u2192C, a path from B\u2192A, a path from C\u2192A, and a path from C\u2192B), the path from A\u2192B could use the source then target commit technique, with the remaining paths using the target then source commit technique.","G. Collision Avoidance\u2014Initially Send Only Key to Target","Each record or \u201crow of data\u201d in a database has an associated key, also referred to as a \u201cprimary key,\u201d which uniquely identifies the record or row of data. The key is typically defined as one or more of the fields in the record, although the key could be a record's relative or absolute position in the file, or represented by the location, sequence, timestamp, or entry\/arrival of the record in the file. Accordingly, the byte size of the key is typically substantially shorter in length than the byte size of the entire record and thus takes up less communication bandwidth. Furthermore, a key may be used to read and lock a record much quicker than a corresponding I\/O operation on the record which requires a time-consuming write operation. These principles may be used to implement a highly efficient database synchronization process.","Consider the following source\/target replication process that sends all of the record information, and performs the entire I\/O operation, as the data arrives:","1. BEGIN transaction step for record n at source database.","2. Send the key for record n and the associated record data to the target database.","3. Use the key and the associated record data to lock and update the appropriate record in the target database. This process requires I\/O operations, and thus time-consuming write operations (e.g., inserts, updates, and deletes), to be performed at the target database.","4. Pause the source's commit operation.","5. Send an RTC token to the target database and use the RTC token to determine if the appropriate record was locked and updated. If so, return the RTC token to the source database.","6. Upon receipt of the RTC token at the source, perform a COMMIT operation at the source.","Consider now an alternative embodiment of this process.","1. BEGIN transaction step for record n at source database.","2. Send only the key for record n to the target database. No associated record data is sent at this time.","3. Use the key to lock the appropriate record in the target database. This process does not require any write operations to be performed at the target database.","4. Pause the source's commit operation.","5. Send an RTC token to the target database and use the RTC token to determine if the appropriate record was locked. If so, return the RTC token to the source database. The RTC token is effectively double-checking to see if the previously sent key did its job.","6. Upon receipt of the RTC token at the source, send the associated record data and perform a COMMIT operation at the source.","7. As the associated record data and commit arrive in the target, update the locked records, and ultimately apply the commit.","In the alternative embodiment, the source does not have to wait for data write operations at the target. Instead, the source only has to wait for RTC token to come back which tells the source that the appropriate records have been locked and no collision will occur.","In another alternative embodiment, the source starts sending the record key information as it is collected, and sends the record data information as communication bandwidth becomes available, rather than waiting for the RTC to return. In this approach, the record key information takes precedence over the record data information when deciding what to send to the target (although the approach needs to insure that the record data information eventually gets sent). As the record key information arrives in the target, the target locks the records as described above, and if any record data arrives and the target has available processing bandwidth, the target applies the write operations as processing capacity allows (in the target, the record key lock operations takes precedence over the record data write operations). In this embodiment, parallelism between sending and processing the record key and record data information is achieved, possibly allowing for a reduced overall processing time and greater communication bandwidth utilization.","H. Synchronous Replication vs. Asynchronous Replication","In a \u201csynchronous replication\u201d scheme, an application executes transactions at a source database in coordination with the ability of a replication engine to replay those transactions against a target database. This is referred to as the application and the replication engine being \u201ctightly coupled\u201d, or operating inter-dependently. The net result is that the source database and the target database are either both updated with the transactional data or neither is updated with the transactional data. This is referred to as making the source and target database updates for the transaction \u201catomic.\u201d Most of the RTC token schemes described above implement synchronous replication, although the systems may be implemented so that the transactions are not necessarily synchronous. For example, the RTC may be sent in parallel or combined with the source side commit being allowed to complete, whereby the return of the RTC indicates that the transaction has been applied and safestored in the target. This approach is useful when data collisions are not inherent or are not important in the application, yet the sending system wants to know that the transaction was applied into the target database. (The sending system may, or may not, pause the application that initiated the transaction until the RTC token is returned, depending on application requirements).","In one preferred embodiment of synchronous replication, a commit operation that occurs at the source database is posted first to the source database and is then propagated by the replication engine at the source for posting to the target database. The opposite scheme is also within the scope of this definition. In synchronous replication jargon, committing a transaction at the source database is similar to sending a local I\/O complete signal.","In an \u201casynchronous replication\u201d scheme, an application executes transactions at a source database without coordination of the replication engine's ability to replay those transactions against the target database. This is referred to as the application and the replication engine being \u201cloosely coupled,\u201d or operating independently. Thus, there may be queues of committed transactions at a source database that have not yet been even begun at the target database. The replication schemes described in U.S. Pat. No. 6,122,630 are asynchronous. Asynchronous replication, also referred to as \u201cstore-and-forward,\u201d may be periodic (replications are executed at specific intervals) or aperiodic (replications are executed only when necessary, such as when a triggering event occurs). In asynchronous replication jargon, data does not have to be written to the target database (remote site) before the local I\/O completes, or the local transaction is allowed to complete.","The advantages and disadvantages of synchronous and asynchronous replication schemes are well-known. Generally, synchronous schemes provide better data integrity between two databases that need to be kept in sync. Asynchronous schemes provide a faster response time since a source or originating database does not need to wait for a return signal from the target or replicated database (which may also have to perform a time-consuming write operation) before committing a transaction. Other well-known advantages and disadvantages exist but are not discussed further.","I. Replication vs. Synchronization","As discussed above in the Definitions section, replication relates to duplicating the contents of at least a portion of data records held in a source database to a target database. In contrast, synchronization (or database synchronization) relates to managing changes in multiple database files to assure that \u201cchanges\u201d made in one file are distributed to all files in a structured manner. The synchronization process must also detect and resolve collisions (i.e., multiple changes to the same data field) in a structured manner. Synchronization may be synchronous or asynchronous.","J. Undirectional vs. Bidirectional Replication","As described above, the RTC design can be used in bidirectional replication environments where an application is \u201cactive\u201d, that is receiving inputs and initiating transactions, on both nodes. It is also useful in unidirectional environments (e.g., where an application is active on only one of the nodes) for keeping the two databases synchronized, and consistent.","In a two-node example of a unidirectional environment, a source system is replicating to a target system. The application is only active on the source. The replication data, along with the RTC's (and optionally RTS's), flow from the source to the target, and the RTC's (and optionally the RTS's) flow back. Each transaction is either committed on both systems, or neither.","This is a very valuable form of replication in some disaster recovery situations. For example, when each transaction is conveying a large amount of stock shares, currency amounts, or commodity baskets, the user may very much want to know that the transaction was safe-stored and can be committed on the target before allowing the source to commit. Alternatively, the design could commit the transaction on the target first, then commit it on the source as described above. Data collisions aren't an issue in this case, as only the source system is receiving inputs.","Adding the reverse replication path into this simple example, to create a bidirectional replication system, is a more complicated example of unidirectional replication. As described above, an application is active on each system, the two replication engines independently provide the benefits described for the unidirectional case, and RTC's prevent application data collisions between the application access to its copy of the data.","K. Collision Avoidance\u2014Allows Application Scaling Across Nodes Resulting in a Dramatic Increase in System Availability","One significant benefit of the present invention is that the application can now be \u201cscaled\u201d across many nodes (that is, the application can run on all of the interconnected nodes). This is known as \u201capplication domain independence,\u201d because the application is not limited to run on one specific, or set of specific, nodes.","In such a system, one can send the system inputs to any node (and\/or split the inputs across the nodes in explicit or arbitrary fashion), because all nodes will perform the same sequence of work on the data, resulting in the same results, plus keep all other copies of the database in sync with those results. Prior to this technique, one had to be careful to send all associated or interrelated inputs to the same node for processing to avoid possible collisions. This prior method is known as \u201cdata content\u201d routing of the inputs.","An additional benefit to scaling the application across two or more nodes is that now the availability of the application increases dramatically. For example, it can be shown that one can easily double the 9's in the availability of the entire system (e.g., a 0.99 available system goes to 0.9999, a 0.999 available system goes to 0.999999) by adding an additional node.","In other words, by scaling the application across multiple nodes, one gets disaster tolerance and recovery prebuilt into the architecture. Also, there is instantaneous (or near instantaneous) recovery from a catastrophic system failure since the surviving node was already processing inputs, and can continue to do so after the failure. In addition, any incomplete and new inputs that were intended to be routed to the failed node can be re-routed to the surviving node(s) instead since the surviving node(s) has all pertinent database information because its copy of the data is up-to-date.","L. Blocks of Transaction Steps or Operations","The Shadowbase replication engine queues transaction steps or operations and then sends them in blocks of data to the other nodes for replication. That is, one block of data typically consists of a plurality of transaction steps or operations. Consider the following consecutive string of transaction steps or operations.\n\n","In this sequence, one block may be designated as the portions:\n\n","Or, alternatively, the block may contain just the specific database I\/O changes (such as the write operations), along with the transactional boundary information (e.g., BEGINs, COMMITs, ABORTs, etc).","Queuing and blocking of transaction steps or operations allows communication channels to be used efficiently by minimizing transmit cycles. It would be desirable to use the queuing and blocking scheme in other database synchronization and replication environments.","M. Relative vs. Absolute Transaction Steps or Operations; Sub Record Collisions","\u201cAbsolute\u201d transaction steps or operations specify the value to be assigned to the data. For example, assign the QUANTITY field a value of 100.","\u201cRelative\u201d transaction steps or operations supply a modifier to be applied to the data, to arrive at the final value. For example, modify the QUANTITY field by adding or subtracting 50.","Relative change information can be obtained via many methods, for example:\n\n","At the sub-record (i.e., field or sub-field level), collisions may not occur if they do not update the same field data in the record. For example, if one node modifies FIELD of a record (\u201crecord 1\u201d) while another node simultaneously updates FIELD of the same record (\u201crecord 1\u201d), a collision does not occur as long as the granularity of the change that is applied to the other database is at the field or sub-field level. This form of collision resolution is acceptable as long as the combination of the new fields (new FIELD and FIELD values), along with the remaining record data, does not violate a referential integrity constraint or other business rule.","Absolute and relative change information is quite valuable for resolving certain types of collisions, e.g., those that can occur when two nodes are receiving inputs and later need to be re-synchronized. Using a relative data change example on numerical data, the relative changes can just be added\/subtracted across the nodal copies of the data to get at the correct final value. For example, for bank account withdrawals, the same account can be updated on multiple nodes by separate withdrawals, just apply the withdrawal delta amounts to the account balances across all the nodes to get at the final \u2018correct\u2019 balance. This example illustrates that while you can ultimately resolve all of the collisions to the correct final value, you may potentially violate interim \u201cbusiness logic\u201d rules. Again using the above example, assuming there is a bank business rule to avoid \u201coverdrafting\u201d the account, while all of the individual withdrawals at each node may not violate the rule, the aggregate of all of the withdrawals may. Hence, when replaying all of the individual steps from each of the nodes, one may need to execute the business logic functionality to check for exceptions.",{"@attributes":{"id":"p-0199","num":"0224"},"figref":"FIG. 8"},"N. Replicate Blocks of Transaction Steps or Operation with Synchronous Replication","One preferred embodiment of the present invention uses transaction blocks in a database replication system. Each system includes a plurality of nodes connected via communication media in a topology. Each node includes a database and a transaction transmitter which sends selected transactions posted to the database to one or more other nodes. Each transaction is one or more transaction steps or transaction operations. For simplification, an example is provided that has a source database at a first node and only one target database at a second node.","In the process, the transaction transmitter at the first node collects a block of transaction steps or transaction operations posted to the source database at the first node. Then, the transaction transmitter at the first node sends the block of transaction steps or transaction operations to the second node for posting to the target database therein. This process is repeated for additional blocks of transaction steps or transaction operations posted to the source database.","Unlike the Shadowbase scheme, in this embodiment of the present invention, commit operations are held up (inhibited) at either the source or the target database until it can be ensured that the source database and the target database can both be updated with the transaction data. That is, the transactions are replicated in a synchronous replication mode.","The block of transaction steps or transaction operations may be collected from a queue of transaction steps or transaction operations posted to a source database at the first node.","In one preferred embodiment, the queue is an audit trail at the source database.","The synchronous replication mode preferably uses the RTC token scheme described above. However, the synchronous replication mode may alternatively use a conventional two-phase commit process. If the RTC token scheme is used, the following steps occur:","1. Pause each transaction being executed in the database at the first (originating) node prior to a commit operation for the transaction.","2. Assign a ready to commit token to the transaction.","3. Send the ready to commit token to the second node.","4. Determine at the second node whether the target database is prepared for a commit operation for the transaction corresponding to the ready to commit token, and, if so, send back the ready to commit token to the first node.","5. Execute a commit operation at the database of the first node only upon receipt from the second node of the ready to commit token originally sent from the first node. If there are a plurality of other nodes, then this step may require receipt from either a preselected number of nodes, certain designated nodes, or all of the nodes. As described in the detailed examples above, the commit operation may occur at the source database first and then at the target database. Alternatively, the commit operation may occur at the target database first and then at the source database. That is, if it is determined at the second node that the target database is prepared for a commit operation for the transaction corresponding to the ready to commit token, then the transaction may be committed at the target database before it is committed at the source database.","In another alternative scheme of this preferred embodiment, the database replication system switches from a synchronous replication mode (which is the normal mode) to an asynchronous replication mode when synchronous replication is not properly functioning.","Synchronous replication is then restored when it is detected that synchronous replication can properly function again. Schemes for determining when synchronous replication is not properly functioning and when it should be restored are discussed in detail below.","O. \u201cDual Writes\u201d using Blocks of Transaction Steps or Operations with Synchronous Replication","Disk mirroring is a disk storage process for generating a mirrored image of data on two or more disks. One disk is referred to as the \u201cprimary volume\u201d and one or more other disks are referred to as \u201csecondary volumes,\u201d \u201csecondary disks,\u201d or \u201cduplicates.\u201d The disks may be in the same system or in different systems, and the secondary disk may be local or remote from the primary volume. For simplicity, the remaining discussion will refer to the primary volume as a local database, and will refer to the secondary disk as a remote database.","One disk mirroring approach is a dual write server-centric approach wherein both disks (here, both databases) connect to the same processor which issues multiple disk write commands, one to each database. The software application that controls the mirroring operation is located in the processor which controls the write operations to both databases. The processor may be local to the local database, local to the remote database, or it may be remote from both databases. The processor may control all of the I\/O for all of the application programs, or there may be many processors each receiving the I\/O from some subset of the application programs. Also, there is a physical I\/O between the application and the remote database.","In the dual write approach, a write operation for a transaction may occur in parallel if supported by the software (writes to the local database and the remote database may occur simultaneously), or serially (write to the local database first, and then write to the remote database, or vice-versa). In either instance, the application considers I\/O completion to occur only after both local and remote databases have completed their writes.","In the dual write approach, transaction steps or operations are mirrored one step or operation at a time. This approach adds a significant amount of time to the mirroring process since the software must wait for I\/O completion for each transaction step or operation. Also, in the dual write approach, as well as mirroring in general, the two databases are always in a known state because a commit is required, often implemented via a two-phase commit, on both databases to complete the write process for a transaction (e.g., to free database locks.)","One preferred embodiment of the present invention queues and blocks transaction steps or operations in the same manner as described above in section L. The application then sends the blocks to the remote database as blocks. A synchronous replication process is used in conjunction with the mirroring.","More specifically, dual writes are performed in a database replication system that includes a local application which receives transactions, a local database associated with the local application process, and a remote database. Each transaction is defined by one or more transaction steps or transaction operations. The following steps occur in the broadest embodiment of the process:","1. A plurality of transaction steps or transaction operations are queued at the local application.","2. A block of queued transaction steps or transaction operations are sent to the remote database for posting thereto.","3. Steps 1 and 2 are repeated for additional blocks of transaction steps or transaction operations collected at the local application.","4. A commit operation is inhibited at either the local database or the remote database until it can be ensured that the source database and the target database can both be successfully updated with the transaction data. In this manner, the transactions are replicated using a synchronous replication mode.","The synchronous replication mode preferably uses the RTC token scheme described above. However, the synchronous replication mode may alternatively use a conventional two-phase commit process. If the RTC token scheme is used, the following steps occur:","1. Pause each transaction being executed in the remote database prior to a commit operation for the transaction.","2. Assign a ready to commit token to the transaction.","3. Send the ready to commit token to the remote database.","4. Determine at the remote database whether the remote database is prepared for a commit operation for the transaction corresponding to the ready to commit token, and, if so, send back the ready to commit token to the local application.","5. Execute a commit operation at the local database only upon receipt from the remote database of the ready to commit token originally sent by the local application. As described in the detailed examples above, the commit operation may occur at the local database first and then at the remote database. Alternatively, the commit operation may occur at the remote database first and then at the local database. That is, if it is determined at the remote database that it is prepared for a commit operation for the transaction corresponding to the ready to commit token, then the transaction may be committed at the remote database before it is committed at the local database.","P. Switching Between Synchronous and Asynchronous Replication Modes","Data replication systems are normally set to operate in either a synchronous or asynchronous replication mode. Synchronous systems are prone to failure due to a disruption in communication between nodes. Accordingly, a synchronous system may be programmed to automatically revert to an asynchronous system if such a failure is detected. For example, the VERITAS Volume Replicator (VVR) 3.2 data replication tool, available from Veritas Software Corporation, Mountain View, Calif., provides unidirectional replication of individual transaction steps or operations from the node on which an application is running (the Primary), to a remote node (the Secondary). VVR replicates in asynchronous and synchronous modes. Typically, the user selects one of the two modes. However, the synchronous replication mode can be configured in a \u201csoft synchronous\u201d mode which enables the user to specify what action is taken when the Secondary is unreachable. Soft synchronous converts to asynchronous during a temporary outage. If configured for soft synchronous mode, after the outage passes and the Secondary catches up with Primary (assuming that there is a surge in the write rate which causes a queue to build up at the Primary), replication reverts to synchronous. In a system that has this switching capability, the process for determining if a synchronous mode is properly functioning and for determining when to switch back from an asynchronous mode to a synchronous mode can be very complex. Additionally, when VVR is in synchronous mode, the source application is held up at every I\/O operation until the I\/O operation is applied into the target database, which can dramatically affect source application response rates.","One preferred embodiment of the present invention provides a queue inspection scheme for determining if a synchronous mode is properly functioning. This scheme is illustrated with an example having an originating node with a source database and another node having a target database. Each node has a replication engine and a queue of transactions that were posted to the database at the respective node. The replication engine at each node synchronizes the database at the originating node to the target database at the other node by sending the transactions in the queue to the target database. If the queue at the originating node is not draining, or is draining \u201ctoo slowly\u201d (i.e., replication latency is above a threshold) then it is presumed that synchronization between the source database at the originating node and the target database at the other node cannot be ensured. The system then reverts to an asynchronous replication mode. In one preferred scheme, the queue of transactions are developed from audit trail entries at the respective node.","Another preferred embodiment of the present invention presumes that synchronous replication cannot be ensured if the replication engine at the originating node is not properly functioning, e.g., if RTC tokens cannot flow between the systems.","Yet another preferred embodiment of the present invention determines when to switch back from an asynchronous mode to a synchronous mode. More specifically, a process is provided to determine when to restore a synchronous replication mode in a unidirectional or bidirectional replication system which replicates data associated with a plurality of transactions. The system includes a plurality of nodes connected via communication media in a topology. Each node includes a database. The system normally operates in a synchronous replication mode, but switches to an asynchronous replication mode when synchronization between a database at an originating node and a database at one or more of the other nodes cannot be ensured. Switching from a synchronous replication mode to an asynchronous replication mode need only occur on those connections where synchronization between a database at an originating node and a database at one or more of the other nodes cannot be ensured. If synchronization between a database at an originating node and a database at one or more of the other nodes can be ensured, the system can remain in synchronous replication mode with that set of node(s).","The following steps occur in the broadest embodiment of the process:","1. Detect replication latency.","2. Restore the synchronous replication mode when synchronization between a database at an originating node and a database at one or more of the other nodes can be ensured again (e.g., the replication queues are draining at an acceptable rate and RTC tokens can flow in both directions between the two systems), and replication latency becomes less than a predetermined time value.","During the synchronous replication mode, the RTC token scheme described above may be used, or a conventional two-phase commit may be used. If the RTC token scheme is used, then token latency may be used to decide when to restore synchronous replication. Token latency is the time it takes for a newly generated RTC token to travel from the end of a transaction queue at the originating node to the beginning of a replay queue at one of the other nodes. The synchronous replication mode may be restored when it is detected that synchronous replication can be ensured again and token latency becomes less than a predetermined time value.","Another preferred embodiment of the present invention addresses collisions when all or some of the nodes of a bidirectional replication system temporarily switch from synchronous replication to asynchronous replication and subsequently switch back. When the system is switched to the asynchronous mode, collisions may occur among queued transactions. To address this issue, the following steps are performed upon detection that the synchronous replication mode may be restored:","1. Send the queued transactions that do not cause any collision to the other nodes in their order of occurrence. For example, transactions that caused collisions can be identified by comparing a unique record indicia (such as a unique primary key) across the nodes; those that were updated on multiple nodes during the asynchronous period have collided.","2. Resolve any collisions in the remaining queued transactions and send the resolved transactions to the respective nodes. For example, the following techniques can be used:\n\n","3. After completing steps 2 and 3, switch back from the asynchronous mode to the synchronous mode.","In an alternative embodiment, when the system is switched to the asynchronous mode, collisions can be avoided by switching all inputs to one of the nodes. Additionally, in the case where there are more than two nodes, and all nodes are synchronously replicating, if replication to one or more of the nodes is converted to asynchronous, collisions can be avoided by switching all inputs from the asynchronous nodes to one or more of the synchronous nodes.","Q. Routing of Inputs after Switching from a Synchronous to an Asynchronous Replication Mode","Another preferred embodiment of the present invention provides a process for routing transaction inputs in a bidirectional replication system which replicates data associated with a plurality of transactions. The system includes a plurality of nodes connected via communication media in a topology. Each node includes a database. The system normally operates in a synchronous replication mode, but switches to an asynchronous replication mode when synchronization between a database at an originating node and a database at one or more of the other nodes cannot be ensured. The following steps occur in the broadest embodiment of the process:","1. Select a winning node upon switching to an asynchronous replication mode. This node can be selected based on many criteria, including processing or database capacity, communication bandwidth capacity, location, etc.","2. Abort any transactions that were in progress on the non-winning node(s), as well as those in progress on the winning node that did not originate on the winning node.","3. Route all transaction inputs at the other nodes to the winning node during the time period of asynchronous replication, including those that were aborted in the step above.","Since the inputs are now directed to a specific winning node, advantages to this embodiment include avoiding data collisions between the nodes. Hence, the recovery steps to restore synchronous replication between the nodes (once synchronous replication can be restored) are simpler and can be achieved faster as no data collisions need to be checked for or resolved.","In another embodiment of the present invention, upon detection that synchronization between the database at the originating node and the database at one or more of the other nodes cannot be ensured, routing all subsequent transactions at the originating node to one of the other nodes.","In an alternative embodiment of this scheme, when more than two nodes are involved, only those nodes that cannot ensure synchronous replication switch to asynchronous replication. The inputs assigned to these asynchronous nodes are reassigned to other nodes that are still performing synchronous replication. In a specific example with three nodes (A, B, and C), all interconnected, receiving inputs, and performing synchronous replication, if node B cannot ensure synchronous replication with nodes A and C, node B's inputs are reassigned to nodes A and C, and replication from A to B and node C to B becomes asynchronous.","Replication between nodes A and C remains synchronous. Later, once replication to node B can be restored to synchronous, nodes A and C will resume synchronous replication to it, and inputs could be reassigned to it.","In another alternative embodiment of this scheme, upon detection that synchronization between the database at the originating node and the database at one or more of the other nodes cannot be ensured, one can either leave the transaction node assignments the same, or re-partitioning them to more fully utilize the processing capacity of each and switch to asynchronous replication. The major disadvantage of this approach is that data collisions can occur. However, these collisions may not be a problem for this application, and\/or may not be hard or troublesome to resolve once synchronous replication can be restored. The major advantage to this approach is that the system retains full processing capacity\/application scaling as all nodes are still receiving and processing inputs, and system availability remains high.","R. Routing of Inputs of After Switching from an Asynchronous to a Synchronous Replication Mode","Another preferred embodiment of the present invention provides a process for routing transaction inputs in a bidirectional replication system which replicates data associated with a plurality of transactions. The system includes a plurality of nodes connected via communication media in a topology. Each node includes a database. The system normally operates in a synchronous replication mode, but switches to an asynchronous replication mode when synchronization between a database at an originating node and a database at one or more of the other nodes cannot be ensured. Upon returning to a synchronous replication mode, the following steps occur in the broadest embodiment of the process:","1. If transaction initiations had been disallowed on the node(s), re-allow transaction initiations.","2. Partition the inputs across the node(s) based on many criteria, including processing or database capacity, communication bandwidth capacity, location, etc.","If the inputs are directed to a single node, data collisions are avoided. If the inputs are directed to more than one node, data collisions are still avoided because of the definition of synchronous replication. An additional benefit to re-partitioning the inputs is that the aggregate processing capacity of the system increases, i.e., the application can scale across the additional nodes. It also increases the availability of the entire system by increasing the number of available nodes with a complete copy of the database on them.","In an alternative embodiment of this scheme, when more than two nodes are involved, only those nodes that can ensure synchronous replication switch to synchronous replication and can start receiving inputs. Other nodes that cannot ensure synchronous replication remain using asynchronous replication. This has the advantage of avoiding data collisions.","S. Inhibit a \u201cFirst I\/O Operation\u201d (e.g., \u201cBegin\u201d) Until Databases are Synchronized","After system startup, and at the initiation of a transaction, the first I\/O operation is typically a BEGIN step.","By managing the initiating of transactions at system startup, one can make sure that all of the other nodes (or some of the other nodes) are ready for replication processing, i.e., they do not have queues of unreplicated transactions waiting to be sent to the other nodes.","While the transaction is held up, the system can resolve any data in the transaction queues (as this may be present if the last state was using asynchronous replication and collisions may need to be resolved as described in other sections of the present specification, and get the databases at each node to match one another). If this step cannot be completed for a node, that node can be marked as \u201cunavailable\u201d, with replication traffic being set to asynchronous to that node.","After resolving collisions in the multiple copies of the database, and draining the replication queues, the system can determine if synchronous replication is functioning properly to each node. If it is functioning properly, and synchronous replication can be ensured, all nodes allow the transactions to proceed, and the nodes use synchronous replication. If it is not functioning properly, the nodes determine which connections\/nodes are not functioning properly, and use asynchronous replication to those nodes, and use synchronous replication to the remaining nodes.","Another preferred embodiment of the present invention replicates data associated with a plurality of transactions in a replication system including a plurality of nodes connected via communication media in a topology. Each node includes a database. The following steps occur in the broadest embodiment of the process:","1. Replicate the data from an originating node to one or more other nodes. Each transaction is one or more transaction steps or transaction operations.","2. Pause each transaction that is requested to be executed in the database at an originating node prior to a first I\/O operation, such as a BEGIN transaction step, for the transaction upon detection that synchronization between the database at the originating node and the database at one or more of the other nodes cannot be ensured. The first I\/O operation may be a begin operation.","Any suitable technique may be used to determine if synchronization between the database at the originating node and the database at one or more of the other nodes cannot be ensured. Some examples include:","1. The queue at any of the nodes is not draining, or is draining slower than a predetermined time period.","2. The replication engine is not properly functioning.","3. The databases become inaccessible to the replication engine for an extended period.","4. The nodes cannot communicate or cannot exchange RTC tokens.","Either synchronous replication or asynchronous replication may be used with this scheme. However, synchronous replication is preferred.","More specifically, the following sequence can be used for restarting the system after an outage of one or more of the nodes when the system wants to reattain synchronous replication between the nodes:\n\n","A similar case exists when re-adding a node that is currently receiving asynchronous replication feed into the system of nodes (which could be just one so far) that are currently using synchronous replication. In this case, it must be determined if synchronous replication to this node can be ensured (see explanations above). Then, one needs to resolve any data collisions (note that if the node receiving the async replication was not processing inputs, then none could have occurred). A method to reintegrate this async node is as follows:\n\n","During this sequence, the sync node kept receiving and processing inputs.","Depending on the implementation, in step a, one can also inhibit the first I\/O operation (thereby suspending the transaction initiations) on the sync node, and then re-allow them to proceed in step d.","T. Bring New Node Online","Another preferred embodiment of the present invention provides a method for adding another node, or replacing a failed node, while the entire system remains active (able to process inputs). An advantage of this method is that the existing nodes in the system remain on-line processing inputs as the new node is brought on-line, synchronized with the database, and eventually starts to receive inputs directly, thereby increasing the overall processing bandwidth and availability\/disaster tolerance of the entire system. While the new node is brought on-line, data collisions are avoided in the new node's database as it is built.","The node to be added is assumed to need an initial database load (to populate all of the database files\/tables with an initial copy of the data).","The steps to re-add this node into the system are as follows:","1. Pick a node in the existing system to extract the load data from, called the source node (the source node will also provide the asynchronous replication feed to the new node prior to the cut-over to synchronous replication for the new node).","2. Do not allow transaction initiation on the target (disallow BEGINs). This is optional if the new node is not receiving inputs.","3. Perform an initial load of the source database into the target node's database. Some techniques include:\n\n","4. Next, turn on unidirectional asynchronous replication from the source node to the target node. If the load step did not capture and data changes being made to the source database while the load was being performed, send that DB change transactional data first (BACKUP\/RESTORE and On-line COPY\/DUPLICATION typically require this resync step, the On-line loading approach does not). In contrast, U.S. Pat. No. 5,884,328 (Mosher) describes a technique for BACKUP\/RESTORE style loading, followed by applying the suspended DB delta information to \u201ccatch up\u201d.","5. Determine when it is a \u201cgood time\u201d to restart synchronous replication mode between the source and target nodes (as defined in other sections of this document), and convert the source's replication mode to the target node to synchronous (from asynchronous).","6. Allow transaction initiation on the target (e.g., allow BEGINs) if it was disabled above.","7. (Optionally) Split the application feed to include the target system.","U. Virtual Token\/Physical Token Processing","\u201cVirtual tokens\u201d, sometimes referred to as \u201clogical tokens\u201d or \u201clogical markers\u201d, can be contrasted with \u201cphysical tokens\u201d, sometimes referred to as \u201cphysical markers\u201d, in several significant ways. All of the previously described \u201cphysical RTC token\u201d schemes that describe an RTC token\/marker may be modified to use virtual RTC tokens\/markers.","A physical marker represents a data item, object, event, signal, call-back, interrupt, or other notification that flows through the system at a specific point in the processing stream, whereas a virtual marker merely represents a point in the processing stream where the marker logically exists. For a virtual marker, nothing actually flows or takes up space in the processing stream. Rather, it is the location in the processing stream where this token would exist that is important.","A significant feature of either marker type is that they both can be ignored, and the replication process can still proceed successfully, as long as the target database replays the transaction steps or operations in the order they occurred in the source. Independent I\/O's, i.e., those that do not affect the same row data, can be replayed in any order provided the transaction boundary is preserved. As long as no errors or timeouts (e.g., on another transaction's locks) occur when the target replays the replication events, the source can apply the commit and continue. If any such error or timeout were to occur, the target would alert the source of the condition and the source could abort (or backout) the transaction.","V. Token \u201cPiggybacking\u201d and Delivery","The path that tokens take to arrive in the target can be via many routes. The preferred embodiment of the present invention sends them via the audit trail, interspersed at the appropriate point with transaction steps or operations. These tokens can be \u201cpiggybacked\u201d onto the last transaction step or operation for their transaction, as well as onto a transaction step or operation for any other transaction. Piggybacking is one preferred scheme in extensive multi-threaded transaction processing environments.","Another route can be via another \u201cdedicated\u201d path between the source and target replication components. In this technique, the token contains sufficient information to identify where in the audit trail or processing stream path it should be logically or physically inserted. The token is then sent, to the target replication component such as in a block with other tokens.","W. Data Input Routing After Failure","Inputs, or transactional steps or operations, will typically be sent from an input device to a single node for execution. This node may be arbitrarily assigned, or assigned based on some node characteristics, such as location or processing capacity. Typically, if the connection between the input device and the node ceases to operate satisfactorily, the input device will abort the transaction and retry the sequence when the connection is restored, or will abort the transaction and retry the sequence to a new node.","In an alternative embodiment of the present invention, when replication is being used to keep two or more nodes synchronized, upon failure of the connection between the input device and a original node in this system, the input device could route the remaining transaction steps or operations to an alternate node. When this alternate node receives the initial transaction steps or operations via the replication channel from the original node, it could append these additional steps or operations to complete the original transaction. As long as these additional steps or operations are replicated back to the original node, the original node will also be able to complete the original transaction.","In both cases, after a failure of a communication channel between the input device and a node, by re-routing the remaining input device's transaction steps or operations to a new node in the system, the original transaction can be completed without aborting and retransmitting the entire transaction again.","The present invention may be implemented with any combination of hardware and software. If implemented as a computer-implemented apparatus, the present invention is implemented using means for performing all of the steps and functions described above.","The present invention can be included in an article of manufacture (e.g., one or more computer program products) having, for instance, computer useable media. The media has embodied therein, for instance, computer readable program code means for providing and facilitating the mechanisms of the present invention. The article of manufacture can be included as part of a computer system or sold separately.","Changes can be made to the embodiments described above without departing from the broad inventive concept thereof. The present invention is thus not limited to the particular embodiments disclosed, but is intended to cover modifications within the spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments of the invention, will be better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings an embodiment that is presently preferred. It should be understood, however, that the invention is not limited to the precise arrangements and instrumentalities shown. In the drawings:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIGS. 2A and 2B"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 4","FIG. 2A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIGS. 5A","FIGS. 2A and 2B"],"b":["5","6","6","7","7","5","5","6","6","7","7"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
